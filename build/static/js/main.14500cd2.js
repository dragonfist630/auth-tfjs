/*! For license information please see main.14500cd2.js.LICENSE.txt */
(()=>{var e={7291:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=7291,e.exports=t},3803:(e,t,n)=>{"use strict";n.d(t,{A:()=>ae});var r=function(){function e(e){var t=this;this._insertTag=function(e){var n;n=0===t.tags.length?t.insertionPoint?t.insertionPoint.nextSibling:t.prepend?t.container.firstChild:t.before:t.tags[t.tags.length-1].nextSibling,t.container.insertBefore(e,n),t.tags.push(e)},this.isSpeedy=void 0===e.speedy||e.speedy,this.tags=[],this.ctr=0,this.nonce=e.nonce,this.key=e.key,this.container=e.container,this.prepend=e.prepend,this.insertionPoint=e.insertionPoint,this.before=null}var t=e.prototype;return t.hydrate=function(e){e.forEach(this._insertTag)},t.insert=function(e){this.ctr%(this.isSpeedy?65e3:1)===0&&this._insertTag(function(e){var t=document.createElement("style");return t.setAttribute("data-emotion",e.key),void 0!==e.nonce&&t.setAttribute("nonce",e.nonce),t.appendChild(document.createTextNode("")),t.setAttribute("data-s",""),t}(this));var t=this.tags[this.tags.length-1];if(this.isSpeedy){var n=function(e){if(e.sheet)return e.sheet;for(var t=0;t<document.styleSheets.length;t++)if(document.styleSheets[t].ownerNode===e)return document.styleSheets[t]}(t);try{n.insertRule(e,n.cssRules.length)}catch(r){}}else t.appendChild(document.createTextNode(e));this.ctr++},t.flush=function(){this.tags.forEach((function(e){var t;return null==(t=e.parentNode)?void 0:t.removeChild(e)})),this.tags=[],this.ctr=0},e}(),a=Math.abs,s=String.fromCharCode,i=Object.assign;function o(e){return e.trim()}function l(e,t,n){return e.replace(t,n)}function u(e,t){return e.indexOf(t)}function c(e,t){return 0|e.charCodeAt(t)}function d(e,t,n){return e.slice(t,n)}function h(e){return e.length}function p(e){return e.length}function f(e,t){return t.push(e),e}var m=1,g=1,y=0,b=0,v=0,x="";function w(e,t,n,r,a,s,i){return{value:e,root:t,parent:n,type:r,props:a,children:s,line:m,column:g,length:i,return:""}}function k(e,t){return i(w("",null,null,"",null,null,0),e,{length:-e.length},t)}function S(){return v=b>0?c(x,--b):0,g--,10===v&&(g=1,m--),v}function I(){return v=b<y?c(x,b++):0,g++,10===v&&(g=1,m++),v}function C(){return c(x,b)}function N(){return b}function T(e,t){return d(x,e,t)}function E(e){switch(e){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function A(e){return m=g=1,y=h(x=e),b=0,[]}function _(e){return x="",e}function $(e){return o(T(b-1,M(91===e?e+2:40===e?e+1:e)))}function R(e){for(;(v=C())&&v<33;)I();return E(e)>2||E(v)>3?"":" "}function D(e,t){for(;--t&&I()&&!(v<48||v>102||v>57&&v<65||v>70&&v<97););return T(e,N()+(t<6&&32==C()&&32==I()))}function M(e){for(;I();)switch(v){case e:return b;case 34:case 39:34!==e&&39!==e&&M(v);break;case 40:41===e&&M(e);break;case 92:I()}return b}function F(e,t){for(;I()&&e+v!==57&&(e+v!==84||47!==C()););return"/*"+T(t,b-1)+"*"+s(47===e?e:I())}function O(e){for(;!E(C());)I();return T(e,b)}var P="-ms-",L="-moz-",z="-webkit-",B="comm",W="rule",V="decl",U="@keyframes";function j(e,t){for(var n="",r=p(e),a=0;a<r;a++)n+=t(e[a],a,e,t)||"";return n}function G(e,t,n,r){switch(e.type){case"@layer":if(e.children.length)break;case"@import":case V:return e.return=e.return||e.value;case B:return"";case U:return e.return=e.value+"{"+j(e.children,r)+"}";case W:e.value=e.props.join(",")}return h(n=j(e.children,r))?e.return=e.value+"{"+n+"}":""}function H(e){return _(q("",null,null,null,[""],e=A(e),0,[0],e))}function q(e,t,n,r,a,i,o,d,p){for(var m=0,g=0,y=o,b=0,v=0,x=0,w=1,k=1,T=1,E=0,A="",_=a,M=i,P=r,L=A;k;)switch(x=E,E=I()){case 40:if(108!=x&&58==c(L,y-1)){-1!=u(L+=l($(E),"&","&\f"),"&\f")&&(T=-1);break}case 34:case 39:case 91:L+=$(E);break;case 9:case 10:case 13:case 32:L+=R(x);break;case 92:L+=D(N()-1,7);continue;case 47:switch(C()){case 42:case 47:f(X(F(I(),N()),t,n),p);break;default:L+="/"}break;case 123*w:d[m++]=h(L)*T;case 125*w:case 59:case 0:switch(E){case 0:case 125:k=0;case 59+g:-1==T&&(L=l(L,/\f/g,"")),v>0&&h(L)-y&&f(v>32?Y(L+";",r,n,y-1):Y(l(L," ","")+";",r,n,y-2),p);break;case 59:L+=";";default:if(f(P=K(L,t,n,m,g,a,d,A,_=[],M=[],y),i),123===E)if(0===g)q(L,t,P,P,_,i,y,d,M);else switch(99===b&&110===c(L,3)?100:b){case 100:case 108:case 109:case 115:q(e,P,P,r&&f(K(e,P,P,0,0,a,d,A,a,_=[],y),M),a,M,y,d,r?_:M);break;default:q(L,P,P,P,[""],M,0,d,M)}}m=g=v=0,w=T=1,A=L="",y=o;break;case 58:y=1+h(L),v=x;default:if(w<1)if(123==E)--w;else if(125==E&&0==w++&&125==S())continue;switch(L+=s(E),E*w){case 38:T=g>0?1:(L+="\f",-1);break;case 44:d[m++]=(h(L)-1)*T,T=1;break;case 64:45===C()&&(L+=$(I())),b=C(),g=y=h(A=L+=O(N())),E++;break;case 45:45===x&&2==h(L)&&(w=0)}}return i}function K(e,t,n,r,s,i,u,c,h,f,m){for(var g=s-1,y=0===s?i:[""],b=p(y),v=0,x=0,k=0;v<r;++v)for(var S=0,I=d(e,g+1,g=a(x=u[v])),C=e;S<b;++S)(C=o(x>0?y[S]+" "+I:l(I,/&\f/g,y[S])))&&(h[k++]=C);return w(e,t,n,0===s?W:c,h,f,m)}function X(e,t,n){return w(e,t,n,B,s(v),d(e,2,-2),0)}function Y(e,t,n,r){return w(e,t,n,V,d(e,0,r),d(e,r+1,-1),r)}var Q=function(e,t,n){for(var r=0,a=0;r=a,a=C(),38===r&&12===a&&(t[n]=1),!E(a);)I();return T(e,b)},J=function(e,t){return _(function(e,t){var n=-1,r=44;do{switch(E(r)){case 0:38===r&&12===C()&&(t[n]=1),e[n]+=Q(b-1,t,n);break;case 2:e[n]+=$(r);break;case 4:if(44===r){e[++n]=58===C()?"&\f":"",t[n]=e[n].length;break}default:e[n]+=s(r)}}while(r=I());return e}(A(e),t))},Z=new WeakMap,ee=function(e){if("rule"===e.type&&e.parent&&!(e.length<1)){for(var t=e.value,n=e.parent,r=e.column===n.column&&e.line===n.line;"rule"!==n.type;)if(!(n=n.parent))return;if((1!==e.props.length||58===t.charCodeAt(0)||Z.get(n))&&!r){Z.set(e,!0);for(var a=[],s=J(t,a),i=n.props,o=0,l=0;o<s.length;o++)for(var u=0;u<i.length;u++,l++)e.props[l]=a[o]?s[o].replace(/&\f/g,i[u]):i[u]+" "+s[o]}}},te=function(e){if("decl"===e.type){var t=e.value;108===t.charCodeAt(0)&&98===t.charCodeAt(2)&&(e.return="",e.value="")}};function ne(e,t){switch(function(e,t){return 45^c(e,0)?(((t<<2^c(e,0))<<2^c(e,1))<<2^c(e,2))<<2^c(e,3):0}(e,t)){case 5103:return z+"print-"+e+e;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return z+e+e;case 5349:case 4246:case 4810:case 6968:case 2756:return z+e+L+e+P+e+e;case 6828:case 4268:return z+e+P+e+e;case 6165:return z+e+P+"flex-"+e+e;case 5187:return z+e+l(e,/(\w+).+(:[^]+)/,z+"box-$1$2"+P+"flex-$1$2")+e;case 5443:return z+e+P+"flex-item-"+l(e,/flex-|-self/,"")+e;case 4675:return z+e+P+"flex-line-pack"+l(e,/align-content|flex-|-self/,"")+e;case 5548:return z+e+P+l(e,"shrink","negative")+e;case 5292:return z+e+P+l(e,"basis","preferred-size")+e;case 6060:return z+"box-"+l(e,"-grow","")+z+e+P+l(e,"grow","positive")+e;case 4554:return z+l(e,/([^-])(transform)/g,"$1"+z+"$2")+e;case 6187:return l(l(l(e,/(zoom-|grab)/,z+"$1"),/(image-set)/,z+"$1"),e,"")+e;case 5495:case 3959:return l(e,/(image-set\([^]*)/,z+"$1$`$1");case 4968:return l(l(e,/(.+:)(flex-)?(.*)/,z+"box-pack:$3"+P+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+z+e+e;case 4095:case 3583:case 4068:case 2532:return l(e,/(.+)-inline(.+)/,z+"$1$2")+e;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(h(e)-1-t>6)switch(c(e,t+1)){case 109:if(45!==c(e,t+4))break;case 102:return l(e,/(.+:)(.+)-([^]+)/,"$1"+z+"$2-$3$1"+L+(108==c(e,t+3)?"$3":"$2-$3"))+e;case 115:return~u(e,"stretch")?ne(l(e,"stretch","fill-available"),t)+e:e}break;case 4949:if(115!==c(e,t+1))break;case 6444:switch(c(e,h(e)-3-(~u(e,"!important")&&10))){case 107:return l(e,":",":"+z)+e;case 101:return l(e,/(.+:)([^;!]+)(;|!.+)?/,"$1"+z+(45===c(e,14)?"inline-":"")+"box$3$1"+z+"$2$3$1"+P+"$2box$3")+e}break;case 5936:switch(c(e,t+11)){case 114:return z+e+P+l(e,/[svh]\w+-[tblr]{2}/,"tb")+e;case 108:return z+e+P+l(e,/[svh]\w+-[tblr]{2}/,"tb-rl")+e;case 45:return z+e+P+l(e,/[svh]\w+-[tblr]{2}/,"lr")+e}return z+e+P+e+e}return e}var re=[function(e,t,n,r){if(e.length>-1&&!e.return)switch(e.type){case V:e.return=ne(e.value,e.length);break;case U:return j([k(e,{value:l(e.value,"@","@"+z)})],r);case W:if(e.length)return function(e,t){return e.map(t).join("")}(e.props,(function(t){switch(function(e,t){return(e=t.exec(e))?e[0]:e}(t,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return j([k(e,{props:[l(t,/:(read-\w+)/,":-moz-$1")]})],r);case"::placeholder":return j([k(e,{props:[l(t,/:(plac\w+)/,":"+z+"input-$1")]}),k(e,{props:[l(t,/:(plac\w+)/,":-moz-$1")]}),k(e,{props:[l(t,/:(plac\w+)/,P+"input-$1")]})],r)}return""}))}}],ae=function(e){var t=e.key;if("css"===t){var n=document.querySelectorAll("style[data-emotion]:not([data-s])");Array.prototype.forEach.call(n,(function(e){-1!==e.getAttribute("data-emotion").indexOf(" ")&&(document.head.appendChild(e),e.setAttribute("data-s",""))}))}var a,s,i=e.stylisPlugins||re,o={},l=[];a=e.container||document.head,Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="'+t+' "]'),(function(e){for(var t=e.getAttribute("data-emotion").split(" "),n=1;n<t.length;n++)o[t[n]]=!0;l.push(e)}));var u,c,d=[G,(c=function(e){u.insert(e)},function(e){e.root||(e=e.return)&&c(e)})],h=function(e){var t=p(e);return function(n,r,a,s){for(var i="",o=0;o<t;o++)i+=e[o](n,r,a,s)||"";return i}}([ee,te].concat(i,d));s=function(e,t,n,r){u=n,j(H(e?e+"{"+t.styles+"}":t.styles),h),r&&(f.inserted[t.name]=!0)};var f={key:t,sheet:new r({key:t,container:a,nonce:e.nonce,speedy:e.speedy,prepend:e.prepend,insertionPoint:e.insertionPoint}),nonce:e.nonce,inserted:o,registered:{},insert:s};return f.sheet.hydrate(l),f}},918:(e,t,n)=>{"use strict";function r(e){var t=Object.create(null);return function(n){return void 0===t[n]&&(t[n]=e(n)),t[n]}}n.d(t,{A:()=>r})},4575:(e,t,n)=>{"use strict";n.d(t,{T:()=>o,w:()=>i});var r=n(5043),a=n(3803),s=(n(6598),n(9436),r.createContext("undefined"!==typeof HTMLElement?(0,a.A)({key:"css"}):null)),i=(s.Provider,function(e){return(0,r.forwardRef)((function(t,n){var a=(0,r.useContext)(s);return e(t,a,n)}))}),o=r.createContext({})},6598:(e,t,n)=>{"use strict";n.d(t,{J:()=>g});var r={animationIterationCount:1,aspectRatio:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,scale:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},a=n(918),s=!1,i=/[A-Z]|^ms/g,o=/_EMO_([^_]+?)_([^]*?)_EMO_/g,l=function(e){return 45===e.charCodeAt(1)},u=function(e){return null!=e&&"boolean"!==typeof e},c=(0,a.A)((function(e){return l(e)?e:e.replace(i,"-$&").toLowerCase()})),d=function(e,t){switch(e){case"animation":case"animationName":if("string"===typeof t)return t.replace(o,(function(e,t,n){return f={name:t,styles:n,next:f},t}))}return 1===r[e]||l(e)||"number"!==typeof t||0===t?t:t+"px"},h="Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";function p(e,t,n){if(null==n)return"";var r=n;if(void 0!==r.__emotion_styles)return r;switch(typeof n){case"boolean":return"";case"object":var a=n;if(1===a.anim)return f={name:a.name,styles:a.styles,next:f},a.name;var i=n;if(void 0!==i.styles){var o=i.next;if(void 0!==o)for(;void 0!==o;)f={name:o.name,styles:o.styles,next:f},o=o.next;return i.styles+";"}return function(e,t,n){var r="";if(Array.isArray(n))for(var a=0;a<n.length;a++)r+=p(e,t,n[a])+";";else for(var i in n){var o=n[i];if("object"!==typeof o){var l=o;null!=t&&void 0!==t[l]?r+=i+"{"+t[l]+"}":u(l)&&(r+=c(i)+":"+d(i,l)+";")}else{if("NO_COMPONENT_SELECTOR"===i&&s)throw new Error(h);if(!Array.isArray(o)||"string"!==typeof o[0]||null!=t&&void 0!==t[o[0]]){var f=p(e,t,o);switch(i){case"animation":case"animationName":r+=c(i)+":"+f+";";break;default:r+=i+"{"+f+"}"}}else for(var m=0;m<o.length;m++)u(o[m])&&(r+=c(i)+":"+d(i,o[m])+";")}}return r}(e,t,n);case"function":if(void 0!==e){var l=f,m=n(e);return f=l,p(e,t,m)}}var g=n;if(null==t)return g;var y=t[g];return void 0!==y?y:g}var f,m=/label:\s*([^\s;\n{]+)\s*(;|$)/g;function g(e,t,n){if(1===e.length&&"object"===typeof e[0]&&null!==e[0]&&void 0!==e[0].styles)return e[0];var r=!0,a="";f=void 0;var s=e[0];null==s||void 0===s.raw?(r=!1,a+=p(n,t,s)):a+=s[0];for(var i=1;i<e.length;i++){if(a+=p(n,t,e[i]),r)a+=s[i]}m.lastIndex=0;for(var o,l="";null!==(o=m.exec(a));)l+="-"+o[1];var u=function(e){for(var t,n=0,r=0,a=e.length;a>=4;++r,a-=4)t=1540483477*(65535&(t=255&e.charCodeAt(r)|(255&e.charCodeAt(++r))<<8|(255&e.charCodeAt(++r))<<16|(255&e.charCodeAt(++r))<<24))+(59797*(t>>>16)<<16),n=1540483477*(65535&(t^=t>>>24))+(59797*(t>>>16)<<16)^1540483477*(65535&n)+(59797*(n>>>16)<<16);switch(a){case 3:n^=(255&e.charCodeAt(r+2))<<16;case 2:n^=(255&e.charCodeAt(r+1))<<8;case 1:n=1540483477*(65535&(n^=255&e.charCodeAt(r)))+(59797*(n>>>16)<<16)}return(((n=1540483477*(65535&(n^=n>>>13))+(59797*(n>>>16)<<16))^n>>>15)>>>0).toString(36)}(a)+l;return{name:u,styles:a,next:f}}},9436:(e,t,n)=>{"use strict";var r;n.d(t,{i:()=>o,s:()=>i});var a=n(5043),s=!!(r||(r=n.t(a,2))).useInsertionEffect&&(r||(r=n.t(a,2))).useInsertionEffect,i=s||function(e){return e()},o=s||a.useLayoutEffect},1722:(e,t,n)=>{"use strict";n.d(t,{Rk:()=>r,SF:()=>a,sk:()=>s});function r(e,t,n){var r="";return n.split(" ").forEach((function(n){void 0!==e[n]?t.push(e[n]+";"):r+=n+" "})),r}var a=function(e,t,n){var r=e.key+"-"+t.name;!1===n&&void 0===e.registered[r]&&(e.registered[r]=t.styles)},s=function(e,t,n){a(e,t,n);var r=e.key+"-"+t.name;if(void 0===e.inserted[t.name]){var s=t;do{e.insert(t===s?"."+r:"",s,e.sheet,!0),s=s.next}while(void 0!==s)}}},4914:(e,t,n)=>{"use strict";var r=n(4994);t.A=void 0;var a=r(n(39)),s=n(579);t.A=(0,a.default)((0,s.jsx)("path",{d:"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"}),"ContentCopy")},7948:(e,t,n)=>{"use strict";var r=n(4994);t.A=void 0;var a=r(n(39)),s=n(579);t.A=(0,a.default)((0,s.jsx)("path",{d:"M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2M12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"}),"ErrorOutline")},3531:(e,t,n)=>{"use strict";var r=n(4994);t.A=void 0;var a=r(n(39)),s=n(579);t.A=(0,a.default)((0,s.jsx)("path",{d:"M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2m0 12H6V10h12z"}),"LockOpen")},39:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return r.createSvgIcon}});var r=n(4421)},8249:(e,t,n)=>{"use strict";n.d(t,{b:()=>o});var r=n(5043),a=n(3030);n(579);const s=r.createContext(void 0);function i(e){let{props:t,name:n}=e;return function(e){const{theme:t,name:n,props:r}=e;if(!t||!t.components||!t.components[n])return r;const s=t.components[n];return s.defaultProps?(0,a.A)(s.defaultProps,r):s.styleOverrides||s.variants?r:(0,a.A)(s,r)}({props:t,name:n,theme:{components:r.useContext(s)}})}function o(e){return i(e)}},5913:(e,t,n)=>{"use strict";n.d(t,{A:()=>ae});var r=n(7868),a=n(9172),s=n(6596);const i={black:"#000",white:"#fff"},o={50:"#fafafa",100:"#f5f5f5",200:"#eeeeee",300:"#e0e0e0",400:"#bdbdbd",500:"#9e9e9e",600:"#757575",700:"#616161",800:"#424242",900:"#212121",A100:"#f5f5f5",A200:"#eeeeee",A400:"#bdbdbd",A700:"#616161"},l={50:"#f3e5f5",100:"#e1bee7",200:"#ce93d8",300:"#ba68c8",400:"#ab47bc",500:"#9c27b0",600:"#8e24aa",700:"#7b1fa2",800:"#6a1b9a",900:"#4a148c",A100:"#ea80fc",A200:"#e040fb",A400:"#d500f9",A700:"#aa00ff"},u={50:"#ffebee",100:"#ffcdd2",200:"#ef9a9a",300:"#e57373",400:"#ef5350",500:"#f44336",600:"#e53935",700:"#d32f2f",800:"#c62828",900:"#b71c1c",A100:"#ff8a80",A200:"#ff5252",A400:"#ff1744",A700:"#d50000"},c={50:"#fff3e0",100:"#ffe0b2",200:"#ffcc80",300:"#ffb74d",400:"#ffa726",500:"#ff9800",600:"#fb8c00",700:"#f57c00",800:"#ef6c00",900:"#e65100",A100:"#ffd180",A200:"#ffab40",A400:"#ff9100",A700:"#ff6d00"},d={50:"#e3f2fd",100:"#bbdefb",200:"#90caf9",300:"#64b5f6",400:"#42a5f5",500:"#2196f3",600:"#1e88e5",700:"#1976d2",800:"#1565c0",900:"#0d47a1",A100:"#82b1ff",A200:"#448aff",A400:"#2979ff",A700:"#2962ff"},h={50:"#e1f5fe",100:"#b3e5fc",200:"#81d4fa",300:"#4fc3f7",400:"#29b6f6",500:"#03a9f4",600:"#039be5",700:"#0288d1",800:"#0277bd",900:"#01579b",A100:"#80d8ff",A200:"#40c4ff",A400:"#00b0ff",A700:"#0091ea"},p={50:"#e8f5e9",100:"#c8e6c9",200:"#a5d6a7",300:"#81c784",400:"#66bb6a",500:"#4caf50",600:"#43a047",700:"#388e3c",800:"#2e7d32",900:"#1b5e20",A100:"#b9f6ca",A200:"#69f0ae",A400:"#00e676",A700:"#00c853"},f={text:{primary:"rgba(0, 0, 0, 0.87)",secondary:"rgba(0, 0, 0, 0.6)",disabled:"rgba(0, 0, 0, 0.38)"},divider:"rgba(0, 0, 0, 0.12)",background:{paper:i.white,default:i.white},action:{active:"rgba(0, 0, 0, 0.54)",hover:"rgba(0, 0, 0, 0.04)",hoverOpacity:.04,selected:"rgba(0, 0, 0, 0.08)",selectedOpacity:.08,disabled:"rgba(0, 0, 0, 0.26)",disabledBackground:"rgba(0, 0, 0, 0.12)",disabledOpacity:.38,focus:"rgba(0, 0, 0, 0.12)",focusOpacity:.12,activatedOpacity:.12}},m={text:{primary:i.white,secondary:"rgba(255, 255, 255, 0.7)",disabled:"rgba(255, 255, 255, 0.5)",icon:"rgba(255, 255, 255, 0.5)"},divider:"rgba(255, 255, 255, 0.12)",background:{paper:"#121212",default:"#121212"},action:{active:i.white,hover:"rgba(255, 255, 255, 0.08)",hoverOpacity:.08,selected:"rgba(255, 255, 255, 0.16)",selectedOpacity:.16,disabled:"rgba(255, 255, 255, 0.3)",disabledBackground:"rgba(255, 255, 255, 0.12)",disabledOpacity:.38,focus:"rgba(255, 255, 255, 0.12)",focusOpacity:.12,activatedOpacity:.24}};function g(e,t,n,r){const a=r.light||r,i=r.dark||1.5*r;e[t]||(e.hasOwnProperty(n)?e[t]=e[n]:"light"===t?e.light=(0,s.a)(e.main,a):"dark"===t&&(e.dark=(0,s.e$)(e.main,i)))}function y(e){const{mode:t="light",contrastThreshold:n=3,tonalOffset:y=.2,...b}=e,v=e.primary||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:d[200],light:d[50],dark:d[400]}:{main:d[700],light:d[400],dark:d[800]}}(t),x=e.secondary||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:l[200],light:l[50],dark:l[400]}:{main:l[500],light:l[300],dark:l[700]}}(t),w=e.error||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:u[500],light:u[300],dark:u[700]}:{main:u[700],light:u[400],dark:u[800]}}(t),k=e.info||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:h[400],light:h[300],dark:h[700]}:{main:h[700],light:h[500],dark:h[900]}}(t),S=e.success||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:p[400],light:p[300],dark:p[700]}:{main:p[800],light:p[500],dark:p[900]}}(t),I=e.warning||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:c[400],light:c[300],dark:c[700]}:{main:"#ed6c02",light:c[500],dark:c[900]}}(t);function C(e){return(0,s.eM)(e,m.text.primary)>=n?m.text.primary:f.text.primary}const N=e=>{let{color:t,name:n,mainShade:a=500,lightShade:s=300,darkShade:i=700}=e;if(t={...t},!t.main&&t[a]&&(t.main=t[a]),!t.hasOwnProperty("main"))throw new Error((0,r.A)(11,n?` (${n})`:"",a));if("string"!==typeof t.main)throw new Error((0,r.A)(12,n?` (${n})`:"",JSON.stringify(t.main)));return g(t,"light",s,y),g(t,"dark",i,y),t.contrastText||(t.contrastText=C(t.main)),t},T={dark:m,light:f};return(0,a.A)({common:{...i},mode:t,primary:N({color:v,name:"primary"}),secondary:N({color:x,name:"secondary",mainShade:"A400",lightShade:"A200",darkShade:"A700"}),error:N({color:w,name:"error"}),warning:N({color:I,name:"warning"}),info:N({color:k,name:"info"}),success:N({color:S,name:"success"}),grey:o,contrastThreshold:n,getContrastText:C,augmentColor:N,tonalOffset:y,...T[t]},b)}function b(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";function t(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];if(!r.length)return"";const s=r[0];return"string"!==typeof s||s.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)?`, ${s}`:`, var(--${e?`${e}-`:""}${s}${t(...r.slice(1))})`}return function(n){for(var r=arguments.length,a=new Array(r>1?r-1:0),s=1;s<r;s++)a[s-1]=arguments[s];return`var(--${e?`${e}-`:""}${n}${t(...a)})`}}var v=n(6160),x=n(883);function w(e){const t={};return Object.entries(e).forEach((e=>{const[n,r]=e;"object"===typeof r&&(t[n]=`${r.fontStyle?`${r.fontStyle} `:""}${r.fontVariant?`${r.fontVariant} `:""}${r.fontWeight?`${r.fontWeight} `:""}${r.fontStretch?`${r.fontStretch} `:""}${r.fontSize||""}${r.lineHeight?`/${r.lineHeight} `:""}${r.fontFamily||""}`)})),t}const k=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=e;t.forEach(((e,s)=>{s===t.length-1?Array.isArray(a)?a[Number(e)]=n:a&&"object"===typeof a&&(a[e]=n):a&&"object"===typeof a&&(a[e]||(a[e]=r.includes(e)?[]:{}),a=a[e])}))},S=(e,t,n)=>{!function e(r){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];Object.entries(r).forEach((r=>{let[i,o]=r;(!n||n&&!n([...a,i]))&&void 0!==o&&null!==o&&("object"===typeof o&&Object.keys(o).length>0?e(o,[...a,i],Array.isArray(o)?[...s,i]:s):t([...a,i],o,s))}))}(e)},I=(e,t)=>{if("number"===typeof t){if(["lineHeight","fontWeight","opacity","zIndex"].some((t=>e.includes(t))))return t;return e[e.length-1].toLowerCase().indexOf("opacity")>=0?t:`${t}px`}return t};function C(e,t){const{prefix:n,shouldSkipGeneratingVar:r}=t||{},a={},s={},i={};return S(e,((e,t,o)=>{if(("string"===typeof t||"number"===typeof t)&&(!r||!r(e,t))){const r=`--${n?`${n}-`:""}${e.join("-")}`,l=I(e,t);Object.assign(a,{[r]:l}),k(s,e,`var(${r})`,o),k(i,e,`var(${r}, ${l})`,o)}}),(e=>"vars"===e[0])),{css:a,vars:s,varsWithDefaults:i}}const N=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{getSelector:n=y,disableCssColorScheme:r,colorSchemeSelector:s}=t,{colorSchemes:i={},components:o,defaultColorScheme:l="light",...u}=e,{vars:c,css:d,varsWithDefaults:h}=C(u,t);let p=h;const f={},{[l]:m,...g}=i;if(Object.entries(g||{}).forEach((e=>{let[n,r]=e;const{vars:s,css:i,varsWithDefaults:o}=C(r,t);p=(0,a.A)(p,o),f[n]={css:i,vars:s}})),m){const{css:e,vars:n,varsWithDefaults:r}=C(m,t);p=(0,a.A)(p,r),f[l]={css:e,vars:n}}function y(t,n){let r=s;if("class"===s&&(r=".%s"),"data"===s&&(r="[data-%s]"),s?.startsWith("data-")&&!s.includes("%s")&&(r=`[${s}="%s"]`),t){if("media"===r){if(e.defaultColorScheme===t)return":root";const r=i[t]?.palette?.mode||t;return{[`@media (prefers-color-scheme: ${r})`]:{":root":n}}}if(r)return e.defaultColorScheme===t?`:root, ${r.replace("%s",String(t))}`:r.replace("%s",String(t))}return":root"}return{vars:p,generateThemeVars:()=>{let e={...c};return Object.entries(f).forEach((t=>{let[,{vars:n}]=t;e=(0,a.A)(e,n)})),e},generateStyleSheets:()=>{const t=[],a=e.defaultColorScheme||"light";function s(e,n){Object.keys(n).length&&t.push("string"===typeof e?{[e]:{...n}}:e)}s(n(void 0,{...d}),d);const{[a]:o,...l}=f;if(o){const{css:e}=o,t=i[a]?.palette?.mode,l=!r&&t?{colorScheme:t,...e}:{...e};s(n(a,{...l}),l)}return Object.entries(l).forEach((e=>{let[t,{css:a}]=e;const o=i[t]?.palette?.mode,l=!r&&o?{colorScheme:o,...a}:{...a};s(n(t,{...l}),l)})),t}}};var T=n(138),E=n(2768),A=n(2390);const _={textTransform:"uppercase"},$='"Roboto", "Helvetica", "Arial", sans-serif';function R(e,t){const{fontFamily:n=$,fontSize:r=14,fontWeightLight:s=300,fontWeightRegular:i=400,fontWeightMedium:o=500,fontWeightBold:l=700,htmlFontSize:u=16,allVariants:c,pxToRem:d,...h}="function"===typeof t?t(e):t;const p=r/14,f=d||(e=>e/u*p+"rem"),m=(e,t,r,a,s)=>{return{fontFamily:n,fontWeight:e,fontSize:f(t),lineHeight:r,...n===$?{letterSpacing:(i=a/t,Math.round(1e5*i)/1e5)+"em"}:{},...s,...c};var i},g={h1:m(s,96,1.167,-1.5),h2:m(s,60,1.2,-.5),h3:m(i,48,1.167,0),h4:m(i,34,1.235,.25),h5:m(i,24,1.334,0),h6:m(o,20,1.6,.15),subtitle1:m(i,16,1.75,.15),subtitle2:m(o,14,1.57,.1),body1:m(i,16,1.5,.15),body2:m(i,14,1.43,.15),button:m(o,14,1.75,.4,_),caption:m(i,12,1.66,.4),overline:m(i,12,2.66,1,_),inherit:{fontFamily:"inherit",fontWeight:"inherit",fontSize:"inherit",lineHeight:"inherit",letterSpacing:"inherit"}};return(0,a.A)({htmlFontSize:u,pxToRem:f,fontFamily:n,fontSize:r,fontWeightLight:s,fontWeightRegular:i,fontWeightMedium:o,fontWeightBold:l,...g},h,{clone:!1})}function D(){return[`${arguments.length<=0?void 0:arguments[0]}px ${arguments.length<=1?void 0:arguments[1]}px ${arguments.length<=2?void 0:arguments[2]}px ${arguments.length<=3?void 0:arguments[3]}px rgba(0,0,0,0.2)`,`${arguments.length<=4?void 0:arguments[4]}px ${arguments.length<=5?void 0:arguments[5]}px ${arguments.length<=6?void 0:arguments[6]}px ${arguments.length<=7?void 0:arguments[7]}px rgba(0,0,0,0.14)`,`${arguments.length<=8?void 0:arguments[8]}px ${arguments.length<=9?void 0:arguments[9]}px ${arguments.length<=10?void 0:arguments[10]}px ${arguments.length<=11?void 0:arguments[11]}px rgba(0,0,0,0.12)`].join(",")}const M=["none",D(0,2,1,-1,0,1,1,0,0,1,3,0),D(0,3,1,-2,0,2,2,0,0,1,5,0),D(0,3,3,-2,0,3,4,0,0,1,8,0),D(0,2,4,-1,0,4,5,0,0,1,10,0),D(0,3,5,-1,0,5,8,0,0,1,14,0),D(0,3,5,-1,0,6,10,0,0,1,18,0),D(0,4,5,-2,0,7,10,1,0,2,16,1),D(0,5,5,-3,0,8,10,1,0,3,14,2),D(0,5,6,-3,0,9,12,1,0,3,16,2),D(0,6,6,-3,0,10,14,1,0,4,18,3),D(0,6,7,-4,0,11,15,1,0,4,20,3),D(0,7,8,-4,0,12,17,2,0,5,22,4),D(0,7,8,-4,0,13,19,2,0,5,24,4),D(0,7,9,-4,0,14,21,2,0,5,26,4),D(0,8,9,-5,0,15,22,2,0,6,28,5),D(0,8,10,-5,0,16,24,2,0,6,30,5),D(0,8,11,-5,0,17,26,2,0,6,32,5),D(0,9,11,-5,0,18,28,2,0,7,34,6),D(0,9,12,-6,0,19,29,2,0,7,36,6),D(0,10,13,-6,0,20,31,3,0,8,38,7),D(0,10,13,-6,0,21,33,3,0,8,40,7),D(0,10,14,-6,0,22,35,3,0,8,42,7),D(0,11,14,-7,0,23,36,3,0,9,44,8),D(0,11,15,-7,0,24,38,3,0,9,46,8)],F={easeInOut:"cubic-bezier(0.4, 0, 0.2, 1)",easeOut:"cubic-bezier(0.0, 0, 0.2, 1)",easeIn:"cubic-bezier(0.4, 0, 1, 1)",sharp:"cubic-bezier(0.4, 0, 0.6, 1)"},O={shortest:150,shorter:200,short:250,standard:300,complex:375,enteringScreen:225,leavingScreen:195};function P(e){return`${Math.round(e)}ms`}function L(e){if(!e)return 0;const t=e/36;return Math.min(Math.round(10*(4+15*t**.25+t/5)),3e3)}function z(e){const t={...F,...e.easing},n={...O,...e.duration};return{getAutoHeightDuration:L,create:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:["all"],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{duration:a=n.standard,easing:s=t.easeInOut,delay:i=0,...o}=r;return(Array.isArray(e)?e:[e]).map((e=>`${e} ${"string"===typeof a?a:P(a)} ${s} ${"string"===typeof i?i:P(i)}`)).join(",")},...e,easing:t,duration:n}}const B={mobileStepper:1e3,fab:1050,speedDial:1050,appBar:1100,drawer:1200,modal:1300,snackbar:1400,tooltip:1500};function W(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{breakpoints:t,mixins:n={},spacing:s,palette:i={},transitions:o={},typography:l={},shape:u,...c}=e;if(e.vars)throw new Error((0,r.A)(20));const d=y(i),h=(0,A.A)(e);let p=(0,a.A)(h,{mixins:(f=h.breakpoints,m=n,{toolbar:{minHeight:56,[f.up("xs")]:{"@media (orientation: landscape)":{minHeight:48}},[f.up("sm")]:{minHeight:64}},...m}),palette:d,shadows:M.slice(),typography:R(d,l),transitions:z(o),zIndex:{...B}});var f,m;p=(0,a.A)(p,c);for(var g=arguments.length,b=new Array(g>1?g-1:0),v=1;v<g;v++)b[v-1]=arguments[v];return p=b.reduce(((e,t)=>(0,a.A)(e,t)),p),p.unstable_sxConfig={...T.A,...c?.unstable_sxConfig},p.unstable_sx=function(e){return(0,E.A)({sx:e,theme:this})},p}const V=W;var U=n(3582);const j=[...Array(25)].map(((e,t)=>{if(0===t)return;const n=(0,U.A)(t);return`linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`}));function G(e){return{inputPlaceholder:"dark"===e?.5:.42,inputUnderline:"dark"===e?.7:.42,switchTrackDisabled:"dark"===e?.2:.12,switchTrack:"dark"===e?.3:.38}}function H(e){return"dark"===e?j:[]}function q(e){return!!e[0].match(/(cssVarPrefix|colorSchemeSelector|typography|mixins|breakpoints|direction|transitions)/)||!!e[0].match(/sxConfig$/)||"palette"===e[0]&&!!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/)}const K=e=>[...[...Array(24)].map(((t,n)=>`--${e?`${e}-`:""}overlays-${n+1}`)),`--${e?`${e}-`:""}palette-AppBar-darkBg`,`--${e?`${e}-`:""}palette-AppBar-darkColor`],X=e=>(t,n)=>{const r=e.colorSchemeSelector;let a=r;if("class"===r&&(a=".%s"),"data"===r&&(a="[data-%s]"),r?.startsWith("data-")&&!r.includes("%s")&&(a=`[${r}="%s"]`),e.defaultColorScheme===t){if("dark"===t){const r={};return K(e.cssVarPrefix).forEach((e=>{r[e]=n[e],delete n[e]})),"media"===a?{":root":n,"@media (prefers-color-scheme: dark)":{":root":r}}:a?{[a.replace("%s",t)]:r,[`:root, ${a.replace("%s",t)}`]:n}:{":root":{...n,...r}}}if(a&&"media"!==a)return`:root, ${a.replace("%s",String(t))}`}else if(t){if("media"===a)return{[`@media (prefers-color-scheme: ${String(t)})`]:{":root":n}};if(a)return a.replace("%s",String(t))}return":root"};function Y(){const e={...arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}};return function e(t){const n=Object.entries(t);for(let s=0;s<n.length;s++){const[i,o]=n[s];r=o,!(0,a.Q)(r)&&"undefined"!==typeof r&&"string"!==typeof r&&"boolean"!==typeof r&&"number"!==typeof r&&!Array.isArray(r)||i.startsWith("unstable_")?delete t[i]:(0,a.Q)(o)&&(t[i]={...o},e(t[i]))}var r}(e),`import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';\n\nconst theme = ${JSON.stringify(e,null,2)};\n\ntheme.breakpoints = createBreakpoints(theme.breakpoints || {});\ntheme.transitions = createTransitions(theme.transitions || {});\n\nexport default theme;`}function Q(e,t,n){!e[t]&&n&&(e[t]=n)}function J(e){return e&&e.startsWith("hsl")?(0,s.YL)(e):e}function Z(e,t){`${t}Channel`in e||(e[`${t}Channel`]=(0,s.Me)(J(e[t]),`MUI: Can't create \`palette.${t}Channel\` because \`palette.${t}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().\nTo suppress this warning, you need to explicitly provide the \`palette.${t}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`))}const ee=e=>{try{return e()}catch(t){}},te=function(){return b(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"mui")};function ne(e,t,n,r){if(!t)return;t=!0===t?{}:t;const a="dark"===r?"dark":"light";if(!n)return void(e[r]=function(e){const{palette:t={mode:"light"},opacity:n,overlays:r,...a}=e,s=y(t);return{palette:s,opacity:{...G(s.mode),...n},overlays:r||H(s.mode),...a}}({...t,palette:{mode:a,...t?.palette}}));const{palette:s,...i}=V({...n,palette:{mode:a,...t?.palette}});return e[r]={...t,palette:s,opacity:{...G(a),...t?.opacity},overlays:t?.overlays||H(a)},i}function re(e,t,n){e.colorSchemes&&n&&(e.colorSchemes[t]={...!0!==n&&n,palette:y({...!0===n?{}:n.palette,mode:t})})}function ae(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{palette:t,cssVariables:n=!1,colorSchemes:i=(t?void 0:{light:!0}),defaultColorScheme:o=t?.mode,...l}=e,u=o||"light",c=i?.[u],d={...i,...t?{[u]:{..."boolean"!==typeof c&&c,palette:t}}:void 0};for(var h=arguments.length,p=new Array(h>1?h-1:0),f=1;f<h;f++)p[f-1]=arguments[f];if(!1===n){if(!("colorSchemes"in e))return V(e,...p);let n=t;"palette"in e||d[u]&&(!0!==d[u]?n=d[u].palette:"dark"===u&&(n={mode:"dark"}));const r=V({...e,palette:n},...p);return r.defaultColorScheme=u,r.colorSchemes=d,"light"===r.palette.mode&&(r.colorSchemes.light={...!0!==d.light&&d.light,palette:r.palette},re(r,"dark",d.dark)),"dark"===r.palette.mode&&(r.colorSchemes.dark={...!0!==d.dark&&d.dark,palette:r.palette},re(r,"light",d.light)),r}return t||"light"in d||"light"!==u||(d.light=!0),function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{colorSchemes:t={light:!0},defaultColorScheme:n,disableCssColorScheme:i=!1,cssVarPrefix:o="mui",shouldSkipGeneratingVar:l=q,colorSchemeSelector:u=(t.light&&t.dark?"media":void 0),...c}=e,d=Object.keys(t)[0],h=n||(t.light&&"light"!==d?"light":d),p=te(o),{[h]:f,light:m,dark:g,...y}=t,b={...y};let k=f;if(("dark"===h&&!("dark"in t)||"light"===h&&!("light"in t))&&(k=!0),!k)throw new Error((0,r.A)(21,h));const S=ne(b,k,c,h);m&&!b.light&&ne(b,m,void 0,"light"),g&&!b.dark&&ne(b,g,void 0,"dark");let I={defaultColorScheme:h,...S,cssVarPrefix:o,colorSchemeSelector:u,getCssVar:p,colorSchemes:b,font:{...w(S.typography),...S.font},spacing:(C=c.spacing,"number"===typeof C?`${C}px`:"string"===typeof C||"function"===typeof C||Array.isArray(C)?C:"8px")};var C;Object.keys(I.colorSchemes).forEach((e=>{const t=I.colorSchemes[e].palette,n=e=>{const n=e.split("-"),r=n[1],a=n[2];return p(e,t[r][a])};var r;if("light"===t.mode&&(Q(t.common,"background","#fff"),Q(t.common,"onBackground","#000")),"dark"===t.mode&&(Q(t.common,"background","#000"),Q(t.common,"onBackground","#fff")),r=t,["Alert","AppBar","Avatar","Button","Chip","FilledInput","LinearProgress","Skeleton","Slider","SnackbarContent","SpeedDialAction","StepConnector","StepContent","Switch","TableCell","Tooltip"].forEach((e=>{r[e]||(r[e]={})})),"light"===t.mode){Q(t.Alert,"errorColor",(0,s.Nd)(t.error.light,.6)),Q(t.Alert,"infoColor",(0,s.Nd)(t.info.light,.6)),Q(t.Alert,"successColor",(0,s.Nd)(t.success.light,.6)),Q(t.Alert,"warningColor",(0,s.Nd)(t.warning.light,.6)),Q(t.Alert,"errorFilledBg",n("palette-error-main")),Q(t.Alert,"infoFilledBg",n("palette-info-main")),Q(t.Alert,"successFilledBg",n("palette-success-main")),Q(t.Alert,"warningFilledBg",n("palette-warning-main")),Q(t.Alert,"errorFilledColor",ee((()=>t.getContrastText(t.error.main)))),Q(t.Alert,"infoFilledColor",ee((()=>t.getContrastText(t.info.main)))),Q(t.Alert,"successFilledColor",ee((()=>t.getContrastText(t.success.main)))),Q(t.Alert,"warningFilledColor",ee((()=>t.getContrastText(t.warning.main)))),Q(t.Alert,"errorStandardBg",(0,s.j4)(t.error.light,.9)),Q(t.Alert,"infoStandardBg",(0,s.j4)(t.info.light,.9)),Q(t.Alert,"successStandardBg",(0,s.j4)(t.success.light,.9)),Q(t.Alert,"warningStandardBg",(0,s.j4)(t.warning.light,.9)),Q(t.Alert,"errorIconColor",n("palette-error-main")),Q(t.Alert,"infoIconColor",n("palette-info-main")),Q(t.Alert,"successIconColor",n("palette-success-main")),Q(t.Alert,"warningIconColor",n("palette-warning-main")),Q(t.AppBar,"defaultBg",n("palette-grey-100")),Q(t.Avatar,"defaultBg",n("palette-grey-400")),Q(t.Button,"inheritContainedBg",n("palette-grey-300")),Q(t.Button,"inheritContainedHoverBg",n("palette-grey-A100")),Q(t.Chip,"defaultBorder",n("palette-grey-400")),Q(t.Chip,"defaultAvatarColor",n("palette-grey-700")),Q(t.Chip,"defaultIconColor",n("palette-grey-700")),Q(t.FilledInput,"bg","rgba(0, 0, 0, 0.06)"),Q(t.FilledInput,"hoverBg","rgba(0, 0, 0, 0.09)"),Q(t.FilledInput,"disabledBg","rgba(0, 0, 0, 0.12)"),Q(t.LinearProgress,"primaryBg",(0,s.j4)(t.primary.main,.62)),Q(t.LinearProgress,"secondaryBg",(0,s.j4)(t.secondary.main,.62)),Q(t.LinearProgress,"errorBg",(0,s.j4)(t.error.main,.62)),Q(t.LinearProgress,"infoBg",(0,s.j4)(t.info.main,.62)),Q(t.LinearProgress,"successBg",(0,s.j4)(t.success.main,.62)),Q(t.LinearProgress,"warningBg",(0,s.j4)(t.warning.main,.62)),Q(t.Skeleton,"bg",`rgba(${n("palette-text-primaryChannel")} / 0.11)`),Q(t.Slider,"primaryTrack",(0,s.j4)(t.primary.main,.62)),Q(t.Slider,"secondaryTrack",(0,s.j4)(t.secondary.main,.62)),Q(t.Slider,"errorTrack",(0,s.j4)(t.error.main,.62)),Q(t.Slider,"infoTrack",(0,s.j4)(t.info.main,.62)),Q(t.Slider,"successTrack",(0,s.j4)(t.success.main,.62)),Q(t.Slider,"warningTrack",(0,s.j4)(t.warning.main,.62));const e=(0,s.Y9)(t.background.default,.8);Q(t.SnackbarContent,"bg",e),Q(t.SnackbarContent,"color",ee((()=>t.getContrastText(e)))),Q(t.SpeedDialAction,"fabHoverBg",(0,s.Y9)(t.background.paper,.15)),Q(t.StepConnector,"border",n("palette-grey-400")),Q(t.StepContent,"border",n("palette-grey-400")),Q(t.Switch,"defaultColor",n("palette-common-white")),Q(t.Switch,"defaultDisabledColor",n("palette-grey-100")),Q(t.Switch,"primaryDisabledColor",(0,s.j4)(t.primary.main,.62)),Q(t.Switch,"secondaryDisabledColor",(0,s.j4)(t.secondary.main,.62)),Q(t.Switch,"errorDisabledColor",(0,s.j4)(t.error.main,.62)),Q(t.Switch,"infoDisabledColor",(0,s.j4)(t.info.main,.62)),Q(t.Switch,"successDisabledColor",(0,s.j4)(t.success.main,.62)),Q(t.Switch,"warningDisabledColor",(0,s.j4)(t.warning.main,.62)),Q(t.TableCell,"border",(0,s.j4)((0,s.Cg)(t.divider,1),.88)),Q(t.Tooltip,"bg",(0,s.Cg)(t.grey[700],.92))}if("dark"===t.mode){Q(t.Alert,"errorColor",(0,s.j4)(t.error.light,.6)),Q(t.Alert,"infoColor",(0,s.j4)(t.info.light,.6)),Q(t.Alert,"successColor",(0,s.j4)(t.success.light,.6)),Q(t.Alert,"warningColor",(0,s.j4)(t.warning.light,.6)),Q(t.Alert,"errorFilledBg",n("palette-error-dark")),Q(t.Alert,"infoFilledBg",n("palette-info-dark")),Q(t.Alert,"successFilledBg",n("palette-success-dark")),Q(t.Alert,"warningFilledBg",n("palette-warning-dark")),Q(t.Alert,"errorFilledColor",ee((()=>t.getContrastText(t.error.dark)))),Q(t.Alert,"infoFilledColor",ee((()=>t.getContrastText(t.info.dark)))),Q(t.Alert,"successFilledColor",ee((()=>t.getContrastText(t.success.dark)))),Q(t.Alert,"warningFilledColor",ee((()=>t.getContrastText(t.warning.dark)))),Q(t.Alert,"errorStandardBg",(0,s.Nd)(t.error.light,.9)),Q(t.Alert,"infoStandardBg",(0,s.Nd)(t.info.light,.9)),Q(t.Alert,"successStandardBg",(0,s.Nd)(t.success.light,.9)),Q(t.Alert,"warningStandardBg",(0,s.Nd)(t.warning.light,.9)),Q(t.Alert,"errorIconColor",n("palette-error-main")),Q(t.Alert,"infoIconColor",n("palette-info-main")),Q(t.Alert,"successIconColor",n("palette-success-main")),Q(t.Alert,"warningIconColor",n("palette-warning-main")),Q(t.AppBar,"defaultBg",n("palette-grey-900")),Q(t.AppBar,"darkBg",n("palette-background-paper")),Q(t.AppBar,"darkColor",n("palette-text-primary")),Q(t.Avatar,"defaultBg",n("palette-grey-600")),Q(t.Button,"inheritContainedBg",n("palette-grey-800")),Q(t.Button,"inheritContainedHoverBg",n("palette-grey-700")),Q(t.Chip,"defaultBorder",n("palette-grey-700")),Q(t.Chip,"defaultAvatarColor",n("palette-grey-300")),Q(t.Chip,"defaultIconColor",n("palette-grey-300")),Q(t.FilledInput,"bg","rgba(255, 255, 255, 0.09)"),Q(t.FilledInput,"hoverBg","rgba(255, 255, 255, 0.13)"),Q(t.FilledInput,"disabledBg","rgba(255, 255, 255, 0.12)"),Q(t.LinearProgress,"primaryBg",(0,s.Nd)(t.primary.main,.5)),Q(t.LinearProgress,"secondaryBg",(0,s.Nd)(t.secondary.main,.5)),Q(t.LinearProgress,"errorBg",(0,s.Nd)(t.error.main,.5)),Q(t.LinearProgress,"infoBg",(0,s.Nd)(t.info.main,.5)),Q(t.LinearProgress,"successBg",(0,s.Nd)(t.success.main,.5)),Q(t.LinearProgress,"warningBg",(0,s.Nd)(t.warning.main,.5)),Q(t.Skeleton,"bg",`rgba(${n("palette-text-primaryChannel")} / 0.13)`),Q(t.Slider,"primaryTrack",(0,s.Nd)(t.primary.main,.5)),Q(t.Slider,"secondaryTrack",(0,s.Nd)(t.secondary.main,.5)),Q(t.Slider,"errorTrack",(0,s.Nd)(t.error.main,.5)),Q(t.Slider,"infoTrack",(0,s.Nd)(t.info.main,.5)),Q(t.Slider,"successTrack",(0,s.Nd)(t.success.main,.5)),Q(t.Slider,"warningTrack",(0,s.Nd)(t.warning.main,.5));const e=(0,s.Y9)(t.background.default,.98);Q(t.SnackbarContent,"bg",e),Q(t.SnackbarContent,"color",ee((()=>t.getContrastText(e)))),Q(t.SpeedDialAction,"fabHoverBg",(0,s.Y9)(t.background.paper,.15)),Q(t.StepConnector,"border",n("palette-grey-600")),Q(t.StepContent,"border",n("palette-grey-600")),Q(t.Switch,"defaultColor",n("palette-grey-300")),Q(t.Switch,"defaultDisabledColor",n("palette-grey-600")),Q(t.Switch,"primaryDisabledColor",(0,s.Nd)(t.primary.main,.55)),Q(t.Switch,"secondaryDisabledColor",(0,s.Nd)(t.secondary.main,.55)),Q(t.Switch,"errorDisabledColor",(0,s.Nd)(t.error.main,.55)),Q(t.Switch,"infoDisabledColor",(0,s.Nd)(t.info.main,.55)),Q(t.Switch,"successDisabledColor",(0,s.Nd)(t.success.main,.55)),Q(t.Switch,"warningDisabledColor",(0,s.Nd)(t.warning.main,.55)),Q(t.TableCell,"border",(0,s.Nd)((0,s.Cg)(t.divider,1),.68)),Q(t.Tooltip,"bg",(0,s.Cg)(t.grey[700],.92))}Z(t.background,"default"),Z(t.background,"paper"),Z(t.common,"background"),Z(t.common,"onBackground"),Z(t,"divider"),Object.keys(t).forEach((e=>{const n=t[e];n&&"object"===typeof n&&(n.main&&Q(t[e],"mainChannel",(0,s.Me)(J(n.main))),n.light&&Q(t[e],"lightChannel",(0,s.Me)(J(n.light))),n.dark&&Q(t[e],"darkChannel",(0,s.Me)(J(n.dark))),n.contrastText&&Q(t[e],"contrastTextChannel",(0,s.Me)(J(n.contrastText))),"text"===e&&(Z(t[e],"primary"),Z(t[e],"secondary")),"action"===e&&(n.active&&Z(t[e],"active"),n.selected&&Z(t[e],"selected")))}))}));for(var A=arguments.length,_=new Array(A>1?A-1:0),$=1;$<A;$++)_[$-1]=arguments[$];I=_.reduce(((e,t)=>(0,a.A)(e,t)),I);const R={prefix:o,disableCssColorScheme:i,shouldSkipGeneratingVar:l,getSelector:X(I)},{vars:D,generateThemeVars:M,generateStyleSheets:F}=N(I,R);return I.vars=D,Object.entries(I.colorSchemes[I.defaultColorScheme]).forEach((e=>{let[t,n]=e;I[t]=n})),I.generateThemeVars=M,I.generateStyleSheets=F,I.generateSpacing=function(){return(0,v.A)(c.spacing,(0,x.LX)(this))},I.getColorSchemeSelector=function(e){return function(t){return"media"===e?`@media (prefers-color-scheme: ${t})`:e?e.startsWith("data-")&&!e.includes("%s")?`[${e}="${t}"] &`:"class"===e?`.${t} &`:"data"===e?`[data-${t}] &`:`${e.replace("%s",t)} &`:"&"}}(u),I.spacing=I.generateSpacing(),I.shouldSkipGeneratingVar=l,I.unstable_sxConfig={...T.A,...c?.unstable_sxConfig},I.unstable_sx=function(e){return(0,E.A)({sx:e,theme:this})},I.toRuntimeSource=Y,I}({...l,colorSchemes:d,defaultColorScheme:u,..."boolean"!==typeof n&&n},...p)}},5170:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=(0,n(5913).A)()},3582:(e,t,n)=>{"use strict";function r(e){let t;return t=e<1?5.11916*e**2:4.5*Math.log(e+1)+2,Math.round(10*t)/1e3}n.d(t,{A:()=>r})},3375:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r="$$material"},1475:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(7123);const a=e=>(0,r.A)(e)&&"classes"!==e},7123:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=function(e){return"ownerState"!==e&&"theme"!==e&&"sx"!==e&&"as"!==e}},4535:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>o});var r=n(3860),a=n(5170),s=n(3375),i=n(1475);const o=(0,r.Ay)({themeId:s.A,defaultTheme:a.A,rootShouldForwardProp:i.A})},6803:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(7598).A},9662:(e,t,n)=>{"use strict";n.d(t,{A:()=>y});var r=n(5043),a=n(8387),s=n(8610),i=n(6803),o=n(4535),l=n(6870),u=n(8249),c=n(2532),d=n(2372);function h(e){return(0,d.Ay)("MuiSvgIcon",e)}(0,c.A)("MuiSvgIcon",["root","colorPrimary","colorSecondary","colorAction","colorError","colorDisabled","fontSizeInherit","fontSizeSmall","fontSizeMedium","fontSizeLarge"]);var p=n(579);const f=(0,o.Ay)("svg",{name:"MuiSvgIcon",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,"inherit"!==n.color&&t[`color${(0,i.A)(n.color)}`],t[`fontSize${(0,i.A)(n.fontSize)}`]]}})((0,l.A)((e=>{let{theme:t}=e;return{userSelect:"none",width:"1em",height:"1em",display:"inline-block",flexShrink:0,transition:t.transitions?.create?.("fill",{duration:(t.vars??t).transitions?.duration?.shorter}),variants:[{props:e=>!e.hasSvgAsChild,style:{fill:"currentColor"}},{props:{fontSize:"inherit"},style:{fontSize:"inherit"}},{props:{fontSize:"small"},style:{fontSize:t.typography?.pxToRem?.(20)||"1.25rem"}},{props:{fontSize:"medium"},style:{fontSize:t.typography?.pxToRem?.(24)||"1.5rem"}},{props:{fontSize:"large"},style:{fontSize:t.typography?.pxToRem?.(35)||"2.1875rem"}},...Object.entries((t.vars??t).palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars??t).palette?.[n]?.main}}})),{props:{color:"action"},style:{color:(t.vars??t).palette?.action?.active}},{props:{color:"disabled"},style:{color:(t.vars??t).palette?.action?.disabled}},{props:{color:"inherit"},style:{color:void 0}}]}}))),m=r.forwardRef((function(e,t){const n=(0,u.b)({props:e,name:"MuiSvgIcon"}),{children:o,className:l,color:c="inherit",component:d="svg",fontSize:m="medium",htmlColor:g,inheritViewBox:y=!1,titleAccess:b,viewBox:v="0 0 24 24",...x}=n,w=r.isValidElement(o)&&"svg"===o.type,k={...n,color:c,component:d,fontSize:m,instanceFontSize:e.fontSize,inheritViewBox:y,viewBox:v,hasSvgAsChild:w},S={};y||(S.viewBox=v);const I=(e=>{const{color:t,fontSize:n,classes:r}=e,a={root:["root","inherit"!==t&&`color${(0,i.A)(t)}`,`fontSize${(0,i.A)(n)}`]};return(0,s.A)(a,h,r)})(k);return(0,p.jsxs)(f,{as:d,className:(0,a.A)(I.root,l),focusable:"false",color:g,"aria-hidden":!b||void 0,role:b?"img":void 0,ref:t,...S,...x,...w&&o.props,ownerState:k,children:[w?o.props.children:o,b?(0,p.jsx)("title",{children:b}):null]})}));m&&(m.muiName="SvgIcon");const g=m;function y(e,t){function n(n,r){return(0,p.jsx)(g,{"data-testid":`${t}Icon`,ref:r,...n,children:e})}return n.muiName=g.muiName,r.memo(r.forwardRef(n))}},950:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(3468).A},4421:(e,t,n)=>{"use strict";n.r(t),n.d(t,{capitalize:()=>a.A,createChainedFunction:()=>s,createSvgIcon:()=>i.A,debounce:()=>o.A,deprecatedPropType:()=>l,isMuiElement:()=>u.A,ownerDocument:()=>d.A,ownerWindow:()=>h.A,requirePropFactory:()=>p,setRef:()=>f,unstable_ClassNameGenerator:()=>w,unstable_memoTheme:()=>c.A,unstable_useEnhancedEffect:()=>m.A,unstable_useId:()=>g.A,unsupportedProp:()=>y,useControlled:()=>b.A,useEventCallback:()=>v.A,useForkRef:()=>x.A});var r=n(9386),a=n(6803);const s=n(2456).A;var i=n(9662),o=n(950);const l=function(e,t){return()=>null};var u=n(7328),c=n(6870),d=n(2427),h=n(6078);const p=function(e,t){return()=>null};const f=n(6564).A;var m=n(5013),g=n(5879);const y=function(e,t,n,r,a){return null};var b=n(5420),v=n(3319),x=n(5849);const w={configure:e=>{r.A.configure(e)}}},7328:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(5043);const a=function(e,t){return r.isValidElement(e)&&-1!==t.indexOf(e.type.muiName??e.type?._payload?.value?.muiName)}},6870:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});const r={theme:void 0};function a(e){let t,n;return a=>{let s=t;return void 0!==s&&a.theme===n||(r.theme=a.theme,s=e(r),t=s,n=a.theme),s}}},2427:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(1668).A},6078:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(3940).A},5420:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(5043);const a=function(e){let{controlled:t,default:n,name:a,state:s="value"}=e;const{current:i}=r.useRef(void 0!==t),[o,l]=r.useState(n);return[i?t:o,r.useCallback((e=>{i||l(e)}),[])]}},5013:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(4440).A},3319:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(1782).A},5849:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(3462).A},5879:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(5844).A},4984:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>b,q_:()=>v});var r=n(8168),a=n(5043),s=n(918),i=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,o=(0,s.A)((function(e){return i.test(e)||111===e.charCodeAt(0)&&110===e.charCodeAt(1)&&e.charCodeAt(2)<91})),l=n(4575),u=n(1722),c=n(6598),d=n(9436),h=o,p=function(e){return"theme"!==e},f=function(e){return"string"===typeof e&&e.charCodeAt(0)>96?h:p},m=function(e,t,n){var r;if(t){var a=t.shouldForwardProp;r=e.__emotion_forwardProp&&a?function(t){return e.__emotion_forwardProp(t)&&a(t)}:a}return"function"!==typeof r&&n&&(r=e.__emotion_forwardProp),r},g=function(e){var t=e.cache,n=e.serialized,r=e.isStringTag;return(0,u.SF)(t,n,r),(0,d.s)((function(){return(0,u.sk)(t,n,r)})),null},y=function e(t,n){var s,i,o=t.__emotion_real===t,d=o&&t.__emotion_base||t;void 0!==n&&(s=n.label,i=n.target);var h=m(t,n,o),p=h||f(d),y=!p("as");return function(){var b=arguments,v=o&&void 0!==t.__emotion_styles?t.__emotion_styles.slice(0):[];if(void 0!==s&&v.push("label:"+s+";"),null==b[0]||void 0===b[0].raw)v.push.apply(v,b);else{v.push(b[0][0]);for(var x=b.length,w=1;w<x;w++)v.push(b[w],b[0][w])}var k=(0,l.w)((function(e,t,n){var r=y&&e.as||d,s="",o=[],m=e;if(null==e.theme){for(var b in m={},e)m[b]=e[b];m.theme=a.useContext(l.T)}"string"===typeof e.className?s=(0,u.Rk)(t.registered,o,e.className):null!=e.className&&(s=e.className+" ");var x=(0,c.J)(v.concat(o),t.registered,m);s+=t.key+"-"+x.name,void 0!==i&&(s+=" "+i);var w=y&&void 0===h?f(r):p,k={};for(var S in e)y&&"as"===S||w(S)&&(k[S]=e[S]);return k.className=s,n&&(k.ref=n),a.createElement(a.Fragment,null,a.createElement(g,{cache:t,serialized:x,isStringTag:"string"===typeof r}),a.createElement(r,k))}));return k.displayName=void 0!==s?s:"Styled("+("string"===typeof d?d:d.displayName||d.name||"Component")+")",k.defaultProps=t.defaultProps,k.__emotion_real=k,k.__emotion_base=d,k.__emotion_styles=v,k.__emotion_forwardProp=h,Object.defineProperty(k,"toString",{value:function(){return"."+i}}),k.withComponent=function(t,a){return e(t,(0,r.A)({},n,a,{shouldForwardProp:m(k,a,!0)})).apply(void 0,v)},k}}.bind();function b(e,t){return y(e,t)}["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"].forEach((function(e){y[e]=y(e)}));const v=(e,t)=>{Array.isArray(e.__emotion_styles)&&(e.__emotion_styles=t(e.__emotion_styles))}},1136:(e,t,n)=>{"use strict";n.d(t,{EU:()=>l,NI:()=>o,kW:()=>c,vf:()=>u,zu:()=>a});var r=n(3072);const a={xs:0,sm:600,md:900,lg:1200,xl:1536},s={keys:["xs","sm","md","lg","xl"],up:e=>`@media (min-width:${a[e]}px)`},i={containerQueries:e=>({up:t=>{let n="number"===typeof t?t:a[t]||t;return"number"===typeof n&&(n=`${n}px`),e?`@container ${e} (min-width:${n})`:`@container (min-width:${n})`}})};function o(e,t,n){const o=e.theme||{};if(Array.isArray(t)){const e=o.breakpoints||s;return t.reduce(((r,a,s)=>(r[e.up(e.keys[s])]=n(t[s]),r)),{})}if("object"===typeof t){const e=o.breakpoints||s;return Object.keys(t).reduce(((s,l)=>{if((0,r.ob)(e.keys,l)){const e=(0,r.CT)(o.containerQueries?o:i,l);e&&(s[e]=n(t[l],l))}else if(Object.keys(e.values||a).includes(l)){s[e.up(l)]=n(t[l],l)}else{const e=l;s[e]=t[e]}return s}),{})}return n(t)}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=e.keys?.reduce(((t,n)=>(t[e.up(n)]={},t)),{});return t||{}}function u(e,t){return e.reduce(((e,t)=>{const n=e[t];return(!n||0===Object.keys(n).length)&&delete e[t],e}),t)}function c(e){let{values:t,breakpoints:n,base:r}=e;const a=r||function(e,t){if("object"!==typeof e)return{};const n={},r=Object.keys(t);return Array.isArray(e)?r.forEach(((t,r)=>{r<e.length&&(n[t]=!0)})):r.forEach((t=>{null!=e[t]&&(n[t]=!0)})),n}(t,n),s=Object.keys(a);if(0===s.length)return t;let i;return s.reduce(((e,n,r)=>(Array.isArray(t)?(e[n]=null!=t[r]?t[r]:t[i],i=r):"object"===typeof t?(e[n]=null!=t[n]?t[n]:t[i],i=n):e[n]=t,e)),{})}},6596:(e,t,n)=>{"use strict";n.d(t,{X4:()=>h,e$:()=>f,tL:()=>b,eM:()=>d,YL:()=>u,a:()=>g,Cg:()=>p,Me:()=>o,Nd:()=>m,Y9:()=>v,j4:()=>y});var r=n(7868);const a=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MIN_SAFE_INTEGER,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Number.MAX_SAFE_INTEGER;return Math.max(t,Math.min(e,n))};function s(e){return a(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1)}function i(e){if(e.type)return e;if("#"===e.charAt(0))return i(function(e){e=e.slice(1);const t=new RegExp(`.{1,${e.length>=6?2:1}}`,"g");let n=e.match(t);return n&&1===n[0].length&&(n=n.map((e=>e+e))),n?`rgb${4===n.length?"a":""}(${n.map(((e,t)=>t<3?parseInt(e,16):Math.round(parseInt(e,16)/255*1e3)/1e3)).join(", ")})`:""}(e));const t=e.indexOf("("),n=e.substring(0,t);if(!["rgb","rgba","hsl","hsla","color"].includes(n))throw new Error((0,r.A)(9,e));let a,s=e.substring(t+1,e.length-1);if("color"===n){if(s=s.split(" "),a=s.shift(),4===s.length&&"/"===s[3].charAt(0)&&(s[3]=s[3].slice(1)),!["srgb","display-p3","a98-rgb","prophoto-rgb","rec-2020"].includes(a))throw new Error((0,r.A)(10,a))}else s=s.split(",");return s=s.map((e=>parseFloat(e))),{type:n,values:s,colorSpace:a}}const o=(e,t)=>{try{return(e=>{const t=i(e);return t.values.slice(0,3).map(((e,n)=>t.type.includes("hsl")&&0!==n?`${e}%`:e)).join(" ")})(e)}catch(n){return e}};function l(e){const{type:t,colorSpace:n}=e;let{values:r}=e;return t.includes("rgb")?r=r.map(((e,t)=>t<3?parseInt(e,10):e)):t.includes("hsl")&&(r[1]=`${r[1]}%`,r[2]=`${r[2]}%`),r=t.includes("color")?`${n} ${r.join(" ")}`:`${r.join(", ")}`,`${t}(${r})`}function u(e){e=i(e);const{values:t}=e,n=t[0],r=t[1]/100,a=t[2]/100,s=r*Math.min(a,1-a),o=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(e+n/30)%12;return a-s*Math.max(Math.min(t-3,9-t,1),-1)};let u="rgb";const c=[Math.round(255*o(0)),Math.round(255*o(8)),Math.round(255*o(4))];return"hsla"===e.type&&(u+="a",c.push(t[3])),l({type:u,values:c})}function c(e){let t="hsl"===(e=i(e)).type||"hsla"===e.type?i(u(e)).values:e.values;return t=t.map((t=>("color"!==e.type&&(t/=255),t<=.03928?t/12.92:((t+.055)/1.055)**2.4))),Number((.2126*t[0]+.7152*t[1]+.0722*t[2]).toFixed(3))}function d(e,t){const n=c(e),r=c(t);return(Math.max(n,r)+.05)/(Math.min(n,r)+.05)}function h(e,t){return e=i(e),t=s(t),"rgb"!==e.type&&"hsl"!==e.type||(e.type+="a"),"color"===e.type?e.values[3]=`/${t}`:e.values[3]=t,l(e)}function p(e,t,n){try{return h(e,t)}catch(r){return e}}function f(e,t){if(e=i(e),t=s(t),e.type.includes("hsl"))e.values[2]*=1-t;else if(e.type.includes("rgb")||e.type.includes("color"))for(let n=0;n<3;n+=1)e.values[n]*=1-t;return l(e)}function m(e,t,n){try{return f(e,t)}catch(r){return e}}function g(e,t){if(e=i(e),t=s(t),e.type.includes("hsl"))e.values[2]+=(100-e.values[2])*t;else if(e.type.includes("rgb"))for(let n=0;n<3;n+=1)e.values[n]+=(255-e.values[n])*t;else if(e.type.includes("color"))for(let n=0;n<3;n+=1)e.values[n]+=(1-e.values[n])*t;return l(e)}function y(e,t,n){try{return g(e,t)}catch(r){return e}}function b(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.15;return c(e)>.5?f(e,t):g(e,t)}function v(e,t,n){try{return b(e,t)}catch(r){return e}}},3860:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>f,MC:()=>l});var r=n(4984),a=n(9172),s=n(2390),i=n(2768);const o=(0,s.A)();function l(e){return"ownerState"!==e&&"theme"!==e&&"sx"!==e&&"as"!==e}function u(e,t,n){return function(e){for(const t in e)return!1;return!0}(t)?n:t[e]||t}const c=Symbol("mui.processed_props");function d(e,t,n){if(c in e)return e[c];const r={...e,theme:u(t,e.theme,n)};return e[c]=r,r[c]=r,r}function h(e){return e?(t,n)=>n[e]:null}function p(e,t){const n="function"===typeof e?e(t):e;if(Array.isArray(n))return n.flatMap((e=>p(e,t)));if(Array.isArray(n?.variants)){const{variants:e,...r}=n;let a,s=r;e:for(let n=0;n<e.length;n+=1){const r=e[n];if("function"===typeof r.props){if(a??={...t,...t.ownerState,ownerState:t.ownerState},!r.props(a))continue}else for(const e in r.props)if(t[e]!==r.props[e]&&t.ownerState?.[e]!==r.props[e])continue e;Array.isArray(s)||(s=[s]),"function"===typeof r.style?(a??={...t,...t.ownerState,ownerState:t.ownerState},s.push(r.style(a))):s.push(r.style)}return s}return n}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{themeId:t,defaultTheme:n=o,rootShouldForwardProp:s=l,slotShouldForwardProp:c=l}=e,f=e=>(0,i.A)(d(e,t,n));f.__mui_systemSx=!0;return function(e){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,r.q_)(e,(e=>e.filter((e=>!e?.__mui_systemSx))));const{name:o,slot:g,skipVariantsResolver:y,skipSx:b,overridesResolver:v=h(m(g)),...x}=i,w=void 0!==y?y:g&&"Root"!==g&&"root"!==g||!1,k=b||!1;let S=l;"Root"===g||"root"===g?S=s:g?S=c:function(e){return"string"===typeof e&&e.charCodeAt(0)>96}(e)&&(S=void 0);const I=(0,r.Ay)(e,{shouldForwardProp:S,label:undefined,...x}),C=e=>"function"===typeof e&&e.__emotion_real!==e||(0,a.Q)(e)?r=>p(e,d(r,t,n)):e,N=function(r){let a=C(r);for(var s=arguments.length,i=new Array(s>1?s-1:0),l=1;l<s;l++)i[l-1]=arguments[l];const c=i?i.map(C):[];o&&v&&c.push((e=>{const r=u(t,e.theme,n);if(!r.components||!r.components[o]||!r.components[o].styleOverrides)return null;const a=r.components[o].styleOverrides,s={},i=d(e,t,n);for(const t in a)s[t]=p(a[t],i);return v(e,s)})),o&&!w&&c.push((e=>{const r=u(t,e.theme,n),a=r?.components?.[o]?.variants;return a?p({variants:a},d(e,t,n)):null})),k||c.push(f);const h=c.length-i.length;if(Array.isArray(r)&&h>0){const e=new Array(h).fill("");a=[...r,...e],a.raw=[...r.raw,...e]}const m=I(a,...c);return e.muiName&&(m.muiName=e.muiName),m};return I.withConfig&&(N.withConfig=I.withConfig),N}}function m(e){return e?e.charAt(0).toLowerCase()+e.slice(1):e}},6160:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(883);function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:8,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(0,r.LX)({spacing:e});if(e.mui)return e;const n=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return(0===n.length?[1]:n).map((e=>{const n=t(e);return"number"===typeof n?`${n}px`:n})).join(" ")};return n.mui=!0,n}},2390:(e,t,n)=>{"use strict";n.d(t,{A:()=>d});var r=n(9172);const a=e=>{const t=Object.keys(e).map((t=>({key:t,val:e[t]})))||[];return t.sort(((e,t)=>e.val-t.val)),t.reduce(((e,t)=>({...e,[t.key]:t.val})),{})};var s=n(3072);const i={borderRadius:4};var o=n(6160),l=n(2768),u=n(138);function c(e,t){const n=this;if(n.vars){if(!n.colorSchemes?.[e]||"function"!==typeof n.getColorSchemeSelector)return{};let r=n.getColorSchemeSelector(e);return(r.includes("data-")||r.includes("."))&&(r=`*:where(${r.replace(/\s*&$/,"")}) &`),{[r]:t}}return n.palette.mode===e?t:{}}const d=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{breakpoints:t={},palette:n={},spacing:d,shape:h={},...p}=e,f=function(e){const{values:t={xs:0,sm:600,md:900,lg:1200,xl:1536},unit:n="px",step:r=5,...s}=e,i=a(t),o=Object.keys(i);function l(e){return`@media (min-width:${"number"===typeof t[e]?t[e]:e}${n})`}function u(e){return`@media (max-width:${("number"===typeof t[e]?t[e]:e)-r/100}${n})`}function c(e,a){const s=o.indexOf(a);return`@media (min-width:${"number"===typeof t[e]?t[e]:e}${n}) and (max-width:${(-1!==s&&"number"===typeof t[o[s]]?t[o[s]]:a)-r/100}${n})`}return{keys:o,values:i,up:l,down:u,between:c,only:function(e){return o.indexOf(e)+1<o.length?c(e,o[o.indexOf(e)+1]):l(e)},not:function(e){const t=o.indexOf(e);return 0===t?l(o[1]):t===o.length-1?u(o[t]):c(e,o[o.indexOf(e)+1]).replace("@media","@media not all and")},unit:n,...s}}(t),m=(0,o.A)(d);let g=(0,r.A)({breakpoints:f,direction:"ltr",components:{},palette:{mode:"light",...n},spacing:m,shape:{...i,...h}},p);g=(0,s.Ay)(g),g.applyStyles=c;for(var y=arguments.length,b=new Array(y>1?y-1:0),v=1;v<y;v++)b[v-1]=arguments[v];return g=b.reduce(((e,t)=>(0,r.A)(e,t)),g),g.unstable_sxConfig={...u.A,...p?.unstable_sxConfig},g.unstable_sx=function(e){return(0,l.A)({sx:e,theme:this})},g}},3072:(e,t,n)=>{"use strict";function r(e,t){if(!e.containerQueries)return t;const n=Object.keys(t).filter((e=>e.startsWith("@container"))).sort(((e,t)=>{const n=/min-width:\s*([0-9.]+)/;return+(e.match(n)?.[1]||0)-+(t.match(n)?.[1]||0)}));return n.length?n.reduce(((e,n)=>{const r=t[n];return delete e[n],e[n]=r,e}),{...t}):t}function a(e,t){return"@"===t||t.startsWith("@")&&(e.some((e=>t.startsWith(`@${e}`)))||!!t.match(/^@\d/))}function s(e,t){const n=t.match(/^@([^/]+)?\/?(.+)?$/);if(!n)return null;const[,r,a]=n,s=Number.isNaN(+r)?r||0:+r;return e.containerQueries(a).up(s)}function i(e){const t=(e,t)=>e.replace("@media",t?`@container ${t}`:"@container");function n(n,r){n.up=function(){return t(e.breakpoints.up(...arguments),r)},n.down=function(){return t(e.breakpoints.down(...arguments),r)},n.between=function(){return t(e.breakpoints.between(...arguments),r)},n.only=function(){return t(e.breakpoints.only(...arguments),r)},n.not=function(){const n=t(e.breakpoints.not(...arguments),r);return n.includes("not all and")?n.replace("not all and ","").replace("min-width:","width<").replace("max-width:","width>").replace("and","or"):n}}const r={},a=e=>(n(r,e),r);return n(a),{...e,containerQueries:a}}n.d(t,{Ay:()=>i,CT:()=>s,_S:()=>r,ob:()=>a})},5056:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(9172);const a=function(e,t){return t?(0,r.A)(e,t,{clone:!1}):e}},883:(e,t,n)=>{"use strict";n.d(t,{LX:()=>f,MA:()=>p,_W:()=>m,Lc:()=>b,Ms:()=>v});var r=n(1136),a=n(6224),s=n(5056);const i={m:"margin",p:"padding"},o={t:"Top",r:"Right",b:"Bottom",l:"Left",x:["Left","Right"],y:["Top","Bottom"]},l={marginX:"mx",marginY:"my",paddingX:"px",paddingY:"py"},u=function(e){const t={};return n=>(void 0===t[n]&&(t[n]=e(n)),t[n])}((e=>{if(e.length>2){if(!l[e])return[e];e=l[e]}const[t,n]=e.split(""),r=i[t],a=o[n]||"";return Array.isArray(a)?a.map((e=>r+e)):[r+a]})),c=["m","mt","mr","mb","ml","mx","my","margin","marginTop","marginRight","marginBottom","marginLeft","marginX","marginY","marginInline","marginInlineStart","marginInlineEnd","marginBlock","marginBlockStart","marginBlockEnd"],d=["p","pt","pr","pb","pl","px","py","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","paddingX","paddingY","paddingInline","paddingInlineStart","paddingInlineEnd","paddingBlock","paddingBlockStart","paddingBlockEnd"],h=[...c,...d];function p(e,t,n,r){const s=(0,a.Yn)(e,t,!0)??n;return"number"===typeof s||"string"===typeof s?e=>"string"===typeof e?e:"string"===typeof s?`calc(${e} * ${s})`:s*e:Array.isArray(s)?e=>{if("string"===typeof e)return e;const t=Math.abs(e);const n=s[t];return e>=0?n:"number"===typeof n?-n:`-${n}`}:"function"===typeof s?s:()=>{}}function f(e){return p(e,"spacing",8)}function m(e,t){return"string"===typeof t||null==t?t:e(t)}function g(e,t,n,a){if(!t.includes(n))return null;const s=function(e,t){return n=>e.reduce(((e,r)=>(e[r]=m(t,n),e)),{})}(u(n),a),i=e[n];return(0,r.NI)(e,i,s)}function y(e,t){const n=f(e.theme);return Object.keys(e).map((r=>g(e,t,r,n))).reduce(s.A,{})}function b(e){return y(e,c)}function v(e){return y(e,d)}function x(e){return y(e,h)}b.propTypes={},b.filterProps=c,v.propTypes={},v.filterProps=d,x.propTypes={},x.filterProps=h},138:(e,t,n)=>{"use strict";n.d(t,{A:()=>M});var r=n(883),a=n(6224),s=n(5056);const i=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=t.reduce(((e,t)=>(t.filterProps.forEach((n=>{e[n]=t})),e)),{}),a=e=>Object.keys(e).reduce(((t,n)=>r[n]?(0,s.A)(t,r[n](e)):t),{});return a.propTypes={},a.filterProps=t.reduce(((e,t)=>e.concat(t.filterProps)),[]),a};var o=n(1136);function l(e){return"number"!==typeof e?e:`${e}px solid`}function u(e,t){return(0,a.Ay)({prop:e,themeKey:"borders",transform:t})}const c=u("border",l),d=u("borderTop",l),h=u("borderRight",l),p=u("borderBottom",l),f=u("borderLeft",l),m=u("borderColor"),g=u("borderTopColor"),y=u("borderRightColor"),b=u("borderBottomColor"),v=u("borderLeftColor"),x=u("outline",l),w=u("outlineColor"),k=e=>{if(void 0!==e.borderRadius&&null!==e.borderRadius){const t=(0,r.MA)(e.theme,"shape.borderRadius",4,"borderRadius"),n=e=>({borderRadius:(0,r._W)(t,e)});return(0,o.NI)(e,e.borderRadius,n)}return null};k.propTypes={},k.filterProps=["borderRadius"];i(c,d,h,p,f,m,g,y,b,v,k,x,w);const S=e=>{if(void 0!==e.gap&&null!==e.gap){const t=(0,r.MA)(e.theme,"spacing",8,"gap"),n=e=>({gap:(0,r._W)(t,e)});return(0,o.NI)(e,e.gap,n)}return null};S.propTypes={},S.filterProps=["gap"];const I=e=>{if(void 0!==e.columnGap&&null!==e.columnGap){const t=(0,r.MA)(e.theme,"spacing",8,"columnGap"),n=e=>({columnGap:(0,r._W)(t,e)});return(0,o.NI)(e,e.columnGap,n)}return null};I.propTypes={},I.filterProps=["columnGap"];const C=e=>{if(void 0!==e.rowGap&&null!==e.rowGap){const t=(0,r.MA)(e.theme,"spacing",8,"rowGap"),n=e=>({rowGap:(0,r._W)(t,e)});return(0,o.NI)(e,e.rowGap,n)}return null};C.propTypes={},C.filterProps=["rowGap"];i(S,I,C,(0,a.Ay)({prop:"gridColumn"}),(0,a.Ay)({prop:"gridRow"}),(0,a.Ay)({prop:"gridAutoFlow"}),(0,a.Ay)({prop:"gridAutoColumns"}),(0,a.Ay)({prop:"gridAutoRows"}),(0,a.Ay)({prop:"gridTemplateColumns"}),(0,a.Ay)({prop:"gridTemplateRows"}),(0,a.Ay)({prop:"gridTemplateAreas"}),(0,a.Ay)({prop:"gridArea"}));function N(e,t){return"grey"===t?t:e}i((0,a.Ay)({prop:"color",themeKey:"palette",transform:N}),(0,a.Ay)({prop:"bgcolor",cssProperty:"backgroundColor",themeKey:"palette",transform:N}),(0,a.Ay)({prop:"backgroundColor",themeKey:"palette",transform:N}));function T(e){return e<=1&&0!==e?100*e+"%":e}const E=(0,a.Ay)({prop:"width",transform:T}),A=e=>{if(void 0!==e.maxWidth&&null!==e.maxWidth){const t=t=>{const n=e.theme?.breakpoints?.values?.[t]||o.zu[t];return n?"px"!==e.theme?.breakpoints?.unit?{maxWidth:`${n}${e.theme.breakpoints.unit}`}:{maxWidth:n}:{maxWidth:T(t)}};return(0,o.NI)(e,e.maxWidth,t)}return null};A.filterProps=["maxWidth"];const _=(0,a.Ay)({prop:"minWidth",transform:T}),$=(0,a.Ay)({prop:"height",transform:T}),R=(0,a.Ay)({prop:"maxHeight",transform:T}),D=(0,a.Ay)({prop:"minHeight",transform:T}),M=((0,a.Ay)({prop:"size",cssProperty:"width",transform:T}),(0,a.Ay)({prop:"size",cssProperty:"height",transform:T}),i(E,A,_,$,R,D,(0,a.Ay)({prop:"boxSizing"})),{border:{themeKey:"borders",transform:l},borderTop:{themeKey:"borders",transform:l},borderRight:{themeKey:"borders",transform:l},borderBottom:{themeKey:"borders",transform:l},borderLeft:{themeKey:"borders",transform:l},borderColor:{themeKey:"palette"},borderTopColor:{themeKey:"palette"},borderRightColor:{themeKey:"palette"},borderBottomColor:{themeKey:"palette"},borderLeftColor:{themeKey:"palette"},outline:{themeKey:"borders",transform:l},outlineColor:{themeKey:"palette"},borderRadius:{themeKey:"shape.borderRadius",style:k},color:{themeKey:"palette",transform:N},bgcolor:{themeKey:"palette",cssProperty:"backgroundColor",transform:N},backgroundColor:{themeKey:"palette",transform:N},p:{style:r.Ms},pt:{style:r.Ms},pr:{style:r.Ms},pb:{style:r.Ms},pl:{style:r.Ms},px:{style:r.Ms},py:{style:r.Ms},padding:{style:r.Ms},paddingTop:{style:r.Ms},paddingRight:{style:r.Ms},paddingBottom:{style:r.Ms},paddingLeft:{style:r.Ms},paddingX:{style:r.Ms},paddingY:{style:r.Ms},paddingInline:{style:r.Ms},paddingInlineStart:{style:r.Ms},paddingInlineEnd:{style:r.Ms},paddingBlock:{style:r.Ms},paddingBlockStart:{style:r.Ms},paddingBlockEnd:{style:r.Ms},m:{style:r.Lc},mt:{style:r.Lc},mr:{style:r.Lc},mb:{style:r.Lc},ml:{style:r.Lc},mx:{style:r.Lc},my:{style:r.Lc},margin:{style:r.Lc},marginTop:{style:r.Lc},marginRight:{style:r.Lc},marginBottom:{style:r.Lc},marginLeft:{style:r.Lc},marginX:{style:r.Lc},marginY:{style:r.Lc},marginInline:{style:r.Lc},marginInlineStart:{style:r.Lc},marginInlineEnd:{style:r.Lc},marginBlock:{style:r.Lc},marginBlockStart:{style:r.Lc},marginBlockEnd:{style:r.Lc},displayPrint:{cssProperty:!1,transform:e=>({"@media print":{display:e}})},display:{},overflow:{},textOverflow:{},visibility:{},whiteSpace:{},flexBasis:{},flexDirection:{},flexWrap:{},justifyContent:{},alignItems:{},alignContent:{},order:{},flex:{},flexGrow:{},flexShrink:{},alignSelf:{},justifyItems:{},justifySelf:{},gap:{style:S},rowGap:{style:C},columnGap:{style:I},gridColumn:{},gridRow:{},gridAutoFlow:{},gridAutoColumns:{},gridAutoRows:{},gridTemplateColumns:{},gridTemplateRows:{},gridTemplateAreas:{},gridArea:{},position:{},zIndex:{themeKey:"zIndex"},top:{},right:{},bottom:{},left:{},boxShadow:{themeKey:"shadows"},width:{transform:T},maxWidth:{style:A},minWidth:{transform:T},height:{transform:T},maxHeight:{transform:T},minHeight:{transform:T},boxSizing:{},font:{themeKey:"font"},fontFamily:{themeKey:"typography"},fontSize:{themeKey:"typography"},fontStyle:{themeKey:"typography"},fontWeight:{themeKey:"typography"},letterSpacing:{},textTransform:{},lineHeight:{},textAlign:{},typography:{cssProperty:!1,themeKey:"typography"}})},2768:(e,t,n)=>{"use strict";n.d(t,{A:()=>c});var r=n(7598),a=n(5056),s=n(6224),i=n(1136),o=n(3072),l=n(138);const u=function(){function e(e,t,n,a){const o={[e]:t,theme:n},l=a[e];if(!l)return{[e]:t};const{cssProperty:u=e,themeKey:c,transform:d,style:h}=l;if(null==t)return null;if("typography"===c&&"inherit"===t)return{[e]:t};const p=(0,s.Yn)(n,c)||{};if(h)return h(o);return(0,i.NI)(o,t,(t=>{let n=(0,s.BO)(p,d,t);return t===n&&"string"===typeof t&&(n=(0,s.BO)(p,d,`${e}${"default"===t?"":(0,r.A)(t)}`,t)),!1===u?n:{[u]:n}}))}return function t(n){const{sx:r,theme:s={}}=n||{};if(!r)return null;const u=s.unstable_sxConfig??l.A;function c(n){let r=n;if("function"===typeof n)r=n(s);else if("object"!==typeof n)return n;if(!r)return null;const l=(0,i.EU)(s.breakpoints),c=Object.keys(l);let d=l;return Object.keys(r).forEach((n=>{const o=(l=r[n],c=s,"function"===typeof l?l(c):l);var l,c;if(null!==o&&void 0!==o)if("object"===typeof o)if(u[n])d=(0,a.A)(d,e(n,o,s,u));else{const e=(0,i.NI)({theme:s},o,(e=>({[n]:e})));!function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=t.reduce(((e,t)=>e.concat(Object.keys(t))),[]),a=new Set(r);return t.every((e=>a.size===Object.keys(e).length))}(e,o)?d=(0,a.A)(d,e):d[n]=t({sx:o,theme:s})}else d=(0,a.A)(d,e(n,o,s,u))})),(0,o._S)(s,(0,i.vf)(c,d))}return Array.isArray(r)?r.map(c):c(r)}}();u.filterProps=["sx"];const c=u},6224:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>o,BO:()=>i,Yn:()=>s});var r=n(7598),a=n(1136);function s(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(!t||"string"!==typeof t)return null;if(e&&e.vars&&n){const n=`vars.${t}`.split(".").reduce(((e,t)=>e&&e[t]?e[t]:null),e);if(null!=n)return n}return t.split(".").reduce(((e,t)=>e&&null!=e[t]?e[t]:null),e)}function i(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n;return r="function"===typeof e?e(n):Array.isArray(e)?e[n]||a:s(e,n)||a,t&&(r=t(r,a,e)),r}const o=function(e){const{prop:t,cssProperty:n=e.prop,themeKey:o,transform:l}=e,u=e=>{if(null==e[t])return null;const u=e[t],c=s(e.theme,o)||{};return(0,a.NI)(e,u,(e=>{let a=i(c,l,e);return e===a&&"string"===typeof e&&(a=i(c,l,`${t}${"default"===e?"":(0,r.A)(e)}`,e)),!1===n?a:{[n]:a}}))};return u.propTypes={},u.filterProps=[t],u}},9386:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});const r=e=>e,a=(()=>{let e=r;return{configure(t){e=t},generate:t=>e(t),reset(){e=r}}})()},7598:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(7868);function a(e){if("string"!==typeof e)throw new Error((0,r.A)(7));return e.charAt(0).toUpperCase()+e.slice(1)}},8610:(e,t,n)=>{"use strict";function r(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;const r={};for(const a in e){const s=e[a];let i="",o=!0;for(let e=0;e<s.length;e+=1){const r=s[e];r&&(i+=(!0===o?"":" ")+t(r),o=!1,n&&n[r]&&(i+=" "+n[r]))}r[a]=i}return r}n.d(t,{A:()=>r})},2456:(e,t,n)=>{"use strict";function r(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.reduce(((e,t)=>null==t?e:function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];e.apply(this,r),t.apply(this,r)}),(()=>{}))}n.d(t,{A:()=>r})},3468:(e,t,n)=>{"use strict";function r(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:166;function r(){for(var r=arguments.length,a=new Array(r),s=0;s<r;s++)a[s]=arguments[s];clearTimeout(t),t=setTimeout((()=>{e.apply(this,a)}),n)}return r.clear=()=>{clearTimeout(t)},r}n.d(t,{A:()=>r})},9172:(e,t,n)=>{"use strict";function r(e){if("object"!==typeof e||null===e)return!1;const t=Object.getPrototypeOf(e);return(null===t||t===Object.prototype||null===Object.getPrototypeOf(t))&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)}function a(e){if(!r(e))return e;const t={};return Object.keys(e).forEach((n=>{t[n]=a(e[n])})),t}function s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{clone:!0};const i=n.clone?{...e}:e;return r(e)&&r(t)&&Object.keys(t).forEach((o=>{r(t[o])&&Object.prototype.hasOwnProperty.call(e,o)&&r(e[o])?i[o]=s(e[o],t[o],n):n.clone?i[o]=r(t[o])?a(t[o]):t[o]:i[o]=t[o]})),i}n.d(t,{A:()=>s,Q:()=>r})},7868:(e,t,n)=>{"use strict";function r(e){let t="https://mui.com/production-error/?code="+e;for(let n=1;n<arguments.length;n+=1)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified MUI error #"+e+"; visit "+t+" for the full message."}n.d(t,{A:()=>r})},2372:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>s});var r=n(9386);const a={active:"active",checked:"checked",completed:"completed",disabled:"disabled",error:"error",expanded:"expanded",focused:"focused",focusVisible:"focusVisible",open:"open",readOnly:"readOnly",required:"required",selected:"selected"};function s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const s=a[t];return s?`${n}-${s}`:`${r.A.generate(e)}-${t}`}},2532:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(2372);function a(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const a={};return t.forEach((t=>{a[t]=(0,r.Ay)(e,t,n)})),a}},1668:(e,t,n)=>{"use strict";function r(e){return e&&e.ownerDocument||document}n.d(t,{A:()=>r})},3940:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(1668);function a(e){return(0,r.A)(e).defaultView||window}},3030:(e,t,n)=>{"use strict";function r(e,t){const n={...t};for(const a in e)if(Object.prototype.hasOwnProperty.call(e,a)){const s=a;if("components"===s||"slots"===s)n[s]={...e[s],...n[s]};else if("componentsProps"===s||"slotProps"===s){const a=e[s],i=t[s];if(i)if(a){n[s]={...i};for(const e in a)if(Object.prototype.hasOwnProperty.call(a,e)){const t=e;n[s][t]=r(a[t],i[t])}}else n[s]=i;else n[s]=a||{}}else void 0===n[s]&&(n[s]=e[s])}return n}n.d(t,{A:()=>r})},6564:(e,t,n)=>{"use strict";function r(e,t){"function"===typeof e?e(t):e&&(e.current=t)}n.d(t,{A:()=>r})},4440:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(5043);const a="undefined"!==typeof window?r.useLayoutEffect:r.useEffect},1782:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var r=n(5043),a=n(4440);const s=function(e){const t=r.useRef(e);return(0,a.A)((()=>{t.current=e})),r.useRef((function(){return(0,t.current)(...arguments)})).current}},3462:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var r=n(5043),a=n(6564);function s(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return r.useMemo((()=>t.every((e=>null==e))?null:e=>{t.forEach((t=>{(0,a.A)(t,e)}))}),t)}},5844:(e,t,n)=>{"use strict";var r;n.d(t,{A:()=>o});var a=n(5043);let s=0;const i=(r||(r=n.t(a,2)))["useId".toString()];function o(e){if(void 0!==i){const t=i();return e??t}return function(e){const[t,n]=a.useState(e),r=e||t;return a.useEffect((()=>{null==t&&(s+=1,n(`mui-${s}`))}),[t]),r}(e)}},8818:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(C){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},s={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=s[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(s[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=a[e])?r:(n=l(e,e<0?-1:0,!1),i&&(a[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?o(-e,t).neg():l(e%h|0,e/h|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var a=o(u(n,8)),s=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),d=parseInt(e.substring(i,i+l),n);if(l<8){var h=o(u(n,l));s=s.mul(h).add(o(d))}else s=(s=s.mul(a)).add(o(d))}return s.unsigned=t,s}function d(e,t){return"number"===typeof e?o(e,t):"string"===typeof e?c(e,t):l(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var v=i(1,!0);n.UONE=v;var x=i(-1);n.NEG_ONE=x;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=o(u(e,6),this.unsigned),s=this,i="";;){var l=s.div(a),c=(s.sub(l.mul(a)).toInt()>>>0).toString(e);if((s=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},I.neg=I.negate,I.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,h=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,h+=(p+=a+u)>>>16,c+=(h+=n+o)>>>16,c+=t+i,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(h&=65535),this.unsigned)},I.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=d(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,a=65535&this.high,s=this.low>>>16,i=65535&this.low,u=e.high>>>16,c=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,v=0;return b+=(v+=i*p)>>>16,y+=(b+=s*p)>>>16,b&=65535,y+=(b+=i*h)>>>16,f+=(y+=a*p)>>>16,y&=65535,f+=(y+=s*h)>>>16,y&=65535,f+=(y+=i*c)>>>16,f+=n*p+a*h+s*c+i*u,l((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,a,s;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return v;s=y}else{if(this.eq(S))return e.eq(b)||e.eq(x)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:x:(a=this.sub(e.mul(n)),s=n.add(a.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=g}for(a=this;a.gte(e);){n=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),h=o(n),p=h.mul(e);p.isNegative()||p.gt(a);)p=(h=o(n-=c,this.unsigned)).mul(e);h.isZero()&&(h=b),s=s.add(h),a=a.sub(p)}return s},I.div=I.divide,I.modulo=function(e){return r(e)||(e=d(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(e){return r(e)||(e=d(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return r(e)||(e=d(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return r(e)||(e=d(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},7780:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.BlockCipher,r=e.algo,a=[],s=[],i=[],o=[],l=[],u=[],c=[],d=[],h=[],p=[];!function(){for(var e=[],t=0;t<256;t++)e[t]=t<128?t<<1:t<<1^283;var n=0,r=0;for(t=0;t<256;t++){var f=r^r<<1^r<<2^r<<3^r<<4;f=f>>>8^255&f^99,a[n]=f,s[f]=n;var m=e[n],g=e[m],y=e[g],b=257*e[f]^16843008*f;i[n]=b<<24|b>>>8,o[n]=b<<16|b>>>16,l[n]=b<<8|b>>>24,u[n]=b,b=16843009*y^65537*g^257*m^16843008*n,c[f]=b<<24|b>>>8,d[f]=b<<16|b>>>16,h[f]=b<<8|b>>>24,p[f]=b,n?(n=m^e[e[e[y^m]]],r^=e[e[r]]):n=r=1}}();var f=[0,1,2,4,8,16,32,64,128,27,54],m=r.AES=n.extend({_doReset:function(){if(!this._nRounds||this._keyPriorReset!==this._key){for(var e=this._keyPriorReset=this._key,t=e.words,n=e.sigBytes/4,r=4*((this._nRounds=n+6)+1),s=this._keySchedule=[],i=0;i<r;i++)i<n?s[i]=t[i]:(u=s[i-1],i%n?n>6&&i%n==4&&(u=a[u>>>24]<<24|a[u>>>16&255]<<16|a[u>>>8&255]<<8|a[255&u]):(u=a[(u=u<<8|u>>>24)>>>24]<<24|a[u>>>16&255]<<16|a[u>>>8&255]<<8|a[255&u],u^=f[i/n|0]<<24),s[i]=s[i-n]^u);for(var o=this._invKeySchedule=[],l=0;l<r;l++){if(i=r-l,l%4)var u=s[i];else u=s[i-4];o[l]=l<4||i<=4?u:c[a[u>>>24]]^d[a[u>>>16&255]]^h[a[u>>>8&255]]^p[a[255&u]]}}},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._keySchedule,i,o,l,u,a)},decryptBlock:function(e,t){var n=e[t+1];e[t+1]=e[t+3],e[t+3]=n,this._doCryptBlock(e,t,this._invKeySchedule,c,d,h,p,s),n=e[t+1],e[t+1]=e[t+3],e[t+3]=n},_doCryptBlock:function(e,t,n,r,a,s,i,o){for(var l=this._nRounds,u=e[t]^n[0],c=e[t+1]^n[1],d=e[t+2]^n[2],h=e[t+3]^n[3],p=4,f=1;f<l;f++){var m=r[u>>>24]^a[c>>>16&255]^s[d>>>8&255]^i[255&h]^n[p++],g=r[c>>>24]^a[d>>>16&255]^s[h>>>8&255]^i[255&u]^n[p++],y=r[d>>>24]^a[h>>>16&255]^s[u>>>8&255]^i[255&c]^n[p++],b=r[h>>>24]^a[u>>>16&255]^s[c>>>8&255]^i[255&d]^n[p++];u=m,c=g,d=y,h=b}m=(o[u>>>24]<<24|o[c>>>16&255]<<16|o[d>>>8&255]<<8|o[255&h])^n[p++],g=(o[c>>>24]<<24|o[d>>>16&255]<<16|o[h>>>8&255]<<8|o[255&u])^n[p++],y=(o[d>>>24]<<24|o[h>>>16&255]<<16|o[u>>>8&255]<<8|o[255&c])^n[p++],b=(o[h>>>24]<<24|o[u>>>16&255]<<16|o[c>>>8&255]<<8|o[255&d])^n[p++],e[t]=m,e[t+1]=g,e[t+2]=y,e[t+3]=b},keySize:8});e.AES=n._createHelper(m)}(),t.AES)}()},6501:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.BlockCipher,r=e.algo;const a=16,s=[608135816,2242054355,320440878,57701188,2752067618,698298832,137296536,3964562569,1160258022,953160567,3193202383,887688300,3232508343,3380367581,1065670069,3041331479,2450970073,2306472731],i=[[3509652390,2564797868,805139163,3491422135,3101798381,1780907670,3128725573,4046225305,614570311,3012652279,134345442,2240740374,1667834072,1901547113,2757295779,4103290238,227898511,1921955416,1904987480,2182433518,2069144605,3260701109,2620446009,720527379,3318853667,677414384,3393288472,3101374703,2390351024,1614419982,1822297739,2954791486,3608508353,3174124327,2024746970,1432378464,3864339955,2857741204,1464375394,1676153920,1439316330,715854006,3033291828,289532110,2706671279,2087905683,3018724369,1668267050,732546397,1947742710,3462151702,2609353502,2950085171,1814351708,2050118529,680887927,999245976,1800124847,3300911131,1713906067,1641548236,4213287313,1216130144,1575780402,4018429277,3917837745,3693486850,3949271944,596196993,3549867205,258830323,2213823033,772490370,2760122372,1774776394,2652871518,566650946,4142492826,1728879713,2882767088,1783734482,3629395816,2517608232,2874225571,1861159788,326777828,3124490320,2130389656,2716951837,967770486,1724537150,2185432712,2364442137,1164943284,2105845187,998989502,3765401048,2244026483,1075463327,1455516326,1322494562,910128902,469688178,1117454909,936433444,3490320968,3675253459,1240580251,122909385,2157517691,634681816,4142456567,3825094682,3061402683,2540495037,79693498,3249098678,1084186820,1583128258,426386531,1761308591,1047286709,322548459,995290223,1845252383,2603652396,3431023940,2942221577,3202600964,3727903485,1712269319,422464435,3234572375,1170764815,3523960633,3117677531,1434042557,442511882,3600875718,1076654713,1738483198,4213154764,2393238008,3677496056,1014306527,4251020053,793779912,2902807211,842905082,4246964064,1395751752,1040244610,2656851899,3396308128,445077038,3742853595,3577915638,679411651,2892444358,2354009459,1767581616,3150600392,3791627101,3102740896,284835224,4246832056,1258075500,768725851,2589189241,3069724005,3532540348,1274779536,3789419226,2764799539,1660621633,3471099624,4011903706,913787905,3497959166,737222580,2514213453,2928710040,3937242737,1804850592,3499020752,2949064160,2386320175,2390070455,2415321851,4061277028,2290661394,2416832540,1336762016,1754252060,3520065937,3014181293,791618072,3188594551,3933548030,2332172193,3852520463,3043980520,413987798,3465142937,3030929376,4245938359,2093235073,3534596313,375366246,2157278981,2479649556,555357303,3870105701,2008414854,3344188149,4221384143,3956125452,2067696032,3594591187,2921233993,2428461,544322398,577241275,1471733935,610547355,4027169054,1432588573,1507829418,2025931657,3646575487,545086370,48609733,2200306550,1653985193,298326376,1316178497,3007786442,2064951626,458293330,2589141269,3591329599,3164325604,727753846,2179363840,146436021,1461446943,4069977195,705550613,3059967265,3887724982,4281599278,3313849956,1404054877,2845806497,146425753,1854211946],[1266315497,3048417604,3681880366,3289982499,290971e4,1235738493,2632868024,2414719590,3970600049,1771706367,1449415276,3266420449,422970021,1963543593,2690192192,3826793022,1062508698,1531092325,1804592342,2583117782,2714934279,4024971509,1294809318,4028980673,1289560198,2221992742,1669523910,35572830,157838143,1052438473,1016535060,1802137761,1753167236,1386275462,3080475397,2857371447,1040679964,2145300060,2390574316,1461121720,2956646967,4031777805,4028374788,33600511,2920084762,1018524850,629373528,3691585981,3515945977,2091462646,2486323059,586499841,988145025,935516892,3367335476,2599673255,2839830854,265290510,3972581182,2759138881,3795373465,1005194799,847297441,406762289,1314163512,1332590856,1866599683,4127851711,750260880,613907577,1450815602,3165620655,3734664991,3650291728,3012275730,3704569646,1427272223,778793252,1343938022,2676280711,2052605720,1946737175,3164576444,3914038668,3967478842,3682934266,1661551462,3294938066,4011595847,840292616,3712170807,616741398,312560963,711312465,1351876610,322626781,1910503582,271666773,2175563734,1594956187,70604529,3617834859,1007753275,1495573769,4069517037,2549218298,2663038764,504708206,2263041392,3941167025,2249088522,1514023603,1998579484,1312622330,694541497,2582060303,2151582166,1382467621,776784248,2618340202,3323268794,2497899128,2784771155,503983604,4076293799,907881277,423175695,432175456,1378068232,4145222326,3954048622,3938656102,3820766613,2793130115,2977904593,26017576,3274890735,3194772133,1700274565,1756076034,4006520079,3677328699,720338349,1533947780,354530856,688349552,3973924725,1637815568,332179504,3949051286,53804574,2852348879,3044236432,1282449977,3583942155,3416972820,4006381244,1617046695,2628476075,3002303598,1686838959,431878346,2686675385,1700445008,1080580658,1009431731,832498133,3223435511,2605976345,2271191193,2516031870,1648197032,4164389018,2548247927,300782431,375919233,238389289,3353747414,2531188641,2019080857,1475708069,455242339,2609103871,448939670,3451063019,1395535956,2413381860,1841049896,1491858159,885456874,4264095073,4001119347,1565136089,3898914787,1108368660,540939232,1173283510,2745871338,3681308437,4207628240,3343053890,4016749493,1699691293,1103962373,3625875870,2256883143,3830138730,1031889488,3479347698,1535977030,4236805024,3251091107,2132092099,1774941330,1199868427,1452454533,157007616,2904115357,342012276,595725824,1480756522,206960106,497939518,591360097,863170706,2375253569,3596610801,1814182875,2094937945,3421402208,1082520231,3463918190,2785509508,435703966,3908032597,1641649973,2842273706,3305899714,1510255612,2148256476,2655287854,3276092548,4258621189,236887753,3681803219,274041037,1734335097,3815195456,3317970021,1899903192,1026095262,4050517792,356393447,2410691914,3873677099,3682840055],[3913112168,2491498743,4132185628,2489919796,1091903735,1979897079,3170134830,3567386728,3557303409,857797738,1136121015,1342202287,507115054,2535736646,337727348,3213592640,1301675037,2528481711,1895095763,1721773893,3216771564,62756741,2142006736,835421444,2531993523,1442658625,3659876326,2882144922,676362277,1392781812,170690266,3921047035,1759253602,3611846912,1745797284,664899054,1329594018,3901205900,3045908486,2062866102,2865634940,3543621612,3464012697,1080764994,553557557,3656615353,3996768171,991055499,499776247,1265440854,648242737,3940784050,980351604,3713745714,1749149687,3396870395,4211799374,3640570775,1161844396,3125318951,1431517754,545492359,4268468663,3499529547,1437099964,2702547544,3433638243,2581715763,2787789398,1060185593,1593081372,2418618748,4260947970,69676912,2159744348,86519011,2512459080,3838209314,1220612927,3339683548,133810670,1090789135,1078426020,1569222167,845107691,3583754449,4072456591,1091646820,628848692,1613405280,3757631651,526609435,236106946,48312990,2942717905,3402727701,1797494240,859738849,992217954,4005476642,2243076622,3870952857,3732016268,765654824,3490871365,2511836413,1685915746,3888969200,1414112111,2273134842,3281911079,4080962846,172450625,2569994100,980381355,4109958455,2819808352,2716589560,2568741196,3681446669,3329971472,1835478071,660984891,3704678404,4045999559,3422617507,3040415634,1762651403,1719377915,3470491036,2693910283,3642056355,3138596744,1364962596,2073328063,1983633131,926494387,3423689081,2150032023,4096667949,1749200295,3328846651,309677260,2016342300,1779581495,3079819751,111262694,1274766160,443224088,298511866,1025883608,3806446537,1145181785,168956806,3641502830,3584813610,1689216846,3666258015,3200248200,1692713982,2646376535,4042768518,1618508792,1610833997,3523052358,4130873264,2001055236,3610705100,2202168115,4028541809,2961195399,1006657119,2006996926,3186142756,1430667929,3210227297,1314452623,4074634658,4101304120,2273951170,1399257539,3367210612,3027628629,1190975929,2062231137,2333990788,2221543033,2438960610,1181637006,548689776,2362791313,3372408396,3104550113,3145860560,296247880,1970579870,3078560182,3769228297,1714227617,3291629107,3898220290,166772364,1251581989,493813264,448347421,195405023,2709975567,677966185,3703036547,1463355134,2715995803,1338867538,1343315457,2802222074,2684532164,233230375,2599980071,2000651841,3277868038,1638401717,4028070440,3237316320,6314154,819756386,300326615,590932579,1405279636,3267499572,3150704214,2428286686,3959192993,3461946742,1862657033,1266418056,963775037,2089974820,2263052895,1917689273,448879540,3550394620,3981727096,150775221,3627908307,1303187396,508620638,2975983352,2726630617,1817252668,1876281319,1457606340,908771278,3720792119,3617206836,2455994898,1729034894,1080033504],[976866871,3556439503,2881648439,1522871579,1555064734,1336096578,3548522304,2579274686,3574697629,3205460757,3593280638,3338716283,3079412587,564236357,2993598910,1781952180,1464380207,3163844217,3332601554,1699332808,1393555694,1183702653,3581086237,1288719814,691649499,2847557200,2895455976,3193889540,2717570544,1781354906,1676643554,2592534050,3230253752,1126444790,2770207658,2633158820,2210423226,2615765581,2414155088,3127139286,673620729,2805611233,1269405062,4015350505,3341807571,4149409754,1057255273,2012875353,2162469141,2276492801,2601117357,993977747,3918593370,2654263191,753973209,36408145,2530585658,25011837,3520020182,2088578344,530523599,2918365339,1524020338,1518925132,3760827505,3759777254,1202760957,3985898139,3906192525,674977740,4174734889,2031300136,2019492241,3983892565,4153806404,3822280332,352677332,2297720250,60907813,90501309,3286998549,1016092578,2535922412,2839152426,457141659,509813237,4120667899,652014361,1966332200,2975202805,55981186,2327461051,676427537,3255491064,2882294119,3433927263,1307055953,942726286,933058658,2468411793,3933900994,4215176142,1361170020,2001714738,2830558078,3274259782,1222529897,1679025792,2729314320,3714953764,1770335741,151462246,3013232138,1682292957,1483529935,471910574,1539241949,458788160,3436315007,1807016891,3718408830,978976581,1043663428,3165965781,1927990952,4200891579,2372276910,3208408903,3533431907,1412390302,2931980059,4132332400,1947078029,3881505623,4168226417,2941484381,1077988104,1320477388,886195818,18198404,3786409e3,2509781533,112762804,3463356488,1866414978,891333506,18488651,661792760,1628790961,3885187036,3141171499,876946877,2693282273,1372485963,791857591,2686433993,3759982718,3167212022,3472953795,2716379847,445679433,3561995674,3504004811,3574258232,54117162,3331405415,2381918588,3769707343,4154350007,1140177722,4074052095,668550556,3214352940,367459370,261225585,2610173221,4209349473,3468074219,3265815641,314222801,3066103646,3808782860,282218597,3406013506,3773591054,379116347,1285071038,846784868,2669647154,3771962079,3550491691,2305946142,453669953,1268987020,3317592352,3279303384,3744833421,2610507566,3859509063,266596637,3847019092,517658769,3462560207,3443424879,370717030,4247526661,2224018117,4143653529,4112773975,2788324899,2477274417,1456262402,2901442914,1517677493,1846949527,2295493580,3734397586,2176403920,1280348187,1908823572,3871786941,846861322,1172426758,3287448474,3383383037,1655181056,3139813346,901632758,1897031941,2986607138,3066810236,3447102507,1393639104,373351379,950779232,625454576,3124240540,4148612726,2007998917,544563296,2244738638,2330496472,2058025392,1291430526,424198748,50039436,29584100,3605783033,2429876329,2791104160,1057563949,3255363231,3075367218,3463963227,1469046755,985887462]];var o={pbox:[],sbox:[]};function l(e,t){let n=t>>24&255,r=t>>16&255,a=t>>8&255,s=255&t,i=e.sbox[0][n]+e.sbox[1][r];return i^=e.sbox[2][a],i+=e.sbox[3][s],i}function u(e,t,n){let r,s=t,i=n;for(let o=0;o<a;++o)s^=e.pbox[o],i=l(e,s)^i,r=s,s=i,i=r;return r=s,s=i,i=r,i^=e.pbox[a],s^=e.pbox[a+1],{left:s,right:i}}function c(e,t,n){let r,s=t,i=n;for(let o=a+1;o>1;--o)s^=e.pbox[o],i=l(e,s)^i,r=s,s=i,i=r;return r=s,s=i,i=r,i^=e.pbox[1],s^=e.pbox[0],{left:s,right:i}}function d(e,t,n){for(let a=0;a<4;a++){e.sbox[a]=[];for(let t=0;t<256;t++)e.sbox[a][t]=i[a][t]}let r=0;for(let i=0;i<a+2;i++)e.pbox[i]=s[i]^t[r],r++,r>=n&&(r=0);let o=0,l=0,c=0;for(let s=0;s<a+2;s+=2)c=u(e,o,l),o=c.left,l=c.right,e.pbox[s]=o,e.pbox[s+1]=l;for(let a=0;a<4;a++)for(let t=0;t<256;t+=2)c=u(e,o,l),o=c.left,l=c.right,e.sbox[a][t]=o,e.sbox[a][t+1]=l;return!0}var h=r.Blowfish=n.extend({_doReset:function(){if(this._keyPriorReset!==this._key){var e=this._keyPriorReset=this._key,t=e.words,n=e.sigBytes/4;d(o,t,n)}},encryptBlock:function(e,t){var n=u(o,e[t],e[t+1]);e[t]=n.left,e[t+1]=n.right},decryptBlock:function(e,t){var n=c(o,e[t],e[t+1]);e[t]=n.left,e[t+1]=n.right},blockSize:2,keySize:4,ivSize:2});e.Blowfish=n._createHelper(h)}(),t.Blowfish)}()},2238:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8211),void(t.lib.Cipher||function(e){var n=t,r=n.lib,a=r.Base,s=r.WordArray,i=r.BufferedBlockAlgorithm,o=n.enc,l=(o.Utf8,o.Base64),u=n.algo.EvpKDF,c=r.Cipher=i.extend({cfg:a.extend(),createEncryptor:function(e,t){return this.create(this._ENC_XFORM_MODE,e,t)},createDecryptor:function(e,t){return this.create(this._DEC_XFORM_MODE,e,t)},init:function(e,t,n){this.cfg=this.cfg.extend(n),this._xformMode=e,this._key=t,this.reset()},reset:function(){i.reset.call(this),this._doReset()},process:function(e){return this._append(e),this._process()},finalize:function(e){return e&&this._append(e),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function e(e){return"string"==typeof e?v:y}return function(t){return{encrypt:function(n,r,a){return e(r).encrypt(t,n,r,a)},decrypt:function(n,r,a){return e(r).decrypt(t,n,r,a)}}}}()}),d=(r.StreamCipher=c.extend({_doFinalize:function(){return this._process(!0)},blockSize:1}),n.mode={}),h=r.BlockCipherMode=a.extend({createEncryptor:function(e,t){return this.Encryptor.create(e,t)},createDecryptor:function(e,t){return this.Decryptor.create(e,t)},init:function(e,t){this._cipher=e,this._iv=t}}),p=d.CBC=function(){var t=h.extend();function n(t,n,r){var a,s=this._iv;s?(a=s,this._iv=e):a=this._prevBlock;for(var i=0;i<r;i++)t[n+i]^=a[i]}return t.Encryptor=t.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize;n.call(this,e,t,a),r.encryptBlock(e,t),this._prevBlock=e.slice(t,t+a)}}),t.Decryptor=t.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize,s=e.slice(t,t+a);r.decryptBlock(e,t),n.call(this,e,t,a),this._prevBlock=s}}),t}(),f=(n.pad={}).Pkcs7={pad:function(e,t){for(var n=4*t,r=n-e.sigBytes%n,a=r<<24|r<<16|r<<8|r,i=[],o=0;o<r;o+=4)i.push(a);var l=s.create(i,r);e.concat(l)},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},m=(r.BlockCipher=c.extend({cfg:c.cfg.extend({mode:p,padding:f}),reset:function(){var e;c.reset.call(this);var t=this.cfg,n=t.iv,r=t.mode;this._xformMode==this._ENC_XFORM_MODE?e=r.createEncryptor:(e=r.createDecryptor,this._minBufferSize=1),this._mode&&this._mode.__creator==e?this._mode.init(this,n&&n.words):(this._mode=e.call(r,this,n&&n.words),this._mode.__creator=e)},_doProcessBlock:function(e,t){this._mode.processBlock(e,t)},_doFinalize:function(){var e,t=this.cfg.padding;return this._xformMode==this._ENC_XFORM_MODE?(t.pad(this._data,this.blockSize),e=this._process(!0)):(e=this._process(!0),t.unpad(e)),e},blockSize:4}),r.CipherParams=a.extend({init:function(e){this.mixIn(e)},toString:function(e){return(e||this.formatter).stringify(this)}})),g=(n.format={}).OpenSSL={stringify:function(e){var t=e.ciphertext,n=e.salt;return(n?s.create([1398893684,1701076831]).concat(n).concat(t):t).toString(l)},parse:function(e){var t,n=l.parse(e),r=n.words;return 1398893684==r[0]&&1701076831==r[1]&&(t=s.create(r.slice(2,4)),r.splice(0,4),n.sigBytes-=16),m.create({ciphertext:n,salt:t})}},y=r.SerializableCipher=a.extend({cfg:a.extend({format:g}),encrypt:function(e,t,n,r){r=this.cfg.extend(r);var a=e.createEncryptor(n,r),s=a.finalize(t),i=a.cfg;return m.create({ciphertext:s,key:n,iv:i.iv,algorithm:e,mode:i.mode,padding:i.padding,blockSize:e.blockSize,formatter:r.format})},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),e.createDecryptor(n,r).finalize(t.ciphertext)},_parse:function(e,t){return"string"==typeof e?t.parse(e,this):e}}),b=(n.kdf={}).OpenSSL={execute:function(e,t,n,r,a){if(r||(r=s.random(8)),a)i=u.create({keySize:t+n,hasher:a}).compute(e,r);else var i=u.create({keySize:t+n}).compute(e,r);var o=s.create(i.words.slice(t),4*n);return i.sigBytes=4*t,m.create({key:i,iv:o,salt:r})}},v=r.PasswordBasedCipher=y.extend({cfg:y.cfg.extend({kdf:b}),encrypt:function(e,t,n,r){var a=(r=this.cfg.extend(r)).kdf.execute(n,e.keySize,e.ivSize,r.salt,r.hasher);r.iv=a.iv;var s=y.encrypt.call(this,e,t,a.key,r);return s.mixIn(a),s},decrypt:function(e,t,n,r){r=this.cfg.extend(r),t=this._parse(t,r.format);var a=r.kdf.execute(n,e.keySize,e.ivSize,t.salt,r.hasher);return r.iv=a.iv,y.decrypt.call(this,e,t,a.key,r)}})}()))}()},4488:function(e,t,n){e.exports=function(){var e=e||function(e,t){var r;if("undefined"!==typeof window&&window.crypto&&(r=window.crypto),"undefined"!==typeof self&&self.crypto&&(r=self.crypto),"undefined"!==typeof globalThis&&globalThis.crypto&&(r=globalThis.crypto),!r&&"undefined"!==typeof window&&window.msCrypto&&(r=window.msCrypto),!r&&"undefined"!==typeof n.g&&n.g.crypto&&(r=n.g.crypto),!r)try{r=n(477)}catch(g){}var a=function(){if(r){if("function"===typeof r.getRandomValues)try{return r.getRandomValues(new Uint32Array(1))[0]}catch(g){}if("function"===typeof r.randomBytes)try{return r.randomBytes(4).readInt32LE()}catch(g){}}throw new Error("Native crypto module could not be used to get secure random number.")},s=Object.create||function(){function e(){}return function(t){var n;return e.prototype=t,n=new e,e.prototype=null,n}}(),i={},o=i.lib={},l=o.Base={extend:function(e){var t=s(this);return e&&t.mixIn(e),t.hasOwnProperty("init")&&this.init!==t.init||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},u=o.WordArray=l.extend({init:function(e,n){e=this.words=e||[],this.sigBytes=n!=t?n:4*e.length},toString:function(e){return(e||d).stringify(this)},concat:function(e){var t=this.words,n=e.words,r=this.sigBytes,a=e.sigBytes;if(this.clamp(),r%4)for(var s=0;s<a;s++){var i=n[s>>>2]>>>24-s%4*8&255;t[r+s>>>2]|=i<<24-(r+s)%4*8}else for(var o=0;o<a;o+=4)t[r+o>>>2]=n[o>>>2];return this.sigBytes+=a,this},clamp:function(){var t=this.words,n=this.sigBytes;t[n>>>2]&=4294967295<<32-n%4*8,t.length=e.ceil(n/4)},clone:function(){var e=l.clone.call(this);return e.words=this.words.slice(0),e},random:function(e){for(var t=[],n=0;n<e;n+=4)t.push(a());return new u.init(t,e)}}),c=i.enc={},d=c.Hex={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],a=0;a<n;a++){var s=t[a>>>2]>>>24-a%4*8&255;r.push((s>>>4).toString(16)),r.push((15&s).toString(16))}return r.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r+=2)n[r>>>3]|=parseInt(e.substr(r,2),16)<<24-r%8*4;return new u.init(n,t/2)}},h=c.Latin1={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],a=0;a<n;a++){var s=t[a>>>2]>>>24-a%4*8&255;r.push(String.fromCharCode(s))}return r.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r++)n[r>>>2]|=(255&e.charCodeAt(r))<<24-r%4*8;return new u.init(n,t)}},p=c.Utf8={stringify:function(e){try{return decodeURIComponent(escape(h.stringify(e)))}catch(t){throw new Error("Malformed UTF-8 data")}},parse:function(e){return h.parse(unescape(encodeURIComponent(e)))}},f=o.BufferedBlockAlgorithm=l.extend({reset:function(){this._data=new u.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=p.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(t){var n,r=this._data,a=r.words,s=r.sigBytes,i=this.blockSize,o=s/(4*i),l=(o=t?e.ceil(o):e.max((0|o)-this._minBufferSize,0))*i,c=e.min(4*l,s);if(l){for(var d=0;d<l;d+=i)this._doProcessBlock(a,d);n=a.splice(0,l),r.sigBytes-=c}return new u.init(n,c)},clone:function(){var e=l.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0}),m=(o.Hasher=f.extend({cfg:l.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){f.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function(e){return function(t,n){return new e.init(n).finalize(t)}},_createHmacHelper:function(e){return function(t,n){return new m.HMAC.init(e,n).finalize(t)}}}),i.algo={});return i}(Math);return e}()},8523:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib.WordArray;function r(e,t,r){for(var a=[],s=0,i=0;i<t;i++)if(i%4){var o=r[e.charCodeAt(i-1)]<<i%4*2|r[e.charCodeAt(i)]>>>6-i%4*2;a[s>>>2]|=o<<24-s%4*8,s++}return n.create(a,s)}e.enc.Base64={stringify:function(e){var t=e.words,n=e.sigBytes,r=this._map;e.clamp();for(var a=[],s=0;s<n;s+=3)for(var i=(t[s>>>2]>>>24-s%4*8&255)<<16|(t[s+1>>>2]>>>24-(s+1)%4*8&255)<<8|t[s+2>>>2]>>>24-(s+2)%4*8&255,o=0;o<4&&s+.75*o<n;o++)a.push(r.charAt(i>>>6*(3-o)&63));var l=r.charAt(64);if(l)for(;a.length%4;)a.push(l);return a.join("")},parse:function(e){var t=e.length,n=this._map,a=this._reverseMap;if(!a){a=this._reverseMap=[];for(var s=0;s<n.length;s++)a[n.charCodeAt(s)]=s}var i=n.charAt(64);if(i){var o=e.indexOf(i);-1!==o&&(t=o)}return r(e,t,a)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}}(),t.enc.Base64)}()},4646:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib.WordArray;function r(e,t,r){for(var a=[],s=0,i=0;i<t;i++)if(i%4){var o=r[e.charCodeAt(i-1)]<<i%4*2|r[e.charCodeAt(i)]>>>6-i%4*2;a[s>>>2]|=o<<24-s%4*8,s++}return n.create(a,s)}e.enc.Base64url={stringify:function(e,t){void 0===t&&(t=!0);var n=e.words,r=e.sigBytes,a=t?this._safe_map:this._map;e.clamp();for(var s=[],i=0;i<r;i+=3)for(var o=(n[i>>>2]>>>24-i%4*8&255)<<16|(n[i+1>>>2]>>>24-(i+1)%4*8&255)<<8|n[i+2>>>2]>>>24-(i+2)%4*8&255,l=0;l<4&&i+.75*l<r;l++)s.push(a.charAt(o>>>6*(3-l)&63));var u=a.charAt(64);if(u)for(;s.length%4;)s.push(u);return s.join("")},parse:function(e,t){void 0===t&&(t=!0);var n=e.length,a=t?this._safe_map:this._map,s=this._reverseMap;if(!s){s=this._reverseMap=[];for(var i=0;i<a.length;i++)s[a.charCodeAt(i)]=i}var o=a.charAt(64);if(o){var l=e.indexOf(o);-1!==l&&(n=l)}return r(e,n,s)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",_safe_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}}(),t.enc.Base64url)}()},5787:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib.WordArray,r=e.enc;function a(e){return e<<8&4278255360|e>>>8&16711935}r.Utf16=r.Utf16BE={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],a=0;a<n;a+=2){var s=t[a>>>2]>>>16-a%4*8&65535;r.push(String.fromCharCode(s))}return r.join("")},parse:function(e){for(var t=e.length,r=[],a=0;a<t;a++)r[a>>>1]|=e.charCodeAt(a)<<16-a%2*16;return n.create(r,2*t)}},r.Utf16LE={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],s=0;s<n;s+=2){var i=a(t[s>>>2]>>>16-s%4*8&65535);r.push(String.fromCharCode(i))}return r.join("")},parse:function(e){for(var t=e.length,r=[],s=0;s<t;s++)r[s>>>1]|=a(e.charCodeAt(s)<<16-s%2*16);return n.create(r,2*t)}}}(),t.enc.Utf16)}()},8211:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2002),n(4220),function(){var e=t,n=e.lib,r=n.Base,a=n.WordArray,s=e.algo,i=s.MD5,o=s.EvpKDF=r.extend({cfg:r.extend({keySize:4,hasher:i,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var n,r=this.cfg,s=r.hasher.create(),i=a.create(),o=i.words,l=r.keySize,u=r.iterations;o.length<l;){n&&s.update(n),n=s.update(e).finalize(t),s.reset();for(var c=1;c<u;c++)n=s.finalize(n),s.reset();i.concat(n)}return i.sigBytes=4*l,i}});e.EvpKDF=function(e,t,n){return o.create(n).compute(e,t)}}(),t.EvpKDF)}()},4708:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),function(){var e=t,n=e.lib.CipherParams,r=e.enc.Hex;e.format.Hex={stringify:function(e){return e.ciphertext.toString(r)},parse:function(e){var t=r.parse(e);return n.create({ciphertext:t})}}}(),t.format.Hex)}()},4220:function(e,t,n){!function(){var t;e.exports=(t=n(4488),void function(){var e=t,n=e.lib.Base,r=e.enc.Utf8;e.algo.HMAC=n.extend({init:function(e,t){e=this._hasher=new e.init,"string"==typeof t&&(t=r.parse(t));var n=e.blockSize,a=4*n;t.sigBytes>a&&(t=e.finalize(t)),t.clamp();for(var s=this._oKey=t.clone(),i=this._iKey=t.clone(),o=s.words,l=i.words,u=0;u<n;u++)o[u]^=1549556828,l[u]^=909522486;s.sigBytes=i.sigBytes=a,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher,n=t.finalize(e);return t.reset(),t.finalize(this._oKey.clone().concat(n))}})}())}()},6111:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),n(4503),n(5787),n(8523),n(4646),n(4199),n(2002),n(6368),n(1641),n(7061),n(9092),n(6600),n(7423),n(4220),n(3930),n(8211),n(2238),n(1112),n(7962),n(8049),n(6380),n(8099),n(1884),n(9132),n(4423),n(548),n(4087),n(4708),n(7780),n(9475),n(9638),n(8875),n(1659),n(6501),t)}()},4503:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){if("function"==typeof ArrayBuffer){var e=t.lib.WordArray,n=e.init,r=e.init=function(e){if(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),(e instanceof Int8Array||"undefined"!==typeof Uint8ClampedArray&&e instanceof Uint8ClampedArray||e instanceof Int16Array||e instanceof Uint16Array||e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array)&&(e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),e instanceof Uint8Array){for(var t=e.byteLength,r=[],a=0;a<t;a++)r[a>>>2]|=e[a]<<24-a%4*8;n.call(this,r,t)}else n.apply(this,arguments)};r.prototype=e}}(),t.lib.WordArray)}()},4199:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(e){var n=t,r=n.lib,a=r.WordArray,s=r.Hasher,i=n.algo,o=[];!function(){for(var t=0;t<64;t++)o[t]=4294967296*e.abs(e.sin(t+1))|0}();var l=i.MD5=s.extend({_doReset:function(){this._hash=new a.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(e,t){for(var n=0;n<16;n++){var r=t+n,a=e[r];e[r]=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8)}var s=this._hash.words,i=e[t+0],l=e[t+1],p=e[t+2],f=e[t+3],m=e[t+4],g=e[t+5],y=e[t+6],b=e[t+7],v=e[t+8],x=e[t+9],w=e[t+10],k=e[t+11],S=e[t+12],I=e[t+13],C=e[t+14],N=e[t+15],T=s[0],E=s[1],A=s[2],_=s[3];T=u(T,E,A,_,i,7,o[0]),_=u(_,T,E,A,l,12,o[1]),A=u(A,_,T,E,p,17,o[2]),E=u(E,A,_,T,f,22,o[3]),T=u(T,E,A,_,m,7,o[4]),_=u(_,T,E,A,g,12,o[5]),A=u(A,_,T,E,y,17,o[6]),E=u(E,A,_,T,b,22,o[7]),T=u(T,E,A,_,v,7,o[8]),_=u(_,T,E,A,x,12,o[9]),A=u(A,_,T,E,w,17,o[10]),E=u(E,A,_,T,k,22,o[11]),T=u(T,E,A,_,S,7,o[12]),_=u(_,T,E,A,I,12,o[13]),A=u(A,_,T,E,C,17,o[14]),T=c(T,E=u(E,A,_,T,N,22,o[15]),A,_,l,5,o[16]),_=c(_,T,E,A,y,9,o[17]),A=c(A,_,T,E,k,14,o[18]),E=c(E,A,_,T,i,20,o[19]),T=c(T,E,A,_,g,5,o[20]),_=c(_,T,E,A,w,9,o[21]),A=c(A,_,T,E,N,14,o[22]),E=c(E,A,_,T,m,20,o[23]),T=c(T,E,A,_,x,5,o[24]),_=c(_,T,E,A,C,9,o[25]),A=c(A,_,T,E,f,14,o[26]),E=c(E,A,_,T,v,20,o[27]),T=c(T,E,A,_,I,5,o[28]),_=c(_,T,E,A,p,9,o[29]),A=c(A,_,T,E,b,14,o[30]),T=d(T,E=c(E,A,_,T,S,20,o[31]),A,_,g,4,o[32]),_=d(_,T,E,A,v,11,o[33]),A=d(A,_,T,E,k,16,o[34]),E=d(E,A,_,T,C,23,o[35]),T=d(T,E,A,_,l,4,o[36]),_=d(_,T,E,A,m,11,o[37]),A=d(A,_,T,E,b,16,o[38]),E=d(E,A,_,T,w,23,o[39]),T=d(T,E,A,_,I,4,o[40]),_=d(_,T,E,A,i,11,o[41]),A=d(A,_,T,E,f,16,o[42]),E=d(E,A,_,T,y,23,o[43]),T=d(T,E,A,_,x,4,o[44]),_=d(_,T,E,A,S,11,o[45]),A=d(A,_,T,E,N,16,o[46]),T=h(T,E=d(E,A,_,T,p,23,o[47]),A,_,i,6,o[48]),_=h(_,T,E,A,b,10,o[49]),A=h(A,_,T,E,C,15,o[50]),E=h(E,A,_,T,g,21,o[51]),T=h(T,E,A,_,S,6,o[52]),_=h(_,T,E,A,f,10,o[53]),A=h(A,_,T,E,w,15,o[54]),E=h(E,A,_,T,l,21,o[55]),T=h(T,E,A,_,v,6,o[56]),_=h(_,T,E,A,N,10,o[57]),A=h(A,_,T,E,y,15,o[58]),E=h(E,A,_,T,I,21,o[59]),T=h(T,E,A,_,m,6,o[60]),_=h(_,T,E,A,k,10,o[61]),A=h(A,_,T,E,p,15,o[62]),E=h(E,A,_,T,x,21,o[63]),s[0]=s[0]+T|0,s[1]=s[1]+E|0,s[2]=s[2]+A|0,s[3]=s[3]+_|0},_doFinalize:function(){var t=this._data,n=t.words,r=8*this._nDataBytes,a=8*t.sigBytes;n[a>>>5]|=128<<24-a%32;var s=e.floor(r/4294967296),i=r;n[15+(a+64>>>9<<4)]=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),n[14+(a+64>>>9<<4)]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),t.sigBytes=4*(n.length+1),this._process();for(var o=this._hash,l=o.words,u=0;u<4;u++){var c=l[u];l[u]=16711935&(c<<8|c>>>24)|4278255360&(c<<24|c>>>8)}return o},clone:function(){var e=s.clone.call(this);return e._hash=this._hash.clone(),e}});function u(e,t,n,r,a,s,i){var o=e+(t&n|~t&r)+a+i;return(o<<s|o>>>32-s)+t}function c(e,t,n,r,a,s,i){var o=e+(t&r|n&~r)+a+i;return(o<<s|o>>>32-s)+t}function d(e,t,n,r,a,s,i){var o=e+(t^n^r)+a+i;return(o<<s|o>>>32-s)+t}function h(e,t,n,r,a,s,i){var o=e+(n^(t|~r))+a+i;return(o<<s|o>>>32-s)+t}n.MD5=s._createHelper(l),n.HmacMD5=s._createHmacHelper(l)}(Math),t.MD5)}()},1112:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.CFB=function(){var e=t.lib.BlockCipherMode.extend();function n(e,t,n,r){var a,s=this._iv;s?(a=s.slice(0),this._iv=void 0):a=this._prevBlock,r.encryptBlock(a,0);for(var i=0;i<n;i++)e[t+i]^=a[i]}return e.Encryptor=e.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize;n.call(this,e,t,a,r),this._prevBlock=e.slice(t,t+a)}}),e.Decryptor=e.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize,s=e.slice(t,t+a);n.call(this,e,t,a,r),this._prevBlock=s}}),e}(),t.mode.CFB)}()},8049:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.CTRGladman=function(){var e=t.lib.BlockCipherMode.extend();function n(e){if(255===(e>>24&255)){var t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}else e+=1<<24;return e}function r(e){return 0===(e[0]=n(e[0]))&&(e[1]=n(e[1])),e}var a=e.Encryptor=e.extend({processBlock:function(e,t){var n=this._cipher,a=n.blockSize,s=this._iv,i=this._counter;s&&(i=this._counter=s.slice(0),this._iv=void 0),r(i);var o=i.slice(0);n.encryptBlock(o,0);for(var l=0;l<a;l++)e[t+l]^=o[l]}});return e.Decryptor=a,e}(),t.mode.CTRGladman)}()},7962:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.CTR=function(){var e=t.lib.BlockCipherMode.extend(),n=e.Encryptor=e.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize,a=this._iv,s=this._counter;a&&(s=this._counter=a.slice(0),this._iv=void 0);var i=s.slice(0);n.encryptBlock(i,0),s[r-1]=s[r-1]+1|0;for(var o=0;o<r;o++)e[t+o]^=i[o]}});return e.Decryptor=n,e}(),t.mode.CTR)}()},8099:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.ECB=function(){var e=t.lib.BlockCipherMode.extend();return e.Encryptor=e.extend({processBlock:function(e,t){this._cipher.encryptBlock(e,t)}}),e.Decryptor=e.extend({processBlock:function(e,t){this._cipher.decryptBlock(e,t)}}),e}(),t.mode.ECB)}()},6380:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.OFB=function(){var e=t.lib.BlockCipherMode.extend(),n=e.Encryptor=e.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize,a=this._iv,s=this._keystream;a&&(s=this._keystream=a.slice(0),this._iv=void 0),n.encryptBlock(s,0);for(var i=0;i<r;i++)e[t+i]^=s[i]}});return e.Decryptor=n,e}(),t.mode.OFB)}()},1884:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.AnsiX923={pad:function(e,t){var n=e.sigBytes,r=4*t,a=r-n%r,s=n+a-1;e.clamp(),e.words[s>>>2]|=a<<24-s%4*8,e.sigBytes+=a},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},t.pad.Ansix923)}()},9132:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.Iso10126={pad:function(e,n){var r=4*n,a=r-e.sigBytes%r;e.concat(t.lib.WordArray.random(a-1)).concat(t.lib.WordArray.create([a<<24],1))},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},t.pad.Iso10126)}()},4423:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.Iso97971={pad:function(e,n){e.concat(t.lib.WordArray.create([2147483648],1)),t.pad.ZeroPadding.pad(e,n)},unpad:function(e){t.pad.ZeroPadding.unpad(e),e.sigBytes--}},t.pad.Iso97971)}()},4087:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.NoPadding={pad:function(){},unpad:function(){}},t.pad.NoPadding)}()},548:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.ZeroPadding={pad:function(e,t){var n=4*t;e.clamp(),e.sigBytes+=n-(e.sigBytes%n||n)},unpad:function(e){var t=e.words,n=e.sigBytes-1;for(n=e.sigBytes-1;n>=0;n--)if(t[n>>>2]>>>24-n%4*8&255){e.sigBytes=n+1;break}}},t.pad.ZeroPadding)}()},3930:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(6368),n(4220),function(){var e=t,n=e.lib,r=n.Base,a=n.WordArray,s=e.algo,i=s.SHA256,o=s.HMAC,l=s.PBKDF2=r.extend({cfg:r.extend({keySize:4,hasher:i,iterations:25e4}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var n=this.cfg,r=o.create(n.hasher,e),s=a.create(),i=a.create([1]),l=s.words,u=i.words,c=n.keySize,d=n.iterations;l.length<c;){var h=r.update(t).finalize(i);r.reset();for(var p=h.words,f=p.length,m=h,g=1;g<d;g++){m=r.finalize(m),r.reset();for(var y=m.words,b=0;b<f;b++)p[b]^=y[b]}s.concat(h),u[0]++}return s.sigBytes=4*c,s}});e.PBKDF2=function(e,t,n){return l.create(n).compute(e,t)}}(),t.PBKDF2)}()},1659:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.StreamCipher,r=e.algo,a=[],s=[],i=[],o=r.RabbitLegacy=n.extend({_doReset:function(){var e=this._key.words,t=this.cfg.iv,n=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],r=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];this._b=0;for(var a=0;a<4;a++)l.call(this);for(a=0;a<8;a++)r[a]^=n[a+4&7];if(t){var s=t.words,i=s[0],o=s[1],u=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),c=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),d=u>>>16|4294901760&c,h=c<<16|65535&u;for(r[0]^=u,r[1]^=d,r[2]^=c,r[3]^=h,r[4]^=u,r[5]^=d,r[6]^=c,r[7]^=h,a=0;a<4;a++)l.call(this)}},_doProcessBlock:function(e,t){var n=this._X;l.call(this),a[0]=n[0]^n[5]>>>16^n[3]<<16,a[1]=n[2]^n[7]>>>16^n[5]<<16,a[2]=n[4]^n[1]>>>16^n[7]<<16,a[3]=n[6]^n[3]>>>16^n[1]<<16;for(var r=0;r<4;r++)a[r]=16711935&(a[r]<<8|a[r]>>>24)|4278255360&(a[r]<<24|a[r]>>>8),e[t+r]^=a[r]},blockSize:4,ivSize:2});function l(){for(var e=this._X,t=this._C,n=0;n<8;n++)s[n]=t[n];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<s[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<s[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<s[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<s[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<s[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<s[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<s[6]>>>0?1:0)|0,this._b=t[7]>>>0<s[7]>>>0?1:0,n=0;n<8;n++){var r=e[n]+t[n],a=65535&r,o=r>>>16,l=((a*a>>>17)+a*o>>>15)+o*o,u=((4294901760&r)*r|0)+((65535&r)*r|0);i[n]=l^u}e[0]=i[0]+(i[7]<<16|i[7]>>>16)+(i[6]<<16|i[6]>>>16)|0,e[1]=i[1]+(i[0]<<8|i[0]>>>24)+i[7]|0,e[2]=i[2]+(i[1]<<16|i[1]>>>16)+(i[0]<<16|i[0]>>>16)|0,e[3]=i[3]+(i[2]<<8|i[2]>>>24)+i[1]|0,e[4]=i[4]+(i[3]<<16|i[3]>>>16)+(i[2]<<16|i[2]>>>16)|0,e[5]=i[5]+(i[4]<<8|i[4]>>>24)+i[3]|0,e[6]=i[6]+(i[5]<<16|i[5]>>>16)+(i[4]<<16|i[4]>>>16)|0,e[7]=i[7]+(i[6]<<8|i[6]>>>24)+i[5]|0}e.RabbitLegacy=n._createHelper(o)}(),t.RabbitLegacy)}()},8875:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.StreamCipher,r=e.algo,a=[],s=[],i=[],o=r.Rabbit=n.extend({_doReset:function(){for(var e=this._key.words,t=this.cfg.iv,n=0;n<4;n++)e[n]=16711935&(e[n]<<8|e[n]>>>24)|4278255360&(e[n]<<24|e[n]>>>8);var r=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],a=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];for(this._b=0,n=0;n<4;n++)l.call(this);for(n=0;n<8;n++)a[n]^=r[n+4&7];if(t){var s=t.words,i=s[0],o=s[1],u=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),c=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),d=u>>>16|4294901760&c,h=c<<16|65535&u;for(a[0]^=u,a[1]^=d,a[2]^=c,a[3]^=h,a[4]^=u,a[5]^=d,a[6]^=c,a[7]^=h,n=0;n<4;n++)l.call(this)}},_doProcessBlock:function(e,t){var n=this._X;l.call(this),a[0]=n[0]^n[5]>>>16^n[3]<<16,a[1]=n[2]^n[7]>>>16^n[5]<<16,a[2]=n[4]^n[1]>>>16^n[7]<<16,a[3]=n[6]^n[3]>>>16^n[1]<<16;for(var r=0;r<4;r++)a[r]=16711935&(a[r]<<8|a[r]>>>24)|4278255360&(a[r]<<24|a[r]>>>8),e[t+r]^=a[r]},blockSize:4,ivSize:2});function l(){for(var e=this._X,t=this._C,n=0;n<8;n++)s[n]=t[n];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<s[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<s[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<s[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<s[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<s[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<s[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<s[6]>>>0?1:0)|0,this._b=t[7]>>>0<s[7]>>>0?1:0,n=0;n<8;n++){var r=e[n]+t[n],a=65535&r,o=r>>>16,l=((a*a>>>17)+a*o>>>15)+o*o,u=((4294901760&r)*r|0)+((65535&r)*r|0);i[n]=l^u}e[0]=i[0]+(i[7]<<16|i[7]>>>16)+(i[6]<<16|i[6]>>>16)|0,e[1]=i[1]+(i[0]<<8|i[0]>>>24)+i[7]|0,e[2]=i[2]+(i[1]<<16|i[1]>>>16)+(i[0]<<16|i[0]>>>16)|0,e[3]=i[3]+(i[2]<<8|i[2]>>>24)+i[1]|0,e[4]=i[4]+(i[3]<<16|i[3]>>>16)+(i[2]<<16|i[2]>>>16)|0,e[5]=i[5]+(i[4]<<8|i[4]>>>24)+i[3]|0,e[6]=i[6]+(i[5]<<16|i[5]>>>16)+(i[4]<<16|i[4]>>>16)|0,e[7]=i[7]+(i[6]<<8|i[6]>>>24)+i[5]|0}e.Rabbit=n._createHelper(o)}(),t.Rabbit)}()},9638:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.StreamCipher,r=e.algo,a=r.RC4=n.extend({_doReset:function(){for(var e=this._key,t=e.words,n=e.sigBytes,r=this._S=[],a=0;a<256;a++)r[a]=a;a=0;for(var s=0;a<256;a++){var i=a%n,o=t[i>>>2]>>>24-i%4*8&255;s=(s+r[a]+o)%256;var l=r[a];r[a]=r[s],r[s]=l}this._i=this._j=0},_doProcessBlock:function(e,t){e[t]^=s.call(this)},keySize:8,ivSize:0});function s(){for(var e=this._S,t=this._i,n=this._j,r=0,a=0;a<4;a++){n=(n+e[t=(t+1)%256])%256;var s=e[t];e[t]=e[n],e[n]=s,r|=e[(e[t]+e[n])%256]<<24-8*a}return this._i=t,this._j=n,r}e.RC4=n._createHelper(a);var i=r.RC4Drop=a.extend({cfg:a.cfg.extend({drop:192}),_doReset:function(){a._doReset.call(this);for(var e=this.cfg.drop;e>0;e--)s.call(this)}});e.RC4Drop=n._createHelper(i)}(),t.RC4)}()},7423:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib,r=n.WordArray,a=n.Hasher,s=e.algo,i=r.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),o=r.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),l=r.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),u=r.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),c=r.create([0,1518500249,1859775393,2400959708,2840853838]),d=r.create([1352829926,1548603684,1836072691,2053994217,0]),h=s.RIPEMD160=a.extend({_doReset:function(){this._hash=r.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var n=0;n<16;n++){var r=t+n,a=e[r];e[r]=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8)}var s,h,v,x,w,k,S,I,C,N,T,E=this._hash.words,A=c.words,_=d.words,$=i.words,R=o.words,D=l.words,M=u.words;for(k=s=E[0],S=h=E[1],I=v=E[2],C=x=E[3],N=w=E[4],n=0;n<80;n+=1)T=s+e[t+$[n]]|0,T+=n<16?p(h,v,x)+A[0]:n<32?f(h,v,x)+A[1]:n<48?m(h,v,x)+A[2]:n<64?g(h,v,x)+A[3]:y(h,v,x)+A[4],T=(T=b(T|=0,D[n]))+w|0,s=w,w=x,x=b(v,10),v=h,h=T,T=k+e[t+R[n]]|0,T+=n<16?y(S,I,C)+_[0]:n<32?g(S,I,C)+_[1]:n<48?m(S,I,C)+_[2]:n<64?f(S,I,C)+_[3]:p(S,I,C)+_[4],T=(T=b(T|=0,M[n]))+N|0,k=N,N=C,C=b(I,10),I=S,S=T;T=E[1]+v+C|0,E[1]=E[2]+x+N|0,E[2]=E[3]+w+k|0,E[3]=E[4]+s+S|0,E[4]=E[0]+h+I|0,E[0]=T},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;t[r>>>5]|=128<<24-r%32,t[14+(r+64>>>9<<4)]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8),e.sigBytes=4*(t.length+1),this._process();for(var a=this._hash,s=a.words,i=0;i<5;i++){var o=s[i];s[i]=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8)}return a},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}});function p(e,t,n){return e^t^n}function f(e,t,n){return e&t|~e&n}function m(e,t,n){return(e|~t)^n}function g(e,t,n){return e&n|t&~n}function y(e,t,n){return e^(t|~n)}function b(e,t){return e<<t|e>>>32-t}e.RIPEMD160=a._createHelper(h),e.HmacRIPEMD160=a._createHmacHelper(h)}(Math),t.RIPEMD160)}()},2002:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib,r=n.WordArray,a=n.Hasher,s=e.algo,i=[],o=s.SHA1=a.extend({_doReset:function(){this._hash=new r.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],a=n[1],s=n[2],o=n[3],l=n[4],u=0;u<80;u++){if(u<16)i[u]=0|e[t+u];else{var c=i[u-3]^i[u-8]^i[u-14]^i[u-16];i[u]=c<<1|c>>>31}var d=(r<<5|r>>>27)+l+i[u];d+=u<20?1518500249+(a&s|~a&o):u<40?1859775393+(a^s^o):u<60?(a&s|a&o|s&o)-1894007588:(a^s^o)-899497514,l=o,o=s,s=a<<30|a>>>2,a=r,r=d}n[0]=n[0]+r|0,n[1]=n[1]+a|0,n[2]=n[2]+s|0,n[3]=n[3]+o|0,n[4]=n[4]+l|0},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;return t[r>>>5]|=128<<24-r%32,t[14+(r+64>>>9<<4)]=Math.floor(n/4294967296),t[15+(r+64>>>9<<4)]=n,e.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}});e.SHA1=a._createHelper(o),e.HmacSHA1=a._createHmacHelper(o)}(),t.SHA1)}()},1641:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(6368),function(){var e=t,n=e.lib.WordArray,r=e.algo,a=r.SHA256,s=r.SHA224=a.extend({_doReset:function(){this._hash=new n.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var e=a._doFinalize.call(this);return e.sigBytes-=4,e}});e.SHA224=a._createHelper(s),e.HmacSHA224=a._createHmacHelper(s)}(),t.SHA224)}()},6368:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(e){var n=t,r=n.lib,a=r.WordArray,s=r.Hasher,i=n.algo,o=[],l=[];!function(){function t(t){for(var n=e.sqrt(t),r=2;r<=n;r++)if(!(t%r))return!1;return!0}function n(e){return 4294967296*(e-(0|e))|0}for(var r=2,a=0;a<64;)t(r)&&(a<8&&(o[a]=n(e.pow(r,.5))),l[a]=n(e.pow(r,1/3)),a++),r++}();var u=[],c=i.SHA256=s.extend({_doReset:function(){this._hash=new a.init(o.slice(0))},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],a=n[1],s=n[2],i=n[3],o=n[4],c=n[5],d=n[6],h=n[7],p=0;p<64;p++){if(p<16)u[p]=0|e[t+p];else{var f=u[p-15],m=(f<<25|f>>>7)^(f<<14|f>>>18)^f>>>3,g=u[p-2],y=(g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10;u[p]=m+u[p-7]+y+u[p-16]}var b=r&a^r&s^a&s,v=(r<<30|r>>>2)^(r<<19|r>>>13)^(r<<10|r>>>22),x=h+((o<<26|o>>>6)^(o<<21|o>>>11)^(o<<7|o>>>25))+(o&c^~o&d)+l[p]+u[p];h=d,d=c,c=o,o=i+x|0,i=s,s=a,a=r,r=x+(v+b)|0}n[0]=n[0]+r|0,n[1]=n[1]+a|0,n[2]=n[2]+s|0,n[3]=n[3]+i|0,n[4]=n[4]+o|0,n[5]=n[5]+c|0,n[6]=n[6]+d|0,n[7]=n[7]+h|0},_doFinalize:function(){var t=this._data,n=t.words,r=8*this._nDataBytes,a=8*t.sigBytes;return n[a>>>5]|=128<<24-a%32,n[14+(a+64>>>9<<4)]=e.floor(r/4294967296),n[15+(a+64>>>9<<4)]=r,t.sigBytes=4*n.length,this._process(),this._hash},clone:function(){var e=s.clone.call(this);return e._hash=this._hash.clone(),e}});n.SHA256=s._createHelper(c),n.HmacSHA256=s._createHmacHelper(c)}(Math),t.SHA256)}()},6600:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),function(e){var n=t,r=n.lib,a=r.WordArray,s=r.Hasher,i=n.x64.Word,o=n.algo,l=[],u=[],c=[];!function(){for(var e=1,t=0,n=0;n<24;n++){l[e+5*t]=(n+1)*(n+2)/2%64;var r=(2*e+3*t)%5;e=t%5,t=r}for(e=0;e<5;e++)for(t=0;t<5;t++)u[e+5*t]=t+(2*e+3*t)%5*5;for(var a=1,s=0;s<24;s++){for(var o=0,d=0,h=0;h<7;h++){if(1&a){var p=(1<<h)-1;p<32?d^=1<<p:o^=1<<p-32}128&a?a=a<<1^113:a<<=1}c[s]=i.create(o,d)}}();var d=[];!function(){for(var e=0;e<25;e++)d[e]=i.create()}();var h=o.SHA3=s.extend({cfg:s.cfg.extend({outputLength:512}),_doReset:function(){for(var e=this._state=[],t=0;t<25;t++)e[t]=new i.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(e,t){for(var n=this._state,r=this.blockSize/2,a=0;a<r;a++){var s=e[t+2*a],i=e[t+2*a+1];s=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),i=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),(E=n[a]).high^=i,E.low^=s}for(var o=0;o<24;o++){for(var h=0;h<5;h++){for(var p=0,f=0,m=0;m<5;m++)p^=(E=n[h+5*m]).high,f^=E.low;var g=d[h];g.high=p,g.low=f}for(h=0;h<5;h++){var y=d[(h+4)%5],b=d[(h+1)%5],v=b.high,x=b.low;for(p=y.high^(v<<1|x>>>31),f=y.low^(x<<1|v>>>31),m=0;m<5;m++)(E=n[h+5*m]).high^=p,E.low^=f}for(var w=1;w<25;w++){var k=(E=n[w]).high,S=E.low,I=l[w];I<32?(p=k<<I|S>>>32-I,f=S<<I|k>>>32-I):(p=S<<I-32|k>>>64-I,f=k<<I-32|S>>>64-I);var C=d[u[w]];C.high=p,C.low=f}var N=d[0],T=n[0];for(N.high=T.high,N.low=T.low,h=0;h<5;h++)for(m=0;m<5;m++){var E=n[w=h+5*m],A=d[w],_=d[(h+1)%5+5*m],$=d[(h+2)%5+5*m];E.high=A.high^~_.high&$.high,E.low=A.low^~_.low&$.low}E=n[0];var R=c[o];E.high^=R.high,E.low^=R.low}},_doFinalize:function(){var t=this._data,n=t.words,r=(this._nDataBytes,8*t.sigBytes),s=32*this.blockSize;n[r>>>5]|=1<<24-r%32,n[(e.ceil((r+1)/s)*s>>>5)-1]|=128,t.sigBytes=4*n.length,this._process();for(var i=this._state,o=this.cfg.outputLength/8,l=o/8,u=[],c=0;c<l;c++){var d=i[c],h=d.high,p=d.low;h=16711935&(h<<8|h>>>24)|4278255360&(h<<24|h>>>8),p=16711935&(p<<8|p>>>24)|4278255360&(p<<24|p>>>8),u.push(p),u.push(h)}return new a.init(u,o)},clone:function(){for(var e=s.clone.call(this),t=e._state=this._state.slice(0),n=0;n<25;n++)t[n]=t[n].clone();return e}});n.SHA3=s._createHelper(h),n.HmacSHA3=s._createHmacHelper(h)}(Math),t.SHA3)}()},9092:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),n(7061),function(){var e=t,n=e.x64,r=n.Word,a=n.WordArray,s=e.algo,i=s.SHA512,o=s.SHA384=i.extend({_doReset:function(){this._hash=new a.init([new r.init(3418070365,3238371032),new r.init(1654270250,914150663),new r.init(2438529370,812702999),new r.init(355462360,4144912697),new r.init(1731405415,4290775857),new r.init(2394180231,1750603025),new r.init(3675008525,1694076839),new r.init(1203062813,3204075428)])},_doFinalize:function(){var e=i._doFinalize.call(this);return e.sigBytes-=16,e}});e.SHA384=i._createHelper(o),e.HmacSHA384=i._createHmacHelper(o)}(),t.SHA384)}()},7061:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),function(){var e=t,n=e.lib.Hasher,r=e.x64,a=r.Word,s=r.WordArray,i=e.algo;function o(){return a.create.apply(a,arguments)}var l=[o(1116352408,3609767458),o(1899447441,602891725),o(3049323471,3964484399),o(3921009573,2173295548),o(961987163,4081628472),o(1508970993,3053834265),o(2453635748,2937671579),o(2870763221,3664609560),o(3624381080,2734883394),o(310598401,1164996542),o(607225278,1323610764),o(1426881987,3590304994),o(1925078388,4068182383),o(2162078206,991336113),o(2614888103,633803317),o(3248222580,3479774868),o(3835390401,2666613458),o(4022224774,944711139),o(264347078,2341262773),o(604807628,2007800933),o(770255983,1495990901),o(1249150122,1856431235),o(1555081692,3175218132),o(1996064986,2198950837),o(2554220882,3999719339),o(2821834349,766784016),o(2952996808,2566594879),o(3210313671,3203337956),o(3336571891,1034457026),o(3584528711,2466948901),o(113926993,3758326383),o(338241895,168717936),o(666307205,1188179964),o(773529912,1546045734),o(1294757372,1522805485),o(1396182291,2643833823),o(1695183700,2343527390),o(1986661051,1014477480),o(2177026350,1206759142),o(2456956037,344077627),o(2730485921,1290863460),o(2820302411,3158454273),o(3259730800,3505952657),o(3345764771,106217008),o(3516065817,3606008344),o(3600352804,1432725776),o(4094571909,1467031594),o(275423344,851169720),o(430227734,3100823752),o(506948616,1363258195),o(659060556,3750685593),o(883997877,3785050280),o(958139571,3318307427),o(1322822218,3812723403),o(1537002063,2003034995),o(1747873779,3602036899),o(1955562222,1575990012),o(2024104815,1125592928),o(2227730452,2716904306),o(2361852424,442776044),o(2428436474,593698344),o(2756734187,3733110249),o(3204031479,2999351573),o(3329325298,3815920427),o(3391569614,3928383900),o(3515267271,566280711),o(3940187606,3454069534),o(4118630271,4000239992),o(116418474,1914138554),o(174292421,2731055270),o(289380356,3203993006),o(460393269,320620315),o(685471733,587496836),o(852142971,1086792851),o(1017036298,365543100),o(1126000580,2618297676),o(1288033470,3409855158),o(1501505948,4234509866),o(1607167915,987167468),o(1816402316,1246189591)],u=[];!function(){for(var e=0;e<80;e++)u[e]=o()}();var c=i.SHA512=n.extend({_doReset:function(){this._hash=new s.init([new a.init(1779033703,4089235720),new a.init(3144134277,2227873595),new a.init(1013904242,4271175723),new a.init(2773480762,1595750129),new a.init(1359893119,2917565137),new a.init(2600822924,725511199),new a.init(528734635,4215389547),new a.init(1541459225,327033209)])},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],a=n[1],s=n[2],i=n[3],o=n[4],c=n[5],d=n[6],h=n[7],p=r.high,f=r.low,m=a.high,g=a.low,y=s.high,b=s.low,v=i.high,x=i.low,w=o.high,k=o.low,S=c.high,I=c.low,C=d.high,N=d.low,T=h.high,E=h.low,A=p,_=f,$=m,R=g,D=y,M=b,F=v,O=x,P=w,L=k,z=S,B=I,W=C,V=N,U=T,j=E,G=0;G<80;G++){var H,q,K=u[G];if(G<16)q=K.high=0|e[t+2*G],H=K.low=0|e[t+2*G+1];else{var X=u[G-15],Y=X.high,Q=X.low,J=(Y>>>1|Q<<31)^(Y>>>8|Q<<24)^Y>>>7,Z=(Q>>>1|Y<<31)^(Q>>>8|Y<<24)^(Q>>>7|Y<<25),ee=u[G-2],te=ee.high,ne=ee.low,re=(te>>>19|ne<<13)^(te<<3|ne>>>29)^te>>>6,ae=(ne>>>19|te<<13)^(ne<<3|te>>>29)^(ne>>>6|te<<26),se=u[G-7],ie=se.high,oe=se.low,le=u[G-16],ue=le.high,ce=le.low;q=(q=(q=J+ie+((H=Z+oe)>>>0<Z>>>0?1:0))+re+((H+=ae)>>>0<ae>>>0?1:0))+ue+((H+=ce)>>>0<ce>>>0?1:0),K.high=q,K.low=H}var de,he=P&z^~P&W,pe=L&B^~L&V,fe=A&$^A&D^$&D,me=_&R^_&M^R&M,ge=(A>>>28|_<<4)^(A<<30|_>>>2)^(A<<25|_>>>7),ye=(_>>>28|A<<4)^(_<<30|A>>>2)^(_<<25|A>>>7),be=(P>>>14|L<<18)^(P>>>18|L<<14)^(P<<23|L>>>9),ve=(L>>>14|P<<18)^(L>>>18|P<<14)^(L<<23|P>>>9),xe=l[G],we=xe.high,ke=xe.low,Se=U+be+((de=j+ve)>>>0<j>>>0?1:0),Ie=ye+me;U=W,j=V,W=z,V=B,z=P,B=L,P=F+(Se=(Se=(Se=Se+he+((de+=pe)>>>0<pe>>>0?1:0))+we+((de+=ke)>>>0<ke>>>0?1:0))+q+((de+=H)>>>0<H>>>0?1:0))+((L=O+de|0)>>>0<O>>>0?1:0)|0,F=D,O=M,D=$,M=R,$=A,R=_,A=Se+(ge+fe+(Ie>>>0<ye>>>0?1:0))+((_=de+Ie|0)>>>0<de>>>0?1:0)|0}f=r.low=f+_,r.high=p+A+(f>>>0<_>>>0?1:0),g=a.low=g+R,a.high=m+$+(g>>>0<R>>>0?1:0),b=s.low=b+M,s.high=y+D+(b>>>0<M>>>0?1:0),x=i.low=x+O,i.high=v+F+(x>>>0<O>>>0?1:0),k=o.low=k+L,o.high=w+P+(k>>>0<L>>>0?1:0),I=c.low=I+B,c.high=S+z+(I>>>0<B>>>0?1:0),N=d.low=N+V,d.high=C+W+(N>>>0<V>>>0?1:0),E=h.low=E+j,h.high=T+U+(E>>>0<j>>>0?1:0)},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;return t[r>>>5]|=128<<24-r%32,t[30+(r+128>>>10<<5)]=Math.floor(n/4294967296),t[31+(r+128>>>10<<5)]=n,e.sigBytes=4*t.length,this._process(),this._hash.toX32()},clone:function(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e},blockSize:32});e.SHA512=n._createHelper(c),e.HmacSHA512=n._createHmacHelper(c)}(),t.SHA512)}()},9475:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib,r=n.WordArray,a=n.BlockCipher,s=e.algo,i=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],o=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],l=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],u=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],c=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],d=s.DES=a.extend({_doReset:function(){for(var e=this._key.words,t=[],n=0;n<56;n++){var r=i[n]-1;t[n]=e[r>>>5]>>>31-r%32&1}for(var a=this._subKeys=[],s=0;s<16;s++){var u=a[s]=[],c=l[s];for(n=0;n<24;n++)u[n/6|0]|=t[(o[n]-1+c)%28]<<31-n%6,u[4+(n/6|0)]|=t[28+(o[n+24]-1+c)%28]<<31-n%6;for(u[0]=u[0]<<1|u[0]>>>31,n=1;n<7;n++)u[n]=u[n]>>>4*(n-1)+3;u[7]=u[7]<<5|u[7]>>>27}var d=this._invSubKeys=[];for(n=0;n<16;n++)d[n]=a[15-n]},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._subKeys)},decryptBlock:function(e,t){this._doCryptBlock(e,t,this._invSubKeys)},_doCryptBlock:function(e,t,n){this._lBlock=e[t],this._rBlock=e[t+1],h.call(this,4,252645135),h.call(this,16,65535),p.call(this,2,858993459),p.call(this,8,16711935),h.call(this,1,1431655765);for(var r=0;r<16;r++){for(var a=n[r],s=this._lBlock,i=this._rBlock,o=0,l=0;l<8;l++)o|=u[l][((i^a[l])&c[l])>>>0];this._lBlock=i,this._rBlock=s^o}var d=this._lBlock;this._lBlock=this._rBlock,this._rBlock=d,h.call(this,1,1431655765),p.call(this,8,16711935),p.call(this,2,858993459),h.call(this,16,65535),h.call(this,4,252645135),e[t]=this._lBlock,e[t+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});function h(e,t){var n=(this._lBlock>>>e^this._rBlock)&t;this._rBlock^=n,this._lBlock^=n<<e}function p(e,t){var n=(this._rBlock>>>e^this._lBlock)&t;this._lBlock^=n,this._rBlock^=n<<e}e.DES=a._createHelper(d);var f=s.TripleDES=a.extend({_doReset:function(){var e=this._key.words;if(2!==e.length&&4!==e.length&&e.length<6)throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");var t=e.slice(0,2),n=e.length<4?e.slice(0,2):e.slice(2,4),a=e.length<6?e.slice(0,2):e.slice(4,6);this._des1=d.createEncryptor(r.create(t)),this._des2=d.createEncryptor(r.create(n)),this._des3=d.createEncryptor(r.create(a))},encryptBlock:function(e,t){this._des1.encryptBlock(e,t),this._des2.decryptBlock(e,t),this._des3.encryptBlock(e,t)},decryptBlock:function(e,t){this._des3.decryptBlock(e,t),this._des2.encryptBlock(e,t),this._des1.decryptBlock(e,t)},keySize:6,ivSize:2,blockSize:2});e.TripleDES=a._createHelper(f)}(),t.TripleDES)}()},9749:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(e){var n=t,r=n.lib,a=r.Base,s=r.WordArray,i=n.x64={};i.Word=a.extend({init:function(e,t){this.high=e,this.low=t}}),i.WordArray=a.extend({init:function(t,n){t=this.words=t||[],this.sigBytes=n!=e?n:8*t.length},toX32:function(){for(var e=this.words,t=e.length,n=[],r=0;r<t;r++){var a=e[r];n.push(a.high),n.push(a.low)}return s.create(n,this.sigBytes)},clone:function(){for(var e=a.clone.call(this),t=e.words=this.words.slice(0),n=t.length,r=0;r<n;r++)t[r]=t[r].clone();return e}})}(),t)}()},446:function(e){e.exports=function(){"use strict";var e=1e3,t=6e4,n=36e5,r="millisecond",a="second",s="minute",i="hour",o="day",l="week",u="month",c="quarter",d="year",h="date",p="Invalid Date",f=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,m=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,g={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(e){var t=["th","st","nd","rd"],n=e%100;return"["+e+(t[(n-20)%10]||t[n]||t[0])+"]"}},y=function(e,t,n){var r=String(e);return!r||r.length>=t?e:""+Array(t+1-r.length).join(n)+e},b={s:y,z:function(e){var t=-e.utcOffset(),n=Math.abs(t),r=Math.floor(n/60),a=n%60;return(t<=0?"+":"-")+y(r,2,"0")+":"+y(a,2,"0")},m:function e(t,n){if(t.date()<n.date())return-e(n,t);var r=12*(n.year()-t.year())+(n.month()-t.month()),a=t.clone().add(r,u),s=n-a<0,i=t.clone().add(r+(s?-1:1),u);return+(-(r+(n-a)/(s?a-i:i-a))||0)},a:function(e){return e<0?Math.ceil(e)||0:Math.floor(e)},p:function(e){return{M:u,y:d,w:l,d:o,D:h,h:i,m:s,s:a,ms:r,Q:c}[e]||String(e||"").toLowerCase().replace(/s$/,"")},u:function(e){return void 0===e}},v="en",x={};x[v]=g;var w="$isDayjsObject",k=function(e){return e instanceof N||!(!e||!e[w])},S=function e(t,n,r){var a;if(!t)return v;if("string"==typeof t){var s=t.toLowerCase();x[s]&&(a=s),n&&(x[s]=n,a=s);var i=t.split("-");if(!a&&i.length>1)return e(i[0])}else{var o=t.name;x[o]=t,a=o}return!r&&a&&(v=a),a||!r&&v},I=function(e,t){if(k(e))return e.clone();var n="object"==typeof t?t:{};return n.date=e,n.args=arguments,new N(n)},C=b;C.l=S,C.i=k,C.w=function(e,t){return I(e,{locale:t.$L,utc:t.$u,x:t.$x,$offset:t.$offset})};var N=function(){function g(e){this.$L=S(e.locale,null,!0),this.parse(e),this.$x=this.$x||e.x||{},this[w]=!0}var y=g.prototype;return y.parse=function(e){this.$d=function(e){var t=e.date,n=e.utc;if(null===t)return new Date(NaN);if(C.u(t))return new Date;if(t instanceof Date)return new Date(t);if("string"==typeof t&&!/Z$/i.test(t)){var r=t.match(f);if(r){var a=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],a,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],a,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(t)}(e),this.init()},y.init=function(){var e=this.$d;this.$y=e.getFullYear(),this.$M=e.getMonth(),this.$D=e.getDate(),this.$W=e.getDay(),this.$H=e.getHours(),this.$m=e.getMinutes(),this.$s=e.getSeconds(),this.$ms=e.getMilliseconds()},y.$utils=function(){return C},y.isValid=function(){return!(this.$d.toString()===p)},y.isSame=function(e,t){var n=I(e);return this.startOf(t)<=n&&n<=this.endOf(t)},y.isAfter=function(e,t){return I(e)<this.startOf(t)},y.isBefore=function(e,t){return this.endOf(t)<I(e)},y.$g=function(e,t,n){return C.u(e)?this[t]:this.set(n,e)},y.unix=function(){return Math.floor(this.valueOf()/1e3)},y.valueOf=function(){return this.$d.getTime()},y.startOf=function(e,t){var n=this,r=!!C.u(t)||t,c=C.p(e),p=function(e,t){var a=C.w(n.$u?Date.UTC(n.$y,t,e):new Date(n.$y,t,e),n);return r?a:a.endOf(o)},f=function(e,t){return C.w(n.toDate()[e].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(t)),n)},m=this.$W,g=this.$M,y=this.$D,b="set"+(this.$u?"UTC":"");switch(c){case d:return r?p(1,0):p(31,11);case u:return r?p(1,g):p(0,g+1);case l:var v=this.$locale().weekStart||0,x=(m<v?m+7:m)-v;return p(r?y-x:y+(6-x),g);case o:case h:return f(b+"Hours",0);case i:return f(b+"Minutes",1);case s:return f(b+"Seconds",2);case a:return f(b+"Milliseconds",3);default:return this.clone()}},y.endOf=function(e){return this.startOf(e,!1)},y.$set=function(e,t){var n,l=C.p(e),c="set"+(this.$u?"UTC":""),p=(n={},n[o]=c+"Date",n[h]=c+"Date",n[u]=c+"Month",n[d]=c+"FullYear",n[i]=c+"Hours",n[s]=c+"Minutes",n[a]=c+"Seconds",n[r]=c+"Milliseconds",n)[l],f=l===o?this.$D+(t-this.$W):t;if(l===u||l===d){var m=this.clone().set(h,1);m.$d[p](f),m.init(),this.$d=m.set(h,Math.min(this.$D,m.daysInMonth())).$d}else p&&this.$d[p](f);return this.init(),this},y.set=function(e,t){return this.clone().$set(e,t)},y.get=function(e){return this[C.p(e)]()},y.add=function(r,c){var h,p=this;r=Number(r);var f=C.p(c),m=function(e){var t=I(p);return C.w(t.date(t.date()+Math.round(e*r)),p)};if(f===u)return this.set(u,this.$M+r);if(f===d)return this.set(d,this.$y+r);if(f===o)return m(1);if(f===l)return m(7);var g=(h={},h[s]=t,h[i]=n,h[a]=e,h)[f]||1,y=this.$d.getTime()+r*g;return C.w(y,this)},y.subtract=function(e,t){return this.add(-1*e,t)},y.format=function(e){var t=this,n=this.$locale();if(!this.isValid())return n.invalidDate||p;var r=e||"YYYY-MM-DDTHH:mm:ssZ",a=C.z(this),s=this.$H,i=this.$m,o=this.$M,l=n.weekdays,u=n.months,c=n.meridiem,d=function(e,n,a,s){return e&&(e[n]||e(t,r))||a[n].slice(0,s)},h=function(e){return C.s(s%12||12,e,"0")},f=c||function(e,t,n){var r=e<12?"AM":"PM";return n?r.toLowerCase():r};return r.replace(m,(function(e,r){return r||function(e){switch(e){case"YY":return String(t.$y).slice(-2);case"YYYY":return C.s(t.$y,4,"0");case"M":return o+1;case"MM":return C.s(o+1,2,"0");case"MMM":return d(n.monthsShort,o,u,3);case"MMMM":return d(u,o);case"D":return t.$D;case"DD":return C.s(t.$D,2,"0");case"d":return String(t.$W);case"dd":return d(n.weekdaysMin,t.$W,l,2);case"ddd":return d(n.weekdaysShort,t.$W,l,3);case"dddd":return l[t.$W];case"H":return String(s);case"HH":return C.s(s,2,"0");case"h":return h(1);case"hh":return h(2);case"a":return f(s,i,!0);case"A":return f(s,i,!1);case"m":return String(i);case"mm":return C.s(i,2,"0");case"s":return String(t.$s);case"ss":return C.s(t.$s,2,"0");case"SSS":return C.s(t.$ms,3,"0");case"Z":return a}return null}(e)||a.replace(":","")}))},y.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},y.diff=function(r,h,p){var f,m=this,g=C.p(h),y=I(r),b=(y.utcOffset()-this.utcOffset())*t,v=this-y,x=function(){return C.m(m,y)};switch(g){case d:f=x()/12;break;case u:f=x();break;case c:f=x()/3;break;case l:f=(v-b)/6048e5;break;case o:f=(v-b)/864e5;break;case i:f=v/n;break;case s:f=v/t;break;case a:f=v/e;break;default:f=v}return p?f:C.a(f)},y.daysInMonth=function(){return this.endOf(u).$D},y.$locale=function(){return x[this.$L]},y.locale=function(e,t){if(!e)return this.$L;var n=this.clone(),r=S(e,t,!0);return r&&(n.$L=r),n},y.clone=function(){return C.w(this.$d,this)},y.toDate=function(){return new Date(this.valueOf())},y.toJSON=function(){return this.isValid()?this.toISOString():null},y.toISOString=function(){return this.$d.toISOString()},y.toString=function(){return this.$d.toUTCString()},g}(),T=N.prototype;return I.prototype=T,[["$ms",r],["$s",a],["$m",s],["$H",i],["$W",o],["$M",u],["$y",d],["$D",h]].forEach((function(e){T[e[1]]=function(t){return this.$g(t,e[0],e[1])}})),I.extend=function(e,t){return e.$i||(e(t,N,I),e.$i=!0),I},I.locale=S,I.isDayjs=k,I.unix=function(e){return I(1e3*e)},I.en=x[v],I.Ls=x,I.p={},I}()},7076:function(e){e.exports=function(){"use strict";return function(e,t){var n=t.prototype,r=n.format;n.format=function(e){var t=this,n=this.$locale();if(!this.isValid())return r.bind(this)(e);var a=this.$utils(),s=(e||"YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,(function(e){switch(e){case"Q":return Math.ceil((t.$M+1)/3);case"Do":return n.ordinal(t.$D);case"gggg":return t.weekYear();case"GGGG":return t.isoWeekYear();case"wo":return n.ordinal(t.week(),"W");case"w":case"ww":return a.s(t.week(),"w"===e?1:2,"0");case"W":case"WW":return a.s(t.isoWeek(),"W"===e?1:2,"0");case"k":case"kk":return a.s(String(0===t.$H?24:t.$H),"k"===e?1:2,"0");case"X":return Math.floor(t.$d.getTime()/1e3);case"x":return t.$d.getTime();case"z":return"["+t.offsetName()+"]";case"zzz":return"["+t.offsetName("long")+"]";default:return e}}));return r.bind(this)(s)}}}()},8988:function(e){e.exports=function(){"use strict";var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},t=/(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,n=/\d/,r=/\d\d/,a=/\d\d?/,s=/\d*[^-_:/,()\s\d]+/,i={},o=function(e){return(e=+e)+(e>68?1900:2e3)},l=function(e){return function(t){this[e]=+t}},u=[/[+-]\d\d:?(\d\d)?|Z/,function(e){(this.zone||(this.zone={})).offset=function(e){if(!e)return 0;if("Z"===e)return 0;var t=e.match(/([+-]|\d\d)/g),n=60*t[1]+(+t[2]||0);return 0===n?0:"+"===t[0]?-n:n}(e)}],c=function(e){var t=i[e];return t&&(t.indexOf?t:t.s.concat(t.f))},d=function(e,t){var n,r=i.meridiem;if(r){for(var a=1;a<=24;a+=1)if(e.indexOf(r(a,0,t))>-1){n=a>12;break}}else n=e===(t?"pm":"PM");return n},h={A:[s,function(e){this.afternoon=d(e,!1)}],a:[s,function(e){this.afternoon=d(e,!0)}],Q:[n,function(e){this.month=3*(e-1)+1}],S:[n,function(e){this.milliseconds=100*+e}],SS:[r,function(e){this.milliseconds=10*+e}],SSS:[/\d{3}/,function(e){this.milliseconds=+e}],s:[a,l("seconds")],ss:[a,l("seconds")],m:[a,l("minutes")],mm:[a,l("minutes")],H:[a,l("hours")],h:[a,l("hours")],HH:[a,l("hours")],hh:[a,l("hours")],D:[a,l("day")],DD:[r,l("day")],Do:[s,function(e){var t=i.ordinal,n=e.match(/\d+/);if(this.day=n[0],t)for(var r=1;r<=31;r+=1)t(r).replace(/\[|\]/g,"")===e&&(this.day=r)}],w:[a,l("week")],ww:[r,l("week")],M:[a,l("month")],MM:[r,l("month")],MMM:[s,function(e){var t=c("months"),n=(c("monthsShort")||t.map((function(e){return e.slice(0,3)}))).indexOf(e)+1;if(n<1)throw new Error;this.month=n%12||n}],MMMM:[s,function(e){var t=c("months").indexOf(e)+1;if(t<1)throw new Error;this.month=t%12||t}],Y:[/[+-]?\d+/,l("year")],YY:[r,function(e){this.year=o(e)}],YYYY:[/\d{4}/,l("year")],Z:u,ZZ:u};function p(n){var r,a;r=n,a=i&&i.formats;for(var s=(n=r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var s=r&&r.toUpperCase();return n||a[r]||e[r]||a[s].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))).match(t),o=s.length,l=0;l<o;l+=1){var u=s[l],c=h[u],d=c&&c[0],p=c&&c[1];s[l]=p?{regex:d,parser:p}:u.replace(/^\[|\]$/g,"")}return function(e){for(var t={},n=0,r=0;n<o;n+=1){var a=s[n];if("string"==typeof a)r+=a.length;else{var i=a.regex,l=a.parser,u=e.slice(r),c=i.exec(u)[0];l.call(t,c),e=e.replace(c,"")}}return function(e){var t=e.afternoon;if(void 0!==t){var n=e.hours;t?n<12&&(e.hours+=12):12===n&&(e.hours=0),delete e.afternoon}}(t),t}}return function(e,t,n){n.p.customParseFormat=!0,e&&e.parseTwoDigitYear&&(o=e.parseTwoDigitYear);var r=t.prototype,a=r.parse;r.parse=function(e){var t=e.date,r=e.utc,s=e.args;this.$u=r;var o=s[1];if("string"==typeof o){var l=!0===s[2],u=!0===s[3],c=l||u,d=s[2];u&&(d=s[2]),i=this.$locale(),!l&&d&&(i=n.Ls[d]),this.$d=function(e,t,n,r){try{if(["x","X"].indexOf(t)>-1)return new Date(("X"===t?1e3:1)*e);var a=p(t)(e),s=a.year,i=a.month,o=a.day,l=a.hours,u=a.minutes,c=a.seconds,d=a.milliseconds,h=a.zone,f=a.week,m=new Date,g=o||(s||i?1:m.getDate()),y=s||m.getFullYear(),b=0;s&&!i||(b=i>0?i-1:m.getMonth());var v,x=l||0,w=u||0,k=c||0,S=d||0;return h?new Date(Date.UTC(y,b,g,x,w,k,S+60*h.offset*1e3)):n?new Date(Date.UTC(y,b,g,x,w,k,S)):(v=new Date(y,b,g,x,w,k,S),f&&(v=r(v).week(f).toDate()),v)}catch(e){return new Date("")}}(t,o,r,n),this.init(),d&&!0!==d&&(this.$L=this.locale(d).$L),c&&t!=this.format(o)&&(this.$d=new Date("")),i={}}else if(o instanceof Array)for(var h=o.length,f=1;f<=h;f+=1){s[1]=o[f-1];var m=n.apply(this,s);if(m.isValid()){this.$d=m.$d,this.$L=m.$L,this.init();break}f===h&&(this.$d=new Date(""))}else a.call(this,e)}}}()},1525:function(e){e.exports=function(){"use strict";return function(e,t,n){t.prototype.isBetween=function(e,t,r,a){var s=n(e),i=n(t),o="("===(a=a||"()")[0],l=")"===a[1];return(o?this.isAfter(s,r):!this.isBefore(s,r))&&(l?this.isBefore(i,r):!this.isAfter(i,r))||(o?this.isBefore(s,r):!this.isAfter(s,r))&&(l?this.isAfter(i,r):!this.isBefore(i,r))}}}()},4443:function(e){e.exports=function(){"use strict";var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};return function(t,n,r){var a=n.prototype,s=a.format;r.en.formats=e,a.format=function(t){void 0===t&&(t="YYYY-MM-DDTHH:mm:ssZ");var n=this.$locale().formats,r=function(t,n){return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,r,a){var s=a&&a.toUpperCase();return r||n[a]||e[a]||n[s].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))}(t,void 0===n?{}:n);return s.call(this,r)}}}()},6865:function(e){e.exports=function(){"use strict";var e="week",t="year";return function(n,r,a){var s=r.prototype;s.week=function(n){if(void 0===n&&(n=null),null!==n)return this.add(7*(n-this.week()),"day");var r=this.$locale().yearStart||1;if(11===this.month()&&this.date()>25){var s=a(this).startOf(t).add(1,t).date(r),i=a(this).endOf(e);if(s.isBefore(i))return 1}var o=a(this).startOf(t).date(r).startOf(e).subtract(1,"millisecond"),l=this.diff(o,e,!0);return l<0?a(this).startOf("week").week():Math.ceil(l)},s.weeks=function(e){return void 0===e&&(e=null),this.week(e)}}}()},757:function(e){"undefined"!=typeof self&&self,e.exports=function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(r,a,function(t){return e[t]}.bind(null,a));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";n.r(t);var r={};function a(e){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}n.r(r),n.d(r,"VictoryGesture",(function(){return T})),n.d(r,"ThumbsUpGesture",(function(){return R}));var s={Thumb:0,Index:1,Middle:2,Ring:3,Pinky:4,all:[0,1,2,3,4],nameMapping:{0:"Thumb",1:"Index",2:"Middle",3:"Ring",4:"Pinky"},pointsMapping:{0:[[0,1],[1,2],[2,3],[3,4]],1:[[0,5],[5,6],[6,7],[7,8]],2:[[0,9],[9,10],[10,11],[11,12]],3:[[0,13],[13,14],[14,15],[15,16]],4:[[0,17],[17,18],[18,19],[19,20]]},getName:function(e){return void 0!==a(this.nameMapping[e])&&this.nameMapping[e]},getPoints:function(e){return void 0!==a(this.pointsMapping[e])&&this.pointsMapping[e]}},i={NoCurl:0,HalfCurl:1,FullCurl:2,nameMapping:{0:"No Curl",1:"Half Curl",2:"Full Curl"},getName:function(e){return void 0!==a(this.nameMapping[e])&&this.nameMapping[e]}},o={VerticalUp:0,VerticalDown:1,HorizontalLeft:2,HorizontalRight:3,DiagonalUpRight:4,DiagonalUpLeft:5,DiagonalDownRight:6,DiagonalDownLeft:7,nameMapping:{0:"Vertical Up",1:"Vertical Down",2:"Horizontal Left",3:"Horizontal Right",4:"Diagonal Up Right",5:"Diagonal Up Left",6:"Diagonal Down Right",7:"Diagonal Down Left"},getName:function(e){return void 0!==a(this.nameMapping[e])&&this.nameMapping[e]}};function l(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=function(e,t){if(e){if("string"==typeof e)return u(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?u(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,a=function(){};return{s:a,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,i=!0,o=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return i=e.done,e},e:function(e){o=!0,s=e},f:function(){try{i||null==n.return||n.return()}finally{if(o)throw s}}}}function u(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function d(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){h(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function h(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function p(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var f=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options=d(d({},{HALF_CURL_START_LIMIT:60,NO_CURL_START_LIMIT:130,DISTANCE_VOTE_POWER:1.1,SINGLE_ANGLE_VOTE_POWER:.9,TOTAL_ANGLE_VOTE_POWER:1.6}),t)}var t,n,r;return t=e,(n=[{key:"estimate",value:function(e){var t,n=[],r=[],a=l(s.all);try{for(a.s();!(t=a.n()).done;){var i,o=t.value,u=s.getPoints(o),c=[],d=[],h=l(u);try{for(h.s();!(i=h.n()).done;){var p=i.value,f=e[p[0]],m=e[p[1]],g=this.getSlopes(f,m),y=g[0],b=g[1];c.push(y),d.push(b)}}catch(e){h.e(e)}finally{h.f()}n.push(c),r.push(d)}}catch(e){a.e(e)}finally{a.f()}var v,x=[],w=[],k=l(s.all);try{for(k.s();!(v=k.n()).done;){var S=v.value,I=S==s.Thumb?1:0,C=s.getPoints(S),N=e[C[I][0]],T=e[C[I+1][1]],E=e[C[3][1]],A=this.estimateFingerCurl(N,T,E),_=this.calculateFingerDirection(N,T,E,n[S].slice(I));x[S]=A,w[S]=_}}catch(e){k.e(e)}finally{k.f()}return{curls:x,directions:w}}},{key:"getSlopes",value:function(e,t){var n=this.calculateSlope(e[0],e[1],t[0],t[1]);return 2==e.length?n:[n,this.calculateSlope(e[1],e[2],t[1],t[2])]}},{key:"angleOrientationAt",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=0,r=0,a=0;return e>=75&&e<=105?n=1*t:e>=25&&e<=155?r=1*t:a=1*t,[n,r,a]}},{key:"estimateFingerCurl",value:function(e,t,n){var r=e[0]-t[0],a=e[0]-n[0],s=t[0]-n[0],o=e[1]-t[1],l=e[1]-n[1],u=t[1]-n[1],c=e[2]-t[2],d=e[2]-n[2],h=t[2]-n[2],p=Math.sqrt(r*r+o*o+c*c),f=Math.sqrt(a*a+l*l+d*d),m=Math.sqrt(s*s+u*u+h*h),g=(m*m+p*p-f*f)/(2*m*p);g>1?g=1:g<-1&&(g=-1);var y=Math.acos(g);return(y=57.2958*y%180)>this.options.NO_CURL_START_LIMIT?i.NoCurl:y>this.options.HALF_CURL_START_LIMIT?i.HalfCurl:i.FullCurl}},{key:"estimateHorizontalDirection",value:function(e,t,n,r){return r==Math.abs(e)?e>0?o.HorizontalLeft:o.HorizontalRight:r==Math.abs(t)?t>0?o.HorizontalLeft:o.HorizontalRight:n>0?o.HorizontalLeft:o.HorizontalRight}},{key:"estimateVerticalDirection",value:function(e,t,n,r){return r==Math.abs(e)?e<0?o.VerticalDown:o.VerticalUp:r==Math.abs(t)?t<0?o.VerticalDown:o.VerticalUp:n<0?o.VerticalDown:o.VerticalUp}},{key:"estimateDiagonalDirection",value:function(e,t,n,r,a,s,i,l){var u=this.estimateVerticalDirection(e,t,n,r),c=this.estimateHorizontalDirection(a,s,i,l);return u==o.VerticalUp?c==o.HorizontalLeft?o.DiagonalUpLeft:o.DiagonalUpRight:c==o.HorizontalLeft?o.DiagonalDownLeft:o.DiagonalDownRight}},{key:"calculateFingerDirection",value:function(e,t,n,r){var a=e[0]-t[0],s=e[0]-n[0],i=t[0]-n[0],o=e[1]-t[1],u=e[1]-n[1],c=t[1]-n[1],d=Math.max(Math.abs(a),Math.abs(s),Math.abs(i)),h=Math.max(Math.abs(o),Math.abs(u),Math.abs(c)),p=0,f=0,m=0,g=h/(d+1e-5);g>1.5?p+=this.options.DISTANCE_VOTE_POWER:g>.66?f+=this.options.DISTANCE_VOTE_POWER:m+=this.options.DISTANCE_VOTE_POWER;var y=Math.sqrt(a*a+o*o),b=Math.sqrt(s*s+u*u),v=Math.sqrt(i*i+c*c),x=Math.max(y,b,v),w=e[0],k=e[1],S=n[0],I=n[1];x==y?(S=n[0],I=n[1]):x==v&&(w=t[0],k=t[1]);var C=[w,k],N=[S,I],T=this.getSlopes(C,N),E=this.angleOrientationAt(T,this.options.TOTAL_ANGLE_VOTE_POWER);p+=E[0],f+=E[1],m+=E[2];var A,_=l(r);try{for(_.s();!(A=_.n()).done;){var $=A.value,R=this.angleOrientationAt($,this.options.SINGLE_ANGLE_VOTE_POWER);p+=R[0],f+=R[1],m+=R[2]}}catch(e){_.e(e)}finally{_.f()}return p==Math.max(p,f,m)?this.estimateVerticalDirection(u,o,c,h):m==Math.max(f,m)?this.estimateHorizontalDirection(s,a,i,d):this.estimateDiagonalDirection(u,o,c,h,s,a,i,d)}},{key:"calculateSlope",value:function(e,t,n,r){var a=(t-r)/(e-n),s=180*Math.atan(a)/Math.PI;return s<=0?s=-s:s>0&&(s=180-s),s}}])&&p(t.prototype,n),r&&p(t,r),e}();function m(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=function(e,t){if(e){if("string"==typeof e)return g(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?g(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,a=function(){};return{s:a,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,i=!0,o=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return i=e.done,e},e:function(e){o=!0,s=e},f:function(){try{i||null==n.return||n.return()}finally{if(o)throw s}}}}function g(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function y(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function b(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var v=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};y(this,e),this.estimator=new f(n),this.gestures=t}var t,n,r;return t=e,(n=[{key:"estimate",value:function(e,t){var n,r=[],a=this.estimator.estimate(e),l=[],u=m(s.all);try{for(u.s();!(n=u.n()).done;){var c=n.value;l.push([s.getName(c),i.getName(a.curls[c]),o.getName(a.directions[c])])}}catch(e){u.e(e)}finally{u.f()}var d,h=m(this.gestures);try{for(h.s();!(d=h.n()).done;){var p=d.value,f=p.matchAgainst(a.curls,a.directions);f>=t&&r.push({name:p.name,score:f})}}catch(e){h.e(e)}finally{h.f()}return{poseData:l,gestures:r}}}])&&b(t.prototype,n),r&&b(t,r),e}();function x(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=n){var r,a,s=[],i=!0,o=!1;try{for(n=n.call(e);!(i=(r=n.next()).done)&&(s.push(r.value),!t||s.length!==t);i=!0);}catch(e){o=!0,a=e}finally{try{i||null==n.return||n.return()}finally{if(o)throw a}}return s}}(e,t)||k(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function w(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=k(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,a=function(){};return{s:a,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,i=!0,o=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return i=e.done,e},e:function(e){o=!0,s=e},f:function(){try{i||null==n.return||n.return()}finally{if(o)throw s}}}}function k(e,t){if(e){if("string"==typeof e)return S(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?S(e,t):void 0}}function S(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function I(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var C=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.name=t,this.curls={},this.directions={}}var t,n,r;return t=e,(n=[{key:"addCurl",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;void 0===this.curls[e]&&(this.curls[e]=[]),this.curls[e].push([t,n])}},{key:"addDirection",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;void 0===this.directions[e]&&(this.directions[e]=[]),this.directions[e].push([t,n])}},{key:"matchAgainst",value:function(e,t){var n=0,r=0;for(var a in e){var s=e[a],i=this.curls[a];if(void 0!==i){r++;var o,l=!1,u=0,c=w(i);try{for(c.s();!(o=c.n()).done;){var d=x(o.value,2),h=d[0],p=d[1];if(s==h){n+=p,u=Math.max(u,p),l=!0;break}}}catch(e){c.e(e)}finally{c.f()}l||(n-=u)}}for(var f in t){var m=t[f],g=this.directions[f];if(void 0!==g){r++;var y,b=!1,v=0,k=w(g);try{for(k.s();!(y=k.n()).done;){var S=x(y.value,2),I=S[0],C=S[1];if(m==I){n+=C,v=Math.max(v,C),b=!0;break}}}catch(e){k.e(e)}finally{k.f()}b||(n-=v)}}return n/r*10}}])&&I(t.prototype,n),r&&I(t,r),e}(),N=new C("victory");N.addDirection(s.Thumb,o.VerticalUp,1),N.addDirection(s.Thumb,o.DiagonalUpLeft,1),N.addDirection(s.Thumb,o.DiagonalUpRight,1),N.addCurl(s.Index,i.NoCurl,1),N.addDirection(s.Index,o.VerticalUp,1),N.addDirection(s.Index,o.DiagonalUpLeft,1),N.addDirection(s.Index,o.DiagonalUpRight,1),N.addDirection(s.Index,o.HorizontalLeft,1),N.addDirection(s.Index,o.HorizontalRight,1),N.addCurl(s.Middle,i.NoCurl,1),N.addDirection(s.Middle,o.VerticalUp,1),N.addDirection(s.Middle,o.DiagonalUpLeft,1),N.addDirection(s.Middle,o.DiagonalUpRight,1),N.addDirection(s.Middle,o.HorizontalLeft,1),N.addDirection(s.Middle,o.HorizontalRight,1),N.addCurl(s.Ring,i.FullCurl,1),N.addCurl(s.Ring,i.HalfCurl,.9),N.addCurl(s.Pinky,i.FullCurl,1),N.addCurl(s.Pinky,i.HalfCurl,.9);var T=N,E=new C("thumbs_up");E.addCurl(s.Thumb,i.NoCurl,1),E.addDirection(s.Thumb,o.VerticalUp,1),E.addDirection(s.Thumb,o.DiagonalUpLeft,.9),E.addDirection(s.Thumb,o.DiagonalUpRight,.9);for(var A=0,_=[s.Index,s.Middle,s.Ring,s.Pinky];A<_.length;A++){var $=_[A];E.addCurl($,i.FullCurl,1),E.addCurl($,i.HalfCurl,.9)}E.addDirection(s.Index,o.DiagonalUpLeft,1),E.addDirection(s.Index,o.HorizontalLeft,1),E.addDirection(s.Index,o.HorizontalRight,1),E.addDirection(s.Index,o.DiagonalUpRight,1);var R=E;t.default={GestureEstimator:v,GestureDescription:C,Finger:s,FingerCurl:i,FingerDirection:o,Gestures:r}}]).default},219:(e,t,n)=>{"use strict";var r=n(3763),a={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},s={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},i={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},o={};function l(e){return r.isMemo(e)?i:o[e.$$typeof]||a}o[r.ForwardRef]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},o[r.Memo]=i;var u=Object.defineProperty,c=Object.getOwnPropertyNames,d=Object.getOwnPropertySymbols,h=Object.getOwnPropertyDescriptor,p=Object.getPrototypeOf,f=Object.prototype;e.exports=function e(t,n,r){if("string"!==typeof n){if(f){var a=p(n);a&&a!==f&&e(t,a,r)}var i=c(n);d&&(i=i.concat(d(n)));for(var o=l(t),m=l(n),g=0;g<i.length;++g){var y=i[g];if(!s[y]&&(!r||!r[y])&&(!m||!m[y])&&(!o||!o[y])){var b=h(n,y);try{u(t,y,b)}catch(v){}}}}return t}},4983:(e,t)=>{"use strict";var n="function"===typeof Symbol&&Symbol.for,r=n?Symbol.for("react.element"):60103,a=n?Symbol.for("react.portal"):60106,s=n?Symbol.for("react.fragment"):60107,i=n?Symbol.for("react.strict_mode"):60108,o=n?Symbol.for("react.profiler"):60114,l=n?Symbol.for("react.provider"):60109,u=n?Symbol.for("react.context"):60110,c=n?Symbol.for("react.async_mode"):60111,d=n?Symbol.for("react.concurrent_mode"):60111,h=n?Symbol.for("react.forward_ref"):60112,p=n?Symbol.for("react.suspense"):60113,f=n?Symbol.for("react.suspense_list"):60120,m=n?Symbol.for("react.memo"):60115,g=n?Symbol.for("react.lazy"):60116,y=n?Symbol.for("react.block"):60121,b=n?Symbol.for("react.fundamental"):60117,v=n?Symbol.for("react.responder"):60118,x=n?Symbol.for("react.scope"):60119;function w(e){if("object"===typeof e&&null!==e){var t=e.$$typeof;switch(t){case r:switch(e=e.type){case c:case d:case s:case o:case i:case p:return e;default:switch(e=e&&e.$$typeof){case u:case h:case g:case m:case l:return e;default:return t}}case a:return t}}}function k(e){return w(e)===d}t.AsyncMode=c,t.ConcurrentMode=d,t.ContextConsumer=u,t.ContextProvider=l,t.Element=r,t.ForwardRef=h,t.Fragment=s,t.Lazy=g,t.Memo=m,t.Portal=a,t.Profiler=o,t.StrictMode=i,t.Suspense=p,t.isAsyncMode=function(e){return k(e)||w(e)===c},t.isConcurrentMode=k,t.isContextConsumer=function(e){return w(e)===u},t.isContextProvider=function(e){return w(e)===l},t.isElement=function(e){return"object"===typeof e&&null!==e&&e.$$typeof===r},t.isForwardRef=function(e){return w(e)===h},t.isFragment=function(e){return w(e)===s},t.isLazy=function(e){return w(e)===g},t.isMemo=function(e){return w(e)===m},t.isPortal=function(e){return w(e)===a},t.isProfiler=function(e){return w(e)===o},t.isStrictMode=function(e){return w(e)===i},t.isSuspense=function(e){return w(e)===p},t.isValidElementType=function(e){return"string"===typeof e||"function"===typeof e||e===s||e===d||e===o||e===i||e===p||e===f||"object"===typeof e&&null!==e&&(e.$$typeof===g||e.$$typeof===m||e.$$typeof===l||e.$$typeof===u||e.$$typeof===h||e.$$typeof===b||e.$$typeof===v||e.$$typeof===x||e.$$typeof===y)},t.typeOf=w},3763:(e,t,n)=>{"use strict";e.exports=n(4983)},1497:(e,t,n)=>{"use strict";var r=n(3218);function a(){}function s(){}s.resetWarningCache=a,e.exports=function(){function e(e,t,n,a,s,i){if(i!==r){var o=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw o.name="Invariant Violation",o}}function t(){return e}e.isRequired=e;var n={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:s,resetWarningCache:a};return n.PropTypes=n,n}},5173:(e,t,n)=>{e.exports=n(1497)()},3218:e=>{"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},2730:(e,t,n)=>{"use strict";var r=n(5043),a=n(8853);function s(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,o={};function l(e,t){u(e,t),u(e+"Capture",t)}function u(e,t){for(o[e]=t,e=0;e<t.length;e++)i.add(t[e])}var c=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),d=Object.prototype.hasOwnProperty,h=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(e,t,n,r,a,s,i){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=r,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=s,this.removeEmptyString=i}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){g[e]=new m(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){g[e]=new m(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){g[e]=new m(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){g[e]=new m(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){g[e]=new m(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)}));var y=/[\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function v(e,t,n,r){var a=g.hasOwnProperty(t)?g[t]:null;(null!==a?0!==a.type:r||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,r){if(null===t||"undefined"===typeof t||function(e,t,n,r){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,a,r)&&(n=null),r||null===a?function(e){return!!d.call(f,e)||!d.call(p,e)&&(h.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):a.mustUseProperty?e[a.propertyName]=null===n?3!==a.type&&"":n:(t=a.attributeName,r=a.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(a=a.type)||4===a&&!0===n?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)})),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)}));var x=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),I=Symbol.for("react.strict_mode"),C=Symbol.for("react.profiler"),N=Symbol.for("react.provider"),T=Symbol.for("react.context"),E=Symbol.for("react.forward_ref"),A=Symbol.for("react.suspense"),_=Symbol.for("react.suspense_list"),$=Symbol.for("react.memo"),R=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var D=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var M=Symbol.iterator;function F(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=M&&e[M]||e["@@iterator"])?e:null}var O,P=Object.assign;function L(e){if(void 0===O)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);O=t&&t[1]||""}return"\n"+O+e}var z=!1;function B(e,t){if(!e||z)return"";z=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(u){var r=u}Reflect.construct(e,[],t)}else{try{t.call()}catch(u){r=u}e.call(t.prototype)}else{try{throw Error()}catch(u){r=u}e()}}catch(u){if(u&&r&&"string"===typeof u.stack){for(var a=u.stack.split("\n"),s=r.stack.split("\n"),i=a.length-1,o=s.length-1;1<=i&&0<=o&&a[i]!==s[o];)o--;for(;1<=i&&0<=o;i--,o--)if(a[i]!==s[o]){if(1!==i||1!==o)do{if(i--,0>--o||a[i]!==s[o]){var l="\n"+a[i].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=i&&0<=o);break}}}finally{z=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?L(e):""}function W(e){switch(e.tag){case 5:return L(e.type);case 16:return L("Lazy");case 13:return L("Suspense");case 19:return L("SuspenseList");case 0:case 2:case 15:return e=B(e.type,!1);case 11:return e=B(e.type.render,!1);case 1:return e=B(e.type,!0);default:return""}}function V(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case S:return"Fragment";case k:return"Portal";case C:return"Profiler";case I:return"StrictMode";case A:return"Suspense";case _:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case T:return(e.displayName||"Context")+".Consumer";case N:return(e._context.displayName||"Context")+".Provider";case E:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case $:return null!==(t=e.displayName||null)?t:V(e.type)||"Memo";case R:t=e._payload,e=e._init;try{return V(e(t))}catch(n){}}return null}function U(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return V(t);case 8:return t===I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function j(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function G(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function H(e){e._valueTracker||(e._valueTracker=function(e){var t=G(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var a=n.get,s=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(e){r=""+e,s.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=G(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function K(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function X(e,t){var n=t.checked;return P({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Y(e,t){var n=null==t.defaultValue?"":t.defaultValue,r=null!=t.checked?t.checked:t.defaultChecked;n=j(null!=t.value?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Q(e,t){null!=(t=t.checked)&&v(e,"checked",t,!1)}function J(e,t){Q(e,t);var n=j(t.value),r=t.type;if(null!=n)"number"===r?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===r||"reset"===r)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,j(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function Z(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!("submit"!==r&&"reset"!==r||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&K(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,r){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&r&&(e[n].defaultSelected=!0)}else{for(n=""+j(n),t=null,a=0;a<e.length;a++){if(e[a].value===n)return e[a].selected=!0,void(r&&(e[a].defaultSelected=!0));null!==t||e[a].disabled||(t=e[a])}null!==t&&(t.selected=!0)}}function re(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(s(91));return P({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function ae(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(s(92));if(te(n)){if(1<n.length)throw Error(s(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:j(n)}}function se(e,t){var n=j(t.value),r=j(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=r&&(e.defaultValue=""+r)}function ie(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function oe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function le(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?oe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var ue,ce,de=(ce=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((ue=ue||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ue.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,r){MSApp.execUnsafeLocalFunction((function(){return ce(e,t)}))}:ce);function he(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var r=0===n.indexOf("--"),a=me(n,t[n],r);"float"===n&&(n="cssFloat"),r?e.setProperty(n,a):e[n]=a}}Object.keys(pe).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]}))}));var ye=P({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function be(e,t){if(t){if(ye[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(s(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(s(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(s(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(s(62))}}function ve(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var xe=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Se=null,Ie=null;function Ce(e){if(e=va(e)){if("function"!==typeof ke)throw Error(s(280));var t=e.stateNode;t&&(t=wa(t),ke(e.stateNode,e.type,t))}}function Ne(e){Se?Ie?Ie.push(e):Ie=[e]:Se=e}function Te(){if(Se){var e=Se,t=Ie;if(Ie=Se=null,Ce(e),t)for(e=0;e<t.length;e++)Ce(t[e])}}function Ee(e,t){return e(t)}function Ae(){}var _e=!1;function $e(e,t,n){if(_e)return e(t,n);_e=!0;try{return Ee(e,t,n)}finally{_e=!1,(null!==Se||null!==Ie)&&(Ae(),Te())}}function Re(e,t){var n=e.stateNode;if(null===n)return null;var r=wa(n);if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(s(231,t,typeof n));return n}var De=!1;if(c)try{var Me={};Object.defineProperty(Me,"passive",{get:function(){De=!0}}),window.addEventListener("test",Me,Me),window.removeEventListener("test",Me,Me)}catch(ce){De=!1}function Fe(e,t,n,r,a,s,i,o,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(c){this.onError(c)}}var Oe=!1,Pe=null,Le=!1,ze=null,Be={onError:function(e){Oe=!0,Pe=e}};function We(e,t,n,r,a,s,i,o,l){Oe=!1,Pe=null,Fe.apply(Be,arguments)}function Ve(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ue(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function je(e){if(Ve(e)!==e)throw Error(s(188))}function Ge(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ve(e)))throw Error(s(188));return t!==e?null:e}for(var n=e,r=t;;){var a=n.return;if(null===a)break;var i=a.alternate;if(null===i){if(null!==(r=a.return)){n=r;continue}break}if(a.child===i.child){for(i=a.child;i;){if(i===n)return je(a),e;if(i===r)return je(a),t;i=i.sibling}throw Error(s(188))}if(n.return!==r.return)n=a,r=i;else{for(var o=!1,l=a.child;l;){if(l===n){o=!0,n=a,r=i;break}if(l===r){o=!0,r=a,n=i;break}l=l.sibling}if(!o){for(l=i.child;l;){if(l===n){o=!0,n=i,r=a;break}if(l===r){o=!0,r=i,n=a;break}l=l.sibling}if(!o)throw Error(s(189))}}if(n.alternate!==r)throw Error(s(190))}if(3!==n.tag)throw Error(s(188));return n.stateNode.current===n?e:t}(e))?He(e):null}function He(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=He(e);if(null!==t)return t;e=e.sibling}return null}var qe=a.unstable_scheduleCallback,Ke=a.unstable_cancelCallback,Xe=a.unstable_shouldYield,Ye=a.unstable_requestPaint,Qe=a.unstable_now,Je=a.unstable_getCurrentPriorityLevel,Ze=a.unstable_ImmediatePriority,et=a.unstable_UserBlockingPriority,tt=a.unstable_NormalPriority,nt=a.unstable_LowPriority,rt=a.unstable_IdlePriority,at=null,st=null;var it=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(ot(e)/lt|0)|0},ot=Math.log,lt=Math.LN2;var ut=64,ct=4194304;function dt(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function ht(e,t){var n=e.pendingLanes;if(0===n)return 0;var r=0,a=e.suspendedLanes,s=e.pingedLanes,i=268435455&n;if(0!==i){var o=i&~a;0!==o?r=dt(o):0!==(s&=i)&&(r=dt(s))}else 0!==(i=n&~a)?r=dt(i):0!==s&&(r=dt(s));if(0===r)return 0;if(0!==t&&t!==r&&0===(t&a)&&((a=r&-r)>=(s=t&-t)||16===a&&0!==(4194240&s)))return t;if(0!==(4&r)&&(r|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=r;0<t;)a=1<<(n=31-it(t)),r|=e[n],t&=~a;return r}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=ut;return 0===(4194240&(ut<<=1))&&(ut=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function yt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-it(t)]=n}function bt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-it(n),a=1<<r;a&t|e[r]&t&&(e[r]|=t),n&=~a}}var vt=0;function xt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var wt,kt,St,It,Ct,Nt=!1,Tt=[],Et=null,At=null,_t=null,$t=new Map,Rt=new Map,Dt=[],Mt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ft(e,t){switch(e){case"focusin":case"focusout":Et=null;break;case"dragenter":case"dragleave":At=null;break;case"mouseover":case"mouseout":_t=null;break;case"pointerover":case"pointerout":$t.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Rt.delete(t.pointerId)}}function Ot(e,t,n,r,a,s){return null===e||e.nativeEvent!==s?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:s,targetContainers:[a]},null!==t&&(null!==(t=va(t))&&kt(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==a&&-1===t.indexOf(a)&&t.push(a),e)}function Pt(e){var t=ba(e.target);if(null!==t){var n=Ve(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ue(n)))return e.blockedOn=t,void Ct(e.priority,(function(){St(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function Lt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Xt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=va(n))&&kt(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);xe=r,n.target.dispatchEvent(r),xe=null,t.shift()}return!0}function zt(e,t,n){Lt(e)&&n.delete(t)}function Bt(){Nt=!1,null!==Et&&Lt(Et)&&(Et=null),null!==At&&Lt(At)&&(At=null),null!==_t&&Lt(_t)&&(_t=null),$t.forEach(zt),Rt.forEach(zt)}function Wt(e,t){e.blockedOn===t&&(e.blockedOn=null,Nt||(Nt=!0,a.unstable_scheduleCallback(a.unstable_NormalPriority,Bt)))}function Vt(e){function t(t){return Wt(t,e)}if(0<Tt.length){Wt(Tt[0],e);for(var n=1;n<Tt.length;n++){var r=Tt[n];r.blockedOn===e&&(r.blockedOn=null)}}for(null!==Et&&Wt(Et,e),null!==At&&Wt(At,e),null!==_t&&Wt(_t,e),$t.forEach(t),Rt.forEach(t),n=0;n<Dt.length;n++)(r=Dt[n]).blockedOn===e&&(r.blockedOn=null);for(;0<Dt.length&&null===(n=Dt[0]).blockedOn;)Pt(n),null===n.blockedOn&&Dt.shift()}var Ut=x.ReactCurrentBatchConfig,jt=!0;function Gt(e,t,n,r){var a=vt,s=Ut.transition;Ut.transition=null;try{vt=1,qt(e,t,n,r)}finally{vt=a,Ut.transition=s}}function Ht(e,t,n,r){var a=vt,s=Ut.transition;Ut.transition=null;try{vt=4,qt(e,t,n,r)}finally{vt=a,Ut.transition=s}}function qt(e,t,n,r){if(jt){var a=Xt(e,t,n,r);if(null===a)jr(e,t,r,Kt,n),Ft(e,r);else if(function(e,t,n,r,a){switch(t){case"focusin":return Et=Ot(Et,e,t,n,r,a),!0;case"dragenter":return At=Ot(At,e,t,n,r,a),!0;case"mouseover":return _t=Ot(_t,e,t,n,r,a),!0;case"pointerover":var s=a.pointerId;return $t.set(s,Ot($t.get(s)||null,e,t,n,r,a)),!0;case"gotpointercapture":return s=a.pointerId,Rt.set(s,Ot(Rt.get(s)||null,e,t,n,r,a)),!0}return!1}(a,e,t,n,r))r.stopPropagation();else if(Ft(e,r),4&t&&-1<Mt.indexOf(e)){for(;null!==a;){var s=va(a);if(null!==s&&wt(s),null===(s=Xt(e,t,n,r))&&jr(e,t,r,Kt,n),s===a)break;a=s}null!==a&&r.stopPropagation()}else jr(e,t,r,null,n)}}var Kt=null;function Xt(e,t,n,r){if(Kt=null,null!==(e=ba(e=we(r))))if(null===(t=Ve(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Ue(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Kt=e,null}function Yt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Je()){case Ze:return 1;case et:return 4;case tt:case nt:return 16;case rt:return 536870912;default:return 16}default:return 16}}var Qt=null,Jt=null,Zt=null;function en(){if(Zt)return Zt;var e,t,n=Jt,r=n.length,a="value"in Qt?Qt.value:Qt.textContent,s=a.length;for(e=0;e<r&&n[e]===a[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===a[s-t];t++);return Zt=a.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function rn(){return!1}function an(e){function t(t,n,r,a,s){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=a,this.target=s,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(a):a[i]);return this.isDefaultPrevented=(null!=a.defaultPrevented?a.defaultPrevented:!1===a.returnValue)?nn:rn,this.isPropagationStopped=rn,this}return P(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var sn,on,ln,un={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},cn=an(un),dn=P({},un,{view:0,detail:0}),hn=an(dn),pn=P({},dn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Cn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==ln&&(ln&&"mousemove"===e.type?(sn=e.screenX-ln.screenX,on=e.screenY-ln.screenY):on=sn=0,ln=e),sn)},movementY:function(e){return"movementY"in e?e.movementY:on}}),fn=an(pn),mn=an(P({},pn,{dataTransfer:0})),gn=an(P({},dn,{relatedTarget:0})),yn=an(P({},un,{animationName:0,elapsedTime:0,pseudoElement:0})),bn=P({},un,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),vn=an(bn),xn=an(P({},un,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function In(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sn[e])&&!!t[e]}function Cn(){return In}var Nn=P({},dn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Cn,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Tn=an(Nn),En=an(P({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),An=an(P({},dn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Cn})),_n=an(P({},un,{propertyName:0,elapsedTime:0,pseudoElement:0})),$n=P({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Rn=an($n),Dn=[9,13,27,32],Mn=c&&"CompositionEvent"in window,Fn=null;c&&"documentMode"in document&&(Fn=document.documentMode);var On=c&&"TextEvent"in window&&!Fn,Pn=c&&(!Mn||Fn&&8<Fn&&11>=Fn),Ln=String.fromCharCode(32),zn=!1;function Bn(e,t){switch(e){case"keyup":return-1!==Dn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Wn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Vn=!1;var Un={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function jn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Un[e.type]:"textarea"===t}function Gn(e,t,n,r){Ne(r),0<(t=Hr(t,"onChange")).length&&(n=new cn("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Hn=null,qn=null;function Kn(e){Lr(e,0)}function Xn(e){if(q(xa(e)))return e}function Yn(e,t){if("change"===e)return t}var Qn=!1;if(c){var Jn;if(c){var Zn="oninput"in document;if(!Zn){var er=document.createElement("div");er.setAttribute("oninput","return;"),Zn="function"===typeof er.oninput}Jn=Zn}else Jn=!1;Qn=Jn&&(!document.documentMode||9<document.documentMode)}function tr(){Hn&&(Hn.detachEvent("onpropertychange",nr),qn=Hn=null)}function nr(e){if("value"===e.propertyName&&Xn(qn)){var t=[];Gn(t,qn,e,we(e)),$e(Kn,t)}}function rr(e,t,n){"focusin"===e?(tr(),qn=n,(Hn=t).attachEvent("onpropertychange",nr)):"focusout"===e&&tr()}function ar(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Xn(qn)}function sr(e,t){if("click"===e)return Xn(t)}function ir(e,t){if("input"===e||"change"===e)return Xn(t)}var or="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function lr(e,t){if(or(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!d.call(t,a)||!or(e[a],t[a]))return!1}return!0}function ur(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function cr(e,t){var n,r=ur(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=ur(r)}}function dr(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?dr(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function hr(){for(var e=window,t=K();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(r){n=!1}if(!n)break;t=K((e=t.contentWindow).document)}return t}function pr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fr(e){var t=hr(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&dr(n.ownerDocument.documentElement,n)){if(null!==r&&pr(n))if(t=r.start,void 0===(e=r.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var a=n.textContent.length,s=Math.min(r.start,a);r=void 0===r.end?s:Math.min(r.end,a),!e.extend&&s>r&&(a=r,r=s,s=a),a=cr(n,s);var i=cr(n,r);a&&i&&(1!==e.rangeCount||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&((t=t.createRange()).setStart(a.node,a.offset),e.removeAllRanges(),s>r?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var mr=c&&"documentMode"in document&&11>=document.documentMode,gr=null,yr=null,br=null,vr=!1;function xr(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;vr||null==gr||gr!==K(r)||("selectionStart"in(r=gr)&&pr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},br&&lr(br,r)||(br=r,0<(r=Hr(yr,"onSelect")).length&&(t=new cn("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=gr)))}function wr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var kr={animationend:wr("Animation","AnimationEnd"),animationiteration:wr("Animation","AnimationIteration"),animationstart:wr("Animation","AnimationStart"),transitionend:wr("Transition","TransitionEnd")},Sr={},Ir={};function Cr(e){if(Sr[e])return Sr[e];if(!kr[e])return e;var t,n=kr[e];for(t in n)if(n.hasOwnProperty(t)&&t in Ir)return Sr[e]=n[t];return e}c&&(Ir=document.createElement("div").style,"AnimationEvent"in window||(delete kr.animationend.animation,delete kr.animationiteration.animation,delete kr.animationstart.animation),"TransitionEvent"in window||delete kr.transitionend.transition);var Nr=Cr("animationend"),Tr=Cr("animationiteration"),Er=Cr("animationstart"),Ar=Cr("transitionend"),_r=new Map,$r="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Rr(e,t){_r.set(e,t),l(t,[e])}for(var Dr=0;Dr<$r.length;Dr++){var Mr=$r[Dr];Rr(Mr.toLowerCase(),"on"+(Mr[0].toUpperCase()+Mr.slice(1)))}Rr(Nr,"onAnimationEnd"),Rr(Tr,"onAnimationIteration"),Rr(Er,"onAnimationStart"),Rr("dblclick","onDoubleClick"),Rr("focusin","onFocus"),Rr("focusout","onBlur"),Rr(Ar,"onTransitionEnd"),u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Fr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Or=new Set("cancel close invalid load scroll toggle".split(" ").concat(Fr));function Pr(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,r,a,i,o,l,u){if(We.apply(this,arguments),Oe){if(!Oe)throw Error(s(198));var c=Pe;Oe=!1,Pe=null,Le||(Le=!0,ze=c)}}(r,t,void 0,e),e.currentTarget=null}function Lr(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var r=e[n],a=r.event;r=r.listeners;e:{var s=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==s&&a.isPropagationStopped())break e;Pr(a,o,u),s=l}else for(i=0;i<r.length;i++){if(l=(o=r[i]).instance,u=o.currentTarget,o=o.listener,l!==s&&a.isPropagationStopped())break e;Pr(a,o,u),s=l}}}if(Le)throw e=ze,Le=!1,ze=null,e}function zr(e,t){var n=t[ma];void 0===n&&(n=t[ma]=new Set);var r=e+"__bubble";n.has(r)||(Ur(t,e,2,!1),n.add(r))}function Br(e,t,n){var r=0;t&&(r|=4),Ur(n,e,r,t)}var Wr="_reactListening"+Math.random().toString(36).slice(2);function Vr(e){if(!e[Wr]){e[Wr]=!0,i.forEach((function(t){"selectionchange"!==t&&(Or.has(t)||Br(t,!1,e),Br(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Wr]||(t[Wr]=!0,Br("selectionchange",!1,t))}}function Ur(e,t,n,r){switch(Yt(t)){case 1:var a=Gt;break;case 4:a=Ht;break;default:a=qt}n=a.bind(null,t,n,e),a=void 0,!De||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(a=!0),r?void 0!==a?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):void 0!==a?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function jr(e,t,n,r,a){var s=r;if(0===(1&t)&&0===(2&t)&&null!==r)e:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var o=r.stateNode.containerInfo;if(o===a||8===o.nodeType&&o.parentNode===a)break;if(4===i)for(i=r.return;null!==i;){var l=i.tag;if((3===l||4===l)&&((l=i.stateNode.containerInfo)===a||8===l.nodeType&&l.parentNode===a))return;i=i.return}for(;null!==o;){if(null===(i=ba(o)))return;if(5===(l=i.tag)||6===l){r=s=i;continue e}o=o.parentNode}}r=r.return}$e((function(){var r=s,a=we(n),i=[];e:{var o=_r.get(e);if(void 0!==o){var l=cn,u=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":l=Tn;break;case"focusin":u="focus",l=gn;break;case"focusout":u="blur",l=gn;break;case"beforeblur":case"afterblur":l=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=An;break;case Nr:case Tr:case Er:l=yn;break;case Ar:l=_n;break;case"scroll":l=hn;break;case"wheel":l=Rn;break;case"copy":case"cut":case"paste":l=vn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=En}var c=0!==(4&t),d=!c&&"scroll"===e,h=c?null!==o?o+"Capture":null:o;c=[];for(var p,f=r;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==h&&(null!=(m=Re(f,h))&&c.push(Gr(f,m,p)))),d)break;f=f.return}0<c.length&&(o=new l(o,u,null,n,a),i.push({event:o,listeners:c}))}}if(0===(7&t)){if(l="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===xe||!(u=n.relatedTarget||n.fromElement)||!ba(u)&&!u[fa])&&(l||o)&&(o=a.window===a?a:(o=a.ownerDocument)?o.defaultView||o.parentWindow:window,l?(l=r,null!==(u=(u=n.relatedTarget||n.toElement)?ba(u):null)&&(u!==(d=Ve(u))||5!==u.tag&&6!==u.tag)&&(u=null)):(l=null,u=r),l!==u)){if(c=fn,m="onMouseLeave",h="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(c=En,m="onPointerLeave",h="onPointerEnter",f="pointer"),d=null==l?o:xa(l),p=null==u?o:xa(u),(o=new c(m,f+"leave",l,n,a)).target=d,o.relatedTarget=p,m=null,ba(a)===r&&((c=new c(h,f+"enter",u,n,a)).target=p,c.relatedTarget=d,m=c),d=m,l&&u)e:{for(h=u,f=0,p=c=l;p;p=qr(p))f++;for(p=0,m=h;m;m=qr(m))p++;for(;0<f-p;)c=qr(c),f--;for(;0<p-f;)h=qr(h),p--;for(;f--;){if(c===h||null!==h&&c===h.alternate)break e;c=qr(c),h=qr(h)}c=null}else c=null;null!==l&&Kr(i,o,l,c,!1),null!==u&&null!==d&&Kr(i,d,u,c,!0)}if("select"===(l=(o=r?xa(r):window).nodeName&&o.nodeName.toLowerCase())||"input"===l&&"file"===o.type)var g=Yn;else if(jn(o))if(Qn)g=ir;else{g=ar;var y=rr}else(l=o.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(g=sr);switch(g&&(g=g(e,r))?Gn(i,g,n,a):(y&&y(e,o,r),"focusout"===e&&(y=o._wrapperState)&&y.controlled&&"number"===o.type&&ee(o,"number",o.value)),y=r?xa(r):window,e){case"focusin":(jn(y)||"true"===y.contentEditable)&&(gr=y,yr=r,br=null);break;case"focusout":br=yr=gr=null;break;case"mousedown":vr=!0;break;case"contextmenu":case"mouseup":case"dragend":vr=!1,xr(i,n,a);break;case"selectionchange":if(mr)break;case"keydown":case"keyup":xr(i,n,a)}var b;if(Mn)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else Vn?Bn(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(Pn&&"ko"!==n.locale&&(Vn||"onCompositionStart"!==v?"onCompositionEnd"===v&&Vn&&(b=en()):(Jt="value"in(Qt=a)?Qt.value:Qt.textContent,Vn=!0)),0<(y=Hr(r,v)).length&&(v=new xn(v,e,null,n,a),i.push({event:v,listeners:y}),b?v.data=b:null!==(b=Wn(n))&&(v.data=b))),(b=On?function(e,t){switch(e){case"compositionend":return Wn(t);case"keypress":return 32!==t.which?null:(zn=!0,Ln);case"textInput":return(e=t.data)===Ln&&zn?null:e;default:return null}}(e,n):function(e,t){if(Vn)return"compositionend"===e||!Mn&&Bn(e,t)?(e=en(),Zt=Jt=Qt=null,Vn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Pn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(r=Hr(r,"onBeforeInput")).length&&(a=new xn("onBeforeInput","beforeinput",null,n,a),i.push({event:a,listeners:r}),a.data=b))}Lr(i,t)}))}function Gr(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Hr(e,t){for(var n=t+"Capture",r=[];null!==e;){var a=e,s=a.stateNode;5===a.tag&&null!==s&&(a=s,null!=(s=Re(e,n))&&r.unshift(Gr(e,s,a)),null!=(s=Re(e,t))&&r.push(Gr(e,s,a))),e=e.return}return r}function qr(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Kr(e,t,n,r,a){for(var s=t._reactName,i=[];null!==n&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(null!==l&&l===r)break;5===o.tag&&null!==u&&(o=u,a?null!=(l=Re(n,s))&&i.unshift(Gr(n,l,o)):a||null!=(l=Re(n,s))&&i.push(Gr(n,l,o))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var Xr=/\r\n?/g,Yr=/\u0000|\uFFFD/g;function Qr(e){return("string"===typeof e?e:""+e).replace(Xr,"\n").replace(Yr,"")}function Jr(e,t,n){if(t=Qr(t),Qr(e)!==t&&n)throw Error(s(425))}function Zr(){}var ea=null,ta=null;function na(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ra="function"===typeof setTimeout?setTimeout:void 0,aa="function"===typeof clearTimeout?clearTimeout:void 0,sa="function"===typeof Promise?Promise:void 0,ia="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof sa?function(e){return sa.resolve(null).then(e).catch(oa)}:ra;function oa(e){setTimeout((function(){throw e}))}function la(e,t){var n=t,r=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0===r)return e.removeChild(a),void Vt(t);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=a}while(n);Vt(t)}function ua(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function ca(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var da=Math.random().toString(36).slice(2),ha="__reactFiber$"+da,pa="__reactProps$"+da,fa="__reactContainer$"+da,ma="__reactEvents$"+da,ga="__reactListeners$"+da,ya="__reactHandles$"+da;function ba(e){var t=e[ha];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fa]||n[ha]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=ca(e);null!==e;){if(n=e[ha])return n;e=ca(e)}return t}n=(e=n).parentNode}return null}function va(e){return!(e=e[ha]||e[fa])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function xa(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(s(33))}function wa(e){return e[pa]||null}var ka=[],Sa=-1;function Ia(e){return{current:e}}function Ca(e){0>Sa||(e.current=ka[Sa],ka[Sa]=null,Sa--)}function Na(e,t){Sa++,ka[Sa]=e.current,e.current=t}var Ta={},Ea=Ia(Ta),Aa=Ia(!1),_a=Ta;function $a(e,t){var n=e.type.contextTypes;if(!n)return Ta;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var a,s={};for(a in n)s[a]=t[a];return r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function Ra(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Da(){Ca(Aa),Ca(Ea)}function Ma(e,t,n){if(Ea.current!==Ta)throw Error(s(168));Na(Ea,t),Na(Aa,n)}function Fa(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,"function"!==typeof r.getChildContext)return n;for(var a in r=r.getChildContext())if(!(a in t))throw Error(s(108,U(e)||"Unknown",a));return P({},n,r)}function Oa(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Ta,_a=Ea.current,Na(Ea,e),Na(Aa,Aa.current),!0}function Pa(e,t,n){var r=e.stateNode;if(!r)throw Error(s(169));n?(e=Fa(e,t,_a),r.__reactInternalMemoizedMergedChildContext=e,Ca(Aa),Ca(Ea),Na(Ea,e)):Ca(Aa),Na(Aa,n)}var La=null,za=!1,Ba=!1;function Wa(e){null===La?La=[e]:La.push(e)}function Va(){if(!Ba&&null!==La){Ba=!0;var e=0,t=vt;try{var n=La;for(vt=1;e<n.length;e++){var r=n[e];do{r=r(!0)}while(null!==r)}La=null,za=!1}catch(a){throw null!==La&&(La=La.slice(e+1)),qe(Ze,Va),a}finally{vt=t,Ba=!1}}return null}var Ua=[],ja=0,Ga=null,Ha=0,qa=[],Ka=0,Xa=null,Ya=1,Qa="";function Ja(e,t){Ua[ja++]=Ha,Ua[ja++]=Ga,Ga=e,Ha=t}function Za(e,t,n){qa[Ka++]=Ya,qa[Ka++]=Qa,qa[Ka++]=Xa,Xa=e;var r=Ya;e=Qa;var a=32-it(r)-1;r&=~(1<<a),n+=1;var s=32-it(t)+a;if(30<s){var i=a-a%5;s=(r&(1<<i)-1).toString(32),r>>=i,a-=i,Ya=1<<32-it(t)+a|n<<a|r,Qa=s+e}else Ya=1<<s|n<<a|r,Qa=e}function es(e){null!==e.return&&(Ja(e,1),Za(e,1,0))}function ts(e){for(;e===Ga;)Ga=Ua[--ja],Ua[ja]=null,Ha=Ua[--ja],Ua[ja]=null;for(;e===Xa;)Xa=qa[--Ka],qa[Ka]=null,Qa=qa[--Ka],qa[Ka]=null,Ya=qa[--Ka],qa[Ka]=null}var ns=null,rs=null,as=!1,ss=null;function is(e,t){var n=$u(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function os(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,ns=e,rs=ua(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,ns=e,rs=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Xa?{id:Ya,overflow:Qa}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=$u(18,null,null,0)).stateNode=t,n.return=e,e.child=n,ns=e,rs=null,!0);default:return!1}}function ls(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function us(e){if(as){var t=rs;if(t){var n=t;if(!os(e,t)){if(ls(e))throw Error(s(418));t=ua(n.nextSibling);var r=ns;t&&os(e,t)?is(r,n):(e.flags=-4097&e.flags|2,as=!1,ns=e)}}else{if(ls(e))throw Error(s(418));e.flags=-4097&e.flags|2,as=!1,ns=e}}}function cs(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;ns=e}function ds(e){if(e!==ns)return!1;if(!as)return cs(e),as=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!na(e.type,e.memoizedProps)),t&&(t=rs)){if(ls(e))throw hs(),Error(s(418));for(;t;)is(e,t),t=ua(t.nextSibling)}if(cs(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(s(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){rs=ua(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}rs=null}}else rs=ns?ua(e.stateNode.nextSibling):null;return!0}function hs(){for(var e=rs;e;)e=ua(e.nextSibling)}function ps(){rs=ns=null,as=!1}function fs(e){null===ss?ss=[e]:ss.push(e)}var ms=x.ReactCurrentBatchConfig;function gs(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(s(309));var r=n.stateNode}if(!r)throw Error(s(147,e));var a=r,i=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===i?t.ref:(t=function(e){var t=a.refs;null===e?delete t[i]:t[i]=e},t._stringRef=i,t)}if("string"!==typeof e)throw Error(s(284));if(!n._owner)throw Error(s(290,e))}return e}function ys(e,t){throw e=Object.prototype.toString.call(t),Error(s(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function bs(e){return(0,e._init)(e._payload)}function vs(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function a(e,t){return(e=Du(e,t)).index=0,e.sibling=null,e}function i(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=2,n):r:(t.flags|=2,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=2),t}function l(e,t,n,r){return null===t||6!==t.tag?((t=Pu(n,e.mode,r)).return=e,t):((t=a(t,n)).return=e,t)}function u(e,t,n,r){var s=n.type;return s===S?d(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===s||"object"===typeof s&&null!==s&&s.$$typeof===R&&bs(s)===t.type)?((r=a(t,n.props)).ref=gs(e,t,n),r.return=e,r):((r=Mu(n.type,n.key,n.props,null,e.mode,r)).ref=gs(e,t,n),r.return=e,r)}function c(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Lu(n,e.mode,r)).return=e,t):((t=a(t,n.children||[])).return=e,t)}function d(e,t,n,r,s){return null===t||7!==t.tag?((t=Fu(n,e.mode,r,s)).return=e,t):((t=a(t,n)).return=e,t)}function h(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=Pu(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Mu(t.type,t.key,t.props,null,e.mode,n)).ref=gs(e,null,t),n.return=e,n;case k:return(t=Lu(t,e.mode,n)).return=e,t;case R:return h(e,(0,t._init)(t._payload),n)}if(te(t)||F(t))return(t=Fu(t,e.mode,n,null)).return=e,t;ys(e,t)}return null}function p(e,t,n,r){var a=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==a?null:l(e,t,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===a?u(e,t,n,r):null;case k:return n.key===a?c(e,t,n,r):null;case R:return p(e,t,(a=n._init)(n._payload),r)}if(te(n)||F(n))return null!==a?null:d(e,t,n,r,null);ys(e,n)}return null}function f(e,t,n,r,a){if("string"===typeof r&&""!==r||"number"===typeof r)return l(t,e=e.get(n)||null,""+r,a);if("object"===typeof r&&null!==r){switch(r.$$typeof){case w:return u(t,e=e.get(null===r.key?n:r.key)||null,r,a);case k:return c(t,e=e.get(null===r.key?n:r.key)||null,r,a);case R:return f(e,t,n,(0,r._init)(r._payload),a)}if(te(r)||F(r))return d(t,e=e.get(n)||null,r,a,null);ys(t,r)}return null}function m(a,s,o,l){for(var u=null,c=null,d=s,m=s=0,g=null;null!==d&&m<o.length;m++){d.index>m?(g=d,d=null):g=d.sibling;var y=p(a,d,o[m],l);if(null===y){null===d&&(d=g);break}e&&d&&null===y.alternate&&t(a,d),s=i(y,s,m),null===c?u=y:c.sibling=y,c=y,d=g}if(m===o.length)return n(a,d),as&&Ja(a,m),u;if(null===d){for(;m<o.length;m++)null!==(d=h(a,o[m],l))&&(s=i(d,s,m),null===c?u=d:c.sibling=d,c=d);return as&&Ja(a,m),u}for(d=r(a,d);m<o.length;m++)null!==(g=f(d,a,m,o[m],l))&&(e&&null!==g.alternate&&d.delete(null===g.key?m:g.key),s=i(g,s,m),null===c?u=g:c.sibling=g,c=g);return e&&d.forEach((function(e){return t(a,e)})),as&&Ja(a,m),u}function g(a,o,l,u){var c=F(l);if("function"!==typeof c)throw Error(s(150));if(null==(l=c.call(l)))throw Error(s(151));for(var d=c=null,m=o,g=o=0,y=null,b=l.next();null!==m&&!b.done;g++,b=l.next()){m.index>g?(y=m,m=null):y=m.sibling;var v=p(a,m,b.value,u);if(null===v){null===m&&(m=y);break}e&&m&&null===v.alternate&&t(a,m),o=i(v,o,g),null===d?c=v:d.sibling=v,d=v,m=y}if(b.done)return n(a,m),as&&Ja(a,g),c;if(null===m){for(;!b.done;g++,b=l.next())null!==(b=h(a,b.value,u))&&(o=i(b,o,g),null===d?c=b:d.sibling=b,d=b);return as&&Ja(a,g),c}for(m=r(a,m);!b.done;g++,b=l.next())null!==(b=f(m,a,g,b.value,u))&&(e&&null!==b.alternate&&m.delete(null===b.key?g:b.key),o=i(b,o,g),null===d?c=b:d.sibling=b,d=b);return e&&m.forEach((function(e){return t(a,e)})),as&&Ja(a,g),c}return function e(r,s,i,l){if("object"===typeof i&&null!==i&&i.type===S&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case w:e:{for(var u=i.key,c=s;null!==c;){if(c.key===u){if((u=i.type)===S){if(7===c.tag){n(r,c.sibling),(s=a(c,i.props.children)).return=r,r=s;break e}}else if(c.elementType===u||"object"===typeof u&&null!==u&&u.$$typeof===R&&bs(u)===c.type){n(r,c.sibling),(s=a(c,i.props)).ref=gs(r,c,i),s.return=r,r=s;break e}n(r,c);break}t(r,c),c=c.sibling}i.type===S?((s=Fu(i.props.children,r.mode,l,i.key)).return=r,r=s):((l=Mu(i.type,i.key,i.props,null,r.mode,l)).ref=gs(r,s,i),l.return=r,r=l)}return o(r);case k:e:{for(c=i.key;null!==s;){if(s.key===c){if(4===s.tag&&s.stateNode.containerInfo===i.containerInfo&&s.stateNode.implementation===i.implementation){n(r,s.sibling),(s=a(s,i.children||[])).return=r,r=s;break e}n(r,s);break}t(r,s),s=s.sibling}(s=Lu(i,r.mode,l)).return=r,r=s}return o(r);case R:return e(r,s,(c=i._init)(i._payload),l)}if(te(i))return m(r,s,i,l);if(F(i))return g(r,s,i,l);ys(r,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==s&&6===s.tag?(n(r,s.sibling),(s=a(s,i)).return=r,r=s):(n(r,s),(s=Pu(i,r.mode,l)).return=r,r=s),o(r)):n(r,s)}}var xs=vs(!0),ws=vs(!1),ks=Ia(null),Ss=null,Is=null,Cs=null;function Ns(){Cs=Is=Ss=null}function Ts(e){var t=ks.current;Ca(ks),e._currentValue=t}function Es(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function As(e,t){Ss=e,Cs=Is=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(vo=!0),e.firstContext=null)}function _s(e){var t=e._currentValue;if(Cs!==e)if(e={context:e,memoizedValue:t,next:null},null===Is){if(null===Ss)throw Error(s(308));Is=e,Ss.dependencies={lanes:0,firstContext:e}}else Is=Is.next=e;return t}var $s=null;function Rs(e){null===$s?$s=[e]:$s.push(e)}function Ds(e,t,n,r){var a=t.interleaved;return null===a?(n.next=n,Rs(t)):(n.next=a.next,a.next=n),t.interleaved=n,Ms(e,r)}function Ms(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Fs=!1;function Os(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Ps(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Ls(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function zs(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&El)){var a=r.pending;return null===a?t.next=t:(t.next=a.next,a.next=t),r.pending=t,Ms(e,n)}return null===(a=r.interleaved)?(t.next=t,Rs(r)):(t.next=a.next,a.next=t),r.interleaved=t,Ms(e,n)}function Bs(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}function Ws(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var a=null,s=null;if(null!==(n=n.firstBaseUpdate)){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===s?a=s=i:s=s.next=i,n=n.next}while(null!==n);null===s?a=s=t:s=s.next=t}else a=s=t;return n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:s,shared:r.shared,effects:r.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Vs(e,t,n,r){var a=e.updateQueue;Fs=!1;var s=a.firstBaseUpdate,i=a.lastBaseUpdate,o=a.shared.pending;if(null!==o){a.shared.pending=null;var l=o,u=l.next;l.next=null,null===i?s=u:i.next=u,i=l;var c=e.alternate;null!==c&&((o=(c=c.updateQueue).lastBaseUpdate)!==i&&(null===o?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(null!==s){var d=a.baseState;for(i=0,c=u=l=null,o=s;;){var h=o.lane,p=o.eventTime;if((r&h)===h){null!==c&&(c=c.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(h=t,p=n,m.tag){case 1:if("function"===typeof(f=m.payload)){d=f.call(p,d,h);break e}d=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(h="function"===typeof(f=m.payload)?f.call(p,d,h):f)||void 0===h)break e;d=P({},d,h);break e;case 2:Fs=!0}}null!==o.callback&&0!==o.lane&&(e.flags|=64,null===(h=a.effects)?a.effects=[o]:h.push(o))}else p={eventTime:p,lane:h,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===c?(u=c=p,l=d):c=c.next=p,i|=h;if(null===(o=o.next)){if(null===(o=a.shared.pending))break;o=(h=o).next,h.next=null,a.lastBaseUpdate=h,a.shared.pending=null}}if(null===c&&(l=d),a.baseState=l,a.firstBaseUpdate=u,a.lastBaseUpdate=c,null!==(t=a.shared.interleaved)){a=t;do{i|=a.lane,a=a.next}while(a!==t)}else null===s&&(a.shared.lanes=0);Ol|=i,e.lanes=i,e.memoizedState=d}}function Us(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var r=e[t],a=r.callback;if(null!==a){if(r.callback=null,r=n,"function"!==typeof a)throw Error(s(191,a));a.call(r)}}}var js={},Gs=Ia(js),Hs=Ia(js),qs=Ia(js);function Ks(e){if(e===js)throw Error(s(174));return e}function Xs(e,t){switch(Na(qs,t),Na(Hs,e),Na(Gs,js),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:le(null,"");break;default:t=le(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Ca(Gs),Na(Gs,t)}function Ys(){Ca(Gs),Ca(Hs),Ca(qs)}function Qs(e){Ks(qs.current);var t=Ks(Gs.current),n=le(t,e.type);t!==n&&(Na(Hs,e),Na(Gs,n))}function Js(e){Hs.current===e&&(Ca(Gs),Ca(Hs))}var Zs=Ia(0);function ei(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ti=[];function ni(){for(var e=0;e<ti.length;e++)ti[e]._workInProgressVersionPrimary=null;ti.length=0}var ri=x.ReactCurrentDispatcher,ai=x.ReactCurrentBatchConfig,si=0,ii=null,oi=null,li=null,ui=!1,ci=!1,di=0,hi=0;function pi(){throw Error(s(321))}function fi(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!or(e[n],t[n]))return!1;return!0}function mi(e,t,n,r,a,i){if(si=i,ii=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,ri.current=null===e||null===e.memoizedState?Ji:Zi,e=n(r,a),ci){i=0;do{if(ci=!1,di=0,25<=i)throw Error(s(301));i+=1,li=oi=null,t.updateQueue=null,ri.current=eo,e=n(r,a)}while(ci)}if(ri.current=Qi,t=null!==oi&&null!==oi.next,si=0,li=oi=ii=null,ui=!1,t)throw Error(s(300));return e}function gi(){var e=0!==di;return di=0,e}function yi(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===li?ii.memoizedState=li=e:li=li.next=e,li}function bi(){if(null===oi){var e=ii.alternate;e=null!==e?e.memoizedState:null}else e=oi.next;var t=null===li?ii.memoizedState:li.next;if(null!==t)li=t,oi=e;else{if(null===e)throw Error(s(310));e={memoizedState:(oi=e).memoizedState,baseState:oi.baseState,baseQueue:oi.baseQueue,queue:oi.queue,next:null},null===li?ii.memoizedState=li=e:li=li.next=e}return li}function vi(e,t){return"function"===typeof t?t(e):t}function xi(e){var t=bi(),n=t.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=e;var r=oi,a=r.baseQueue,i=n.pending;if(null!==i){if(null!==a){var o=a.next;a.next=i.next,i.next=o}r.baseQueue=a=i,n.pending=null}if(null!==a){i=a.next,r=r.baseState;var l=o=null,u=null,c=i;do{var d=c.lane;if((si&d)===d)null!==u&&(u=u.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),r=c.hasEagerState?c.eagerState:e(r,c.action);else{var h={lane:d,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};null===u?(l=u=h,o=r):u=u.next=h,ii.lanes|=d,Ol|=d}c=c.next}while(null!==c&&c!==i);null===u?o=r:u.next=l,or(r,t.memoizedState)||(vo=!0),t.memoizedState=r,t.baseState=o,t.baseQueue=u,n.lastRenderedState=r}if(null!==(e=n.interleaved)){a=e;do{i=a.lane,ii.lanes|=i,Ol|=i,a=a.next}while(a!==e)}else null===a&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function wi(e){var t=bi(),n=t.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=e;var r=n.dispatch,a=n.pending,i=t.memoizedState;if(null!==a){n.pending=null;var o=a=a.next;do{i=e(i,o.action),o=o.next}while(o!==a);or(i,t.memoizedState)||(vo=!0),t.memoizedState=i,null===t.baseQueue&&(t.baseState=i),n.lastRenderedState=i}return[i,r]}function ki(){}function Si(e,t){var n=ii,r=bi(),a=t(),i=!or(r.memoizedState,a);if(i&&(r.memoizedState=a,vo=!0),r=r.queue,Fi(Ni.bind(null,n,r,e),[e]),r.getSnapshot!==t||i||null!==li&&1&li.memoizedState.tag){if(n.flags|=2048,_i(9,Ci.bind(null,n,r,a,t),void 0,null),null===Al)throw Error(s(349));0!==(30&si)||Ii(n,t,a)}return a}function Ii(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ci(e,t,n,r){t.value=n,t.getSnapshot=r,Ti(t)&&Ei(e)}function Ni(e,t,n){return n((function(){Ti(t)&&Ei(e)}))}function Ti(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!or(e,n)}catch(r){return!0}}function Ei(e){var t=Ms(e,1);null!==t&&nu(t,e,1,-1)}function Ai(e){var t=yi();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:vi,lastRenderedState:e},t.queue=e,e=e.dispatch=qi.bind(null,ii,e),[t.memoizedState,e]}function _i(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function $i(){return bi().memoizedState}function Ri(e,t,n,r){var a=yi();ii.flags|=e,a.memoizedState=_i(1|t,n,void 0,void 0===r?null:r)}function Di(e,t,n,r){var a=bi();r=void 0===r?null:r;var s=void 0;if(null!==oi){var i=oi.memoizedState;if(s=i.destroy,null!==r&&fi(r,i.deps))return void(a.memoizedState=_i(t,n,s,r))}ii.flags|=e,a.memoizedState=_i(1|t,n,s,r)}function Mi(e,t){return Ri(8390656,8,e,t)}function Fi(e,t){return Di(2048,8,e,t)}function Oi(e,t){return Di(4,2,e,t)}function Pi(e,t){return Di(4,4,e,t)}function Li(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function zi(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Di(4,4,Li.bind(null,t,e),n)}function Bi(){}function Wi(e,t){var n=bi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fi(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Vi(e,t){var n=bi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fi(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Ui(e,t,n){return 0===(21&si)?(e.baseState&&(e.baseState=!1,vo=!0),e.memoizedState=n):(or(n,t)||(n=mt(),ii.lanes|=n,Ol|=n,e.baseState=!0),t)}function ji(e,t){var n=vt;vt=0!==n&&4>n?n:4,e(!0);var r=ai.transition;ai.transition={};try{e(!1),t()}finally{vt=n,ai.transition=r}}function Gi(){return bi().memoizedState}function Hi(e,t,n){var r=tu(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},Ki(e))Xi(t,n);else if(null!==(n=Ds(e,t,n,r))){nu(n,e,r,eu()),Yi(n,t,r)}}function qi(e,t,n){var r=tu(e),a={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ki(e))Xi(t,a);else{var s=e.alternate;if(0===e.lanes&&(null===s||0===s.lanes)&&null!==(s=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=s(i,n);if(a.hasEagerState=!0,a.eagerState=o,or(o,i)){var l=t.interleaved;return null===l?(a.next=a,Rs(t)):(a.next=l.next,l.next=a),void(t.interleaved=a)}}catch(u){}null!==(n=Ds(e,t,a,r))&&(nu(n,e,r,a=eu()),Yi(n,t,r))}}function Ki(e){var t=e.alternate;return e===ii||null!==t&&t===ii}function Xi(e,t){ci=ui=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Yi(e,t,n){if(0!==(4194240&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}var Qi={readContext:_s,useCallback:pi,useContext:pi,useEffect:pi,useImperativeHandle:pi,useInsertionEffect:pi,useLayoutEffect:pi,useMemo:pi,useReducer:pi,useRef:pi,useState:pi,useDebugValue:pi,useDeferredValue:pi,useTransition:pi,useMutableSource:pi,useSyncExternalStore:pi,useId:pi,unstable_isNewReconciler:!1},Ji={readContext:_s,useCallback:function(e,t){return yi().memoizedState=[e,void 0===t?null:t],e},useContext:_s,useEffect:Mi,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Ri(4194308,4,Li.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Ri(4194308,4,e,t)},useInsertionEffect:function(e,t){return Ri(4,2,e,t)},useMemo:function(e,t){var n=yi();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=yi();return t=void 0!==n?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=Hi.bind(null,ii,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},yi().memoizedState=e},useState:Ai,useDebugValue:Bi,useDeferredValue:function(e){return yi().memoizedState=e},useTransition:function(){var e=Ai(!1),t=e[0];return e=ji.bind(null,e[1]),yi().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=ii,a=yi();if(as){if(void 0===n)throw Error(s(407));n=n()}else{if(n=t(),null===Al)throw Error(s(349));0!==(30&si)||Ii(r,t,n)}a.memoizedState=n;var i={value:n,getSnapshot:t};return a.queue=i,Mi(Ni.bind(null,r,i,e),[e]),r.flags|=2048,_i(9,Ci.bind(null,r,i,n,t),void 0,null),n},useId:function(){var e=yi(),t=Al.identifierPrefix;if(as){var n=Qa;t=":"+t+"R"+(n=(Ya&~(1<<32-it(Ya)-1)).toString(32)+n),0<(n=di++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=hi++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},Zi={readContext:_s,useCallback:Wi,useContext:_s,useEffect:Fi,useImperativeHandle:zi,useInsertionEffect:Oi,useLayoutEffect:Pi,useMemo:Vi,useReducer:xi,useRef:$i,useState:function(){return xi(vi)},useDebugValue:Bi,useDeferredValue:function(e){return Ui(bi(),oi.memoizedState,e)},useTransition:function(){return[xi(vi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1},eo={readContext:_s,useCallback:Wi,useContext:_s,useEffect:Fi,useImperativeHandle:zi,useInsertionEffect:Oi,useLayoutEffect:Pi,useMemo:Vi,useReducer:wi,useRef:$i,useState:function(){return wi(vi)},useDebugValue:Bi,useDeferredValue:function(e){var t=bi();return null===oi?t.memoizedState=e:Ui(t,oi.memoizedState,e)},useTransition:function(){return[wi(vi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1};function to(e,t){if(e&&e.defaultProps){for(var n in t=P({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function no(e,t,n,r){n=null===(n=n(r,t=e.memoizedState))||void 0===n?t:P({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var ro={isMounted:function(e){return!!(e=e._reactInternals)&&Ve(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=eu(),a=tu(e),s=Ls(r,a);s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=zs(e,s,a))&&(nu(t,e,a,r),Bs(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=eu(),a=tu(e),s=Ls(r,a);s.tag=1,s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=zs(e,s,a))&&(nu(t,e,a,r),Bs(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=eu(),r=tu(e),a=Ls(n,r);a.tag=2,void 0!==t&&null!==t&&(a.callback=t),null!==(t=zs(e,a,r))&&(nu(t,e,r,n),Bs(t,e,r))}};function ao(e,t,n,r,a,s,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,s,i):!t.prototype||!t.prototype.isPureReactComponent||(!lr(n,r)||!lr(a,s))}function so(e,t,n){var r=!1,a=Ta,s=t.contextType;return"object"===typeof s&&null!==s?s=_s(s):(a=Ra(t)?_a:Ea.current,s=(r=null!==(r=t.contextTypes)&&void 0!==r)?$a(e,a):Ta),t=new t(n,s),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ro,e.stateNode=t,t._reactInternals=e,r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=s),t}function io(e,t,n,r){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&ro.enqueueReplaceState(t,t.state,null)}function oo(e,t,n,r){var a=e.stateNode;a.props=n,a.state=e.memoizedState,a.refs={},Os(e);var s=t.contextType;"object"===typeof s&&null!==s?a.context=_s(s):(s=Ra(t)?_a:Ea.current,a.context=$a(e,s)),a.state=e.memoizedState,"function"===typeof(s=t.getDerivedStateFromProps)&&(no(e,t,s,n),a.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof a.getSnapshotBeforeUpdate||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||(t=a.state,"function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),t!==a.state&&ro.enqueueReplaceState(a,a.state,null),Vs(e,n,a,r),a.state=e.memoizedState),"function"===typeof a.componentDidMount&&(e.flags|=4194308)}function lo(e,t){try{var n="",r=t;do{n+=W(r),r=r.return}while(r);var a=n}catch(s){a="\nError generating stack: "+s.message+"\n"+s.stack}return{value:e,source:t,stack:a,digest:null}}function uo(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function co(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}var ho="function"===typeof WeakMap?WeakMap:Map;function po(e,t,n){(n=Ls(-1,n)).tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){jl||(jl=!0,Gl=r),co(0,t)},n}function fo(e,t,n){(n=Ls(-1,n)).tag=3;var r=e.type.getDerivedStateFromError;if("function"===typeof r){var a=t.value;n.payload=function(){return r(a)},n.callback=function(){co(0,t)}}var s=e.stateNode;return null!==s&&"function"===typeof s.componentDidCatch&&(n.callback=function(){co(0,t),"function"!==typeof r&&(null===Hl?Hl=new Set([this]):Hl.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function mo(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new ho;var a=new Set;r.set(t,a)}else void 0===(a=r.get(t))&&(a=new Set,r.set(t,a));a.has(n)||(a.add(n),e=Cu.bind(null,e,t,n),t.then(e,e))}function go(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function yo(e,t,n,r,a){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Ls(-1,1)).tag=2,zs(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=a,e)}var bo=x.ReactCurrentOwner,vo=!1;function xo(e,t,n,r){t.child=null===e?ws(t,null,n,r):xs(t,e.child,n,r)}function wo(e,t,n,r,a){n=n.render;var s=t.ref;return As(t,a),r=mi(e,t,n,r,s,a),n=gi(),null===e||vo?(as&&n&&es(t),t.flags|=1,xo(e,t,r,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,jo(e,t,a))}function ko(e,t,n,r,a){if(null===e){var s=n.type;return"function"!==typeof s||Ru(s)||void 0!==s.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Mu(n.type,null,r,t,t.mode,a)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=s,So(e,t,s,r,a))}if(s=e.child,0===(e.lanes&a)){var i=s.memoizedProps;if((n=null!==(n=n.compare)?n:lr)(i,r)&&e.ref===t.ref)return jo(e,t,a)}return t.flags|=1,(e=Du(s,r)).ref=t.ref,e.return=t,t.child=e}function So(e,t,n,r,a){if(null!==e){var s=e.memoizedProps;if(lr(s,r)&&e.ref===t.ref){if(vo=!1,t.pendingProps=r=s,0===(e.lanes&a))return t.lanes=e.lanes,jo(e,t,a);0!==(131072&e.flags)&&(vo=!0)}}return No(e,t,n,r,a)}function Io(e,t,n){var r=t.pendingProps,a=r.children,s=null!==e?e.memoizedState:null;if("hidden"===r.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Na(Dl,Rl),Rl|=n;else{if(0===(1073741824&n))return e=null!==s?s.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Na(Dl,Rl),Rl|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==s?s.baseLanes:n,Na(Dl,Rl),Rl|=r}else null!==s?(r=s.baseLanes|n,t.memoizedState=null):r=n,Na(Dl,Rl),Rl|=r;return xo(e,t,a,n),t.child}function Co(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function No(e,t,n,r,a){var s=Ra(n)?_a:Ea.current;return s=$a(t,s),As(t,a),n=mi(e,t,n,r,s,a),r=gi(),null===e||vo?(as&&r&&es(t),t.flags|=1,xo(e,t,n,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,jo(e,t,a))}function To(e,t,n,r,a){if(Ra(n)){var s=!0;Oa(t)}else s=!1;if(As(t,a),null===t.stateNode)Uo(e,t),so(t,n,r),oo(t,n,r,a),r=!0;else if(null===e){var i=t.stateNode,o=t.memoizedProps;i.props=o;var l=i.context,u=n.contextType;"object"===typeof u&&null!==u?u=_s(u):u=$a(t,u=Ra(n)?_a:Ea.current);var c=n.getDerivedStateFromProps,d="function"===typeof c||"function"===typeof i.getSnapshotBeforeUpdate;d||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==r||l!==u)&&io(t,i,r,u),Fs=!1;var h=t.memoizedState;i.state=h,Vs(t,r,i,a),l=t.memoizedState,o!==r||h!==l||Aa.current||Fs?("function"===typeof c&&(no(t,n,c,r),l=t.memoizedState),(o=Fs||ao(t,n,o,r,h,l,u))?(d||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(t.flags|=4194308)):("function"===typeof i.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),i.props=r,i.state=l,i.context=u,r=o):("function"===typeof i.componentDidMount&&(t.flags|=4194308),r=!1)}else{i=t.stateNode,Ps(e,t),o=t.memoizedProps,u=t.type===t.elementType?o:to(t.type,o),i.props=u,d=t.pendingProps,h=i.context,"object"===typeof(l=n.contextType)&&null!==l?l=_s(l):l=$a(t,l=Ra(n)?_a:Ea.current);var p=n.getDerivedStateFromProps;(c="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==d||h!==l)&&io(t,i,r,l),Fs=!1,h=t.memoizedState,i.state=h,Vs(t,r,i,a);var f=t.memoizedState;o!==d||h!==f||Aa.current||Fs?("function"===typeof p&&(no(t,n,p,r),f=t.memoizedState),(u=Fs||ao(t,n,u,r,h,f,l)||!1)?(c||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(r,f,l),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(r,f,l)),"function"===typeof i.componentDidUpdate&&(t.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),i.props=r,i.state=f,i.context=l,r=u):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),r=!1)}return Eo(e,t,n,r,s,a)}function Eo(e,t,n,r,a,s){Co(e,t);var i=0!==(128&t.flags);if(!r&&!i)return a&&Pa(t,n,!1),jo(e,t,s);r=t.stateNode,bo.current=t;var o=i&&"function"!==typeof n.getDerivedStateFromError?null:r.render();return t.flags|=1,null!==e&&i?(t.child=xs(t,e.child,null,s),t.child=xs(t,null,o,s)):xo(e,t,o,s),t.memoizedState=r.state,a&&Pa(t,n,!0),t.child}function Ao(e){var t=e.stateNode;t.pendingContext?Ma(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Ma(0,t.context,!1),Xs(e,t.containerInfo)}function _o(e,t,n,r,a){return ps(),fs(a),t.flags|=256,xo(e,t,n,r),t.child}var $o,Ro,Do,Mo,Fo={dehydrated:null,treeContext:null,retryLane:0};function Oo(e){return{baseLanes:e,cachePool:null,transitions:null}}function Po(e,t,n){var r,a=t.pendingProps,i=Zs.current,o=!1,l=0!==(128&t.flags);if((r=l)||(r=(null===e||null!==e.memoizedState)&&0!==(2&i)),r?(o=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(i|=1),Na(Zs,1&i),null===e)return us(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(l=a.children,e=a.fallback,o?(a=t.mode,o=t.child,l={mode:"hidden",children:l},0===(1&a)&&null!==o?(o.childLanes=0,o.pendingProps=l):o=Ou(l,a,0,null),e=Fu(e,a,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=Oo(n),t.memoizedState=Fo,e):Lo(t,l));if(null!==(i=e.memoizedState)&&null!==(r=i.dehydrated))return function(e,t,n,r,a,i,o){if(n)return 256&t.flags?(t.flags&=-257,zo(e,t,o,r=uo(Error(s(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(i=r.fallback,a=t.mode,r=Ou({mode:"visible",children:r.children},a,0,null),(i=Fu(i,a,o,null)).flags|=2,r.return=t,i.return=t,r.sibling=i,t.child=r,0!==(1&t.mode)&&xs(t,e.child,null,o),t.child.memoizedState=Oo(o),t.memoizedState=Fo,i);if(0===(1&t.mode))return zo(e,t,o,null);if("$!"===a.data){if(r=a.nextSibling&&a.nextSibling.dataset)var l=r.dgst;return r=l,zo(e,t,o,r=uo(i=Error(s(419)),r,void 0))}if(l=0!==(o&e.childLanes),vo||l){if(null!==(r=Al)){switch(o&-o){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}0!==(a=0!==(a&(r.suspendedLanes|o))?0:a)&&a!==i.retryLane&&(i.retryLane=a,Ms(e,a),nu(r,e,a,-1))}return mu(),zo(e,t,o,r=uo(Error(s(421))))}return"$?"===a.data?(t.flags|=128,t.child=e.child,t=Tu.bind(null,e),a._reactRetry=t,null):(e=i.treeContext,rs=ua(a.nextSibling),ns=t,as=!0,ss=null,null!==e&&(qa[Ka++]=Ya,qa[Ka++]=Qa,qa[Ka++]=Xa,Ya=e.id,Qa=e.overflow,Xa=t),t=Lo(t,r.children),t.flags|=4096,t)}(e,t,l,a,r,i,n);if(o){o=a.fallback,l=t.mode,r=(i=e.child).sibling;var u={mode:"hidden",children:a.children};return 0===(1&l)&&t.child!==i?((a=t.child).childLanes=0,a.pendingProps=u,t.deletions=null):(a=Du(i,u)).subtreeFlags=14680064&i.subtreeFlags,null!==r?o=Du(r,o):(o=Fu(o,l,n,null)).flags|=2,o.return=t,a.return=t,a.sibling=o,t.child=a,a=o,o=t.child,l=null===(l=e.child.memoizedState)?Oo(n):{baseLanes:l.baseLanes|n,cachePool:null,transitions:l.transitions},o.memoizedState=l,o.childLanes=e.childLanes&~n,t.memoizedState=Fo,a}return e=(o=e.child).sibling,a=Du(o,{mode:"visible",children:a.children}),0===(1&t.mode)&&(a.lanes=n),a.return=t,a.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=a,t.memoizedState=null,a}function Lo(e,t){return(t=Ou({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function zo(e,t,n,r){return null!==r&&fs(r),xs(t,e.child,null,n),(e=Lo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Bo(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),Es(e.return,t,n)}function Wo(e,t,n,r,a){var s=e.memoizedState;null===s?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(s.isBackwards=t,s.rendering=null,s.renderingStartTime=0,s.last=r,s.tail=n,s.tailMode=a)}function Vo(e,t,n){var r=t.pendingProps,a=r.revealOrder,s=r.tail;if(xo(e,t,r.children,n),0!==(2&(r=Zs.current)))r=1&r|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Bo(e,n,t);else if(19===e.tag)Bo(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Na(Zs,r),0===(1&t.mode))t.memoizedState=null;else switch(a){case"forwards":for(n=t.child,a=null;null!==n;)null!==(e=n.alternate)&&null===ei(e)&&(a=n),n=n.sibling;null===(n=a)?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),Wo(t,!1,a,n,s);break;case"backwards":for(n=null,a=t.child,t.child=null;null!==a;){if(null!==(e=a.alternate)&&null===ei(e)){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}Wo(t,!0,n,null,s);break;case"together":Wo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Uo(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function jo(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Ol|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(s(153));if(null!==t.child){for(n=Du(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Du(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Go(e,t){if(!as)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Ho(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=14680064&a.subtreeFlags,r|=14680064&a.flags,a.return=e,a=a.sibling;else for(a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function qo(e,t,n){var r=t.pendingProps;switch(ts(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ho(t),null;case 1:case 17:return Ra(t.type)&&Da(),Ho(t),null;case 3:return r=t.stateNode,Ys(),Ca(Aa),Ca(Ea),ni(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==e&&null!==e.child||(ds(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==ss&&(iu(ss),ss=null))),Ro(e,t),Ho(t),null;case 5:Js(t);var a=Ks(qs.current);if(n=t.type,null!==e&&null!=t.stateNode)Do(e,t,n,r,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(null===t.stateNode)throw Error(s(166));return Ho(t),null}if(e=Ks(Gs.current),ds(t)){r=t.stateNode,n=t.type;var i=t.memoizedProps;switch(r[ha]=t,r[pa]=i,e=0!==(1&t.mode),n){case"dialog":zr("cancel",r),zr("close",r);break;case"iframe":case"object":case"embed":zr("load",r);break;case"video":case"audio":for(a=0;a<Fr.length;a++)zr(Fr[a],r);break;case"source":zr("error",r);break;case"img":case"image":case"link":zr("error",r),zr("load",r);break;case"details":zr("toggle",r);break;case"input":Y(r,i),zr("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!i.multiple},zr("invalid",r);break;case"textarea":ae(r,i),zr("invalid",r)}for(var l in be(n,i),a=null,i)if(i.hasOwnProperty(l)){var u=i[l];"children"===l?"string"===typeof u?r.textContent!==u&&(!0!==i.suppressHydrationWarning&&Jr(r.textContent,u,e),a=["children",u]):"number"===typeof u&&r.textContent!==""+u&&(!0!==i.suppressHydrationWarning&&Jr(r.textContent,u,e),a=["children",""+u]):o.hasOwnProperty(l)&&null!=u&&"onScroll"===l&&zr("scroll",r)}switch(n){case"input":H(r),Z(r,i,!0);break;case"textarea":H(r),ie(r);break;case"select":case"option":break;default:"function"===typeof i.onClick&&(r.onclick=Zr)}r=a,t.updateQueue=r,null!==r&&(t.flags|=4)}else{l=9===a.nodeType?a:a.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=oe(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=l.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof r.is?e=l.createElement(n,{is:r.is}):(e=l.createElement(n),"select"===n&&(l=e,r.multiple?l.multiple=!0:r.size&&(l.size=r.size))):e=l.createElementNS(e,n),e[ha]=t,e[pa]=r,$o(e,t,!1,!1),t.stateNode=e;e:{switch(l=ve(n,r),n){case"dialog":zr("cancel",e),zr("close",e),a=r;break;case"iframe":case"object":case"embed":zr("load",e),a=r;break;case"video":case"audio":for(a=0;a<Fr.length;a++)zr(Fr[a],e);a=r;break;case"source":zr("error",e),a=r;break;case"img":case"image":case"link":zr("error",e),zr("load",e),a=r;break;case"details":zr("toggle",e),a=r;break;case"input":Y(e,r),a=X(e,r),zr("invalid",e);break;case"option":default:a=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},a=P({},r,{value:void 0}),zr("invalid",e);break;case"textarea":ae(e,r),a=re(e,r),zr("invalid",e)}for(i in be(n,a),u=a)if(u.hasOwnProperty(i)){var c=u[i];"style"===i?ge(e,c):"dangerouslySetInnerHTML"===i?null!=(c=c?c.__html:void 0)&&de(e,c):"children"===i?"string"===typeof c?("textarea"!==n||""!==c)&&he(e,c):"number"===typeof c&&he(e,""+c):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(o.hasOwnProperty(i)?null!=c&&"onScroll"===i&&zr("scroll",e):null!=c&&v(e,i,c,l))}switch(n){case"input":H(e),Z(e,r,!1);break;case"textarea":H(e),ie(e);break;case"option":null!=r.value&&e.setAttribute("value",""+j(r.value));break;case"select":e.multiple=!!r.multiple,null!=(i=r.value)?ne(e,!!r.multiple,i,!1):null!=r.defaultValue&&ne(e,!!r.multiple,r.defaultValue,!0);break;default:"function"===typeof a.onClick&&(e.onclick=Zr)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Ho(t),null;case 6:if(e&&null!=t.stateNode)Mo(e,t,e.memoizedProps,r);else{if("string"!==typeof r&&null===t.stateNode)throw Error(s(166));if(n=Ks(qs.current),Ks(Gs.current),ds(t)){if(r=t.stateNode,n=t.memoizedProps,r[ha]=t,(i=r.nodeValue!==n)&&null!==(e=ns))switch(e.tag){case 3:Jr(r.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Jr(r.nodeValue,n,0!==(1&e.mode))}i&&(t.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[ha]=t,t.stateNode=r}return Ho(t),null;case 13:if(Ca(Zs),r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(as&&null!==rs&&0!==(1&t.mode)&&0===(128&t.flags))hs(),ps(),t.flags|=98560,i=!1;else if(i=ds(t),null!==r&&null!==r.dehydrated){if(null===e){if(!i)throw Error(s(318));if(!(i=null!==(i=t.memoizedState)?i.dehydrated:null))throw Error(s(317));i[ha]=t}else ps(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Ho(t),i=!1}else null!==ss&&(iu(ss),ss=null),i=!0;if(!i)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((r=null!==r)!==(null!==e&&null!==e.memoizedState)&&r&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&Zs.current)?0===Ml&&(Ml=3):mu())),null!==t.updateQueue&&(t.flags|=4),Ho(t),null);case 4:return Ys(),Ro(e,t),null===e&&Vr(t.stateNode.containerInfo),Ho(t),null;case 10:return Ts(t.type._context),Ho(t),null;case 19:if(Ca(Zs),null===(i=t.memoizedState))return Ho(t),null;if(r=0!==(128&t.flags),null===(l=i.rendering))if(r)Go(i,!1);else{if(0!==Ml||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(l=ei(e))){for(t.flags|=128,Go(i,!1),null!==(r=l.updateQueue)&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;null!==n;)e=r,(i=n).flags&=14680066,null===(l=i.alternate)?(i.childLanes=0,i.lanes=e,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=l.childLanes,i.lanes=l.lanes,i.child=l.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=l.memoizedProps,i.memoizedState=l.memoizedState,i.updateQueue=l.updateQueue,i.type=l.type,e=l.dependencies,i.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Na(Zs,1&Zs.current|2),t.child}e=e.sibling}null!==i.tail&&Qe()>Vl&&(t.flags|=128,r=!0,Go(i,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=ei(l))){if(t.flags|=128,r=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Go(i,!0),null===i.tail&&"hidden"===i.tailMode&&!l.alternate&&!as)return Ho(t),null}else 2*Qe()-i.renderingStartTime>Vl&&1073741824!==n&&(t.flags|=128,r=!0,Go(i,!1),t.lanes=4194304);i.isBackwards?(l.sibling=t.child,t.child=l):(null!==(n=i.last)?n.sibling=l:t.child=l,i.last=l)}return null!==i.tail?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.renderingStartTime=Qe(),t.sibling=null,n=Zs.current,Na(Zs,r?1&n|2:1&n),t):(Ho(t),null);case 22:case 23:return du(),r=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==r&&(t.flags|=8192),r&&0!==(1&t.mode)?0!==(1073741824&Rl)&&(Ho(t),6&t.subtreeFlags&&(t.flags|=8192)):Ho(t),null;case 24:case 25:return null}throw Error(s(156,t.tag))}function Ko(e,t){switch(ts(t),t.tag){case 1:return Ra(t.type)&&Da(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Ys(),Ca(Aa),Ca(Ea),ni(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return Js(t),null;case 13:if(Ca(Zs),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(s(340));ps()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Ca(Zs),null;case 4:return Ys(),null;case 10:return Ts(t.type._context),null;case 22:case 23:return du(),null;default:return null}}$o=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Ro=function(){},Do=function(e,t,n,r){var a=e.memoizedProps;if(a!==r){e=t.stateNode,Ks(Gs.current);var s,i=null;switch(n){case"input":a=X(e,a),r=X(e,r),i=[];break;case"select":a=P({},a,{value:void 0}),r=P({},r,{value:void 0}),i=[];break;case"textarea":a=re(e,a),r=re(e,r),i=[];break;default:"function"!==typeof a.onClick&&"function"===typeof r.onClick&&(e.onclick=Zr)}for(c in be(n,r),n=null,a)if(!r.hasOwnProperty(c)&&a.hasOwnProperty(c)&&null!=a[c])if("style"===c){var l=a[c];for(s in l)l.hasOwnProperty(s)&&(n||(n={}),n[s]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(o.hasOwnProperty(c)?i||(i=[]):(i=i||[]).push(c,null));for(c in r){var u=r[c];if(l=null!=a?a[c]:void 0,r.hasOwnProperty(c)&&u!==l&&(null!=u||null!=l))if("style"===c)if(l){for(s in l)!l.hasOwnProperty(s)||u&&u.hasOwnProperty(s)||(n||(n={}),n[s]="");for(s in u)u.hasOwnProperty(s)&&l[s]!==u[s]&&(n||(n={}),n[s]=u[s])}else n||(i||(i=[]),i.push(c,n)),n=u;else"dangerouslySetInnerHTML"===c?(u=u?u.__html:void 0,l=l?l.__html:void 0,null!=u&&l!==u&&(i=i||[]).push(c,u)):"children"===c?"string"!==typeof u&&"number"!==typeof u||(i=i||[]).push(c,""+u):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(o.hasOwnProperty(c)?(null!=u&&"onScroll"===c&&zr("scroll",e),i||l===u||(i=[])):(i=i||[]).push(c,u))}n&&(i=i||[]).push("style",n);var c=i;(t.updateQueue=c)&&(t.flags|=4)}},Mo=function(e,t,n,r){n!==r&&(t.flags|=4)};var Xo=!1,Yo=!1,Qo="function"===typeof WeakSet?WeakSet:Set,Jo=null;function Zo(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(r){Iu(e,t,r)}else n.current=null}function el(e,t,n){try{n()}catch(r){Iu(e,t,r)}}var tl=!1;function nl(e,t,n){var r=t.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var a=r=r.next;do{if((a.tag&e)===e){var s=a.destroy;a.destroy=void 0,void 0!==s&&el(t,n,s)}a=a.next}while(a!==r)}}function rl(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function al(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function sl(e){var t=e.alternate;null!==t&&(e.alternate=null,sl(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[ha],delete t[pa],delete t[ma],delete t[ga],delete t[ya])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function il(e){return 5===e.tag||3===e.tag||4===e.tag}function ol(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||il(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function ll(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Zr));else if(4!==r&&null!==(e=e.child))for(ll(e,t,n),e=e.sibling;null!==e;)ll(e,t,n),e=e.sibling}function ul(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&null!==(e=e.child))for(ul(e,t,n),e=e.sibling;null!==e;)ul(e,t,n),e=e.sibling}var cl=null,dl=!1;function hl(e,t,n){for(n=n.child;null!==n;)pl(e,t,n),n=n.sibling}function pl(e,t,n){if(st&&"function"===typeof st.onCommitFiberUnmount)try{st.onCommitFiberUnmount(at,n)}catch(o){}switch(n.tag){case 5:Yo||Zo(n,t);case 6:var r=cl,a=dl;cl=null,hl(e,t,n),dl=a,null!==(cl=r)&&(dl?(e=cl,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):cl.removeChild(n.stateNode));break;case 18:null!==cl&&(dl?(e=cl,n=n.stateNode,8===e.nodeType?la(e.parentNode,n):1===e.nodeType&&la(e,n),Vt(e)):la(cl,n.stateNode));break;case 4:r=cl,a=dl,cl=n.stateNode.containerInfo,dl=!0,hl(e,t,n),cl=r,dl=a;break;case 0:case 11:case 14:case 15:if(!Yo&&(null!==(r=n.updateQueue)&&null!==(r=r.lastEffect))){a=r=r.next;do{var s=a,i=s.destroy;s=s.tag,void 0!==i&&(0!==(2&s)||0!==(4&s))&&el(n,t,i),a=a.next}while(a!==r)}hl(e,t,n);break;case 1:if(!Yo&&(Zo(n,t),"function"===typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(o){Iu(n,t,o)}hl(e,t,n);break;case 21:hl(e,t,n);break;case 22:1&n.mode?(Yo=(r=Yo)||null!==n.memoizedState,hl(e,t,n),Yo=r):hl(e,t,n);break;default:hl(e,t,n)}}function fl(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Qo),t.forEach((function(t){var r=Eu.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}}function ml(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var a=n[r];try{var i=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 5:cl=l.stateNode,dl=!1;break e;case 3:case 4:cl=l.stateNode.containerInfo,dl=!0;break e}l=l.return}if(null===cl)throw Error(s(160));pl(i,o,a),cl=null,dl=!1;var u=a.alternate;null!==u&&(u.return=null),a.return=null}catch(c){Iu(a,t,c)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)gl(t,e),t=t.sibling}function gl(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(ml(t,e),yl(e),4&r){try{nl(3,e,e.return),rl(3,e)}catch(g){Iu(e,e.return,g)}try{nl(5,e,e.return)}catch(g){Iu(e,e.return,g)}}break;case 1:ml(t,e),yl(e),512&r&&null!==n&&Zo(n,n.return);break;case 5:if(ml(t,e),yl(e),512&r&&null!==n&&Zo(n,n.return),32&e.flags){var a=e.stateNode;try{he(a,"")}catch(g){Iu(e,e.return,g)}}if(4&r&&null!=(a=e.stateNode)){var i=e.memoizedProps,o=null!==n?n.memoizedProps:i,l=e.type,u=e.updateQueue;if(e.updateQueue=null,null!==u)try{"input"===l&&"radio"===i.type&&null!=i.name&&Q(a,i),ve(l,o);var c=ve(l,i);for(o=0;o<u.length;o+=2){var d=u[o],h=u[o+1];"style"===d?ge(a,h):"dangerouslySetInnerHTML"===d?de(a,h):"children"===d?he(a,h):v(a,d,h,c)}switch(l){case"input":J(a,i);break;case"textarea":se(a,i);break;case"select":var p=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!i.multiple;var f=i.value;null!=f?ne(a,!!i.multiple,f,!1):p!==!!i.multiple&&(null!=i.defaultValue?ne(a,!!i.multiple,i.defaultValue,!0):ne(a,!!i.multiple,i.multiple?[]:"",!1))}a[pa]=i}catch(g){Iu(e,e.return,g)}}break;case 6:if(ml(t,e),yl(e),4&r){if(null===e.stateNode)throw Error(s(162));a=e.stateNode,i=e.memoizedProps;try{a.nodeValue=i}catch(g){Iu(e,e.return,g)}}break;case 3:if(ml(t,e),yl(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Vt(t.containerInfo)}catch(g){Iu(e,e.return,g)}break;case 4:default:ml(t,e),yl(e);break;case 13:ml(t,e),yl(e),8192&(a=e.child).flags&&(i=null!==a.memoizedState,a.stateNode.isHidden=i,!i||null!==a.alternate&&null!==a.alternate.memoizedState||(Wl=Qe())),4&r&&fl(e);break;case 22:if(d=null!==n&&null!==n.memoizedState,1&e.mode?(Yo=(c=Yo)||d,ml(t,e),Yo=c):ml(t,e),yl(e),8192&r){if(c=null!==e.memoizedState,(e.stateNode.isHidden=c)&&!d&&0!==(1&e.mode))for(Jo=e,d=e.child;null!==d;){for(h=Jo=d;null!==Jo;){switch(f=(p=Jo).child,p.tag){case 0:case 11:case 14:case 15:nl(4,p,p.return);break;case 1:Zo(p,p.return);var m=p.stateNode;if("function"===typeof m.componentWillUnmount){r=p,n=p.return;try{t=r,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(g){Iu(r,n,g)}}break;case 5:Zo(p,p.return);break;case 22:if(null!==p.memoizedState){wl(h);continue}}null!==f?(f.return=p,Jo=f):wl(h)}d=d.sibling}e:for(d=null,h=e;;){if(5===h.tag){if(null===d){d=h;try{a=h.stateNode,c?"function"===typeof(i=a.style).setProperty?i.setProperty("display","none","important"):i.display="none":(l=h.stateNode,o=void 0!==(u=h.memoizedProps.style)&&null!==u&&u.hasOwnProperty("display")?u.display:null,l.style.display=me("display",o))}catch(g){Iu(e,e.return,g)}}}else if(6===h.tag){if(null===d)try{h.stateNode.nodeValue=c?"":h.memoizedProps}catch(g){Iu(e,e.return,g)}}else if((22!==h.tag&&23!==h.tag||null===h.memoizedState||h===e)&&null!==h.child){h.child.return=h,h=h.child;continue}if(h===e)break e;for(;null===h.sibling;){if(null===h.return||h.return===e)break e;d===h&&(d=null),h=h.return}d===h&&(d=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:ml(t,e),yl(e),4&r&&fl(e);case 21:}}function yl(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(il(n)){var r=n;break e}n=n.return}throw Error(s(160))}switch(r.tag){case 5:var a=r.stateNode;32&r.flags&&(he(a,""),r.flags&=-33),ul(e,ol(e),a);break;case 3:case 4:var i=r.stateNode.containerInfo;ll(e,ol(e),i);break;default:throw Error(s(161))}}catch(o){Iu(e,e.return,o)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function bl(e,t,n){Jo=e,vl(e,t,n)}function vl(e,t,n){for(var r=0!==(1&e.mode);null!==Jo;){var a=Jo,s=a.child;if(22===a.tag&&r){var i=null!==a.memoizedState||Xo;if(!i){var o=a.alternate,l=null!==o&&null!==o.memoizedState||Yo;o=Xo;var u=Yo;if(Xo=i,(Yo=l)&&!u)for(Jo=a;null!==Jo;)l=(i=Jo).child,22===i.tag&&null!==i.memoizedState?kl(a):null!==l?(l.return=i,Jo=l):kl(a);for(;null!==s;)Jo=s,vl(s,t,n),s=s.sibling;Jo=a,Xo=o,Yo=u}xl(e)}else 0!==(8772&a.subtreeFlags)&&null!==s?(s.return=a,Jo=s):xl(e)}}function xl(e){for(;null!==Jo;){var t=Jo;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Yo||rl(5,t);break;case 1:var r=t.stateNode;if(4&t.flags&&!Yo)if(null===n)r.componentDidMount();else{var a=t.elementType===t.type?n.memoizedProps:to(t.type,n.memoizedProps);r.componentDidUpdate(a,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var i=t.updateQueue;null!==i&&Us(t,i,r);break;case 3:var o=t.updateQueue;if(null!==o){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Us(t,o,n)}break;case 5:var l=t.stateNode;if(null===n&&4&t.flags){n=l;var u=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":u.autoFocus&&n.focus();break;case"img":u.src&&(n.src=u.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var c=t.alternate;if(null!==c){var d=c.memoizedState;if(null!==d){var h=d.dehydrated;null!==h&&Vt(h)}}}break;default:throw Error(s(163))}Yo||512&t.flags&&al(t)}catch(p){Iu(t,t.return,p)}}if(t===e){Jo=null;break}if(null!==(n=t.sibling)){n.return=t.return,Jo=n;break}Jo=t.return}}function wl(e){for(;null!==Jo;){var t=Jo;if(t===e){Jo=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Jo=n;break}Jo=t.return}}function kl(e){for(;null!==Jo;){var t=Jo;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{rl(4,t)}catch(l){Iu(t,n,l)}break;case 1:var r=t.stateNode;if("function"===typeof r.componentDidMount){var a=t.return;try{r.componentDidMount()}catch(l){Iu(t,a,l)}}var s=t.return;try{al(t)}catch(l){Iu(t,s,l)}break;case 5:var i=t.return;try{al(t)}catch(l){Iu(t,i,l)}}}catch(l){Iu(t,t.return,l)}if(t===e){Jo=null;break}var o=t.sibling;if(null!==o){o.return=t.return,Jo=o;break}Jo=t.return}}var Sl,Il=Math.ceil,Cl=x.ReactCurrentDispatcher,Nl=x.ReactCurrentOwner,Tl=x.ReactCurrentBatchConfig,El=0,Al=null,_l=null,$l=0,Rl=0,Dl=Ia(0),Ml=0,Fl=null,Ol=0,Pl=0,Ll=0,zl=null,Bl=null,Wl=0,Vl=1/0,Ul=null,jl=!1,Gl=null,Hl=null,ql=!1,Kl=null,Xl=0,Yl=0,Ql=null,Jl=-1,Zl=0;function eu(){return 0!==(6&El)?Qe():-1!==Jl?Jl:Jl=Qe()}function tu(e){return 0===(1&e.mode)?1:0!==(2&El)&&0!==$l?$l&-$l:null!==ms.transition?(0===Zl&&(Zl=mt()),Zl):0!==(e=vt)?e:e=void 0===(e=window.event)?16:Yt(e.type)}function nu(e,t,n,r){if(50<Yl)throw Yl=0,Ql=null,Error(s(185));yt(e,n,r),0!==(2&El)&&e===Al||(e===Al&&(0===(2&El)&&(Pl|=n),4===Ml&&ou(e,$l)),ru(e,r),1===n&&0===El&&0===(1&t.mode)&&(Vl=Qe()+500,za&&Va()))}function ru(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,a=e.expirationTimes,s=e.pendingLanes;0<s;){var i=31-it(s),o=1<<i,l=a[i];-1===l?0!==(o&n)&&0===(o&r)||(a[i]=pt(o,t)):l<=t&&(e.expiredLanes|=o),s&=~o}}(e,t);var r=ht(e,e===Al?$l:0);if(0===r)null!==n&&Ke(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(null!=n&&Ke(n),1===t)0===e.tag?function(e){za=!0,Wa(e)}(lu.bind(null,e)):Wa(lu.bind(null,e)),ia((function(){0===(6&El)&&Va()})),n=null;else{switch(xt(r)){case 1:n=Ze;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=rt}n=Au(n,au.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function au(e,t){if(Jl=-1,Zl=0,0!==(6&El))throw Error(s(327));var n=e.callbackNode;if(ku()&&e.callbackNode!==n)return null;var r=ht(e,e===Al?$l:0);if(0===r)return null;if(0!==(30&r)||0!==(r&e.expiredLanes)||t)t=gu(e,r);else{t=r;var a=El;El|=2;var i=fu();for(Al===e&&$l===t||(Ul=null,Vl=Qe()+500,hu(e,t));;)try{bu();break}catch(l){pu(e,l)}Ns(),Cl.current=i,El=a,null!==_l?t=0:(Al=null,$l=0,t=Ml)}if(0!==t){if(2===t&&(0!==(a=ft(e))&&(r=a,t=su(e,a))),1===t)throw n=Fl,hu(e,0),ou(e,r),ru(e,Qe()),n;if(6===t)ou(e,r);else{if(a=e.current.alternate,0===(30&r)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var a=n[r],s=a.getSnapshot;a=a.value;try{if(!or(s(),a))return!1}catch(o){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(a)&&(2===(t=gu(e,r))&&(0!==(i=ft(e))&&(r=i,t=su(e,i))),1===t))throw n=Fl,hu(e,0),ou(e,r),ru(e,Qe()),n;switch(e.finishedWork=a,e.finishedLanes=r,t){case 0:case 1:throw Error(s(345));case 2:case 5:wu(e,Bl,Ul);break;case 3:if(ou(e,r),(130023424&r)===r&&10<(t=Wl+500-Qe())){if(0!==ht(e,0))break;if(((a=e.suspendedLanes)&r)!==r){eu(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=ra(wu.bind(null,e,Bl,Ul),t);break}wu(e,Bl,Ul);break;case 4:if(ou(e,r),(4194240&r)===r)break;for(t=e.eventTimes,a=-1;0<r;){var o=31-it(r);i=1<<o,(o=t[o])>a&&(a=o),r&=~i}if(r=a,10<(r=(120>(r=Qe()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Il(r/1960))-r)){e.timeoutHandle=ra(wu.bind(null,e,Bl,Ul),r);break}wu(e,Bl,Ul);break;default:throw Error(s(329))}}}return ru(e,Qe()),e.callbackNode===n?au.bind(null,e):null}function su(e,t){var n=zl;return e.current.memoizedState.isDehydrated&&(hu(e,t).flags|=256),2!==(e=gu(e,t))&&(t=Bl,Bl=n,null!==t&&iu(t)),e}function iu(e){null===Bl?Bl=e:Bl.push.apply(Bl,e)}function ou(e,t){for(t&=~Ll,t&=~Pl,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-it(t),r=1<<n;e[n]=-1,t&=~r}}function lu(e){if(0!==(6&El))throw Error(s(327));ku();var t=ht(e,0);if(0===(1&t))return ru(e,Qe()),null;var n=gu(e,t);if(0!==e.tag&&2===n){var r=ft(e);0!==r&&(t=r,n=su(e,r))}if(1===n)throw n=Fl,hu(e,0),ou(e,t),ru(e,Qe()),n;if(6===n)throw Error(s(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wu(e,Bl,Ul),ru(e,Qe()),null}function uu(e,t){var n=El;El|=1;try{return e(t)}finally{0===(El=n)&&(Vl=Qe()+500,za&&Va())}}function cu(e){null!==Kl&&0===Kl.tag&&0===(6&El)&&ku();var t=El;El|=1;var n=Tl.transition,r=vt;try{if(Tl.transition=null,vt=1,e)return e()}finally{vt=r,Tl.transition=n,0===(6&(El=t))&&Va()}}function du(){Rl=Dl.current,Ca(Dl)}function hu(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,aa(n)),null!==_l)for(n=_l.return;null!==n;){var r=n;switch(ts(r),r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&Da();break;case 3:Ys(),Ca(Aa),Ca(Ea),ni();break;case 5:Js(r);break;case 4:Ys();break;case 13:case 19:Ca(Zs);break;case 10:Ts(r.type._context);break;case 22:case 23:du()}n=n.return}if(Al=e,_l=e=Du(e.current,null),$l=Rl=t,Ml=0,Fl=null,Ll=Pl=Ol=0,Bl=zl=null,null!==$s){for(t=0;t<$s.length;t++)if(null!==(r=(n=$s[t]).interleaved)){n.interleaved=null;var a=r.next,s=n.pending;if(null!==s){var i=s.next;s.next=a,r.next=i}n.pending=r}$s=null}return e}function pu(e,t){for(;;){var n=_l;try{if(Ns(),ri.current=Qi,ui){for(var r=ii.memoizedState;null!==r;){var a=r.queue;null!==a&&(a.pending=null),r=r.next}ui=!1}if(si=0,li=oi=ii=null,ci=!1,di=0,Nl.current=null,null===n||null===n.return){Ml=1,Fl=t,_l=null;break}e:{var i=e,o=n.return,l=n,u=t;if(t=$l,l.flags|=32768,null!==u&&"object"===typeof u&&"function"===typeof u.then){var c=u,d=l,h=d.tag;if(0===(1&d.mode)&&(0===h||11===h||15===h)){var p=d.alternate;p?(d.updateQueue=p.updateQueue,d.memoizedState=p.memoizedState,d.lanes=p.lanes):(d.updateQueue=null,d.memoizedState=null)}var f=go(o);if(null!==f){f.flags&=-257,yo(f,o,l,0,t),1&f.mode&&mo(i,c,t),u=c;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(u),t.updateQueue=g}else m.add(u);break e}if(0===(1&t)){mo(i,c,t),mu();break e}u=Error(s(426))}else if(as&&1&l.mode){var y=go(o);if(null!==y){0===(65536&y.flags)&&(y.flags|=256),yo(y,o,l,0,t),fs(lo(u,l));break e}}i=u=lo(u,l),4!==Ml&&(Ml=2),null===zl?zl=[i]:zl.push(i),i=o;do{switch(i.tag){case 3:i.flags|=65536,t&=-t,i.lanes|=t,Ws(i,po(0,u,t));break e;case 1:l=u;var b=i.type,v=i.stateNode;if(0===(128&i.flags)&&("function"===typeof b.getDerivedStateFromError||null!==v&&"function"===typeof v.componentDidCatch&&(null===Hl||!Hl.has(v)))){i.flags|=65536,t&=-t,i.lanes|=t,Ws(i,fo(i,l,t));break e}}i=i.return}while(null!==i)}xu(n)}catch(x){t=x,_l===n&&null!==n&&(_l=n=n.return);continue}break}}function fu(){var e=Cl.current;return Cl.current=Qi,null===e?Qi:e}function mu(){0!==Ml&&3!==Ml&&2!==Ml||(Ml=4),null===Al||0===(268435455&Ol)&&0===(268435455&Pl)||ou(Al,$l)}function gu(e,t){var n=El;El|=2;var r=fu();for(Al===e&&$l===t||(Ul=null,hu(e,t));;)try{yu();break}catch(a){pu(e,a)}if(Ns(),El=n,Cl.current=r,null!==_l)throw Error(s(261));return Al=null,$l=0,Ml}function yu(){for(;null!==_l;)vu(_l)}function bu(){for(;null!==_l&&!Xe();)vu(_l)}function vu(e){var t=Sl(e.alternate,e,Rl);e.memoizedProps=e.pendingProps,null===t?xu(e):_l=t,Nl.current=null}function xu(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=qo(n,t,Rl)))return void(_l=n)}else{if(null!==(n=Ko(n,t)))return n.flags&=32767,void(_l=n);if(null===e)return Ml=6,void(_l=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(_l=t);_l=t=e}while(null!==t);0===Ml&&(Ml=5)}function wu(e,t,n){var r=vt,a=Tl.transition;try{Tl.transition=null,vt=1,function(e,t,n,r){do{ku()}while(null!==Kl);if(0!==(6&El))throw Error(s(327));n=e.finishedWork;var a=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(s(177));e.callbackNode=null,e.callbackPriority=0;var i=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var a=31-it(n),s=1<<a;t[a]=0,r[a]=-1,e[a]=-1,n&=~s}}(e,i),e===Al&&(_l=Al=null,$l=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||ql||(ql=!0,Au(tt,(function(){return ku(),null}))),i=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||i){i=Tl.transition,Tl.transition=null;var o=vt;vt=1;var l=El;El|=4,Nl.current=null,function(e,t){if(ea=jt,pr(e=hr())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var a=r.anchorOffset,i=r.focusNode;r=r.focusOffset;try{n.nodeType,i.nodeType}catch(w){n=null;break e}var o=0,l=-1,u=-1,c=0,d=0,h=e,p=null;t:for(;;){for(var f;h!==n||0!==a&&3!==h.nodeType||(l=o+a),h!==i||0!==r&&3!==h.nodeType||(u=o+r),3===h.nodeType&&(o+=h.nodeValue.length),null!==(f=h.firstChild);)p=h,h=f;for(;;){if(h===e)break t;if(p===n&&++c===a&&(l=o),p===i&&++d===r&&(u=o),null!==(f=h.nextSibling))break;p=(h=p).parentNode}h=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(ta={focusedElem:e,selectionRange:n},jt=!1,Jo=t;null!==Jo;)if(e=(t=Jo).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Jo=e;else for(;null!==Jo;){t=Jo;try{var m=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,y=m.memoizedState,b=t.stateNode,v=b.getSnapshotBeforeUpdate(t.elementType===t.type?g:to(t.type,g),y);b.__reactInternalSnapshotBeforeUpdate=v}break;case 3:var x=t.stateNode.containerInfo;1===x.nodeType?x.textContent="":9===x.nodeType&&x.documentElement&&x.removeChild(x.documentElement);break;default:throw Error(s(163))}}catch(w){Iu(t,t.return,w)}if(null!==(e=t.sibling)){e.return=t.return,Jo=e;break}Jo=t.return}m=tl,tl=!1}(e,n),gl(n,e),fr(ta),jt=!!ea,ta=ea=null,e.current=n,bl(n,e,a),Ye(),El=l,vt=o,Tl.transition=i}else e.current=n;if(ql&&(ql=!1,Kl=e,Xl=a),i=e.pendingLanes,0===i&&(Hl=null),function(e){if(st&&"function"===typeof st.onCommitFiberRoot)try{st.onCommitFiberRoot(at,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),ru(e,Qe()),null!==t)for(r=e.onRecoverableError,n=0;n<t.length;n++)a=t[n],r(a.value,{componentStack:a.stack,digest:a.digest});if(jl)throw jl=!1,e=Gl,Gl=null,e;0!==(1&Xl)&&0!==e.tag&&ku(),i=e.pendingLanes,0!==(1&i)?e===Ql?Yl++:(Yl=0,Ql=e):Yl=0,Va()}(e,t,n,r)}finally{Tl.transition=a,vt=r}return null}function ku(){if(null!==Kl){var e=xt(Xl),t=Tl.transition,n=vt;try{if(Tl.transition=null,vt=16>e?16:e,null===Kl)var r=!1;else{if(e=Kl,Kl=null,Xl=0,0!==(6&El))throw Error(s(331));var a=El;for(El|=4,Jo=e.current;null!==Jo;){var i=Jo,o=i.child;if(0!==(16&Jo.flags)){var l=i.deletions;if(null!==l){for(var u=0;u<l.length;u++){var c=l[u];for(Jo=c;null!==Jo;){var d=Jo;switch(d.tag){case 0:case 11:case 15:nl(8,d,i)}var h=d.child;if(null!==h)h.return=d,Jo=h;else for(;null!==Jo;){var p=(d=Jo).sibling,f=d.return;if(sl(d),d===c){Jo=null;break}if(null!==p){p.return=f,Jo=p;break}Jo=f}}}var m=i.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var y=g.sibling;g.sibling=null,g=y}while(null!==g)}}Jo=i}}if(0!==(2064&i.subtreeFlags)&&null!==o)o.return=i,Jo=o;else e:for(;null!==Jo;){if(0!==(2048&(i=Jo).flags))switch(i.tag){case 0:case 11:case 15:nl(9,i,i.return)}var b=i.sibling;if(null!==b){b.return=i.return,Jo=b;break e}Jo=i.return}}var v=e.current;for(Jo=v;null!==Jo;){var x=(o=Jo).child;if(0!==(2064&o.subtreeFlags)&&null!==x)x.return=o,Jo=x;else e:for(o=v;null!==Jo;){if(0!==(2048&(l=Jo).flags))try{switch(l.tag){case 0:case 11:case 15:rl(9,l)}}catch(k){Iu(l,l.return,k)}if(l===o){Jo=null;break e}var w=l.sibling;if(null!==w){w.return=l.return,Jo=w;break e}Jo=l.return}}if(El=a,Va(),st&&"function"===typeof st.onPostCommitFiberRoot)try{st.onPostCommitFiberRoot(at,e)}catch(k){}r=!0}return r}finally{vt=n,Tl.transition=t}}return!1}function Su(e,t,n){e=zs(e,t=po(0,t=lo(n,t),1),1),t=eu(),null!==e&&(yt(e,1,t),ru(e,t))}function Iu(e,t,n){if(3===e.tag)Su(e,e,n);else for(;null!==t;){if(3===t.tag){Su(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===Hl||!Hl.has(r))){t=zs(t,e=fo(t,e=lo(n,e),1),1),e=eu(),null!==t&&(yt(t,1,e),ru(t,e));break}}t=t.return}}function Cu(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),t=eu(),e.pingedLanes|=e.suspendedLanes&n,Al===e&&($l&n)===n&&(4===Ml||3===Ml&&(130023424&$l)===$l&&500>Qe()-Wl?hu(e,0):Ll|=n),ru(e,t)}function Nu(e,t){0===t&&(0===(1&e.mode)?t=1:(t=ct,0===(130023424&(ct<<=1))&&(ct=4194304)));var n=eu();null!==(e=Ms(e,t))&&(yt(e,t,n),ru(e,n))}function Tu(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Nu(e,n)}function Eu(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,a=e.memoizedState;null!==a&&(n=a.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(s(314))}null!==r&&r.delete(t),Nu(e,n)}function Au(e,t){return qe(e,t)}function _u(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function $u(e,t,n,r){return new _u(e,t,n,r)}function Ru(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Du(e,t){var n=e.alternate;return null===n?((n=$u(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Mu(e,t,n,r,a,i){var o=2;if(r=e,"function"===typeof e)Ru(e)&&(o=1);else if("string"===typeof e)o=5;else e:switch(e){case S:return Fu(n.children,a,i,t);case I:o=8,a|=8;break;case C:return(e=$u(12,n,t,2|a)).elementType=C,e.lanes=i,e;case A:return(e=$u(13,n,t,a)).elementType=A,e.lanes=i,e;case _:return(e=$u(19,n,t,a)).elementType=_,e.lanes=i,e;case D:return Ou(n,a,i,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case N:o=10;break e;case T:o=9;break e;case E:o=11;break e;case $:o=14;break e;case R:o=16,r=null;break e}throw Error(s(130,null==e?e:typeof e,""))}return(t=$u(o,n,t,a)).elementType=e,t.type=r,t.lanes=i,t}function Fu(e,t,n,r){return(e=$u(7,e,r,t)).lanes=n,e}function Ou(e,t,n,r){return(e=$u(22,e,r,t)).elementType=D,e.lanes=n,e.stateNode={isHidden:!1},e}function Pu(e,t,n){return(e=$u(6,e,null,t)).lanes=n,e}function Lu(e,t,n){return(t=$u(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function zu(e,t,n,r,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=r,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Bu(e,t,n,r,a,s,i,o,l){return e=new zu(e,t,n,o,l),1===t?(t=1,!0===s&&(t|=8)):t=0,s=$u(3,null,null,t),e.current=s,s.stateNode=e,s.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Os(s),e}function Wu(e){if(!e)return Ta;e:{if(Ve(e=e._reactInternals)!==e||1!==e.tag)throw Error(s(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ra(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(s(171))}if(1===e.tag){var n=e.type;if(Ra(n))return Fa(e,n,t)}return t}function Vu(e,t,n,r,a,s,i,o,l){return(e=Bu(n,r,!0,e,0,s,0,o,l)).context=Wu(null),n=e.current,(s=Ls(r=eu(),a=tu(n))).callback=void 0!==t&&null!==t?t:null,zs(n,s,a),e.current.lanes=a,yt(e,a,r),ru(e,r),e}function Uu(e,t,n,r){var a=t.current,s=eu(),i=tu(a);return n=Wu(n),null===t.context?t.context=n:t.pendingContext=n,(t=Ls(s,i)).payload={element:e},null!==(r=void 0===r?null:r)&&(t.callback=r),null!==(e=zs(a,t,i))&&(nu(e,a,i,s),Bs(e,a,i)),i}function ju(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Gu(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Hu(e,t){Gu(e,t),(e=e.alternate)&&Gu(e,t)}Sl=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Aa.current)vo=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return vo=!1,function(e,t,n){switch(t.tag){case 3:Ao(t),ps();break;case 5:Qs(t);break;case 1:Ra(t.type)&&Oa(t);break;case 4:Xs(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,a=t.memoizedProps.value;Na(ks,r._currentValue),r._currentValue=a;break;case 13:if(null!==(r=t.memoizedState))return null!==r.dehydrated?(Na(Zs,1&Zs.current),t.flags|=128,null):0!==(n&t.child.childLanes)?Po(e,t,n):(Na(Zs,1&Zs.current),null!==(e=jo(e,t,n))?e.sibling:null);Na(Zs,1&Zs.current);break;case 19:if(r=0!==(n&t.childLanes),0!==(128&e.flags)){if(r)return Vo(e,t,n);t.flags|=128}if(null!==(a=t.memoizedState)&&(a.rendering=null,a.tail=null,a.lastEffect=null),Na(Zs,Zs.current),r)break;return null;case 22:case 23:return t.lanes=0,Io(e,t,n)}return jo(e,t,n)}(e,t,n);vo=0!==(131072&e.flags)}else vo=!1,as&&0!==(1048576&t.flags)&&Za(t,Ha,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;Uo(e,t),e=t.pendingProps;var a=$a(t,Ea.current);As(t,n),a=mi(null,t,r,e,a,n);var i=gi();return t.flags|=1,"object"===typeof a&&null!==a&&"function"===typeof a.render&&void 0===a.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ra(r)?(i=!0,Oa(t)):i=!1,t.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,Os(t),a.updater=ro,t.stateNode=a,a._reactInternals=t,oo(t,r,e,n),t=Eo(null,t,r,!0,i,n)):(t.tag=0,as&&i&&es(t),xo(null,t,a,n),t=t.child),t;case 16:r=t.elementType;e:{switch(Uo(e,t),e=t.pendingProps,r=(a=r._init)(r._payload),t.type=r,a=t.tag=function(e){if("function"===typeof e)return Ru(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===E)return 11;if(e===$)return 14}return 2}(r),e=to(r,e),a){case 0:t=No(null,t,r,e,n);break e;case 1:t=To(null,t,r,e,n);break e;case 11:t=wo(null,t,r,e,n);break e;case 14:t=ko(null,t,r,to(r.type,e),n);break e}throw Error(s(306,r,""))}return t;case 0:return r=t.type,a=t.pendingProps,No(e,t,r,a=t.elementType===r?a:to(r,a),n);case 1:return r=t.type,a=t.pendingProps,To(e,t,r,a=t.elementType===r?a:to(r,a),n);case 3:e:{if(Ao(t),null===e)throw Error(s(387));r=t.pendingProps,a=(i=t.memoizedState).element,Ps(e,t),Vs(t,r,null,n);var o=t.memoizedState;if(r=o.element,i.isDehydrated){if(i={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=i,t.memoizedState=i,256&t.flags){t=_o(e,t,r,n,a=lo(Error(s(423)),t));break e}if(r!==a){t=_o(e,t,r,n,a=lo(Error(s(424)),t));break e}for(rs=ua(t.stateNode.containerInfo.firstChild),ns=t,as=!0,ss=null,n=ws(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ps(),r===a){t=jo(e,t,n);break e}xo(e,t,r,n)}t=t.child}return t;case 5:return Qs(t),null===e&&us(t),r=t.type,a=t.pendingProps,i=null!==e?e.memoizedProps:null,o=a.children,na(r,a)?o=null:null!==i&&na(r,i)&&(t.flags|=32),Co(e,t),xo(e,t,o,n),t.child;case 6:return null===e&&us(t),null;case 13:return Po(e,t,n);case 4:return Xs(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=xs(t,null,r,n):xo(e,t,r,n),t.child;case 11:return r=t.type,a=t.pendingProps,wo(e,t,r,a=t.elementType===r?a:to(r,a),n);case 7:return xo(e,t,t.pendingProps,n),t.child;case 8:case 12:return xo(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,a=t.pendingProps,i=t.memoizedProps,o=a.value,Na(ks,r._currentValue),r._currentValue=o,null!==i)if(or(i.value,o)){if(i.children===a.children&&!Aa.current){t=jo(e,t,n);break e}}else for(null!==(i=t.child)&&(i.return=t);null!==i;){var l=i.dependencies;if(null!==l){o=i.child;for(var u=l.firstContext;null!==u;){if(u.context===r){if(1===i.tag){(u=Ls(-1,n&-n)).tag=2;var c=i.updateQueue;if(null!==c){var d=(c=c.shared).pending;null===d?u.next=u:(u.next=d.next,d.next=u),c.pending=u}}i.lanes|=n,null!==(u=i.alternate)&&(u.lanes|=n),Es(i.return,n,t),l.lanes|=n;break}u=u.next}}else if(10===i.tag)o=i.type===t.type?null:i.child;else if(18===i.tag){if(null===(o=i.return))throw Error(s(341));o.lanes|=n,null!==(l=o.alternate)&&(l.lanes|=n),Es(o,n,t),o=i.sibling}else o=i.child;if(null!==o)o.return=i;else for(o=i;null!==o;){if(o===t){o=null;break}if(null!==(i=o.sibling)){i.return=o.return,o=i;break}o=o.return}i=o}xo(e,t,a.children,n),t=t.child}return t;case 9:return a=t.type,r=t.pendingProps.children,As(t,n),r=r(a=_s(a)),t.flags|=1,xo(e,t,r,n),t.child;case 14:return a=to(r=t.type,t.pendingProps),ko(e,t,r,a=to(r.type,a),n);case 15:return So(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:to(r,a),Uo(e,t),t.tag=1,Ra(r)?(e=!0,Oa(t)):e=!1,As(t,n),so(t,r,a),oo(t,r,a,n),Eo(null,t,r,!0,e,n);case 19:return Vo(e,t,n);case 22:return Io(e,t,n)}throw Error(s(156,t.tag))};var qu="function"===typeof reportError?reportError:function(e){console.error(e)};function Ku(e){this._internalRoot=e}function Xu(e){this._internalRoot=e}function Yu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Qu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Ju(){}function Zu(e,t,n,r,a){var s=n._reactRootContainer;if(s){var i=s;if("function"===typeof a){var o=a;a=function(){var e=ju(i);o.call(e)}}Uu(t,i,e,a)}else i=function(e,t,n,r,a){if(a){if("function"===typeof r){var s=r;r=function(){var e=ju(i);s.call(e)}}var i=Vu(t,r,e,0,null,!1,0,"",Ju);return e._reactRootContainer=i,e[fa]=i.current,Vr(8===e.nodeType?e.parentNode:e),cu(),i}for(;a=e.lastChild;)e.removeChild(a);if("function"===typeof r){var o=r;r=function(){var e=ju(l);o.call(e)}}var l=Bu(e,0,!1,null,0,!1,0,"",Ju);return e._reactRootContainer=l,e[fa]=l.current,Vr(8===e.nodeType?e.parentNode:e),cu((function(){Uu(t,l,n,r)})),l}(n,t,e,a,r);return ju(i)}Xu.prototype.render=Ku.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(s(409));Uu(e,t,null,null)},Xu.prototype.unmount=Ku.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;cu((function(){Uu(null,e,null,null)})),t[fa]=null}},Xu.prototype.unstable_scheduleHydration=function(e){if(e){var t=It();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Dt.length&&0!==t&&t<Dt[n].priority;n++);Dt.splice(n,0,e),0===n&&Pt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=dt(t.pendingLanes);0!==n&&(bt(t,1|n),ru(t,Qe()),0===(6&El)&&(Vl=Qe()+500,Va()))}break;case 13:cu((function(){var t=Ms(e,1);if(null!==t){var n=eu();nu(t,e,1,n)}})),Hu(e,1)}},kt=function(e){if(13===e.tag){var t=Ms(e,134217728);if(null!==t)nu(t,e,134217728,eu());Hu(e,134217728)}},St=function(e){if(13===e.tag){var t=tu(e),n=Ms(e,t);if(null!==n)nu(n,e,t,eu());Hu(e,t)}},It=function(){return vt},Ct=function(e,t){var n=vt;try{return vt=e,t()}finally{vt=n}},ke=function(e,t,n){switch(t){case"input":if(J(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var a=wa(r);if(!a)throw Error(s(90));q(r),J(r,a)}}}break;case"textarea":se(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ee=uu,Ae=cu;var ec={usingClientEntryPoint:!1,Events:[va,xa,wa,Ne,Te,uu]},tc={findFiberByHostInstance:ba,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},nc={bundleType:tc.bundleType,version:tc.version,rendererPackageName:tc.rendererPackageName,rendererConfig:tc.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:x.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Ge(e))?null:e.stateNode},findFiberByHostInstance:tc.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var rc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rc.isDisabled&&rc.supportsFiber)try{at=rc.inject(nc),st=rc}catch(ce){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ec,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Yu(t))throw Error(s(200));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Yu(e))throw Error(s(299));var n=!1,r="",a=qu;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onRecoverableError&&(a=t.onRecoverableError)),t=Bu(e,1,!1,null,0,n,0,r,a),e[fa]=t.current,Vr(8===e.nodeType?e.parentNode:e),new Ku(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(s(188));throw e=Object.keys(e).join(","),Error(s(268,e))}return e=null===(e=Ge(t))?null:e.stateNode},t.flushSync=function(e){return cu(e)},t.hydrate=function(e,t,n){if(!Qu(t))throw Error(s(200));return Zu(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Yu(e))throw Error(s(405));var r=null!=n&&n.hydratedSources||null,a=!1,i="",o=qu;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(a=!0),void 0!==n.identifierPrefix&&(i=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),t=Vu(t,null,e,1,null!=n?n:null,a,0,i,o),e[fa]=t.current,Vr(e),r)for(e=0;e<r.length;e++)a=(a=(n=r[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,a]:t.mutableSourceEagerHydrationData.push(n,a);return new Xu(t)},t.render=function(e,t,n){if(!Qu(t))throw Error(s(200));return Zu(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Qu(e))throw Error(s(40));return!!e._reactRootContainer&&(cu((function(){Zu(null,null,e,!1,(function(){e._reactRootContainer=null,e[fa]=null}))})),!0)},t.unstable_batchedUpdates=uu,t.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Qu(n))throw Error(s(200));if(null==e||void 0===e._reactInternals)throw Error(s(38));return Zu(e,t,n,!1,r)},t.version="18.3.1-next-f1338f8080-20240426"},7950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(2730)},5082:(e,t)=>{"use strict";var n,r=Symbol.for("react.element"),a=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),i=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),l=Symbol.for("react.provider"),u=Symbol.for("react.context"),c=Symbol.for("react.server_context"),d=Symbol.for("react.forward_ref"),h=Symbol.for("react.suspense"),p=Symbol.for("react.suspense_list"),f=Symbol.for("react.memo"),m=Symbol.for("react.lazy"),g=Symbol.for("react.offscreen");function y(e){if("object"===typeof e&&null!==e){var t=e.$$typeof;switch(t){case r:switch(e=e.type){case s:case o:case i:case h:case p:return e;default:switch(e=e&&e.$$typeof){case c:case u:case d:case m:case f:case l:return e;default:return t}}case a:return t}}}n=Symbol.for("react.module.reference")},2086:(e,t,n)=>{"use strict";n(5082)},7029:function(e,t,n){var r;r=function(e){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(r,a,function(t){return e[t]}.bind(null,a));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(e,t,n){"use strict";n.r(t);var r=n("react"),a=function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function r(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),s=function(){return s=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var a in t=arguments[n])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e},s.apply(this,arguments)},i=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};function o(){return!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)}"undefined"!==typeof window&&(void 0===navigator.mediaDevices&&(navigator.mediaDevices={}),void 0===navigator.mediaDevices.getUserMedia&&(navigator.mediaDevices.getUserMedia=function(e){var t=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return t?new Promise((function(n,r){t.call(navigator,e,n,r)})):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}));var l=function(e){function t(t){var n=e.call(this,t)||this;return n.canvas=null,n.ctx=null,n.requestUserMediaId=0,n.unmounted=!1,n.state={hasUserMedia:!1},n}return a(t,e),t.prototype.componentDidMount=function(){var e=this.state,t=this.props;this.unmounted=!1,o()?(e.hasUserMedia||this.requestUserMedia(),t.children&&"function"!=typeof t.children&&console.warn("children must be a function")):t.onUserMediaError("getUserMedia not supported")},t.prototype.componentDidUpdate=function(e){var t=this.props;if(o()){var n=JSON.stringify(e.audioConstraints)!==JSON.stringify(t.audioConstraints),r=JSON.stringify(e.videoConstraints)!==JSON.stringify(t.videoConstraints),a=e.minScreenshotWidth!==t.minScreenshotWidth,s=e.minScreenshotHeight!==t.minScreenshotHeight;(r||a||s)&&(this.canvas=null,this.ctx=null),(n||r)&&(this.stopAndCleanup(),this.requestUserMedia())}else t.onUserMediaError("getUserMedia not supported")},t.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},t.stopMediaStream=function(e){e&&(e.getVideoTracks&&e.getAudioTracks?(e.getVideoTracks().map((function(t){e.removeTrack(t),t.stop()})),e.getAudioTracks().map((function(t){e.removeTrack(t),t.stop()}))):e.stop())},t.prototype.stopAndCleanup=function(){var e=this.state;e.hasUserMedia&&(t.stopMediaStream(this.stream),e.src&&window.URL.revokeObjectURL(e.src))},t.prototype.getScreenshot=function(e){var t=this.state,n=this.props;if(!t.hasUserMedia)return null;var r=this.getCanvas(e);return r&&r.toDataURL(n.screenshotFormat,n.screenshotQuality)},t.prototype.getCanvas=function(e){var t=this.state,n=this.props;if(!this.video)return null;if(!t.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var r=this.video.videoWidth,a=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var s=r/a;a=(r=n.minScreenshotWidth||this.video.clientWidth)/s,n.minScreenshotHeight&&a<n.minScreenshotHeight&&(r=(a=n.minScreenshotHeight)*s)}this.canvas=document.createElement("canvas"),this.canvas.width=(null===e||void 0===e?void 0:e.width)||r,this.canvas.height=(null===e||void 0===e?void 0:e.height)||a,this.ctx=this.canvas.getContext("2d")}var i=this.ctx,o=this.canvas;return i&&o&&(o.width=(null===e||void 0===e?void 0:e.width)||o.width,o.height=(null===e||void 0===e?void 0:e.height)||o.height,n.mirrored&&(i.translate(o.width,0),i.scale(-1,1)),i.imageSmoothingEnabled=n.imageSmoothing,i.drawImage(this.video,0,0,(null===e||void 0===e?void 0:e.width)||o.width,(null===e||void 0===e?void 0:e.height)||o.height),n.mirrored&&(i.scale(-1,1),i.translate(-o.width,0))),o},t.prototype.requestUserMedia=function(){var e=this,n=this.props,r=function(r,a){var s={video:"undefined"===typeof a||a};n.audio&&(s.audio="undefined"===typeof r||r),e.requestUserMediaId++;var i=e.requestUserMediaId;navigator.mediaDevices.getUserMedia(s).then((function(n){e.unmounted||i!==e.requestUserMediaId?t.stopMediaStream(n):e.handleUserMedia(null,n)})).catch((function(t){e.handleUserMedia(t)}))};if("mediaDevices"in navigator)r(n.audioConstraints,n.videoConstraints);else{var a=function(e){return{optional:[{sourceId:e}]}},s=function(e){var t=e.deviceId;return"string"===typeof t?t:Array.isArray(t)&&t.length>0?t[0]:"object"===typeof t&&t.ideal?t.ideal:null};MediaStreamTrack.getSources((function(e){var t=null,i=null;e.forEach((function(e){"audio"===e.kind?t=e.id:"video"===e.kind&&(i=e.id)}));var o=s(n.audioConstraints);o&&(t=o);var l=s(n.videoConstraints);l&&(i=l),r(a(t),a(i))}))}},t.prototype.handleUserMedia=function(e,t){var n=this.props;if(e||!t)return this.setState({hasUserMedia:!1}),void n.onUserMediaError(e);this.stream=t;try{this.video&&(this.video.srcObject=t),this.setState({hasUserMedia:!0})}catch(r){this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(t)})}n.onUserMedia(t)},t.prototype.render=function(){var e=this,t=this.state,n=this.props,a=n.audio,o=(n.forceScreenshotSourceSize,n.disablePictureInPicture),l=(n.onUserMedia,n.onUserMediaError,n.screenshotFormat,n.screenshotQuality,n.minScreenshotWidth,n.minScreenshotHeight,n.audioConstraints,n.videoConstraints,n.imageSmoothing,n.mirrored),u=n.style,c=void 0===u?{}:u,d=n.children,h=i(n,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),p=l?s(s({},c),{transform:(c.transform||"")+" scaleX(-1)"}):c,f={getScreenshot:this.getScreenshot.bind(this)};return r.createElement(r.Fragment,null,r.createElement("video",s({autoPlay:!0,disablePictureInPicture:o,src:t.src,muted:!a,playsInline:!0,ref:function(t){e.video=t},style:p},h)),d&&d(f))},t.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},t}(r.Component);t.default=l},react:function(t,n){t.exports=e}}).default},e.exports=r(n(5043))},1153:(e,t,n)=>{"use strict";var r=n(5043),a=Symbol.for("react.element"),s=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,o=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function u(e,t,n){var r,s={},u=null,c=null;for(r in void 0!==n&&(u=""+n),void 0!==t.key&&(u=""+t.key),void 0!==t.ref&&(c=t.ref),t)i.call(t,r)&&!l.hasOwnProperty(r)&&(s[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps)void 0===s[r]&&(s[r]=t[r]);return{$$typeof:a,type:e,key:u,ref:c,props:s,_owner:o.current}}t.Fragment=s,t.jsx=u,t.jsxs=u},4202:(e,t)=>{"use strict";var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function v(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var x=v.prototype=new b;x.constructor=v,m(x,y.prototype),x.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},I={key:!0,ref:!0,__self:!0,__source:!0};function C(e,t,r){var a,s={},i=null,o=null;if(null!=t)for(a in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(i=""+t.key),t)k.call(t,a)&&!I.hasOwnProperty(a)&&(s[a]=t[a]);var l=arguments.length-2;if(1===l)s.children=r;else if(1<l){for(var u=Array(l),c=0;c<l;c++)u[c]=arguments[c+2];s.children=u}if(e&&e.defaultProps)for(a in l=e.defaultProps)void 0===s[a]&&(s[a]=l[a]);return{$$typeof:n,type:e,key:i,ref:o,props:s,_owner:S.current}}function N(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var T=/\/+/g;function E(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function A(e,t,a,s,i){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var l=!1;if(null===e)l=!0;else switch(o){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case n:case r:l=!0}}if(l)return i=i(l=e),e=""===s?"."+E(l,0):s,w(i)?(a="",null!=e&&(a=e.replace(T,"$&/")+"/"),A(i,t,a,"",(function(e){return e}))):null!=i&&(N(i)&&(i=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,a+(!i.key||l&&l.key===i.key?"":(""+i.key).replace(T,"$&/")+"/")+e)),t.push(i)),1;if(l=0,s=""===s?".":s+":",w(e))for(var u=0;u<e.length;u++){var c=s+E(o=e[u],u);l+=A(o,t,a,c,i)}else if(c=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"===typeof c)for(e=c.call(e),u=0;!(o=e.next()).done;)l+=A(o=o.value,t,a,c=s+E(o,u++),i);else if("object"===o)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return l}function _(e,t,n){if(null==e)return e;var r=[],a=0;return A(e,r,"","",(function(e){return t.call(n,e,a++)})),r}function $(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var R={current:null},D={transition:null},M={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:D,ReactCurrentOwner:S};function F(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:_,forEach:function(e,t,n){_(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return _(e,(function(){t++})),t},toArray:function(e){return _(e,(function(e){return e}))||[]},only:function(e){if(!N(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=a,t.Profiler=i,t.PureComponent=v,t.StrictMode=s,t.Suspense=c,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=M,t.act=F,t.cloneElement=function(e,t,r){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var a=m({},e.props),s=e.key,i=e.ref,o=e._owner;if(null!=t){if(void 0!==t.ref&&(i=t.ref,o=S.current),void 0!==t.key&&(s=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(u in t)k.call(t,u)&&!I.hasOwnProperty(u)&&(a[u]=void 0===t[u]&&void 0!==l?l[u]:t[u])}var u=arguments.length-2;if(1===u)a.children=r;else if(1<u){l=Array(u);for(var c=0;c<u;c++)l[c]=arguments[c+2];a.children=l}return{$$typeof:n,type:e.type,key:s,ref:i,props:a,_owner:o}},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=C,t.createFactory=function(e){var t=C.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=N,t.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:$}},t.memo=function(e,t){return{$$typeof:d,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=D.transition;D.transition={};try{e()}finally{D.transition=t}},t.unstable_act=F,t.useCallback=function(e,t){return R.current.useCallback(e,t)},t.useContext=function(e){return R.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return R.current.useDeferredValue(e)},t.useEffect=function(e,t){return R.current.useEffect(e,t)},t.useId=function(){return R.current.useId()},t.useImperativeHandle=function(e,t,n){return R.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return R.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return R.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return R.current.useMemo(e,t)},t.useReducer=function(e,t,n){return R.current.useReducer(e,t,n)},t.useRef=function(e){return R.current.useRef(e)},t.useState=function(e){return R.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return R.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return R.current.useTransition()},t.version="18.3.1"},5043:(e,t,n)=>{"use strict";e.exports=n(4202)},579:(e,t,n)=>{"use strict";e.exports=n(1153)},7234:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,a=e[r];if(!(0<s(a,t)))break e;e[r]=t,e[n]=a,n=r}}function r(e){return 0===e.length?null:e[0]}function a(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,a=e.length,i=a>>>1;r<i;){var o=2*(r+1)-1,l=e[o],u=o+1,c=e[u];if(0>s(l,n))u<a&&0>s(c,l)?(e[r]=c,e[u]=n,r=u):(e[r]=l,e[o]=n,r=o);else{if(!(u<a&&0>s(c,n)))break e;e[r]=c,e[u]=n,r=u}}}return t}function s(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],c=[],d=1,h=null,p=3,f=!1,m=!1,g=!1,y="function"===typeof setTimeout?setTimeout:null,b="function"===typeof clearTimeout?clearTimeout:null,v="undefined"!==typeof setImmediate?setImmediate:null;function x(e){for(var t=r(c);null!==t;){if(null===t.callback)a(c);else{if(!(t.startTime<=e))break;a(c),t.sortIndex=t.expirationTime,n(u,t)}t=r(c)}}function w(e){if(g=!1,x(e),!m)if(null!==r(u))m=!0,D(k);else{var t=r(c);null!==t&&M(w,t.startTime-e)}}function k(e,n){m=!1,g&&(g=!1,b(N),N=-1),f=!0;var s=p;try{for(x(n),h=r(u);null!==h&&(!(h.expirationTime>n)||e&&!A());){var i=h.callback;if("function"===typeof i){h.callback=null,p=h.priorityLevel;var o=i(h.expirationTime<=n);n=t.unstable_now(),"function"===typeof o?h.callback=o:h===r(u)&&a(u),x(n)}else a(u);h=r(u)}if(null!==h)var l=!0;else{var d=r(c);null!==d&&M(w,d.startTime-n),l=!1}return l}finally{h=null,p=s,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,I=!1,C=null,N=-1,T=5,E=-1;function A(){return!(t.unstable_now()-E<T)}function _(){if(null!==C){var e=t.unstable_now();E=e;var n=!0;try{n=C(!0,e)}finally{n?S():(I=!1,C=null)}}else I=!1}if("function"===typeof v)S=function(){v(_)};else if("undefined"!==typeof MessageChannel){var $=new MessageChannel,R=$.port2;$.port1.onmessage=_,S=function(){R.postMessage(null)}}else S=function(){y(_,0)};function D(e){C=e,I||(I=!0,S())}function M(e,n){N=y((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,D(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):T=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return r(u)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,a,s){var i=t.unstable_now();switch("object"===typeof s&&null!==s?s="number"===typeof(s=s.delay)&&0<s?i+s:i:s=i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:d++,callback:a,priorityLevel:e,startTime:s,expirationTime:o=s+o,sortIndex:-1},s>i?(e.sortIndex=s,n(c,e),null===r(u)&&e===r(c)&&(g?(b(N),N=-1):g=!0,M(w,s-i))):(e.sortIndex=o,n(u,e),m||f||(m=!0,D(k))),e},t.unstable_shouldYield=A,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},8853:(e,t,n)=>{"use strict";e.exports=n(7234)},4334:(e,t,n)=>{var r=n(7359),a=n(7066),s=n(9016),i=n(9538),o=n(6288),l=n(5262),u=n(2430);u.alea=r,u.xor128=a,u.xorwow=s,u.xorshift7=i,u.xor4096=o,u.tychei=l,e.exports=u},7359:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new s(e),r=t&&t.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.alea=o}(0,e=n.nmd(e),n.amdD)},5262:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.tychei=o}(0,e=n.nmd(e),n.amdD)},7066:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xor128=o}(0,e=n.nmd(e),n.amdD)},6288:function(e,t,n){var r;!function(e,a){function s(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,a=0==(n=o[127&s]^=r+i)?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.X&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},9538:function(e,t,n){var r;!function(e,a){function s(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.x&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},9016:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},2430:function(e,t,n){var r;!function(a,s,i){var o,l=256,u=i.pow(l,6),c=i.pow(2,52),d=2*c,h=l-1;function p(e,t,n){var r=[],h=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(s)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(l):(e=new Uint8Array(l),(a.crypto||a.msCrypto).getRandomValues(e)),b(e)}catch(r){var t=a.navigator,n=t&&t.plugins;return[+new Date,a,n,a.screen,b(s)]}}():e,3),r),p=new f(r),v=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),s),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(v,h,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);a<l;)i[a]=a++;for(a=0;a<l;a++)i[a]=i[s=h&s+e[a%n]+(t=i[a])],i[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,i=r.S;e--;)t=i[a=h&a+1],n=n*l+i[h&(i[a]=i[s=h&s+t])+(i[s]=t)];return r.i=a,r.j=s,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(g(e[n],t-1))}catch(s){}return r.length?r:"string"==a?e:e+"\0"}function y(e,t){for(var n,r=e+"",a=0;a<r.length;)t[h&a]=h&(n^=19*t[h&a])+r.charCodeAt(a++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),s),e.exports){e.exports=p;try{o=n(1234)}catch(v){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!==typeof self?self:this,[],Math)},3895:(e,t,n)=>{"use strict";var r=n(5043);var a="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t},s=r.useSyncExternalStore,i=r.useRef,o=r.useEffect,l=r.useMemo,u=r.useDebugValue;t.useSyncExternalStoreWithSelector=function(e,t,n,r,c){var d=i(null);if(null===d.current){var h={hasValue:!1,value:null};d.current=h}else h=d.current;d=l((function(){function e(e){if(!o){if(o=!0,s=e,e=r(e),void 0!==c&&h.hasValue){var t=h.value;if(c(t,e))return i=t}return i=e}if(t=i,a(s,e))return t;var n=r(e);return void 0!==c&&c(t,n)?t:(s=e,i=n)}var s,i,o=!1,l=void 0===n?null:n;return[function(){return e(t())},null===l?void 0:function(){return e(l())}]}),[t,n,r,c]);var p=s(e,d[0],d[1]);return o((function(){h.hasValue=!0,h.value=p}),[p]),u(p),p}},7237:(e,t,n)=>{"use strict";e.exports=n(3895)},5817:()=>{},8590:()=>{},4530:()=>{},8108:()=>{},551:()=>{},477:()=>{},1234:()=>{},4994:e=>{e.exports=function(e){return e&&e.__esModule?e:{default:e}},e.exports.__esModule=!0,e.exports.default=e.exports},8168:(e,t,n)=>{"use strict";function r(){return r=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},r.apply(null,arguments)}n.d(t,{A:()=>r})},8387:(e,t,n)=>{"use strict";function r(e){var t,n,a="";if("string"==typeof e||"number"==typeof e)a+=e;else if("object"==typeof e)if(Array.isArray(e)){var s=e.length;for(t=0;t<s;t++)e[t]&&(n=r(e[t]))&&(a&&(a+=" "),a+=n)}else for(n in e)e[n]&&(a&&(a+=" "),a+=n);return a}n.d(t,{A:()=>a});const a=function(){for(var e,t,n=0,a="",s=arguments.length;n<s;n++)(e=arguments[n])&&(t=r(e))&&(a&&(a+=" "),a+=t);return a}}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var s=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},(()=>{var e,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;n.t=function(r,a){if(1&a&&(r=this(r)),8&a)return r;if("object"===typeof r&&r){if(4&a&&r.__esModule)return r;if(16&a&&"function"===typeof r.then)return r}var s=Object.create(null);n.r(s);var i={};e=e||[null,t({}),t([]),t(t)];for(var o=2&a&&r;"object"==typeof o&&!~e.indexOf(o);o=t(o))Object.getOwnPropertyNames(o).forEach((e=>i[e]=()=>r[e]));return i.default=()=>r,n.d(s,i),s}})(),n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{"use strict";var e={};n.r(e),n.d(e,{CompositeArrayBuffer:()=>gCe,browserFiles:()=>dTe,browserHTTPRequest:()=>xTe,concatenateArrayBuffers:()=>OCe,copyModel:()=>wNe,decodeWeights:()=>TCe,decodeWeightsStream:()=>RCe,encodeWeights:()=>NCe,fromMemory:()=>ITe,fromMemorySync:()=>CTe,getLoadHandlers:()=>qCe,getModelArtifactsForJSON:()=>BCe,getModelArtifactsForJSONSync:()=>zCe,getModelArtifactsInfoForJSON:()=>WCe,getSaveHandlers:()=>HCe,getWeightSpecs:()=>VCe,http:()=>vTe,isHTTPScheme:()=>yTe,listModels:()=>vNe,loadWeights:()=>fTe,moveModel:()=>kNe,registerLoadRouter:()=>GCe,registerSaveRouter:()=>jCe,removeModel:()=>xNe,weightsLoaderFactory:()=>mTe,withSaveHandler:()=>NTe,withSaveHandlerSync:()=>TTe});var t={};n.r(t),n.d(t,{assertParamsValid:()=>MTe,computeFlatOffset:()=>qTe,computeOutShape:()=>OTe,getNormalizedAxes:()=>BTe,isSliceContinous:()=>HTe,maskToAxes:()=>FTe,parseSliceParams:()=>KTe,sliceInfo:()=>XTe,startForAxis:()=>jTe,startIndicesWithElidedDims:()=>WTe,stopForAxis:()=>GTe,stopIndicesWithElidedDims:()=>VTe,stridesForAxis:()=>UTe,stridesWithElidedDims:()=>PTe});var r={};n.r(r),n.d(r,{conv2d:()=>lRe,depthwiseConv2d:()=>dRe,matMul:()=>hRe});var a={};n.r(a),n.d(a,{collectGatherOpShapeInfo:()=>SMe,computeOutShape:()=>kMe,segOpComputeOptimalWindowSize:()=>wMe});var s={};n.r(s),n.d(s,{ERF_A1:()=>zDe,ERF_A2:()=>BDe,ERF_A3:()=>WDe,ERF_A4:()=>VDe,ERF_A5:()=>UDe,ERF_P:()=>LDe,PARALLELIZE_THRESHOLD:()=>TDe,RowPartitionType:()=>kDe,SELU_SCALE:()=>PDe,SELU_SCALEALPHA:()=>ODe,applyActivation:()=>iRe,assertAndGetBroadcastShape:()=>tTe,assertAxesAreInnerMostDims:()=>kAe,assertParamsConsistent:()=>xDe,assignToTypedArray:()=>XDe,axesAreInnerMostDims:()=>bAe,calculateShapes:()=>O$e,checkEinsumDimSizes:()=>aMe,checkPadOnDimRoundingMode:()=>SEe,combineLocations:()=>vAe,combineRaggedTensorToTensorShapes:()=>SDe,complexWithEvenIndex:()=>HDe,complexWithOddIndex:()=>qDe,computeConv2DInfo:()=>hEe,computeConv3DInfo:()=>pEe,computeDefaultPad:()=>fEe,computeDilation2DInfo:()=>uEe,computeOptimalWindowSize:()=>EDe,computeOutAndReduceShapes:()=>xAe,computeOutShape:()=>wDe,computePool2DInfo:()=>cEe,computePool3DInfo:()=>dEe,convertConv2DDataFormat:()=>kEe,decodeEinsumEquation:()=>nMe,eitherStridesOrDilationsAreOne:()=>xEe,expandShapeToKeepDim:()=>wAe,exponent:()=>QDe,exponents:()=>YDe,fromStringArrayToUint8:()=>CMe,fromUint8ToStringArray:()=>IMe,getAxesPermutation:()=>SAe,getBroadcastDims:()=>ZNe,getComplexWithIndex:()=>KDe,getEinsumComputePath:()=>sMe,getEinsumPermutation:()=>rMe,getFusedBiasGradient:()=>sRe,getFusedDyActivation:()=>aRe,getImageCenter:()=>ADe,getInnerMostAxes:()=>CAe,getPermuted:()=>$De,getRaggedRank:()=>CDe,getReductionAxes:()=>eTe,getReshaped:()=>_De,getReshapedPermuted:()=>RDe,getRowPartitionTypesHelper:()=>IDe,getSliceBeginCoords:()=>DDe,getSliceSize:()=>MDe,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>uMe,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>cMe,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>dMe,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>fMe,getSparseReshapeInputOutputMismatchErrorMessage:()=>gMe,getSparseReshapeInputOutputMultipleErrorMessage:()=>mMe,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>hMe,getSparseReshapeNegativeOutputDimErrorMessage:()=>pMe,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>xMe,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>yMe,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>bMe,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>vMe,getUndoAxesPermutation:()=>IAe,isIdentityPermutation:()=>iMe,log:()=>zSe,mergeRealAndImagArrays:()=>jDe,prepareAndValidate:()=>FDe,prepareSplitSize:()=>lMe,segment_util:()=>a,shouldFuse:()=>oRe,slice_util:()=>t,splitRealAndImagArrays:()=>GDe,stridesOrDilationsArePositive:()=>wEe,tupleValuesAreOne:()=>vEe,upcastType:()=>WIe,validateDefaultValueShape:()=>NDe,validateInput:()=>F$e,validateUpdateShape:()=>M$e,warn:()=>LSe});var i={};n.r(i),n.d(i,{json:()=>vVe});var o={};n.r(o),n.d(o,{json:()=>xVe});var l={};n.r(l),n.d(l,{json:()=>wVe});var u={};n.r(u),n.d(u,{json:()=>kVe});var c={};n.r(c),n.d(c,{json:()=>SVe});var d={};n.r(d),n.d(d,{json:()=>IVe});var h={};n.r(h),n.d(h,{json:()=>CVe});var p={};n.r(p),n.d(p,{json:()=>NVe});var f={};n.r(f),n.d(f,{json:()=>TVe});var m={};n.r(m),n.d(m,{json:()=>EVe});var g={};n.r(g),n.d(g,{json:()=>AVe});var y={};n.r(y),n.d(y,{json:()=>_Ve});var b={};n.r(b),n.d(b,{json:()=>$Ve});var v={};n.r(v),n.d(v,{json:()=>RVe});var x={};n.r(x),n.d(x,{json:()=>DVe});var w={};n.r(w),n.d(w,{json:()=>MVe});var k={};n.r(k),n.d(k,{json:()=>FVe});var S={};n.r(S),n.d(S,{json:()=>OVe});var I={};n.r(I),n.d(I,{json:()=>PVe});var C={};n.r(C),n.d(C,{OP_SCOPE_SUFFIX:()=>cCe,abs:()=>JNe,acos:()=>QTe,acosh:()=>JTe,add:()=>$Ne,addN:()=>ZTe,all:()=>eEe,any:()=>tEe,argMax:()=>nEe,argMin:()=>rEe,asin:()=>aEe,asinh:()=>sEe,atan:()=>iEe,atan2:()=>oEe,atanh:()=>lEe,avgPool:()=>CEe,avgPool3d:()=>NEe,basicLSTMCell:()=>REe,batchNorm:()=>MEe,batchNorm2d:()=>FEe,batchNorm3d:()=>OEe,batchNorm4d:()=>PEe,batchToSpaceND:()=>DEe,bincount:()=>LEe,bitwiseAnd:()=>zEe,booleanMaskAsync:()=>q$e,broadcastArgs:()=>BEe,broadcastTo:()=>WEe,buffer:()=>TNe,cast:()=>ENe,ceil:()=>VEe,clipByValue:()=>UEe,clone:()=>ANe,complex:()=>hCe,concat:()=>TEe,concat1d:()=>jEe,concat2d:()=>GEe,concat3d:()=>HEe,concat4d:()=>qEe,conv1d:()=>XEe,conv2d:()=>KEe,conv2dTranspose:()=>QEe,conv3d:()=>JEe,conv3dTranspose:()=>eAe,cos:()=>tAe,cosh:()=>nAe,cosineWindow:()=>tRe,cumprod:()=>rAe,cumsum:()=>aAe,denseBincount:()=>sAe,depthToSpace:()=>iAe,depthwiseConv2d:()=>oAe,diag:()=>lAe,dilation2d:()=>uAe,div:()=>DNe,divNoNan:()=>hAe,dot:()=>pAe,dropout:()=>Z$e,einsum:()=>fAe,elu:()=>mAe,enclosingPowerOfTwo:()=>eRe,ensureShape:()=>gAe,equal:()=>cAe,erf:()=>yAe,euclideanNorm:()=>$Ae,exp:()=>RAe,expandDims:()=>DAe,expm1:()=>MAe,eye:()=>OAe,fft:()=>b$e,fill:()=>qNe,floor:()=>PAe,floorDiv:()=>RNe,fused:()=>r,gather:()=>LAe,gatherND:()=>J$e,greater:()=>zAe,greaterEqual:()=>BAe,ifft:()=>v$e,imag:()=>WAe,image:()=>hDe,inTopKAsync:()=>nRe,irfft:()=>x$e,isFinite:()=>VAe,isInf:()=>UAe,isNaN:()=>jAe,leakyRelu:()=>GAe,less:()=>HAe,lessEqual:()=>qAe,linalg:()=>pDe,linspace:()=>KAe,localResponseNormalization:()=>XAe,log:()=>YAe,log1p:()=>QAe,logSigmoid:()=>e_e,logSoftmax:()=>t_e,logSumExp:()=>n_e,logicalAnd:()=>r_e,logicalNot:()=>a_e,logicalOr:()=>s_e,logicalXor:()=>i_e,losses:()=>fDe,lowerBound:()=>u_e,matMul:()=>EEe,max:()=>NAe,maxPool:()=>c_e,maxPool3d:()=>d_e,maxPoolWithArgmax:()=>h_e,maximum:()=>nTe,mean:()=>p_e,meshgrid:()=>g_e,min:()=>TAe,minimum:()=>y_e,mirrorPad:()=>b_e,mod:()=>v_e,moments:()=>x_e,movingAverage:()=>X$e,mul:()=>MNe,multiRNNCell:()=>w_e,multinomial:()=>k_e,neg:()=>JAe,norm:()=>_Ae,notEqual:()=>S_e,oneHot:()=>I_e,ones:()=>m_e,onesLike:()=>C_e,op:()=>dCe,outerProduct:()=>N_e,pad:()=>T_e,pad1d:()=>E_e,pad2d:()=>A_e,pad3d:()=>__e,pad4d:()=>$_e,pool:()=>D_e,pow:()=>XNe,prelu:()=>M_e,print:()=>_Ne,prod:()=>F_e,raggedGather:()=>O_e,raggedRange:()=>P_e,raggedTensorToTensor:()=>L_e,rand:()=>z_e,randomGamma:()=>j_e,randomNormal:()=>G_e,randomStandardNormal:()=>H_e,randomUniform:()=>q_e,randomUniformInt:()=>K_e,range:()=>X_e,real:()=>Y_e,reciprocal:()=>Q_e,relu:()=>J_e,relu6:()=>Z_e,reshape:()=>IEe,reverse:()=>e$e,reverse1d:()=>t$e,reverse2d:()=>n$e,reverse3d:()=>r$e,reverse4d:()=>a$e,rfft:()=>k$e,round:()=>s$e,rsqrt:()=>i$e,scalar:()=>zNe,scatterND:()=>Y$e,searchSorted:()=>l_e,selu:()=>o$e,separableConv2d:()=>l$e,setdiff1dAsync:()=>u$e,sigmoid:()=>AEe,sign:()=>c$e,signal:()=>dDe,sin:()=>d$e,sinh:()=>h$e,slice:()=>_Ee,slice1d:()=>p$e,slice2d:()=>f$e,slice3d:()=>m$e,slice4d:()=>g$e,softmax:()=>y$e,softplus:()=>ZAe,spaceToBatchND:()=>R_e,sparse:()=>mDe,sparseToDense:()=>Q$e,spectral:()=>cDe,split:()=>w$e,sqrt:()=>FNe,square:()=>ONe,squaredDifference:()=>S$e,squeeze:()=>I$e,stack:()=>C$e,step:()=>N$e,stridedSlice:()=>T$e,string:()=>gDe,sub:()=>YNe,sum:()=>EAe,tan:()=>E$e,tanh:()=>$Ee,tensor:()=>fCe,tensor1d:()=>A$e,tensor2d:()=>_$e,tensor3d:()=>ETe,tensor4d:()=>$$e,tensor5d:()=>R$e,tensor6d:()=>D$e,tensorScatterUpdate:()=>P$e,tile:()=>FAe,topk:()=>L$e,transpose:()=>K$e,truncatedNormal:()=>z$e,unique:()=>B$e,unsortedSegmentSum:()=>W$e,unstack:()=>V$e,upperBound:()=>U$e,variable:()=>j$e,where:()=>dAe,whereAsync:()=>H$e,zeros:()=>f_e,zerosLike:()=>PNe});var N={};n.r(N),n.d(N,{mx:()=>Lje,XI:()=>_Ge,Nk:()=>$Ge,f6:()=>DGe,ct:()=>Dje,YG:()=>PGe,hH:()=>UGe,z3:()=>THe,sG:()=>LHe,uM:()=>UHe,vS:()=>iqe,qB:()=>fqe,GG:()=>gqe,lg:()=>wqe,rq:()=>bqe,cu:()=>Mqe,WR:()=>$qe,GE:()=>Pqe,px:()=>zqe,jC:()=>eKe,He:()=>rKe,hE:()=>pKe,BF:()=>vHe,Dk:()=>SKe,cl:()=>$Ke,_B:()=>jKe,ub:()=>XKe,_f:()=>JKe,Ku:()=>aXe,qy:()=>iXe,Zy:()=>bXe,bu:()=>wXe,zv:()=>Ije,dH:()=>qje,HS:()=>NGe,yH:()=>WXe,l3:()=>UXe,z9:()=>GXe,x6:()=>YXe,_m:()=>rYe,eW:()=>lYe,GK:()=>dYe,SP:()=>fYe,yr:()=>gYe,dl:()=>XHe,Dw:()=>kYe,xT:()=>NYe,_X:()=>eGe,wz:()=>DYe});var T=n(5043),E=n.t(T,2),A=n(7950),_=n.t(A,2),$=n(7237),R=T,D=Symbol.for("react-redux-context"),M="undefined"!==typeof globalThis?globalThis:{};function F(){if(!R.createContext)return{};const e=M[D]??(M[D]=new Map);let t=e.get(R.createContext);return t||(t=R.createContext(null),e.set(R.createContext,t)),t}var O=F(),P=()=>{throw new Error("uSES not initialized!")};function L(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:O;return function(){return R.useContext(e)}}var z=L(),B=P,W=(e,t)=>e===t;function V(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:O;const t=e===O?z:L(e),n=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{equalityFn:r=W,devModeChecks:a={}}="function"===typeof n?{equalityFn:n}:n;const{store:s,subscription:i,getServerState:o,stabilityCheck:l,identityFunctionCheck:u}=t(),c=(R.useRef(!0),R.useCallback({[e.name]:t=>e(t)}[e.name],[e,l,a.stabilityCheck])),d=B(i.addNestedSub,s.getState,o||s.getState,c,r);return R.useDebugValue(d),d};return Object.assign(n,{withTypes:()=>n}),n}var U=V();Symbol.for("react.element"),Symbol.for("react.portal"),Symbol.for("react.fragment"),Symbol.for("react.strict_mode"),Symbol.for("react.profiler"),Symbol.for("react.provider"),Symbol.for("react.context"),Symbol.for("react.server_context"),Symbol.for("react.forward_ref"),Symbol.for("react.suspense"),Symbol.for("react.suspense_list"),Symbol.for("react.memo"),Symbol.for("react.lazy"),Symbol.for("react.offscreen"),Symbol.for("react.client.reference");function j(e){e()}var G={notify(){},get:()=>[]};function H(e,t){let n,r=G,a=0,s=!1;function i(){u.onStateChange&&u.onStateChange()}function o(){a++,n||(n=t?t.addNestedSub(i):e.subscribe(i),r=function(){let e=null,t=null;return{clear(){e=null,t=null},notify(){j((()=>{let t=e;for(;t;)t.callback(),t=t.next}))},get(){const t=[];let n=e;for(;n;)t.push(n),n=n.next;return t},subscribe(n){let r=!0;const a=t={callback:n,next:null,prev:t};return a.prev?a.prev.next=a:e=a,function(){r&&null!==e&&(r=!1,a.next?a.next.prev=a.prev:t=a.prev,a.prev?a.prev.next=a.next:e=a.next)}}}}())}function l(){a--,n&&0===a&&(n(),n=void 0,r.clear(),r=G)}const u={addNestedSub:function(e){o();const t=r.subscribe(e);let n=!1;return()=>{n||(n=!0,t(),l())}},notifyNestedSubs:function(){r.notify()},handleChangeWrapper:i,isSubscribed:function(){return s},trySubscribe:function(){s||(s=!0,o())},tryUnsubscribe:function(){s&&(s=!1,l())},getListeners:()=>r};return u}var q=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),K="undefined"!==typeof navigator&&"ReactNative"===navigator.product,X=q||K?R.useLayoutEffect:R.useEffect;Object.defineProperty,Object.getOwnPropertyNames,Object.getOwnPropertySymbols,Object.getOwnPropertyDescriptor,Object.getPrototypeOf,Object.prototype;var Y=function(e){let{store:t,context:n,children:r,serverState:a,stabilityCheck:s="once",identityFunctionCheck:i="once"}=e;const o=R.useMemo((()=>{const e=H(t);return{store:t,subscription:e,getServerState:a?()=>a:void 0,stabilityCheck:s,identityFunctionCheck:i}}),[t,a,s,i]),l=R.useMemo((()=>t.getState()),[t]);X((()=>{const{subscription:e}=o;return e.onStateChange=e.notifyNestedSubs,e.trySubscribe(),l!==t.getState()&&e.notifyNestedSubs(),()=>{e.tryUnsubscribe(),e.onStateChange=void 0}}),[o,l]);const u=n||O;return R.createElement(u.Provider,{value:o},r)};function Q(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:O;const t=e===O?z:L(e),n=()=>{const{store:e}=t();return e};return Object.assign(n,{withTypes:()=>n}),n}var J=Q();function Z(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:O;const t=e===O?J:Q(e),n=()=>t().dispatch;return Object.assign(n,{withTypes:()=>n}),n}var ee=Z();function te(e){return`Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `}(e=>{B=e})($.useSyncExternalStoreWithSelector),(e=>{e})(T.useSyncExternalStore);var ne=(()=>"function"===typeof Symbol&&Symbol.observable||"@@observable")(),re=()=>Math.random().toString(36).substring(7).split("").join("."),ae={INIT:`@@redux/INIT${re()}`,REPLACE:`@@redux/REPLACE${re()}`,PROBE_UNKNOWN_ACTION:()=>`@@redux/PROBE_UNKNOWN_ACTION${re()}`};function se(e){if("object"!==typeof e||null===e)return!1;let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t||null===Object.getPrototypeOf(e)}function ie(e,t,n){if("function"!==typeof e)throw new Error(te(2));if("function"===typeof t&&"function"===typeof n||"function"===typeof n&&"function"===typeof arguments[3])throw new Error(te(0));if("function"===typeof t&&"undefined"===typeof n&&(n=t,t=void 0),"undefined"!==typeof n){if("function"!==typeof n)throw new Error(te(1));return n(ie)(e,t)}let r=e,a=t,s=new Map,i=s,o=0,l=!1;function u(){i===s&&(i=new Map,s.forEach(((e,t)=>{i.set(t,e)})))}function c(){if(l)throw new Error(te(3));return a}function d(e){if("function"!==typeof e)throw new Error(te(4));if(l)throw new Error(te(5));let t=!0;u();const n=o++;return i.set(n,e),function(){if(t){if(l)throw new Error(te(6));t=!1,u(),i.delete(n),s=null}}}function h(e){if(!se(e))throw new Error(te(7));if("undefined"===typeof e.type)throw new Error(te(8));if("string"!==typeof e.type)throw new Error(te(17));if(l)throw new Error(te(9));try{l=!0,a=r(a,e)}finally{l=!1}return(s=i).forEach((e=>{e()})),e}h({type:ae.INIT});return{dispatch:h,subscribe:d,getState:c,replaceReducer:function(e){if("function"!==typeof e)throw new Error(te(10));r=e,h({type:ae.REPLACE})},[ne]:function(){const e=d;return{subscribe(t){if("object"!==typeof t||null===t)throw new Error(te(11));function n(){const e=t;e.next&&e.next(c())}n();return{unsubscribe:e(n)}},[ne](){return this}}}}}function oe(e){const t=Object.keys(e),n={};for(let s=0;s<t.length;s++){const r=t[s];0,"function"===typeof e[r]&&(n[r]=e[r])}const r=Object.keys(n);let a;try{!function(e){Object.keys(e).forEach((t=>{const n=e[t];if("undefined"===typeof n(void 0,{type:ae.INIT}))throw new Error(te(12));if("undefined"===typeof n(void 0,{type:ae.PROBE_UNKNOWN_ACTION()}))throw new Error(te(13))}))}(n)}catch(gD){a=gD}return function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;if(a)throw a;let s=!1;const i={};for(let a=0;a<r.length;a++){const o=r[a],l=n[o],u=e[o],c=l(u,t);if("undefined"===typeof c){t&&t.type;throw new Error(te(14))}i[o]=c,s=s||c!==u}return s=s||r.length!==Object.keys(e).length,s?i:e}}function le(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 0===t.length?e=>e:1===t.length?t[0]:t.reduce(((e,t)=>function(){return e(t(...arguments))}))}function ue(e){return t=>{let{dispatch:n,getState:r}=t;return t=>a=>"function"===typeof a?a(n,r,e):t(a)}}var ce=ue(),de=ue,he=Symbol.for("immer-nothing"),pe=Symbol.for("immer-draftable"),fe=Symbol.for("immer-state");function me(e){throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)}var ge=Object.getPrototypeOf;function ye(e){return!!e&&!!e[fe]}function be(e){return!!e&&(xe(e)||Array.isArray(e)||!!e[pe]||!!e.constructor?.[pe]||Ce(e)||Ne(e))}var ve=Object.prototype.constructor.toString();function xe(e){if(!e||"object"!==typeof e)return!1;const t=ge(e);if(null===t)return!0;const n=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return n===Object||"function"==typeof n&&Function.toString.call(n)===ve}function we(e,t){0===ke(e)?Reflect.ownKeys(e).forEach((n=>{t(n,e[n],e)})):e.forEach(((n,r)=>t(r,n,e)))}function ke(e){const t=e[fe];return t?t.type_:Array.isArray(e)?1:Ce(e)?2:Ne(e)?3:0}function Se(e,t){return 2===ke(e)?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function Ie(e,t,n){const r=ke(e);2===r?e.set(t,n):3===r?e.add(n):e[t]=n}function Ce(e){return e instanceof Map}function Ne(e){return e instanceof Set}function Te(e){return e.copy_||e.base_}function Ee(e,t){if(Ce(e))return new Map(e);if(Ne(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);const n=xe(e);if(!0===t||"class_only"===t&&!n){const t=Object.getOwnPropertyDescriptors(e);delete t[fe];let n=Reflect.ownKeys(t);for(let r=0;r<n.length;r++){const a=n[r],s=t[a];!1===s.writable&&(s.writable=!0,s.configurable=!0),(s.get||s.set)&&(t[a]={configurable:!0,writable:!0,enumerable:s.enumerable,value:e[a]})}return Object.create(ge(e),t)}{const t=ge(e);if(null!==t&&n)return{...e};const r=Object.create(t);return Object.assign(r,e)}}function Ae(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return $e(e)||ye(e)||!be(e)||(ke(e)>1&&(e.set=e.add=e.clear=e.delete=_e),Object.freeze(e),t&&Object.entries(e).forEach((e=>{let[t,n]=e;return Ae(n,!0)}))),e}function _e(){me(2)}function $e(e){return Object.isFrozen(e)}var Re,De={};function Me(e){const t=De[e];return t||me(0),t}function Fe(){return Re}function Oe(e,t){t&&(Me("Patches"),e.patches_=[],e.inversePatches_=[],e.patchListener_=t)}function Pe(e){Le(e),e.drafts_.forEach(Be),e.drafts_=null}function Le(e){e===Re&&(Re=e.parent_)}function ze(e){return Re={drafts_:[],parent_:Re,immer_:e,canAutoFreeze_:!0,unfinalizedDrafts_:0}}function Be(e){const t=e[fe];0===t.type_||1===t.type_?t.revoke_():t.revoked_=!0}function We(e,t){t.unfinalizedDrafts_=t.drafts_.length;const n=t.drafts_[0];return void 0!==e&&e!==n?(n[fe].modified_&&(Pe(t),me(4)),be(e)&&(e=Ve(t,e),t.parent_||je(t,e)),t.patches_&&Me("Patches").generateReplacementPatches_(n[fe].base_,e,t.patches_,t.inversePatches_)):e=Ve(t,n,[]),Pe(t),t.patches_&&t.patchListener_(t.patches_,t.inversePatches_),e!==he?e:void 0}function Ve(e,t,n){if($e(t))return t;const r=t[fe];if(!r)return we(t,((a,s)=>Ue(e,r,t,a,s,n))),t;if(r.scope_!==e)return t;if(!r.modified_)return je(e,r.base_,!0),r.base_;if(!r.finalized_){r.finalized_=!0,r.scope_.unfinalizedDrafts_--;const t=r.copy_;let a=t,s=!1;3===r.type_&&(a=new Set(t),t.clear(),s=!0),we(a,((a,i)=>Ue(e,r,t,a,i,n,s))),je(e,t,!1),n&&e.patches_&&Me("Patches").generatePatches_(r,n,e.patches_,e.inversePatches_)}return r.copy_}function Ue(e,t,n,r,a,s,i){if(ye(a)){const i=Ve(e,a,s&&t&&3!==t.type_&&!Se(t.assigned_,r)?s.concat(r):void 0);if(Ie(n,r,i),!ye(i))return;e.canAutoFreeze_=!1}else i&&n.add(a);if(be(a)&&!$e(a)){if(!e.immer_.autoFreeze_&&e.unfinalizedDrafts_<1)return;Ve(e,a),t&&t.scope_.parent_||"symbol"===typeof r||!Object.prototype.propertyIsEnumerable.call(n,r)||je(e,a)}}function je(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];!e.parent_&&e.immer_.autoFreeze_&&e.canAutoFreeze_&&Ae(t,n)}var Ge={get(e,t){if(t===fe)return e;const n=Te(e);if(!Se(n,t))return function(e,t,n){const r=Ke(t,n);return r?"value"in r?r.value:r.get?.call(e.draft_):void 0}(e,n,t);const r=n[t];return e.finalized_||!be(r)?r:r===qe(e.base_,t)?(Ye(e),e.copy_[t]=Qe(r,e)):r},has:(e,t)=>t in Te(e),ownKeys:e=>Reflect.ownKeys(Te(e)),set(e,t,n){const r=Ke(Te(e),t);if(r?.set)return r.set.call(e.draft_,n),!0;if(!e.modified_){const r=qe(Te(e),t),a=r?.[fe];if(a&&a.base_===n)return e.copy_[t]=n,e.assigned_[t]=!1,!0;if(function(e,t){return e===t?0!==e||1/e===1/t:e!==e&&t!==t}(n,r)&&(void 0!==n||Se(e.base_,t)))return!0;Ye(e),Xe(e)}return e.copy_[t]===n&&(void 0!==n||t in e.copy_)||Number.isNaN(n)&&Number.isNaN(e.copy_[t])||(e.copy_[t]=n,e.assigned_[t]=!0),!0},deleteProperty:(e,t)=>(void 0!==qe(e.base_,t)||t in e.base_?(e.assigned_[t]=!1,Ye(e),Xe(e)):delete e.assigned_[t],e.copy_&&delete e.copy_[t],!0),getOwnPropertyDescriptor(e,t){const n=Te(e),r=Reflect.getOwnPropertyDescriptor(n,t);return r?{writable:!0,configurable:1!==e.type_||"length"!==t,enumerable:r.enumerable,value:n[t]}:r},defineProperty(){me(11)},getPrototypeOf:e=>ge(e.base_),setPrototypeOf(){me(12)}},He={};function qe(e,t){const n=e[fe];return(n?Te(n):e)[t]}function Ke(e,t){if(!(t in e))return;let n=ge(e);for(;n;){const e=Object.getOwnPropertyDescriptor(n,t);if(e)return e;n=ge(n)}}function Xe(e){e.modified_||(e.modified_=!0,e.parent_&&Xe(e.parent_))}function Ye(e){e.copy_||(e.copy_=Ee(e.base_,e.scope_.immer_.useStrictShallowCopy_))}we(Ge,((e,t)=>{He[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),He.deleteProperty=function(e,t){return He.set.call(this,e,t,void 0)},He.set=function(e,t,n){return Ge.set.call(this,e[0],t,n,e[0])};function Qe(e,t){const n=Ce(e)?Me("MapSet").proxyMap_(e,t):Ne(e)?Me("MapSet").proxySet_(e,t):function(e,t){const n=Array.isArray(e),r={type_:n?1:0,scope_:t?t.scope_:Fe(),modified_:!1,finalized_:!1,assigned_:{},parent_:t,base_:e,draft_:null,copy_:null,revoke_:null,isManual_:!1};let a=r,s=Ge;n&&(a=[r],s=He);const{revoke:i,proxy:o}=Proxy.revocable(a,s);return r.draft_=o,r.revoke_=i,o}(e,t);return(t?t.scope_:Fe()).drafts_.push(n),n}function Je(e){if(!be(e)||$e(e))return e;const t=e[fe];let n;if(t){if(!t.modified_)return t.base_;t.finalized_=!0,n=Ee(e,t.scope_.immer_.useStrictShallowCopy_)}else n=Ee(e,!0);return we(n,((e,t)=>{Ie(n,e,Je(t))})),t&&(t.finalized_=!1),n}var Ze=new class{constructor(e){var t=this;this.autoFreeze_=!0,this.useStrictShallowCopy_=!1,this.produce=(e,t,n)=>{if("function"===typeof e&&"function"!==typeof t){const n=t;t=e;const r=this;return function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;for(var a=arguments.length,s=new Array(a>1?a-1:0),i=1;i<a;i++)s[i-1]=arguments[i];return r.produce(e,(e=>t.call(this,e,...s)))}}let r;if("function"!==typeof t&&me(6),void 0!==n&&"function"!==typeof n&&me(7),be(e)){const a=ze(this),s=Qe(e,void 0);let i=!0;try{r=t(s),i=!1}finally{i?Pe(a):Le(a)}return Oe(a,n),We(r,a)}if(!e||"object"!==typeof e){if(r=t(e),void 0===r&&(r=e),r===he&&(r=void 0),this.autoFreeze_&&Ae(r,!0),n){const t=[],a=[];Me("Patches").generateReplacementPatches_(e,r,t,a),n(t,a)}return r}me(1)},this.produceWithPatches=(e,n)=>{if("function"===typeof e)return function(n){for(var r=arguments.length,a=new Array(r>1?r-1:0),s=1;s<r;s++)a[s-1]=arguments[s];return t.produceWithPatches(n,(t=>e(t,...a)))};let r,a;const s=this.produce(e,n,((e,t)=>{r=e,a=t}));return[s,r,a]},"boolean"===typeof e?.autoFreeze&&this.setAutoFreeze(e.autoFreeze),"boolean"===typeof e?.useStrictShallowCopy&&this.setUseStrictShallowCopy(e.useStrictShallowCopy)}createDraft(e){be(e)||me(8),ye(e)&&(e=function(e){ye(e)||me(10);return Je(e)}(e));const t=ze(this),n=Qe(e,void 0);return n[fe].isManual_=!0,Le(t),n}finishDraft(e,t){const n=e&&e[fe];n&&n.isManual_||me(9);const{scope_:r}=n;return Oe(r,t),We(void 0,r)}setAutoFreeze(e){this.autoFreeze_=e}setUseStrictShallowCopy(e){this.useStrictShallowCopy_=e}applyPatches(e,t){let n;for(n=t.length-1;n>=0;n--){const r=t[n];if(0===r.path.length&&"replace"===r.op){e=r.value;break}}n>-1&&(t=t.slice(n+1));const r=Me("Patches").applyPatches_;return ye(e)?r(e,t):this.produce(e,(e=>r(e,t)))}},et=Ze.produce;Ze.produceWithPatches.bind(Ze),Ze.setAutoFreeze.bind(Ze),Ze.setUseStrictShallowCopy.bind(Ze),Ze.applyPatches.bind(Ze),Ze.createDraft.bind(Ze),Ze.finishDraft.bind(Ze);var tt="undefined"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__:function(){if(0!==arguments.length)return"object"===typeof arguments[0]?le:le.apply(null,arguments)};"undefined"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__&&window.__REDUX_DEVTOOLS_EXTENSION__;function nt(e,t){function n(){if(t){let n=t(...arguments);if(!n)throw new Error(bt(0));return{type:e,payload:n.payload,..."meta"in n&&{meta:n.meta},..."error"in n&&{error:n.error}}}return{type:e,payload:arguments.length<=0?void 0:arguments[0]}}return n.toString=()=>`${e}`,n.type=e,n.match=t=>function(e){return se(e)&&"type"in e&&"string"===typeof e.type}(t)&&t.type===e,n}var rt=class e extends Array{constructor(){super(...arguments),Object.setPrototypeOf(this,e.prototype)}static get[Symbol.species](){return e}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return super.concat.apply(this,t)}prepend(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return 1===n.length&&Array.isArray(n[0])?new e(...n[0].concat(this)):new e(...n.concat(this))}};function at(e){return be(e)?et(e,(()=>{})):e}function st(e,t,n){if(e.has(t)){let r=e.get(t);return n.update&&(r=n.update(r,t,e),e.set(t,r)),r}if(!n.insert)throw new Error(bt(10));const r=n.insert(t,e);return e.set(t,r),r}var it="RTK_autoBatch",ot=e=>t=>{setTimeout(t,e)},lt="undefined"!==typeof window&&window.requestAnimationFrame?window.requestAnimationFrame:ot(10),ut=e=>function(t){const{autoBatch:n=!0}=t??{};let r=new rt(e);return n&&r.push(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{type:"raf"};return t=>function(){const n=t(...arguments);let r=!0,a=!1,s=!1;const i=new Set,o="tick"===e.type?queueMicrotask:"raf"===e.type?lt:"callback"===e.type?e.queueNotification:ot(e.timeout),l=()=>{s=!1,a&&(a=!1,i.forEach((e=>e())))};return Object.assign({},n,{subscribe(e){const t=n.subscribe((()=>r&&e()));return i.add(e),()=>{t(),i.delete(e)}},dispatch(e){try{return r=!e?.meta?.[it],a=!r,a&&(s||(s=!0,o(l))),n.dispatch(e)}finally{r=!0}}})}}("object"===typeof n?n:void 0)),r};function ct(e){const t={},n=[];let r;const a={addCase(e,n){const r="string"===typeof e?e:e.type;if(!r)throw new Error(bt(28));if(r in t)throw new Error(bt(29));return t[r]=n,a},addMatcher:(e,t)=>(n.push({matcher:e,reducer:t}),a),addDefaultCase:e=>(r=e,a)};return e(a),[t,n,r]}var dt=Symbol.for("rtk-slice-createasyncthunk");function ht(e,t){return`${e}/${t}`}function pt(){let{creators:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=e?.asyncThunk?.[dt];return function(e){const{name:n,reducerPath:r=n}=e;if(!n)throw new Error(bt(11));const a=("function"===typeof e.reducers?e.reducers(function(){function e(e,t){return{_reducerDefinitionType:"asyncThunk",payloadCreator:e,...t}}return e.withTypes=()=>e,{reducer:e=>Object.assign({[e.name](){return e(...arguments)}}[e.name],{_reducerDefinitionType:"reducer"}),preparedReducer:(e,t)=>({_reducerDefinitionType:"reducerWithPrepare",prepare:e,reducer:t}),asyncThunk:e}}()):e.reducers)||{},s=Object.keys(a),i={sliceCaseReducersByName:{},sliceCaseReducersByType:{},actionCreators:{},sliceMatchers:[]},o={addCase(e,t){const n="string"===typeof e?e:e.type;if(!n)throw new Error(bt(12));if(n in i.sliceCaseReducersByType)throw new Error(bt(13));return i.sliceCaseReducersByType[n]=t,o},addMatcher:(e,t)=>(i.sliceMatchers.push({matcher:e,reducer:t}),o),exposeAction:(e,t)=>(i.actionCreators[e]=t,o),exposeCaseReducer:(e,t)=>(i.sliceCaseReducersByName[e]=t,o)};function l(){const[t={},n=[],r]="function"===typeof e.extraReducers?ct(e.extraReducers):[e.extraReducers],a={...t,...i.sliceCaseReducersByType};return function(e,t){let n,[r,a,s]=ct(t);if(function(e){return"function"===typeof e}(e))n=()=>at(e());else{const t=at(e);n=()=>t}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n(),t=arguments.length>1?arguments[1]:void 0,i=[r[t.type],...a.filter((e=>{let{matcher:n}=e;return n(t)})).map((e=>{let{reducer:t}=e;return t}))];return 0===i.filter((e=>!!e)).length&&(i=[s]),i.reduce(((e,n)=>{if(n){if(ye(e)){const r=n(e,t);return void 0===r?e:r}if(be(e))return et(e,(e=>n(e,t)));{const r=n(e,t);if(void 0===r){if(null===e)return e;throw new Error(bt(9))}return r}}return e}),e)}return i.getInitialState=n,i}(e.initialState,(e=>{for(let t in a)e.addCase(t,a[t]);for(let t of i.sliceMatchers)e.addMatcher(t.matcher,t.reducer);for(let t of n)e.addMatcher(t.matcher,t.reducer);r&&e.addDefaultCase(r)}))}s.forEach((r=>{const s=a[r],i={reducerName:r,type:ht(n,r),createNotation:"function"===typeof e.reducers};!function(e){return"asyncThunk"===e._reducerDefinitionType}(s)?function(e,t,n){let r,a,{type:s,reducerName:i,createNotation:o}=e;if("reducer"in t){if(o&&!function(e){return"reducerWithPrepare"===e._reducerDefinitionType}(t))throw new Error(bt(17));r=t.reducer,a=t.prepare}else r=t;n.addCase(s,r).exposeCaseReducer(i,r).exposeAction(i,a?nt(s,a):nt(s))}(i,s,o):function(e,t,n,r){let{type:a,reducerName:s}=e;if(!r)throw new Error(bt(18));const{payloadCreator:i,fulfilled:o,pending:l,rejected:u,settled:c,options:d}=t,h=r(a,i,d);n.exposeAction(s,h),o&&n.addCase(h.fulfilled,o);l&&n.addCase(h.pending,l);u&&n.addCase(h.rejected,u);c&&n.addMatcher(h.settled,c);n.exposeCaseReducer(s,{fulfilled:o||gt,pending:l||gt,rejected:u||gt,settled:c||gt})}(i,s,o,t)}));const u=e=>e,c=new Map;let d;function h(e,t){return d||(d=l()),d(e,t)}function p(){return d||(d=l()),d.getInitialState()}function f(t){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];function r(e){let r=e[t];return"undefined"===typeof r&&n&&(r=p()),r}function a(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:u;const r=st(c,n,{insert:()=>new WeakMap});return st(r,t,{insert:()=>{const r={};for(const[a,s]of Object.entries(e.selectors??{}))r[a]=ft(s,t,p,n);return r}})}return{reducerPath:t,getSelectors:a,get selectors(){return a(r)},selectSlice:r}}const m={name:n,reducer:h,actions:i.actionCreators,caseReducers:i.sliceCaseReducersByName,getInitialState:p,...f(r),injectInto(e){let{reducerPath:t,...n}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const a=t??r;return e.inject({reducerPath:a,reducer:h},n),{...m,...f(a,!0)}}};return m}}function ft(e,t,n,r){function a(a){let s=t(a);"undefined"===typeof s&&r&&(s=n());for(var i=arguments.length,o=new Array(i>1?i-1:0),l=1;l<i;l++)o[l-1]=arguments[l];return e(s,...o)}return a.unwrapped=e,a}var mt=pt();function gt(){}var{assign:yt}=Object;Symbol.for("rtk-state-proxy-original");function bt(e){return`Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `}const vt=mt({name:"user",initialState:{name:"",email:"",dateOfBirth:"",userId:"",generatedId:""},reducers:{setUser:(e,t)=>{const{name:n,email:r,dateOfBirth:a,userId:s}=t.payload;e.name=n,e.email=r,e.dateOfBirth=a,e.userId=s},setGeneratedId:(e,t)=>{e.generatedId=t.payload},clearUser:e=>{e.name="",e.email="",e.dateOfBirth="",e.userId="",e.generatedId=""}}}),{setUser:xt,setGeneratedId:wt,clearUser:kt}=vt.actions,St=function(e){const t=function(e){const{thunk:t=!0,immutableCheck:n=!0,serializableCheck:r=!0,actionCreatorCheck:a=!0}=e??{};let s=new rt;return t&&(function(e){return"boolean"===typeof e}(t)?s.push(ce):s.push(de(t.extraArgument))),s},{reducer:n,middleware:r,devTools:a=!0,preloadedState:s,enhancers:i}=e||{};let o,l;if("function"===typeof n)o=n;else{if(!se(n))throw new Error(bt(1));o=oe(n)}l="function"===typeof r?r(t):t();let u=le;a&&(u=tt({trace:!1,..."object"===typeof a&&a}));const c=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return e=>(n,r)=>{const a=e(n,r);let s=()=>{throw new Error(te(15))};const i={getState:a.getState,dispatch:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return s(e,...n)}},o=t.map((e=>e(i)));return s=le(...o)(a.dispatch),{...a,dispatch:s}}}(...l),d=ut(c);return ie(o,s,u(..."function"===typeof i?i(d):d()))}({reducer:{user:vt.reducer}}),It=St;function Ct(){return Ct=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Ct.apply(this,arguments)}var Nt;!function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"}(Nt||(Nt={}));const Tt="popstate";function Et(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function At(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(gD){}}}function _t(e,t){return{usr:e.state,key:e.key,idx:t}}function $t(e,t,n,r){return void 0===n&&(n=null),Ct({pathname:"string"===typeof e?e:e.pathname,search:"",hash:""},"string"===typeof t?Dt(t):t,{state:n,key:t&&t.key||r||Math.random().toString(36).substr(2,8)})}function Rt(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(t+="#"===r.charAt(0)?r:"#"+r),t}function Dt(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substr(r),e=e.substr(0,r)),e&&(t.pathname=e)}return t}function Mt(e,t,n,r){void 0===r&&(r={});let{window:a=document.defaultView,v5Compat:s=!1}=r,i=a.history,o=Nt.Pop,l=null,u=c();function c(){return(i.state||{idx:null}).idx}function d(){o=Nt.Pop;let e=c(),t=null==e?null:e-u;u=e,l&&l({action:o,location:p.location,delta:t})}function h(e){let t="null"!==a.location.origin?a.location.origin:a.location.href,n="string"===typeof e?e:Rt(e);return n=n.replace(/ $/,"%20"),Et(t,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,t)}null==u&&(u=0,i.replaceState(Ct({},i.state,{idx:u}),""));let p={get action(){return o},get location(){return e(a,i)},listen(e){if(l)throw new Error("A history only accepts one active listener");return a.addEventListener(Tt,d),l=e,()=>{a.removeEventListener(Tt,d),l=null}},createHref:e=>t(a,e),createURL:h,encodeLocation(e){let t=h(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){o=Nt.Push;let r=$t(p.location,e,t);n&&n(r,e),u=c()+1;let d=_t(r,u),h=p.createHref(r);try{i.pushState(d,"",h)}catch(f){if(f instanceof DOMException&&"DataCloneError"===f.name)throw f;a.location.assign(h)}s&&l&&l({action:o,location:p.location,delta:1})},replace:function(e,t){o=Nt.Replace;let r=$t(p.location,e,t);n&&n(r,e),u=c();let a=_t(r,u),d=p.createHref(r);i.replaceState(a,"",d),s&&l&&l({action:o,location:p.location,delta:0})},go:e=>i.go(e)};return p}var Ft;!function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"}(Ft||(Ft={}));new Set(["lazy","caseSensitive","path","id","index","children"]);function Ot(e,t,n){return void 0===n&&(n="/"),Pt(e,t,n,!1)}function Pt(e,t,n,r){let a=Qt(("string"===typeof t?Dt(t):t).pathname||"/",n);if(null==a)return null;let s=Lt(e);!function(e){e.sort(((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every(((e,n)=>e===t[n]));return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map((e=>e.childrenIndex)),t.routesMeta.map((e=>e.childrenIndex)))))}(s);let i=null;for(let o=0;null==i&&o<s.length;++o){let e=Yt(a);i=Kt(s[o],e,r)}return i}function Lt(e,t,n,r){void 0===t&&(t=[]),void 0===n&&(n=[]),void 0===r&&(r="");let a=(e,a,s)=>{let i={relativePath:void 0===s?e.path||"":s,caseSensitive:!0===e.caseSensitive,childrenIndex:a,route:e};i.relativePath.startsWith("/")&&(Et(i.relativePath.startsWith(r),'Absolute route path "'+i.relativePath+'" nested under path "'+r+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),i.relativePath=i.relativePath.slice(r.length));let o=nn([r,i.relativePath]),l=n.concat(i);e.children&&e.children.length>0&&(Et(!0!==e.index,'Index routes must not have child routes. Please remove all child routes from route path "'+o+'".'),Lt(e.children,t,l,o)),(null!=e.path||e.index)&&t.push({path:o,score:qt(o,e.index),routesMeta:l})};return e.forEach(((e,t)=>{var n;if(""!==e.path&&null!=(n=e.path)&&n.includes("?"))for(let r of zt(e.path))a(e,t,r);else a(e,t)})),t}function zt(e){let t=e.split("/");if(0===t.length)return[];let[n,...r]=t,a=n.endsWith("?"),s=n.replace(/\?$/,"");if(0===r.length)return a?[s,""]:[s];let i=zt(r.join("/")),o=[];return o.push(...i.map((e=>""===e?s:[s,e].join("/")))),a&&o.push(...i),o.map((t=>e.startsWith("/")&&""===t?"/":t))}const Bt=/^:[\w-]+$/,Wt=3,Vt=2,Ut=1,jt=10,Gt=-2,Ht=e=>"*"===e;function qt(e,t){let n=e.split("/"),r=n.length;return n.some(Ht)&&(r+=Gt),t&&(r+=Vt),n.filter((e=>!Ht(e))).reduce(((e,t)=>e+(Bt.test(t)?Wt:""===t?Ut:jt)),r)}function Kt(e,t,n){void 0===n&&(n=!1);let{routesMeta:r}=e,a={},s="/",i=[];for(let o=0;o<r.length;++o){let e=r[o],l=o===r.length-1,u="/"===s?t:t.slice(s.length)||"/",c=Xt({path:e.relativePath,caseSensitive:e.caseSensitive,end:l},u),d=e.route;if(!c&&l&&n&&!r[r.length-1].route.index&&(c=Xt({path:e.relativePath,caseSensitive:e.caseSensitive,end:!1},u)),!c)return null;Object.assign(a,c.params),i.push({params:a,pathname:nn([s,c.pathname]),pathnameBase:rn(nn([s,c.pathnameBase])),route:d}),"/"!==c.pathnameBase&&(s=nn([s,c.pathnameBase]))}return i}function Xt(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=!0);At("*"===e||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were "'+e.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+e.replace(/\*$/,"/*")+'".');let r=[],a="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((e,t,n)=>(r.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));e.endsWith("*")?(r.push({paramName:"*"}),a+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?a+="\\/*$":""!==e&&"/"!==e&&(a+="(?:(?=\\/|$))");let s=new RegExp(a,t?void 0:"i");return[s,r]}(e.path,e.caseSensitive,e.end),a=t.match(n);if(!a)return null;let s=a[0],i=s.replace(/(.)\/+$/,"$1"),o=a.slice(1);return{params:r.reduce(((e,t,n)=>{let{paramName:r,isOptional:a}=t;if("*"===r){let e=o[n]||"";i=s.slice(0,s.length-e.length).replace(/(.)\/+$/,"$1")}const l=o[n];return e[r]=a&&!l?void 0:(l||"").replace(/%2F/g,"/"),e}),{}),pathname:s,pathnameBase:i,pattern:e}}function Yt(e){try{return e.split("/").map((e=>decodeURIComponent(e).replace(/\//g,"%2F"))).join("/")}catch(t){return At(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+t+")."),e}}function Qt(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&"/"!==r?null:e.slice(n)||"/"}function Jt(e,t,n,r){return"Cannot include a '"+e+"' character in a manually specified `to."+t+"` field ["+JSON.stringify(r)+"].  Please separate it out to the `to."+n+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function Zt(e){return e.filter(((e,t)=>0===t||e.route.path&&e.route.path.length>0))}function en(e,t){let n=Zt(e);return t?n.map(((e,t)=>t===n.length-1?e.pathname:e.pathnameBase)):n.map((e=>e.pathnameBase))}function tn(e,t,n,r){let a;void 0===r&&(r=!1),"string"===typeof e?a=Dt(e):(a=Ct({},e),Et(!a.pathname||!a.pathname.includes("?"),Jt("?","pathname","search",a)),Et(!a.pathname||!a.pathname.includes("#"),Jt("#","pathname","hash",a)),Et(!a.search||!a.search.includes("#"),Jt("#","search","hash",a)));let s,i=""===e||""===a.pathname,o=i?"/":a.pathname;if(null==o)s=n;else{let e=t.length-1;if(!r&&o.startsWith("..")){let t=o.split("/");for(;".."===t[0];)t.shift(),e-=1;a.pathname=t.join("/")}s=e>=0?t[e]:"/"}let l=function(e,t){void 0===t&&(t="/");let{pathname:n,search:r="",hash:a=""}="string"===typeof e?Dt(e):e,s=n?n.startsWith("/")?n:function(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach((e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)})),n.length>1?n.join("/"):"/"}(n,t):t;return{pathname:s,search:an(r),hash:sn(a)}}(a,s),u=o&&"/"!==o&&o.endsWith("/"),c=(i||"."===o)&&n.endsWith("/");return l.pathname.endsWith("/")||!u&&!c||(l.pathname+="/"),l}const nn=e=>e.join("/").replace(/\/\/+/g,"/"),rn=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),an=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",sn=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:"";Error;function on(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}const ln=["post","put","patch","delete"],un=(new Set(ln),["get",...ln]);new Set(un),new Set([301,302,303,307,308]),new Set([307,308]);Symbol("deferred");function cn(){return cn=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},cn.apply(this,arguments)}const dn=T.createContext(null);const hn=T.createContext(null);const pn=T.createContext(null);const fn=T.createContext(null);const mn=T.createContext({outlet:null,matches:[],isDataRoute:!1});const gn=T.createContext(null);function yn(){return null!=T.useContext(fn)}function bn(){return yn()||Et(!1),T.useContext(fn).location}function vn(e){T.useContext(pn).static||T.useLayoutEffect(e)}function xn(){let{isDataRoute:e}=T.useContext(mn);return e?function(){let{router:e}=An(Tn.UseNavigateStable),t=$n(En.UseNavigateStable),n=T.useRef(!1);vn((()=>{n.current=!0}));let r=T.useCallback((function(r,a){void 0===a&&(a={}),n.current&&("number"===typeof r?e.navigate(r):e.navigate(r,cn({fromRouteId:t},a)))}),[e,t]);return r}():function(){yn()||Et(!1);let e=T.useContext(dn),{basename:t,future:n,navigator:r}=T.useContext(pn),{matches:a}=T.useContext(mn),{pathname:s}=bn(),i=JSON.stringify(en(a,n.v7_relativeSplatPath)),o=T.useRef(!1);vn((()=>{o.current=!0}));let l=T.useCallback((function(n,a){if(void 0===a&&(a={}),!o.current)return;if("number"===typeof n)return void r.go(n);let l=tn(n,JSON.parse(i),s,"path"===a.relative);null==e&&"/"!==t&&(l.pathname="/"===l.pathname?t:nn([t,l.pathname])),(a.replace?r.replace:r.push)(l,a.state,a)}),[t,r,i,s,e]);return l}()}function wn(e,t,n,r){yn()||Et(!1);let{navigator:a}=T.useContext(pn),{matches:s}=T.useContext(mn),i=s[s.length-1],o=i?i.params:{},l=(i&&i.pathname,i?i.pathnameBase:"/");i&&i.route;let u,c=bn();if(t){var d;let e="string"===typeof t?Dt(t):t;"/"===l||(null==(d=e.pathname)?void 0:d.startsWith(l))||Et(!1),u=e}else u=c;let h=u.pathname||"/",p=h;if("/"!==l){let e=l.replace(/^\//,"").split("/");p="/"+h.replace(/^\//,"").split("/").slice(e.length).join("/")}let f=Ot(e,{pathname:p});let m=Nn(f&&f.map((e=>Object.assign({},e,{params:Object.assign({},o,e.params),pathname:nn([l,a.encodeLocation?a.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?l:nn([l,a.encodeLocation?a.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])}))),s,n,r);return t&&m?T.createElement(fn.Provider,{value:{location:cn({pathname:"/",search:"",hash:"",state:null,key:"default"},u),navigationType:Nt.Pop}},m):m}function kn(){let e=function(){var e;let t=T.useContext(gn),n=_n(En.UseRouteError),r=$n(En.UseRouteError);if(void 0!==t)return t;return null==(e=n.errors)?void 0:e[r]}(),t=on(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,r="rgba(200,200,200, 0.5)",a={padding:"0.5rem",backgroundColor:r};return T.createElement(T.Fragment,null,T.createElement("h2",null,"Unexpected Application Error!"),T.createElement("h3",{style:{fontStyle:"italic"}},t),n?T.createElement("pre",{style:a},n):null,null)}const Sn=T.createElement(kn,null);class In extends T.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?T.createElement(mn.Provider,{value:this.props.routeContext},T.createElement(gn.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function Cn(e){let{routeContext:t,match:n,children:r}=e,a=T.useContext(dn);return a&&a.static&&a.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=n.route.id),T.createElement(mn.Provider,{value:t},r)}function Nn(e,t,n,r){var a;if(void 0===t&&(t=[]),void 0===n&&(n=null),void 0===r&&(r=null),null==e){var s;if(!n)return null;if(n.errors)e=n.matches;else{if(!(null!=(s=r)&&s.v7_partialHydration&&0===t.length&&!n.initialized&&n.matches.length>0))return null;e=n.matches}}let i=e,o=null==(a=n)?void 0:a.errors;if(null!=o){let e=i.findIndex((e=>e.route.id&&void 0!==(null==o?void 0:o[e.route.id])));e>=0||Et(!1),i=i.slice(0,Math.min(i.length,e+1))}let l=!1,u=-1;if(n&&r&&r.v7_partialHydration)for(let c=0;c<i.length;c++){let e=i[c];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(u=c),e.route.id){let{loaderData:t,errors:r}=n,a=e.route.loader&&void 0===t[e.route.id]&&(!r||void 0===r[e.route.id]);if(e.route.lazy||a){l=!0,i=u>=0?i.slice(0,u+1):[i[0]];break}}}return i.reduceRight(((e,r,a)=>{let s,c=!1,d=null,h=null;var p;n&&(s=o&&r.route.id?o[r.route.id]:void 0,d=r.route.errorElement||Sn,l&&(u<0&&0===a?(p="route-fallback",!1||Rn[p]||(Rn[p]=!0),c=!0,h=null):u===a&&(c=!0,h=r.route.hydrateFallbackElement||null)));let f=t.concat(i.slice(0,a+1)),m=()=>{let t;return t=s?d:c?h:r.route.Component?T.createElement(r.route.Component,null):r.route.element?r.route.element:e,T.createElement(Cn,{match:r,routeContext:{outlet:e,matches:f,isDataRoute:null!=n},children:t})};return n&&(r.route.ErrorBoundary||r.route.errorElement||0===a)?T.createElement(In,{location:n.location,revalidation:n.revalidation,component:d,error:s,children:m(),routeContext:{outlet:null,matches:f,isDataRoute:!0}}):m()}),null)}var Tn=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(Tn||{}),En=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(En||{});function An(e){let t=T.useContext(dn);return t||Et(!1),t}function _n(e){let t=T.useContext(hn);return t||Et(!1),t}function $n(e){let t=function(){let e=T.useContext(mn);return e||Et(!1),e}(),n=t.matches[t.matches.length-1];return n.route.id||Et(!1),n.route.id}const Rn={};E.startTransition;function Dn(e){Et(!1)}function Mn(e){let{basename:t="/",children:n=null,location:r,navigationType:a=Nt.Pop,navigator:s,static:i=!1,future:o}=e;yn()&&Et(!1);let l=t.replace(/^\/*/,"/"),u=T.useMemo((()=>({basename:l,navigator:s,static:i,future:cn({v7_relativeSplatPath:!1},o)})),[l,o,s,i]);"string"===typeof r&&(r=Dt(r));let{pathname:c="/",search:d="",hash:h="",state:p=null,key:f="default"}=r,m=T.useMemo((()=>{let e=Qt(c,l);return null==e?null:{location:{pathname:e,search:d,hash:h,state:p,key:f},navigationType:a}}),[l,c,d,h,p,f,a]);return null==m?null:T.createElement(pn.Provider,{value:u},T.createElement(fn.Provider,{children:n,value:m}))}function Fn(e){let{children:t,location:n}=e;return wn(On(t),n)}new Promise((()=>{}));T.Component;function On(e,t){void 0===t&&(t=[]);let n=[];return T.Children.forEach(e,((e,r)=>{if(!T.isValidElement(e))return;let a=[...t,r];if(e.type===T.Fragment)return void n.push.apply(n,On(e.props.children,a));e.type!==Dn&&Et(!1),e.props.index&&e.props.children&&Et(!1);let s={id:e.props.id||a.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(s.children=On(e.props.children,a)),n.push(s)})),n}new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);try{window.__reactRouterVersion="6"}catch(gD){}new Map;const Pn=E.startTransition;_.flushSync,E.useId;function Ln(e){let{basename:t,children:n,future:r,window:a}=e,s=T.useRef();var i;null==s.current&&(s.current=(void 0===(i={window:a,v5Compat:!0})&&(i={}),Mt((function(e,t){let{pathname:n,search:r,hash:a}=e.location;return $t("",{pathname:n,search:r,hash:a},t.state&&t.state.usr||null,t.state&&t.state.key||"default")}),(function(e,t){return"string"===typeof t?t:Rt(t)}),null,i)));let o=s.current,[l,u]=T.useState({action:o.action,location:o.location}),{v7_startTransition:c}=r||{},d=T.useCallback((e=>{c&&Pn?Pn((()=>u(e))):u(e)}),[u,c]);return T.useLayoutEffect((()=>o.listen(d)),[o,d]),T.createElement(Mn,{basename:t,children:n,location:l.location,navigationType:l.action,navigator:o,future:r})}"undefined"!==typeof window&&"undefined"!==typeof window.document&&window.document.createElement;var zn,Bn;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(zn||(zn={})),function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"}(Bn||(Bn={}));var Wn=n(8387),Vn=n(4984),Un=n(2768),jn=n(9172),Gn=n(138);const Hn=e=>{const t={systemProps:{},otherProps:{}},n=e?.theme?.unstable_sxConfig??Gn.A;return Object.keys(e).forEach((r=>{n[r]?t.systemProps[r]=e[r]:t.otherProps[r]=e[r]})),t};function qn(e){const{sx:t,...n}=e,{systemProps:r,otherProps:a}=Hn(n);let s;return s=Array.isArray(t)?[r,...t]:"function"===typeof t?function(){const e=t(...arguments);return(0,jn.Q)(e)?{...r,...e}:r}:{...r,...t},{...a,sx:s}}var Kn=n(2390),Xn=n(4575);const Yn=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const t=T.useContext(Xn.T);return t&&(n=t,0!==Object.keys(n).length)?t:e;var n},Qn=(0,Kn.A)();const Jn=function(){return Yn(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Qn)};var Zn=n(579);var er=n(9386),tr=n(5913),nr=n(3375),rr=n(2532);const ar=(0,rr.A)("MuiBox",["root"]),sr=(0,tr.A)(),ir=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{themeId:t,defaultTheme:n,defaultClassName:r="MuiBox-root",generateClassName:a}=e,s=(0,Vn.Ay)("div",{shouldForwardProp:e=>"theme"!==e&&"sx"!==e&&"as"!==e})(Un.A);return T.forwardRef((function(e,i){const o=Jn(n),{className:l,component:u="div",...c}=qn(e);return(0,Zn.jsx)(s,{as:u,ref:i,className:(0,Wn.A)(l,a?a(r):r),theme:t&&o[t]||o,...c})}))}({themeId:nr.A,defaultTheme:sr,defaultClassName:ar.root,generateClassName:er.A.generate}),or=ir;var lr=n(8610),ur=n(6596),cr=n(4535),dr=n(5170);function hr(){const e=Jn(dr.A);return e[nr.A]||e}var pr=n(6870),fr=n(8249),mr=n(3582),gr=n(2372);function yr(e){return(0,gr.Ay)("MuiPaper",e)}(0,rr.A)("MuiPaper",["root","rounded","outlined","elevation","elevation0","elevation1","elevation2","elevation3","elevation4","elevation5","elevation6","elevation7","elevation8","elevation9","elevation10","elevation11","elevation12","elevation13","elevation14","elevation15","elevation16","elevation17","elevation18","elevation19","elevation20","elevation21","elevation22","elevation23","elevation24"]);const br=(0,cr.Ay)("div",{name:"MuiPaper",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],!n.square&&t.rounded,"elevation"===n.variant&&t[`elevation${n.elevation}`]]}})((0,pr.A)((e=>{let{theme:t}=e;return{backgroundColor:(t.vars||t).palette.background.paper,color:(t.vars||t).palette.text.primary,transition:t.transitions.create("box-shadow"),variants:[{props:e=>{let{ownerState:t}=e;return!t.square},style:{borderRadius:t.shape.borderRadius}},{props:{variant:"outlined"},style:{border:`1px solid ${(t.vars||t).palette.divider}`}},{props:{variant:"elevation"},style:{boxShadow:"var(--Paper-shadow)",backgroundImage:"var(--Paper-overlay)"}}]}}))),vr=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiPaper"}),r=hr(),{className:a,component:s="div",elevation:i=1,square:o=!1,variant:l="elevation",...u}=n,c={...n,component:s,elevation:i,square:o,variant:l},d=(e=>{const{square:t,elevation:n,variant:r,classes:a}=e,s={root:["root",r,!t&&"rounded","elevation"===r&&`elevation${n}`]};return(0,lr.A)(s,yr,a)})(c);return(0,Zn.jsx)(br,{as:s,ownerState:c,className:(0,Wn.A)(d.root,a),ref:t,...u,style:{..."elevation"===l&&{"--Paper-shadow":(r.vars||r).shadows[i],...r.vars&&{"--Paper-overlay":r.vars.overlays?.[i]},...!r.vars&&"dark"===r.palette.mode&&{"--Paper-overlay":`linear-gradient(${(0,ur.X4)("#fff",(0,mr.A)(i))}, ${(0,ur.X4)("#fff",(0,mr.A)(i))})`}},...u.style}})})),xr=vr;var wr=n(1722),kr=n(9436),Sr=n(6598),Ir=(n(3803),n(219),(0,Xn.w)((function(e,t){var n=e.styles,r=(0,Sr.J)([n],void 0,T.useContext(Xn.T)),a=T.useRef();return(0,kr.i)((function(){var e=t.key+"-global",n=new t.sheet.constructor({key:e,nonce:t.sheet.nonce,container:t.sheet.container,speedy:t.sheet.isSpeedy}),s=!1,i=document.querySelector('style[data-emotion="'+e+" "+r.name+'"]');return t.sheet.tags.length&&(n.before=t.sheet.tags[0]),null!==i&&(s=!0,i.setAttribute("data-emotion",e),n.hydrate([i])),a.current=[n,s],function(){n.flush()}}),[t]),(0,kr.i)((function(){var e=a.current,n=e[0];if(e[1])e[1]=!1;else{if(void 0!==r.next&&(0,wr.sk)(t,r.next,!0),n.tags.length){var s=n.tags[n.tags.length-1].nextElementSibling;n.before=s,n.flush()}t.insert("",r,n,!1)}}),[t,r.name]),null})));function Cr(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return(0,Sr.J)(t)}var Nr=function(){var e=Cr.apply(void 0,arguments),t="animation-"+e.name;return{name:t,styles:"@keyframes "+t+"{"+e.styles+"}",anim:1,toString:function(){return"_EMO_"+this.name+"_"+this.styles+"_EMO_"}}};function Tr(e){const{styles:t,defaultTheme:n={}}=e,r="function"===typeof t?e=>{return t(void 0===(r=e)||null===r||0===Object.keys(r).length?n:e);var r}:t;return(0,Zn.jsx)(Ir,{styles:r})}const Er=function(e){let{styles:t,themeId:n,defaultTheme:r={}}=e;const a=Jn(r),s="function"===typeof t?t(n&&a[n]||a):t;return(0,Zn.jsx)(Tr,{styles:s})};const Ar=function(e){return(0,Zn.jsx)(Er,{...e,defaultTheme:dr.A,themeId:nr.A})};var _r=n(6803);function $r(e){return(0,gr.Ay)("MuiTypography",e)}(0,rr.A)("MuiTypography",["root","h1","h2","h3","h4","h5","h6","subtitle1","subtitle2","body1","body2","inherit","button","caption","overline","alignLeft","alignRight","alignCenter","alignJustify","noWrap","gutterBottom","paragraph"]);const Rr={primary:!0,secondary:!0,error:!0,info:!0,success:!0,warning:!0,textPrimary:!0,textSecondary:!0,textDisabled:!0},Dr=qn,Mr=(0,cr.Ay)("span",{name:"MuiTypography",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.variant&&t[n.variant],"inherit"!==n.align&&t[`align${(0,_r.A)(n.align)}`],n.noWrap&&t.noWrap,n.gutterBottom&&t.gutterBottom,n.paragraph&&t.paragraph]}})((0,pr.A)((e=>{let{theme:t}=e;return{margin:0,variants:[{props:{variant:"inherit"},style:{font:"inherit",lineHeight:"inherit",letterSpacing:"inherit"}},...Object.entries(t.typography).filter((e=>{let[t,n]=e;return"inherit"!==t&&n&&"object"===typeof n})).map((e=>{let[t,n]=e;return{props:{variant:t},style:n}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars||t).palette[n].main}}})),...Object.entries(t.palette?.text||{}).filter((e=>{let[,t]=e;return"string"===typeof t})).map((e=>{let[n]=e;return{props:{color:`text${(0,_r.A)(n)}`},style:{color:(t.vars||t).palette.text[n]}}})),{props:e=>{let{ownerState:t}=e;return"inherit"!==t.align},style:{textAlign:"var(--Typography-textAlign)"}},{props:e=>{let{ownerState:t}=e;return t.noWrap},style:{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}},{props:e=>{let{ownerState:t}=e;return t.gutterBottom},style:{marginBottom:"0.35em"}},{props:e=>{let{ownerState:t}=e;return t.paragraph},style:{marginBottom:16}}]}}))),Fr={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",subtitle1:"h6",subtitle2:"h6",body1:"p",body2:"p",inherit:"p"},Or=T.forwardRef((function(e,t){const{color:n,...r}=(0,fr.b)({props:e,name:"MuiTypography"}),a=Dr({...r,...!Rr[n]&&{color:n}}),{align:s="inherit",className:i,component:o,gutterBottom:l=!1,noWrap:u=!1,paragraph:c=!1,variant:d="body1",variantMapping:h=Fr,...p}=a,f={...a,align:s,color:n,className:i,component:o,gutterBottom:l,noWrap:u,paragraph:c,variant:d,variantMapping:h},m=o||(c?"p":h[d]||Fr[d])||"span",g=(e=>{const{align:t,gutterBottom:n,noWrap:r,paragraph:a,variant:s,classes:i}=e,o={root:["root",s,"inherit"!==e.align&&`align${(0,_r.A)(t)}`,n&&"gutterBottom",r&&"noWrap",a&&"paragraph"]};return(0,lr.A)(o,$r,i)})(f);return(0,Zn.jsx)(Mr,{as:m,ref:t,className:(0,Wn.A)(g.root,i),...p,ownerState:f,style:{..."inherit"!==s&&{"--Typography-textAlign":s},...p.style}})})),Pr=Or;var Lr=n(5844),zr=n(7868),Br=n(3462),Wr=n(3940),Vr=n(4440),Ur=n(3468);function jr(e){return parseInt(e,10)||0}const Gr={visibility:"hidden",position:"absolute",overflow:"hidden",height:0,top:0,left:0,transform:"translateZ(0)"};const Hr=T.forwardRef((function(e,t){const{onChange:n,maxRows:r,minRows:a=1,style:s,value:i,...o}=e,{current:l}=T.useRef(null!=i),u=T.useRef(null),c=(0,Br.A)(t,u),d=T.useRef(null),h=T.useRef(null),p=T.useCallback((()=>{const t=u.current,n=(0,Wr.A)(t).getComputedStyle(t);if("0px"===n.width)return{outerHeightStyle:0,overflowing:!1};const s=h.current;s.style.width=n.width,s.value=t.value||e.placeholder||"x","\n"===s.value.slice(-1)&&(s.value+=" ");const i=n.boxSizing,o=jr(n.paddingBottom)+jr(n.paddingTop),l=jr(n.borderBottomWidth)+jr(n.borderTopWidth),c=s.scrollHeight;s.value="x";const d=s.scrollHeight;let p=c;a&&(p=Math.max(Number(a)*d,p)),r&&(p=Math.min(Number(r)*d,p)),p=Math.max(p,d);return{outerHeightStyle:p+("border-box"===i?o+l:0),overflowing:Math.abs(p-c)<=1}}),[r,a,e.placeholder]),f=T.useCallback((()=>{const e=p();if(void 0===(t=e)||null===t||0===Object.keys(t).length||0===t.outerHeightStyle&&!t.overflowing)return;var t;const n=e.outerHeightStyle,r=u.current;d.current!==n&&(d.current=n,r.style.height=`${n}px`),r.style.overflow=e.overflowing?"hidden":""}),[p]);(0,Vr.A)((()=>{const e=()=>{f()};let t;const n=(0,Ur.A)(e),r=u.current,a=(0,Wr.A)(r);let s;return a.addEventListener("resize",n),"undefined"!==typeof ResizeObserver&&(s=new ResizeObserver(e),s.observe(r)),()=>{n.clear(),cancelAnimationFrame(t),a.removeEventListener("resize",n),s&&s.disconnect()}}),[p,f]),(0,Vr.A)((()=>{f()}));return(0,Zn.jsxs)(T.Fragment,{children:[(0,Zn.jsx)("textarea",{value:i,onChange:e=>{l||f(),n&&n(e)},ref:c,rows:a,style:s,...o}),(0,Zn.jsx)("textarea",{"aria-hidden":!0,className:e.className,readOnly:!0,ref:h,tabIndex:-1,style:{...Gr,...s,paddingTop:0,paddingBottom:0}})]})})),qr=Hr;const Kr=function(e){return"string"===typeof e};function Xr(e){let{props:t,states:n,muiFormControl:r}=e;return n.reduce(((e,n)=>(e[n]=t[n],r&&"undefined"===typeof t[n]&&(e[n]=r[n]),e)),{})}const Yr=T.createContext(void 0);function Qr(){return T.useContext(Yr)}var Jr=n(5849),Zr=n(5013);function ea(e){return null!=e&&!(Array.isArray(e)&&0===e.length)}function ta(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return e&&(ea(e.value)&&""!==e.value||t&&ea(e.defaultValue)&&""!==e.defaultValue)}function na(e){return(0,gr.Ay)("MuiInputBase",e)}const ra=(0,rr.A)("MuiInputBase",["root","formControl","focused","disabled","adornedStart","adornedEnd","error","sizeSmall","multiline","colorSecondary","fullWidth","hiddenLabel","readOnly","input","inputSizeSmall","inputMultiline","inputTypeSearch","inputAdornedStart","inputAdornedEnd","inputHiddenLabel"]);var aa;const sa=(e,t)=>{const{ownerState:n}=e;return[t.root,n.formControl&&t.formControl,n.startAdornment&&t.adornedStart,n.endAdornment&&t.adornedEnd,n.error&&t.error,"small"===n.size&&t.sizeSmall,n.multiline&&t.multiline,n.color&&t[`color${(0,_r.A)(n.color)}`],n.fullWidth&&t.fullWidth,n.hiddenLabel&&t.hiddenLabel]},ia=(e,t)=>{const{ownerState:n}=e;return[t.input,"small"===n.size&&t.inputSizeSmall,n.multiline&&t.inputMultiline,"search"===n.type&&t.inputTypeSearch,n.startAdornment&&t.inputAdornedStart,n.endAdornment&&t.inputAdornedEnd,n.hiddenLabel&&t.inputHiddenLabel]},oa=(0,cr.Ay)("div",{name:"MuiInputBase",slot:"Root",overridesResolver:sa})((0,pr.A)((e=>{let{theme:t}=e;return{...t.typography.body1,color:(t.vars||t).palette.text.primary,lineHeight:"1.4375em",boxSizing:"border-box",position:"relative",cursor:"text",display:"inline-flex",alignItems:"center",[`&.${ra.disabled}`]:{color:(t.vars||t).palette.text.disabled,cursor:"default"},variants:[{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:"4px 0 5px"}},{props:e=>{let{ownerState:t,size:n}=e;return t.multiline&&"small"===n},style:{paddingTop:1}},{props:e=>{let{ownerState:t}=e;return t.fullWidth},style:{width:"100%"}}]}}))),la=(0,cr.Ay)("input",{name:"MuiInputBase",slot:"Input",overridesResolver:ia})((0,pr.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode,r={color:"currentColor",...t.vars?{opacity:t.vars.opacity.inputPlaceholder}:{opacity:n?.42:.5},transition:t.transitions.create("opacity",{duration:t.transitions.duration.shorter})},a={opacity:"0 !important"},s=t.vars?{opacity:t.vars.opacity.inputPlaceholder}:{opacity:n?.42:.5};return{font:"inherit",letterSpacing:"inherit",color:"currentColor",padding:"4px 0 5px",border:0,boxSizing:"content-box",background:"none",height:"1.4375em",margin:0,WebkitTapHighlightColor:"transparent",display:"block",minWidth:0,width:"100%","&::-webkit-input-placeholder":r,"&::-moz-placeholder":r,"&::-ms-input-placeholder":r,"&:focus":{outline:0},"&:invalid":{boxShadow:"none"},"&::-webkit-search-decoration":{WebkitAppearance:"none"},[`label[data-shrink=false] + .${ra.formControl} &`]:{"&::-webkit-input-placeholder":a,"&::-moz-placeholder":a,"&::-ms-input-placeholder":a,"&:focus::-webkit-input-placeholder":s,"&:focus::-moz-placeholder":s,"&:focus::-ms-input-placeholder":s},[`&.${ra.disabled}`]:{opacity:1,WebkitTextFillColor:(t.vars||t).palette.text.disabled},variants:[{props:e=>{let{ownerState:t}=e;return!t.disableInjectingGlobalStyles},style:{animationName:"mui-auto-fill-cancel",animationDuration:"10ms","&:-webkit-autofill":{animationDuration:"5000s",animationName:"mui-auto-fill"}}},{props:{size:"small"},style:{paddingTop:1}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{height:"auto",resize:"none",padding:0,paddingTop:0}},{props:{type:"search"},style:{MozAppearance:"textfield"}}]}}))),ua=function(e){return function(t){return(0,Zn.jsx)(Ar,{styles:"function"===typeof e?n=>e({theme:n,...t}):e})}}({"@keyframes mui-auto-fill":{from:{display:"block"}},"@keyframes mui-auto-fill-cancel":{from:{display:"block"}}}),ca=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiInputBase"}),{"aria-describedby":r,autoComplete:a,autoFocus:s,className:i,color:o,components:l={},componentsProps:u={},defaultValue:c,disabled:d,disableInjectingGlobalStyles:h,endAdornment:p,error:f,fullWidth:m=!1,id:g,inputComponent:y="input",inputProps:b={},inputRef:v,margin:x,maxRows:w,minRows:k,multiline:S=!1,name:I,onBlur:C,onChange:N,onClick:E,onFocus:A,onKeyDown:_,onKeyUp:$,placeholder:R,readOnly:D,renderSuffix:M,rows:F,size:O,slotProps:P={},slots:L={},startAdornment:z,type:B="text",value:W,...V}=n,U=null!=b.value?b.value:W,{current:j}=T.useRef(null!=U),G=T.useRef(),H=T.useCallback((e=>{0}),[]),q=(0,Jr.A)(G,v,b.ref,H),[K,X]=T.useState(!1),Y=Qr();const Q=Xr({props:n,muiFormControl:Y,states:["color","disabled","error","hiddenLabel","size","required","filled"]});Q.focused=Y?Y.focused:K,T.useEffect((()=>{!Y&&d&&K&&(X(!1),C&&C())}),[Y,d,K,C]);const J=Y&&Y.onFilled,Z=Y&&Y.onEmpty,ee=T.useCallback((e=>{ta(e)?J&&J():Z&&Z()}),[J,Z]);(0,Zr.A)((()=>{j&&ee({value:U})}),[U,ee,j]);T.useEffect((()=>{ee(G.current)}),[]);let te=y,ne=b;S&&"input"===te&&(ne=F?{type:void 0,minRows:F,maxRows:F,...ne}:{type:void 0,maxRows:w,minRows:k,...ne},te=qr);T.useEffect((()=>{Y&&Y.setAdornedStart(Boolean(z))}),[Y,z]);const re={...n,color:Q.color||"primary",disabled:Q.disabled,endAdornment:p,error:Q.error,focused:Q.focused,formControl:Y,fullWidth:m,hiddenLabel:Q.hiddenLabel,multiline:S,size:Q.size,startAdornment:z,type:B},ae=(e=>{const{classes:t,color:n,disabled:r,error:a,endAdornment:s,focused:i,formControl:o,fullWidth:l,hiddenLabel:u,multiline:c,readOnly:d,size:h,startAdornment:p,type:f}=e,m={root:["root",`color${(0,_r.A)(n)}`,r&&"disabled",a&&"error",l&&"fullWidth",i&&"focused",o&&"formControl",h&&"medium"!==h&&`size${(0,_r.A)(h)}`,c&&"multiline",p&&"adornedStart",s&&"adornedEnd",u&&"hiddenLabel",d&&"readOnly"],input:["input",r&&"disabled","search"===f&&"inputTypeSearch",c&&"inputMultiline","small"===h&&"inputSizeSmall",u&&"inputHiddenLabel",p&&"inputAdornedStart",s&&"inputAdornedEnd",d&&"readOnly"]};return(0,lr.A)(m,na,t)})(re),se=L.root||l.Root||oa,ie=P.root||u.root||{},oe=L.input||l.Input||la;return ne={...ne,...P.input??u.input},(0,Zn.jsxs)(T.Fragment,{children:[!h&&"function"===typeof ua&&(aa||(aa=(0,Zn.jsx)(ua,{}))),(0,Zn.jsxs)(se,{...ie,ref:t,onClick:e=>{G.current&&e.currentTarget===e.target&&G.current.focus(),E&&E(e)},...V,...!Kr(se)&&{ownerState:{...re,...ie.ownerState}},className:(0,Wn.A)(ae.root,ie.className,i,D&&"MuiInputBase-readOnly"),children:[z,(0,Zn.jsx)(Yr.Provider,{value:null,children:(0,Zn.jsx)(oe,{"aria-invalid":Q.error,"aria-describedby":r,autoComplete:a,autoFocus:s,defaultValue:c,disabled:Q.disabled,id:g,onAnimationStart:e=>{ee("mui-auto-fill-cancel"===e.animationName?G.current:{value:"x"})},name:I,placeholder:R,readOnly:D,required:Q.required,rows:F,value:U,onKeyDown:_,onKeyUp:$,type:B,...ne,...!Kr(oe)&&{as:te,ownerState:{...re,...ne.ownerState}},ref:q,className:(0,Wn.A)(ae.input,ne.className,D&&"MuiInputBase-readOnly"),onBlur:e=>{C&&C(e),b.onBlur&&b.onBlur(e),Y&&Y.onBlur?Y.onBlur(e):X(!1)},onChange:function(e){if(!j){const t=e.target||G.current;if(null==t)throw new Error((0,zr.A)(1));ee({value:t.value})}for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];b.onChange&&b.onChange(e,...n),N&&N(e,...n)},onFocus:e=>{A&&A(e),b.onFocus&&b.onFocus(e),Y&&Y.onFocus?Y.onFocus(e):X(!0)}})}),p,M?M({...Q,startAdornment:z}):null]})]})})),da=ca;var ha=n(1475);function pa(e){return(0,gr.Ay)("MuiInput",e)}const fa={...ra,...(0,rr.A)("MuiInput",["root","underline","input"])},ma=(0,cr.Ay)(oa,{shouldForwardProp:e=>(0,ha.A)(e)||"classes"===e,name:"MuiInput",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[...sa(e,t),!n.disableUnderline&&t.underline]}})((0,pr.A)((e=>{let{theme:t}=e;let n="light"===t.palette.mode?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)";return t.vars&&(n=`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`),{position:"relative",variants:[{props:e=>{let{ownerState:t}=e;return t.formControl},style:{"label + &":{marginTop:16}}},{props:e=>{let{ownerState:t}=e;return!t.disableUnderline},style:{"&::after":{left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${fa.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${fa.error}`]:{"&::before, &::after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${n}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${fa.disabled}, .${fa.error}):before`]:{borderBottom:`2px solid ${(t.vars||t).palette.text.primary}`,"@media (hover: none)":{borderBottom:`1px solid ${n}`}},[`&.${fa.disabled}:before`]:{borderBottomStyle:"dotted"}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n,disableUnderline:!1},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[n].main}`}}}}))]}}))),ga=(0,cr.Ay)(la,{name:"MuiInput",slot:"Input",overridesResolver:ia})({}),ya=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiInput"}),{disableUnderline:r=!1,components:a={},componentsProps:s,fullWidth:i=!1,inputComponent:o="input",multiline:l=!1,slotProps:u,slots:c={},type:d="text",...h}=n,p=(e=>{const{classes:t,disableUnderline:n}=e,r={root:["root",!n&&"underline"],input:["input"]},a=(0,lr.A)(r,pa,t);return{...t,...a}})(n),f={root:{ownerState:{disableUnderline:r}}},m=u??s?(0,jn.A)(u??s,f):f,g=c.root??a.Root??ma,y=c.input??a.Input??ga;return(0,Zn.jsx)(da,{slots:{root:g,input:y},slotProps:m,fullWidth:i,inputComponent:o,multiline:l,ref:t,type:d,...h,classes:p})}));ya&&(ya.muiName="Input");const ba=ya;function va(e){return(0,gr.Ay)("MuiFilledInput",e)}const xa={...ra,...(0,rr.A)("MuiFilledInput",["root","underline","input","adornedStart","adornedEnd","sizeSmall","multiline","hiddenLabel"])},wa=(0,cr.Ay)(oa,{shouldForwardProp:e=>(0,ha.A)(e)||"classes"===e,name:"MuiFilledInput",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[...sa(e,t),!n.disableUnderline&&t.underline]}})((0,pr.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode,r=n?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)",a=n?"rgba(0, 0, 0, 0.06)":"rgba(255, 255, 255, 0.09)",s=n?"rgba(0, 0, 0, 0.09)":"rgba(255, 255, 255, 0.13)",i=n?"rgba(0, 0, 0, 0.12)":"rgba(255, 255, 255, 0.12)";return{position:"relative",backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a,borderTopLeftRadius:(t.vars||t).shape.borderRadius,borderTopRightRadius:(t.vars||t).shape.borderRadius,transition:t.transitions.create("background-color",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),"&:hover":{backgroundColor:t.vars?t.vars.palette.FilledInput.hoverBg:s,"@media (hover: none)":{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a}},[`&.${xa.focused}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a},[`&.${xa.disabled}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.disabledBg:i},variants:[{props:e=>{let{ownerState:t}=e;return!t.disableUnderline},style:{"&::after":{left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${xa.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${xa.error}`]:{"&::before, &::after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`:r}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${xa.disabled}, .${xa.error}):before`]:{borderBottom:`1px solid ${(t.vars||t).palette.text.primary}`},[`&.${xa.disabled}:before`]:{borderBottomStyle:"dotted"}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{disableUnderline:!1,color:n},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[n]?.main}`}}}})),{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:12}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:12}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:"25px 12px 8px"}},{props:e=>{let{ownerState:t,size:n}=e;return t.multiline&&"small"===n},style:{paddingTop:21,paddingBottom:4}},{props:e=>{let{ownerState:t}=e;return t.multiline&&t.hiddenLabel},style:{paddingTop:16,paddingBottom:17}},{props:e=>{let{ownerState:t}=e;return t.multiline&&t.hiddenLabel&&"small"===t.size},style:{paddingTop:8,paddingBottom:9}}]}}))),ka=(0,cr.Ay)(la,{name:"MuiFilledInput",slot:"Input",overridesResolver:ia})((0,pr.A)((e=>{let{theme:t}=e;return{paddingTop:25,paddingRight:12,paddingBottom:8,paddingLeft:12,...!t.vars&&{"&:-webkit-autofill":{WebkitBoxShadow:"light"===t.palette.mode?null:"0 0 0 100px #266798 inset",WebkitTextFillColor:"light"===t.palette.mode?null:"#fff",caretColor:"light"===t.palette.mode?null:"#fff",borderTopLeftRadius:"inherit",borderTopRightRadius:"inherit"}},...t.vars&&{"&:-webkit-autofill":{borderTopLeftRadius:"inherit",borderTopRightRadius:"inherit"},[t.getColorSchemeSelector("dark")]:{"&:-webkit-autofill":{WebkitBoxShadow:"0 0 0 100px #266798 inset",WebkitTextFillColor:"#fff",caretColor:"#fff"}}},variants:[{props:{size:"small"},style:{paddingTop:21,paddingBottom:4}},{props:e=>{let{ownerState:t}=e;return t.hiddenLabel},style:{paddingTop:16,paddingBottom:17}},{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:0}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:0}},{props:e=>{let{ownerState:t}=e;return t.hiddenLabel&&"small"===t.size},style:{paddingTop:8,paddingBottom:9}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{paddingTop:0,paddingBottom:0,paddingLeft:0,paddingRight:0}}]}}))),Sa=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiFilledInput"}),{disableUnderline:r=!1,components:a={},componentsProps:s,fullWidth:i=!1,hiddenLabel:o,inputComponent:l="input",multiline:u=!1,slotProps:c,slots:d={},type:h="text",...p}=n,f={...n,disableUnderline:r,fullWidth:i,inputComponent:l,multiline:u,type:h},m=(e=>{const{classes:t,disableUnderline:n,startAdornment:r,endAdornment:a,size:s,hiddenLabel:i,multiline:o}=e,l={root:["root",!n&&"underline",r&&"adornedStart",a&&"adornedEnd","small"===s&&`size${(0,_r.A)(s)}`,i&&"hiddenLabel",o&&"multiline"],input:["input"]},u=(0,lr.A)(l,va,t);return{...t,...u}})(n),g={root:{ownerState:f},input:{ownerState:f}},y=c??s?(0,jn.A)(g,c??s):g,b=d.root??a.Root??wa,v=d.input??a.Input??ka;return(0,Zn.jsx)(da,{slots:{root:b,input:v},componentsProps:y,fullWidth:i,inputComponent:l,multiline:u,ref:t,type:h,...p,classes:m})}));Sa&&(Sa.muiName="Input");const Ia=Sa;var Ca;const Na=(0,cr.Ay)("fieldset",{shouldForwardProp:ha.A})({textAlign:"left",position:"absolute",bottom:0,right:0,top:-5,left:0,margin:0,padding:"0 8px",pointerEvents:"none",borderRadius:"inherit",borderStyle:"solid",borderWidth:1,overflow:"hidden",minWidth:"0%"}),Ta=(0,cr.Ay)("legend",{shouldForwardProp:ha.A})((0,pr.A)((e=>{let{theme:t}=e;return{float:"unset",width:"auto",overflow:"hidden",variants:[{props:e=>{let{ownerState:t}=e;return!t.withLabel},style:{padding:0,lineHeight:"11px",transition:t.transitions.create("width",{duration:150,easing:t.transitions.easing.easeOut})}},{props:e=>{let{ownerState:t}=e;return t.withLabel},style:{display:"block",padding:0,height:11,fontSize:"0.75em",visibility:"hidden",maxWidth:.01,transition:t.transitions.create("max-width",{duration:50,easing:t.transitions.easing.easeOut}),whiteSpace:"nowrap","& > span":{paddingLeft:5,paddingRight:5,display:"inline-block",opacity:0,visibility:"visible"}}},{props:e=>{let{ownerState:t}=e;return t.withLabel&&t.notched},style:{maxWidth:"100%",transition:t.transitions.create("max-width",{duration:100,easing:t.transitions.easing.easeOut,delay:50})}}]}})));function Ea(e){return(0,gr.Ay)("MuiOutlinedInput",e)}const Aa={...ra,...(0,rr.A)("MuiOutlinedInput",["root","notchedOutline","input"])},_a=(0,cr.Ay)(oa,{shouldForwardProp:e=>(0,ha.A)(e)||"classes"===e,name:"MuiOutlinedInput",slot:"Root",overridesResolver:sa})((0,pr.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{position:"relative",borderRadius:(t.vars||t).shape.borderRadius,[`&:hover .${Aa.notchedOutline}`]:{borderColor:(t.vars||t).palette.text.primary},[`&.${Aa.focused} .${Aa.notchedOutline}`]:{borderWidth:2},variants:[...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{[`&.${Aa.focused} .${Aa.notchedOutline}`]:{borderColor:(t.vars||t).palette[n].main}}}})),{props:{},style:{"@media (hover: none)":{[`&:hover .${Aa.notchedOutline}`]:{borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}},[`&.${Aa.error} .${Aa.notchedOutline}`]:{borderColor:(t.vars||t).palette.error.main},[`&.${Aa.disabled} .${Aa.notchedOutline}`]:{borderColor:(t.vars||t).palette.action.disabled}}},{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:14}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:14}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:"16.5px 14px"}},{props:e=>{let{ownerState:t,size:n}=e;return t.multiline&&"small"===n},style:{padding:"8.5px 14px"}}]}}))),$a=(0,cr.Ay)((function(e){const{children:t,classes:n,className:r,label:a,notched:s,...i}=e,o=null!=a&&""!==a,l={...e,notched:s,withLabel:o};return(0,Zn.jsx)(Na,{"aria-hidden":!0,className:r,ownerState:l,...i,children:(0,Zn.jsx)(Ta,{ownerState:l,children:o?(0,Zn.jsx)("span",{children:a}):Ca||(Ca=(0,Zn.jsx)("span",{className:"notranslate",children:"\u200b"}))})})}),{name:"MuiOutlinedInput",slot:"NotchedOutline",overridesResolver:(e,t)=>t.notchedOutline})((0,pr.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}}))),Ra=(0,cr.Ay)(la,{name:"MuiOutlinedInput",slot:"Input",overridesResolver:ia})((0,pr.A)((e=>{let{theme:t}=e;return{padding:"16.5px 14px",...!t.vars&&{"&:-webkit-autofill":{WebkitBoxShadow:"light"===t.palette.mode?null:"0 0 0 100px #266798 inset",WebkitTextFillColor:"light"===t.palette.mode?null:"#fff",caretColor:"light"===t.palette.mode?null:"#fff",borderRadius:"inherit"}},...t.vars&&{"&:-webkit-autofill":{borderRadius:"inherit"},[t.getColorSchemeSelector("dark")]:{"&:-webkit-autofill":{WebkitBoxShadow:"0 0 0 100px #266798 inset",WebkitTextFillColor:"#fff",caretColor:"#fff"}}},variants:[{props:{size:"small"},style:{padding:"8.5px 14px"}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:0}},{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:0}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:0}}]}}))),Da=T.forwardRef((function(e,t){var n;const r=(0,fr.b)({props:e,name:"MuiOutlinedInput"}),{components:a={},fullWidth:s=!1,inputComponent:i="input",label:o,multiline:l=!1,notched:u,slots:c={},type:d="text",...h}=r,p=(e=>{const{classes:t}=e,n=(0,lr.A)({root:["root"],notchedOutline:["notchedOutline"],input:["input"]},Ea,t);return{...t,...n}})(r),f=Qr(),m=Xr({props:r,muiFormControl:f,states:["color","disabled","error","focused","hiddenLabel","size","required"]}),g={...r,color:m.color||"primary",disabled:m.disabled,error:m.error,focused:m.focused,formControl:f,fullWidth:s,hiddenLabel:m.hiddenLabel,multiline:l,size:m.size,type:d},y=c.root??a.Root??_a,b=c.input??a.Input??Ra;return(0,Zn.jsx)(da,{slots:{root:y,input:b},renderSuffix:e=>(0,Zn.jsx)($a,{ownerState:g,className:p.notchedOutline,label:null!=o&&""!==o&&m.required?n||(n=(0,Zn.jsxs)(T.Fragment,{children:[o,"\u2009","*"]})):o,notched:"undefined"!==typeof u?u:Boolean(e.startAdornment||e.filled||e.focused)}),fullWidth:s,inputComponent:i,multiline:l,ref:t,type:d,...h,classes:{...p,notchedOutline:null}})}));Da&&(Da.muiName="Input");const Ma=Da;function Fa(e){return(0,gr.Ay)("MuiFormLabel",e)}const Oa=(0,rr.A)("MuiFormLabel",["root","colorSecondary","focused","disabled","error","filled","required","asterisk"]),Pa=(0,cr.Ay)("label",{name:"MuiFormLabel",slot:"Root",overridesResolver:(e,t)=>{let{ownerState:n}=e;return{...t.root,..."secondary"===n.color&&t.colorSecondary,...n.filled&&t.filled}}})((0,pr.A)((e=>{let{theme:t}=e;return{color:(t.vars||t).palette.text.secondary,...t.typography.body1,lineHeight:"1.4375em",padding:0,position:"relative",variants:[...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{[`&.${Oa.focused}`]:{color:(t.vars||t).palette[n].main}}}})),{props:{},style:{[`&.${Oa.disabled}`]:{color:(t.vars||t).palette.text.disabled},[`&.${Oa.error}`]:{color:(t.vars||t).palette.error.main}}}]}}))),La=(0,cr.Ay)("span",{name:"MuiFormLabel",slot:"Asterisk",overridesResolver:(e,t)=>t.asterisk})((0,pr.A)((e=>{let{theme:t}=e;return{[`&.${Oa.error}`]:{color:(t.vars||t).palette.error.main}}}))),za=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiFormLabel"}),{children:r,className:a,color:s,component:i="label",disabled:o,error:l,filled:u,focused:c,required:d,...h}=n,p=Xr({props:n,muiFormControl:Qr(),states:["color","required","focused","disabled","error","filled"]}),f={...n,color:p.color||"primary",component:i,disabled:p.disabled,error:p.error,filled:p.filled,focused:p.focused,required:p.required},m=(e=>{const{classes:t,color:n,focused:r,disabled:a,error:s,filled:i,required:o}=e,l={root:["root",`color${(0,_r.A)(n)}`,a&&"disabled",s&&"error",i&&"filled",r&&"focused",o&&"required"],asterisk:["asterisk",s&&"error"]};return(0,lr.A)(l,Fa,t)})(f);return(0,Zn.jsxs)(Pa,{as:i,ownerState:f,className:(0,Wn.A)(m.root,a),ref:t,...h,children:[r,p.required&&(0,Zn.jsxs)(La,{ownerState:f,"aria-hidden":!0,className:m.asterisk,children:["\u2009","*"]})]})}));function Ba(e){return(0,gr.Ay)("MuiInputLabel",e)}(0,rr.A)("MuiInputLabel",["root","focused","disabled","error","required","asterisk","formControl","sizeSmall","shrink","animated","standard","filled","outlined"]);const Wa=(0,cr.Ay)(za,{shouldForwardProp:e=>(0,ha.A)(e)||"classes"===e,name:"MuiInputLabel",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[{[`& .${Oa.asterisk}`]:t.asterisk},t.root,n.formControl&&t.formControl,"small"===n.size&&t.sizeSmall,n.shrink&&t.shrink,!n.disableAnimation&&t.animated,n.focused&&t.focused,t[n.variant]]}})((0,pr.A)((e=>{let{theme:t}=e;return{display:"block",transformOrigin:"top left",whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis",maxWidth:"100%",variants:[{props:e=>{let{ownerState:t}=e;return t.formControl},style:{position:"absolute",left:0,top:0,transform:"translate(0, 20px) scale(1)"}},{props:{size:"small"},style:{transform:"translate(0, 17px) scale(1)"}},{props:e=>{let{ownerState:t}=e;return t.shrink},style:{transform:"translate(0, -1.5px) scale(0.75)",transformOrigin:"top left",maxWidth:"133%"}},{props:e=>{let{ownerState:t}=e;return!t.disableAnimation},style:{transition:t.transitions.create(["color","transform","max-width"],{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut})}},{props:{variant:"filled"},style:{zIndex:1,pointerEvents:"none",transform:"translate(12px, 16px) scale(1)",maxWidth:"calc(100% - 24px)"}},{props:{variant:"filled",size:"small"},style:{transform:"translate(12px, 13px) scale(1)"}},{props:e=>{let{variant:t,ownerState:n}=e;return"filled"===t&&n.shrink},style:{userSelect:"none",pointerEvents:"auto",transform:"translate(12px, 7px) scale(0.75)",maxWidth:"calc(133% - 24px)"}},{props:e=>{let{variant:t,ownerState:n,size:r}=e;return"filled"===t&&n.shrink&&"small"===r},style:{transform:"translate(12px, 4px) scale(0.75)"}},{props:{variant:"outlined"},style:{zIndex:1,pointerEvents:"none",transform:"translate(14px, 16px) scale(1)",maxWidth:"calc(100% - 24px)"}},{props:{variant:"outlined",size:"small"},style:{transform:"translate(14px, 9px) scale(1)"}},{props:e=>{let{variant:t,ownerState:n}=e;return"outlined"===t&&n.shrink},style:{userSelect:"none",pointerEvents:"auto",maxWidth:"calc(133% - 32px)",transform:"translate(14px, -9px) scale(0.75)"}}]}}))),Va=T.forwardRef((function(e,t){const n=(0,fr.b)({name:"MuiInputLabel",props:e}),{disableAnimation:r=!1,margin:a,shrink:s,variant:i,className:o,...l}=n,u=Qr();let c=s;"undefined"===typeof c&&u&&(c=u.filled||u.focused||u.adornedStart);const d=Xr({props:n,muiFormControl:u,states:["size","variant","required","focused"]}),h={...n,disableAnimation:r,formControl:u,shrink:c,size:d.size,variant:d.variant,required:d.required,focused:d.focused},p=(e=>{const{classes:t,formControl:n,size:r,shrink:a,disableAnimation:s,variant:i,required:o}=e,l={root:["root",n&&"formControl",!s&&"animated",a&&"shrink",r&&"normal"!==r&&`size${(0,_r.A)(r)}`,i],asterisk:[o&&"asterisk"]},u=(0,lr.A)(l,Ba,t);return{...t,...u}})(h);return(0,Zn.jsx)(Wa,{"data-shrink":c,ref:t,className:(0,Wn.A)(p.root,o),...l,ownerState:h,classes:p})})),Ua=Va;var ja=n(7328);function Ga(e){return(0,gr.Ay)("MuiFormControl",e)}(0,rr.A)("MuiFormControl",["root","marginNone","marginNormal","marginDense","fullWidth","disabled"]);const Ha=(0,cr.Ay)("div",{name:"MuiFormControl",slot:"Root",overridesResolver:(e,t)=>{let{ownerState:n}=e;return{...t.root,...t[`margin${(0,_r.A)(n.margin)}`],...n.fullWidth&&t.fullWidth}}})({display:"inline-flex",flexDirection:"column",position:"relative",minWidth:0,padding:0,margin:0,border:0,verticalAlign:"top",variants:[{props:{margin:"normal"},style:{marginTop:16,marginBottom:8}},{props:{margin:"dense"},style:{marginTop:8,marginBottom:4}},{props:{fullWidth:!0},style:{width:"100%"}}]}),qa=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiFormControl"}),{children:r,className:a,color:s="primary",component:i="div",disabled:o=!1,error:l=!1,focused:u,fullWidth:c=!1,hiddenLabel:d=!1,margin:h="none",required:p=!1,size:f="medium",variant:m="outlined",...g}=n,y={...n,color:s,component:i,disabled:o,error:l,fullWidth:c,hiddenLabel:d,margin:h,required:p,size:f,variant:m},b=(e=>{const{classes:t,margin:n,fullWidth:r}=e,a={root:["root","none"!==n&&`margin${(0,_r.A)(n)}`,r&&"fullWidth"]};return(0,lr.A)(a,Ga,t)})(y),[v,x]=T.useState((()=>{let e=!1;return r&&T.Children.forEach(r,(t=>{if(!(0,ja.A)(t,["Input","Select"]))return;const n=(0,ja.A)(t,["Select"])?t.props.input:t;n&&n.props.startAdornment&&(e=!0)})),e})),[w,k]=T.useState((()=>{let e=!1;return r&&T.Children.forEach(r,(t=>{(0,ja.A)(t,["Input","Select"])&&(ta(t.props,!0)||ta(t.props.inputProps,!0))&&(e=!0)})),e})),[S,I]=T.useState(!1);o&&S&&I(!1);const C=void 0===u||o?S:u;let N;const E=T.useMemo((()=>({adornedStart:v,setAdornedStart:x,color:s,disabled:o,error:l,filled:w,focused:C,fullWidth:c,hiddenLabel:d,size:f,onBlur:()=>{I(!1)},onEmpty:()=>{k(!1)},onFilled:()=>{k(!0)},onFocus:()=>{I(!0)},registerEffect:N,required:p,variant:m})),[v,s,o,l,w,C,c,d,N,p,f,m]);return(0,Zn.jsx)(Yr.Provider,{value:E,children:(0,Zn.jsx)(Ha,{as:i,ownerState:y,className:(0,Wn.A)(b.root,a),ref:t,...g,children:r})})})),Ka=qa;function Xa(e){return(0,gr.Ay)("MuiFormHelperText",e)}const Ya=(0,rr.A)("MuiFormHelperText",["root","error","disabled","sizeSmall","sizeMedium","contained","focused","filled","required"]);var Qa;const Ja=(0,cr.Ay)("p",{name:"MuiFormHelperText",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.size&&t[`size${(0,_r.A)(n.size)}`],n.contained&&t.contained,n.filled&&t.filled]}})((0,pr.A)((e=>{let{theme:t}=e;return{color:(t.vars||t).palette.text.secondary,...t.typography.caption,textAlign:"left",marginTop:3,marginRight:0,marginBottom:0,marginLeft:0,[`&.${Ya.disabled}`]:{color:(t.vars||t).palette.text.disabled},[`&.${Ya.error}`]:{color:(t.vars||t).palette.error.main},variants:[{props:{size:"small"},style:{marginTop:4}},{props:e=>{let{ownerState:t}=e;return t.contained},style:{marginLeft:14,marginRight:14}}]}}))),Za=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiFormHelperText"}),{children:r,className:a,component:s="p",disabled:i,error:o,filled:l,focused:u,margin:c,required:d,variant:h,...p}=n,f=Xr({props:n,muiFormControl:Qr(),states:["variant","size","disabled","error","filled","focused","required"]}),m={...n,component:s,contained:"filled"===f.variant||"outlined"===f.variant,variant:f.variant,size:f.size,disabled:f.disabled,error:f.error,filled:f.filled,focused:f.focused,required:f.required};delete m.ownerState;const g=(e=>{const{classes:t,contained:n,size:r,disabled:a,error:s,filled:i,focused:o,required:l}=e,u={root:["root",a&&"disabled",s&&"error",r&&`size${(0,_r.A)(r)}`,n&&"contained",o&&"focused",i&&"filled",l&&"required"]};return(0,lr.A)(u,Xa,t)})(m);return(0,Zn.jsx)(Ja,{as:s,className:(0,Wn.A)(g.root,a),ref:t,...p,ownerState:m,children:" "===r?Qa||(Qa=(0,Zn.jsx)("span",{className:"notranslate",children:"\u200b"})):r})}));function es(e){return e&&T.isValidElement(e)?e.props.propertyIsEnumerable("ref")?e.props.ref:e.ref:null}n(2086);var ts=n(2427);const ns=T.createContext();const rs=()=>T.useContext(ns)??!1;const as=function(e){return"string"===typeof e};const ss=function(e,t,n){return void 0===e||as(e)?t:{...t,ownerState:{...t.ownerState,...n}}};const is=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];if(void 0===e)return{};const n={};return Object.keys(e).filter((n=>n.match(/^on[A-Z]/)&&"function"===typeof e[n]&&!t.includes(n))).forEach((t=>{n[t]=e[t]})),n};const os=function(e){if(void 0===e)return{};const t={};return Object.keys(e).filter((t=>!(t.match(/^on[A-Z]/)&&"function"===typeof e[t]))).forEach((n=>{t[n]=e[n]})),t};const ls=function(e){const{getSlotProps:t,additionalProps:n,externalSlotProps:r,externalForwardedProps:a,className:s}=e;if(!t){const e=(0,Wn.A)(n?.className,s,a?.className,r?.className),t={...n?.style,...a?.style,...r?.style},i={...n,...a,...r};return e.length>0&&(i.className=e),Object.keys(t).length>0&&(i.style=t),{props:i,internalRef:void 0}}const i=is({...a,...r}),o=os(r),l=os(a),u=t(i),c=(0,Wn.A)(u?.className,n?.className,s,a?.className,r?.className),d={...u?.style,...n?.style,...a?.style,...r?.style},h={...u,...n,...l,...o};return c.length>0&&(h.className=c),Object.keys(d).length>0&&(h.style=d),{props:h,internalRef:u.ref}};const us=function(e,t,n){return"function"===typeof e?e(t,n):e};const cs=function(e){const{elementType:t,externalSlotProps:n,ownerState:r,skipResolvingSlotProps:a=!1,...s}=e,i=a?{}:us(n,r),{props:o,internalRef:l}=ls({...s,externalSlotProps:i}),u=(0,Br.A)(l,i?.ref,e.additionalProps?.ref);return ss(t,{...o,ref:u},r)};const ds=T.createContext({});function hs(e){return(0,gr.Ay)("MuiList",e)}(0,rr.A)("MuiList",["root","padding","dense","subheader"]);const ps=(0,cr.Ay)("ul",{name:"MuiList",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,!n.disablePadding&&t.padding,n.dense&&t.dense,n.subheader&&t.subheader]}})({listStyle:"none",margin:0,padding:0,position:"relative",variants:[{props:e=>{let{ownerState:t}=e;return!t.disablePadding},style:{paddingTop:8,paddingBottom:8}},{props:e=>{let{ownerState:t}=e;return t.subheader},style:{paddingTop:0}}]}),fs=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiList"}),{children:r,className:a,component:s="ul",dense:i=!1,disablePadding:o=!1,subheader:l,...u}=n,c=T.useMemo((()=>({dense:i})),[i]),d={...n,component:s,dense:i,disablePadding:o},h=(e=>{const{classes:t,disablePadding:n,dense:r,subheader:a}=e,s={root:["root",!n&&"padding",r&&"dense",a&&"subheader"]};return(0,lr.A)(s,hs,t)})(d);return(0,Zn.jsx)(ds.Provider,{value:c,children:(0,Zn.jsxs)(ps,{as:s,className:(0,Wn.A)(h.root,a),ref:t,ownerState:d,...u,children:[l,r]})})})),ms=fs;function gs(e){const t=e.documentElement.clientWidth;return Math.abs(window.innerWidth-t)}const ys=gs;function bs(e,t,n){return e===t?e.firstChild:t&&t.nextElementSibling?t.nextElementSibling:n?null:e.firstChild}function vs(e,t,n){return e===t?n?e.firstChild:e.lastChild:t&&t.previousElementSibling?t.previousElementSibling:n?null:e.lastChild}function xs(e,t){if(void 0===t)return!0;let n=e.innerText;return void 0===n&&(n=e.textContent),n=n.trim().toLowerCase(),0!==n.length&&(t.repeating?n[0]===t.keys[0]:n.startsWith(t.keys.join("")))}function ws(e,t,n,r,a,s){let i=!1,o=a(e,t,!!t&&n);for(;o;){if(o===e.firstChild){if(i)return!1;i=!0}const t=!r&&(o.disabled||"true"===o.getAttribute("aria-disabled"));if(o.hasAttribute("tabindex")&&xs(o,s)&&!t)return o.focus(),!0;o=a(e,o,n)}return!1}const ks=T.forwardRef((function(e,t){const{actions:n,autoFocus:r=!1,autoFocusItem:a=!1,children:s,className:i,disabledItemsFocusable:o=!1,disableListWrap:l=!1,onKeyDown:u,variant:c="selectedMenu",...d}=e,h=T.useRef(null),p=T.useRef({keys:[],repeating:!0,previousKeyMatched:!0,lastTime:null});(0,Zr.A)((()=>{r&&h.current.focus()}),[r]),T.useImperativeHandle(n,(()=>({adjustStyleForScrollbar:(e,t)=>{let{direction:n}=t;const r=!h.current.style.width;if(e.clientHeight<h.current.clientHeight&&r){const t=`${ys((0,ts.A)(e))}px`;h.current.style["rtl"===n?"paddingLeft":"paddingRight"]=t,h.current.style.width=`calc(100% + ${t})`}return h.current}})),[]);const f=(0,Jr.A)(h,t);let m=-1;T.Children.forEach(s,((e,t)=>{T.isValidElement(e)?(e.props.disabled||("selectedMenu"===c&&e.props.selected||-1===m)&&(m=t),m===t&&(e.props.disabled||e.props.muiSkipListHighlight||e.type.muiSkipListHighlight)&&(m+=1,m>=s.length&&(m=-1))):m===t&&(m+=1,m>=s.length&&(m=-1))}));const g=T.Children.map(s,((e,t)=>{if(t===m){const t={};return a&&(t.autoFocus=!0),void 0===e.props.tabIndex&&"selectedMenu"===c&&(t.tabIndex=0),T.cloneElement(e,t)}return e}));return(0,Zn.jsx)(ms,{role:"menu",ref:f,className:i,onKeyDown:e=>{const t=h.current,n=e.key;if(e.ctrlKey||e.metaKey||e.altKey)return void(u&&u(e));const r=(0,ts.A)(t).activeElement;if("ArrowDown"===n)e.preventDefault(),ws(t,r,l,o,bs);else if("ArrowUp"===n)e.preventDefault(),ws(t,r,l,o,vs);else if("Home"===n)e.preventDefault(),ws(t,null,l,o,bs);else if("End"===n)e.preventDefault(),ws(t,null,l,o,vs);else if(1===n.length){const a=p.current,s=n.toLowerCase(),i=performance.now();a.keys.length>0&&(i-a.lastTime>500?(a.keys=[],a.repeating=!0,a.previousKeyMatched=!0):a.repeating&&s!==a.keys[0]&&(a.repeating=!1)),a.lastTime=i,a.keys.push(s);const l=r&&!a.repeating&&xs(r,a);a.previousKeyMatched&&(l||ws(t,r,!1,o,bs,a))?e.preventDefault():a.previousKeyMatched=!1}u&&u(e)},tabIndex:r?0:-1,...d,children:g})})),Ss=ks;var Is=n(950),Cs=n(6078);const Ns={};function Ts(e,t){const n=T.useRef(Ns);return n.current===Ns&&(n.current=e(t)),n}const Es=[];class As{static create(){return new As}currentId=null;start(e,t){this.clear(),this.currentId=setTimeout((()=>{this.currentId=null,t()}),e)}clear=()=>{null!==this.currentId&&(clearTimeout(this.currentId),this.currentId=null)};disposeEffect=()=>this.clear}function _s(){const e=Ts(As.create).current;return function(e){T.useEffect(e,Es)}(e.disposeEffect),e}function $s(e,t){if(null==e)return{};var n={};for(var r in e)if({}.hasOwnProperty.call(e,r)){if(t.includes(r))continue;n[r]=e[r]}return n}function Rs(e,t){return Rs=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},Rs(e,t)}function Ds(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,Rs(e,t)}const Ms=!1,Fs=T.createContext(null);var Os=function(e){return e.scrollTop},Ps="unmounted",Ls="exited",zs="entering",Bs="entered",Ws="exiting",Vs=function(e){function t(t,n){var r;r=e.call(this,t,n)||this;var a,s=n&&!n.isMounting?t.enter:t.appear;return r.appearStatus=null,t.in?s?(a=Ls,r.appearStatus=zs):a=Bs:a=t.unmountOnExit||t.mountOnEnter?Ps:Ls,r.state={status:a},r.nextCallback=null,r}Ds(t,e),t.getDerivedStateFromProps=function(e,t){return e.in&&t.status===Ps?{status:Ls}:null};var n=t.prototype;return n.componentDidMount=function(){this.updateStatus(!0,this.appearStatus)},n.componentDidUpdate=function(e){var t=null;if(e!==this.props){var n=this.state.status;this.props.in?n!==zs&&n!==Bs&&(t=zs):n!==zs&&n!==Bs||(t=Ws)}this.updateStatus(!1,t)},n.componentWillUnmount=function(){this.cancelNextCallback()},n.getTimeouts=function(){var e,t,n,r=this.props.timeout;return e=t=n=r,null!=r&&"number"!==typeof r&&(e=r.exit,t=r.enter,n=void 0!==r.appear?r.appear:t),{exit:e,enter:t,appear:n}},n.updateStatus=function(e,t){if(void 0===e&&(e=!1),null!==t)if(this.cancelNextCallback(),t===zs){if(this.props.unmountOnExit||this.props.mountOnEnter){var n=this.props.nodeRef?this.props.nodeRef.current:A.findDOMNode(this);n&&Os(n)}this.performEnter(e)}else this.performExit();else this.props.unmountOnExit&&this.state.status===Ls&&this.setState({status:Ps})},n.performEnter=function(e){var t=this,n=this.props.enter,r=this.context?this.context.isMounting:e,a=this.props.nodeRef?[r]:[A.findDOMNode(this),r],s=a[0],i=a[1],o=this.getTimeouts(),l=r?o.appear:o.enter;!e&&!n||Ms?this.safeSetState({status:Bs},(function(){t.props.onEntered(s)})):(this.props.onEnter(s,i),this.safeSetState({status:zs},(function(){t.props.onEntering(s,i),t.onTransitionEnd(l,(function(){t.safeSetState({status:Bs},(function(){t.props.onEntered(s,i)}))}))})))},n.performExit=function(){var e=this,t=this.props.exit,n=this.getTimeouts(),r=this.props.nodeRef?void 0:A.findDOMNode(this);t&&!Ms?(this.props.onExit(r),this.safeSetState({status:Ws},(function(){e.props.onExiting(r),e.onTransitionEnd(n.exit,(function(){e.safeSetState({status:Ls},(function(){e.props.onExited(r)}))}))}))):this.safeSetState({status:Ls},(function(){e.props.onExited(r)}))},n.cancelNextCallback=function(){null!==this.nextCallback&&(this.nextCallback.cancel(),this.nextCallback=null)},n.safeSetState=function(e,t){t=this.setNextCallback(t),this.setState(e,t)},n.setNextCallback=function(e){var t=this,n=!0;return this.nextCallback=function(r){n&&(n=!1,t.nextCallback=null,e(r))},this.nextCallback.cancel=function(){n=!1},this.nextCallback},n.onTransitionEnd=function(e,t){this.setNextCallback(t);var n=this.props.nodeRef?this.props.nodeRef.current:A.findDOMNode(this),r=null==e&&!this.props.addEndListener;if(n&&!r){if(this.props.addEndListener){var a=this.props.nodeRef?[this.nextCallback]:[n,this.nextCallback],s=a[0],i=a[1];this.props.addEndListener(s,i)}null!=e&&setTimeout(this.nextCallback,e)}else setTimeout(this.nextCallback,0)},n.render=function(){var e=this.state.status;if(e===Ps)return null;var t=this.props,n=t.children,r=(t.in,t.mountOnEnter,t.unmountOnExit,t.appear,t.enter,t.exit,t.timeout,t.addEndListener,t.onEnter,t.onEntering,t.onEntered,t.onExit,t.onExiting,t.onExited,t.nodeRef,$s(t,["children","in","mountOnEnter","unmountOnExit","appear","enter","exit","timeout","addEndListener","onEnter","onEntering","onEntered","onExit","onExiting","onExited","nodeRef"]));return T.createElement(Fs.Provider,{value:null},"function"===typeof n?n(e,r):T.cloneElement(T.Children.only(n),r))},t}(T.Component);function Us(){}Vs.contextType=Fs,Vs.propTypes={},Vs.defaultProps={in:!1,mountOnEnter:!1,unmountOnExit:!1,appear:!1,enter:!0,exit:!0,onEnter:Us,onEntering:Us,onEntered:Us,onExit:Us,onExiting:Us,onExited:Us},Vs.UNMOUNTED=Ps,Vs.EXITED=Ls,Vs.ENTERING=zs,Vs.ENTERED=Bs,Vs.EXITING=Ws;const js=Vs,Gs=e=>e.scrollTop;function Hs(e,t){const{timeout:n,easing:r,style:a={}}=e;return{duration:a.transitionDuration??("number"===typeof n?n:n[t.mode]||0),easing:a.transitionTimingFunction??("object"===typeof r?r[t.mode]:r),delay:a.transitionDelay}}function qs(e){return`scale(${e}, ${e**2})`}const Ks={entering:{opacity:1,transform:qs(1)},entered:{opacity:1,transform:"none"}},Xs="undefined"!==typeof navigator&&/^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent)&&/(os |version\/)15(.|_)4/i.test(navigator.userAgent),Ys=T.forwardRef((function(e,t){const{addEndListener:n,appear:r=!0,children:a,easing:s,in:i,onEnter:o,onEntered:l,onEntering:u,onExit:c,onExited:d,onExiting:h,style:p,timeout:f="auto",TransitionComponent:m=js,...g}=e,y=_s(),b=T.useRef(),v=hr(),x=T.useRef(null),w=(0,Jr.A)(x,es(a),t),k=e=>t=>{if(e){const n=x.current;void 0===t?e(n):e(n,t)}},S=k(u),I=k(((e,t)=>{Gs(e);const{duration:n,delay:r,easing:a}=Hs({style:p,timeout:f,easing:s},{mode:"enter"});let i;"auto"===f?(i=v.transitions.getAutoHeightDuration(e.clientHeight),b.current=i):i=n,e.style.transition=[v.transitions.create("opacity",{duration:i,delay:r}),v.transitions.create("transform",{duration:Xs?i:.666*i,delay:r,easing:a})].join(","),o&&o(e,t)})),C=k(l),N=k(h),E=k((e=>{const{duration:t,delay:n,easing:r}=Hs({style:p,timeout:f,easing:s},{mode:"exit"});let a;"auto"===f?(a=v.transitions.getAutoHeightDuration(e.clientHeight),b.current=a):a=t,e.style.transition=[v.transitions.create("opacity",{duration:a,delay:n}),v.transitions.create("transform",{duration:Xs?a:.666*a,delay:Xs?n:n||.333*a,easing:r})].join(","),e.style.opacity=0,e.style.transform=qs(.75),c&&c(e)})),A=k(d);return(0,Zn.jsx)(m,{appear:r,in:i,nodeRef:x,onEnter:I,onEntered:C,onEntering:S,onExit:E,onExited:A,onExiting:N,addEndListener:e=>{"auto"===f&&y.start(b.current||0,e),n&&n(x.current,e)},timeout:"auto"===f?null:f,...g,children:(e,t)=>T.cloneElement(a,{style:{opacity:0,transform:qs(.75),visibility:"exited"!==e||i?void 0:"hidden",...Ks[e],...p,...a.props.style},ref:w,...t})})}));Ys&&(Ys.muiSupportAuto=!0);const Qs=Ys;var Js=n(1668);const Zs=["input","select","textarea","a[href]","button","[tabindex]","audio[controls]","video[controls]",'[contenteditable]:not([contenteditable="false"])'].join(",");function ei(e){const t=[],n=[];return Array.from(e.querySelectorAll(Zs)).forEach(((e,r)=>{const a=function(e){const t=parseInt(e.getAttribute("tabindex")||"",10);return Number.isNaN(t)?"true"===e.contentEditable||("AUDIO"===e.nodeName||"VIDEO"===e.nodeName||"DETAILS"===e.nodeName)&&null===e.getAttribute("tabindex")?0:e.tabIndex:t}(e);-1!==a&&function(e){return!(e.disabled||"INPUT"===e.tagName&&"hidden"===e.type||function(e){if("INPUT"!==e.tagName||"radio"!==e.type)return!1;if(!e.name)return!1;const t=t=>e.ownerDocument.querySelector(`input[type="radio"]${t}`);let n=t(`[name="${e.name}"]:checked`);return n||(n=t(`[name="${e.name}"]`)),n!==e}(e))}(e)&&(0===a?t.push(e):n.push({documentOrder:r,tabIndex:a,node:e}))})),n.sort(((e,t)=>e.tabIndex===t.tabIndex?e.documentOrder-t.documentOrder:e.tabIndex-t.tabIndex)).map((e=>e.node)).concat(t)}function ti(){return!0}const ni=function(e){const{children:t,disableAutoFocus:n=!1,disableEnforceFocus:r=!1,disableRestoreFocus:a=!1,getTabbable:s=ei,isEnabled:i=ti,open:o}=e,l=T.useRef(!1),u=T.useRef(null),c=T.useRef(null),d=T.useRef(null),h=T.useRef(null),p=T.useRef(!1),f=T.useRef(null),m=(0,Br.A)(es(t),f),g=T.useRef(null);T.useEffect((()=>{o&&f.current&&(p.current=!n)}),[n,o]),T.useEffect((()=>{if(!o||!f.current)return;const e=(0,Js.A)(f.current);return f.current.contains(e.activeElement)||(f.current.hasAttribute("tabIndex")||f.current.setAttribute("tabIndex","-1"),p.current&&f.current.focus()),()=>{a||(d.current&&d.current.focus&&(l.current=!0,d.current.focus()),d.current=null)}}),[o]),T.useEffect((()=>{if(!o||!f.current)return;const e=(0,Js.A)(f.current),t=t=>{g.current=t,!r&&i()&&"Tab"===t.key&&e.activeElement===f.current&&t.shiftKey&&(l.current=!0,c.current&&c.current.focus())},n=()=>{const t=f.current;if(null===t)return;if(!e.hasFocus()||!i()||l.current)return void(l.current=!1);if(t.contains(e.activeElement))return;if(r&&e.activeElement!==u.current&&e.activeElement!==c.current)return;if(e.activeElement!==h.current)h.current=null;else if(null!==h.current)return;if(!p.current)return;let n=[];if(e.activeElement!==u.current&&e.activeElement!==c.current||(n=s(f.current)),n.length>0){const e=Boolean(g.current?.shiftKey&&"Tab"===g.current?.key),t=n[0],r=n[n.length-1];"string"!==typeof t&&"string"!==typeof r&&(e?r.focus():t.focus())}else t.focus()};e.addEventListener("focusin",n),e.addEventListener("keydown",t,!0);const a=setInterval((()=>{e.activeElement&&"BODY"===e.activeElement.tagName&&n()}),50);return()=>{clearInterval(a),e.removeEventListener("focusin",n),e.removeEventListener("keydown",t,!0)}}),[n,r,a,i,o,s]);const y=e=>{null===d.current&&(d.current=e.relatedTarget),p.current=!0};return(0,Zn.jsxs)(T.Fragment,{children:[(0,Zn.jsx)("div",{tabIndex:o?0:-1,onFocus:y,ref:u,"data-testid":"sentinelStart"}),T.cloneElement(t,{ref:m,onFocus:e=>{null===d.current&&(d.current=e.relatedTarget),p.current=!0,h.current=e.target;const n=t.props.onFocus;n&&n(e)}}),(0,Zn.jsx)("div",{tabIndex:o?0:-1,onFocus:y,ref:c,"data-testid":"sentinelEnd"})]})};var ri=n(6564);const ai=T.forwardRef((function(e,t){const{children:n,container:r,disablePortal:a=!1}=e,[s,i]=T.useState(null),o=(0,Br.A)(es(n),t);if((0,Vr.A)((()=>{a||i(function(e){return"function"===typeof e?e():e}(r)||document.body)}),[r,a]),(0,Vr.A)((()=>{if(s&&!a)return(0,ri.A)(t,s),()=>{(0,ri.A)(t,null)}}),[t,s,a]),a){if(T.isValidElement(n)){const e={ref:o};return T.cloneElement(n,e)}return(0,Zn.jsx)(T.Fragment,{children:n})}return(0,Zn.jsx)(T.Fragment,{children:s?A.createPortal(n,s):s})}));function si(e,t){const{className:n,elementType:r,ownerState:a,externalForwardedProps:s,getSlotOwnerState:i,internalForwardedProps:o,...l}=t,{component:u,slots:c={[e]:void 0},slotProps:d={[e]:void 0},...h}=s,p=c[e]||r,f=us(d[e],a),{props:{component:m,...g},internalRef:y}=ls({className:n,...l,externalForwardedProps:"root"===e?h:void 0,externalSlotProps:f}),b=(0,Br.A)(y,f?.ref,t.ref),v=i?i(g):{},x={...a,...v},w="root"===e?m||u:m,k=ss(p,{..."root"===e&&!u&&!c[e]&&o,..."root"!==e&&!c[e]&&o,...g,...w&&{as:w},ref:b},x);return Object.keys(v).forEach((e=>{delete k[e]})),[p,k]}const ii={entering:{opacity:1},entered:{opacity:1}},oi=T.forwardRef((function(e,t){const n=hr(),r={enter:n.transitions.duration.enteringScreen,exit:n.transitions.duration.leavingScreen},{addEndListener:a,appear:s=!0,children:i,easing:o,in:l,onEnter:u,onEntered:c,onEntering:d,onExit:h,onExited:p,onExiting:f,style:m,timeout:g=r,TransitionComponent:y=js,...b}=e,v=T.useRef(null),x=(0,Jr.A)(v,es(i),t),w=e=>t=>{if(e){const n=v.current;void 0===t?e(n):e(n,t)}},k=w(d),S=w(((e,t)=>{Gs(e);const r=Hs({style:m,timeout:g,easing:o},{mode:"enter"});e.style.webkitTransition=n.transitions.create("opacity",r),e.style.transition=n.transitions.create("opacity",r),u&&u(e,t)})),I=w(c),C=w(f),N=w((e=>{const t=Hs({style:m,timeout:g,easing:o},{mode:"exit"});e.style.webkitTransition=n.transitions.create("opacity",t),e.style.transition=n.transitions.create("opacity",t),h&&h(e)})),E=w(p);return(0,Zn.jsx)(y,{appear:s,in:l,nodeRef:v,onEnter:S,onEntered:I,onEntering:k,onExit:N,onExited:E,onExiting:C,addEndListener:e=>{a&&a(v.current,e)},timeout:g,...b,children:(e,t)=>T.cloneElement(i,{style:{opacity:0,visibility:"exited"!==e||l?void 0:"hidden",...ii[e],...m,...i.props.style},ref:x,...t})})})),li=oi;function ui(e){return(0,gr.Ay)("MuiBackdrop",e)}(0,rr.A)("MuiBackdrop",["root","invisible"]);const ci=(0,cr.Ay)("div",{name:"MuiBackdrop",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.invisible&&t.invisible]}})({position:"fixed",display:"flex",alignItems:"center",justifyContent:"center",right:0,bottom:0,top:0,left:0,backgroundColor:"rgba(0, 0, 0, 0.5)",WebkitTapHighlightColor:"transparent",variants:[{props:{invisible:!0},style:{backgroundColor:"transparent"}}]}),di=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiBackdrop"}),{children:r,className:a,component:s="div",invisible:i=!1,open:o,components:l={},componentsProps:u={},slotProps:c={},slots:d={},TransitionComponent:h,transitionDuration:p,...f}=n,m={...n,component:s,invisible:i},g=(e=>{const{classes:t,invisible:n}=e,r={root:["root",n&&"invisible"]};return(0,lr.A)(r,ui,t)})(m),y={slots:{transition:h,root:l.Root,...d},slotProps:{...u,...c}},[b,v]=si("root",{elementType:ci,externalForwardedProps:y,className:(0,Wn.A)(g.root,a),ownerState:m}),[x,w]=si("transition",{elementType:li,externalForwardedProps:y,ownerState:m});return delete w.ownerState,(0,Zn.jsx)(x,{in:o,timeout:p,...f,...w,children:(0,Zn.jsx)(b,{"aria-hidden":!0,...v,classes:g,ref:t,children:r})})}));var hi=n(1782),pi=n(2456);function fi(e,t){t?e.setAttribute("aria-hidden","true"):e.removeAttribute("aria-hidden")}function mi(e){return parseInt((0,Wr.A)(e).getComputedStyle(e).paddingRight,10)||0}function gi(e,t,n,r,a){const s=[t,n,...r];[].forEach.call(e.children,(e=>{const t=-1===s.indexOf(e),n=!function(e){const t=-1!==["TEMPLATE","SCRIPT","STYLE","LINK","MAP","META","NOSCRIPT","PICTURE","COL","COLGROUP","PARAM","SLOT","SOURCE","TRACK"].indexOf(e.tagName),n="INPUT"===e.tagName&&"hidden"===e.getAttribute("type");return t||n}(e);t&&n&&fi(e,a)}))}function yi(e,t){let n=-1;return e.some(((e,r)=>!!t(e)&&(n=r,!0))),n}function bi(e,t){const n=[],r=e.container;if(!t.disableScrollLock){if(function(e){const t=(0,Js.A)(e);return t.body===e?(0,Wr.A)(e).innerWidth>t.documentElement.clientWidth:e.scrollHeight>e.clientHeight}(r)){const e=gs((0,Js.A)(r));n.push({value:r.style.paddingRight,property:"padding-right",el:r}),r.style.paddingRight=`${mi(r)+e}px`;const t=(0,Js.A)(r).querySelectorAll(".mui-fixed");[].forEach.call(t,(t=>{n.push({value:t.style.paddingRight,property:"padding-right",el:t}),t.style.paddingRight=`${mi(t)+e}px`}))}let e;if(r.parentNode instanceof DocumentFragment)e=(0,Js.A)(r).body;else{const t=r.parentElement,n=(0,Wr.A)(r);e="HTML"===t?.nodeName&&"scroll"===n.getComputedStyle(t).overflowY?t:r}n.push({value:e.style.overflow,property:"overflow",el:e},{value:e.style.overflowX,property:"overflow-x",el:e},{value:e.style.overflowY,property:"overflow-y",el:e}),e.style.overflow="hidden"}return()=>{n.forEach((e=>{let{value:t,el:n,property:r}=e;t?n.style.setProperty(r,t):n.style.removeProperty(r)}))}}const vi=new class{constructor(){this.modals=[],this.containers=[]}add(e,t){let n=this.modals.indexOf(e);if(-1!==n)return n;n=this.modals.length,this.modals.push(e),e.modalRef&&fi(e.modalRef,!1);const r=function(e){const t=[];return[].forEach.call(e.children,(e=>{"true"===e.getAttribute("aria-hidden")&&t.push(e)})),t}(t);gi(t,e.mount,e.modalRef,r,!0);const a=yi(this.containers,(e=>e.container===t));return-1!==a?(this.containers[a].modals.push(e),n):(this.containers.push({modals:[e],container:t,restore:null,hiddenSiblings:r}),n)}mount(e,t){const n=yi(this.containers,(t=>-1!==t.modals.indexOf(e))),r=this.containers[n];r.restore||(r.restore=bi(r,t))}remove(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this.modals.indexOf(e);if(-1===n)return n;const r=yi(this.containers,(t=>-1!==t.modals.indexOf(e))),a=this.containers[r];if(a.modals.splice(a.modals.indexOf(e),1),this.modals.splice(n,1),0===a.modals.length)a.restore&&a.restore(),e.modalRef&&fi(e.modalRef,t),gi(a.container,e.mount,e.modalRef,a.hiddenSiblings,!1),this.containers.splice(r,1);else{const e=a.modals[a.modals.length-1];e.modalRef&&fi(e.modalRef,!1)}return n}isTopModal(e){return this.modals.length>0&&this.modals[this.modals.length-1]===e}};const xi=function(e){const{container:t,disableEscapeKeyDown:n=!1,disableScrollLock:r=!1,manager:a=vi,closeAfterTransition:s=!1,onTransitionEnter:i,onTransitionExited:o,children:l,onClose:u,open:c,rootRef:d}=e,h=T.useRef({}),p=T.useRef(null),f=T.useRef(null),m=(0,Br.A)(f,d),[g,y]=T.useState(!c),b=function(e){return!!e&&e.props.hasOwnProperty("in")}(l);let v=!0;"false"!==e["aria-hidden"]&&!1!==e["aria-hidden"]||(v=!1);const x=()=>(h.current.modalRef=f.current,h.current.mount=p.current,h.current),w=()=>{a.mount(x(),{disableScrollLock:r}),f.current&&(f.current.scrollTop=0)},k=(0,hi.A)((()=>{const e=function(e){return"function"===typeof e?e():e}(t)||(0,Js.A)(p.current).body;a.add(x(),e),f.current&&w()})),S=T.useCallback((()=>a.isTopModal(x())),[a]),I=(0,hi.A)((e=>{p.current=e,e&&(c&&S()?w():f.current&&fi(f.current,v))})),C=T.useCallback((()=>{a.remove(x(),v)}),[v,a]);T.useEffect((()=>()=>{C()}),[C]),T.useEffect((()=>{c?k():b&&s||C()}),[c,C,b,s,k]);const N=e=>t=>{e.onKeyDown?.(t),"Escape"===t.key&&229!==t.which&&S()&&(n||(t.stopPropagation(),u&&u(t,"escapeKeyDown")))},E=e=>t=>{e.onClick?.(t),t.target===t.currentTarget&&u&&u(t,"backdropClick")};return{getRootProps:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=is(e);delete n.onTransitionEnter,delete n.onTransitionExited;const r={...n,...t};return{role:"presentation",...r,onKeyDown:N(r),ref:m}},getBackdropProps:function(){const e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{"aria-hidden":!0,...e,onClick:E(e),open:c}},getTransitionProps:()=>({onEnter:(0,pi.A)((()=>{y(!1),i&&i()}),l?.props.onEnter),onExited:(0,pi.A)((()=>{y(!0),o&&o(),s&&C()}),l?.props.onExited)}),rootRef:m,portalRef:I,isTopModal:S,exited:g,hasTransition:b}};function wi(e){return(0,gr.Ay)("MuiModal",e)}(0,rr.A)("MuiModal",["root","hidden","backdrop"]);const ki=(0,cr.Ay)("div",{name:"MuiModal",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,!n.open&&n.exited&&t.hidden]}})((0,pr.A)((e=>{let{theme:t}=e;return{position:"fixed",zIndex:(t.vars||t).zIndex.modal,right:0,bottom:0,top:0,left:0,variants:[{props:e=>{let{ownerState:t}=e;return!t.open&&t.exited},style:{visibility:"hidden"}}]}}))),Si=(0,cr.Ay)(di,{name:"MuiModal",slot:"Backdrop",overridesResolver:(e,t)=>t.backdrop})({zIndex:-1}),Ii=T.forwardRef((function(e,t){const n=(0,fr.b)({name:"MuiModal",props:e}),{BackdropComponent:r=Si,BackdropProps:a,classes:s,className:i,closeAfterTransition:o=!1,children:l,container:u,component:c,components:d={},componentsProps:h={},disableAutoFocus:p=!1,disableEnforceFocus:f=!1,disableEscapeKeyDown:m=!1,disablePortal:g=!1,disableRestoreFocus:y=!1,disableScrollLock:b=!1,hideBackdrop:v=!1,keepMounted:x=!1,onBackdropClick:w,onClose:k,onTransitionEnter:S,onTransitionExited:I,open:C,slotProps:N={},slots:E={},theme:A,..._}=n,$={...n,closeAfterTransition:o,disableAutoFocus:p,disableEnforceFocus:f,disableEscapeKeyDown:m,disablePortal:g,disableRestoreFocus:y,disableScrollLock:b,hideBackdrop:v,keepMounted:x},{getRootProps:R,getBackdropProps:D,getTransitionProps:M,portalRef:F,isTopModal:O,exited:P,hasTransition:L}=xi({...$,rootRef:t}),z={...$,exited:P},B=(e=>{const{open:t,exited:n,classes:r}=e,a={root:["root",!t&&n&&"hidden"],backdrop:["backdrop"]};return(0,lr.A)(a,wi,r)})(z),W={};if(void 0===l.props.tabIndex&&(W.tabIndex="-1"),L){const{onEnter:e,onExited:t}=M();W.onEnter=e,W.onExited=t}const V={slots:{root:d.Root,backdrop:d.Backdrop,...E},slotProps:{...h,...N}},[U,j]=si("root",{elementType:ki,externalForwardedProps:V,getSlotProps:R,additionalProps:{ref:t,as:c},ownerState:z,className:(0,Wn.A)(i,B?.root,!z.open&&z.exited&&B?.hidden)}),[G,H]=si("backdrop",{elementType:r,externalForwardedProps:V,additionalProps:a,getSlotProps:e=>D({...e,onClick:t=>{w&&w(t),e?.onClick&&e.onClick(t)}}),className:(0,Wn.A)(a?.className,B?.backdrop),ownerState:z}),q=(0,Jr.A)(a?.ref,H.ref);return x||C||L&&!P?(0,Zn.jsx)(ai,{ref:F,container:u,disablePortal:g,children:(0,Zn.jsxs)(U,{...j,..._,children:[!v&&r?(0,Zn.jsx)(G,{...H,ref:q}):null,(0,Zn.jsx)(ni,{disableEnforceFocus:f,disableAutoFocus:p,disableRestoreFocus:y,isEnabled:O,open:C,children:T.cloneElement(l,W)})]})}):null})),Ci=Ii;function Ni(e){return(0,gr.Ay)("MuiPopover",e)}(0,rr.A)("MuiPopover",["root","paper"]);function Ti(e,t){let n=0;return"number"===typeof t?n=t:"center"===t?n=e.height/2:"bottom"===t&&(n=e.height),n}function Ei(e,t){let n=0;return"number"===typeof t?n=t:"center"===t?n=e.width/2:"right"===t&&(n=e.width),n}function Ai(e){return[e.horizontal,e.vertical].map((e=>"number"===typeof e?`${e}px`:e)).join(" ")}function _i(e){return"function"===typeof e?e():e}const $i=(0,cr.Ay)(Ci,{name:"MuiPopover",slot:"Root",overridesResolver:(e,t)=>t.root})({}),Ri=(0,cr.Ay)(xr,{name:"MuiPopover",slot:"Paper",overridesResolver:(e,t)=>t.paper})({position:"absolute",overflowY:"auto",overflowX:"hidden",minWidth:16,minHeight:16,maxWidth:"calc(100% - 32px)",maxHeight:"calc(100% - 32px)",outline:0}),Di=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiPopover"}),{action:r,anchorEl:a,anchorOrigin:s={vertical:"top",horizontal:"left"},anchorPosition:i,anchorReference:o="anchorEl",children:l,className:u,container:c,elevation:d=8,marginThreshold:h=16,open:p,PaperProps:f={},slots:m={},slotProps:g={},transformOrigin:y={vertical:"top",horizontal:"left"},TransitionComponent:b=Qs,transitionDuration:v="auto",TransitionProps:{onEntering:x,...w}={},disableScrollLock:k=!1,...S}=n,I=g?.paper??f,C=T.useRef(),N={...n,anchorOrigin:s,anchorReference:o,elevation:d,marginThreshold:h,externalPaperSlotProps:I,transformOrigin:y,TransitionComponent:b,transitionDuration:v,TransitionProps:w},E=(e=>{const{classes:t}=e;return(0,lr.A)({root:["root"],paper:["paper"]},Ni,t)})(N),A=T.useCallback((()=>{if("anchorPosition"===o)return i;const e=_i(a),t=(e&&1===e.nodeType?e:(0,ts.A)(C.current).body).getBoundingClientRect();return{top:t.top+Ti(t,s.vertical),left:t.left+Ei(t,s.horizontal)}}),[a,s.horizontal,s.vertical,i,o]),_=T.useCallback((e=>({vertical:Ti(e,y.vertical),horizontal:Ei(e,y.horizontal)})),[y.horizontal,y.vertical]),$=T.useCallback((e=>{const t={width:e.offsetWidth,height:e.offsetHeight},n=_(t);if("none"===o)return{top:null,left:null,transformOrigin:Ai(n)};const r=A();let s=r.top-n.vertical,i=r.left-n.horizontal;const l=s+t.height,u=i+t.width,c=(0,Cs.A)(_i(a)),d=c.innerHeight-h,p=c.innerWidth-h;if(null!==h&&s<h){const e=s-h;s-=e,n.vertical+=e}else if(null!==h&&l>d){const e=l-d;s-=e,n.vertical+=e}if(null!==h&&i<h){const e=i-h;i-=e,n.horizontal+=e}else if(u>p){const e=u-p;i-=e,n.horizontal+=e}return{top:`${Math.round(s)}px`,left:`${Math.round(i)}px`,transformOrigin:Ai(n)}}),[a,o,A,_,h]),[R,D]=T.useState(p),M=T.useCallback((()=>{const e=C.current;if(!e)return;const t=$(e);null!==t.top&&(e.style.top=t.top),null!==t.left&&(e.style.left=t.left),e.style.transformOrigin=t.transformOrigin,D(!0)}),[$]);T.useEffect((()=>(k&&window.addEventListener("scroll",M),()=>window.removeEventListener("scroll",M))),[a,k,M]);T.useEffect((()=>{p&&M()})),T.useImperativeHandle(r,(()=>p?{updatePosition:()=>{M()}}:null),[p,M]),T.useEffect((()=>{if(!p)return;const e=(0,Is.A)((()=>{M()})),t=(0,Cs.A)(a);return t.addEventListener("resize",e),()=>{e.clear(),t.removeEventListener("resize",e)}}),[a,p,M]);let F=v;"auto"!==v||b.muiSupportAuto||(F=void 0);const O=c||(a?(0,ts.A)(_i(a)).body:void 0),P={slots:m,slotProps:{...g,paper:I}},[L,z]=si("paper",{elementType:Ri,externalForwardedProps:P,additionalProps:{elevation:d,className:(0,Wn.A)(E.paper,I?.className),style:R?I.style:{...I.style,opacity:0}},ownerState:N}),[B,{slotProps:W,...V}]=si("root",{elementType:$i,externalForwardedProps:P,additionalProps:{slotProps:{backdrop:{invisible:!0}},container:O,open:p},ownerState:N,className:(0,Wn.A)(E.root,u)}),U=(0,Jr.A)(C,z.ref);return(0,Zn.jsx)(B,{...V,...!Kr(B)&&{slotProps:W,disableScrollLock:k},...S,ref:t,children:(0,Zn.jsx)(b,{appear:!0,in:p,onEntering:(e,t)=>{x&&x(e,t),M()},onExited:()=>{D(!1)},timeout:F,...w,children:(0,Zn.jsx)(L,{...z,ref:U,children:l})})})})),Mi=Di;function Fi(e){return(0,gr.Ay)("MuiMenu",e)}(0,rr.A)("MuiMenu",["root","paper","list"]);const Oi={vertical:"top",horizontal:"right"},Pi={vertical:"top",horizontal:"left"},Li=(0,cr.Ay)(Mi,{shouldForwardProp:e=>(0,ha.A)(e)||"classes"===e,name:"MuiMenu",slot:"Root",overridesResolver:(e,t)=>t.root})({}),zi=(0,cr.Ay)(Ri,{name:"MuiMenu",slot:"Paper",overridesResolver:(e,t)=>t.paper})({maxHeight:"calc(100% - 96px)",WebkitOverflowScrolling:"touch"}),Bi=(0,cr.Ay)(Ss,{name:"MuiMenu",slot:"List",overridesResolver:(e,t)=>t.list})({outline:0}),Wi=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiMenu"}),{autoFocus:r=!0,children:a,className:s,disableAutoFocusItem:i=!1,MenuListProps:o={},onClose:l,open:u,PaperProps:c={},PopoverClasses:d,transitionDuration:h="auto",TransitionProps:{onEntering:p,...f}={},variant:m="selectedMenu",slots:g={},slotProps:y={},...b}=n,v=rs(),x={...n,autoFocus:r,disableAutoFocusItem:i,MenuListProps:o,onEntering:p,PaperProps:c,transitionDuration:h,TransitionProps:f,variant:m},w=(e=>{const{classes:t}=e;return(0,lr.A)({root:["root"],paper:["paper"],list:["list"]},Fi,t)})(x),k=r&&!i&&u,S=T.useRef(null);let I=-1;T.Children.map(a,((e,t)=>{T.isValidElement(e)&&(e.props.disabled||("selectedMenu"===m&&e.props.selected||-1===I)&&(I=t))}));const C=g.paper??zi,N=y.paper??c,E=cs({elementType:g.root,externalSlotProps:y.root,ownerState:x,className:[w.root,s]}),A=cs({elementType:C,externalSlotProps:N,ownerState:x,className:w.paper});return(0,Zn.jsx)(Li,{onClose:l,anchorOrigin:{vertical:"bottom",horizontal:v?"right":"left"},transformOrigin:v?Oi:Pi,slots:{paper:C,root:g.root},slotProps:{root:E,paper:A},open:u,ref:t,transitionDuration:h,TransitionProps:{onEntering:(e,t)=>{S.current&&S.current.adjustStyleForScrollbar(e,{direction:v?"rtl":"ltr"}),p&&p(e,t)},...f},ownerState:x,...b,classes:d,children:(0,Zn.jsx)(Bi,{onKeyDown:e=>{"Tab"===e.key&&(e.preventDefault(),l&&l(e,"tabKeyDown"))},actions:S,autoFocus:r&&(-1===I||i),autoFocusItem:k,variant:m,...o,className:(0,Wn.A)(w.list,o.className),children:a})})})),Vi=Wi;function Ui(e){return(0,gr.Ay)("MuiNativeSelect",e)}const ji=(0,rr.A)("MuiNativeSelect",["root","select","multiple","filled","outlined","standard","disabled","icon","iconOpen","iconFilled","iconOutlined","iconStandard","nativeInput","error"]),Gi=(0,cr.Ay)("select")((e=>{let{theme:t}=e;return{MozAppearance:"none",WebkitAppearance:"none",userSelect:"none",borderRadius:0,cursor:"pointer","&:focus":{borderRadius:0},[`&.${ji.disabled}`]:{cursor:"default"},"&[multiple]":{height:"auto"},"&:not([multiple]) option, &:not([multiple]) optgroup":{backgroundColor:(t.vars||t).palette.background.paper},variants:[{props:e=>{let{ownerState:t}=e;return"filled"!==t.variant&&"outlined"!==t.variant},style:{"&&&":{paddingRight:24,minWidth:16}}},{props:{variant:"filled"},style:{"&&&":{paddingRight:32}}},{props:{variant:"outlined"},style:{borderRadius:(t.vars||t).shape.borderRadius,"&:focus":{borderRadius:(t.vars||t).shape.borderRadius},"&&&":{paddingRight:32}}}]}})),Hi=(0,cr.Ay)(Gi,{name:"MuiNativeSelect",slot:"Select",shouldForwardProp:ha.A,overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.select,t[n.variant],n.error&&t.error,{[`&.${ji.multiple}`]:t.multiple}]}})({}),qi=(0,cr.Ay)("svg")((e=>{let{theme:t}=e;return{position:"absolute",right:0,top:"calc(50% - .5em)",pointerEvents:"none",color:(t.vars||t).palette.action.active,[`&.${ji.disabled}`]:{color:(t.vars||t).palette.action.disabled},variants:[{props:e=>{let{ownerState:t}=e;return t.open},style:{transform:"rotate(180deg)"}},{props:{variant:"filled"},style:{right:7}},{props:{variant:"outlined"},style:{right:7}}]}})),Ki=(0,cr.Ay)(qi,{name:"MuiNativeSelect",slot:"Icon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.icon,n.variant&&t[`icon${(0,_r.A)(n.variant)}`],n.open&&t.iconOpen]}})({}),Xi=T.forwardRef((function(e,t){const{className:n,disabled:r,error:a,IconComponent:s,inputRef:i,variant:o="standard",...l}=e,u={...e,disabled:r,variant:o,error:a},c=(e=>{const{classes:t,variant:n,disabled:r,multiple:a,open:s,error:i}=e,o={select:["select",n,r&&"disabled",a&&"multiple",i&&"error"],icon:["icon",`icon${(0,_r.A)(n)}`,s&&"iconOpen",r&&"disabled"]};return(0,lr.A)(o,Ui,t)})(u);return(0,Zn.jsxs)(T.Fragment,{children:[(0,Zn.jsx)(Hi,{ownerState:u,className:(0,Wn.A)(c.select,n),disabled:r,ref:i||t,...l}),e.multiple?null:(0,Zn.jsx)(Ki,{as:s,ownerState:u,className:c.icon})]})})),Yi=Xi;var Qi=n(7123),Ji=n(5420);function Zi(e){return(0,gr.Ay)("MuiSelect",e)}const eo=(0,rr.A)("MuiSelect",["root","select","multiple","filled","outlined","standard","disabled","focused","icon","iconOpen","iconFilled","iconOutlined","iconStandard","nativeInput","error"]);var to;const no=(0,cr.Ay)(Gi,{name:"MuiSelect",slot:"Select",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[{[`&.${eo.select}`]:t.select},{[`&.${eo.select}`]:t[n.variant]},{[`&.${eo.error}`]:t.error},{[`&.${eo.multiple}`]:t.multiple}]}})({[`&.${eo.select}`]:{height:"auto",minHeight:"1.4375em",textOverflow:"ellipsis",whiteSpace:"nowrap",overflow:"hidden"}}),ro=(0,cr.Ay)(qi,{name:"MuiSelect",slot:"Icon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.icon,n.variant&&t[`icon${(0,_r.A)(n.variant)}`],n.open&&t.iconOpen]}})({}),ao=(0,cr.Ay)("input",{shouldForwardProp:e=>(0,Qi.A)(e)&&"classes"!==e,name:"MuiSelect",slot:"NativeInput",overridesResolver:(e,t)=>t.nativeInput})({bottom:0,left:0,position:"absolute",opacity:0,pointerEvents:"none",width:"100%",boxSizing:"border-box"});function so(e,t){return"object"===typeof t&&null!==t?e===t:String(e)===String(t)}function io(e){return null==e||"string"===typeof e&&!e.trim()}const oo=T.forwardRef((function(e,t){const{"aria-describedby":n,"aria-label":r,autoFocus:a,autoWidth:s,children:i,className:o,defaultOpen:l,defaultValue:u,disabled:c,displayEmpty:d,error:h=!1,IconComponent:p,inputRef:f,labelId:m,MenuProps:g={},multiple:y,name:b,onBlur:v,onChange:x,onClose:w,onFocus:k,onOpen:S,open:I,readOnly:C,renderValue:N,SelectDisplayProps:E={},tabIndex:A,type:_,value:$,variant:R="standard",...D}=e,[M,F]=(0,Ji.A)({controlled:$,default:u,name:"Select"}),[O,P]=(0,Ji.A)({controlled:I,default:l,name:"Select"}),L=T.useRef(null),z=T.useRef(null),[B,W]=T.useState(null),{current:V}=T.useRef(null!=I),[U,j]=T.useState(),G=(0,Jr.A)(t,f),H=T.useCallback((e=>{z.current=e,e&&W(e)}),[]),q=B?.parentNode;T.useImperativeHandle(G,(()=>({focus:()=>{z.current.focus()},node:L.current,value:M})),[M]),T.useEffect((()=>{l&&O&&B&&!V&&(j(s?null:q.clientWidth),z.current.focus())}),[B,s]),T.useEffect((()=>{a&&z.current.focus()}),[a]),T.useEffect((()=>{if(!m)return;const e=(0,ts.A)(z.current).getElementById(m);if(e){const t=()=>{getSelection().isCollapsed&&z.current.focus()};return e.addEventListener("click",t),()=>{e.removeEventListener("click",t)}}}),[m]);const K=(e,t)=>{e?S&&S(t):w&&w(t),V||(j(s?null:q.clientWidth),P(e))},X=T.Children.toArray(i),Y=e=>t=>{let n;if(t.currentTarget.hasAttribute("tabindex")){if(y){n=Array.isArray(M)?M.slice():[];const t=M.indexOf(e.props.value);-1===t?n.push(e.props.value):n.splice(t,1)}else n=e.props.value;if(e.props.onClick&&e.props.onClick(t),M!==n&&(F(n),x)){const r=t.nativeEvent||t,a=new r.constructor(r.type,r);Object.defineProperty(a,"target",{writable:!0,value:{value:n,name:b}}),x(a,e)}y||K(!1,t)}},Q=null!==B&&O;let J,Z;delete D["aria-invalid"];const ee=[];let te=!1,ne=!1;(ta({value:M})||d)&&(N?J=N(M):te=!0);const re=X.map((e=>{if(!T.isValidElement(e))return null;let t;if(y){if(!Array.isArray(M))throw new Error((0,zr.A)(2));t=M.some((t=>so(t,e.props.value))),t&&te&&ee.push(e.props.children)}else t=so(M,e.props.value),t&&te&&(Z=e.props.children);return t&&(ne=!0),T.cloneElement(e,{"aria-selected":t?"true":"false",onClick:Y(e),onKeyUp:t=>{" "===t.key&&t.preventDefault(),e.props.onKeyUp&&e.props.onKeyUp(t)},role:"option",selected:t,value:void 0,"data-value":e.props.value})}));te&&(J=y?0===ee.length?null:ee.reduce(((e,t,n)=>(e.push(t),n<ee.length-1&&e.push(", "),e)),[]):Z);let ae,se=U;!s&&V&&B&&(se=q.clientWidth),ae="undefined"!==typeof A?A:c?null:0;const ie=E.id||(b?`mui-component-select-${b}`:void 0),oe={...e,variant:R,value:M,open:Q,error:h},le=(e=>{const{classes:t,variant:n,disabled:r,multiple:a,open:s,error:i}=e,o={select:["select",n,r&&"disabled",a&&"multiple",i&&"error"],icon:["icon",`icon${(0,_r.A)(n)}`,s&&"iconOpen",r&&"disabled"],nativeInput:["nativeInput"]};return(0,lr.A)(o,Zi,t)})(oe),ue={...g.PaperProps,...g.slotProps?.paper},ce=(0,Lr.A)();return(0,Zn.jsxs)(T.Fragment,{children:[(0,Zn.jsx)(no,{as:"div",ref:H,tabIndex:ae,role:"combobox","aria-controls":ce,"aria-disabled":c?"true":void 0,"aria-expanded":Q?"true":"false","aria-haspopup":"listbox","aria-label":r,"aria-labelledby":[m,ie].filter(Boolean).join(" ")||void 0,"aria-describedby":n,onKeyDown:e=>{if(!C){[" ","ArrowUp","ArrowDown","Enter"].includes(e.key)&&(e.preventDefault(),K(!0,e))}},onMouseDown:c||C?null:e=>{0===e.button&&(e.preventDefault(),z.current.focus(),K(!0,e))},onBlur:e=>{!Q&&v&&(Object.defineProperty(e,"target",{writable:!0,value:{value:M,name:b}}),v(e))},onFocus:k,...E,ownerState:oe,className:(0,Wn.A)(E.className,le.select,o),id:ie,children:io(J)?to||(to=(0,Zn.jsx)("span",{className:"notranslate",children:"\u200b"})):J}),(0,Zn.jsx)(ao,{"aria-invalid":h,value:Array.isArray(M)?M.join(","):M,name:b,ref:L,"aria-hidden":!0,onChange:e=>{const t=X.find((t=>t.props.value===e.target.value));void 0!==t&&(F(t.props.value),x&&x(e,t))},tabIndex:-1,disabled:c,className:le.nativeInput,autoFocus:a,...D,ownerState:oe}),(0,Zn.jsx)(ro,{as:p,className:le.icon,ownerState:oe}),(0,Zn.jsx)(Vi,{id:`menu-${b||""}`,anchorEl:q,open:Q,onClose:e=>{K(!1,e)},anchorOrigin:{vertical:"bottom",horizontal:"center"},transformOrigin:{vertical:"top",horizontal:"center"},...g,MenuListProps:{"aria-labelledby":m,role:"listbox","aria-multiselectable":y?"true":void 0,disableListWrap:!0,id:ce,...g.MenuListProps},slotProps:{...g.slotProps,paper:{...ue,style:{minWidth:se,...null!=ue?ue.style:null}}},children:re})]})})),lo=oo;var uo=n(9662);const co=(0,uo.A)((0,Zn.jsx)("path",{d:"M7 10l5 5 5-5z"}),"ArrowDropDown");var ho=n(3030);function po(e){const{theme:t,name:n,props:r}=e;return t&&t.components&&t.components[n]&&t.components[n].defaultProps?(0,ho.A)(t.components[n].defaultProps,r):r}function fo(e){let{props:t,name:n,defaultTheme:r,themeId:a}=e,s=Jn(r);return a&&(s=s[a]||s),po({theme:s,name:n,props:t})}function mo(e){let{props:t,name:n}=e;return fo({props:t,name:n,defaultTheme:dr.A,themeId:nr.A})}const go={name:"MuiSelect",overridesResolver:(e,t)=>t.root,shouldForwardProp:e=>(0,ha.A)(e)&&"variant"!==e,slot:"Root"},yo=(0,cr.Ay)(ba,go)(""),bo=(0,cr.Ay)(Ma,go)(""),vo=(0,cr.Ay)(Ia,go)(""),xo=T.forwardRef((function(e,t){const n=mo({name:"MuiSelect",props:e}),{autoWidth:r=!1,children:a,classes:s={},className:i,defaultOpen:o=!1,displayEmpty:l=!1,IconComponent:u=co,id:c,input:d,inputProps:h,label:p,labelId:f,MenuProps:m,multiple:g=!1,native:y=!1,onClose:b,onOpen:v,open:x,renderValue:w,SelectDisplayProps:k,variant:S="outlined",...I}=n,C=y?Yi:lo,N=Xr({props:n,muiFormControl:Qr(),states:["variant","error"]}),E=N.variant||S,A={...n,variant:E,classes:s},_=(e=>{const{classes:t}=e;return t})(A),{root:$,...R}=_,D=d||{standard:(0,Zn.jsx)(yo,{ownerState:A}),outlined:(0,Zn.jsx)(bo,{label:p,ownerState:A}),filled:(0,Zn.jsx)(vo,{ownerState:A})}[E],M=(0,Jr.A)(t,es(D));return(0,Zn.jsx)(T.Fragment,{children:T.cloneElement(D,{inputComponent:C,inputProps:{children:a,error:N.error,IconComponent:u,variant:E,type:void 0,multiple:g,...y?{id:c}:{autoWidth:r,defaultOpen:o,displayEmpty:l,labelId:f,MenuProps:m,onClose:b,onOpen:v,open:x,renderValue:w,SelectDisplayProps:{id:c,...k}},...h,classes:h?(0,jn.A)(R,h.classes):R,...d?d.props.inputProps:{}},...(g&&y||l)&&"outlined"===E?{notched:!0}:{},ref:M,className:(0,Wn.A)(D.props.className,i,_.root),...!d&&{variant:E},...I})})}));xo.muiName="Select";const wo=xo;function ko(e){return(0,gr.Ay)("MuiTextField",e)}(0,rr.A)("MuiTextField",["root"]);const So={standard:ba,filled:Ia,outlined:Ma},Io=(0,cr.Ay)(Ka,{name:"MuiTextField",slot:"Root",overridesResolver:(e,t)=>t.root})({}),Co=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiTextField"}),{autoComplete:r,autoFocus:a=!1,children:s,className:i,color:o="primary",defaultValue:l,disabled:u=!1,error:c=!1,FormHelperTextProps:d,fullWidth:h=!1,helperText:p,id:f,InputLabelProps:m,inputProps:g,InputProps:y,inputRef:b,label:v,maxRows:x,minRows:w,multiline:k=!1,name:S,onBlur:I,onChange:C,onFocus:N,placeholder:T,required:E=!1,rows:A,select:_=!1,SelectProps:$,slots:R={},slotProps:D={},type:M,value:F,variant:O="outlined",...P}=n,L={...n,autoFocus:a,color:o,disabled:u,error:c,fullWidth:h,multiline:k,required:E,select:_,variant:O},z=(e=>{const{classes:t}=e;return(0,lr.A)({root:["root"]},ko,t)})(L);const B=(0,Lr.A)(f),W=p&&B?`${B}-helper-text`:void 0,V=v&&B?`${B}-label`:void 0,U=So[O],j={slots:R,slotProps:{input:y,inputLabel:m,htmlInput:g,formHelperText:d,select:$,...D}},G={},H=j.slotProps.inputLabel;"outlined"===O&&(H&&"undefined"!==typeof H.shrink&&(G.notched=H.shrink),G.label=v),_&&($&&$.native||(G.id=void 0),G["aria-describedby"]=void 0);const[q,K]=si("input",{elementType:U,externalForwardedProps:j,additionalProps:G,ownerState:L}),[X,Y]=si("inputLabel",{elementType:Ua,externalForwardedProps:j,ownerState:L}),[Q,J]=si("htmlInput",{elementType:"input",externalForwardedProps:j,ownerState:L}),[Z,ee]=si("formHelperText",{elementType:Za,externalForwardedProps:j,ownerState:L}),[te,ne]=si("select",{elementType:wo,externalForwardedProps:j,ownerState:L}),re=(0,Zn.jsx)(q,{"aria-describedby":W,autoComplete:r,autoFocus:a,defaultValue:l,fullWidth:h,multiline:k,name:S,rows:A,maxRows:x,minRows:w,type:M,value:F,id:B,inputRef:b,onBlur:I,onChange:C,onFocus:N,placeholder:T,inputProps:J,slots:{input:R.htmlInput?Q:void 0},...K});return(0,Zn.jsxs)(Io,{className:(0,Wn.A)(z.root,i),disabled:u,error:c,fullWidth:h,ref:t,required:E,color:o,variant:O,ownerState:L,...P,children:[null!=v&&""!==v&&(0,Zn.jsx)(X,{htmlFor:B,id:V,...Y,children:v}),_?(0,Zn.jsx)(te,{"aria-describedby":W,id:B,labelId:V,value:F,input:re,...ne,children:s}):re,p&&(0,Zn.jsx)(Z,{id:W,...ee,children:p})]})})),No=Co;function To(e){try{return e.matches(":focus-visible")}catch(t){0}return!1}var Eo=n(3319);class Ao{static create(){return new Ao}static use(){const e=Ts(Ao.create).current,[t,n]=T.useState(!1);return e.shouldMount=t,e.setShouldMount=n,T.useEffect(e.mountEffect,[t]),e}constructor(){this.ref={current:null},this.mounted=null,this.didMount=!1,this.shouldMount=!1,this.setShouldMount=null}mount(){return this.mounted||(this.mounted=function(){let e,t;const n=new Promise(((n,r)=>{e=n,t=r}));return n.resolve=e,n.reject=t,n}(),this.shouldMount=!0,this.setShouldMount(this.shouldMount)),this.mounted}mountEffect=()=>{this.shouldMount&&!this.didMount&&null!==this.ref.current&&(this.didMount=!0,this.mounted.resolve())};start(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this.mount().then((()=>this.ref.current?.start(...t)))}stop(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this.mount().then((()=>this.ref.current?.stop(...t)))}pulsate(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this.mount().then((()=>this.ref.current?.pulsate(...t)))}}var _o=n(8168);function $o(e,t){var n=Object.create(null);return e&&T.Children.map(e,(function(e){return e})).forEach((function(e){n[e.key]=function(e){return t&&(0,T.isValidElement)(e)?t(e):e}(e)})),n}function Ro(e,t,n){return null!=n[t]?n[t]:e.props[t]}function Do(e,t,n){var r=$o(e.children),a=function(e,t){function n(n){return n in t?t[n]:e[n]}e=e||{},t=t||{};var r,a=Object.create(null),s=[];for(var i in e)i in t?s.length&&(a[i]=s,s=[]):s.push(i);var o={};for(var l in t){if(a[l])for(r=0;r<a[l].length;r++){var u=a[l][r];o[a[l][r]]=n(u)}o[l]=n(l)}for(r=0;r<s.length;r++)o[s[r]]=n(s[r]);return o}(t,r);return Object.keys(a).forEach((function(s){var i=a[s];if((0,T.isValidElement)(i)){var o=s in t,l=s in r,u=t[s],c=(0,T.isValidElement)(u)&&!u.props.in;!l||o&&!c?l||!o||c?l&&o&&(0,T.isValidElement)(u)&&(a[s]=(0,T.cloneElement)(i,{onExited:n.bind(null,i),in:u.props.in,exit:Ro(i,"exit",e),enter:Ro(i,"enter",e)})):a[s]=(0,T.cloneElement)(i,{in:!1}):a[s]=(0,T.cloneElement)(i,{onExited:n.bind(null,i),in:!0,exit:Ro(i,"exit",e),enter:Ro(i,"enter",e)})}})),a}var Mo=Object.values||function(e){return Object.keys(e).map((function(t){return e[t]}))},Fo=function(e){function t(t,n){var r,a=(r=e.call(this,t,n)||this).handleExited.bind(function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(r));return r.state={contextValue:{isMounting:!0},handleExited:a,firstRender:!0},r}Ds(t,e);var n=t.prototype;return n.componentDidMount=function(){this.mounted=!0,this.setState({contextValue:{isMounting:!1}})},n.componentWillUnmount=function(){this.mounted=!1},t.getDerivedStateFromProps=function(e,t){var n,r,a=t.children,s=t.handleExited;return{children:t.firstRender?(n=e,r=s,$o(n.children,(function(e){return(0,T.cloneElement)(e,{onExited:r.bind(null,e),in:!0,appear:Ro(e,"appear",n),enter:Ro(e,"enter",n),exit:Ro(e,"exit",n)})}))):Do(e,a,s),firstRender:!1}},n.handleExited=function(e,t){var n=$o(this.props.children);e.key in n||(e.props.onExited&&e.props.onExited(t),this.mounted&&this.setState((function(t){var n=(0,_o.A)({},t.children);return delete n[e.key],{children:n}})))},n.render=function(){var e=this.props,t=e.component,n=e.childFactory,r=$s(e,["component","childFactory"]),a=this.state.contextValue,s=Mo(this.state.children).map(n);return delete r.appear,delete r.enter,delete r.exit,null===t?T.createElement(Fs.Provider,{value:a},s):T.createElement(Fs.Provider,{value:a},T.createElement(t,r,s))},t}(T.Component);Fo.propTypes={},Fo.defaultProps={component:"div",childFactory:function(e){return e}};const Oo=Fo;const Po=function(e){const{className:t,classes:n,pulsate:r=!1,rippleX:a,rippleY:s,rippleSize:i,in:o,onExited:l,timeout:u}=e,[c,d]=T.useState(!1),h=(0,Wn.A)(t,n.ripple,n.rippleVisible,r&&n.ripplePulsate),p={width:i,height:i,top:-i/2+s,left:-i/2+a},f=(0,Wn.A)(n.child,c&&n.childLeaving,r&&n.childPulsate);return o||c||d(!0),T.useEffect((()=>{if(!o&&null!=l){const e=setTimeout(l,u);return()=>{clearTimeout(e)}}}),[l,o,u]),(0,Zn.jsx)("span",{className:h,style:p,children:(0,Zn.jsx)("span",{className:f})})};const Lo=(0,rr.A)("MuiTouchRipple",["root","ripple","rippleVisible","ripplePulsate","child","childLeaving","childPulsate"]),zo=Nr`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`,Bo=Nr`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`,Wo=Nr`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`,Vo=(0,cr.Ay)("span",{name:"MuiTouchRipple",slot:"Root"})({overflow:"hidden",pointerEvents:"none",position:"absolute",zIndex:0,top:0,right:0,bottom:0,left:0,borderRadius:"inherit"}),Uo=(0,cr.Ay)(Po,{name:"MuiTouchRipple",slot:"Ripple"})`
  opacity: 0;
  position: absolute;

  &.${Lo.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${zo};
    animation-duration: ${550}ms;
    animation-timing-function: ${e=>{let{theme:t}=e;return t.transitions.easing.easeInOut}};
  }

  &.${Lo.ripplePulsate} {
    animation-duration: ${e=>{let{theme:t}=e;return t.transitions.duration.shorter}}ms;
  }

  & .${Lo.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${Lo.childLeaving} {
    opacity: 0;
    animation-name: ${Bo};
    animation-duration: ${550}ms;
    animation-timing-function: ${e=>{let{theme:t}=e;return t.transitions.easing.easeInOut}};
  }

  & .${Lo.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${Wo};
    animation-duration: 2500ms;
    animation-timing-function: ${e=>{let{theme:t}=e;return t.transitions.easing.easeInOut}};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`,jo=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiTouchRipple"}),{center:r=!1,classes:a={},className:s,...i}=n,[o,l]=T.useState([]),u=T.useRef(0),c=T.useRef(null);T.useEffect((()=>{c.current&&(c.current(),c.current=null)}),[o]);const d=T.useRef(!1),h=_s(),p=T.useRef(null),f=T.useRef(null),m=T.useCallback((e=>{const{pulsate:t,rippleX:n,rippleY:r,rippleSize:s,cb:i}=e;l((e=>[...e,(0,Zn.jsx)(Uo,{classes:{ripple:(0,Wn.A)(a.ripple,Lo.ripple),rippleVisible:(0,Wn.A)(a.rippleVisible,Lo.rippleVisible),ripplePulsate:(0,Wn.A)(a.ripplePulsate,Lo.ripplePulsate),child:(0,Wn.A)(a.child,Lo.child),childLeaving:(0,Wn.A)(a.childLeaving,Lo.childLeaving),childPulsate:(0,Wn.A)(a.childPulsate,Lo.childPulsate)},timeout:550,pulsate:t,rippleX:n,rippleY:r,rippleSize:s},u.current)])),u.current+=1,c.current=i}),[a]),g=T.useCallback((function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>{};const{pulsate:a=!1,center:s=r||t.pulsate,fakeElement:i=!1}=t;if("mousedown"===e?.type&&d.current)return void(d.current=!1);"touchstart"===e?.type&&(d.current=!0);const o=i?null:f.current,l=o?o.getBoundingClientRect():{width:0,height:0,left:0,top:0};let u,c,g;if(s||void 0===e||0===e.clientX&&0===e.clientY||!e.clientX&&!e.touches)u=Math.round(l.width/2),c=Math.round(l.height/2);else{const{clientX:t,clientY:n}=e.touches&&e.touches.length>0?e.touches[0]:e;u=Math.round(t-l.left),c=Math.round(n-l.top)}if(s)g=Math.sqrt((2*l.width**2+l.height**2)/3),g%2===0&&(g+=1);else{const e=2*Math.max(Math.abs((o?o.clientWidth:0)-u),u)+2,t=2*Math.max(Math.abs((o?o.clientHeight:0)-c),c)+2;g=Math.sqrt(e**2+t**2)}e?.touches?null===p.current&&(p.current=()=>{m({pulsate:a,rippleX:u,rippleY:c,rippleSize:g,cb:n})},h.start(80,(()=>{p.current&&(p.current(),p.current=null)}))):m({pulsate:a,rippleX:u,rippleY:c,rippleSize:g,cb:n})}),[r,m,h]),y=T.useCallback((()=>{g({},{pulsate:!0})}),[g]),b=T.useCallback(((e,t)=>{if(h.clear(),"touchend"===e?.type&&p.current)return p.current(),p.current=null,void h.start(0,(()=>{b(e,t)}));p.current=null,l((e=>e.length>0?e.slice(1):e)),c.current=t}),[h]);return T.useImperativeHandle(t,(()=>({pulsate:y,start:g,stop:b})),[y,g,b]),(0,Zn.jsx)(Vo,{className:(0,Wn.A)(Lo.root,a.root,s),ref:f,...i,children:(0,Zn.jsx)(Oo,{component:null,exit:!0,children:o})})})),Go=jo;function Ho(e){return(0,gr.Ay)("MuiButtonBase",e)}const qo=(0,rr.A)("MuiButtonBase",["root","disabled","focusVisible"]),Ko=(0,cr.Ay)("button",{name:"MuiButtonBase",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"inline-flex",alignItems:"center",justifyContent:"center",position:"relative",boxSizing:"border-box",WebkitTapHighlightColor:"transparent",backgroundColor:"transparent",outline:0,border:0,margin:0,borderRadius:0,padding:0,cursor:"pointer",userSelect:"none",verticalAlign:"middle",MozAppearance:"none",WebkitAppearance:"none",textDecoration:"none",color:"inherit","&::-moz-focus-inner":{borderStyle:"none"},[`&.${qo.disabled}`]:{pointerEvents:"none",cursor:"default"},"@media print":{colorAdjust:"exact"}}),Xo=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiButtonBase"}),{action:r,centerRipple:a=!1,children:s,className:i,component:o="button",disabled:l=!1,disableRipple:u=!1,disableTouchRipple:c=!1,focusRipple:d=!1,focusVisibleClassName:h,LinkComponent:p="a",onBlur:f,onClick:m,onContextMenu:g,onDragLeave:y,onFocus:b,onFocusVisible:v,onKeyDown:x,onKeyUp:w,onMouseDown:k,onMouseLeave:S,onMouseUp:I,onTouchEnd:C,onTouchMove:N,onTouchStart:E,tabIndex:A=0,TouchRippleProps:_,touchRippleRef:$,type:R,...D}=n,M=T.useRef(null),F=Ao.use(),O=(0,Jr.A)(F.ref,$),[P,L]=T.useState(!1);l&&P&&L(!1),T.useImperativeHandle(r,(()=>({focusVisible:()=>{L(!0),M.current.focus()}})),[]);const z=F.shouldMount&&!u&&!l;function B(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:c;return(0,Eo.A)((r=>{t&&t(r);return n||F[e](r),!0}))}T.useEffect((()=>{P&&d&&!u&&F.pulsate()}),[u,d,P,F]);const W=B("start",k),V=B("stop",g),U=B("stop",y),j=B("stop",I),G=B("stop",(e=>{P&&e.preventDefault(),S&&S(e)})),H=B("start",E),q=B("stop",C),K=B("stop",N),X=B("stop",(e=>{To(e.target)||L(!1),f&&f(e)}),!1),Y=(0,Eo.A)((e=>{M.current||(M.current=e.currentTarget),To(e.target)&&(L(!0),v&&v(e)),b&&b(e)})),Q=()=>{const e=M.current;return o&&"button"!==o&&!("A"===e.tagName&&e.href)},J=(0,Eo.A)((e=>{d&&!e.repeat&&P&&" "===e.key&&F.stop(e,(()=>{F.start(e)})),e.target===e.currentTarget&&Q()&&" "===e.key&&e.preventDefault(),x&&x(e),e.target===e.currentTarget&&Q()&&"Enter"===e.key&&!l&&(e.preventDefault(),m&&m(e))})),Z=(0,Eo.A)((e=>{d&&" "===e.key&&P&&!e.defaultPrevented&&F.stop(e,(()=>{F.pulsate(e)})),w&&w(e),m&&e.target===e.currentTarget&&Q()&&" "===e.key&&!e.defaultPrevented&&m(e)}));let ee=o;"button"===ee&&(D.href||D.to)&&(ee=p);const te={};"button"===ee?(te.type=void 0===R?"button":R,te.disabled=l):(D.href||D.to||(te.role="button"),l&&(te["aria-disabled"]=l));const ne=(0,Jr.A)(t,M),re={...n,centerRipple:a,component:o,disabled:l,disableRipple:u,disableTouchRipple:c,focusRipple:d,tabIndex:A,focusVisible:P},ae=(e=>{const{disabled:t,focusVisible:n,focusVisibleClassName:r,classes:a}=e,s={root:["root",t&&"disabled",n&&"focusVisible"]},i=(0,lr.A)(s,Ho,a);return n&&r&&(i.root+=` ${r}`),i})(re);return(0,Zn.jsxs)(Ko,{as:ee,className:(0,Wn.A)(ae.root,i),ownerState:re,onBlur:X,onClick:m,onContextMenu:V,onFocus:Y,onKeyDown:J,onKeyUp:Z,onMouseDown:W,onMouseLeave:G,onMouseUp:j,onDragLeave:U,onTouchEnd:q,onTouchMove:K,onTouchStart:H,ref:ne,tabIndex:l?-1:A,type:R,...te,...D,children:[s,z?(0,Zn.jsx)(Go,{ref:O,center:a,..._}):null]})}));function Yo(e){return(0,gr.Ay)("MuiButton",e)}const Qo=(0,rr.A)("MuiButton",["root","text","textInherit","textPrimary","textSecondary","textSuccess","textError","textInfo","textWarning","outlined","outlinedInherit","outlinedPrimary","outlinedSecondary","outlinedSuccess","outlinedError","outlinedInfo","outlinedWarning","contained","containedInherit","containedPrimary","containedSecondary","containedSuccess","containedError","containedInfo","containedWarning","disableElevation","focusVisible","disabled","colorInherit","colorPrimary","colorSecondary","colorSuccess","colorError","colorInfo","colorWarning","textSizeSmall","textSizeMedium","textSizeLarge","outlinedSizeSmall","outlinedSizeMedium","outlinedSizeLarge","containedSizeSmall","containedSizeMedium","containedSizeLarge","sizeMedium","sizeSmall","sizeLarge","fullWidth","startIcon","endIcon","icon","iconSizeSmall","iconSizeMedium","iconSizeLarge"]);const Jo=T.createContext({});const Zo=T.createContext(void 0),el=[{props:{size:"small"},style:{"& > *:nth-of-type(1)":{fontSize:18}}},{props:{size:"medium"},style:{"& > *:nth-of-type(1)":{fontSize:20}}},{props:{size:"large"},style:{"& > *:nth-of-type(1)":{fontSize:22}}}],tl=(0,cr.Ay)(Xo,{shouldForwardProp:e=>(0,ha.A)(e)||"classes"===e,name:"MuiButton",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],t[`${n.variant}${(0,_r.A)(n.color)}`],t[`size${(0,_r.A)(n.size)}`],t[`${n.variant}Size${(0,_r.A)(n.size)}`],"inherit"===n.color&&t.colorInherit,n.disableElevation&&t.disableElevation,n.fullWidth&&t.fullWidth]}})((0,pr.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?t.palette.grey[300]:t.palette.grey[800],r="light"===t.palette.mode?t.palette.grey.A100:t.palette.grey[700];return{...t.typography.button,minWidth:64,padding:"6px 16px",border:0,borderRadius:(t.vars||t).shape.borderRadius,transition:t.transitions.create(["background-color","box-shadow","border-color","color"],{duration:t.transitions.duration.short}),"&:hover":{textDecoration:"none"},[`&.${Qo.disabled}`]:{color:(t.vars||t).palette.action.disabled},variants:[{props:{variant:"contained"},style:{color:"var(--variant-containedColor)",backgroundColor:"var(--variant-containedBg)",boxShadow:(t.vars||t).shadows[2],"&:hover":{boxShadow:(t.vars||t).shadows[4],"@media (hover: none)":{boxShadow:(t.vars||t).shadows[2]}},"&:active":{boxShadow:(t.vars||t).shadows[8]},[`&.${Qo.focusVisible}`]:{boxShadow:(t.vars||t).shadows[6]},[`&.${Qo.disabled}`]:{color:(t.vars||t).palette.action.disabled,boxShadow:(t.vars||t).shadows[0],backgroundColor:(t.vars||t).palette.action.disabledBackground}}},{props:{variant:"outlined"},style:{padding:"5px 15px",border:"1px solid currentColor",borderColor:"var(--variant-outlinedBorder, currentColor)",backgroundColor:"var(--variant-outlinedBg)",color:"var(--variant-outlinedColor)",[`&.${Qo.disabled}`]:{border:`1px solid ${(t.vars||t).palette.action.disabledBackground}`}}},{props:{variant:"text"},style:{padding:"6px 8px",color:"var(--variant-textColor)",backgroundColor:"var(--variant-textBg)"}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.dark&&t.contrastText})).map((e=>{let[n]=e;return{props:{color:n},style:{"--variant-textColor":(t.vars||t).palette[n].main,"--variant-outlinedColor":(t.vars||t).palette[n].main,"--variant-outlinedBorder":t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.5)`:(0,ur.X4)(t.palette[n].main,.5),"--variant-containedColor":(t.vars||t).palette[n].contrastText,"--variant-containedBg":(t.vars||t).palette[n].main,"@media (hover: hover)":{"&:hover":{"--variant-containedBg":(t.vars||t).palette[n].dark,"--variant-textBg":t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,ur.X4)(t.palette[n].main,t.palette.action.hoverOpacity),"--variant-outlinedBorder":(t.vars||t).palette[n].main,"--variant-outlinedBg":t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,ur.X4)(t.palette[n].main,t.palette.action.hoverOpacity)}}}}})),{props:{color:"inherit"},style:{"--variant-containedColor":t.vars?t.vars.palette.text.primary:t.palette.getContrastText?.(n),"--variant-containedBg":t.vars?t.vars.palette.Button.inheritContainedBg:n,"@media (hover: hover)":{"&:hover":{"--variant-containedBg":t.vars?t.vars.palette.Button.inheritContainedHoverBg:r,"--variant-textBg":t.vars?`rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,ur.X4)(t.palette.text.primary,t.palette.action.hoverOpacity),"--variant-outlinedBg":t.vars?`rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,ur.X4)(t.palette.text.primary,t.palette.action.hoverOpacity)}}}},{props:{size:"small",variant:"text"},style:{padding:"4px 5px",fontSize:t.typography.pxToRem(13)}},{props:{size:"large",variant:"text"},style:{padding:"8px 11px",fontSize:t.typography.pxToRem(15)}},{props:{size:"small",variant:"outlined"},style:{padding:"3px 9px",fontSize:t.typography.pxToRem(13)}},{props:{size:"large",variant:"outlined"},style:{padding:"7px 21px",fontSize:t.typography.pxToRem(15)}},{props:{size:"small",variant:"contained"},style:{padding:"4px 10px",fontSize:t.typography.pxToRem(13)}},{props:{size:"large",variant:"contained"},style:{padding:"8px 22px",fontSize:t.typography.pxToRem(15)}},{props:{disableElevation:!0},style:{boxShadow:"none","&:hover":{boxShadow:"none"},[`&.${Qo.focusVisible}`]:{boxShadow:"none"},"&:active":{boxShadow:"none"},[`&.${Qo.disabled}`]:{boxShadow:"none"}}},{props:{fullWidth:!0},style:{width:"100%"}}]}}))),nl=(0,cr.Ay)("span",{name:"MuiButton",slot:"StartIcon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.startIcon,t[`iconSize${(0,_r.A)(n.size)}`]]}})({display:"inherit",marginRight:8,marginLeft:-4,variants:[{props:{size:"small"},style:{marginLeft:-2}},...el]}),rl=(0,cr.Ay)("span",{name:"MuiButton",slot:"EndIcon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.endIcon,t[`iconSize${(0,_r.A)(n.size)}`]]}})({display:"inherit",marginRight:-4,marginLeft:8,variants:[{props:{size:"small"},style:{marginRight:-2}},...el]}),al=T.forwardRef((function(e,t){const n=T.useContext(Jo),r=T.useContext(Zo),a=(0,ho.A)(n,e),s=(0,fr.b)({props:a,name:"MuiButton"}),{children:i,color:o="primary",component:l="button",className:u,disabled:c=!1,disableElevation:d=!1,disableFocusRipple:h=!1,endIcon:p,focusVisibleClassName:f,fullWidth:m=!1,size:g="medium",startIcon:y,type:b,variant:v="text",...x}=s,w={...s,color:o,component:l,disabled:c,disableElevation:d,disableFocusRipple:h,fullWidth:m,size:g,type:b,variant:v},k=(e=>{const{color:t,disableElevation:n,fullWidth:r,size:a,variant:s,classes:i}=e,o={root:["root",s,`${s}${(0,_r.A)(t)}`,`size${(0,_r.A)(a)}`,`${s}Size${(0,_r.A)(a)}`,`color${(0,_r.A)(t)}`,n&&"disableElevation",r&&"fullWidth"],label:["label"],startIcon:["icon","startIcon",`iconSize${(0,_r.A)(a)}`],endIcon:["icon","endIcon",`iconSize${(0,_r.A)(a)}`]},l=(0,lr.A)(o,Yo,i);return{...i,...l}})(w),S=y&&(0,Zn.jsx)(nl,{className:k.startIcon,ownerState:w,children:y}),I=p&&(0,Zn.jsx)(rl,{className:k.endIcon,ownerState:w,children:p}),C=r||"";return(0,Zn.jsxs)(tl,{ownerState:w,className:(0,Wn.A)(n.className,k.root,u,C),component:l,disabled:c,focusRipple:!h,focusVisibleClassName:(0,Wn.A)(k.focusVisible,f),ref:t,type:b,...x,classes:k,children:[S,i,I]})})),sl=al;function il(e){return(0,gr.Ay)("MuiAlert",e)}const ol=(0,rr.A)("MuiAlert",["root","action","icon","message","filled","colorSuccess","colorInfo","colorWarning","colorError","filledSuccess","filledInfo","filledWarning","filledError","outlined","outlinedSuccess","outlinedInfo","outlinedWarning","outlinedError","standard","standardSuccess","standardInfo","standardWarning","standardError"]);function ll(e){return(0,gr.Ay)("MuiIconButton",e)}const ul=(0,rr.A)("MuiIconButton",["root","disabled","colorInherit","colorPrimary","colorSecondary","colorError","colorInfo","colorSuccess","colorWarning","edgeStart","edgeEnd","sizeSmall","sizeMedium","sizeLarge"]),cl=(0,cr.Ay)(Xo,{name:"MuiIconButton",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,"default"!==n.color&&t[`color${(0,_r.A)(n.color)}`],n.edge&&t[`edge${(0,_r.A)(n.edge)}`],t[`size${(0,_r.A)(n.size)}`]]}})((0,pr.A)((e=>{let{theme:t}=e;return{textAlign:"center",flex:"0 0 auto",fontSize:t.typography.pxToRem(24),padding:8,borderRadius:"50%",color:(t.vars||t).palette.action.active,transition:t.transitions.create("background-color",{duration:t.transitions.duration.shortest}),variants:[{props:{disableRipple:!1},style:{"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,ur.X4)(t.palette.action.active,t.palette.action.hoverOpacity),"@media (hover: none)":{backgroundColor:"transparent"}}}},{props:{edge:"start"},style:{marginLeft:-12}},{props:{edge:"start",size:"small"},style:{marginLeft:-3}},{props:{edge:"end"},style:{marginRight:-12}},{props:{edge:"end",size:"small"},style:{marginRight:-3}}]}})),(0,pr.A)((e=>{let{theme:t}=e;return{variants:[{props:{color:"inherit"},style:{color:"inherit"}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars||t).palette[n].main}}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n,disableRipple:!1},style:{"&:hover":{backgroundColor:t.vars?`rgba(${(t.vars||t).palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,ur.X4)((t.vars||t).palette[n].main,t.palette.action.hoverOpacity),"@media (hover: none)":{backgroundColor:"transparent"}}}}})),{props:{size:"small"},style:{padding:5,fontSize:t.typography.pxToRem(18)}},{props:{size:"large"},style:{padding:12,fontSize:t.typography.pxToRem(28)}}],[`&.${ul.disabled}`]:{backgroundColor:"transparent",color:(t.vars||t).palette.action.disabled}}}))),dl=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiIconButton"}),{edge:r=!1,children:a,className:s,color:i="default",disabled:o=!1,disableFocusRipple:l=!1,disableRipple:u=!1,size:c="medium",...d}=n,h={...n,edge:r,color:i,disabled:o,disableFocusRipple:l,disableRipple:u,size:c},p=(e=>{const{classes:t,disabled:n,color:r,edge:a,size:s}=e,i={root:["root",n&&"disabled","default"!==r&&`color${(0,_r.A)(r)}`,a&&`edge${(0,_r.A)(a)}`,`size${(0,_r.A)(s)}`]};return(0,lr.A)(i,ll,t)})(h);return(0,Zn.jsx)(cl,{className:(0,Wn.A)(p.root,s),centerRipple:!0,focusRipple:!l,disabled:o,disableRipple:u,ref:t,...d,ownerState:h,children:a})})),hl=(0,uo.A)((0,Zn.jsx)("path",{d:"M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"}),"SuccessOutlined"),pl=(0,uo.A)((0,Zn.jsx)("path",{d:"M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"}),"ReportProblemOutlined"),fl=(0,uo.A)((0,Zn.jsx)("path",{d:"M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"}),"ErrorOutline"),ml=(0,uo.A)((0,Zn.jsx)("path",{d:"M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"}),"InfoOutlined"),gl=(0,uo.A)((0,Zn.jsx)("path",{d:"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"}),"Close"),yl=(0,cr.Ay)(xr,{name:"MuiAlert",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],t[`${n.variant}${(0,_r.A)(n.color||n.severity)}`]]}})((0,pr.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?ur.e$:ur.a,r="light"===t.palette.mode?ur.a:ur.e$;return{...t.typography.body2,backgroundColor:"transparent",display:"flex",padding:"6px 16px",variants:[...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.light})).map((e=>{let[a]=e;return{props:{colorSeverity:a,variant:"standard"},style:{color:t.vars?t.vars.palette.Alert[`${a}Color`]:n(t.palette[a].light,.6),backgroundColor:t.vars?t.vars.palette.Alert[`${a}StandardBg`]:r(t.palette[a].light,.9),[`& .${ol.icon}`]:t.vars?{color:t.vars.palette.Alert[`${a}IconColor`]}:{color:t.palette[a].main}}}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.light})).map((e=>{let[r]=e;return{props:{colorSeverity:r,variant:"outlined"},style:{color:t.vars?t.vars.palette.Alert[`${r}Color`]:n(t.palette[r].light,.6),border:`1px solid ${(t.vars||t).palette[r].light}`,[`& .${ol.icon}`]:t.vars?{color:t.vars.palette.Alert[`${r}IconColor`]}:{color:t.palette[r].main}}}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.dark})).map((e=>{let[n]=e;return{props:{colorSeverity:n,variant:"filled"},style:{fontWeight:t.typography.fontWeightMedium,...t.vars?{color:t.vars.palette.Alert[`${n}FilledColor`],backgroundColor:t.vars.palette.Alert[`${n}FilledBg`]}:{backgroundColor:"dark"===t.palette.mode?t.palette[n].dark:t.palette[n].main,color:t.palette.getContrastText(t.palette[n].main)}}}}))]}}))),bl=(0,cr.Ay)("div",{name:"MuiAlert",slot:"Icon",overridesResolver:(e,t)=>t.icon})({marginRight:12,padding:"7px 0",display:"flex",fontSize:22,opacity:.9}),vl=(0,cr.Ay)("div",{name:"MuiAlert",slot:"Message",overridesResolver:(e,t)=>t.message})({padding:"8px 0",minWidth:0,overflow:"auto"}),xl=(0,cr.Ay)("div",{name:"MuiAlert",slot:"Action",overridesResolver:(e,t)=>t.action})({display:"flex",alignItems:"flex-start",padding:"4px 0 0 16px",marginLeft:"auto",marginRight:-8}),wl={success:(0,Zn.jsx)(hl,{fontSize:"inherit"}),warning:(0,Zn.jsx)(pl,{fontSize:"inherit"}),error:(0,Zn.jsx)(fl,{fontSize:"inherit"}),info:(0,Zn.jsx)(ml,{fontSize:"inherit"})},kl=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiAlert"}),{action:r,children:a,className:s,closeText:i="Close",color:o,components:l={},componentsProps:u={},icon:c,iconMapping:d=wl,onClose:h,role:p="alert",severity:f="success",slotProps:m={},slots:g={},variant:y="standard",...b}=n,v={...n,color:o,severity:f,variant:y,colorSeverity:o||f},x=(e=>{const{variant:t,color:n,severity:r,classes:a}=e,s={root:["root",`color${(0,_r.A)(n||r)}`,`${t}${(0,_r.A)(n||r)}`,`${t}`],icon:["icon"],message:["message"],action:["action"]};return(0,lr.A)(s,il,a)})(v),w={slots:{closeButton:l.CloseButton,closeIcon:l.CloseIcon,...g},slotProps:{...u,...m}},[k,S]=si("closeButton",{elementType:dl,externalForwardedProps:w,ownerState:v}),[I,C]=si("closeIcon",{elementType:gl,externalForwardedProps:w,ownerState:v});return(0,Zn.jsxs)(yl,{role:p,elevation:0,ownerState:v,className:(0,Wn.A)(x.root,s),ref:t,...b,children:[!1!==c?(0,Zn.jsx)(bl,{ownerState:v,className:x.icon,children:c||d[f]||wl[f]}):null,(0,Zn.jsx)(vl,{ownerState:v,className:x.message,children:a}),null!=r?(0,Zn.jsx)(xl,{ownerState:v,className:x.action,children:r}):null,null==r&&h?(0,Zn.jsx)(xl,{ownerState:v,className:x.action,children:(0,Zn.jsx)(k,{size:"small","aria-label":i,title:i,color:"inherit",onClick:h,...S,children:(0,Zn.jsx)(I,{fontSize:"small",...C})})}):null]})})),Sl=kl;function Il(e){return(0,gr.Ay)("MuiLink",e)}const Cl=(0,rr.A)("MuiLink",["root","underlineNone","underlineHover","underlineAlways","button","focusVisible"]);var Nl=n(6224);const Tl=e=>{let{theme:t,ownerState:n}=e;const r=n.color,a=(0,Nl.Yn)(t,`palette.${r}`,!1)||n.color,s=(0,Nl.Yn)(t,`palette.${r}Channel`);return"vars"in t&&s?`rgba(${s} / 0.4)`:(0,ur.X4)(a,.4)},El={primary:!0,secondary:!0,error:!0,info:!0,success:!0,warning:!0,textPrimary:!0,textSecondary:!0,textDisabled:!0},Al=(0,cr.Ay)(Pr,{name:"MuiLink",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`underline${(0,_r.A)(n.underline)}`],"button"===n.component&&t.button]}})((0,pr.A)((e=>{let{theme:t}=e;return{variants:[{props:{underline:"none"},style:{textDecoration:"none"}},{props:{underline:"hover"},style:{textDecoration:"none","&:hover":{textDecoration:"underline"}}},{props:{underline:"always"},style:{textDecoration:"underline","&:hover":{textDecorationColor:"inherit"}}},{props:e=>{let{underline:t,ownerState:n}=e;return"always"===t&&"inherit"!==n.color},style:{textDecorationColor:"var(--Link-underlineColor)"}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{underline:"always",color:n},style:{"--Link-underlineColor":t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.4)`:(0,ur.X4)(t.palette[n].main,.4)}}})),{props:{underline:"always",color:"textPrimary"},style:{"--Link-underlineColor":t.vars?`rgba(${t.vars.palette.text.primaryChannel} / 0.4)`:(0,ur.X4)(t.palette.text.primary,.4)}},{props:{underline:"always",color:"textSecondary"},style:{"--Link-underlineColor":t.vars?`rgba(${t.vars.palette.text.secondaryChannel} / 0.4)`:(0,ur.X4)(t.palette.text.secondary,.4)}},{props:{underline:"always",color:"textDisabled"},style:{"--Link-underlineColor":(t.vars||t).palette.text.disabled}},{props:{component:"button"},style:{position:"relative",WebkitTapHighlightColor:"transparent",backgroundColor:"transparent",outline:0,border:0,margin:0,borderRadius:0,padding:0,cursor:"pointer",userSelect:"none",verticalAlign:"middle",MozAppearance:"none",WebkitAppearance:"none","&::-moz-focus-inner":{borderStyle:"none"},[`&.${Cl.focusVisible}`]:{outline:"auto"}}}]}}))),_l=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiLink"}),r=hr(),{className:a,color:s="primary",component:i="a",onBlur:o,onFocus:l,TypographyClasses:u,underline:c="always",variant:d="inherit",sx:h,...p}=n,[f,m]=T.useState(!1),g={...n,color:s,component:i,focusVisible:f,underline:c,variant:d},y=(e=>{const{classes:t,component:n,focusVisible:r,underline:a}=e,s={root:["root",`underline${(0,_r.A)(a)}`,"button"===n&&"button",r&&"focusVisible"]};return(0,lr.A)(s,Il,t)})(g);return(0,Zn.jsx)(Al,{color:s,className:(0,Wn.A)(y.root,a),classes:u,component:i,onBlur:e=>{To(e.target)||m(!1),o&&o(e)},onFocus:e=>{To(e.target)&&m(!0),l&&l(e)},ref:t,ownerState:g,variant:d,...p,sx:[...void 0===El[s]?[{color:s}]:[],...Array.isArray(h)?h:[h]],style:{...p.style,..."always"===c&&"inherit"!==s&&!El[s]&&{"--Link-underlineColor":Tl({theme:r,ownerState:g})}}})})),$l=_l;var Rl=n(4914);const Dl=()=>{const[e,t]=(0,T.useState)(!1),n=xn(),r=U((e=>e.user.generatedId));(0,T.useEffect)((()=>{r||n("/error")}),[r,n]);return r?(0,Zn.jsx)(or,{display:"flex",justifyContent:"center",alignItems:"center",minHeight:"100vh",bgcolor:"#f5f5f5",padding:3,children:(0,Zn.jsxs)(xr,{elevation:3,sx:{padding:4,borderRadius:2,maxWidth:500},children:[(0,Zn.jsx)(Pr,{variant:"h4",textAlign:"center",gutterBottom:!0,children:"Congratulations!"}),(0,Zn.jsx)(Pr,{variant:"body1",textAlign:"center",gutterBottom:!0,children:"You have been successfully registered in our system."}),(0,Zn.jsx)(Pr,{variant:"h6",textAlign:"center",gutterBottom:!0,children:"User ID:"}),(0,Zn.jsxs)(or,{display:"flex",alignItems:"center",justifyContent:"center",mb:2,children:[(0,Zn.jsx)(No,{value:r,InputProps:{readOnly:!0},sx:{width:"80%"}}),(0,Zn.jsx)(sl,{variant:"contained",color:"primary",onClick:()=>{navigator.clipboard.writeText(r),t(!0),setTimeout((()=>t(!1)),2e3)},sx:{ml:2},startIcon:(0,Zn.jsx)(Rl.A,{}),children:"Copy"})]}),e&&(0,Zn.jsx)(Sl,{severity:"success",sx:{mb:2},onClose:()=>t(!1),children:"User ID copied to clipboard!"}),(0,Zn.jsx)(Pr,{variant:"body2",textAlign:"center",children:"Kindly save this ID safely as it will be used to authenticate you."}),(0,Zn.jsxs)(Pr,{variant:"body2",textAlign:"center",children:["Want to use this ID \xa0",(0,Zn.jsx)($l,{component:"button",variant:"body2",onClick:()=>{n("/login")},children:"Click here to Login"})]})]})}):null};var Ml=n(7598),Fl=n(3860);const Ol=(0,Fl.Ay)(),Pl=(0,Kn.A)(),Ll=Ol("div",{name:"MuiContainer",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`maxWidth${(0,Ml.A)(String(n.maxWidth))}`],n.fixed&&t.fixed,n.disableGutters&&t.disableGutters]}}),zl=e=>fo({props:e,name:"MuiContainer",defaultTheme:Pl});const Bl=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{createStyledComponent:t=Ll,useThemeProps:n=zl,componentName:r="MuiContainer"}=e,a=t((e=>{let{theme:t,ownerState:n}=e;return{width:"100%",marginLeft:"auto",boxSizing:"border-box",marginRight:"auto",...!n.disableGutters&&{paddingLeft:t.spacing(2),paddingRight:t.spacing(2),[t.breakpoints.up("sm")]:{paddingLeft:t.spacing(3),paddingRight:t.spacing(3)}}}}),(e=>{let{theme:t,ownerState:n}=e;return n.fixed&&Object.keys(t.breakpoints.values).reduce(((e,n)=>{const r=n,a=t.breakpoints.values[r];return 0!==a&&(e[t.breakpoints.up(r)]={maxWidth:`${a}${t.breakpoints.unit}`}),e}),{})}),(e=>{let{theme:t,ownerState:n}=e;return{..."xs"===n.maxWidth&&{[t.breakpoints.up("xs")]:{maxWidth:Math.max(t.breakpoints.values.xs,444)}},...n.maxWidth&&"xs"!==n.maxWidth&&{[t.breakpoints.up(n.maxWidth)]:{maxWidth:`${t.breakpoints.values[n.maxWidth]}${t.breakpoints.unit}`}}}})),s=T.forwardRef((function(e,t){const s=n(e),{className:i,component:o="div",disableGutters:l=!1,fixed:u=!1,maxWidth:c="lg",classes:d,...h}=s,p={...s,component:o,disableGutters:l,fixed:u,maxWidth:c},f=((e,t)=>{const{classes:n,fixed:r,disableGutters:a,maxWidth:s}=e,i={root:["root",s&&`maxWidth${(0,Ml.A)(String(s))}`,r&&"fixed",a&&"disableGutters"]};return(0,lr.A)(i,(e=>(0,gr.Ay)(t,e)),n)})(p,r);return(0,Zn.jsx)(a,{as:o,ownerState:p,className:(0,Wn.A)(f.root,i),ref:t,...h})}));return s}({createStyledComponent:(0,cr.Ay)("div",{name:"MuiContainer",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`maxWidth${(0,_r.A)(String(n.maxWidth))}`],n.fixed&&t.fixed,n.disableGutters&&t.disableGutters]}}),useThemeProps:e=>mo({props:e,name:"MuiContainer"})}),Wl=Bl;function Vl(e){return(0,gr.Ay)("MuiDialog",e)}const Ul=(0,rr.A)("MuiDialog",["root","scrollPaper","scrollBody","container","paper","paperScrollPaper","paperScrollBody","paperWidthFalse","paperWidthXs","paperWidthSm","paperWidthMd","paperWidthLg","paperWidthXl","paperFullWidth","paperFullScreen"]);const jl=T.createContext({}),Gl=(0,cr.Ay)(di,{name:"MuiDialog",slot:"Backdrop",overrides:(e,t)=>t.backdrop})({zIndex:-1}),Hl=(0,cr.Ay)(Ci,{name:"MuiDialog",slot:"Root",overridesResolver:(e,t)=>t.root})({"@media print":{position:"absolute !important"}}),ql=(0,cr.Ay)("div",{name:"MuiDialog",slot:"Container",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.container,t[`scroll${(0,_r.A)(n.scroll)}`]]}})({height:"100%","@media print":{height:"auto"},outline:0,variants:[{props:{scroll:"paper"},style:{display:"flex",justifyContent:"center",alignItems:"center"}},{props:{scroll:"body"},style:{overflowY:"auto",overflowX:"hidden",textAlign:"center","&::after":{content:'""',display:"inline-block",verticalAlign:"middle",height:"100%",width:"0"}}}]}),Kl=(0,cr.Ay)(xr,{name:"MuiDialog",slot:"Paper",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.paper,t[`scrollPaper${(0,_r.A)(n.scroll)}`],t[`paperWidth${(0,_r.A)(String(n.maxWidth))}`],n.fullWidth&&t.paperFullWidth,n.fullScreen&&t.paperFullScreen]}})((0,pr.A)((e=>{let{theme:t}=e;return{margin:32,position:"relative","@media print":{overflowY:"visible",boxShadow:"none"},variants:[{props:{scroll:"paper"},style:{display:"flex",flexDirection:"column",maxHeight:"calc(100% - 64px)"}},{props:{scroll:"body"},style:{display:"inline-block",verticalAlign:"middle",textAlign:"initial"}},{props:e=>{let{ownerState:t}=e;return!t.maxWidth},style:{maxWidth:"calc(100% - 64px)"}},{props:{maxWidth:"xs"},style:{maxWidth:"px"===t.breakpoints.unit?Math.max(t.breakpoints.values.xs,444):`max(${t.breakpoints.values.xs}${t.breakpoints.unit}, 444px)`,[`&.${Ul.paperScrollBody}`]:{[t.breakpoints.down(Math.max(t.breakpoints.values.xs,444)+64)]:{maxWidth:"calc(100% - 64px)"}}}},...Object.keys(t.breakpoints.values).filter((e=>"xs"!==e)).map((e=>({props:{maxWidth:e},style:{maxWidth:`${t.breakpoints.values[e]}${t.breakpoints.unit}`,[`&.${Ul.paperScrollBody}`]:{[t.breakpoints.down(t.breakpoints.values[e]+64)]:{maxWidth:"calc(100% - 64px)"}}}}))),{props:e=>{let{ownerState:t}=e;return t.fullWidth},style:{width:"calc(100% - 64px)"}},{props:e=>{let{ownerState:t}=e;return t.fullScreen},style:{margin:0,width:"100%",maxWidth:"100%",height:"100%",maxHeight:"none",borderRadius:0,[`&.${Ul.paperScrollBody}`]:{margin:0,maxWidth:"100%"}}}]}}))),Xl=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiDialog"}),r=hr(),a={enter:r.transitions.duration.enteringScreen,exit:r.transitions.duration.leavingScreen},{"aria-describedby":s,"aria-labelledby":i,BackdropComponent:o,BackdropProps:l,children:u,className:c,disableEscapeKeyDown:d=!1,fullScreen:h=!1,fullWidth:p=!1,maxWidth:f="sm",onBackdropClick:m,onClick:g,onClose:y,open:b,PaperComponent:v=xr,PaperProps:x={},scroll:w="paper",TransitionComponent:k=li,transitionDuration:S=a,TransitionProps:I,...C}=n,N={...n,disableEscapeKeyDown:d,fullScreen:h,fullWidth:p,maxWidth:f,scroll:w},E=(e=>{const{classes:t,scroll:n,maxWidth:r,fullWidth:a,fullScreen:s}=e,i={root:["root"],container:["container",`scroll${(0,_r.A)(n)}`],paper:["paper",`paperScroll${(0,_r.A)(n)}`,`paperWidth${(0,_r.A)(String(r))}`,a&&"paperFullWidth",s&&"paperFullScreen"]};return(0,lr.A)(i,Vl,t)})(N),A=T.useRef(),_=(0,Lr.A)(i),$=T.useMemo((()=>({titleId:_})),[_]);return(0,Zn.jsx)(Hl,{className:(0,Wn.A)(E.root,c),closeAfterTransition:!0,components:{Backdrop:Gl},componentsProps:{backdrop:{transitionDuration:S,as:o,...l}},disableEscapeKeyDown:d,onClose:y,open:b,ref:t,onClick:e=>{g&&g(e),A.current&&(A.current=null,m&&m(e),y&&y(e,"backdropClick"))},ownerState:N,...C,children:(0,Zn.jsx)(k,{appear:!0,in:b,timeout:S,role:"presentation",...I,children:(0,Zn.jsx)(ql,{className:(0,Wn.A)(E.container),onMouseDown:e=>{A.current=e.target===e.currentTarget},ownerState:N,children:(0,Zn.jsx)(Kl,{as:v,elevation:24,role:"dialog","aria-describedby":s,"aria-labelledby":_,...x,className:(0,Wn.A)(E.paper,x.className),ownerState:N,children:(0,Zn.jsx)(jl.Provider,{value:$,children:u})})})})})}));function Yl(e){return(0,gr.Ay)("MuiDialogTitle",e)}const Ql=(0,rr.A)("MuiDialogTitle",["root"]),Jl=(0,cr.Ay)(Pr,{name:"MuiDialogTitle",slot:"Root",overridesResolver:(e,t)=>t.root})({padding:"16px 24px",flex:"0 0 auto"}),Zl=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiDialogTitle"}),{className:r,id:a,...s}=n,i=n,o=(e=>{const{classes:t}=e;return(0,lr.A)({root:["root"]},Yl,t)})(i),{titleId:l=a}=T.useContext(jl);return(0,Zn.jsx)(Jl,{component:"h2",className:(0,Wn.A)(o.root,r),ownerState:i,ref:t,variant:"h6",id:a??l,...s})}));function eu(e){return(0,gr.Ay)("MuiDialogContent",e)}(0,rr.A)("MuiDialogContent",["root","dividers"]);const tu=(0,cr.Ay)("div",{name:"MuiDialogContent",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.dividers&&t.dividers]}})((0,pr.A)((e=>{let{theme:t}=e;return{flex:"1 1 auto",WebkitOverflowScrolling:"touch",overflowY:"auto",padding:"20px 24px",variants:[{props:e=>{let{ownerState:t}=e;return t.dividers},style:{padding:"16px 24px",borderTop:`1px solid ${(t.vars||t).palette.divider}`,borderBottom:`1px solid ${(t.vars||t).palette.divider}`}},{props:e=>{let{ownerState:t}=e;return!t.dividers},style:{[`.${Ql.root} + &`]:{paddingTop:0}}}]}}))),nu=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiDialogContent"}),{className:r,dividers:a=!1,...s}=n,i={...n,dividers:a},o=(e=>{const{classes:t,dividers:n}=e,r={root:["root",n&&"dividers"]};return(0,lr.A)(r,eu,t)})(i);return(0,Zn.jsx)(tu,{className:(0,Wn.A)(o.root,r),ownerState:i,ref:t,...s})}));function ru(e){return(0,gr.Ay)("MuiDialogActions",e)}(0,rr.A)("MuiDialogActions",["root","spacing"]);const au=(0,cr.Ay)("div",{name:"MuiDialogActions",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,!n.disableSpacing&&t.spacing]}})({display:"flex",alignItems:"center",padding:8,justifyContent:"flex-end",flex:"0 0 auto",variants:[{props:e=>{let{ownerState:t}=e;return!t.disableSpacing},style:{"& > :not(style) ~ :not(style)":{marginLeft:8}}}]}),su=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiDialogActions"}),{className:r,disableSpacing:a=!1,...s}=n,i={...n,disableSpacing:a},o=(e=>{const{classes:t,disableSpacing:n}=e,r={root:["root",!n&&"spacing"]};return(0,lr.A)(r,ru,t)})(i);return(0,Zn.jsx)(au,{className:(0,Wn.A)(o.root,r),ownerState:i,ref:t,...s})}));var iu=n(3531),ou=n(7948);const lu=function(e){const t=[];let n=0;for(let r=0;r<e.length;r++){let a=e.charCodeAt(r);a<128?t[n++]=a:a<2048?(t[n++]=a>>6|192,t[n++]=63&a|128):55296===(64512&a)&&r+1<e.length&&56320===(64512&e.charCodeAt(r+1))?(a=65536+((1023&a)<<10)+(1023&e.charCodeAt(++r)),t[n++]=a>>18|240,t[n++]=a>>12&63|128,t[n++]=a>>6&63|128,t[n++]=63&a|128):(t[n++]=a>>12|224,t[n++]=a>>6&63|128,t[n++]=63&a|128)}return t},uu={byteToCharMap_:null,charToByteMap_:null,byteToCharMapWebSafe_:null,charToByteMapWebSafe_:null,ENCODED_VALS_BASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",get ENCODED_VALS(){return this.ENCODED_VALS_BASE+"+/="},get ENCODED_VALS_WEBSAFE(){return this.ENCODED_VALS_BASE+"-_."},HAS_NATIVE_SUPPORT:"function"===typeof atob,encodeByteArray(e,t){if(!Array.isArray(e))throw Error("encodeByteArray takes an array as a parameter");this.init_();const n=t?this.byteToCharMapWebSafe_:this.byteToCharMap_,r=[];for(let a=0;a<e.length;a+=3){const t=e[a],s=a+1<e.length,i=s?e[a+1]:0,o=a+2<e.length,l=o?e[a+2]:0,u=t>>2,c=(3&t)<<4|i>>4;let d=(15&i)<<2|l>>6,h=63&l;o||(h=64,s||(d=64)),r.push(n[u],n[c],n[d],n[h])}return r.join("")},encodeString(e,t){return this.HAS_NATIVE_SUPPORT&&!t?btoa(e):this.encodeByteArray(lu(e),t)},decodeString(e,t){return this.HAS_NATIVE_SUPPORT&&!t?atob(e):function(e){const t=[];let n=0,r=0;for(;n<e.length;){const a=e[n++];if(a<128)t[r++]=String.fromCharCode(a);else if(a>191&&a<224){const s=e[n++];t[r++]=String.fromCharCode((31&a)<<6|63&s)}else if(a>239&&a<365){const s=((7&a)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536;t[r++]=String.fromCharCode(55296+(s>>10)),t[r++]=String.fromCharCode(56320+(1023&s))}else{const s=e[n++],i=e[n++];t[r++]=String.fromCharCode((15&a)<<12|(63&s)<<6|63&i)}}return t.join("")}(this.decodeStringToByteArray(e,t))},decodeStringToByteArray(e,t){this.init_();const n=t?this.charToByteMapWebSafe_:this.charToByteMap_,r=[];for(let a=0;a<e.length;){const t=n[e.charAt(a++)],s=a<e.length?n[e.charAt(a)]:0;++a;const i=a<e.length?n[e.charAt(a)]:64;++a;const o=a<e.length?n[e.charAt(a)]:64;if(++a,null==t||null==s||null==i||null==o)throw new cu;const l=t<<2|s>>4;if(r.push(l),64!==i){const e=s<<4&240|i>>2;if(r.push(e),64!==o){const e=i<<6&192|o;r.push(e)}}}return r},init_(){if(!this.byteToCharMap_){this.byteToCharMap_={},this.charToByteMap_={},this.byteToCharMapWebSafe_={},this.charToByteMapWebSafe_={};for(let e=0;e<this.ENCODED_VALS.length;e++)this.byteToCharMap_[e]=this.ENCODED_VALS.charAt(e),this.charToByteMap_[this.byteToCharMap_[e]]=e,this.byteToCharMapWebSafe_[e]=this.ENCODED_VALS_WEBSAFE.charAt(e),this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]]=e,e>=this.ENCODED_VALS_BASE.length&&(this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)]=e,this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)]=e)}}};class cu extends Error{constructor(){super(...arguments),this.name="DecodeBase64StringError"}}const du=function(e){return function(e){const t=lu(e);return uu.encodeByteArray(t,!0)}(e).replace(/\./g,"")},hu=function(e){try{return uu.decodeString(e,!0)}catch(gD){console.error("base64Decode failed: ",gD)}return null};const pu=()=>function(){if("undefined"!==typeof self)return self;if("undefined"!==typeof window)return window;if("undefined"!==typeof n.g)return n.g;throw new Error("Unable to locate global object.")}().__FIREBASE_DEFAULTS__,fu=()=>{try{return pu()||(()=>{if("undefined"===typeof process)return;const e={NODE_ENV:"production",PUBLIC_URL:"",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0,REACT_APP_API_KEY:"'AIzaSyCMm9VBymR43tOkkv4wQ6szA2yGfH3j3RE';",REACT_APP_APP_ID:"1:1021363670094:web:252b1088a0266e0573c71f",REACT_APP_ENV_SENDER_ID:"1021363670094",REACT_APP_TOKEN:"d891e715-d5ab-49ee-8c4c-d14c25d7fb7a"}.__FIREBASE_DEFAULTS__;return e?JSON.parse(e):void 0})()||(()=>{if("undefined"===typeof document)return;let e;try{e=document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)}catch(gD){return}const t=e&&hu(e[1]);return t&&JSON.parse(t)})()}catch(gD){return void console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${gD}`)}},mu=e=>{const t=(e=>{var t,n;return null===(n=null===(t=fu())||void 0===t?void 0:t.emulatorHosts)||void 0===n?void 0:n[e]})(e);if(!t)return;const n=t.lastIndexOf(":");if(n<=0||n+1===t.length)throw new Error(`Invalid host ${t} with no separate hostname and port!`);const r=parseInt(t.substring(n+1),10);return"["===t[0]?[t.substring(1,n-1),r]:[t.substring(0,n),r]},gu=()=>{var e;return null===(e=fu())||void 0===e?void 0:e.config};class yu{constructor(){this.reject=()=>{},this.resolve=()=>{},this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}wrapCallback(e){return(t,n)=>{t?this.reject(t):this.resolve(n),"function"===typeof e&&(this.promise.catch((()=>{})),1===e.length?e(t):e(t,n))}}}function bu(){return"undefined"!==typeof navigator&&"string"===typeof navigator.userAgent?navigator.userAgent:""}function vu(){return!function(){var e;const t=null===(e=fu())||void 0===e?void 0:e.forceEnvironment;if("node"===t)return!0;if("browser"===t)return!1;try{return"[object process]"===Object.prototype.toString.call(n.g.process)}catch(gD){return!1}}()&&!!navigator.userAgent&&navigator.userAgent.includes("Safari")&&!navigator.userAgent.includes("Chrome")}function xu(){try{return"object"===typeof indexedDB}catch(gD){return!1}}class wu extends Error{constructor(e,t,n){super(t),this.code=e,this.customData=n,this.name="FirebaseError",Object.setPrototypeOf(this,wu.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,ku.prototype.create)}}class ku{constructor(e,t,n){this.service=e,this.serviceName=t,this.errors=n}create(e){const t=(arguments.length<=1?void 0:arguments[1])||{},n=`${this.service}/${e}`,r=this.errors[e],a=r?function(e,t){return e.replace(Su,((e,n)=>{const r=t[n];return null!=r?String(r):`<${n}?>`}))}(r,t):"Error",s=`${this.serviceName}: ${a} (${n}).`;return new wu(n,s,t)}}const Su=/\{\$([^}]+)}/g;function Iu(e,t){if(e===t)return!0;const n=Object.keys(e),r=Object.keys(t);for(const a of n){if(!r.includes(a))return!1;const n=e[a],s=t[a];if(Cu(n)&&Cu(s)){if(!Iu(n,s))return!1}else if(n!==s)return!1}for(const a of r)if(!n.includes(a))return!1;return!0}function Cu(e){return null!==e&&"object"===typeof e}function Nu(e){return e&&e._delegate?e._delegate:e}class Tu{constructor(e,t,n){this.name=e,this.instanceFactory=t,this.type=n,this.multipleInstances=!1,this.serviceProps={},this.instantiationMode="LAZY",this.onInstanceCreated=null}setInstantiationMode(e){return this.instantiationMode=e,this}setMultipleInstances(e){return this.multipleInstances=e,this}setServiceProps(e){return this.serviceProps=e,this}setInstanceCreatedCallback(e){return this.onInstanceCreated=e,this}}const Eu="[DEFAULT]";class Au{constructor(e,t){this.name=e,this.container=t,this.component=null,this.instances=new Map,this.instancesDeferred=new Map,this.instancesOptions=new Map,this.onInitCallbacks=new Map}get(e){const t=this.normalizeInstanceIdentifier(e);if(!this.instancesDeferred.has(t)){const e=new yu;if(this.instancesDeferred.set(t,e),this.isInitialized(t)||this.shouldAutoInitialize())try{const n=this.getOrInitializeService({instanceIdentifier:t});n&&e.resolve(n)}catch(gD){}}return this.instancesDeferred.get(t).promise}getImmediate(e){var t;const n=this.normalizeInstanceIdentifier(null===e||void 0===e?void 0:e.identifier),r=null!==(t=null===e||void 0===e?void 0:e.optional)&&void 0!==t&&t;if(!this.isInitialized(n)&&!this.shouldAutoInitialize()){if(r)return null;throw Error(`Service ${this.name} is not available`)}try{return this.getOrInitializeService({instanceIdentifier:n})}catch(gD){if(r)return null;throw gD}}getComponent(){return this.component}setComponent(e){if(e.name!==this.name)throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);if(this.component)throw Error(`Component for ${this.name} has already been provided`);if(this.component=e,this.shouldAutoInitialize()){if(function(e){return"EAGER"===e.instantiationMode}(e))try{this.getOrInitializeService({instanceIdentifier:Eu})}catch(gD){}for(const[e,t]of this.instancesDeferred.entries()){const n=this.normalizeInstanceIdentifier(e);try{const e=this.getOrInitializeService({instanceIdentifier:n});t.resolve(e)}catch(gD){}}}}clearInstance(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Eu;this.instancesDeferred.delete(e),this.instancesOptions.delete(e),this.instances.delete(e)}async delete(){const e=Array.from(this.instances.values());await Promise.all([...e.filter((e=>"INTERNAL"in e)).map((e=>e.INTERNAL.delete())),...e.filter((e=>"_delete"in e)).map((e=>e._delete()))])}isComponentSet(){return null!=this.component}isInitialized(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Eu;return this.instances.has(e)}getOptions(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Eu;return this.instancesOptions.get(e)||{}}initialize(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{options:t={}}=e,n=this.normalizeInstanceIdentifier(e.instanceIdentifier);if(this.isInitialized(n))throw Error(`${this.name}(${n}) has already been initialized`);if(!this.isComponentSet())throw Error(`Component ${this.name} has not been registered yet`);const r=this.getOrInitializeService({instanceIdentifier:n,options:t});for(const[a,s]of this.instancesDeferred.entries()){n===this.normalizeInstanceIdentifier(a)&&s.resolve(r)}return r}onInit(e,t){var n;const r=this.normalizeInstanceIdentifier(t),a=null!==(n=this.onInitCallbacks.get(r))&&void 0!==n?n:new Set;a.add(e),this.onInitCallbacks.set(r,a);const s=this.instances.get(r);return s&&e(s,r),()=>{a.delete(e)}}invokeOnInitCallbacks(e,t){const n=this.onInitCallbacks.get(t);if(n)for(const r of n)try{r(e,t)}catch(tL){}}getOrInitializeService(e){let{instanceIdentifier:t,options:n={}}=e,r=this.instances.get(t);if(!r&&this.component&&(r=this.component.instanceFactory(this.container,{instanceIdentifier:_u(t),options:n}),this.instances.set(t,r),this.instancesOptions.set(t,n),this.invokeOnInitCallbacks(r,t),this.component.onInstanceCreated))try{this.component.onInstanceCreated(this.container,t,r)}catch(tL){}return r||null}normalizeInstanceIdentifier(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Eu;return this.component?this.component.multipleInstances?e:Eu:e}shouldAutoInitialize(){return!!this.component&&"EXPLICIT"!==this.component.instantiationMode}}function _u(e){return e===Eu?void 0:e}class $u{constructor(e){this.name=e,this.providers=new Map}addComponent(e){const t=this.getProvider(e.name);if(t.isComponentSet())throw new Error(`Component ${e.name} has already been registered with ${this.name}`);t.setComponent(e)}addOrOverwriteComponent(e){this.getProvider(e.name).isComponentSet()&&this.providers.delete(e.name),this.addComponent(e)}getProvider(e){if(this.providers.has(e))return this.providers.get(e);const t=new Au(e,this);return this.providers.set(e,t),t}getProviders(){return Array.from(this.providers.values())}}const Ru=[];var Du;!function(e){e[e.DEBUG=0]="DEBUG",e[e.VERBOSE=1]="VERBOSE",e[e.INFO=2]="INFO",e[e.WARN=3]="WARN",e[e.ERROR=4]="ERROR",e[e.SILENT=5]="SILENT"}(Du||(Du={}));const Mu={debug:Du.DEBUG,verbose:Du.VERBOSE,info:Du.INFO,warn:Du.WARN,error:Du.ERROR,silent:Du.SILENT},Fu=Du.INFO,Ou={[Du.DEBUG]:"log",[Du.VERBOSE]:"log",[Du.INFO]:"info",[Du.WARN]:"warn",[Du.ERROR]:"error"},Pu=function(e,t){if(t<e.logLevel)return;const n=(new Date).toISOString(),r=Ou[t];if(!r)throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);for(var a=arguments.length,s=new Array(a>2?a-2:0),i=2;i<a;i++)s[i-2]=arguments[i];console[r](`[${n}]  ${e.name}:`,...s)};class Lu{constructor(e){this.name=e,this._logLevel=Fu,this._logHandler=Pu,this._userLogHandler=null,Ru.push(this)}get logLevel(){return this._logLevel}set logLevel(e){if(!(e in Du))throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);this._logLevel=e}setLogLevel(e){this._logLevel="string"===typeof e?Mu[e]:e}get logHandler(){return this._logHandler}set logHandler(e){if("function"!==typeof e)throw new TypeError("Value assigned to `logHandler` must be a function");this._logHandler=e}get userLogHandler(){return this._userLogHandler}set userLogHandler(e){this._userLogHandler=e}debug(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,Du.DEBUG,...t),this._logHandler(this,Du.DEBUG,...t)}log(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,Du.VERBOSE,...t),this._logHandler(this,Du.VERBOSE,...t)}info(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,Du.INFO,...t),this._logHandler(this,Du.INFO,...t)}warn(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,Du.WARN,...t),this._logHandler(this,Du.WARN,...t)}error(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,Du.ERROR,...t),this._logHandler(this,Du.ERROR,...t)}}const zu=(e,t)=>t.some((t=>e instanceof t));let Bu,Wu;const Vu=new WeakMap,Uu=new WeakMap,ju=new WeakMap,Gu=new WeakMap,Hu=new WeakMap;let qu={get(e,t,n){if(e instanceof IDBTransaction){if("done"===t)return Uu.get(e);if("objectStoreNames"===t)return e.objectStoreNames||ju.get(e);if("store"===t)return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return Yu(e[t])},set:(e,t,n)=>(e[t]=n,!0),has:(e,t)=>e instanceof IDBTransaction&&("done"===t||"store"===t)||t in e};function Ku(e){return e!==IDBDatabase.prototype.transaction||"objectStoreNames"in IDBTransaction.prototype?(Wu||(Wu=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(e)?function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return e.apply(Qu(this),n),Yu(Vu.get(this))}:function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return Yu(e.apply(Qu(this),n))}:function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];const s=e.call(Qu(this),t,...r);return ju.set(s,t.sort?t.sort():[t]),Yu(s)}}function Xu(e){return"function"===typeof e?Ku(e):(e instanceof IDBTransaction&&function(e){if(Uu.has(e))return;const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("complete",a),e.removeEventListener("error",s),e.removeEventListener("abort",s)},a=()=>{t(),r()},s=()=>{n(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",a),e.addEventListener("error",s),e.addEventListener("abort",s)}));Uu.set(e,t)}(e),zu(e,Bu||(Bu=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction]))?new Proxy(e,qu):e)}function Yu(e){if(e instanceof IDBRequest)return function(e){const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("success",a),e.removeEventListener("error",s)},a=()=>{t(Yu(e.result)),r()},s=()=>{n(e.error),r()};e.addEventListener("success",a),e.addEventListener("error",s)}));return t.then((t=>{t instanceof IDBCursor&&Vu.set(t,e)})).catch((()=>{})),Hu.set(t,e),t}(e);if(Gu.has(e))return Gu.get(e);const t=Xu(e);return t!==e&&(Gu.set(e,t),Hu.set(t,e)),t}const Qu=e=>Hu.get(e);const Ju=["get","getKey","getAll","getAllKeys","count"],Zu=["put","add","delete","clear"],ec=new Map;function tc(e,t){if(!(e instanceof IDBDatabase)||t in e||"string"!==typeof t)return;if(ec.get(t))return ec.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,a=Zu.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!a&&!Ju.includes(n))return;const s=async function(e){const t=this.transaction(e,a?"readwrite":"readonly");let s=t.store;for(var i=arguments.length,o=new Array(i>1?i-1:0),l=1;l<i;l++)o[l-1]=arguments[l];return r&&(s=s.index(o.shift())),(await Promise.all([s[n](...o),a&&t.done]))[0]};return ec.set(t,s),s}qu=(e=>({...e,get:(t,n,r)=>tc(t,n)||e.get(t,n,r),has:(t,n)=>!!tc(t,n)||e.has(t,n)}))(qu);class nc{constructor(e){this.container=e}getPlatformInfoString(){return this.container.getProviders().map((e=>{if(function(e){const t=e.getComponent();return"VERSION"===(null===t||void 0===t?void 0:t.type)}(e)){const t=e.getImmediate();return`${t.library}/${t.version}`}return null})).filter((e=>e)).join(" ")}}const rc="@firebase/app",ac="0.10.10",sc=new Lu("@firebase/app"),ic="@firebase/app-compat",oc="@firebase/analytics-compat",lc="@firebase/analytics",uc="@firebase/app-check-compat",cc="@firebase/app-check",dc="@firebase/auth",hc="@firebase/auth-compat",pc="@firebase/database",fc="@firebase/database-compat",mc="@firebase/functions",gc="@firebase/functions-compat",yc="@firebase/installations",bc="@firebase/installations-compat",vc="@firebase/messaging",xc="@firebase/messaging-compat",wc="@firebase/performance",kc="@firebase/performance-compat",Sc="@firebase/remote-config",Ic="@firebase/remote-config-compat",Cc="@firebase/storage",Nc="@firebase/storage-compat",Tc="@firebase/firestore",Ec="@firebase/vertexai-preview",Ac="@firebase/firestore-compat",_c="firebase",$c="[DEFAULT]",Rc={[rc]:"fire-core",[ic]:"fire-core-compat",[lc]:"fire-analytics",[oc]:"fire-analytics-compat",[cc]:"fire-app-check",[uc]:"fire-app-check-compat",[dc]:"fire-auth",[hc]:"fire-auth-compat",[pc]:"fire-rtdb",[fc]:"fire-rtdb-compat",[mc]:"fire-fn",[gc]:"fire-fn-compat",[yc]:"fire-iid",[bc]:"fire-iid-compat",[vc]:"fire-fcm",[xc]:"fire-fcm-compat",[wc]:"fire-perf",[kc]:"fire-perf-compat",[Sc]:"fire-rc",[Ic]:"fire-rc-compat",[Cc]:"fire-gcs",[Nc]:"fire-gcs-compat",[Tc]:"fire-fst",[Ac]:"fire-fst-compat",[Ec]:"fire-vertex","fire-js":"fire-js",[_c]:"fire-js-all"},Dc=new Map,Mc=new Map,Fc=new Map;function Oc(e,t){try{e.container.addComponent(t)}catch(gD){sc.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`,gD)}}function Pc(e){const t=e.name;if(Fc.has(t))return sc.debug(`There were multiple attempts to register component ${t}.`),!1;Fc.set(t,e);for(const n of Dc.values())Oc(n,e);for(const n of Mc.values())Oc(n,e);return!0}function Lc(e,t){const n=e.container.getProvider("heartbeat").getImmediate({optional:!0});return n&&n.triggerHeartbeat(),e.container.getProvider(t)}const zc=new ku("app","Firebase",{"no-app":"No Firebase App '{$appName}' has been created - call initializeApp() first","bad-app-name":"Illegal App name: '{$appName}'","duplicate-app":"Firebase App named '{$appName}' already exists with different options or config","app-deleted":"Firebase App named '{$appName}' already deleted","server-app-deleted":"Firebase Server App has been deleted","no-options":"Need to provide options, when not being deployed to hosting via source.","invalid-app-argument":"firebase.{$appName}() takes either no argument or a Firebase App instance.","invalid-log-argument":"First argument to `onLog` must be null or a function.","idb-open":"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.","idb-get":"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.","idb-set":"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.","idb-delete":"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.","finalization-registry-not-supported":"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.","invalid-server-app-environment":"FirebaseServerApp is not for use in browser environments."});class Bc{constructor(e,t,n){this._isDeleted=!1,this._options=Object.assign({},e),this._config=Object.assign({},t),this._name=t.name,this._automaticDataCollectionEnabled=t.automaticDataCollectionEnabled,this._container=n,this.container.addComponent(new Tu("app",(()=>this),"PUBLIC"))}get automaticDataCollectionEnabled(){return this.checkDestroyed(),this._automaticDataCollectionEnabled}set automaticDataCollectionEnabled(e){this.checkDestroyed(),this._automaticDataCollectionEnabled=e}get name(){return this.checkDestroyed(),this._name}get options(){return this.checkDestroyed(),this._options}get config(){return this.checkDestroyed(),this._config}get container(){return this._container}get isDeleted(){return this._isDeleted}set isDeleted(e){this._isDeleted=e}checkDestroyed(){if(this.isDeleted)throw zc.create("app-deleted",{appName:this._name})}}function Wc(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e;if("object"!==typeof t){t={name:t}}const r=Object.assign({name:$c,automaticDataCollectionEnabled:!1},t),a=r.name;if("string"!==typeof a||!a)throw zc.create("bad-app-name",{appName:String(a)});if(n||(n=gu()),!n)throw zc.create("no-options");const s=Dc.get(a);if(s){if(Iu(n,s.options)&&Iu(r,s.config))return s;throw zc.create("duplicate-app",{appName:a})}const i=new $u(a);for(const l of Fc.values())i.addComponent(l);const o=new Bc(n,r,i);return Dc.set(a,o),o}function Vc(e,t,n){var r;let a=null!==(r=Rc[e])&&void 0!==r?r:e;n&&(a+=`-${n}`);const s=a.match(/\s|\//),i=t.match(/\s|\//);if(s||i){const e=[`Unable to register library "${a}" with version "${t}":`];return s&&e.push(`library name "${a}" contains illegal characters (whitespace or "/")`),s&&i&&e.push("and"),i&&e.push(`version name "${t}" contains illegal characters (whitespace or "/")`),void sc.warn(e.join(" "))}Pc(new Tu(`${a}-version`,(()=>({library:a,version:t})),"VERSION"))}const Uc="firebase-heartbeat-database",jc=1,Gc="firebase-heartbeat-store";let Hc=null;function qc(){return Hc||(Hc=function(e,t){let{blocked:n,upgrade:r,blocking:a,terminated:s}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=indexedDB.open(e,t),o=Yu(i);return r&&i.addEventListener("upgradeneeded",(e=>{r(Yu(i.result),e.oldVersion,e.newVersion,Yu(i.transaction),e)})),n&&i.addEventListener("blocked",(e=>n(e.oldVersion,e.newVersion,e))),o.then((e=>{s&&e.addEventListener("close",(()=>s())),a&&e.addEventListener("versionchange",(e=>a(e.oldVersion,e.newVersion,e)))})).catch((()=>{})),o}(Uc,jc,{upgrade:(e,t)=>{if(0===t)try{e.createObjectStore(Gc)}catch(gD){console.warn(gD)}}}).catch((e=>{throw zc.create("idb-open",{originalErrorMessage:e.message})}))),Hc}async function Kc(e,t){try{const n=(await qc()).transaction(Gc,"readwrite"),r=n.objectStore(Gc);await r.put(t,Xc(e)),await n.done}catch(gD){if(gD instanceof wu)sc.warn(gD.message);else{const t=zc.create("idb-set",{originalErrorMessage:null===gD||void 0===gD?void 0:gD.message});sc.warn(t.message)}}}function Xc(e){return`${e.name}!${e.options.appId}`}class Yc{constructor(e){this.container=e,this._heartbeatsCache=null;const t=this.container.getProvider("app").getImmediate();this._storage=new Jc(t),this._heartbeatsCachePromise=this._storage.read().then((e=>(this._heartbeatsCache=e,e)))}async triggerHeartbeat(){var e,t;try{const n=this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),r=Qc();if(null==(null===(e=this._heartbeatsCache)||void 0===e?void 0:e.heartbeats)&&(this._heartbeatsCache=await this._heartbeatsCachePromise,null==(null===(t=this._heartbeatsCache)||void 0===t?void 0:t.heartbeats)))return;if(this._heartbeatsCache.lastSentHeartbeatDate===r||this._heartbeatsCache.heartbeats.some((e=>e.date===r)))return;return this._heartbeatsCache.heartbeats.push({date:r,agent:n}),this._heartbeatsCache.heartbeats=this._heartbeatsCache.heartbeats.filter((e=>{const t=new Date(e.date).valueOf();return Date.now()-t<=2592e6})),this._storage.overwrite(this._heartbeatsCache)}catch(gD){sc.warn(gD)}}async getHeartbeatsHeader(){var e;try{if(null===this._heartbeatsCache&&await this._heartbeatsCachePromise,null==(null===(e=this._heartbeatsCache)||void 0===e?void 0:e.heartbeats)||0===this._heartbeatsCache.heartbeats.length)return"";const t=Qc(),{heartbeatsToSend:n,unsentEntries:r}=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1024;const n=[];let r=e.slice();for(const a of e){const e=n.find((e=>e.agent===a.agent));if(e){if(e.dates.push(a.date),Zc(n)>t){e.dates.pop();break}}else if(n.push({agent:a.agent,dates:[a.date]}),Zc(n)>t){n.pop();break}r=r.slice(1)}return{heartbeatsToSend:n,unsentEntries:r}}(this._heartbeatsCache.heartbeats),a=du(JSON.stringify({version:2,heartbeats:n}));return this._heartbeatsCache.lastSentHeartbeatDate=t,r.length>0?(this._heartbeatsCache.heartbeats=r,await this._storage.overwrite(this._heartbeatsCache)):(this._heartbeatsCache.heartbeats=[],this._storage.overwrite(this._heartbeatsCache)),a}catch(gD){return sc.warn(gD),""}}}function Qc(){return(new Date).toISOString().substring(0,10)}class Jc{constructor(e){this.app=e,this._canUseIndexedDBPromise=this.runIndexedDBEnvironmentCheck()}async runIndexedDBEnvironmentCheck(){return!!xu()&&new Promise(((e,t)=>{try{let n=!0;const r="validate-browser-context-for-indexeddb-analytics-module",a=self.indexedDB.open(r);a.onsuccess=()=>{a.result.close(),n||self.indexedDB.deleteDatabase(r),e(!0)},a.onupgradeneeded=()=>{n=!1},a.onerror=()=>{var e;t((null===(e=a.error)||void 0===e?void 0:e.message)||"")}}catch(n){t(n)}})).then((()=>!0)).catch((()=>!1))}async read(){if(await this._canUseIndexedDBPromise){const e=await async function(e){try{const t=(await qc()).transaction(Gc),n=await t.objectStore(Gc).get(Xc(e));return await t.done,n}catch(gD){if(gD instanceof wu)sc.warn(gD.message);else{const t=zc.create("idb-get",{originalErrorMessage:null===gD||void 0===gD?void 0:gD.message});sc.warn(t.message)}}}(this.app);return(null===e||void 0===e?void 0:e.heartbeats)?e:{heartbeats:[]}}return{heartbeats:[]}}async overwrite(e){var t;if(await this._canUseIndexedDBPromise){const n=await this.read();return Kc(this.app,{lastSentHeartbeatDate:null!==(t=e.lastSentHeartbeatDate)&&void 0!==t?t:n.lastSentHeartbeatDate,heartbeats:e.heartbeats})}}async add(e){var t;if(await this._canUseIndexedDBPromise){const n=await this.read();return Kc(this.app,{lastSentHeartbeatDate:null!==(t=e.lastSentHeartbeatDate)&&void 0!==t?t:n.lastSentHeartbeatDate,heartbeats:[...n.heartbeats,...e.heartbeats]})}}}function Zc(e){return du(JSON.stringify({version:2,heartbeats:e})).length}var ed;ed="",Pc(new Tu("platform-logger",(e=>new nc(e)),"PRIVATE")),Pc(new Tu("heartbeat",(e=>new Yc(e)),"PRIVATE")),Vc(rc,ac,ed),Vc(rc,ac,"esm2017"),Vc("fire-js","");var td,nd,rd="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{},ad={};(function(){var e;function t(){this.blockSize=-1,this.blockSize=64,this.g=Array(4),this.B=Array(this.blockSize),this.o=this.h=0,this.s()}function n(e,t,n){n||(n=0);var r=Array(16);if("string"===typeof t)for(var a=0;16>a;++a)r[a]=t.charCodeAt(n++)|t.charCodeAt(n++)<<8|t.charCodeAt(n++)<<16|t.charCodeAt(n++)<<24;else for(a=0;16>a;++a)r[a]=t[n++]|t[n++]<<8|t[n++]<<16|t[n++]<<24;t=e.g[0],n=e.g[1],a=e.g[2];var s=e.g[3],i=t+(s^n&(a^s))+r[0]+3614090360&4294967295;i=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=n+(i<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[1]+3905402710&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[2]+606105819&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[3]+3250441966&4294967295)<<22&4294967295|i>>>10))+((i=t+(s^n&(a^s))+r[4]+4118548399&4294967295)<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[5]+1200080426&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[6]+2821735955&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[7]+4249261313&4294967295)<<22&4294967295|i>>>10))+((i=t+(s^n&(a^s))+r[8]+1770035416&4294967295)<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[9]+2336552879&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[10]+4294925233&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[11]+2304563134&4294967295)<<22&4294967295|i>>>10))+((i=t+(s^n&(a^s))+r[12]+1804603682&4294967295)<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[13]+4254626195&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[14]+2792965006&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[15]+1236535329&4294967295)<<22&4294967295|i>>>10))+((i=t+(a^s&(n^a))+r[1]+4129170786&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[6]+3225465664&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[11]+643717713&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[0]+3921069994&4294967295)<<20&4294967295|i>>>12))+((i=t+(a^s&(n^a))+r[5]+3593408605&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[10]+38016083&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[15]+3634488961&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[4]+3889429448&4294967295)<<20&4294967295|i>>>12))+((i=t+(a^s&(n^a))+r[9]+568446438&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[14]+3275163606&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[3]+4107603335&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[8]+1163531501&4294967295)<<20&4294967295|i>>>12))+((i=t+(a^s&(n^a))+r[13]+2850285829&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[2]+4243563512&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[7]+1735328473&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[12]+2368359562&4294967295)<<20&4294967295|i>>>12))+((i=t+(n^a^s)+r[5]+4294588738&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[8]+2272392833&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[11]+1839030562&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[14]+4259657740&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^a^s)+r[1]+2763975236&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[4]+1272893353&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[7]+4139469664&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[10]+3200236656&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^a^s)+r[13]+681279174&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[0]+3936430074&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[3]+3572445317&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[6]+76029189&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^a^s)+r[9]+3654602809&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[12]+3873151461&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[15]+530742520&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[2]+3299628645&4294967295)<<23&4294967295|i>>>9))+((i=t+(a^(n|~s))+r[0]+4096336452&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[7]+1126891415&4294967295)<<10&4294967295|i>>>22))+((i=a+(t^(s|~n))+r[14]+2878612391&4294967295)<<15&4294967295|i>>>17))+((i=n+(s^(a|~t))+r[5]+4237533241&4294967295)<<21&4294967295|i>>>11))+((i=t+(a^(n|~s))+r[12]+1700485571&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[3]+2399980690&4294967295)<<10&4294967295|i>>>22))+((i=a+(t^(s|~n))+r[10]+4293915773&4294967295)<<15&4294967295|i>>>17))+((i=n+(s^(a|~t))+r[1]+2240044497&4294967295)<<21&4294967295|i>>>11))+((i=t+(a^(n|~s))+r[8]+1873313359&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[15]+4264355552&4294967295)<<10&4294967295|i>>>22))+((i=a+(t^(s|~n))+r[6]+2734768916&4294967295)<<15&4294967295|i>>>17))+((i=n+(s^(a|~t))+r[13]+1309151649&4294967295)<<21&4294967295|i>>>11))+((s=(t=n+((i=t+(a^(n|~s))+r[4]+4149444226&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[11]+3174756917&4294967295)<<10&4294967295|i>>>22))^((a=s+((i=a+(t^(s|~n))+r[2]+718787259&4294967295)<<15&4294967295|i>>>17))|~t))+r[9]+3951481745&4294967295,e.g[0]=e.g[0]+t&4294967295,e.g[1]=e.g[1]+(a+(i<<21&4294967295|i>>>11))&4294967295,e.g[2]=e.g[2]+a&4294967295,e.g[3]=e.g[3]+s&4294967295}function r(e,t){this.h=t;for(var n=[],r=!0,a=e.length-1;0<=a;a--){var s=0|e[a];r&&s==t||(n[a]=s,r=!1)}this.g=n}!function(e,t){function n(){}n.prototype=t.prototype,e.D=t.prototype,e.prototype=new n,e.prototype.constructor=e,e.C=function(e,n,r){for(var a=Array(arguments.length-2),s=2;s<arguments.length;s++)a[s-2]=arguments[s];return t.prototype[n].apply(e,a)}}(t,(function(){this.blockSize=-1})),t.prototype.s=function(){this.g[0]=1732584193,this.g[1]=4023233417,this.g[2]=2562383102,this.g[3]=271733878,this.o=this.h=0},t.prototype.u=function(e,t){void 0===t&&(t=e.length);for(var r=t-this.blockSize,a=this.B,s=this.h,i=0;i<t;){if(0==s)for(;i<=r;)n(this,e,i),i+=this.blockSize;if("string"===typeof e){for(;i<t;)if(a[s++]=e.charCodeAt(i++),s==this.blockSize){n(this,a),s=0;break}}else for(;i<t;)if(a[s++]=e[i++],s==this.blockSize){n(this,a),s=0;break}}this.h=s,this.o+=t},t.prototype.v=function(){var e=Array((56>this.h?this.blockSize:2*this.blockSize)-this.h);e[0]=128;for(var t=1;t<e.length-8;++t)e[t]=0;var n=8*this.o;for(t=e.length-8;t<e.length;++t)e[t]=255&n,n/=256;for(this.u(e),e=Array(16),t=n=0;4>t;++t)for(var r=0;32>r;r+=8)e[n++]=this.g[t]>>>r&255;return e};var a={};function s(e){return-128<=e&&128>e?function(e,t){var n=a;return Object.prototype.hasOwnProperty.call(n,e)?n[e]:n[e]=t(e)}(e,(function(e){return new r([0|e],0>e?-1:0)})):new r([0|e],0>e?-1:0)}function i(e){if(isNaN(e)||!isFinite(e))return o;if(0>e)return h(i(-e));for(var t=[],n=1,a=0;e>=n;a++)t[a]=e/n|0,n*=4294967296;return new r(t,0)}var o=s(0),l=s(1),u=s(16777216);function c(e){if(0!=e.h)return!1;for(var t=0;t<e.g.length;t++)if(0!=e.g[t])return!1;return!0}function d(e){return-1==e.h}function h(e){for(var t=e.g.length,n=[],a=0;a<t;a++)n[a]=~e.g[a];return new r(n,~e.h).add(l)}function p(e,t){return e.add(h(t))}function f(e,t){for(;(65535&e[t])!=e[t];)e[t+1]+=e[t]>>>16,e[t]&=65535,t++}function m(e,t){this.g=e,this.h=t}function g(e,t){if(c(t))throw Error("division by zero");if(c(e))return new m(o,o);if(d(e))return t=g(h(e),t),new m(h(t.g),h(t.h));if(d(t))return t=g(e,h(t)),new m(h(t.g),t.h);if(30<e.g.length){if(d(e)||d(t))throw Error("slowDivide_ only works with positive integers.");for(var n=l,r=t;0>=r.l(e);)n=y(n),r=y(r);var a=b(n,1),s=b(r,1);for(r=b(r,2),n=b(n,2);!c(r);){var u=s.add(r);0>=u.l(e)&&(a=a.add(n),s=u),r=b(r,1),n=b(n,1)}return t=p(e,a.j(t)),new m(a,t)}for(a=o;0<=e.l(t);){for(n=Math.max(1,Math.floor(e.m()/t.m())),r=48>=(r=Math.ceil(Math.log(n)/Math.LN2))?1:Math.pow(2,r-48),u=(s=i(n)).j(t);d(u)||0<u.l(e);)u=(s=i(n-=r)).j(t);c(s)&&(s=l),a=a.add(s),e=p(e,u)}return new m(a,e)}function y(e){for(var t=e.g.length+1,n=[],a=0;a<t;a++)n[a]=e.i(a)<<1|e.i(a-1)>>>31;return new r(n,e.h)}function b(e,t){var n=t>>5;t%=32;for(var a=e.g.length-n,s=[],i=0;i<a;i++)s[i]=0<t?e.i(i+n)>>>t|e.i(i+n+1)<<32-t:e.i(i+n);return new r(s,e.h)}(e=r.prototype).m=function(){if(d(this))return-h(this).m();for(var e=0,t=1,n=0;n<this.g.length;n++){var r=this.i(n);e+=(0<=r?r:4294967296+r)*t,t*=4294967296}return e},e.toString=function(e){if(2>(e=e||10)||36<e)throw Error("radix out of range: "+e);if(c(this))return"0";if(d(this))return"-"+h(this).toString(e);for(var t=i(Math.pow(e,6)),n=this,r="";;){var a=g(n,t).g,s=((0<(n=p(n,a.j(t))).g.length?n.g[0]:n.h)>>>0).toString(e);if(c(n=a))return s+r;for(;6>s.length;)s="0"+s;r=s+r}},e.i=function(e){return 0>e?0:e<this.g.length?this.g[e]:this.h},e.l=function(e){return d(e=p(this,e))?-1:c(e)?0:1},e.abs=function(){return d(this)?h(this):this},e.add=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0,s=0;s<=t;s++){var i=a+(65535&this.i(s))+(65535&e.i(s)),o=(i>>>16)+(this.i(s)>>>16)+(e.i(s)>>>16);a=o>>>16,i&=65535,o&=65535,n[s]=o<<16|i}return new r(n,-2147483648&n[n.length-1]?-1:0)},e.j=function(e){if(c(this)||c(e))return o;if(d(this))return d(e)?h(this).j(h(e)):h(h(this).j(e));if(d(e))return h(this.j(h(e)));if(0>this.l(u)&&0>e.l(u))return i(this.m()*e.m());for(var t=this.g.length+e.g.length,n=[],a=0;a<2*t;a++)n[a]=0;for(a=0;a<this.g.length;a++)for(var s=0;s<e.g.length;s++){var l=this.i(a)>>>16,p=65535&this.i(a),m=e.i(s)>>>16,g=65535&e.i(s);n[2*a+2*s]+=p*g,f(n,2*a+2*s),n[2*a+2*s+1]+=l*g,f(n,2*a+2*s+1),n[2*a+2*s+1]+=p*m,f(n,2*a+2*s+1),n[2*a+2*s+2]+=l*m,f(n,2*a+2*s+2)}for(a=0;a<t;a++)n[a]=n[2*a+1]<<16|n[2*a];for(a=t;a<2*t;a++)n[a]=0;return new r(n,0)},e.A=function(e){return g(this,e).h},e.and=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0;a<t;a++)n[a]=this.i(a)&e.i(a);return new r(n,this.h&e.h)},e.or=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0;a<t;a++)n[a]=this.i(a)|e.i(a);return new r(n,this.h|e.h)},e.xor=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0;a<t;a++)n[a]=this.i(a)^e.i(a);return new r(n,this.h^e.h)},t.prototype.digest=t.prototype.v,t.prototype.reset=t.prototype.s,t.prototype.update=t.prototype.u,nd=ad.Md5=t,r.prototype.add=r.prototype.add,r.prototype.multiply=r.prototype.j,r.prototype.modulo=r.prototype.A,r.prototype.compare=r.prototype.l,r.prototype.toNumber=r.prototype.m,r.prototype.toString=r.prototype.toString,r.prototype.getBits=r.prototype.i,r.fromNumber=i,r.fromString=function e(t,n){if(0==t.length)throw Error("number format error: empty string");if(2>(n=n||10)||36<n)throw Error("radix out of range: "+n);if("-"==t.charAt(0))return h(e(t.substring(1),n));if(0<=t.indexOf("-"))throw Error('number format error: interior "-" character');for(var r=i(Math.pow(n,8)),a=o,s=0;s<t.length;s+=8){var l=Math.min(8,t.length-s),u=parseInt(t.substring(s,s+l),n);8>l?(l=i(Math.pow(n,l)),a=a.j(l).add(i(u))):a=(a=a.j(r)).add(i(u))}return a},td=ad.Integer=r}).apply("undefined"!==typeof rd?rd:"undefined"!==typeof self?self:"undefined"!==typeof window?window:{});var sd,id,od,ld,ud,cd,dd,hd,pd,fd="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{},md={};(function(){var e,t="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){return e==Array.prototype||e==Object.prototype||(e[t]=n.value),e};var n=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof fd&&fd];for(var t=0;t<e.length;++t){var n=e[t];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);!function(e,r){if(r)e:{var a=n;e=e.split(".");for(var s=0;s<e.length-1;s++){var i=e[s];if(!(i in a))break e;a=a[i]}(r=r(s=a[e=e[e.length-1]]))!=s&&null!=r&&t(a,e,{configurable:!0,writable:!0,value:r})}}("Array.prototype.values",(function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var n=0,r=!1,a={next:function(){if(!r&&n<e.length){var a=n++;return{value:t(a,e[a]),done:!1}}return r=!0,{done:!0,value:void 0}}};return a[Symbol.iterator]=function(){return a},a}(this,(function(e,t){return t}))}}));var r=r||{},a=this||self;function s(e){var t=typeof e;return"array"==(t="object"!=t?t:e?Array.isArray(e)?"array":t:"null")||"object"==t&&"number"==typeof e.length}function i(e){var t=typeof e;return"object"==t&&null!=e||"function"==t}function o(e,t,n){return e.call.apply(e.bind,arguments)}function l(e,t,n){if(!e)throw Error();if(2<arguments.length){var r=Array.prototype.slice.call(arguments,2);return function(){var n=Array.prototype.slice.call(arguments);return Array.prototype.unshift.apply(n,r),e.apply(t,n)}}return function(){return e.apply(t,arguments)}}function u(e,t,n){return(u=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?o:l).apply(null,arguments)}function c(e,t){var n=Array.prototype.slice.call(arguments,1);return function(){var t=n.slice();return t.push.apply(t,arguments),e.apply(this,t)}}function d(e,t){function n(){}n.prototype=t.prototype,e.aa=t.prototype,e.prototype=new n,e.prototype.constructor=e,e.Qb=function(e,n,r){for(var a=Array(arguments.length-2),s=2;s<arguments.length;s++)a[s-2]=arguments[s];return t.prototype[n].apply(e,a)}}function h(e){const t=e.length;if(0<t){const n=Array(t);for(let r=0;r<t;r++)n[r]=e[r];return n}return[]}function p(e,t){for(let n=1;n<arguments.length;n++){const t=arguments[n];if(s(t)){const n=e.length||0,r=t.length||0;e.length=n+r;for(let a=0;a<r;a++)e[n+a]=t[a]}else e.push(t)}}function f(e){return/^[\s\xa0]*$/.test(e)}function m(){var e=a.navigator;return e&&(e=e.userAgent)?e:""}function g(e){return g[" "](e),e}g[" "]=function(){};var y=-1!=m().indexOf("Gecko")&&!(-1!=m().toLowerCase().indexOf("webkit")&&-1==m().indexOf("Edge"))&&!(-1!=m().indexOf("Trident")||-1!=m().indexOf("MSIE"))&&-1==m().indexOf("Edge");function b(e,t,n){for(const r in e)t.call(n,e[r],r,e)}function v(e){const t={};for(const n in e)t[n]=e[n];return t}const x="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function w(e,t){let n,r;for(let a=1;a<arguments.length;a++){for(n in r=arguments[a],r)e[n]=r[n];for(let t=0;t<x.length;t++)n=x[t],Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}}function k(e){var t=1;e=e.split(":");const n=[];for(;0<t&&e.length;)n.push(e.shift()),t--;return e.length&&n.push(e.join(":")),n}function S(e){a.setTimeout((()=>{throw e}),0)}function I(){var e=A;let t=null;return e.g&&(t=e.g,e.g=e.g.next,e.g||(e.h=null),t.next=null),t}var C=new class{constructor(e,t){this.i=e,this.j=t,this.h=0,this.g=null}get(){let e;return 0<this.h?(this.h--,e=this.g,this.g=e.next,e.next=null):e=this.i(),e}}((()=>new N),(e=>e.reset()));class N{constructor(){this.next=this.g=this.h=null}set(e,t){this.h=e,this.g=t,this.next=null}reset(){this.next=this.g=this.h=null}}let T,E=!1,A=new class{constructor(){this.h=this.g=null}add(e,t){const n=C.get();n.set(e,t),this.h?this.h.next=n:this.g=n,this.h=n}},_=()=>{const e=a.Promise.resolve(void 0);T=()=>{e.then($)}};var $=()=>{for(var e;e=I();){try{e.h.call(e.g)}catch(n){S(n)}var t=C;t.j(e),100>t.h&&(t.h++,e.next=t.g,t.g=e)}E=!1};function R(){this.s=this.s,this.C=this.C}function D(e,t){this.type=e,this.g=this.target=t,this.defaultPrevented=!1}R.prototype.s=!1,R.prototype.ma=function(){this.s||(this.s=!0,this.N())},R.prototype.N=function(){if(this.C)for(;this.C.length;)this.C.shift()()},D.prototype.h=function(){this.defaultPrevented=!0};var M=function(){if(!a.addEventListener||!Object.defineProperty)return!1;var e=!1,t=Object.defineProperty({},"passive",{get:function(){e=!0}});try{const e=()=>{};a.addEventListener("test",e,t),a.removeEventListener("test",e,t)}catch(n){}return e}();function F(e,t){if(D.call(this,e?e.type:""),this.relatedTarget=this.g=this.target=null,this.button=this.screenY=this.screenX=this.clientY=this.clientX=0,this.key="",this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1,this.state=null,this.pointerId=0,this.pointerType="",this.i=null,e){var n=this.type=e.type,r=e.changedTouches&&e.changedTouches.length?e.changedTouches[0]:null;if(this.target=e.target||e.srcElement,this.g=t,t=e.relatedTarget){if(y){e:{try{g(t.nodeName);var a=!0;break e}catch(s){}a=!1}a||(t=null)}}else"mouseover"==n?t=e.fromElement:"mouseout"==n&&(t=e.toElement);this.relatedTarget=t,r?(this.clientX=void 0!==r.clientX?r.clientX:r.pageX,this.clientY=void 0!==r.clientY?r.clientY:r.pageY,this.screenX=r.screenX||0,this.screenY=r.screenY||0):(this.clientX=void 0!==e.clientX?e.clientX:e.pageX,this.clientY=void 0!==e.clientY?e.clientY:e.pageY,this.screenX=e.screenX||0,this.screenY=e.screenY||0),this.button=e.button,this.key=e.key||"",this.ctrlKey=e.ctrlKey,this.altKey=e.altKey,this.shiftKey=e.shiftKey,this.metaKey=e.metaKey,this.pointerId=e.pointerId||0,this.pointerType="string"===typeof e.pointerType?e.pointerType:O[e.pointerType]||"",this.state=e.state,this.i=e,e.defaultPrevented&&F.aa.h.call(this)}}d(F,D);var O={2:"touch",3:"pen",4:"mouse"};F.prototype.h=function(){F.aa.h.call(this);var e=this.i;e.preventDefault?e.preventDefault():e.returnValue=!1};var P="closure_listenable_"+(1e6*Math.random()|0),L=0;function z(e,t,n,r,a){this.listener=e,this.proxy=null,this.src=t,this.type=n,this.capture=!!r,this.ha=a,this.key=++L,this.da=this.fa=!1}function B(e){e.da=!0,e.listener=null,e.proxy=null,e.src=null,e.ha=null}function W(e){this.src=e,this.g={},this.h=0}function V(e,t){var n=t.type;if(n in e.g){var r,a=e.g[n],s=Array.prototype.indexOf.call(a,t,void 0);(r=0<=s)&&Array.prototype.splice.call(a,s,1),r&&(B(t),0==e.g[n].length&&(delete e.g[n],e.h--))}}function U(e,t,n,r){for(var a=0;a<e.length;++a){var s=e[a];if(!s.da&&s.listener==t&&s.capture==!!n&&s.ha==r)return a}return-1}W.prototype.add=function(e,t,n,r,a){var s=e.toString();(e=this.g[s])||(e=this.g[s]=[],this.h++);var i=U(e,t,r,a);return-1<i?(t=e[i],n||(t.fa=!1)):((t=new z(t,this.src,s,!!r,a)).fa=n,e.push(t)),t};var j="closure_lm_"+(1e6*Math.random()|0),G={};function H(e,t,n,r,a){if(r&&r.once)return K(e,t,n,r,a);if(Array.isArray(t)){for(var s=0;s<t.length;s++)H(e,t[s],n,r,a);return null}return n=te(n),e&&e[P]?e.K(t,n,i(r)?!!r.capture:!!r,a):q(e,t,n,!1,r,a)}function q(e,t,n,r,a,s){if(!t)throw Error("Invalid event type");var o=i(a)?!!a.capture:!!a,l=Z(e);if(l||(e[j]=l=new W(e)),(n=l.add(t,n,r,o,s)).proxy)return n;if(r=function(){function e(n){return t.call(e.src,e.listener,n)}const t=J;return e}(),n.proxy=r,r.src=e,r.listener=n,e.addEventListener)M||(a=o),void 0===a&&(a=!1),e.addEventListener(t.toString(),r,a);else if(e.attachEvent)e.attachEvent(Q(t.toString()),r);else{if(!e.addListener||!e.removeListener)throw Error("addEventListener and attachEvent are unavailable.");e.addListener(r)}return n}function K(e,t,n,r,a){if(Array.isArray(t)){for(var s=0;s<t.length;s++)K(e,t[s],n,r,a);return null}return n=te(n),e&&e[P]?e.L(t,n,i(r)?!!r.capture:!!r,a):q(e,t,n,!0,r,a)}function X(e,t,n,r,a){if(Array.isArray(t))for(var s=0;s<t.length;s++)X(e,t[s],n,r,a);else r=i(r)?!!r.capture:!!r,n=te(n),e&&e[P]?(e=e.i,(t=String(t).toString())in e.g&&(-1<(n=U(s=e.g[t],n,r,a))&&(B(s[n]),Array.prototype.splice.call(s,n,1),0==s.length&&(delete e.g[t],e.h--)))):e&&(e=Z(e))&&(t=e.g[t.toString()],e=-1,t&&(e=U(t,n,r,a)),(n=-1<e?t[e]:null)&&Y(n))}function Y(e){if("number"!==typeof e&&e&&!e.da){var t=e.src;if(t&&t[P])V(t.i,e);else{var n=e.type,r=e.proxy;t.removeEventListener?t.removeEventListener(n,r,e.capture):t.detachEvent?t.detachEvent(Q(n),r):t.addListener&&t.removeListener&&t.removeListener(r),(n=Z(t))?(V(n,e),0==n.h&&(n.src=null,t[j]=null)):B(e)}}}function Q(e){return e in G?G[e]:G[e]="on"+e}function J(e,t){if(e.da)e=!0;else{t=new F(t,this);var n=e.listener,r=e.ha||e.src;e.fa&&Y(e),e=n.call(r,t)}return e}function Z(e){return(e=e[j])instanceof W?e:null}var ee="__closure_events_fn_"+(1e9*Math.random()>>>0);function te(e){return"function"===typeof e?e:(e[ee]||(e[ee]=function(t){return e.handleEvent(t)}),e[ee])}function ne(){R.call(this),this.i=new W(this),this.M=this,this.F=null}function re(e,t){var n,r=e.F;if(r)for(n=[];r;r=r.F)n.push(r);if(e=e.M,r=t.type||t,"string"===typeof t)t=new D(t,e);else if(t instanceof D)t.target=t.target||e;else{var a=t;w(t=new D(r,e),a)}if(a=!0,n)for(var s=n.length-1;0<=s;s--){var i=t.g=n[s];a=ae(i,r,!0,t)&&a}if(a=ae(i=t.g=e,r,!0,t)&&a,a=ae(i,r,!1,t)&&a,n)for(s=0;s<n.length;s++)a=ae(i=t.g=n[s],r,!1,t)&&a}function ae(e,t,n,r){if(!(t=e.i.g[String(t)]))return!0;t=t.concat();for(var a=!0,s=0;s<t.length;++s){var i=t[s];if(i&&!i.da&&i.capture==n){var o=i.listener,l=i.ha||i.src;i.fa&&V(e.i,i),a=!1!==o.call(l,r)&&a}}return a&&!r.defaultPrevented}function se(e,t,n){if("function"===typeof e)n&&(e=u(e,n));else{if(!e||"function"!=typeof e.handleEvent)throw Error("Invalid listener argument");e=u(e.handleEvent,e)}return 2147483647<Number(t)?-1:a.setTimeout(e,t||0)}function ie(e){e.g=se((()=>{e.g=null,e.i&&(e.i=!1,ie(e))}),e.l);const t=e.h;e.h=null,e.m.apply(null,t)}d(ne,R),ne.prototype[P]=!0,ne.prototype.removeEventListener=function(e,t,n,r){X(this,e,t,n,r)},ne.prototype.N=function(){if(ne.aa.N.call(this),this.i){var e,t=this.i;for(e in t.g){for(var n=t.g[e],r=0;r<n.length;r++)B(n[r]);delete t.g[e],t.h--}}this.F=null},ne.prototype.K=function(e,t,n,r){return this.i.add(String(e),t,!1,n,r)},ne.prototype.L=function(e,t,n,r){return this.i.add(String(e),t,!0,n,r)};class oe extends R{constructor(e,t){super(),this.m=e,this.l=t,this.h=null,this.i=!1,this.g=null}j(e){this.h=arguments,this.g?this.i=!0:ie(this)}N(){super.N(),this.g&&(a.clearTimeout(this.g),this.g=null,this.i=!1,this.h=null)}}function le(e){R.call(this),this.h=e,this.g={}}d(le,R);var ue=[];function ce(e){b(e.g,(function(e,t){this.g.hasOwnProperty(t)&&Y(e)}),e),e.g={}}le.prototype.N=function(){le.aa.N.call(this),ce(this)},le.prototype.handleEvent=function(){throw Error("EventHandler.handleEvent not implemented")};var de=a.JSON.stringify,he=a.JSON.parse,pe=class{stringify(e){return a.JSON.stringify(e,void 0)}parse(e){return a.JSON.parse(e,void 0)}};function fe(){}function me(e){return e.h||(e.h=e.i())}function ge(){}fe.prototype.h=null;var ye={OPEN:"a",kb:"b",Ja:"c",wb:"d"};function be(){D.call(this,"d")}function ve(){D.call(this,"c")}d(be,D),d(ve,D);var xe={},we=null;function ke(){return we=we||new ne}function Se(e){D.call(this,xe.La,e)}function Ie(e){const t=ke();re(t,new Se(t))}function Ce(e,t){D.call(this,xe.STAT_EVENT,e),this.stat=t}function Ne(e){const t=ke();re(t,new Ce(t,e))}function Te(e,t){D.call(this,xe.Ma,e),this.size=t}function Ee(e,t){if("function"!==typeof e)throw Error("Fn must not be null and must be a function");return a.setTimeout((function(){e()}),t)}function Ae(){this.g=!0}function _e(e,t,n,r){e.info((function(){return"XMLHTTP TEXT ("+t+"): "+function(e,t){if(!e.g)return t;if(!t)return null;try{var n=JSON.parse(t);if(n)for(e=0;e<n.length;e++)if(Array.isArray(n[e])){var r=n[e];if(!(2>r.length)){var a=r[1];if(Array.isArray(a)&&!(1>a.length)){var s=a[0];if("noop"!=s&&"stop"!=s&&"close"!=s)for(var i=1;i<a.length;i++)a[i]=""}}}return de(n)}catch(o){return t}}(e,n)+(r?" "+r:"")}))}xe.La="serverreachability",d(Se,D),xe.STAT_EVENT="statevent",d(Ce,D),xe.Ma="timingevent",d(Te,D),Ae.prototype.xa=function(){this.g=!1},Ae.prototype.info=function(){};var $e,Re={NO_ERROR:0,gb:1,tb:2,sb:3,nb:4,rb:5,ub:6,Ia:7,TIMEOUT:8,xb:9},De={lb:"complete",Hb:"success",Ja:"error",Ia:"abort",zb:"ready",Ab:"readystatechange",TIMEOUT:"timeout",vb:"incrementaldata",yb:"progress",ob:"downloadprogress",Pb:"uploadprogress"};function Me(){}function Fe(e,t,n,r){this.j=e,this.i=t,this.l=n,this.R=r||1,this.U=new le(this),this.I=45e3,this.H=null,this.o=!1,this.m=this.A=this.v=this.L=this.F=this.S=this.B=null,this.D=[],this.g=null,this.C=0,this.s=this.u=null,this.X=-1,this.J=!1,this.O=0,this.M=null,this.W=this.K=this.T=this.P=!1,this.h=new Oe}function Oe(){this.i=null,this.g="",this.h=!1}d(Me,fe),Me.prototype.g=function(){return new XMLHttpRequest},Me.prototype.i=function(){return{}},$e=new Me;var Pe={},Le={};function ze(e,t,n){e.L=1,e.v=dt(it(t)),e.m=n,e.P=!0,Be(e,null)}function Be(e,t){e.F=Date.now(),Ue(e),e.A=it(e.v);var n=e.A,r=e.R;Array.isArray(r)||(r=[String(r)]),Ct(n.i,"t",r),e.C=0,n=e.j.J,e.h=new Oe,e.g=pn(e.j,n?t:null,!e.m),0<e.O&&(e.M=new oe(u(e.Y,e,e.g),e.O)),t=e.U,n=e.g,r=e.ca;var a="readystatechange";Array.isArray(a)||(a&&(ue[0]=a.toString()),a=ue);for(var s=0;s<a.length;s++){var i=H(n,a[s],r||t.handleEvent,!1,t.h||t);if(!i)break;t.g[i.key]=i}t=e.H?v(e.H):{},e.m?(e.u||(e.u="POST"),t["Content-Type"]="application/x-www-form-urlencoded",e.g.ea(e.A,e.u,e.m,t)):(e.u="GET",e.g.ea(e.A,e.u,null,t)),Ie(),function(e,t,n,r,a,s){e.info((function(){if(e.g)if(s)for(var i="",o=s.split("&"),l=0;l<o.length;l++){var u=o[l].split("=");if(1<u.length){var c=u[0];u=u[1];var d=c.split("_");i=2<=d.length&&"type"==d[1]?i+(c+"=")+u+"&":i+(c+"=redacted&")}}else i=null;else i=s;return"XMLHTTP REQ ("+r+") [attempt "+a+"]: "+t+"\n"+n+"\n"+i}))}(e.i,e.u,e.A,e.l,e.R,e.m)}function We(e){return!!e.g&&("GET"==e.u&&2!=e.L&&e.j.Ca)}function Ve(e,t){var n=e.C,r=t.indexOf("\n",n);return-1==r?Le:(n=Number(t.substring(n,r)),isNaN(n)?Pe:(r+=1)+n>t.length?Le:(t=t.slice(r,r+n),e.C=r+n,t))}function Ue(e){e.S=Date.now()+e.I,je(e,e.I)}function je(e,t){if(null!=e.B)throw Error("WatchDog timer not null");e.B=Ee(u(e.ba,e),t)}function Ge(e){e.B&&(a.clearTimeout(e.B),e.B=null)}function He(e){0==e.j.G||e.J||ln(e.j,e)}function qe(e){Ge(e);var t=e.M;t&&"function"==typeof t.ma&&t.ma(),e.M=null,ce(e.U),e.g&&(t=e.g,e.g=null,t.abort(),t.ma())}function Ke(e,t){try{var n=e.j;if(0!=n.G&&(n.g==e||Ze(n.h,e)))if(!e.K&&Ze(n.h,e)&&3==n.G){try{var r=n.Da.g.parse(t)}catch(c){r=null}if(Array.isArray(r)&&3==r.length){var a=r;if(0==a[0]){e:if(!n.u){if(n.g){if(!(n.g.F+3e3<e.F))break e;on(n),Yt(n)}rn(n),Ne(18)}}else n.za=a[1],0<n.za-n.T&&37500>a[2]&&n.F&&0==n.v&&!n.C&&(n.C=Ee(u(n.Za,n),6e3));if(1>=Je(n.h)&&n.ca){try{n.ca()}catch(c){}n.ca=void 0}}else cn(n,11)}else if((e.K||n.g==e)&&on(n),!f(t))for(a=n.Da.g.parse(t),t=0;t<a.length;t++){let u=a[t];if(n.T=u[0],u=u[1],2==n.G)if("c"==u[0]){n.K=u[1],n.ia=u[2];const t=u[3];null!=t&&(n.la=t,n.j.info("VER="+n.la));const a=u[4];null!=a&&(n.Aa=a,n.j.info("SVER="+n.Aa));const c=u[5];null!=c&&"number"===typeof c&&0<c&&(r=1.5*c,n.L=r,n.j.info("backChannelRequestTimeoutMs_="+r)),r=n;const d=e.g;if(d){const e=d.g?d.g.getResponseHeader("X-Client-Wire-Protocol"):null;if(e){var s=r.h;s.g||-1==e.indexOf("spdy")&&-1==e.indexOf("quic")&&-1==e.indexOf("h2")||(s.j=s.l,s.g=new Set,s.h&&(et(s,s.h),s.h=null))}if(r.D){const e=d.g?d.g.getResponseHeader("X-HTTP-Session-Id"):null;e&&(r.ya=e,ct(r.I,r.D,e))}}n.G=3,n.l&&n.l.ua(),n.ba&&(n.R=Date.now()-e.F,n.j.info("Handshake RTT: "+n.R+"ms"));var i=e;if((r=n).qa=hn(r,r.J?r.ia:null,r.W),i.K){tt(r.h,i);var o=i,l=r.L;l&&(o.I=l),o.B&&(Ge(o),Ue(o)),r.g=i}else nn(r);0<n.i.length&&Jt(n)}else"stop"!=u[0]&&"close"!=u[0]||cn(n,7);else 3==n.G&&("stop"==u[0]||"close"==u[0]?"stop"==u[0]?cn(n,7):Xt(n):"noop"!=u[0]&&n.l&&n.l.ta(u),n.v=0)}Ie()}catch(c){}}Fe.prototype.ca=function(e){e=e.target;const t=this.M;t&&3==Gt(e)?t.j():this.Y(e)},Fe.prototype.Y=function(e){try{if(e==this.g)e:{const h=Gt(this.g);var t=this.g.Ba();this.g.Z();if(!(3>h)&&(3!=h||this.g&&(this.h.h||this.g.oa()||Ht(this.g)))){this.J||4!=h||7==t||Ie(),Ge(this);var n=this.g.Z();this.X=n;t:if(We(this)){var r=Ht(this.g);e="";var s=r.length,i=4==Gt(this.g);if(!this.h.i){if("undefined"===typeof TextDecoder){qe(this),He(this);var o="";break t}this.h.i=new a.TextDecoder}for(t=0;t<s;t++)this.h.h=!0,e+=this.h.i.decode(r[t],{stream:!(i&&t==s-1)});r.length=0,this.h.g+=e,this.C=0,o=this.h.g}else o=this.g.oa();if(this.o=200==n,function(e,t,n,r,a,s,i){e.info((function(){return"XMLHTTP RESP ("+r+") [ attempt "+a+"]: "+t+"\n"+n+"\n"+s+" "+i}))}(this.i,this.u,this.A,this.l,this.R,h,n),this.o){if(this.T&&!this.K){t:{if(this.g){var l,u=this.g;if((l=u.g?u.g.getResponseHeader("X-HTTP-Initial-Response"):null)&&!f(l)){var c=l;break t}}c=null}if(!(n=c)){this.o=!1,this.s=3,Ne(12),qe(this),He(this);break e}_e(this.i,this.l,n,"Initial handshake response via X-HTTP-Initial-Response"),this.K=!0,Ke(this,n)}if(this.P){let e;for(n=!0;!this.J&&this.C<o.length;){if(e=Ve(this,o),e==Le){4==h&&(this.s=4,Ne(14),n=!1),_e(this.i,this.l,null,"[Incomplete Response]");break}if(e==Pe){this.s=4,Ne(15),_e(this.i,this.l,o,"[Invalid Chunk]"),n=!1;break}_e(this.i,this.l,e,null),Ke(this,e)}if(We(this)&&0!=this.C&&(this.h.g=this.h.g.slice(this.C),this.C=0),4!=h||0!=o.length||this.h.h||(this.s=1,Ne(16),n=!1),this.o=this.o&&n,n){if(0<o.length&&!this.W){this.W=!0;var d=this.j;d.g==this&&d.ba&&!d.M&&(d.j.info("Great, no buffering proxy detected. Bytes received: "+o.length),an(d),d.M=!0,Ne(11))}}else _e(this.i,this.l,o,"[Invalid Chunked Response]"),qe(this),He(this)}else _e(this.i,this.l,o,null),Ke(this,o);4==h&&qe(this),this.o&&!this.J&&(4==h?ln(this.j,this):(this.o=!1,Ue(this)))}else(function(e){const t={};e=(e.g&&2<=Gt(e)&&e.g.getAllResponseHeaders()||"").split("\r\n");for(let r=0;r<e.length;r++){if(f(e[r]))continue;var n=k(e[r]);const a=n[0];if("string"!==typeof(n=n[1]))continue;n=n.trim();const s=t[a]||[];t[a]=s,s.push(n)}!function(e,t){for(const n in e)t.call(void 0,e[n],n,e)}(t,(function(e){return e.join(", ")}))})(this.g),400==n&&0<o.indexOf("Unknown SID")?(this.s=3,Ne(12)):(this.s=0,Ne(13)),qe(this),He(this)}}}catch(ER){}},Fe.prototype.cancel=function(){this.J=!0,qe(this)},Fe.prototype.ba=function(){this.B=null;const e=Date.now();0<=e-this.S?(function(e,t){e.info((function(){return"TIMEOUT: "+t}))}(this.i,this.A),2!=this.L&&(Ie(),Ne(17)),qe(this),this.s=2,He(this)):je(this,this.S-e)};var Xe=class{constructor(e,t){this.g=e,this.map=t}};function Ye(e){this.l=e||10,a.PerformanceNavigationTiming?e=0<(e=a.performance.getEntriesByType("navigation")).length&&("hq"==e[0].nextHopProtocol||"h2"==e[0].nextHopProtocol):e=!!(a.chrome&&a.chrome.loadTimes&&a.chrome.loadTimes()&&a.chrome.loadTimes().wasFetchedViaSpdy),this.j=e?this.l:1,this.g=null,1<this.j&&(this.g=new Set),this.h=null,this.i=[]}function Qe(e){return!!e.h||!!e.g&&e.g.size>=e.j}function Je(e){return e.h?1:e.g?e.g.size:0}function Ze(e,t){return e.h?e.h==t:!!e.g&&e.g.has(t)}function et(e,t){e.g?e.g.add(t):e.h=t}function tt(e,t){e.h&&e.h==t?e.h=null:e.g&&e.g.has(t)&&e.g.delete(t)}function nt(e){if(null!=e.h)return e.i.concat(e.h.D);if(null!=e.g&&0!==e.g.size){let t=e.i;for(const n of e.g.values())t=t.concat(n.D);return t}return h(e.i)}function rt(e,t){if(e.forEach&&"function"==typeof e.forEach)e.forEach(t,void 0);else if(s(e)||"string"===typeof e)Array.prototype.forEach.call(e,t,void 0);else for(var n=function(e){if(e.na&&"function"==typeof e.na)return e.na();if(!e.V||"function"!=typeof e.V){if("undefined"!==typeof Map&&e instanceof Map)return Array.from(e.keys());if(!("undefined"!==typeof Set&&e instanceof Set)){if(s(e)||"string"===typeof e){var t=[];e=e.length;for(var n=0;n<e;n++)t.push(n);return t}t=[],n=0;for(const r in e)t[n++]=r;return t}}}(e),r=function(e){if(e.V&&"function"==typeof e.V)return e.V();if("undefined"!==typeof Map&&e instanceof Map||"undefined"!==typeof Set&&e instanceof Set)return Array.from(e.values());if("string"===typeof e)return e.split("");if(s(e)){for(var t=[],n=e.length,r=0;r<n;r++)t.push(e[r]);return t}for(r in t=[],n=0,e)t[n++]=e[r];return t}(e),a=r.length,i=0;i<a;i++)t.call(void 0,r[i],n&&n[i],e)}Ye.prototype.cancel=function(){if(this.i=nt(this),this.h)this.h.cancel(),this.h=null;else if(this.g&&0!==this.g.size){for(const e of this.g.values())e.cancel();this.g.clear()}};var at=RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");function st(e){if(this.g=this.o=this.j="",this.s=null,this.m=this.l="",this.h=!1,e instanceof st){this.h=e.h,ot(this,e.j),this.o=e.o,this.g=e.g,lt(this,e.s),this.l=e.l;var t=e.i,n=new wt;n.i=t.i,t.g&&(n.g=new Map(t.g),n.h=t.h),ut(this,n),this.m=e.m}else e&&(t=String(e).match(at))?(this.h=!1,ot(this,t[1]||"",!0),this.o=ht(t[2]||""),this.g=ht(t[3]||"",!0),lt(this,t[4]),this.l=ht(t[5]||"",!0),ut(this,t[6]||"",!0),this.m=ht(t[7]||"")):(this.h=!1,this.i=new wt(null,this.h))}function it(e){return new st(e)}function ot(e,t,n){e.j=n?ht(t,!0):t,e.j&&(e.j=e.j.replace(/:$/,""))}function lt(e,t){if(t){if(t=Number(t),isNaN(t)||0>t)throw Error("Bad port number "+t);e.s=t}else e.s=null}function ut(e,t,n){t instanceof wt?(e.i=t,function(e,t){t&&!e.j&&(kt(e),e.i=null,e.g.forEach((function(e,t){var n=t.toLowerCase();t!=n&&(St(this,t),Ct(this,n,e))}),e)),e.j=t}(e.i,e.h)):(n||(t=pt(t,vt)),e.i=new wt(t,e.h))}function ct(e,t,n){e.i.set(t,n)}function dt(e){return ct(e,"zx",Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^Date.now()).toString(36)),e}function ht(e,t){return e?t?decodeURI(e.replace(/%25/g,"%2525")):decodeURIComponent(e):""}function pt(e,t,n){return"string"===typeof e?(e=encodeURI(e).replace(t,ft),n&&(e=e.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),e):null}function ft(e){return"%"+((e=e.charCodeAt(0))>>4&15).toString(16)+(15&e).toString(16)}st.prototype.toString=function(){var e=[],t=this.j;t&&e.push(pt(t,gt,!0),":");var n=this.g;return(n||"file"==t)&&(e.push("//"),(t=this.o)&&e.push(pt(t,gt,!0),"@"),e.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),null!=(n=this.s)&&e.push(":",String(n))),(n=this.l)&&(this.g&&"/"!=n.charAt(0)&&e.push("/"),e.push(pt(n,"/"==n.charAt(0)?bt:yt,!0))),(n=this.i.toString())&&e.push("?",n),(n=this.m)&&e.push("#",pt(n,xt)),e.join("")};var mt,gt=/[#\/\?@]/g,yt=/[#\?:]/g,bt=/[#\?]/g,vt=/[#\?@]/g,xt=/#/g;function wt(e,t){this.h=this.g=null,this.i=e||null,this.j=!!t}function kt(e){e.g||(e.g=new Map,e.h=0,e.i&&function(e,t){if(e){e=e.split("&");for(var n=0;n<e.length;n++){var r=e[n].indexOf("="),a=null;if(0<=r){var s=e[n].substring(0,r);a=e[n].substring(r+1)}else s=e[n];t(s,a?decodeURIComponent(a.replace(/\+/g," ")):"")}}}(e.i,(function(t,n){e.add(decodeURIComponent(t.replace(/\+/g," ")),n)})))}function St(e,t){kt(e),t=Nt(e,t),e.g.has(t)&&(e.i=null,e.h-=e.g.get(t).length,e.g.delete(t))}function It(e,t){return kt(e),t=Nt(e,t),e.g.has(t)}function Ct(e,t,n){St(e,t),0<n.length&&(e.i=null,e.g.set(Nt(e,t),h(n)),e.h+=n.length)}function Nt(e,t){return t=String(t),e.j&&(t=t.toLowerCase()),t}function Tt(e,t,n,r,a){try{a&&(a.onload=null,a.onerror=null,a.onabort=null,a.ontimeout=null),r(n)}catch(s){}}function Et(){this.g=new pe}function At(e,t,n){const r=n||"";try{rt(e,(function(e,n){let a=e;i(e)&&(a=de(e)),t.push(r+n+"="+encodeURIComponent(a))}))}catch(gD){throw t.push(r+"type="+encodeURIComponent("_badmap")),gD}}function _t(e){this.l=e.Ub||null,this.j=e.eb||!1}function $t(e,t){ne.call(this),this.D=e,this.o=t,this.m=void 0,this.status=this.readyState=0,this.responseType=this.responseText=this.response=this.statusText="",this.onreadystatechange=null,this.u=new Headers,this.h=null,this.B="GET",this.A="",this.g=!1,this.v=this.j=this.l=null}function Rt(e){e.j.read().then(e.Pa.bind(e)).catch(e.ga.bind(e))}function Dt(e){e.readyState=4,e.l=null,e.j=null,e.v=null,Mt(e)}function Mt(e){e.onreadystatechange&&e.onreadystatechange.call(e)}function Ft(e){let t="";return b(e,(function(e,n){t+=n,t+=":",t+=e,t+="\r\n"})),t}function Ot(e,t,n){e:{for(r in n){var r=!1;break e}r=!0}r||(n=Ft(n),"string"===typeof e?null!=n&&encodeURIComponent(String(n)):ct(e,t,n))}function Pt(e){ne.call(this),this.headers=new Map,this.o=e||null,this.h=!1,this.v=this.g=null,this.D="",this.m=0,this.l="",this.j=this.B=this.u=this.A=!1,this.I=null,this.H="",this.J=!1}(e=wt.prototype).add=function(e,t){kt(this),this.i=null,e=Nt(this,e);var n=this.g.get(e);return n||this.g.set(e,n=[]),n.push(t),this.h+=1,this},e.forEach=function(e,t){kt(this),this.g.forEach((function(n,r){n.forEach((function(n){e.call(t,n,r,this)}),this)}),this)},e.na=function(){kt(this);const e=Array.from(this.g.values()),t=Array.from(this.g.keys()),n=[];for(let r=0;r<t.length;r++){const a=e[r];for(let e=0;e<a.length;e++)n.push(t[r])}return n},e.V=function(e){kt(this);let t=[];if("string"===typeof e)It(this,e)&&(t=t.concat(this.g.get(Nt(this,e))));else{e=Array.from(this.g.values());for(let n=0;n<e.length;n++)t=t.concat(e[n])}return t},e.set=function(e,t){return kt(this),this.i=null,It(this,e=Nt(this,e))&&(this.h-=this.g.get(e).length),this.g.set(e,[t]),this.h+=1,this},e.get=function(e,t){return e&&0<(e=this.V(e)).length?String(e[0]):t},e.toString=function(){if(this.i)return this.i;if(!this.g)return"";const e=[],t=Array.from(this.g.keys());for(var n=0;n<t.length;n++){var r=t[n];const s=encodeURIComponent(String(r)),i=this.V(r);for(r=0;r<i.length;r++){var a=s;""!==i[r]&&(a+="="+encodeURIComponent(String(i[r]))),e.push(a)}}return this.i=e.join("&")},d(_t,fe),_t.prototype.g=function(){return new $t(this.l,this.j)},_t.prototype.i=(mt={},function(){return mt}),d($t,ne),(e=$t.prototype).open=function(e,t){if(0!=this.readyState)throw this.abort(),Error("Error reopening a connection");this.B=e,this.A=t,this.readyState=1,Mt(this)},e.send=function(e){if(1!=this.readyState)throw this.abort(),Error("need to call open() first. ");this.g=!0;const t={headers:this.u,method:this.B,credentials:this.m,cache:void 0};e&&(t.body=e),(this.D||a).fetch(new Request(this.A,t)).then(this.Sa.bind(this),this.ga.bind(this))},e.abort=function(){this.response=this.responseText="",this.u=new Headers,this.status=0,this.j&&this.j.cancel("Request was aborted.").catch((()=>{})),1<=this.readyState&&this.g&&4!=this.readyState&&(this.g=!1,Dt(this)),this.readyState=0},e.Sa=function(e){if(this.g&&(this.l=e,this.h||(this.status=this.l.status,this.statusText=this.l.statusText,this.h=e.headers,this.readyState=2,Mt(this)),this.g&&(this.readyState=3,Mt(this),this.g)))if("arraybuffer"===this.responseType)e.arrayBuffer().then(this.Qa.bind(this),this.ga.bind(this));else if("undefined"!==typeof a.ReadableStream&&"body"in e){if(this.j=e.body.getReader(),this.o){if(this.responseType)throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');this.response=[]}else this.response=this.responseText="",this.v=new TextDecoder;Rt(this)}else e.text().then(this.Ra.bind(this),this.ga.bind(this))},e.Pa=function(e){if(this.g){if(this.o&&e.value)this.response.push(e.value);else if(!this.o){var t=e.value?e.value:new Uint8Array(0);(t=this.v.decode(t,{stream:!e.done}))&&(this.response=this.responseText+=t)}e.done?Dt(this):Mt(this),3==this.readyState&&Rt(this)}},e.Ra=function(e){this.g&&(this.response=this.responseText=e,Dt(this))},e.Qa=function(e){this.g&&(this.response=e,Dt(this))},e.ga=function(){this.g&&Dt(this)},e.setRequestHeader=function(e,t){this.u.append(e,t)},e.getResponseHeader=function(e){return this.h&&this.h.get(e.toLowerCase())||""},e.getAllResponseHeaders=function(){if(!this.h)return"";const e=[],t=this.h.entries();for(var n=t.next();!n.done;)n=n.value,e.push(n[0]+": "+n[1]),n=t.next();return e.join("\r\n")},Object.defineProperty($t.prototype,"withCredentials",{get:function(){return"include"===this.m},set:function(e){this.m=e?"include":"same-origin"}}),d(Pt,ne);var Lt=/^https?$/i,zt=["POST","PUT"];function Bt(e,t){e.h=!1,e.g&&(e.j=!0,e.g.abort(),e.j=!1),e.l=t,e.m=5,Wt(e),Ut(e)}function Wt(e){e.A||(e.A=!0,re(e,"complete"),re(e,"error"))}function Vt(e){if(e.h&&"undefined"!=typeof r&&(!e.v[1]||4!=Gt(e)||2!=e.Z()))if(e.u&&4==Gt(e))se(e.Ea,0,e);else if(re(e,"readystatechange"),4==Gt(e)){e.h=!1;try{const r=e.Z();e:switch(r){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var t=!0;break e;default:t=!1}var n;if(!(n=t)){var s;if(s=0===r){var i=String(e.D).match(at)[1]||null;!i&&a.self&&a.self.location&&(i=a.self.location.protocol.slice(0,-1)),s=!Lt.test(i?i.toLowerCase():"")}n=s}if(n)re(e,"complete"),re(e,"success");else{e.m=6;try{var o=2<Gt(e)?e.g.statusText:""}catch(l){o=""}e.l=o+" ["+e.Z()+"]",Wt(e)}}finally{Ut(e)}}}function Ut(e,t){if(e.g){jt(e);const n=e.g,r=e.v[0]?()=>{}:null;e.g=null,e.v=null,t||re(e,"ready");try{n.onreadystatechange=r}catch(gD){}}}function jt(e){e.I&&(a.clearTimeout(e.I),e.I=null)}function Gt(e){return e.g?e.g.readyState:0}function Ht(e){try{if(!e.g)return null;if("response"in e.g)return e.g.response;switch(e.H){case"":case"text":return e.g.responseText;case"arraybuffer":if("mozResponseArrayBuffer"in e.g)return e.g.mozResponseArrayBuffer}return null}catch(bd){return null}}function qt(e,t,n){return n&&n.internalChannelParams&&n.internalChannelParams[e]||t}function Kt(e){this.Aa=0,this.i=[],this.j=new Ae,this.ia=this.qa=this.I=this.W=this.g=this.ya=this.D=this.H=this.m=this.S=this.o=null,this.Ya=this.U=0,this.Va=qt("failFast",!1,e),this.F=this.C=this.u=this.s=this.l=null,this.X=!0,this.za=this.T=-1,this.Y=this.v=this.B=0,this.Ta=qt("baseRetryDelayMs",5e3,e),this.cb=qt("retryDelaySeedMs",1e4,e),this.Wa=qt("forwardChannelMaxRetries",2,e),this.wa=qt("forwardChannelRequestTimeoutMs",2e4,e),this.pa=e&&e.xmlHttpFactory||void 0,this.Xa=e&&e.Tb||void 0,this.Ca=e&&e.useFetchStreams||!1,this.L=void 0,this.J=e&&e.supportsCrossDomainXhr||!1,this.K="",this.h=new Ye(e&&e.concurrentRequestLimit),this.Da=new Et,this.P=e&&e.fastHandshake||!1,this.O=e&&e.encodeInitMessageHeaders||!1,this.P&&this.O&&(this.O=!1),this.Ua=e&&e.Rb||!1,e&&e.xa&&this.j.xa(),e&&e.forceLongPolling&&(this.X=!1),this.ba=!this.P&&this.X&&e&&e.detectBufferingProxy||!1,this.ja=void 0,e&&e.longPollingTimeout&&0<e.longPollingTimeout&&(this.ja=e.longPollingTimeout),this.ca=void 0,this.R=0,this.M=!1,this.ka=this.A=null}function Xt(e){if(Qt(e),3==e.G){var t=e.U++,n=it(e.I);if(ct(n,"SID",e.K),ct(n,"RID",t),ct(n,"TYPE","terminate"),en(e,n),(t=new Fe(e,e.j,t)).L=2,t.v=dt(it(n)),n=!1,a.navigator&&a.navigator.sendBeacon)try{n=a.navigator.sendBeacon(t.v.toString(),"")}catch(r){}!n&&a.Image&&((new Image).src=t.v,n=!0),n||(t.g=pn(t.j,null),t.g.ea(t.v)),t.F=Date.now(),Ue(t)}dn(e)}function Yt(e){e.g&&(an(e),e.g.cancel(),e.g=null)}function Qt(e){Yt(e),e.u&&(a.clearTimeout(e.u),e.u=null),on(e),e.h.cancel(),e.s&&("number"===typeof e.s&&a.clearTimeout(e.s),e.s=null)}function Jt(e){if(!Qe(e.h)&&!e.s){e.s=!0;var t=e.Ga;T||_(),E||(T(),E=!0),A.add(t,e),e.B=0}}function Zt(e,t){var n;n=t?t.l:e.U++;const r=it(e.I);ct(r,"SID",e.K),ct(r,"RID",n),ct(r,"AID",e.T),en(e,r),e.m&&e.o&&Ot(r,e.m,e.o),n=new Fe(e,e.j,n,e.B+1),null===e.m&&(n.H=e.o),t&&(e.i=t.D.concat(e.i)),t=tn(e,n,1e3),n.I=Math.round(.5*e.wa)+Math.round(.5*e.wa*Math.random()),et(e.h,n),ze(n,r,t)}function en(e,t){e.H&&b(e.H,(function(e,n){ct(t,n,e)})),e.l&&rt({},(function(e,n){ct(t,n,e)}))}function tn(e,t,n){n=Math.min(e.i.length,n);var r=e.l?u(e.l.Na,e.l,e):null;e:{var a=e.i;let t=-1;for(;;){const e=["count="+n];-1==t?0<n?(t=a[0].g,e.push("ofs="+t)):t=0:e.push("ofs="+t);let s=!0;for(let i=0;i<n;i++){let n=a[i].g;const o=a[i].map;if(n-=t,0>n)t=Math.max(0,a[i].g-100),s=!1;else try{At(o,e,"req"+n+"_")}catch(ER){r&&r(o)}}if(s){r=e.join("&");break e}}}return e=e.i.splice(0,n),t.D=e,r}function nn(e){if(!e.g&&!e.u){e.Y=1;var t=e.Fa;T||_(),E||(T(),E=!0),A.add(t,e),e.v=0}}function rn(e){return!(e.g||e.u||3<=e.v)&&(e.Y++,e.u=Ee(u(e.Fa,e),un(e,e.v)),e.v++,!0)}function an(e){null!=e.A&&(a.clearTimeout(e.A),e.A=null)}function sn(e){e.g=new Fe(e,e.j,"rpc",e.Y),null===e.m&&(e.g.H=e.o),e.g.O=0;var t=it(e.qa);ct(t,"RID","rpc"),ct(t,"SID",e.K),ct(t,"AID",e.T),ct(t,"CI",e.F?"0":"1"),!e.F&&e.ja&&ct(t,"TO",e.ja),ct(t,"TYPE","xmlhttp"),en(e,t),e.m&&e.o&&Ot(t,e.m,e.o),e.L&&(e.g.I=e.L);var n=e.g;e=e.ia,n.L=1,n.v=dt(it(t)),n.m=null,n.P=!0,Be(n,e)}function on(e){null!=e.C&&(a.clearTimeout(e.C),e.C=null)}function ln(e,t){var n=null;if(e.g==t){on(e),an(e),e.g=null;var r=2}else{if(!Ze(e.h,t))return;n=t.D,tt(e.h,t),r=1}if(0!=e.G)if(t.o)if(1==r){n=t.m?t.m.length:0,t=Date.now()-t.F;var a=e.B;re(r=ke(),new Te(r,n)),Jt(e)}else nn(e);else if(3==(a=t.s)||0==a&&0<t.X||!(1==r&&function(e,t){return!(Je(e.h)>=e.h.j-(e.s?1:0))&&(e.s?(e.i=t.D.concat(e.i),!0):!(1==e.G||2==e.G||e.B>=(e.Va?0:e.Wa))&&(e.s=Ee(u(e.Ga,e,t),un(e,e.B)),e.B++,!0))}(e,t)||2==r&&rn(e)))switch(n&&0<n.length&&(t=e.h,t.i=t.i.concat(n)),a){case 1:cn(e,5);break;case 4:cn(e,10);break;case 3:cn(e,6);break;default:cn(e,2)}}function un(e,t){let n=e.Ta+Math.floor(Math.random()*e.cb);return e.isActive()||(n*=2),n*t}function cn(e,t){if(e.j.info("Error code "+t),2==t){var n=u(e.fb,e),r=e.Xa;const t=!r;r=new st(r||"//www.google.com/images/cleardot.gif"),a.location&&"http"==a.location.protocol||ot(r,"https"),dt(r),t?function(e,t){const n=new Ae;if(a.Image){const r=new Image;r.onload=c(Tt,n,"TestLoadImage: loaded",!0,t,r),r.onerror=c(Tt,n,"TestLoadImage: error",!1,t,r),r.onabort=c(Tt,n,"TestLoadImage: abort",!1,t,r),r.ontimeout=c(Tt,n,"TestLoadImage: timeout",!1,t,r),a.setTimeout((function(){r.ontimeout&&r.ontimeout()}),1e4),r.src=e}else t(!1)}(r.toString(),n):function(e,t){new Ae;const n=new AbortController,r=setTimeout((()=>{n.abort(),Tt(0,0,!1,t)}),1e4);fetch(e,{signal:n.signal}).then((e=>{clearTimeout(r),e.ok?Tt(0,0,!0,t):Tt(0,0,!1,t)})).catch((()=>{clearTimeout(r),Tt(0,0,!1,t)}))}(r.toString(),n)}else Ne(2);e.G=0,e.l&&e.l.sa(t),dn(e),Qt(e)}function dn(e){if(e.G=0,e.ka=[],e.l){const t=nt(e.h);0==t.length&&0==e.i.length||(p(e.ka,t),p(e.ka,e.i),e.h.i.length=0,h(e.i),e.i.length=0),e.l.ra()}}function hn(e,t,n){var r=n instanceof st?it(n):new st(n);if(""!=r.g)t&&(r.g=t+"."+r.g),lt(r,r.s);else{var s=a.location;r=s.protocol,t=t?t+"."+s.hostname:s.hostname,s=+s.port;var i=new st(null);r&&ot(i,r),t&&(i.g=t),s&&lt(i,s),n&&(i.l=n),r=i}return n=e.D,t=e.ya,n&&t&&ct(r,n,t),ct(r,"VER",e.la),en(e,r),r}function pn(e,t,n){if(t&&!e.J)throw Error("Can't create secondary domain capable XhrIo object.");return(t=e.Ca&&!e.pa?new Pt(new _t({eb:n})):new Pt(e.pa)).Ha(e.J),t}function fn(){}function mn(){}function gn(e,t){ne.call(this),this.g=new Kt(t),this.l=e,this.h=t&&t.messageUrlParams||null,e=t&&t.messageHeaders||null,t&&t.clientProtocolHeaderRequired&&(e?e["X-Client-Protocol"]="webchannel":e={"X-Client-Protocol":"webchannel"}),this.g.o=e,e=t&&t.initMessageHeaders||null,t&&t.messageContentType&&(e?e["X-WebChannel-Content-Type"]=t.messageContentType:e={"X-WebChannel-Content-Type":t.messageContentType}),t&&t.va&&(e?e["X-WebChannel-Client-Profile"]=t.va:e={"X-WebChannel-Client-Profile":t.va}),this.g.S=e,(e=t&&t.Sb)&&!f(e)&&(this.g.m=e),this.v=t&&t.supportsCrossDomainXhr||!1,this.u=t&&t.sendRawJson||!1,(t=t&&t.httpSessionIdParam)&&!f(t)&&(this.g.D=t,null!==(e=this.h)&&t in e&&(t in(e=this.h)&&delete e[t])),this.j=new vn(this)}function yn(e){be.call(this),e.__headers__&&(this.headers=e.__headers__,this.statusCode=e.__status__,delete e.__headers__,delete e.__status__);var t=e.__sm__;if(t){e:{for(const n in t){e=n;break e}e=void 0}(this.i=e)&&(e=this.i,t=null!==t&&e in t?t[e]:void 0),this.data=t}else this.data=e}function bn(){ve.call(this),this.status=1}function vn(e){this.g=e}(e=Pt.prototype).Ha=function(e){this.J=e},e.ea=function(e,t,n,r){if(this.g)throw Error("[goog.net.XhrIo] Object is active with another request="+this.D+"; newUri="+e);t=t?t.toUpperCase():"GET",this.D=e,this.l="",this.m=0,this.A=!1,this.h=!0,this.g=this.o?this.o.g():$e.g(),this.v=this.o?me(this.o):me($e),this.g.onreadystatechange=u(this.Ea,this);try{this.B=!0,this.g.open(t,String(e),!0),this.B=!1}catch(i){return void Bt(this,i)}if(e=n||"",n=new Map(this.headers),r)if(Object.getPrototypeOf(r)===Object.prototype)for(var s in r)n.set(s,r[s]);else{if("function"!==typeof r.keys||"function"!==typeof r.get)throw Error("Unknown input type for opt_headers: "+String(r));for(const e of r.keys())n.set(e,r.get(e))}r=Array.from(n.keys()).find((e=>"content-type"==e.toLowerCase())),s=a.FormData&&e instanceof a.FormData,!(0<=Array.prototype.indexOf.call(zt,t,void 0))||r||s||n.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");for(const[a,o]of n)this.g.setRequestHeader(a,o);this.H&&(this.g.responseType=this.H),"withCredentials"in this.g&&this.g.withCredentials!==this.J&&(this.g.withCredentials=this.J);try{jt(this),this.u=!0,this.g.send(e),this.u=!1}catch(i){Bt(this,i)}},e.abort=function(e){this.g&&this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1,this.m=e||7,re(this,"complete"),re(this,"abort"),Ut(this))},e.N=function(){this.g&&(this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1),Ut(this,!0)),Pt.aa.N.call(this)},e.Ea=function(){this.s||(this.B||this.u||this.j?Vt(this):this.bb())},e.bb=function(){Vt(this)},e.isActive=function(){return!!this.g},e.Z=function(){try{return 2<Gt(this)?this.g.status:-1}catch(mt){return-1}},e.oa=function(){try{return this.g?this.g.responseText:""}catch(mt){return""}},e.Oa=function(e){if(this.g){var t=this.g.responseText;return e&&0==t.indexOf(e)&&(t=t.substring(e.length)),he(t)}},e.Ba=function(){return this.m},e.Ka=function(){return"string"===typeof this.l?this.l:String(this.l)},(e=Kt.prototype).la=8,e.G=1,e.connect=function(e,t,n,r){Ne(0),this.W=e,this.H=t||{},n&&void 0!==r&&(this.H.OSID=n,this.H.OAID=r),this.F=this.X,this.I=hn(this,null,this.W),Jt(this)},e.Ga=function(e){if(this.s)if(this.s=null,1==this.G){if(!e){this.U=Math.floor(1e5*Math.random()),e=this.U++;const a=new Fe(this,this.j,e);let s=this.o;if(this.S&&(s?(s=v(s),w(s,this.S)):s=this.S),null!==this.m||this.O||(a.H=s,s=null),this.P)e:{for(var t=0,n=0;n<this.i.length;n++){var r=this.i[n];if(void 0===(r="__data__"in r.map&&"string"===typeof(r=r.map.__data__)?r.length:void 0))break;if(4096<(t+=r)){t=n;break e}if(4096===t||n===this.i.length-1){t=n+1;break e}}t=1e3}else t=1e3;t=tn(this,a,t),ct(n=it(this.I),"RID",e),ct(n,"CVER",22),this.D&&ct(n,"X-HTTP-Session-Id",this.D),en(this,n),s&&(this.O?t="headers="+encodeURIComponent(String(Ft(s)))+"&"+t:this.m&&Ot(n,this.m,s)),et(this.h,a),this.Ua&&ct(n,"TYPE","init"),this.P?(ct(n,"$req",t),ct(n,"SID","null"),a.T=!0,ze(a,n,null)):ze(a,n,t),this.G=2}}else 3==this.G&&(e?Zt(this,e):0==this.i.length||Qe(this.h)||Zt(this))},e.Fa=function(){if(this.u=null,sn(this),this.ba&&!(this.M||null==this.g||0>=this.R)){var e=2*this.R;this.j.info("BP detection timer enabled: "+e),this.A=Ee(u(this.ab,this),e)}},e.ab=function(){this.A&&(this.A=null,this.j.info("BP detection timeout reached."),this.j.info("Buffering proxy detected and switch to long-polling!"),this.F=!1,this.M=!0,Ne(10),Yt(this),sn(this))},e.Za=function(){null!=this.C&&(this.C=null,Yt(this),rn(this),Ne(19))},e.fb=function(e){e?(this.j.info("Successfully pinged google.com"),Ne(2)):(this.j.info("Failed to ping google.com"),Ne(1))},e.isActive=function(){return!!this.l&&this.l.isActive(this)},(e=fn.prototype).ua=function(){},e.ta=function(){},e.sa=function(){},e.ra=function(){},e.isActive=function(){return!0},e.Na=function(){},mn.prototype.g=function(e,t){return new gn(e,t)},d(gn,ne),gn.prototype.m=function(){this.g.l=this.j,this.v&&(this.g.J=!0),this.g.connect(this.l,this.h||void 0)},gn.prototype.close=function(){Xt(this.g)},gn.prototype.o=function(e){var t=this.g;if("string"===typeof e){var n={};n.__data__=e,e=n}else this.u&&((n={}).__data__=de(e),e=n);t.i.push(new Xe(t.Ya++,e)),3==t.G&&Jt(t)},gn.prototype.N=function(){this.g.l=null,delete this.j,Xt(this.g),delete this.g,gn.aa.N.call(this)},d(yn,be),d(bn,ve),d(vn,fn),vn.prototype.ua=function(){re(this.g,"a")},vn.prototype.ta=function(e){re(this.g,new yn(e))},vn.prototype.sa=function(e){re(this.g,new bn)},vn.prototype.ra=function(){re(this.g,"b")},mn.prototype.createWebChannel=mn.prototype.g,gn.prototype.send=gn.prototype.o,gn.prototype.open=gn.prototype.m,gn.prototype.close=gn.prototype.close,pd=md.createWebChannelTransport=function(){return new mn},hd=md.getStatEventTarget=function(){return ke()},dd=md.Event=xe,cd=md.Stat={mb:0,pb:1,qb:2,Jb:3,Ob:4,Lb:5,Mb:6,Kb:7,Ib:8,Nb:9,PROXY:10,NOPROXY:11,Gb:12,Cb:13,Db:14,Bb:15,Eb:16,Fb:17,ib:18,hb:19,jb:20},Re.NO_ERROR=0,Re.TIMEOUT=8,Re.HTTP_ERROR=6,ud=md.ErrorCode=Re,De.COMPLETE="complete",ld=md.EventType=De,ge.EventType=ye,ye.OPEN="a",ye.CLOSE="b",ye.ERROR="c",ye.MESSAGE="d",ne.prototype.listen=ne.prototype.K,od=md.WebChannel=ge,id=md.FetchXmlHttpFactory=_t,Pt.prototype.listenOnce=Pt.prototype.L,Pt.prototype.getLastError=Pt.prototype.Ka,Pt.prototype.getLastErrorCode=Pt.prototype.Ba,Pt.prototype.getStatus=Pt.prototype.Z,Pt.prototype.getResponseJson=Pt.prototype.Oa,Pt.prototype.getResponseText=Pt.prototype.oa,Pt.prototype.send=Pt.prototype.ea,Pt.prototype.setWithCredentials=Pt.prototype.Ha,sd=md.XhrIo=Pt}).apply("undefined"!==typeof fd?fd:"undefined"!==typeof self?self:"undefined"!==typeof window?window:{});const gd="@firebase/firestore";class yd{constructor(e){this.uid=e}isAuthenticated(){return null!=this.uid}toKey(){return this.isAuthenticated()?"uid:"+this.uid:"anonymous-user"}isEqual(e){return e.uid===this.uid}}yd.UNAUTHENTICATED=new yd(null),yd.GOOGLE_CREDENTIALS=new yd("google-credentials-uid"),yd.FIRST_PARTY=new yd("first-party-uid"),yd.MOCK_USER=new yd("mock-user");let bd="10.13.1";const vd=new Lu("@firebase/firestore");function xd(){return vd.logLevel}function wd(e){if(vd.logLevel<=Du.DEBUG){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(Id);vd.debug(`Firestore (${bd}): ${e}`,...a)}}function kd(e){if(vd.logLevel<=Du.ERROR){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(Id);vd.error(`Firestore (${bd}): ${e}`,...a)}}function Sd(e){if(vd.logLevel<=Du.WARN){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(Id);vd.warn(`Firestore (${bd}): ${e}`,...a)}}function Id(e){if("string"==typeof e)return e;try{return function(e){return JSON.stringify(e)}(e)}catch(t){return e}}function Cd(){const e=`FIRESTORE (${bd}) INTERNAL ASSERTION FAILED: `+(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Unexpected state");throw kd(e),new Error(e)}function Nd(e,t){e||Cd()}function Td(e,t){return e}const Ed={OK:"ok",CANCELLED:"cancelled",UNKNOWN:"unknown",INVALID_ARGUMENT:"invalid-argument",DEADLINE_EXCEEDED:"deadline-exceeded",NOT_FOUND:"not-found",ALREADY_EXISTS:"already-exists",PERMISSION_DENIED:"permission-denied",UNAUTHENTICATED:"unauthenticated",RESOURCE_EXHAUSTED:"resource-exhausted",FAILED_PRECONDITION:"failed-precondition",ABORTED:"aborted",OUT_OF_RANGE:"out-of-range",UNIMPLEMENTED:"unimplemented",INTERNAL:"internal",UNAVAILABLE:"unavailable",DATA_LOSS:"data-loss"};class Ad extends wu{constructor(e,t){super(e,t),this.code=e,this.message=t,this.toString=()=>`${this.name}: [code=${this.code}]: ${this.message}`}}class _d{constructor(){this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}}class $d{constructor(e,t){this.user=t,this.type="OAuth",this.headers=new Map,this.headers.set("Authorization",`Bearer ${e}`)}}class Rd{getToken(){return Promise.resolve(null)}invalidateToken(){}start(e,t){e.enqueueRetryable((()=>t(yd.UNAUTHENTICATED)))}shutdown(){}}class Dd{constructor(e){this.token=e,this.changeListener=null}getToken(){return Promise.resolve(this.token)}invalidateToken(){}start(e,t){this.changeListener=t,e.enqueueRetryable((()=>t(this.token.user)))}shutdown(){this.changeListener=null}}class Md{constructor(e){this.t=e,this.currentUser=yd.UNAUTHENTICATED,this.i=0,this.forceRefresh=!1,this.auth=null}start(e,t){let n=this.i;const r=e=>this.i!==n?(n=this.i,t(e)):Promise.resolve();let a=new _d;this.o=()=>{this.i++,this.currentUser=this.u(),a.resolve(),a=new _d,e.enqueueRetryable((()=>r(this.currentUser)))};const s=()=>{const t=a;e.enqueueRetryable((async()=>{await t.promise,await r(this.currentUser)}))},i=e=>{wd("FirebaseAuthCredentialsProvider","Auth detected"),this.auth=e,this.auth.addAuthTokenListener(this.o),s()};this.t.onInit((e=>i(e))),setTimeout((()=>{if(!this.auth){const e=this.t.getImmediate({optional:!0});e?i(e):(wd("FirebaseAuthCredentialsProvider","Auth not yet detected"),a.resolve(),a=new _d)}}),0),s()}getToken(){const e=this.i,t=this.forceRefresh;return this.forceRefresh=!1,this.auth?this.auth.getToken(t).then((t=>this.i!==e?(wd("FirebaseAuthCredentialsProvider","getToken aborted due to token change."),this.getToken()):t?(Nd("string"==typeof t.accessToken),new $d(t.accessToken,this.currentUser)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.auth&&this.auth.removeAuthTokenListener(this.o)}u(){const e=this.auth&&this.auth.getUid();return Nd(null===e||"string"==typeof e),new yd(e)}}class Fd{constructor(e,t,n){this.l=e,this.h=t,this.P=n,this.type="FirstParty",this.user=yd.FIRST_PARTY,this.I=new Map}T(){return this.P?this.P():null}get headers(){this.I.set("X-Goog-AuthUser",this.l);const e=this.T();return e&&this.I.set("Authorization",e),this.h&&this.I.set("X-Goog-Iam-Authorization-Token",this.h),this.I}}class Od{constructor(e,t,n){this.l=e,this.h=t,this.P=n}getToken(){return Promise.resolve(new Fd(this.l,this.h,this.P))}start(e,t){e.enqueueRetryable((()=>t(yd.FIRST_PARTY)))}shutdown(){}invalidateToken(){}}class Pd{constructor(e){this.value=e,this.type="AppCheck",this.headers=new Map,e&&e.length>0&&this.headers.set("x-firebase-appcheck",this.value)}}class Ld{constructor(e){this.A=e,this.forceRefresh=!1,this.appCheck=null,this.R=null}start(e,t){const n=e=>{null!=e.error&&wd("FirebaseAppCheckTokenProvider",`Error getting App Check token; using placeholder token instead. Error: ${e.error.message}`);const n=e.token!==this.R;return this.R=e.token,wd("FirebaseAppCheckTokenProvider",`Received ${n?"new":"existing"} token.`),n?t(e.token):Promise.resolve()};this.o=t=>{e.enqueueRetryable((()=>n(t)))};const r=e=>{wd("FirebaseAppCheckTokenProvider","AppCheck detected"),this.appCheck=e,this.appCheck.addTokenListener(this.o)};this.A.onInit((e=>r(e))),setTimeout((()=>{if(!this.appCheck){const e=this.A.getImmediate({optional:!0});e?r(e):wd("FirebaseAppCheckTokenProvider","AppCheck not yet detected")}}),0)}getToken(){const e=this.forceRefresh;return this.forceRefresh=!1,this.appCheck?this.appCheck.getToken(e).then((e=>e?(Nd("string"==typeof e.token),this.R=e.token,new Pd(e.token)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.appCheck&&this.appCheck.removeTokenListener(this.o)}}function zd(e){const t="undefined"!=typeof self&&(self.crypto||self.msCrypto),n=new Uint8Array(e);if(t&&"function"==typeof t.getRandomValues)t.getRandomValues(n);else for(let r=0;r<e;r++)n[r]=Math.floor(256*Math.random());return n}class Bd{static newId(){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",t=62*Math.floor(256/62);let n="";for(;n.length<20;){const r=zd(40);for(let a=0;a<r.length;++a)n.length<20&&r[a]<t&&(n+=e.charAt(r[a]%62))}return n}}function Wd(e,t){return e<t?-1:e>t?1:0}function Vd(e,t,n){return e.length===t.length&&e.every(((e,r)=>n(e,t[r])))}class Ud{constructor(e,t){if(this.seconds=e,this.nanoseconds=t,t<0)throw new Ad(Ed.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+t);if(t>=1e9)throw new Ad(Ed.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+t);if(e<-62135596800)throw new Ad(Ed.INVALID_ARGUMENT,"Timestamp seconds out of range: "+e);if(e>=253402300800)throw new Ad(Ed.INVALID_ARGUMENT,"Timestamp seconds out of range: "+e)}static now(){return Ud.fromMillis(Date.now())}static fromDate(e){return Ud.fromMillis(e.getTime())}static fromMillis(e){const t=Math.floor(e/1e3),n=Math.floor(1e6*(e-1e3*t));return new Ud(t,n)}toDate(){return new Date(this.toMillis())}toMillis(){return 1e3*this.seconds+this.nanoseconds/1e6}_compareTo(e){return this.seconds===e.seconds?Wd(this.nanoseconds,e.nanoseconds):Wd(this.seconds,e.seconds)}isEqual(e){return e.seconds===this.seconds&&e.nanoseconds===this.nanoseconds}toString(){return"Timestamp(seconds="+this.seconds+", nanoseconds="+this.nanoseconds+")"}toJSON(){return{seconds:this.seconds,nanoseconds:this.nanoseconds}}valueOf(){const e=this.seconds- -62135596800;return String(e).padStart(12,"0")+"."+String(this.nanoseconds).padStart(9,"0")}}class jd{constructor(e){this.timestamp=e}static fromTimestamp(e){return new jd(e)}static min(){return new jd(new Ud(0,0))}static max(){return new jd(new Ud(253402300799,999999999))}compareTo(e){return this.timestamp._compareTo(e.timestamp)}isEqual(e){return this.timestamp.isEqual(e.timestamp)}toMicroseconds(){return 1e6*this.timestamp.seconds+this.timestamp.nanoseconds/1e3}toString(){return"SnapshotVersion("+this.timestamp.toString()+")"}toTimestamp(){return this.timestamp}}class Gd{constructor(e,t,n){void 0===t?t=0:t>e.length&&Cd(),void 0===n?n=e.length-t:n>e.length-t&&Cd(),this.segments=e,this.offset=t,this.len=n}get length(){return this.len}isEqual(e){return 0===Gd.comparator(this,e)}child(e){const t=this.segments.slice(this.offset,this.limit());return e instanceof Gd?e.forEach((e=>{t.push(e)})):t.push(e),this.construct(t)}limit(){return this.offset+this.length}popFirst(e){return e=void 0===e?1:e,this.construct(this.segments,this.offset+e,this.length-e)}popLast(){return this.construct(this.segments,this.offset,this.length-1)}firstSegment(){return this.segments[this.offset]}lastSegment(){return this.get(this.length-1)}get(e){return this.segments[this.offset+e]}isEmpty(){return 0===this.length}isPrefixOf(e){if(e.length<this.length)return!1;for(let t=0;t<this.length;t++)if(this.get(t)!==e.get(t))return!1;return!0}isImmediateParentOf(e){if(this.length+1!==e.length)return!1;for(let t=0;t<this.length;t++)if(this.get(t)!==e.get(t))return!1;return!0}forEach(e){for(let t=this.offset,n=this.limit();t<n;t++)e(this.segments[t])}toArray(){return this.segments.slice(this.offset,this.limit())}static comparator(e,t){const n=Math.min(e.length,t.length);for(let r=0;r<n;r++){const n=e.get(r),a=t.get(r);if(n<a)return-1;if(n>a)return 1}return e.length<t.length?-1:e.length>t.length?1:0}}class Hd extends Gd{construct(e,t,n){return new Hd(e,t,n)}canonicalString(){return this.toArray().join("/")}toString(){return this.canonicalString()}toUriEncodedString(){return this.toArray().map(encodeURIComponent).join("/")}static fromString(){const e=[];for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const a of n){if(a.indexOf("//")>=0)throw new Ad(Ed.INVALID_ARGUMENT,`Invalid segment (${a}). Paths must not contain // in them.`);e.push(...a.split("/").filter((e=>e.length>0)))}return new Hd(e)}static emptyPath(){return new Hd([])}}const qd=/^[_a-zA-Z][_a-zA-Z0-9]*$/;class Kd extends Gd{construct(e,t,n){return new Kd(e,t,n)}static isValidIdentifier(e){return qd.test(e)}canonicalString(){return this.toArray().map((e=>(e=e.replace(/\\/g,"\\\\").replace(/`/g,"\\`"),Kd.isValidIdentifier(e)||(e="`"+e+"`"),e))).join(".")}toString(){return this.canonicalString()}isKeyField(){return 1===this.length&&"__name__"===this.get(0)}static keyField(){return new Kd(["__name__"])}static fromServerFormat(e){const t=[];let n="",r=0;const a=()=>{if(0===n.length)throw new Ad(Ed.INVALID_ARGUMENT,`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);t.push(n),n=""};let s=!1;for(;r<e.length;){const t=e[r];if("\\"===t){if(r+1===e.length)throw new Ad(Ed.INVALID_ARGUMENT,"Path has trailing escape character: "+e);const t=e[r+1];if("\\"!==t&&"."!==t&&"`"!==t)throw new Ad(Ed.INVALID_ARGUMENT,"Path has invalid escape sequence: "+e);n+=t,r+=2}else"`"===t?(s=!s,r++):"."!==t||s?(n+=t,r++):(a(),r++)}if(a(),s)throw new Ad(Ed.INVALID_ARGUMENT,"Unterminated ` in path: "+e);return new Kd(t)}static emptyPath(){return new Kd([])}}class Xd{constructor(e){this.path=e}static fromPath(e){return new Xd(Hd.fromString(e))}static fromName(e){return new Xd(Hd.fromString(e).popFirst(5))}static empty(){return new Xd(Hd.emptyPath())}get collectionGroup(){return this.path.popLast().lastSegment()}hasCollectionId(e){return this.path.length>=2&&this.path.get(this.path.length-2)===e}getCollectionGroup(){return this.path.get(this.path.length-2)}getCollectionPath(){return this.path.popLast()}isEqual(e){return null!==e&&0===Hd.comparator(this.path,e.path)}toString(){return this.path.toString()}static comparator(e,t){return Hd.comparator(e.path,t.path)}static isDocumentKey(e){return e.length%2==0}static fromSegments(e){return new Xd(new Hd(e.slice()))}}class Yd{constructor(e,t,n,r){this.indexId=e,this.collectionGroup=t,this.fields=n,this.indexState=r}}Yd.UNKNOWN_ID=-1;function Qd(e,t){const n=e.toTimestamp().seconds,r=e.toTimestamp().nanoseconds+1,a=jd.fromTimestamp(1e9===r?new Ud(n+1,0):new Ud(n,r));return new Zd(a,Xd.empty(),t)}function Jd(e){return new Zd(e.readTime,e.key,-1)}class Zd{constructor(e,t,n){this.readTime=e,this.documentKey=t,this.largestBatchId=n}static min(){return new Zd(jd.min(),Xd.empty(),-1)}static max(){return new Zd(jd.max(),Xd.empty(),-1)}}function eh(e,t){let n=e.readTime.compareTo(t.readTime);return 0!==n?n:(n=Xd.comparator(e.documentKey,t.documentKey),0!==n?n:Wd(e.largestBatchId,t.largestBatchId))}const th="The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";class nh{constructor(){this.onCommittedListeners=[]}addOnCommittedListener(e){this.onCommittedListeners.push(e)}raiseOnCommittedEvent(){this.onCommittedListeners.forEach((e=>e()))}}async function rh(e){if(e.code!==Ed.FAILED_PRECONDITION||e.message!==th)throw e;wd("LocalStore","Unexpectedly lost primary lease")}class ah{constructor(e){this.nextCallback=null,this.catchCallback=null,this.result=void 0,this.error=void 0,this.isDone=!1,this.callbackAttached=!1,e((e=>{this.isDone=!0,this.result=e,this.nextCallback&&this.nextCallback(e)}),(e=>{this.isDone=!0,this.error=e,this.catchCallback&&this.catchCallback(e)}))}catch(e){return this.next(void 0,e)}next(e,t){return this.callbackAttached&&Cd(),this.callbackAttached=!0,this.isDone?this.error?this.wrapFailure(t,this.error):this.wrapSuccess(e,this.result):new ah(((n,r)=>{this.nextCallback=t=>{this.wrapSuccess(e,t).next(n,r)},this.catchCallback=e=>{this.wrapFailure(t,e).next(n,r)}}))}toPromise(){return new Promise(((e,t)=>{this.next(e,t)}))}wrapUserFunction(e){try{const t=e();return t instanceof ah?t:ah.resolve(t)}catch(e){return ah.reject(e)}}wrapSuccess(e,t){return e?this.wrapUserFunction((()=>e(t))):ah.resolve(t)}wrapFailure(e,t){return e?this.wrapUserFunction((()=>e(t))):ah.reject(t)}static resolve(e){return new ah(((t,n)=>{t(e)}))}static reject(e){return new ah(((t,n)=>{n(e)}))}static waitFor(e){return new ah(((t,n)=>{let r=0,a=0,s=!1;e.forEach((e=>{++r,e.next((()=>{++a,s&&a===r&&t()}),(e=>n(e)))})),s=!0,a===r&&t()}))}static or(e){let t=ah.resolve(!1);for(const n of e)t=t.next((e=>e?ah.resolve(e):n()));return t}static forEach(e,t){const n=[];return e.forEach(((e,r)=>{n.push(t.call(this,e,r))})),this.waitFor(n)}static mapArray(e,t){return new ah(((n,r)=>{const a=e.length,s=new Array(a);let i=0;for(let o=0;o<a;o++){const l=o;t(e[l]).next((e=>{s[l]=e,++i,i===a&&n(s)}),(e=>r(e)))}}))}static doWhile(e,t){return new ah(((n,r)=>{const a=()=>{!0===e()?t().next((()=>{a()}),r):n()};a()}))}}function sh(e){const t=e.match(/Android ([\d.]+)/i),n=t?t[1].split(".").slice(0,2).join("."):"-1";return Number(n)}function ih(e){return"IndexedDbTransactionError"===e.name}class oh{constructor(e,t){this.previousValue=e,t&&(t.sequenceNumberHandler=e=>this.ie(e),this.se=e=>t.writeSequenceNumber(e))}ie(e){return this.previousValue=Math.max(e,this.previousValue),this.previousValue}next(){const e=++this.previousValue;return this.se&&this.se(e),e}}function lh(e){return null==e}function uh(e){return 0===e&&1/e==-1/0}function ch(e){return"number"==typeof e&&Number.isInteger(e)&&!uh(e)&&e<=Number.MAX_SAFE_INTEGER&&e>=Number.MIN_SAFE_INTEGER}oh.oe=-1;const dh=["mutationQueues","mutations","documentMutations","remoteDocuments","targets","owner","targetGlobal","targetDocuments","clientMetadata","remoteDocumentGlobal","collectionParents","bundles","namedQueries"],hh=["mutationQueues","mutations","documentMutations","remoteDocumentsV14","targets","owner","targetGlobal","targetDocuments","clientMetadata","remoteDocumentGlobal","collectionParents","bundles","namedQueries","documentOverlays"],ph=hh,fh=[...ph,"indexConfiguration","indexState","indexEntries"];function mh(e){let t=0;for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t++;return t}function gh(e,t){for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t(n,e[n])}function yh(e){for(const t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!1;return!0}class bh{constructor(e,t){this.comparator=e,this.root=t||xh.EMPTY}insert(e,t){return new bh(this.comparator,this.root.insert(e,t,this.comparator).copy(null,null,xh.BLACK,null,null))}remove(e){return new bh(this.comparator,this.root.remove(e,this.comparator).copy(null,null,xh.BLACK,null,null))}get(e){let t=this.root;for(;!t.isEmpty();){const n=this.comparator(e,t.key);if(0===n)return t.value;n<0?t=t.left:n>0&&(t=t.right)}return null}indexOf(e){let t=0,n=this.root;for(;!n.isEmpty();){const r=this.comparator(e,n.key);if(0===r)return t+n.left.size;r<0?n=n.left:(t+=n.left.size+1,n=n.right)}return-1}isEmpty(){return this.root.isEmpty()}get size(){return this.root.size}minKey(){return this.root.minKey()}maxKey(){return this.root.maxKey()}inorderTraversal(e){return this.root.inorderTraversal(e)}forEach(e){this.inorderTraversal(((t,n)=>(e(t,n),!1)))}toString(){const e=[];return this.inorderTraversal(((t,n)=>(e.push(`${t}:${n}`),!1))),`{${e.join(", ")}}`}reverseTraversal(e){return this.root.reverseTraversal(e)}getIterator(){return new vh(this.root,null,this.comparator,!1)}getIteratorFrom(e){return new vh(this.root,e,this.comparator,!1)}getReverseIterator(){return new vh(this.root,null,this.comparator,!0)}getReverseIteratorFrom(e){return new vh(this.root,e,this.comparator,!0)}}class vh{constructor(e,t,n,r){this.isReverse=r,this.nodeStack=[];let a=1;for(;!e.isEmpty();)if(a=t?n(e.key,t):1,t&&r&&(a*=-1),a<0)e=this.isReverse?e.left:e.right;else{if(0===a){this.nodeStack.push(e);break}this.nodeStack.push(e),e=this.isReverse?e.right:e.left}}getNext(){let e=this.nodeStack.pop();const t={key:e.key,value:e.value};if(this.isReverse)for(e=e.left;!e.isEmpty();)this.nodeStack.push(e),e=e.right;else for(e=e.right;!e.isEmpty();)this.nodeStack.push(e),e=e.left;return t}hasNext(){return this.nodeStack.length>0}peek(){if(0===this.nodeStack.length)return null;const e=this.nodeStack[this.nodeStack.length-1];return{key:e.key,value:e.value}}}class xh{constructor(e,t,n,r,a){this.key=e,this.value=t,this.color=null!=n?n:xh.RED,this.left=null!=r?r:xh.EMPTY,this.right=null!=a?a:xh.EMPTY,this.size=this.left.size+1+this.right.size}copy(e,t,n,r,a){return new xh(null!=e?e:this.key,null!=t?t:this.value,null!=n?n:this.color,null!=r?r:this.left,null!=a?a:this.right)}isEmpty(){return!1}inorderTraversal(e){return this.left.inorderTraversal(e)||e(this.key,this.value)||this.right.inorderTraversal(e)}reverseTraversal(e){return this.right.reverseTraversal(e)||e(this.key,this.value)||this.left.reverseTraversal(e)}min(){return this.left.isEmpty()?this:this.left.min()}minKey(){return this.min().key}maxKey(){return this.right.isEmpty()?this.key:this.right.maxKey()}insert(e,t,n){let r=this;const a=n(e,r.key);return r=a<0?r.copy(null,null,null,r.left.insert(e,t,n),null):0===a?r.copy(null,t,null,null,null):r.copy(null,null,null,null,r.right.insert(e,t,n)),r.fixUp()}removeMin(){if(this.left.isEmpty())return xh.EMPTY;let e=this;return e.left.isRed()||e.left.left.isRed()||(e=e.moveRedLeft()),e=e.copy(null,null,null,e.left.removeMin(),null),e.fixUp()}remove(e,t){let n,r=this;if(t(e,r.key)<0)r.left.isEmpty()||r.left.isRed()||r.left.left.isRed()||(r=r.moveRedLeft()),r=r.copy(null,null,null,r.left.remove(e,t),null);else{if(r.left.isRed()&&(r=r.rotateRight()),r.right.isEmpty()||r.right.isRed()||r.right.left.isRed()||(r=r.moveRedRight()),0===t(e,r.key)){if(r.right.isEmpty())return xh.EMPTY;n=r.right.min(),r=r.copy(n.key,n.value,null,null,r.right.removeMin())}r=r.copy(null,null,null,null,r.right.remove(e,t))}return r.fixUp()}isRed(){return this.color}fixUp(){let e=this;return e.right.isRed()&&!e.left.isRed()&&(e=e.rotateLeft()),e.left.isRed()&&e.left.left.isRed()&&(e=e.rotateRight()),e.left.isRed()&&e.right.isRed()&&(e=e.colorFlip()),e}moveRedLeft(){let e=this.colorFlip();return e.right.left.isRed()&&(e=e.copy(null,null,null,null,e.right.rotateRight()),e=e.rotateLeft(),e=e.colorFlip()),e}moveRedRight(){let e=this.colorFlip();return e.left.left.isRed()&&(e=e.rotateRight(),e=e.colorFlip()),e}rotateLeft(){const e=this.copy(null,null,xh.RED,null,this.right.left);return this.right.copy(null,null,this.color,e,null)}rotateRight(){const e=this.copy(null,null,xh.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,e)}colorFlip(){const e=this.left.copy(null,null,!this.left.color,null,null),t=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,e,t)}checkMaxDepth(){const e=this.check();return Math.pow(2,e)<=this.size+1}check(){if(this.isRed()&&this.left.isRed())throw Cd();if(this.right.isRed())throw Cd();const e=this.left.check();if(e!==this.right.check())throw Cd();return e+(this.isRed()?0:1)}}xh.EMPTY=null,xh.RED=!0,xh.BLACK=!1,xh.EMPTY=new class{constructor(){this.size=0}get key(){throw Cd()}get value(){throw Cd()}get color(){throw Cd()}get left(){throw Cd()}get right(){throw Cd()}copy(e,t,n,r,a){return this}insert(e,t,n){return new xh(e,t)}remove(e,t){return this}isEmpty(){return!0}inorderTraversal(e){return!1}reverseTraversal(e){return!1}minKey(){return null}maxKey(){return null}isRed(){return!1}checkMaxDepth(){return!0}check(){return 0}};class wh{constructor(e){this.comparator=e,this.data=new bh(this.comparator)}has(e){return null!==this.data.get(e)}first(){return this.data.minKey()}last(){return this.data.maxKey()}get size(){return this.data.size}indexOf(e){return this.data.indexOf(e)}forEach(e){this.data.inorderTraversal(((t,n)=>(e(t),!1)))}forEachInRange(e,t){const n=this.data.getIteratorFrom(e[0]);for(;n.hasNext();){const r=n.getNext();if(this.comparator(r.key,e[1])>=0)return;t(r.key)}}forEachWhile(e,t){let n;for(n=void 0!==t?this.data.getIteratorFrom(t):this.data.getIterator();n.hasNext();)if(!e(n.getNext().key))return}firstAfterOrEqual(e){const t=this.data.getIteratorFrom(e);return t.hasNext()?t.getNext().key:null}getIterator(){return new kh(this.data.getIterator())}getIteratorFrom(e){return new kh(this.data.getIteratorFrom(e))}add(e){return this.copy(this.data.remove(e).insert(e,!0))}delete(e){return this.has(e)?this.copy(this.data.remove(e)):this}isEmpty(){return this.data.isEmpty()}unionWith(e){let t=this;return t.size<e.size&&(t=e,e=this),e.forEach((e=>{t=t.add(e)})),t}isEqual(e){if(!(e instanceof wh))return!1;if(this.size!==e.size)return!1;const t=this.data.getIterator(),n=e.data.getIterator();for(;t.hasNext();){const e=t.getNext().key,r=n.getNext().key;if(0!==this.comparator(e,r))return!1}return!0}toArray(){const e=[];return this.forEach((t=>{e.push(t)})),e}toString(){const e=[];return this.forEach((t=>e.push(t))),"SortedSet("+e.toString()+")"}copy(e){const t=new wh(this.comparator);return t.data=e,t}}class kh{constructor(e){this.iter=e}getNext(){return this.iter.getNext().key}hasNext(){return this.iter.hasNext()}}class Sh{constructor(e){this.fields=e,e.sort(Kd.comparator)}static empty(){return new Sh([])}unionWith(e){let t=new wh(Kd.comparator);for(const n of this.fields)t=t.add(n);for(const n of e)t=t.add(n);return new Sh(t.toArray())}covers(e){for(const t of this.fields)if(t.isPrefixOf(e))return!0;return!1}isEqual(e){return Vd(this.fields,e.fields,((e,t)=>e.isEqual(t)))}}class Ih extends Error{constructor(){super(...arguments),this.name="Base64DecodeError"}}class Ch{constructor(e){this.binaryString=e}static fromBase64String(e){const t=function(e){try{return atob(e)}catch(e){throw"undefined"!=typeof DOMException&&e instanceof DOMException?new Ih("Invalid base64 string: "+e):e}}(e);return new Ch(t)}static fromUint8Array(e){const t=function(e){let t="";for(let n=0;n<e.length;++n)t+=String.fromCharCode(e[n]);return t}(e);return new Ch(t)}[Symbol.iterator](){let e=0;return{next:()=>e<this.binaryString.length?{value:this.binaryString.charCodeAt(e++),done:!1}:{value:void 0,done:!0}}}toBase64(){return e=this.binaryString,btoa(e);var e}toUint8Array(){return function(e){const t=new Uint8Array(e.length);for(let n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}(this.binaryString)}approximateByteSize(){return 2*this.binaryString.length}compareTo(e){return Wd(this.binaryString,e.binaryString)}isEqual(e){return this.binaryString===e.binaryString}}Ch.EMPTY_BYTE_STRING=new Ch("");const Nh=new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);function Th(e){if(Nd(!!e),"string"==typeof e){let t=0;const n=Nh.exec(e);if(Nd(!!n),n[1]){let e=n[1];e=(e+"000000000").substr(0,9),t=Number(e)}const r=new Date(e);return{seconds:Math.floor(r.getTime()/1e3),nanos:t}}return{seconds:Eh(e.seconds),nanos:Eh(e.nanos)}}function Eh(e){return"number"==typeof e?e:"string"==typeof e?Number(e):0}function Ah(e){return"string"==typeof e?Ch.fromBase64String(e):Ch.fromUint8Array(e)}function _h(e){var t,n;return"server_timestamp"===(null===(n=((null===(t=null==e?void 0:e.mapValue)||void 0===t?void 0:t.fields)||{}).__type__)||void 0===n?void 0:n.stringValue)}function $h(e){const t=e.mapValue.fields.__previous_value__;return _h(t)?$h(t):t}function Rh(e){const t=Th(e.mapValue.fields.__local_write_time__.timestampValue);return new Ud(t.seconds,t.nanos)}class Dh{constructor(e,t,n,r,a,s,i,o,l){this.databaseId=e,this.appId=t,this.persistenceKey=n,this.host=r,this.ssl=a,this.forceLongPolling=s,this.autoDetectLongPolling=i,this.longPollingOptions=o,this.useFetchStreams=l}}class Mh{constructor(e,t){this.projectId=e,this.database=t||"(default)"}static empty(){return new Mh("","")}get isDefaultDatabase(){return"(default)"===this.database}isEqual(e){return e instanceof Mh&&e.projectId===this.projectId&&e.database===this.database}}const Fh={mapValue:{fields:{__type__:{stringValue:"__max__"}}}};function Oh(e){return"nullValue"in e?0:"booleanValue"in e?1:"integerValue"in e||"doubleValue"in e?2:"timestampValue"in e?3:"stringValue"in e?5:"bytesValue"in e?6:"referenceValue"in e?7:"geoPointValue"in e?8:"arrayValue"in e?9:"mapValue"in e?_h(e)?4:Qh(e)?9007199254740991:Xh(e)?10:11:Cd()}function Ph(e,t){if(e===t)return!0;const n=Oh(e);if(n!==Oh(t))return!1;switch(n){case 0:case 9007199254740991:return!0;case 1:return e.booleanValue===t.booleanValue;case 4:return Rh(e).isEqual(Rh(t));case 3:return function(e,t){if("string"==typeof e.timestampValue&&"string"==typeof t.timestampValue&&e.timestampValue.length===t.timestampValue.length)return e.timestampValue===t.timestampValue;const n=Th(e.timestampValue),r=Th(t.timestampValue);return n.seconds===r.seconds&&n.nanos===r.nanos}(e,t);case 5:return e.stringValue===t.stringValue;case 6:return function(e,t){return Ah(e.bytesValue).isEqual(Ah(t.bytesValue))}(e,t);case 7:return e.referenceValue===t.referenceValue;case 8:return function(e,t){return Eh(e.geoPointValue.latitude)===Eh(t.geoPointValue.latitude)&&Eh(e.geoPointValue.longitude)===Eh(t.geoPointValue.longitude)}(e,t);case 2:return function(e,t){if("integerValue"in e&&"integerValue"in t)return Eh(e.integerValue)===Eh(t.integerValue);if("doubleValue"in e&&"doubleValue"in t){const n=Eh(e.doubleValue),r=Eh(t.doubleValue);return n===r?uh(n)===uh(r):isNaN(n)&&isNaN(r)}return!1}(e,t);case 9:return Vd(e.arrayValue.values||[],t.arrayValue.values||[],Ph);case 10:case 11:return function(e,t){const n=e.mapValue.fields||{},r=t.mapValue.fields||{};if(mh(n)!==mh(r))return!1;for(const a in n)if(n.hasOwnProperty(a)&&(void 0===r[a]||!Ph(n[a],r[a])))return!1;return!0}(e,t);default:return Cd()}}function Lh(e,t){return void 0!==(e.values||[]).find((e=>Ph(e,t)))}function zh(e,t){if(e===t)return 0;const n=Oh(e),r=Oh(t);if(n!==r)return Wd(n,r);switch(n){case 0:case 9007199254740991:return 0;case 1:return Wd(e.booleanValue,t.booleanValue);case 2:return function(e,t){const n=Eh(e.integerValue||e.doubleValue),r=Eh(t.integerValue||t.doubleValue);return n<r?-1:n>r?1:n===r?0:isNaN(n)?isNaN(r)?0:-1:1}(e,t);case 3:return Bh(e.timestampValue,t.timestampValue);case 4:return Bh(Rh(e),Rh(t));case 5:return Wd(e.stringValue,t.stringValue);case 6:return function(e,t){const n=Ah(e),r=Ah(t);return n.compareTo(r)}(e.bytesValue,t.bytesValue);case 7:return function(e,t){const n=e.split("/"),r=t.split("/");for(let a=0;a<n.length&&a<r.length;a++){const e=Wd(n[a],r[a]);if(0!==e)return e}return Wd(n.length,r.length)}(e.referenceValue,t.referenceValue);case 8:return function(e,t){const n=Wd(Eh(e.latitude),Eh(t.latitude));return 0!==n?n:Wd(Eh(e.longitude),Eh(t.longitude))}(e.geoPointValue,t.geoPointValue);case 9:return Wh(e.arrayValue,t.arrayValue);case 10:return function(e,t){var n,r,a,s;const i=e.fields||{},o=t.fields||{},l=null===(n=i.value)||void 0===n?void 0:n.arrayValue,u=null===(r=o.value)||void 0===r?void 0:r.arrayValue,c=Wd((null===(a=null==l?void 0:l.values)||void 0===a?void 0:a.length)||0,(null===(s=null==u?void 0:u.values)||void 0===s?void 0:s.length)||0);return 0!==c?c:Wh(l,u)}(e.mapValue,t.mapValue);case 11:return function(e,t){if(e===Fh.mapValue&&t===Fh.mapValue)return 0;if(e===Fh.mapValue)return 1;if(t===Fh.mapValue)return-1;const n=e.fields||{},r=Object.keys(n),a=t.fields||{},s=Object.keys(a);r.sort(),s.sort();for(let i=0;i<r.length&&i<s.length;++i){const e=Wd(r[i],s[i]);if(0!==e)return e;const t=zh(n[r[i]],a[s[i]]);if(0!==t)return t}return Wd(r.length,s.length)}(e.mapValue,t.mapValue);default:throw Cd()}}function Bh(e,t){if("string"==typeof e&&"string"==typeof t&&e.length===t.length)return Wd(e,t);const n=Th(e),r=Th(t),a=Wd(n.seconds,r.seconds);return 0!==a?a:Wd(n.nanos,r.nanos)}function Wh(e,t){const n=e.values||[],r=t.values||[];for(let a=0;a<n.length&&a<r.length;++a){const e=zh(n[a],r[a]);if(e)return e}return Wd(n.length,r.length)}function Vh(e){return Uh(e)}function Uh(e){return"nullValue"in e?"null":"booleanValue"in e?""+e.booleanValue:"integerValue"in e?""+e.integerValue:"doubleValue"in e?""+e.doubleValue:"timestampValue"in e?function(e){const t=Th(e);return`time(${t.seconds},${t.nanos})`}(e.timestampValue):"stringValue"in e?e.stringValue:"bytesValue"in e?function(e){return Ah(e).toBase64()}(e.bytesValue):"referenceValue"in e?function(e){return Xd.fromName(e).toString()}(e.referenceValue):"geoPointValue"in e?function(e){return`geo(${e.latitude},${e.longitude})`}(e.geoPointValue):"arrayValue"in e?function(e){let t="[",n=!0;for(const r of e.values||[])n?n=!1:t+=",",t+=Uh(r);return t+"]"}(e.arrayValue):"mapValue"in e?function(e){const t=Object.keys(e.fields||{}).sort();let n="{",r=!0;for(const a of t)r?r=!1:n+=",",n+=`${a}:${Uh(e.fields[a])}`;return n+"}"}(e.mapValue):Cd()}function jh(e){return!!e&&"integerValue"in e}function Gh(e){return!!e&&"arrayValue"in e}function Hh(e){return!!e&&"nullValue"in e}function qh(e){return!!e&&"doubleValue"in e&&isNaN(Number(e.doubleValue))}function Kh(e){return!!e&&"mapValue"in e}function Xh(e){var t,n;return"__vector__"===(null===(n=((null===(t=null==e?void 0:e.mapValue)||void 0===t?void 0:t.fields)||{}).__type__)||void 0===n?void 0:n.stringValue)}function Yh(e){if(e.geoPointValue)return{geoPointValue:Object.assign({},e.geoPointValue)};if(e.timestampValue&&"object"==typeof e.timestampValue)return{timestampValue:Object.assign({},e.timestampValue)};if(e.mapValue){const t={mapValue:{fields:{}}};return gh(e.mapValue.fields,((e,n)=>t.mapValue.fields[e]=Yh(n))),t}if(e.arrayValue){const t={arrayValue:{values:[]}};for(let n=0;n<(e.arrayValue.values||[]).length;++n)t.arrayValue.values[n]=Yh(e.arrayValue.values[n]);return t}return Object.assign({},e)}function Qh(e){return"__max__"===(((e.mapValue||{}).fields||{}).__type__||{}).stringValue}class Jh{constructor(e){this.value=e}static empty(){return new Jh({mapValue:{}})}field(e){if(e.isEmpty())return this.value;{let t=this.value;for(let n=0;n<e.length-1;++n)if(t=(t.mapValue.fields||{})[e.get(n)],!Kh(t))return null;return t=(t.mapValue.fields||{})[e.lastSegment()],t||null}}set(e,t){this.getFieldsMap(e.popLast())[e.lastSegment()]=Yh(t)}setAll(e){let t=Kd.emptyPath(),n={},r=[];e.forEach(((e,a)=>{if(!t.isImmediateParentOf(a)){const e=this.getFieldsMap(t);this.applyChanges(e,n,r),n={},r=[],t=a.popLast()}e?n[a.lastSegment()]=Yh(e):r.push(a.lastSegment())}));const a=this.getFieldsMap(t);this.applyChanges(a,n,r)}delete(e){const t=this.field(e.popLast());Kh(t)&&t.mapValue.fields&&delete t.mapValue.fields[e.lastSegment()]}isEqual(e){return Ph(this.value,e.value)}getFieldsMap(e){let t=this.value;t.mapValue.fields||(t.mapValue={fields:{}});for(let n=0;n<e.length;++n){let r=t.mapValue.fields[e.get(n)];Kh(r)&&r.mapValue.fields||(r={mapValue:{fields:{}}},t.mapValue.fields[e.get(n)]=r),t=r}return t.mapValue.fields}applyChanges(e,t,n){gh(t,((t,n)=>e[t]=n));for(const r of n)delete e[r]}clone(){return new Jh(Yh(this.value))}}function Zh(e){const t=[];return gh(e.fields,((e,n)=>{const r=new Kd([e]);if(Kh(n)){const e=Zh(n.mapValue).fields;if(0===e.length)t.push(r);else for(const n of e)t.push(r.child(n))}else t.push(r)})),new Sh(t)}class ep{constructor(e,t,n,r,a,s,i){this.key=e,this.documentType=t,this.version=n,this.readTime=r,this.createTime=a,this.data=s,this.documentState=i}static newInvalidDocument(e){return new ep(e,0,jd.min(),jd.min(),jd.min(),Jh.empty(),0)}static newFoundDocument(e,t,n,r){return new ep(e,1,t,jd.min(),n,r,0)}static newNoDocument(e,t){return new ep(e,2,t,jd.min(),jd.min(),Jh.empty(),0)}static newUnknownDocument(e,t){return new ep(e,3,t,jd.min(),jd.min(),Jh.empty(),2)}convertToFoundDocument(e,t){return!this.createTime.isEqual(jd.min())||2!==this.documentType&&0!==this.documentType||(this.createTime=e),this.version=e,this.documentType=1,this.data=t,this.documentState=0,this}convertToNoDocument(e){return this.version=e,this.documentType=2,this.data=Jh.empty(),this.documentState=0,this}convertToUnknownDocument(e){return this.version=e,this.documentType=3,this.data=Jh.empty(),this.documentState=2,this}setHasCommittedMutations(){return this.documentState=2,this}setHasLocalMutations(){return this.documentState=1,this.version=jd.min(),this}setReadTime(e){return this.readTime=e,this}get hasLocalMutations(){return 1===this.documentState}get hasCommittedMutations(){return 2===this.documentState}get hasPendingWrites(){return this.hasLocalMutations||this.hasCommittedMutations}isValidDocument(){return 0!==this.documentType}isFoundDocument(){return 1===this.documentType}isNoDocument(){return 2===this.documentType}isUnknownDocument(){return 3===this.documentType}isEqual(e){return e instanceof ep&&this.key.isEqual(e.key)&&this.version.isEqual(e.version)&&this.documentType===e.documentType&&this.documentState===e.documentState&&this.data.isEqual(e.data)}mutableCopy(){return new ep(this.key,this.documentType,this.version,this.readTime,this.createTime,this.data.clone(),this.documentState)}toString(){return`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`}}class tp{constructor(e,t){this.position=e,this.inclusive=t}}function np(e,t,n){let r=0;for(let a=0;a<e.position.length;a++){const s=t[a],i=e.position[a];if(r=s.field.isKeyField()?Xd.comparator(Xd.fromName(i.referenceValue),n.key):zh(i,n.data.field(s.field)),"desc"===s.dir&&(r*=-1),0!==r)break}return r}function rp(e,t){if(null===e)return null===t;if(null===t)return!1;if(e.inclusive!==t.inclusive||e.position.length!==t.position.length)return!1;for(let n=0;n<e.position.length;n++)if(!Ph(e.position[n],t.position[n]))return!1;return!0}class ap{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"asc";this.field=e,this.dir=t}}function sp(e,t){return e.dir===t.dir&&e.field.isEqual(t.field)}class ip{}class op extends ip{constructor(e,t,n){super(),this.field=e,this.op=t,this.value=n}static create(e,t,n){return e.isKeyField()?"in"===t||"not-in"===t?this.createKeyFieldInFilter(e,t,n):new mp(e,t,n):"array-contains"===t?new vp(e,n):"in"===t?new xp(e,n):"not-in"===t?new wp(e,n):"array-contains-any"===t?new kp(e,n):new op(e,t,n)}static createKeyFieldInFilter(e,t,n){return"in"===t?new gp(e,n):new yp(e,n)}matches(e){const t=e.data.field(this.field);return"!="===this.op?null!==t&&this.matchesComparison(zh(t,this.value)):null!==t&&Oh(this.value)===Oh(t)&&this.matchesComparison(zh(t,this.value))}matchesComparison(e){switch(this.op){case"<":return e<0;case"<=":return e<=0;case"==":return 0===e;case"!=":return 0!==e;case">":return e>0;case">=":return e>=0;default:return Cd()}}isInequality(){return["<","<=",">",">=","!=","not-in"].indexOf(this.op)>=0}getFlattenedFilters(){return[this]}getFilters(){return[this]}}class lp extends ip{constructor(e,t){super(),this.filters=e,this.op=t,this.ae=null}static create(e,t){return new lp(e,t)}matches(e){return up(this)?void 0===this.filters.find((t=>!t.matches(e))):void 0!==this.filters.find((t=>t.matches(e)))}getFlattenedFilters(){return null!==this.ae||(this.ae=this.filters.reduce(((e,t)=>e.concat(t.getFlattenedFilters())),[])),this.ae}getFilters(){return Object.assign([],this.filters)}}function up(e){return"and"===e.op}function cp(e){return dp(e)&&up(e)}function dp(e){for(const t of e.filters)if(t instanceof lp)return!1;return!0}function hp(e){if(e instanceof op)return e.field.canonicalString()+e.op.toString()+Vh(e.value);if(cp(e))return e.filters.map((e=>hp(e))).join(",");{const t=e.filters.map((e=>hp(e))).join(",");return`${e.op}(${t})`}}function pp(e,t){return e instanceof op?function(e,t){return t instanceof op&&e.op===t.op&&e.field.isEqual(t.field)&&Ph(e.value,t.value)}(e,t):e instanceof lp?function(e,t){return t instanceof lp&&e.op===t.op&&e.filters.length===t.filters.length&&e.filters.reduce(((e,n,r)=>e&&pp(n,t.filters[r])),!0)}(e,t):void Cd()}function fp(e){return e instanceof op?function(e){return`${e.field.canonicalString()} ${e.op} ${Vh(e.value)}`}(e):e instanceof lp?function(e){return e.op.toString()+" {"+e.getFilters().map(fp).join(" ,")+"}"}(e):"Filter"}class mp extends op{constructor(e,t,n){super(e,t,n),this.key=Xd.fromName(n.referenceValue)}matches(e){const t=Xd.comparator(e.key,this.key);return this.matchesComparison(t)}}class gp extends op{constructor(e,t){super(e,"in",t),this.keys=bp("in",t)}matches(e){return this.keys.some((t=>t.isEqual(e.key)))}}class yp extends op{constructor(e,t){super(e,"not-in",t),this.keys=bp("not-in",t)}matches(e){return!this.keys.some((t=>t.isEqual(e.key)))}}function bp(e,t){var n;return((null===(n=t.arrayValue)||void 0===n?void 0:n.values)||[]).map((e=>Xd.fromName(e.referenceValue)))}class vp extends op{constructor(e,t){super(e,"array-contains",t)}matches(e){const t=e.data.field(this.field);return Gh(t)&&Lh(t.arrayValue,this.value)}}class xp extends op{constructor(e,t){super(e,"in",t)}matches(e){const t=e.data.field(this.field);return null!==t&&Lh(this.value.arrayValue,t)}}class wp extends op{constructor(e,t){super(e,"not-in",t)}matches(e){if(Lh(this.value.arrayValue,{nullValue:"NULL_VALUE"}))return!1;const t=e.data.field(this.field);return null!==t&&!Lh(this.value.arrayValue,t)}}class kp extends op{constructor(e,t){super(e,"array-contains-any",t)}matches(e){const t=e.data.field(this.field);return!(!Gh(t)||!t.arrayValue.values)&&t.arrayValue.values.some((e=>Lh(this.value.arrayValue,e)))}}class Sp{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;this.path=e,this.collectionGroup=t,this.orderBy=n,this.filters=r,this.limit=a,this.startAt=s,this.endAt=i,this.ue=null}}function Ip(e){return new Sp(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,arguments.length>6&&void 0!==arguments[6]?arguments[6]:null)}function Cp(e){const t=Td(e);if(null===t.ue){let e=t.path.canonicalString();null!==t.collectionGroup&&(e+="|cg:"+t.collectionGroup),e+="|f:",e+=t.filters.map((e=>hp(e))).join(","),e+="|ob:",e+=t.orderBy.map((e=>function(e){return e.field.canonicalString()+e.dir}(e))).join(","),lh(t.limit)||(e+="|l:",e+=t.limit),t.startAt&&(e+="|lb:",e+=t.startAt.inclusive?"b:":"a:",e+=t.startAt.position.map((e=>Vh(e))).join(",")),t.endAt&&(e+="|ub:",e+=t.endAt.inclusive?"a:":"b:",e+=t.endAt.position.map((e=>Vh(e))).join(",")),t.ue=e}return t.ue}function Np(e,t){if(e.limit!==t.limit)return!1;if(e.orderBy.length!==t.orderBy.length)return!1;for(let n=0;n<e.orderBy.length;n++)if(!sp(e.orderBy[n],t.orderBy[n]))return!1;if(e.filters.length!==t.filters.length)return!1;for(let n=0;n<e.filters.length;n++)if(!pp(e.filters[n],t.filters[n]))return!1;return e.collectionGroup===t.collectionGroup&&!!e.path.isEqual(t.path)&&!!rp(e.startAt,t.startAt)&&rp(e.endAt,t.endAt)}function Tp(e){return Xd.isDocumentKey(e.path)&&null===e.collectionGroup&&0===e.filters.length}class Ep{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"F",i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;this.path=e,this.collectionGroup=t,this.explicitOrderBy=n,this.filters=r,this.limit=a,this.limitType=s,this.startAt=i,this.endAt=o,this.ce=null,this.le=null,this.he=null,this.startAt,this.endAt}}function Ap(e,t,n,r,a,s,i,o){return new Ep(e,t,n,r,a,s,i,o)}function _p(e){return new Ep(e)}function $p(e){return 0===e.filters.length&&null===e.limit&&null==e.startAt&&null==e.endAt&&(0===e.explicitOrderBy.length||1===e.explicitOrderBy.length&&e.explicitOrderBy[0].field.isKeyField())}function Rp(e){return null!==e.collectionGroup}function Dp(e){const t=Td(e);if(null===t.ce){t.ce=[];const e=new Set;for(const a of t.explicitOrderBy)t.ce.push(a),e.add(a.field.canonicalString());const n=t.explicitOrderBy.length>0?t.explicitOrderBy[t.explicitOrderBy.length-1].dir:"asc",r=function(e){let t=new wh(Kd.comparator);return e.filters.forEach((e=>{e.getFlattenedFilters().forEach((e=>{e.isInequality()&&(t=t.add(e.field))}))})),t}(t);r.forEach((r=>{e.has(r.canonicalString())||r.isKeyField()||t.ce.push(new ap(r,n))})),e.has(Kd.keyField().canonicalString())||t.ce.push(new ap(Kd.keyField(),n))}return t.ce}function Mp(e){const t=Td(e);return t.le||(t.le=Fp(t,Dp(e))),t.le}function Fp(e,t){if("F"===e.limitType)return Ip(e.path,e.collectionGroup,t,e.filters,e.limit,e.startAt,e.endAt);{t=t.map((e=>{const t="desc"===e.dir?"asc":"desc";return new ap(e.field,t)}));const n=e.endAt?new tp(e.endAt.position,e.endAt.inclusive):null,r=e.startAt?new tp(e.startAt.position,e.startAt.inclusive):null;return Ip(e.path,e.collectionGroup,t,e.filters,e.limit,n,r)}}function Op(e,t,n){return new Ep(e.path,e.collectionGroup,e.explicitOrderBy.slice(),e.filters.slice(),t,n,e.startAt,e.endAt)}function Pp(e,t){return Np(Mp(e),Mp(t))&&e.limitType===t.limitType}function Lp(e){return`${Cp(Mp(e))}|lt:${e.limitType}`}function zp(e){return`Query(target=${function(e){let t=e.path.canonicalString();return null!==e.collectionGroup&&(t+=" collectionGroup="+e.collectionGroup),e.filters.length>0&&(t+=`, filters: [${e.filters.map((e=>fp(e))).join(", ")}]`),lh(e.limit)||(t+=", limit: "+e.limit),e.orderBy.length>0&&(t+=`, orderBy: [${e.orderBy.map((e=>function(e){return`${e.field.canonicalString()} (${e.dir})`}(e))).join(", ")}]`),e.startAt&&(t+=", startAt: ",t+=e.startAt.inclusive?"b:":"a:",t+=e.startAt.position.map((e=>Vh(e))).join(",")),e.endAt&&(t+=", endAt: ",t+=e.endAt.inclusive?"a:":"b:",t+=e.endAt.position.map((e=>Vh(e))).join(",")),`Target(${t})`}(Mp(e))}; limitType=${e.limitType})`}function Bp(e,t){return t.isFoundDocument()&&function(e,t){const n=t.key.path;return null!==e.collectionGroup?t.key.hasCollectionId(e.collectionGroup)&&e.path.isPrefixOf(n):Xd.isDocumentKey(e.path)?e.path.isEqual(n):e.path.isImmediateParentOf(n)}(e,t)&&function(e,t){for(const n of Dp(e))if(!n.field.isKeyField()&&null===t.data.field(n.field))return!1;return!0}(e,t)&&function(e,t){for(const n of e.filters)if(!n.matches(t))return!1;return!0}(e,t)&&function(e,t){return!(e.startAt&&!function(e,t,n){const r=np(e,t,n);return e.inclusive?r<=0:r<0}(e.startAt,Dp(e),t))&&!(e.endAt&&!function(e,t,n){const r=np(e,t,n);return e.inclusive?r>=0:r>0}(e.endAt,Dp(e),t))}(e,t)}function Wp(e){return e.collectionGroup||(e.path.length%2==1?e.path.lastSegment():e.path.get(e.path.length-2))}function Vp(e){return(t,n)=>{let r=!1;for(const a of Dp(e)){const e=Up(a,t,n);if(0!==e)return e;r=r||a.field.isKeyField()}return 0}}function Up(e,t,n){const r=e.field.isKeyField()?Xd.comparator(t.key,n.key):function(e,t,n){const r=t.data.field(e),a=n.data.field(e);return null!==r&&null!==a?zh(r,a):Cd()}(e.field,t,n);switch(e.dir){case"asc":return r;case"desc":return-1*r;default:return Cd()}}class jp{constructor(e,t){this.mapKeyFn=e,this.equalsFn=t,this.inner={},this.innerSize=0}get(e){const t=this.mapKeyFn(e),n=this.inner[t];if(void 0!==n)for(const[r,a]of n)if(this.equalsFn(r,e))return a}has(e){return void 0!==this.get(e)}set(e,t){const n=this.mapKeyFn(e),r=this.inner[n];if(void 0===r)return this.inner[n]=[[e,t]],void this.innerSize++;for(let a=0;a<r.length;a++)if(this.equalsFn(r[a][0],e))return void(r[a]=[e,t]);r.push([e,t]),this.innerSize++}delete(e){const t=this.mapKeyFn(e),n=this.inner[t];if(void 0===n)return!1;for(let r=0;r<n.length;r++)if(this.equalsFn(n[r][0],e))return 1===n.length?delete this.inner[t]:n.splice(r,1),this.innerSize--,!0;return!1}forEach(e){gh(this.inner,((t,n)=>{for(const[r,a]of n)e(r,a)}))}isEmpty(){return yh(this.inner)}size(){return this.innerSize}}const Gp=new bh(Xd.comparator);function Hp(){return Gp}const qp=new bh(Xd.comparator);function Kp(){let e=qp;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const a of n)e=e.insert(a.key,a);return e}function Xp(e){let t=qp;return e.forEach(((e,n)=>t=t.insert(e,n.overlayedDocument))),t}function Yp(){return Jp()}function Qp(){return Jp()}function Jp(){return new jp((e=>e.toString()),((e,t)=>e.isEqual(t)))}const Zp=new bh(Xd.comparator),ef=new wh(Xd.comparator);function tf(){let e=ef;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const a of n)e=e.add(a);return e}const nf=new wh(Wd);function rf(){return nf}function af(e,t){if(e.useProto3Json){if(isNaN(t))return{doubleValue:"NaN"};if(t===1/0)return{doubleValue:"Infinity"};if(t===-1/0)return{doubleValue:"-Infinity"}}return{doubleValue:uh(t)?"-0":t}}function sf(e){return{integerValue:""+e}}function of(e,t){return ch(t)?sf(t):af(e,t)}class lf{constructor(){this._=void 0}}function uf(e,t,n){return e instanceof hf?function(e,t){const n={fields:{__type__:{stringValue:"server_timestamp"},__local_write_time__:{timestampValue:{seconds:e.seconds,nanos:e.nanoseconds}}}};return t&&_h(t)&&(t=$h(t)),t&&(n.fields.__previous_value__=t),{mapValue:n}}(n,t):e instanceof pf?ff(e,t):e instanceof mf?gf(e,t):function(e,t){const n=df(e,t),r=bf(n)+bf(e.Pe);return jh(n)&&jh(e.Pe)?sf(r):af(e.serializer,r)}(e,t)}function cf(e,t,n){return e instanceof pf?ff(e,t):e instanceof mf?gf(e,t):n}function df(e,t){return e instanceof yf?function(e){return jh(e)||function(e){return!!e&&"doubleValue"in e}(e)}(t)?t:{integerValue:0}:null}class hf extends lf{}class pf extends lf{constructor(e){super(),this.elements=e}}function ff(e,t){const n=vf(t);for(const r of e.elements)n.some((e=>Ph(e,r)))||n.push(r);return{arrayValue:{values:n}}}class mf extends lf{constructor(e){super(),this.elements=e}}function gf(e,t){let n=vf(t);for(const r of e.elements)n=n.filter((e=>!Ph(e,r)));return{arrayValue:{values:n}}}class yf extends lf{constructor(e,t){super(),this.serializer=e,this.Pe=t}}function bf(e){return Eh(e.integerValue||e.doubleValue)}function vf(e){return Gh(e)&&e.arrayValue.values?e.arrayValue.values.slice():[]}class xf{constructor(e,t){this.version=e,this.transformResults=t}}class wf{constructor(e,t){this.updateTime=e,this.exists=t}static none(){return new wf}static exists(e){return new wf(void 0,e)}static updateTime(e){return new wf(e)}get isNone(){return void 0===this.updateTime&&void 0===this.exists}isEqual(e){return this.exists===e.exists&&(this.updateTime?!!e.updateTime&&this.updateTime.isEqual(e.updateTime):!e.updateTime)}}function kf(e,t){return void 0!==e.updateTime?t.isFoundDocument()&&t.version.isEqual(e.updateTime):void 0===e.exists||e.exists===t.isFoundDocument()}class Sf{}function If(e,t){if(!e.hasLocalMutations||t&&0===t.fields.length)return null;if(null===t)return e.isNoDocument()?new Mf(e.key,wf.none()):new Af(e.key,e.data,wf.none());{const n=e.data,r=Jh.empty();let a=new wh(Kd.comparator);for(let e of t.fields)if(!a.has(e)){let t=n.field(e);null===t&&e.length>1&&(e=e.popLast(),t=n.field(e)),null===t?r.delete(e):r.set(e,t),a=a.add(e)}return new _f(e.key,r,new Sh(a.toArray()),wf.none())}}function Cf(e,t,n){e instanceof Af?function(e,t,n){const r=e.value.clone(),a=Rf(e.fieldTransforms,t,n.transformResults);r.setAll(a),t.convertToFoundDocument(n.version,r).setHasCommittedMutations()}(e,t,n):e instanceof _f?function(e,t,n){if(!kf(e.precondition,t))return void t.convertToUnknownDocument(n.version);const r=Rf(e.fieldTransforms,t,n.transformResults),a=t.data;a.setAll($f(e)),a.setAll(r),t.convertToFoundDocument(n.version,a).setHasCommittedMutations()}(e,t,n):function(e,t,n){t.convertToNoDocument(n.version).setHasCommittedMutations()}(0,t,n)}function Nf(e,t,n,r){return e instanceof Af?function(e,t,n,r){if(!kf(e.precondition,t))return n;const a=e.value.clone(),s=Df(e.fieldTransforms,r,t);return a.setAll(s),t.convertToFoundDocument(t.version,a).setHasLocalMutations(),null}(e,t,n,r):e instanceof _f?function(e,t,n,r){if(!kf(e.precondition,t))return n;const a=Df(e.fieldTransforms,r,t),s=t.data;return s.setAll($f(e)),s.setAll(a),t.convertToFoundDocument(t.version,s).setHasLocalMutations(),null===n?null:n.unionWith(e.fieldMask.fields).unionWith(e.fieldTransforms.map((e=>e.field)))}(e,t,n,r):function(e,t,n){return kf(e.precondition,t)?(t.convertToNoDocument(t.version).setHasLocalMutations(),null):n}(e,t,n)}function Tf(e,t){let n=null;for(const r of e.fieldTransforms){const e=t.data.field(r.field),a=df(r.transform,e||null);null!=a&&(null===n&&(n=Jh.empty()),n.set(r.field,a))}return n||null}function Ef(e,t){return e.type===t.type&&!!e.key.isEqual(t.key)&&!!e.precondition.isEqual(t.precondition)&&!!function(e,t){return void 0===e&&void 0===t||!(!e||!t)&&Vd(e,t,((e,t)=>function(e,t){return e.field.isEqual(t.field)&&function(e,t){return e instanceof pf&&t instanceof pf||e instanceof mf&&t instanceof mf?Vd(e.elements,t.elements,Ph):e instanceof yf&&t instanceof yf?Ph(e.Pe,t.Pe):e instanceof hf&&t instanceof hf}(e.transform,t.transform)}(e,t)))}(e.fieldTransforms,t.fieldTransforms)&&(0===e.type?e.value.isEqual(t.value):1!==e.type||e.data.isEqual(t.data)&&e.fieldMask.isEqual(t.fieldMask))}class Af extends Sf{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];super(),this.key=e,this.value=t,this.precondition=n,this.fieldTransforms=r,this.type=0}getFieldMask(){return null}}class _f extends Sf{constructor(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];super(),this.key=e,this.data=t,this.fieldMask=n,this.precondition=r,this.fieldTransforms=a,this.type=1}getFieldMask(){return this.fieldMask}}function $f(e){const t=new Map;return e.fieldMask.fields.forEach((n=>{if(!n.isEmpty()){const r=e.data.field(n);t.set(n,r)}})),t}function Rf(e,t,n){const r=new Map;Nd(e.length===n.length);for(let a=0;a<n.length;a++){const s=e[a],i=s.transform,o=t.data.field(s.field);r.set(s.field,cf(i,o,n[a]))}return r}function Df(e,t,n){const r=new Map;for(const a of e){const e=a.transform,s=n.data.field(a.field);r.set(a.field,uf(e,s,t))}return r}class Mf extends Sf{constructor(e,t){super(),this.key=e,this.precondition=t,this.type=2,this.fieldTransforms=[]}getFieldMask(){return null}}class Ff extends Sf{constructor(e,t){super(),this.key=e,this.precondition=t,this.type=3,this.fieldTransforms=[]}getFieldMask(){return null}}class Of{constructor(e,t,n,r){this.batchId=e,this.localWriteTime=t,this.baseMutations=n,this.mutations=r}applyToRemoteDocument(e,t){const n=t.mutationResults;for(let r=0;r<this.mutations.length;r++){const t=this.mutations[r];t.key.isEqual(e.key)&&Cf(t,e,n[r])}}applyToLocalView(e,t){for(const n of this.baseMutations)n.key.isEqual(e.key)&&(t=Nf(n,e,t,this.localWriteTime));for(const n of this.mutations)n.key.isEqual(e.key)&&(t=Nf(n,e,t,this.localWriteTime));return t}applyToLocalDocumentSet(e,t){const n=Qp();return this.mutations.forEach((r=>{const a=e.get(r.key),s=a.overlayedDocument;let i=this.applyToLocalView(s,a.mutatedFields);i=t.has(r.key)?null:i;const o=If(s,i);null!==o&&n.set(r.key,o),s.isValidDocument()||s.convertToNoDocument(jd.min())})),n}keys(){return this.mutations.reduce(((e,t)=>e.add(t.key)),tf())}isEqual(e){return this.batchId===e.batchId&&Vd(this.mutations,e.mutations,((e,t)=>Ef(e,t)))&&Vd(this.baseMutations,e.baseMutations,((e,t)=>Ef(e,t)))}}class Pf{constructor(e,t,n,r){this.batch=e,this.commitVersion=t,this.mutationResults=n,this.docVersions=r}static from(e,t,n){Nd(e.mutations.length===n.length);let r=Zp;const a=e.mutations;for(let s=0;s<a.length;s++)r=r.insert(a[s].key,n[s].version);return new Pf(e,t,n,r)}}class Lf{constructor(e,t){this.largestBatchId=e,this.mutation=t}getKey(){return this.mutation.key}isEqual(e){return null!==e&&this.mutation===e.mutation}toString(){return`Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`}}class zf{constructor(e,t){this.count=e,this.unchangedNames=t}}var Bf,Wf;function Vf(e){switch(e){default:return Cd();case Ed.CANCELLED:case Ed.UNKNOWN:case Ed.DEADLINE_EXCEEDED:case Ed.RESOURCE_EXHAUSTED:case Ed.INTERNAL:case Ed.UNAVAILABLE:case Ed.UNAUTHENTICATED:return!1;case Ed.INVALID_ARGUMENT:case Ed.NOT_FOUND:case Ed.ALREADY_EXISTS:case Ed.PERMISSION_DENIED:case Ed.FAILED_PRECONDITION:case Ed.ABORTED:case Ed.OUT_OF_RANGE:case Ed.UNIMPLEMENTED:case Ed.DATA_LOSS:return!0}}function Uf(e){if(void 0===e)return kd("GRPC error has no .code"),Ed.UNKNOWN;switch(e){case Bf.OK:return Ed.OK;case Bf.CANCELLED:return Ed.CANCELLED;case Bf.UNKNOWN:return Ed.UNKNOWN;case Bf.DEADLINE_EXCEEDED:return Ed.DEADLINE_EXCEEDED;case Bf.RESOURCE_EXHAUSTED:return Ed.RESOURCE_EXHAUSTED;case Bf.INTERNAL:return Ed.INTERNAL;case Bf.UNAVAILABLE:return Ed.UNAVAILABLE;case Bf.UNAUTHENTICATED:return Ed.UNAUTHENTICATED;case Bf.INVALID_ARGUMENT:return Ed.INVALID_ARGUMENT;case Bf.NOT_FOUND:return Ed.NOT_FOUND;case Bf.ALREADY_EXISTS:return Ed.ALREADY_EXISTS;case Bf.PERMISSION_DENIED:return Ed.PERMISSION_DENIED;case Bf.FAILED_PRECONDITION:return Ed.FAILED_PRECONDITION;case Bf.ABORTED:return Ed.ABORTED;case Bf.OUT_OF_RANGE:return Ed.OUT_OF_RANGE;case Bf.UNIMPLEMENTED:return Ed.UNIMPLEMENTED;case Bf.DATA_LOSS:return Ed.DATA_LOSS;default:return Cd()}}(Wf=Bf||(Bf={}))[Wf.OK=0]="OK",Wf[Wf.CANCELLED=1]="CANCELLED",Wf[Wf.UNKNOWN=2]="UNKNOWN",Wf[Wf.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",Wf[Wf.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",Wf[Wf.NOT_FOUND=5]="NOT_FOUND",Wf[Wf.ALREADY_EXISTS=6]="ALREADY_EXISTS",Wf[Wf.PERMISSION_DENIED=7]="PERMISSION_DENIED",Wf[Wf.UNAUTHENTICATED=16]="UNAUTHENTICATED",Wf[Wf.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",Wf[Wf.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",Wf[Wf.ABORTED=10]="ABORTED",Wf[Wf.OUT_OF_RANGE=11]="OUT_OF_RANGE",Wf[Wf.UNIMPLEMENTED=12]="UNIMPLEMENTED",Wf[Wf.INTERNAL=13]="INTERNAL",Wf[Wf.UNAVAILABLE=14]="UNAVAILABLE",Wf[Wf.DATA_LOSS=15]="DATA_LOSS";let jf=null;function Gf(){return new TextEncoder}const Hf=new td([4294967295,4294967295],0);function qf(e){const t=Gf().encode(e),n=new nd;return n.update(t),new Uint8Array(n.digest())}function Kf(e){const t=new DataView(e.buffer),n=t.getUint32(0,!0),r=t.getUint32(4,!0),a=t.getUint32(8,!0),s=t.getUint32(12,!0);return[new td([n,r],0),new td([a,s],0)]}class Xf{constructor(e,t,n){if(this.bitmap=e,this.padding=t,this.hashCount=n,t<0||t>=8)throw new Yf(`Invalid padding: ${t}`);if(n<0)throw new Yf(`Invalid hash count: ${n}`);if(e.length>0&&0===this.hashCount)throw new Yf(`Invalid hash count: ${n}`);if(0===e.length&&0!==t)throw new Yf(`Invalid padding when bitmap length is 0: ${t}`);this.Ie=8*e.length-t,this.Te=td.fromNumber(this.Ie)}Ee(e,t,n){let r=e.add(t.multiply(td.fromNumber(n)));return 1===r.compare(Hf)&&(r=new td([r.getBits(0),r.getBits(1)],0)),r.modulo(this.Te).toNumber()}de(e){return 0!=(this.bitmap[Math.floor(e/8)]&1<<e%8)}mightContain(e){if(0===this.Ie)return!1;const t=qf(e),[n,r]=Kf(t);for(let a=0;a<this.hashCount;a++){const e=this.Ee(n,r,a);if(!this.de(e))return!1}return!0}static create(e,t,n){const r=e%8==0?0:8-e%8,a=new Uint8Array(Math.ceil(e/8)),s=new Xf(a,r,t);return n.forEach((e=>s.insert(e))),s}insert(e){if(0===this.Ie)return;const t=qf(e),[n,r]=Kf(t);for(let a=0;a<this.hashCount;a++){const e=this.Ee(n,r,a);this.Ae(e)}}Ae(e){const t=Math.floor(e/8),n=e%8;this.bitmap[t]|=1<<n}}class Yf extends Error{constructor(){super(...arguments),this.name="BloomFilterError"}}class Qf{constructor(e,t,n,r,a){this.snapshotVersion=e,this.targetChanges=t,this.targetMismatches=n,this.documentUpdates=r,this.resolvedLimboDocuments=a}static createSynthesizedRemoteEventForCurrentChange(e,t,n){const r=new Map;return r.set(e,Jf.createSynthesizedTargetChangeForCurrentChange(e,t,n)),new Qf(jd.min(),r,new bh(Wd),Hp(),tf())}}class Jf{constructor(e,t,n,r,a){this.resumeToken=e,this.current=t,this.addedDocuments=n,this.modifiedDocuments=r,this.removedDocuments=a}static createSynthesizedTargetChangeForCurrentChange(e,t,n){return new Jf(n,t,tf(),tf(),tf())}}class Zf{constructor(e,t,n,r){this.Re=e,this.removedTargetIds=t,this.key=n,this.Ve=r}}class em{constructor(e,t){this.targetId=e,this.me=t}}class tm{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ch.EMPTY_BYTE_STRING,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;this.state=e,this.targetIds=t,this.resumeToken=n,this.cause=r}}class nm{constructor(){this.fe=0,this.ge=sm(),this.pe=Ch.EMPTY_BYTE_STRING,this.ye=!1,this.we=!0}get current(){return this.ye}get resumeToken(){return this.pe}get Se(){return 0!==this.fe}get be(){return this.we}De(e){e.approximateByteSize()>0&&(this.we=!0,this.pe=e)}ve(){let e=tf(),t=tf(),n=tf();return this.ge.forEach(((r,a)=>{switch(a){case 0:e=e.add(r);break;case 2:t=t.add(r);break;case 1:n=n.add(r);break;default:Cd()}})),new Jf(this.pe,this.ye,e,t,n)}Ce(){this.we=!1,this.ge=sm()}Fe(e,t){this.we=!0,this.ge=this.ge.insert(e,t)}Me(e){this.we=!0,this.ge=this.ge.remove(e)}xe(){this.fe+=1}Oe(){this.fe-=1,Nd(this.fe>=0)}Ne(){this.we=!0,this.ye=!0}}class rm{constructor(e){this.Le=e,this.Be=new Map,this.ke=Hp(),this.qe=am(),this.Qe=new bh(Wd)}Ke(e){for(const t of e.Re)e.Ve&&e.Ve.isFoundDocument()?this.$e(t,e.Ve):this.Ue(t,e.key,e.Ve);for(const t of e.removedTargetIds)this.Ue(t,e.key,e.Ve)}We(e){this.forEachTarget(e,(t=>{const n=this.Ge(t);switch(e.state){case 0:this.ze(t)&&n.De(e.resumeToken);break;case 1:n.Oe(),n.Se||n.Ce(),n.De(e.resumeToken);break;case 2:n.Oe(),n.Se||this.removeTarget(t);break;case 3:this.ze(t)&&(n.Ne(),n.De(e.resumeToken));break;case 4:this.ze(t)&&(this.je(t),n.De(e.resumeToken));break;default:Cd()}}))}forEachTarget(e,t){e.targetIds.length>0?e.targetIds.forEach(t):this.Be.forEach(((e,n)=>{this.ze(n)&&t(n)}))}He(e){const t=e.targetId,n=e.me.count,r=this.Je(t);if(r){const a=r.target;if(Tp(a))if(0===n){const e=new Xd(a.path);this.Ue(t,e,ep.newNoDocument(e,jd.min()))}else Nd(1===n);else{const r=this.Ye(t);if(r!==n){const n=this.Ze(e),a=n?this.Xe(n,e,r):1;if(0!==a){this.je(t);const e=2===a?"TargetPurposeExistenceFilterMismatchBloom":"TargetPurposeExistenceFilterMismatch";this.Qe=this.Qe.insert(t,e)}null==jf||jf.et(function(e,t,n,r,a){var s,i,o,l,u,c;const d={localCacheCount:e,existenceFilterCount:t.count,databaseId:n.database,projectId:n.projectId},h=t.unchangedNames;return h&&(d.bloomFilter={applied:0===a,hashCount:null!==(s=null==h?void 0:h.hashCount)&&void 0!==s?s:0,bitmapLength:null!==(l=null===(o=null===(i=null==h?void 0:h.bits)||void 0===i?void 0:i.bitmap)||void 0===o?void 0:o.length)&&void 0!==l?l:0,padding:null!==(c=null===(u=null==h?void 0:h.bits)||void 0===u?void 0:u.padding)&&void 0!==c?c:0,mightContain:e=>{var t;return null!==(t=null==r?void 0:r.mightContain(e))&&void 0!==t&&t}}),d}(r,e.me,this.Le.tt(),n,a))}}}}Ze(e){const t=e.me.unchangedNames;if(!t||!t.bits)return null;const{bits:{bitmap:n="",padding:r=0},hashCount:a=0}=t;let s,i;try{s=Ah(n).toUint8Array()}catch(e){if(e instanceof Ih)return Sd("Decoding the base64 bloom filter in existence filter failed ("+e.message+"); ignoring the bloom filter and falling back to full re-query."),null;throw e}try{i=new Xf(s,r,a)}catch(e){return Sd(e instanceof Yf?"BloomFilter error: ":"Applying bloom filter failed: ",e),null}return 0===i.Ie?null:i}Xe(e,t,n){return t.me.count===n-this.nt(e,t.targetId)?0:2}nt(e,t){const n=this.Le.getRemoteKeysForTarget(t);let r=0;return n.forEach((n=>{const a=this.Le.tt(),s=`projects/${a.projectId}/databases/${a.database}/documents/${n.path.canonicalString()}`;e.mightContain(s)||(this.Ue(t,n,null),r++)})),r}rt(e){const t=new Map;this.Be.forEach(((n,r)=>{const a=this.Je(r);if(a){if(n.current&&Tp(a.target)){const t=new Xd(a.target.path);null!==this.ke.get(t)||this.it(r,t)||this.Ue(r,t,ep.newNoDocument(t,e))}n.be&&(t.set(r,n.ve()),n.Ce())}}));let n=tf();this.qe.forEach(((e,t)=>{let r=!0;t.forEachWhile((e=>{const t=this.Je(e);return!t||"TargetPurposeLimboResolution"===t.purpose||(r=!1,!1)})),r&&(n=n.add(e))})),this.ke.forEach(((t,n)=>n.setReadTime(e)));const r=new Qf(e,t,this.Qe,this.ke,n);return this.ke=Hp(),this.qe=am(),this.Qe=new bh(Wd),r}$e(e,t){if(!this.ze(e))return;const n=this.it(e,t.key)?2:0;this.Ge(e).Fe(t.key,n),this.ke=this.ke.insert(t.key,t),this.qe=this.qe.insert(t.key,this.st(t.key).add(e))}Ue(e,t,n){if(!this.ze(e))return;const r=this.Ge(e);this.it(e,t)?r.Fe(t,1):r.Me(t),this.qe=this.qe.insert(t,this.st(t).delete(e)),n&&(this.ke=this.ke.insert(t,n))}removeTarget(e){this.Be.delete(e)}Ye(e){const t=this.Ge(e).ve();return this.Le.getRemoteKeysForTarget(e).size+t.addedDocuments.size-t.removedDocuments.size}xe(e){this.Ge(e).xe()}Ge(e){let t=this.Be.get(e);return t||(t=new nm,this.Be.set(e,t)),t}st(e){let t=this.qe.get(e);return t||(t=new wh(Wd),this.qe=this.qe.insert(e,t)),t}ze(e){const t=null!==this.Je(e);return t||wd("WatchChangeAggregator","Detected inactive target",e),t}Je(e){const t=this.Be.get(e);return t&&t.Se?null:this.Le.ot(e)}je(e){this.Be.set(e,new nm),this.Le.getRemoteKeysForTarget(e).forEach((t=>{this.Ue(e,t,null)}))}it(e,t){return this.Le.getRemoteKeysForTarget(e).has(t)}}function am(){return new bh(Xd.comparator)}function sm(){return new bh(Xd.comparator)}const im={asc:"ASCENDING",desc:"DESCENDING"},om={"<":"LESS_THAN","<=":"LESS_THAN_OR_EQUAL",">":"GREATER_THAN",">=":"GREATER_THAN_OR_EQUAL","==":"EQUAL","!=":"NOT_EQUAL","array-contains":"ARRAY_CONTAINS",in:"IN","not-in":"NOT_IN","array-contains-any":"ARRAY_CONTAINS_ANY"},lm={and:"AND",or:"OR"};class um{constructor(e,t){this.databaseId=e,this.useProto3Json=t}}function cm(e,t){return e.useProto3Json||lh(t)?t:{value:t}}function dm(e,t){return e.useProto3Json?`${new Date(1e3*t.seconds).toISOString().replace(/\.\d*/,"").replace("Z","")}.${("000000000"+t.nanoseconds).slice(-9)}Z`:{seconds:""+t.seconds,nanos:t.nanoseconds}}function hm(e,t){return e.useProto3Json?t.toBase64():t.toUint8Array()}function pm(e,t){return dm(e,t.toTimestamp())}function fm(e){return Nd(!!e),jd.fromTimestamp(function(e){const t=Th(e);return new Ud(t.seconds,t.nanos)}(e))}function mm(e,t){return gm(e,t).canonicalString()}function gm(e,t){const n=function(e){return new Hd(["projects",e.projectId,"databases",e.database])}(e).child("documents");return void 0===t?n:n.child(t)}function ym(e){const t=Hd.fromString(e);return Nd(Pm(t)),t}function bm(e,t){return mm(e.databaseId,t.path)}function vm(e,t){const n=ym(t);if(n.get(1)!==e.databaseId.projectId)throw new Ad(Ed.INVALID_ARGUMENT,"Tried to deserialize key from different project: "+n.get(1)+" vs "+e.databaseId.projectId);if(n.get(3)!==e.databaseId.database)throw new Ad(Ed.INVALID_ARGUMENT,"Tried to deserialize key from different database: "+n.get(3)+" vs "+e.databaseId.database);return new Xd(Sm(n))}function xm(e,t){return mm(e.databaseId,t)}function wm(e){const t=ym(e);return 4===t.length?Hd.emptyPath():Sm(t)}function km(e){return new Hd(["projects",e.databaseId.projectId,"databases",e.databaseId.database]).canonicalString()}function Sm(e){return Nd(e.length>4&&"documents"===e.get(4)),e.popFirst(5)}function Im(e,t,n){return{name:bm(e,t),fields:n.value.mapValue.fields}}function Cm(e,t){let n;if(t instanceof Af)n={update:Im(e,t.key,t.value)};else if(t instanceof Mf)n={delete:bm(e,t.key)};else if(t instanceof _f)n={update:Im(e,t.key,t.data),updateMask:Om(t.fieldMask)};else{if(!(t instanceof Ff))return Cd();n={verify:bm(e,t.key)}}return t.fieldTransforms.length>0&&(n.updateTransforms=t.fieldTransforms.map((e=>function(e,t){const n=t.transform;if(n instanceof hf)return{fieldPath:t.field.canonicalString(),setToServerValue:"REQUEST_TIME"};if(n instanceof pf)return{fieldPath:t.field.canonicalString(),appendMissingElements:{values:n.elements}};if(n instanceof mf)return{fieldPath:t.field.canonicalString(),removeAllFromArray:{values:n.elements}};if(n instanceof yf)return{fieldPath:t.field.canonicalString(),increment:n.Pe};throw Cd()}(0,e)))),t.precondition.isNone||(n.currentDocument=function(e,t){return void 0!==t.updateTime?{updateTime:pm(e,t.updateTime)}:void 0!==t.exists?{exists:t.exists}:Cd()}(e,t.precondition)),n}function Nm(e,t){return{documents:[xm(e,t.path)]}}function Tm(e,t){const n={structuredQuery:{}},r=t.path;let a;null!==t.collectionGroup?(a=r,n.structuredQuery.from=[{collectionId:t.collectionGroup,allDescendants:!0}]):(a=r.popLast(),n.structuredQuery.from=[{collectionId:r.lastSegment()}]),n.parent=xm(e,a);const s=function(e){if(0!==e.length)return Fm(lp.create(e,"and"))}(t.filters);s&&(n.structuredQuery.where=s);const i=function(e){if(0!==e.length)return e.map((e=>function(e){return{field:Dm(e.field),direction:_m(e.dir)}}(e)))}(t.orderBy);i&&(n.structuredQuery.orderBy=i);const o=cm(e,t.limit);return null!==o&&(n.structuredQuery.limit=o),t.startAt&&(n.structuredQuery.startAt=function(e){return{before:e.inclusive,values:e.position}}(t.startAt)),t.endAt&&(n.structuredQuery.endAt=function(e){return{before:!e.inclusive,values:e.position}}(t.endAt)),{_t:n,parent:a}}function Em(e){let t=wm(e.parent);const n=e.structuredQuery,r=n.from?n.from.length:0;let a=null;if(r>0){Nd(1===r);const e=n.from[0];e.allDescendants?a=e.collectionId:t=t.child(e.collectionId)}let s=[];n.where&&(s=function(e){const t=Am(e);return t instanceof lp&&cp(t)?t.getFilters():[t]}(n.where));let i=[];n.orderBy&&(i=function(e){return e.map((e=>function(e){return new ap(Mm(e.field),function(e){switch(e){case"ASCENDING":return"asc";case"DESCENDING":return"desc";default:return}}(e.direction))}(e)))}(n.orderBy));let o=null;n.limit&&(o=function(e){let t;return t="object"==typeof e?e.value:e,lh(t)?null:t}(n.limit));let l=null;n.startAt&&(l=function(e){const t=!!e.before,n=e.values||[];return new tp(n,t)}(n.startAt));let u=null;return n.endAt&&(u=function(e){const t=!e.before,n=e.values||[];return new tp(n,t)}(n.endAt)),Ap(t,a,i,s,o,"F",l,u)}function Am(e){return void 0!==e.unaryFilter?function(e){switch(e.unaryFilter.op){case"IS_NAN":const t=Mm(e.unaryFilter.field);return op.create(t,"==",{doubleValue:NaN});case"IS_NULL":const n=Mm(e.unaryFilter.field);return op.create(n,"==",{nullValue:"NULL_VALUE"});case"IS_NOT_NAN":const r=Mm(e.unaryFilter.field);return op.create(r,"!=",{doubleValue:NaN});case"IS_NOT_NULL":const a=Mm(e.unaryFilter.field);return op.create(a,"!=",{nullValue:"NULL_VALUE"});default:return Cd()}}(e):void 0!==e.fieldFilter?function(e){return op.create(Mm(e.fieldFilter.field),function(e){switch(e){case"EQUAL":return"==";case"NOT_EQUAL":return"!=";case"GREATER_THAN":return">";case"GREATER_THAN_OR_EQUAL":return">=";case"LESS_THAN":return"<";case"LESS_THAN_OR_EQUAL":return"<=";case"ARRAY_CONTAINS":return"array-contains";case"IN":return"in";case"NOT_IN":return"not-in";case"ARRAY_CONTAINS_ANY":return"array-contains-any";default:return Cd()}}(e.fieldFilter.op),e.fieldFilter.value)}(e):void 0!==e.compositeFilter?function(e){return lp.create(e.compositeFilter.filters.map((e=>Am(e))),function(e){switch(e){case"AND":return"and";case"OR":return"or";default:return Cd()}}(e.compositeFilter.op))}(e):Cd()}function _m(e){return im[e]}function $m(e){return om[e]}function Rm(e){return lm[e]}function Dm(e){return{fieldPath:e.canonicalString()}}function Mm(e){return Kd.fromServerFormat(e.fieldPath)}function Fm(e){return e instanceof op?function(e){if("=="===e.op){if(qh(e.value))return{unaryFilter:{field:Dm(e.field),op:"IS_NAN"}};if(Hh(e.value))return{unaryFilter:{field:Dm(e.field),op:"IS_NULL"}}}else if("!="===e.op){if(qh(e.value))return{unaryFilter:{field:Dm(e.field),op:"IS_NOT_NAN"}};if(Hh(e.value))return{unaryFilter:{field:Dm(e.field),op:"IS_NOT_NULL"}}}return{fieldFilter:{field:Dm(e.field),op:$m(e.op),value:e.value}}}(e):e instanceof lp?function(e){const t=e.getFilters().map((e=>Fm(e)));return 1===t.length?t[0]:{compositeFilter:{op:Rm(e.op),filters:t}}}(e):Cd()}function Om(e){const t=[];return e.fields.forEach((e=>t.push(e.canonicalString()))),{fieldPaths:t}}function Pm(e){return e.length>=4&&"projects"===e.get(0)&&"databases"===e.get(2)}class Lm{constructor(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:jd.min(),s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:jd.min(),i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:Ch.EMPTY_BYTE_STRING,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;this.target=e,this.targetId=t,this.purpose=n,this.sequenceNumber=r,this.snapshotVersion=a,this.lastLimboFreeSnapshotVersion=s,this.resumeToken=i,this.expectedCount=o}withSequenceNumber(e){return new Lm(this.target,this.targetId,this.purpose,e,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,this.expectedCount)}withResumeToken(e,t){return new Lm(this.target,this.targetId,this.purpose,this.sequenceNumber,t,this.lastLimboFreeSnapshotVersion,e,null)}withExpectedCount(e){return new Lm(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,e)}withLastLimboFreeSnapshotVersion(e){return new Lm(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,e,this.resumeToken,this.expectedCount)}}class zm{constructor(e){this.ct=e}}function Bm(e){const t=Em({parent:e.parent,structuredQuery:e.structuredQuery});return"LAST"===e.limitType?Op(t,t.limit,"L"):t}class Wm{constructor(){}It(e,t){this.Tt(e,t),t.Et()}Tt(e,t){if("nullValue"in e)this.dt(t,5);else if("booleanValue"in e)this.dt(t,10),t.At(e.booleanValue?1:0);else if("integerValue"in e)this.dt(t,15),t.At(Eh(e.integerValue));else if("doubleValue"in e){const n=Eh(e.doubleValue);isNaN(n)?this.dt(t,13):(this.dt(t,15),uh(n)?t.At(0):t.At(n))}else if("timestampValue"in e){let n=e.timestampValue;this.dt(t,20),"string"==typeof n&&(n=Th(n)),t.Rt(`${n.seconds||""}`),t.At(n.nanos||0)}else if("stringValue"in e)this.Vt(e.stringValue,t),this.ft(t);else if("bytesValue"in e)this.dt(t,30),t.gt(Ah(e.bytesValue)),this.ft(t);else if("referenceValue"in e)this.yt(e.referenceValue,t);else if("geoPointValue"in e){const n=e.geoPointValue;this.dt(t,45),t.At(n.latitude||0),t.At(n.longitude||0)}else"mapValue"in e?Qh(e)?this.dt(t,Number.MAX_SAFE_INTEGER):Xh(e)?this.wt(e.mapValue,t):(this.St(e.mapValue,t),this.ft(t)):"arrayValue"in e?(this.bt(e.arrayValue,t),this.ft(t)):Cd()}Vt(e,t){this.dt(t,25),this.Dt(e,t)}Dt(e,t){t.Rt(e)}St(e,t){const n=e.fields||{};this.dt(t,55);for(const r of Object.keys(n))this.Vt(r,t),this.Tt(n[r],t)}wt(e,t){var n,r;const a=e.fields||{};this.dt(t,53);const s="value",i=(null===(r=null===(n=a[s].arrayValue)||void 0===n?void 0:n.values)||void 0===r?void 0:r.length)||0;this.dt(t,15),t.At(Eh(i)),this.Vt(s,t),this.Tt(a[s],t)}bt(e,t){const n=e.values||[];this.dt(t,50);for(const r of n)this.Tt(r,t)}yt(e,t){this.dt(t,37),Xd.fromName(e).path.forEach((e=>{this.dt(t,60),this.Dt(e,t)}))}dt(e,t){e.At(t)}ft(e){e.At(2)}}Wm.vt=new Wm;class Vm{constructor(){this.un=new Um}addToCollectionParentIndex(e,t){return this.un.add(t),ah.resolve()}getCollectionParents(e,t){return ah.resolve(this.un.getEntries(t))}addFieldIndex(e,t){return ah.resolve()}deleteFieldIndex(e,t){return ah.resolve()}deleteAllFieldIndexes(e){return ah.resolve()}createTargetIndexes(e,t){return ah.resolve()}getDocumentsMatchingTarget(e,t){return ah.resolve(null)}getIndexType(e,t){return ah.resolve(0)}getFieldIndexes(e,t){return ah.resolve([])}getNextCollectionGroupToUpdate(e){return ah.resolve(null)}getMinOffset(e,t){return ah.resolve(Zd.min())}getMinOffsetFromCollectionGroup(e,t){return ah.resolve(Zd.min())}updateCollectionGroup(e,t,n){return ah.resolve()}updateIndexEntries(e,t){return ah.resolve()}}class Um{constructor(){this.index={}}add(e){const t=e.lastSegment(),n=e.popLast(),r=this.index[t]||new wh(Hd.comparator),a=!r.has(n);return this.index[t]=r.add(n),a}has(e){const t=e.lastSegment(),n=e.popLast(),r=this.index[t];return r&&r.has(n)}getEntries(e){return(this.index[e]||new wh(Hd.comparator)).toArray()}}new Uint8Array(0);class jm{constructor(e,t,n){this.cacheSizeCollectionThreshold=e,this.percentileToCollect=t,this.maximumSequenceNumbersToCollect=n}static withCacheSize(e){return new jm(e,jm.DEFAULT_COLLECTION_PERCENTILE,jm.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)}}jm.DEFAULT_COLLECTION_PERCENTILE=10,jm.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT=1e3,jm.DEFAULT=new jm(41943040,jm.DEFAULT_COLLECTION_PERCENTILE,jm.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT),jm.DISABLED=new jm(-1,0,0);class Gm{constructor(e){this.Ln=e}next(){return this.Ln+=2,this.Ln}static Bn(){return new Gm(0)}static kn(){return new Gm(-1)}}class Hm{constructor(){this.changes=new jp((e=>e.toString()),((e,t)=>e.isEqual(t))),this.changesApplied=!1}addEntry(e){this.assertNotApplied(),this.changes.set(e.key,e)}removeEntry(e,t){this.assertNotApplied(),this.changes.set(e,ep.newInvalidDocument(e).setReadTime(t))}getEntry(e,t){this.assertNotApplied();const n=this.changes.get(t);return void 0!==n?ah.resolve(n):this.getFromCache(e,t)}getEntries(e,t){return this.getAllFromCache(e,t)}apply(e){return this.assertNotApplied(),this.changesApplied=!0,this.applyChanges(e)}assertNotApplied(){}}class qm{constructor(e,t){this.overlayedDocument=e,this.mutatedFields=t}}class Km{constructor(e,t,n,r){this.remoteDocumentCache=e,this.mutationQueue=t,this.documentOverlayCache=n,this.indexManager=r}getDocument(e,t){let n=null;return this.documentOverlayCache.getOverlay(e,t).next((r=>(n=r,this.remoteDocumentCache.getEntry(e,t)))).next((e=>(null!==n&&Nf(n.mutation,e,Sh.empty(),Ud.now()),e)))}getDocuments(e,t){return this.remoteDocumentCache.getEntries(e,t).next((t=>this.getLocalViewOfDocuments(e,t,tf()).next((()=>t))))}getLocalViewOfDocuments(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:tf();const r=Yp();return this.populateOverlays(e,r,t).next((()=>this.computeViews(e,t,r,n).next((e=>{let t=Kp();return e.forEach(((e,n)=>{t=t.insert(e,n.overlayedDocument)})),t}))))}getOverlayedDocuments(e,t){const n=Yp();return this.populateOverlays(e,n,t).next((()=>this.computeViews(e,t,n,tf())))}populateOverlays(e,t,n){const r=[];return n.forEach((e=>{t.has(e)||r.push(e)})),this.documentOverlayCache.getOverlays(e,r).next((e=>{e.forEach(((e,n)=>{t.set(e,n)}))}))}computeViews(e,t,n,r){let a=Hp();const s=Jp(),i=Jp();return t.forEach(((e,t)=>{const i=n.get(t.key);r.has(t.key)&&(void 0===i||i.mutation instanceof _f)?a=a.insert(t.key,t):void 0!==i?(s.set(t.key,i.mutation.getFieldMask()),Nf(i.mutation,t,i.mutation.getFieldMask(),Ud.now())):s.set(t.key,Sh.empty())})),this.recalculateAndSaveOverlays(e,a).next((e=>(e.forEach(((e,t)=>s.set(e,t))),t.forEach(((e,t)=>{var n;return i.set(e,new qm(t,null!==(n=s.get(e))&&void 0!==n?n:null))})),i)))}recalculateAndSaveOverlays(e,t){const n=Jp();let r=new bh(((e,t)=>e-t)),a=tf();return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e,t).next((e=>{for(const a of e)a.keys().forEach((e=>{const s=t.get(e);if(null===s)return;let i=n.get(e)||Sh.empty();i=a.applyToLocalView(s,i),n.set(e,i);const o=(r.get(a.batchId)||tf()).add(e);r=r.insert(a.batchId,o)}))})).next((()=>{const s=[],i=r.getReverseIterator();for(;i.hasNext();){const r=i.getNext(),o=r.key,l=r.value,u=Qp();l.forEach((e=>{if(!a.has(e)){const r=If(t.get(e),n.get(e));null!==r&&u.set(e,r),a=a.add(e)}})),s.push(this.documentOverlayCache.saveOverlays(e,o,u))}return ah.waitFor(s)})).next((()=>n))}recalculateAndSaveOverlaysForDocumentKeys(e,t){return this.remoteDocumentCache.getEntries(e,t).next((t=>this.recalculateAndSaveOverlays(e,t)))}getDocumentsMatchingQuery(e,t,n,r){return function(e){return Xd.isDocumentKey(e.path)&&null===e.collectionGroup&&0===e.filters.length}(t)?this.getDocumentsMatchingDocumentQuery(e,t.path):Rp(t)?this.getDocumentsMatchingCollectionGroupQuery(e,t,n,r):this.getDocumentsMatchingCollectionQuery(e,t,n,r)}getNextDocuments(e,t,n,r){return this.remoteDocumentCache.getAllFromCollectionGroup(e,t,n,r).next((a=>{const s=r-a.size>0?this.documentOverlayCache.getOverlaysForCollectionGroup(e,t,n.largestBatchId,r-a.size):ah.resolve(Yp());let i=-1,o=a;return s.next((t=>ah.forEach(t,((t,n)=>(i<n.largestBatchId&&(i=n.largestBatchId),a.get(t)?ah.resolve():this.remoteDocumentCache.getEntry(e,t).next((e=>{o=o.insert(t,e)}))))).next((()=>this.populateOverlays(e,t,a))).next((()=>this.computeViews(e,o,t,tf()))).next((e=>({batchId:i,changes:Xp(e)})))))}))}getDocumentsMatchingDocumentQuery(e,t){return this.getDocument(e,new Xd(t)).next((e=>{let t=Kp();return e.isFoundDocument()&&(t=t.insert(e.key,e)),t}))}getDocumentsMatchingCollectionGroupQuery(e,t,n,r){const a=t.collectionGroup;let s=Kp();return this.indexManager.getCollectionParents(e,a).next((i=>ah.forEach(i,(i=>{const o=function(e,t){return new Ep(t,null,e.explicitOrderBy.slice(),e.filters.slice(),e.limit,e.limitType,e.startAt,e.endAt)}(t,i.child(a));return this.getDocumentsMatchingCollectionQuery(e,o,n,r).next((e=>{e.forEach(((e,t)=>{s=s.insert(e,t)}))}))})).next((()=>s))))}getDocumentsMatchingCollectionQuery(e,t,n,r){let a;return this.documentOverlayCache.getOverlaysForCollection(e,t.path,n.largestBatchId).next((s=>(a=s,this.remoteDocumentCache.getDocumentsMatchingQuery(e,t,n,a,r)))).next((e=>{a.forEach(((t,n)=>{const r=n.getKey();null===e.get(r)&&(e=e.insert(r,ep.newInvalidDocument(r)))}));let n=Kp();return e.forEach(((e,r)=>{const s=a.get(e);void 0!==s&&Nf(s.mutation,r,Sh.empty(),Ud.now()),Bp(t,r)&&(n=n.insert(e,r))})),n}))}}class Xm{constructor(e){this.serializer=e,this.hr=new Map,this.Pr=new Map}getBundleMetadata(e,t){return ah.resolve(this.hr.get(t))}saveBundleMetadata(e,t){return this.hr.set(t.id,function(e){return{id:e.id,version:e.version,createTime:fm(e.createTime)}}(t)),ah.resolve()}getNamedQuery(e,t){return ah.resolve(this.Pr.get(t))}saveNamedQuery(e,t){return this.Pr.set(t.name,function(e){return{name:e.name,query:Bm(e.bundledQuery),readTime:fm(e.readTime)}}(t)),ah.resolve()}}class Ym{constructor(){this.overlays=new bh(Xd.comparator),this.Ir=new Map}getOverlay(e,t){return ah.resolve(this.overlays.get(t))}getOverlays(e,t){const n=Yp();return ah.forEach(t,(t=>this.getOverlay(e,t).next((e=>{null!==e&&n.set(t,e)})))).next((()=>n))}saveOverlays(e,t,n){return n.forEach(((n,r)=>{this.ht(e,t,r)})),ah.resolve()}removeOverlaysForBatchId(e,t,n){const r=this.Ir.get(n);return void 0!==r&&(r.forEach((e=>this.overlays=this.overlays.remove(e))),this.Ir.delete(n)),ah.resolve()}getOverlaysForCollection(e,t,n){const r=Yp(),a=t.length+1,s=new Xd(t.child("")),i=this.overlays.getIteratorFrom(s);for(;i.hasNext();){const e=i.getNext().value,s=e.getKey();if(!t.isPrefixOf(s.path))break;s.path.length===a&&e.largestBatchId>n&&r.set(e.getKey(),e)}return ah.resolve(r)}getOverlaysForCollectionGroup(e,t,n,r){let a=new bh(((e,t)=>e-t));const s=this.overlays.getIterator();for(;s.hasNext();){const e=s.getNext().value;if(e.getKey().getCollectionGroup()===t&&e.largestBatchId>n){let t=a.get(e.largestBatchId);null===t&&(t=Yp(),a=a.insert(e.largestBatchId,t)),t.set(e.getKey(),e)}}const i=Yp(),o=a.getIterator();for(;o.hasNext()&&(o.getNext().value.forEach(((e,t)=>i.set(e,t))),!(i.size()>=r)););return ah.resolve(i)}ht(e,t,n){const r=this.overlays.get(n.key);if(null!==r){const e=this.Ir.get(r.largestBatchId).delete(n.key);this.Ir.set(r.largestBatchId,e)}this.overlays=this.overlays.insert(n.key,new Lf(t,n));let a=this.Ir.get(t);void 0===a&&(a=tf(),this.Ir.set(t,a)),this.Ir.set(t,a.add(n.key))}}class Qm{constructor(){this.sessionToken=Ch.EMPTY_BYTE_STRING}getSessionToken(e){return ah.resolve(this.sessionToken)}setSessionToken(e,t){return this.sessionToken=t,ah.resolve()}}class Jm{constructor(){this.Tr=new wh(Zm.Er),this.dr=new wh(Zm.Ar)}isEmpty(){return this.Tr.isEmpty()}addReference(e,t){const n=new Zm(e,t);this.Tr=this.Tr.add(n),this.dr=this.dr.add(n)}Rr(e,t){e.forEach((e=>this.addReference(e,t)))}removeReference(e,t){this.Vr(new Zm(e,t))}mr(e,t){e.forEach((e=>this.removeReference(e,t)))}gr(e){const t=new Xd(new Hd([])),n=new Zm(t,e),r=new Zm(t,e+1),a=[];return this.dr.forEachInRange([n,r],(e=>{this.Vr(e),a.push(e.key)})),a}pr(){this.Tr.forEach((e=>this.Vr(e)))}Vr(e){this.Tr=this.Tr.delete(e),this.dr=this.dr.delete(e)}yr(e){const t=new Xd(new Hd([])),n=new Zm(t,e),r=new Zm(t,e+1);let a=tf();return this.dr.forEachInRange([n,r],(e=>{a=a.add(e.key)})),a}containsKey(e){const t=new Zm(e,0),n=this.Tr.firstAfterOrEqual(t);return null!==n&&e.isEqual(n.key)}}class Zm{constructor(e,t){this.key=e,this.wr=t}static Er(e,t){return Xd.comparator(e.key,t.key)||Wd(e.wr,t.wr)}static Ar(e,t){return Wd(e.wr,t.wr)||Xd.comparator(e.key,t.key)}}class eg{constructor(e,t){this.indexManager=e,this.referenceDelegate=t,this.mutationQueue=[],this.Sr=1,this.br=new wh(Zm.Er)}checkEmpty(e){return ah.resolve(0===this.mutationQueue.length)}addMutationBatch(e,t,n,r){const a=this.Sr;this.Sr++,this.mutationQueue.length>0&&this.mutationQueue[this.mutationQueue.length-1];const s=new Of(a,t,n,r);this.mutationQueue.push(s);for(const i of r)this.br=this.br.add(new Zm(i.key,a)),this.indexManager.addToCollectionParentIndex(e,i.key.path.popLast());return ah.resolve(s)}lookupMutationBatch(e,t){return ah.resolve(this.Dr(t))}getNextMutationBatchAfterBatchId(e,t){const n=t+1,r=this.vr(n),a=r<0?0:r;return ah.resolve(this.mutationQueue.length>a?this.mutationQueue[a]:null)}getHighestUnacknowledgedBatchId(){return ah.resolve(0===this.mutationQueue.length?-1:this.Sr-1)}getAllMutationBatches(e){return ah.resolve(this.mutationQueue.slice())}getAllMutationBatchesAffectingDocumentKey(e,t){const n=new Zm(t,0),r=new Zm(t,Number.POSITIVE_INFINITY),a=[];return this.br.forEachInRange([n,r],(e=>{const t=this.Dr(e.wr);a.push(t)})),ah.resolve(a)}getAllMutationBatchesAffectingDocumentKeys(e,t){let n=new wh(Wd);return t.forEach((e=>{const t=new Zm(e,0),r=new Zm(e,Number.POSITIVE_INFINITY);this.br.forEachInRange([t,r],(e=>{n=n.add(e.wr)}))})),ah.resolve(this.Cr(n))}getAllMutationBatchesAffectingQuery(e,t){const n=t.path,r=n.length+1;let a=n;Xd.isDocumentKey(a)||(a=a.child(""));const s=new Zm(new Xd(a),0);let i=new wh(Wd);return this.br.forEachWhile((e=>{const t=e.key.path;return!!n.isPrefixOf(t)&&(t.length===r&&(i=i.add(e.wr)),!0)}),s),ah.resolve(this.Cr(i))}Cr(e){const t=[];return e.forEach((e=>{const n=this.Dr(e);null!==n&&t.push(n)})),t}removeMutationBatch(e,t){Nd(0===this.Fr(t.batchId,"removed")),this.mutationQueue.shift();let n=this.br;return ah.forEach(t.mutations,(r=>{const a=new Zm(r.key,t.batchId);return n=n.delete(a),this.referenceDelegate.markPotentiallyOrphaned(e,r.key)})).next((()=>{this.br=n}))}On(e){}containsKey(e,t){const n=new Zm(t,0),r=this.br.firstAfterOrEqual(n);return ah.resolve(t.isEqual(r&&r.key))}performConsistencyCheck(e){return this.mutationQueue.length,ah.resolve()}Fr(e,t){return this.vr(e)}vr(e){return 0===this.mutationQueue.length?0:e-this.mutationQueue[0].batchId}Dr(e){const t=this.vr(e);return t<0||t>=this.mutationQueue.length?null:this.mutationQueue[t]}}class tg{constructor(e){this.Mr=e,this.docs=new bh(Xd.comparator),this.size=0}setIndexManager(e){this.indexManager=e}addEntry(e,t){const n=t.key,r=this.docs.get(n),a=r?r.size:0,s=this.Mr(t);return this.docs=this.docs.insert(n,{document:t.mutableCopy(),size:s}),this.size+=s-a,this.indexManager.addToCollectionParentIndex(e,n.path.popLast())}removeEntry(e){const t=this.docs.get(e);t&&(this.docs=this.docs.remove(e),this.size-=t.size)}getEntry(e,t){const n=this.docs.get(t);return ah.resolve(n?n.document.mutableCopy():ep.newInvalidDocument(t))}getEntries(e,t){let n=Hp();return t.forEach((e=>{const t=this.docs.get(e);n=n.insert(e,t?t.document.mutableCopy():ep.newInvalidDocument(e))})),ah.resolve(n)}getDocumentsMatchingQuery(e,t,n,r){let a=Hp();const s=t.path,i=new Xd(s.child("")),o=this.docs.getIteratorFrom(i);for(;o.hasNext();){const{key:e,value:{document:i}}=o.getNext();if(!s.isPrefixOf(e.path))break;e.path.length>s.length+1||eh(Jd(i),n)<=0||(r.has(i.key)||Bp(t,i))&&(a=a.insert(i.key,i.mutableCopy()))}return ah.resolve(a)}getAllFromCollectionGroup(e,t,n,r){Cd()}Or(e,t){return ah.forEach(this.docs,(e=>t(e)))}newChangeBuffer(e){return new ng(this)}getSize(e){return ah.resolve(this.size)}}class ng extends Hm{constructor(e){super(),this.cr=e}applyChanges(e){const t=[];return this.changes.forEach(((n,r)=>{r.isValidDocument()?t.push(this.cr.addEntry(e,r)):this.cr.removeEntry(n)})),ah.waitFor(t)}getFromCache(e,t){return this.cr.getEntry(e,t)}getAllFromCache(e,t){return this.cr.getEntries(e,t)}}class rg{constructor(e){this.persistence=e,this.Nr=new jp((e=>Cp(e)),Np),this.lastRemoteSnapshotVersion=jd.min(),this.highestTargetId=0,this.Lr=0,this.Br=new Jm,this.targetCount=0,this.kr=Gm.Bn()}forEachTarget(e,t){return this.Nr.forEach(((e,n)=>t(n))),ah.resolve()}getLastRemoteSnapshotVersion(e){return ah.resolve(this.lastRemoteSnapshotVersion)}getHighestSequenceNumber(e){return ah.resolve(this.Lr)}allocateTargetId(e){return this.highestTargetId=this.kr.next(),ah.resolve(this.highestTargetId)}setTargetsMetadata(e,t,n){return n&&(this.lastRemoteSnapshotVersion=n),t>this.Lr&&(this.Lr=t),ah.resolve()}Kn(e){this.Nr.set(e.target,e);const t=e.targetId;t>this.highestTargetId&&(this.kr=new Gm(t),this.highestTargetId=t),e.sequenceNumber>this.Lr&&(this.Lr=e.sequenceNumber)}addTargetData(e,t){return this.Kn(t),this.targetCount+=1,ah.resolve()}updateTargetData(e,t){return this.Kn(t),ah.resolve()}removeTargetData(e,t){return this.Nr.delete(t.target),this.Br.gr(t.targetId),this.targetCount-=1,ah.resolve()}removeTargets(e,t,n){let r=0;const a=[];return this.Nr.forEach(((s,i)=>{i.sequenceNumber<=t&&null===n.get(i.targetId)&&(this.Nr.delete(s),a.push(this.removeMatchingKeysForTargetId(e,i.targetId)),r++)})),ah.waitFor(a).next((()=>r))}getTargetCount(e){return ah.resolve(this.targetCount)}getTargetData(e,t){const n=this.Nr.get(t)||null;return ah.resolve(n)}addMatchingKeys(e,t,n){return this.Br.Rr(t,n),ah.resolve()}removeMatchingKeys(e,t,n){this.Br.mr(t,n);const r=this.persistence.referenceDelegate,a=[];return r&&t.forEach((t=>{a.push(r.markPotentiallyOrphaned(e,t))})),ah.waitFor(a)}removeMatchingKeysForTargetId(e,t){return this.Br.gr(t),ah.resolve()}getMatchingKeysForTargetId(e,t){const n=this.Br.yr(t);return ah.resolve(n)}containsKey(e,t){return ah.resolve(this.Br.containsKey(t))}}class ag{constructor(e,t){this.qr={},this.overlays={},this.Qr=new oh(0),this.Kr=!1,this.Kr=!0,this.$r=new Qm,this.referenceDelegate=e(this),this.Ur=new rg(this),this.indexManager=new Vm,this.remoteDocumentCache=function(e){return new tg(e)}((e=>this.referenceDelegate.Wr(e))),this.serializer=new zm(t),this.Gr=new Xm(this.serializer)}start(){return Promise.resolve()}shutdown(){return this.Kr=!1,Promise.resolve()}get started(){return this.Kr}setDatabaseDeletedListener(){}setNetworkEnabled(){}getIndexManager(e){return this.indexManager}getDocumentOverlayCache(e){let t=this.overlays[e.toKey()];return t||(t=new Ym,this.overlays[e.toKey()]=t),t}getMutationQueue(e,t){let n=this.qr[e.toKey()];return n||(n=new eg(t,this.referenceDelegate),this.qr[e.toKey()]=n),n}getGlobalsCache(){return this.$r}getTargetCache(){return this.Ur}getRemoteDocumentCache(){return this.remoteDocumentCache}getBundleCache(){return this.Gr}runTransaction(e,t,n){wd("MemoryPersistence","Starting transaction:",e);const r=new sg(this.Qr.next());return this.referenceDelegate.zr(),n(r).next((e=>this.referenceDelegate.jr(r).next((()=>e)))).toPromise().then((e=>(r.raiseOnCommittedEvent(),e)))}Hr(e,t){return ah.or(Object.values(this.qr).map((n=>()=>n.containsKey(e,t))))}}class sg extends nh{constructor(e){super(),this.currentSequenceNumber=e}}class ig{constructor(e){this.persistence=e,this.Jr=new Jm,this.Yr=null}static Zr(e){return new ig(e)}get Xr(){if(this.Yr)return this.Yr;throw Cd()}addReference(e,t,n){return this.Jr.addReference(n,t),this.Xr.delete(n.toString()),ah.resolve()}removeReference(e,t,n){return this.Jr.removeReference(n,t),this.Xr.add(n.toString()),ah.resolve()}markPotentiallyOrphaned(e,t){return this.Xr.add(t.toString()),ah.resolve()}removeTarget(e,t){this.Jr.gr(t.targetId).forEach((e=>this.Xr.add(e.toString())));const n=this.persistence.getTargetCache();return n.getMatchingKeysForTargetId(e,t.targetId).next((e=>{e.forEach((e=>this.Xr.add(e.toString())))})).next((()=>n.removeTargetData(e,t)))}zr(){this.Yr=new Set}jr(e){const t=this.persistence.getRemoteDocumentCache().newChangeBuffer();return ah.forEach(this.Xr,(n=>{const r=Xd.fromPath(n);return this.ei(e,r).next((e=>{e||t.removeEntry(r,jd.min())}))})).next((()=>(this.Yr=null,t.apply(e))))}updateLimboDocument(e,t){return this.ei(e,t).next((e=>{e?this.Xr.delete(t.toString()):this.Xr.add(t.toString())}))}Wr(e){return 0}ei(e,t){return ah.or([()=>ah.resolve(this.Jr.containsKey(t)),()=>this.persistence.getTargetCache().containsKey(e,t),()=>this.persistence.Hr(e,t)])}}class og{constructor(e,t,n,r){this.targetId=e,this.fromCache=t,this.$i=n,this.Ui=r}static Wi(e,t){let n=tf(),r=tf();for(const a of t.docChanges)switch(a.type){case 0:n=n.add(a.doc.key);break;case 1:r=r.add(a.doc.key)}return new og(e,t.fromCache,n,r)}}class lg{constructor(){this._documentReadCount=0}get documentReadCount(){return this._documentReadCount}incrementDocumentReadCount(e){this._documentReadCount+=e}}class ug{constructor(){this.Gi=!1,this.zi=!1,this.ji=100,this.Hi=vu()?8:sh(bu())>0?6:4}initialize(e,t){this.Ji=e,this.indexManager=t,this.Gi=!0}getDocumentsMatchingQuery(e,t,n,r){const a={result:null};return this.Yi(e,t).next((e=>{a.result=e})).next((()=>{if(!a.result)return this.Zi(e,t,r,n).next((e=>{a.result=e}))})).next((()=>{if(a.result)return;const n=new lg;return this.Xi(e,t,n).next((r=>{if(a.result=r,this.zi)return this.es(e,t,n,r.size)}))})).next((()=>a.result))}es(e,t,n,r){return n.documentReadCount<this.ji?(xd()<=Du.DEBUG&&wd("QueryEngine","SDK will not create cache indexes for query:",zp(t),"since it only creates cache indexes for collection contains","more than or equal to",this.ji,"documents"),ah.resolve()):(xd()<=Du.DEBUG&&wd("QueryEngine","Query:",zp(t),"scans",n.documentReadCount,"local documents and returns",r,"documents as results."),n.documentReadCount>this.Hi*r?(xd()<=Du.DEBUG&&wd("QueryEngine","The SDK decides to create cache indexes for query:",zp(t),"as using cache indexes may help improve performance."),this.indexManager.createTargetIndexes(e,Mp(t))):ah.resolve())}Yi(e,t){if($p(t))return ah.resolve(null);let n=Mp(t);return this.indexManager.getIndexType(e,n).next((r=>0===r?null:(null!==t.limit&&1===r&&(t=Op(t,null,"F"),n=Mp(t)),this.indexManager.getDocumentsMatchingTarget(e,n).next((r=>{const a=tf(...r);return this.Ji.getDocuments(e,a).next((r=>this.indexManager.getMinOffset(e,n).next((n=>{const s=this.ts(t,r);return this.ns(t,s,a,n.readTime)?this.Yi(e,Op(t,null,"F")):this.rs(e,s,t,n)}))))})))))}Zi(e,t,n,r){return $p(t)||r.isEqual(jd.min())?ah.resolve(null):this.Ji.getDocuments(e,n).next((a=>{const s=this.ts(t,a);return this.ns(t,s,n,r)?ah.resolve(null):(xd()<=Du.DEBUG&&wd("QueryEngine","Re-using previous result from %s to execute query: %s",r.toString(),zp(t)),this.rs(e,s,t,Qd(r,-1)).next((e=>e)))}))}ts(e,t){let n=new wh(Vp(e));return t.forEach(((t,r)=>{Bp(e,r)&&(n=n.add(r))})),n}ns(e,t,n,r){if(null===e.limit)return!1;if(n.size!==t.size)return!0;const a="F"===e.limitType?t.last():t.first();return!!a&&(a.hasPendingWrites||a.version.compareTo(r)>0)}Xi(e,t,n){return xd()<=Du.DEBUG&&wd("QueryEngine","Using full collection scan to execute query:",zp(t)),this.Ji.getDocumentsMatchingQuery(e,t,Zd.min(),n)}rs(e,t,n,r){return this.Ji.getDocumentsMatchingQuery(e,n,r).next((e=>(t.forEach((t=>{e=e.insert(t.key,t)})),e)))}}class cg{constructor(e,t,n,r){this.persistence=e,this.ss=t,this.serializer=r,this.os=new bh(Wd),this._s=new jp((e=>Cp(e)),Np),this.us=new Map,this.cs=e.getRemoteDocumentCache(),this.Ur=e.getTargetCache(),this.Gr=e.getBundleCache(),this.ls(n)}ls(e){this.documentOverlayCache=this.persistence.getDocumentOverlayCache(e),this.indexManager=this.persistence.getIndexManager(e),this.mutationQueue=this.persistence.getMutationQueue(e,this.indexManager),this.localDocuments=new Km(this.cs,this.mutationQueue,this.documentOverlayCache,this.indexManager),this.cs.setIndexManager(this.indexManager),this.ss.initialize(this.localDocuments,this.indexManager)}collectGarbage(e){return this.persistence.runTransaction("Collect garbage","readwrite-primary",(t=>e.collect(t,this.os)))}}function dg(e,t,n,r){return new cg(e,t,n,r)}async function hg(e,t){const n=Td(e);return await n.persistence.runTransaction("Handle user change","readonly",(e=>{let r;return n.mutationQueue.getAllMutationBatches(e).next((a=>(r=a,n.ls(t),n.mutationQueue.getAllMutationBatches(e)))).next((t=>{const a=[],s=[];let i=tf();for(const e of r){a.push(e.batchId);for(const t of e.mutations)i=i.add(t.key)}for(const e of t){s.push(e.batchId);for(const t of e.mutations)i=i.add(t.key)}return n.localDocuments.getDocuments(e,i).next((e=>({hs:e,removedBatchIds:a,addedBatchIds:s})))}))}))}function pg(e){const t=Td(e);return t.persistence.runTransaction("Get last remote snapshot version","readonly",(e=>t.Ur.getLastRemoteSnapshotVersion(e)))}function fg(e,t,n){let r=tf(),a=tf();return n.forEach((e=>r=r.add(e))),t.getEntries(e,r).next((e=>{let r=Hp();return n.forEach(((n,s)=>{const i=e.get(n);s.isFoundDocument()!==i.isFoundDocument()&&(a=a.add(n)),s.isNoDocument()&&s.version.isEqual(jd.min())?(t.removeEntry(n,s.readTime),r=r.insert(n,s)):!i.isValidDocument()||s.version.compareTo(i.version)>0||0===s.version.compareTo(i.version)&&i.hasPendingWrites?(t.addEntry(s),r=r.insert(n,s)):wd("LocalStore","Ignoring outdated watch update for ",n,". Current version:",i.version," Watch version:",s.version)})),{Ps:r,Is:a}}))}function mg(e,t){const n=Td(e);return n.persistence.runTransaction("Get next mutation batch","readonly",(e=>(void 0===t&&(t=-1),n.mutationQueue.getNextMutationBatchAfterBatchId(e,t))))}function gg(e,t){const n=Td(e);return n.persistence.runTransaction("Allocate target","readwrite",(e=>{let r;return n.Ur.getTargetData(e,t).next((a=>a?(r=a,ah.resolve(r)):n.Ur.allocateTargetId(e).next((a=>(r=new Lm(t,a,"TargetPurposeListen",e.currentSequenceNumber),n.Ur.addTargetData(e,r).next((()=>r)))))))})).then((e=>{const r=n.os.get(e.targetId);return(null===r||e.snapshotVersion.compareTo(r.snapshotVersion)>0)&&(n.os=n.os.insert(e.targetId,e),n._s.set(t,e.targetId)),e}))}async function yg(e,t,n){const r=Td(e),a=r.os.get(t),s=n?"readwrite":"readwrite-primary";try{n||await r.persistence.runTransaction("Release target",s,(e=>r.persistence.referenceDelegate.removeTarget(e,a)))}catch(e){if(!ih(e))throw e;wd("LocalStore",`Failed to update sequence numbers for target ${t}: ${e}`)}r.os=r.os.remove(t),r._s.delete(a.target)}function bg(e,t,n){const r=Td(e);let a=jd.min(),s=tf();return r.persistence.runTransaction("Execute query","readwrite",(e=>function(e,t,n){const r=Td(e),a=r._s.get(n);return void 0!==a?ah.resolve(r.os.get(a)):r.Ur.getTargetData(t,n)}(r,e,Mp(t)).next((t=>{if(t)return a=t.lastLimboFreeSnapshotVersion,r.Ur.getMatchingKeysForTargetId(e,t.targetId).next((e=>{s=e}))})).next((()=>r.ss.getDocumentsMatchingQuery(e,t,n?a:jd.min(),n?s:tf()))).next((e=>(vg(r,Wp(t),e),{documents:e,Ts:s})))))}function vg(e,t,n){let r=e.us.get(t)||jd.min();n.forEach(((e,t)=>{t.readTime.compareTo(r)>0&&(r=t.readTime)})),e.us.set(t,r)}class xg{constructor(){this.activeTargetIds=rf()}fs(e){this.activeTargetIds=this.activeTargetIds.add(e)}gs(e){this.activeTargetIds=this.activeTargetIds.delete(e)}Vs(){const e={activeTargetIds:this.activeTargetIds.toArray(),updateTimeMs:Date.now()};return JSON.stringify(e)}}class wg{constructor(){this.so=new xg,this.oo={},this.onlineStateHandler=null,this.sequenceNumberHandler=null}addPendingMutation(e){}updateMutationState(e,t,n){}addLocalQueryTarget(e){return this.so.fs(e),this.oo[e]||"not-current"}updateQueryState(e,t,n){this.oo[e]=t}removeLocalQueryTarget(e){this.so.gs(e)}isLocalQueryTarget(e){return this.so.activeTargetIds.has(e)}clearQueryState(e){delete this.oo[e]}getAllActiveQueryTargets(){return this.so.activeTargetIds}isActiveQueryTarget(e){return this.so.activeTargetIds.has(e)}start(){return this.so=new xg,Promise.resolve()}handleUserChange(e,t,n){}setOnlineState(e){}shutdown(){}writeSequenceNumber(e){}notifyBundleLoaded(e){}}class kg{_o(e){}shutdown(){}}class Sg{constructor(){this.ao=()=>this.uo(),this.co=()=>this.lo(),this.ho=[],this.Po()}_o(e){this.ho.push(e)}shutdown(){window.removeEventListener("online",this.ao),window.removeEventListener("offline",this.co)}Po(){window.addEventListener("online",this.ao),window.addEventListener("offline",this.co)}uo(){wd("ConnectivityMonitor","Network connectivity changed: AVAILABLE");for(const e of this.ho)e(0)}lo(){wd("ConnectivityMonitor","Network connectivity changed: UNAVAILABLE");for(const e of this.ho)e(1)}static D(){return"undefined"!=typeof window&&void 0!==window.addEventListener&&void 0!==window.removeEventListener}}let Ig=null;function Cg(){return null===Ig?Ig=268435456+Math.round(2147483648*Math.random()):Ig++,"0x"+Ig.toString(16)}const Ng={BatchGetDocuments:"batchGet",Commit:"commit",RunQuery:"runQuery",RunAggregationQuery:"runAggregationQuery"};class Tg{constructor(e){this.Io=e.Io,this.To=e.To}Eo(e){this.Ao=e}Ro(e){this.Vo=e}mo(e){this.fo=e}onMessage(e){this.po=e}close(){this.To()}send(e){this.Io(e)}yo(){this.Ao()}wo(){this.Vo()}So(e){this.fo(e)}bo(e){this.po(e)}}const Eg="WebChannelConnection";class Ag extends class{constructor(e){this.databaseInfo=e,this.databaseId=e.databaseId;const t=e.ssl?"https":"http",n=encodeURIComponent(this.databaseId.projectId),r=encodeURIComponent(this.databaseId.database);this.Do=t+"://"+e.host,this.vo=`projects/${n}/databases/${r}`,this.Co="(default)"===this.databaseId.database?`project_id=${n}`:`project_id=${n}&database_id=${r}`}get Fo(){return!1}Mo(e,t,n,r,a){const s=Cg(),i=this.xo(e,t.toUriEncodedString());wd("RestConnection",`Sending RPC '${e}' ${s}:`,i,n);const o={"google-cloud-resource-prefix":this.vo,"x-goog-request-params":this.Co};return this.Oo(o,r,a),this.No(e,i,o,n).then((t=>(wd("RestConnection",`Received RPC '${e}' ${s}: `,t),t)),(t=>{throw Sd("RestConnection",`RPC '${e}' ${s} failed with error: `,t,"url: ",i,"request:",n),t}))}Lo(e,t,n,r,a,s){return this.Mo(e,t,n,r,a)}Oo(e,t,n){e["X-Goog-Api-Client"]="gl-js/ fire/"+bd,e["Content-Type"]="text/plain",this.databaseInfo.appId&&(e["X-Firebase-GMPID"]=this.databaseInfo.appId),t&&t.headers.forEach(((t,n)=>e[n]=t)),n&&n.headers.forEach(((t,n)=>e[n]=t))}xo(e,t){const n=Ng[e];return`${this.Do}/v1/${t}:${n}`}terminate(){}}{constructor(e){super(e),this.forceLongPolling=e.forceLongPolling,this.autoDetectLongPolling=e.autoDetectLongPolling,this.useFetchStreams=e.useFetchStreams,this.longPollingOptions=e.longPollingOptions}No(e,t,n,r){const a=Cg();return new Promise(((s,i)=>{const o=new sd;o.setWithCredentials(!0),o.listenOnce(ld.COMPLETE,(()=>{try{switch(o.getLastErrorCode()){case ud.NO_ERROR:const t=o.getResponseJson();wd(Eg,`XHR for RPC '${e}' ${a} received:`,JSON.stringify(t)),s(t);break;case ud.TIMEOUT:wd(Eg,`RPC '${e}' ${a} timed out`),i(new Ad(Ed.DEADLINE_EXCEEDED,"Request time out"));break;case ud.HTTP_ERROR:const n=o.getStatus();if(wd(Eg,`RPC '${e}' ${a} failed with status:`,n,"response text:",o.getResponseText()),n>0){let e=o.getResponseJson();Array.isArray(e)&&(e=e[0]);const t=null==e?void 0:e.error;if(t&&t.status&&t.message){const e=function(e){const t=e.toLowerCase().replace(/_/g,"-");return Object.values(Ed).indexOf(t)>=0?t:Ed.UNKNOWN}(t.status);i(new Ad(e,t.message))}else i(new Ad(Ed.UNKNOWN,"Server responded with status "+o.getStatus()))}else i(new Ad(Ed.UNAVAILABLE,"Connection failed."));break;default:Cd()}}finally{wd(Eg,`RPC '${e}' ${a} completed.`)}}));const l=JSON.stringify(r);wd(Eg,`RPC '${e}' ${a} sending request:`,r),o.send(t,"POST",l,n,15)}))}Bo(e,t,n){const r=Cg(),a=[this.Do,"/","google.firestore.v1.Firestore","/",e,"/channel"],s=pd(),i=hd(),o={httpSessionIdParam:"gsessionid",initMessageHeaders:{},messageUrlParams:{database:`projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`},sendRawJson:!0,supportsCrossDomainXhr:!0,internalChannelParams:{forwardChannelRequestTimeoutMs:6e5},forceLongPolling:this.forceLongPolling,detectBufferingProxy:this.autoDetectLongPolling},l=this.longPollingOptions.timeoutSeconds;void 0!==l&&(o.longPollingTimeout=Math.round(1e3*l)),this.useFetchStreams&&(o.xmlHttpFactory=new id({})),this.Oo(o.initMessageHeaders,t,n),o.encodeInitMessageHeaders=!0;const u=a.join("");wd(Eg,`Creating RPC '${e}' stream ${r}: ${u}`,o);const c=s.createWebChannel(u,o);let d=!1,h=!1;const p=new Tg({Io:t=>{h?wd(Eg,`Not sending because RPC '${e}' stream ${r} is closed:`,t):(d||(wd(Eg,`Opening RPC '${e}' stream ${r} transport.`),c.open(),d=!0),wd(Eg,`RPC '${e}' stream ${r} sending:`,t),c.send(t))},To:()=>c.close()}),f=(e,t,n)=>{e.listen(t,(e=>{try{n(e)}catch(e){setTimeout((()=>{throw e}),0)}}))};return f(c,od.EventType.OPEN,(()=>{h||(wd(Eg,`RPC '${e}' stream ${r} transport opened.`),p.yo())})),f(c,od.EventType.CLOSE,(()=>{h||(h=!0,wd(Eg,`RPC '${e}' stream ${r} transport closed`),p.So())})),f(c,od.EventType.ERROR,(t=>{h||(h=!0,Sd(Eg,`RPC '${e}' stream ${r} transport errored:`,t),p.So(new Ad(Ed.UNAVAILABLE,"The operation could not be completed")))})),f(c,od.EventType.MESSAGE,(t=>{var n;if(!h){const a=t.data[0];Nd(!!a);const s=a,i=s.error||(null===(n=s[0])||void 0===n?void 0:n.error);if(i){wd(Eg,`RPC '${e}' stream ${r} received error:`,i);const t=i.status;let n=function(e){const t=Bf[e];if(void 0!==t)return Uf(t)}(t),a=i.message;void 0===n&&(n=Ed.INTERNAL,a="Unknown error status: "+t+" with message "+i.message),h=!0,p.So(new Ad(n,a)),c.close()}else wd(Eg,`RPC '${e}' stream ${r} received:`,a),p.bo(a)}})),f(i,dd.STAT_EVENT,(t=>{t.stat===cd.PROXY?wd(Eg,`RPC '${e}' stream ${r} detected buffering proxy`):t.stat===cd.NOPROXY&&wd(Eg,`RPC '${e}' stream ${r} detected no buffering proxy`)})),setTimeout((()=>{p.wo()}),0),p}}function _g(){return"undefined"!=typeof document?document:null}function $g(e){return new um(e,!0)}class Rg{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:6e4;this.ui=e,this.timerId=t,this.ko=n,this.qo=r,this.Qo=a,this.Ko=0,this.$o=null,this.Uo=Date.now(),this.reset()}reset(){this.Ko=0}Wo(){this.Ko=this.Qo}Go(e){this.cancel();const t=Math.floor(this.Ko+this.zo()),n=Math.max(0,Date.now()-this.Uo),r=Math.max(0,t-n);r>0&&wd("ExponentialBackoff",`Backing off for ${r} ms (base delay: ${this.Ko} ms, delay with jitter: ${t} ms, last attempt: ${n} ms ago)`),this.$o=this.ui.enqueueAfterDelay(this.timerId,r,(()=>(this.Uo=Date.now(),e()))),this.Ko*=this.qo,this.Ko<this.ko&&(this.Ko=this.ko),this.Ko>this.Qo&&(this.Ko=this.Qo)}jo(){null!==this.$o&&(this.$o.skipDelay(),this.$o=null)}cancel(){null!==this.$o&&(this.$o.cancel(),this.$o=null)}zo(){return(Math.random()-.5)*this.Ko}}class Dg{constructor(e,t,n,r,a,s,i,o){this.ui=e,this.Ho=n,this.Jo=r,this.connection=a,this.authCredentialsProvider=s,this.appCheckCredentialsProvider=i,this.listener=o,this.state=0,this.Yo=0,this.Zo=null,this.Xo=null,this.stream=null,this.e_=0,this.t_=new Rg(e,t)}n_(){return 1===this.state||5===this.state||this.r_()}r_(){return 2===this.state||3===this.state}start(){this.e_=0,4!==this.state?this.auth():this.i_()}async stop(){this.n_()&&await this.close(0)}s_(){this.state=0,this.t_.reset()}o_(){this.r_()&&null===this.Zo&&(this.Zo=this.ui.enqueueAfterDelay(this.Ho,6e4,(()=>this.__())))}a_(e){this.u_(),this.stream.send(e)}async __(){if(this.r_())return this.close(0)}u_(){this.Zo&&(this.Zo.cancel(),this.Zo=null)}c_(){this.Xo&&(this.Xo.cancel(),this.Xo=null)}async close(e,t){this.u_(),this.c_(),this.t_.cancel(),this.Yo++,4!==e?this.t_.reset():t&&t.code===Ed.RESOURCE_EXHAUSTED?(kd(t.toString()),kd("Using maximum backoff delay to prevent overloading the backend."),this.t_.Wo()):t&&t.code===Ed.UNAUTHENTICATED&&3!==this.state&&(this.authCredentialsProvider.invalidateToken(),this.appCheckCredentialsProvider.invalidateToken()),null!==this.stream&&(this.l_(),this.stream.close(),this.stream=null),this.state=e,await this.listener.mo(t)}l_(){}auth(){this.state=1;const e=this.h_(this.Yo),t=this.Yo;Promise.all([this.authCredentialsProvider.getToken(),this.appCheckCredentialsProvider.getToken()]).then((e=>{let[n,r]=e;this.Yo===t&&this.P_(n,r)}),(t=>{e((()=>{const e=new Ad(Ed.UNKNOWN,"Fetching auth token failed: "+t.message);return this.I_(e)}))}))}P_(e,t){const n=this.h_(this.Yo);this.stream=this.T_(e,t),this.stream.Eo((()=>{n((()=>this.listener.Eo()))})),this.stream.Ro((()=>{n((()=>(this.state=2,this.Xo=this.ui.enqueueAfterDelay(this.Jo,1e4,(()=>(this.r_()&&(this.state=3),Promise.resolve()))),this.listener.Ro())))})),this.stream.mo((e=>{n((()=>this.I_(e)))})),this.stream.onMessage((e=>{n((()=>1==++this.e_?this.E_(e):this.onNext(e)))}))}i_(){this.state=5,this.t_.Go((async()=>{this.state=0,this.start()}))}I_(e){return wd("PersistentStream",`close with error: ${e}`),this.stream=null,this.close(4,e)}h_(e){return t=>{this.ui.enqueueAndForget((()=>this.Yo===e?t():(wd("PersistentStream","stream callback skipped by getCloseGuardedDispatcher."),Promise.resolve())))}}}class Mg extends Dg{constructor(e,t,n,r,a,s){super(e,"listen_stream_connection_backoff","listen_stream_idle","health_check_timeout",t,n,r,s),this.serializer=a}T_(e,t){return this.connection.Bo("Listen",e,t)}E_(e){return this.onNext(e)}onNext(e){this.t_.reset();const t=function(e,t){let n;if("targetChange"in t){t.targetChange;const r=function(e){return"NO_CHANGE"===e?0:"ADD"===e?1:"REMOVE"===e?2:"CURRENT"===e?3:"RESET"===e?4:Cd()}(t.targetChange.targetChangeType||"NO_CHANGE"),a=t.targetChange.targetIds||[],s=function(e,t){return e.useProto3Json?(Nd(void 0===t||"string"==typeof t),Ch.fromBase64String(t||"")):(Nd(void 0===t||t instanceof Buffer||t instanceof Uint8Array),Ch.fromUint8Array(t||new Uint8Array))}(e,t.targetChange.resumeToken),i=t.targetChange.cause,o=i&&function(e){const t=void 0===e.code?Ed.UNKNOWN:Uf(e.code);return new Ad(t,e.message||"")}(i);n=new tm(r,a,s,o||null)}else if("documentChange"in t){t.documentChange;const r=t.documentChange;r.document,r.document.name,r.document.updateTime;const a=vm(e,r.document.name),s=fm(r.document.updateTime),i=r.document.createTime?fm(r.document.createTime):jd.min(),o=new Jh({mapValue:{fields:r.document.fields}}),l=ep.newFoundDocument(a,s,i,o),u=r.targetIds||[],c=r.removedTargetIds||[];n=new Zf(u,c,l.key,l)}else if("documentDelete"in t){t.documentDelete;const r=t.documentDelete;r.document;const a=vm(e,r.document),s=r.readTime?fm(r.readTime):jd.min(),i=ep.newNoDocument(a,s),o=r.removedTargetIds||[];n=new Zf([],o,i.key,i)}else if("documentRemove"in t){t.documentRemove;const r=t.documentRemove;r.document;const a=vm(e,r.document),s=r.removedTargetIds||[];n=new Zf([],s,a,null)}else{if(!("filter"in t))return Cd();{t.filter;const e=t.filter;e.targetId;const{count:r=0,unchangedNames:a}=e,s=new zf(r,a),i=e.targetId;n=new em(i,s)}}return n}(this.serializer,e),n=function(e){if(!("targetChange"in e))return jd.min();const t=e.targetChange;return t.targetIds&&t.targetIds.length?jd.min():t.readTime?fm(t.readTime):jd.min()}(e);return this.listener.d_(t,n)}A_(e){const t={};t.database=km(this.serializer),t.addTarget=function(e,t){let n;const r=t.target;if(n=Tp(r)?{documents:Nm(e,r)}:{query:Tm(e,r)._t},n.targetId=t.targetId,t.resumeToken.approximateByteSize()>0){n.resumeToken=hm(e,t.resumeToken);const r=cm(e,t.expectedCount);null!==r&&(n.expectedCount=r)}else if(t.snapshotVersion.compareTo(jd.min())>0){n.readTime=dm(e,t.snapshotVersion.toTimestamp());const r=cm(e,t.expectedCount);null!==r&&(n.expectedCount=r)}return n}(this.serializer,e);const n=function(e,t){const n=function(e){switch(e){case"TargetPurposeListen":return null;case"TargetPurposeExistenceFilterMismatch":return"existence-filter-mismatch";case"TargetPurposeExistenceFilterMismatchBloom":return"existence-filter-mismatch-bloom";case"TargetPurposeLimboResolution":return"limbo-document";default:return Cd()}}(t.purpose);return null==n?null:{"goog-listen-tags":n}}(this.serializer,e);n&&(t.labels=n),this.a_(t)}R_(e){const t={};t.database=km(this.serializer),t.removeTarget=e,this.a_(t)}}class Fg extends Dg{constructor(e,t,n,r,a,s){super(e,"write_stream_connection_backoff","write_stream_idle","health_check_timeout",t,n,r,s),this.serializer=a}get V_(){return this.e_>0}start(){this.lastStreamToken=void 0,super.start()}l_(){this.V_&&this.m_([])}T_(e,t){return this.connection.Bo("Write",e,t)}E_(e){return Nd(!!e.streamToken),this.lastStreamToken=e.streamToken,Nd(!e.writeResults||0===e.writeResults.length),this.listener.f_()}onNext(e){Nd(!!e.streamToken),this.lastStreamToken=e.streamToken,this.t_.reset();const t=function(e,t){return e&&e.length>0?(Nd(void 0!==t),e.map((e=>function(e,t){let n=e.updateTime?fm(e.updateTime):fm(t);return n.isEqual(jd.min())&&(n=fm(t)),new xf(n,e.transformResults||[])}(e,t)))):[]}(e.writeResults,e.commitTime),n=fm(e.commitTime);return this.listener.g_(n,t)}p_(){const e={};e.database=km(this.serializer),this.a_(e)}m_(e){const t={streamToken:this.lastStreamToken,writes:e.map((e=>Cm(this.serializer,e)))};this.a_(t)}}class Og extends class{}{constructor(e,t,n,r){super(),this.authCredentials=e,this.appCheckCredentials=t,this.connection=n,this.serializer=r,this.y_=!1}w_(){if(this.y_)throw new Ad(Ed.FAILED_PRECONDITION,"The client has already been terminated.")}Mo(e,t,n,r){return this.w_(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((a=>{let[s,i]=a;return this.connection.Mo(e,gm(t,n),r,s,i)})).catch((e=>{throw"FirebaseError"===e.name?(e.code===Ed.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),e):new Ad(Ed.UNKNOWN,e.toString())}))}Lo(e,t,n,r,a){return this.w_(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((s=>{let[i,o]=s;return this.connection.Lo(e,gm(t,n),r,i,o,a)})).catch((e=>{throw"FirebaseError"===e.name?(e.code===Ed.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),e):new Ad(Ed.UNKNOWN,e.toString())}))}terminate(){this.y_=!0,this.connection.terminate()}}class Pg{constructor(e,t){this.asyncQueue=e,this.onlineStateHandler=t,this.state="Unknown",this.S_=0,this.b_=null,this.D_=!0}v_(){0===this.S_&&(this.C_("Unknown"),this.b_=this.asyncQueue.enqueueAfterDelay("online_state_timeout",1e4,(()=>(this.b_=null,this.F_("Backend didn't respond within 10 seconds."),this.C_("Offline"),Promise.resolve()))))}M_(e){"Online"===this.state?this.C_("Unknown"):(this.S_++,this.S_>=1&&(this.x_(),this.F_(`Connection failed 1 times. Most recent error: ${e.toString()}`),this.C_("Offline")))}set(e){this.x_(),this.S_=0,"Online"===e&&(this.D_=!1),this.C_(e)}C_(e){e!==this.state&&(this.state=e,this.onlineStateHandler(e))}F_(e){const t=`Could not reach Cloud Firestore backend. ${e}\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;this.D_?(kd(t),this.D_=!1):wd("OnlineStateTracker",t)}x_(){null!==this.b_&&(this.b_.cancel(),this.b_=null)}}class Lg{constructor(e,t,n,r,a){this.localStore=e,this.datastore=t,this.asyncQueue=n,this.remoteSyncer={},this.O_=[],this.N_=new Map,this.L_=new Set,this.B_=[],this.k_=a,this.k_._o((e=>{n.enqueueAndForget((async()=>{qg(this)&&(wd("RemoteStore","Restarting streams for network reachability change."),await async function(e){const t=Td(e);t.L_.add(4),await Bg(t),t.q_.set("Unknown"),t.L_.delete(4),await zg(t)}(this))}))})),this.q_=new Pg(n,r)}}async function zg(e){if(qg(e))for(const t of e.B_)await t(!0)}async function Bg(e){for(const t of e.B_)await t(!1)}function Wg(e,t){const n=Td(e);n.N_.has(t.targetId)||(n.N_.set(t.targetId,t),Hg(n)?Gg(n):hy(n).r_()&&Ug(n,t))}function Vg(e,t){const n=Td(e),r=hy(n);n.N_.delete(t),r.r_()&&jg(n,t),0===n.N_.size&&(r.r_()?r.o_():qg(n)&&n.q_.set("Unknown"))}function Ug(e,t){if(e.Q_.xe(t.targetId),t.resumeToken.approximateByteSize()>0||t.snapshotVersion.compareTo(jd.min())>0){const n=e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size;t=t.withExpectedCount(n)}hy(e).A_(t)}function jg(e,t){e.Q_.xe(t),hy(e).R_(t)}function Gg(e){e.Q_=new rm({getRemoteKeysForTarget:t=>e.remoteSyncer.getRemoteKeysForTarget(t),ot:t=>e.N_.get(t)||null,tt:()=>e.datastore.serializer.databaseId}),hy(e).start(),e.q_.v_()}function Hg(e){return qg(e)&&!hy(e).n_()&&e.N_.size>0}function qg(e){return 0===Td(e).L_.size}function Kg(e){e.Q_=void 0}async function Xg(e){e.q_.set("Online")}async function Yg(e){e.N_.forEach(((t,n)=>{Ug(e,t)}))}async function Qg(e,t){Kg(e),Hg(e)?(e.q_.M_(t),Gg(e)):e.q_.set("Unknown")}async function Jg(e,t,n){if(e.q_.set("Online"),t instanceof tm&&2===t.state&&t.cause)try{await async function(e,t){const n=t.cause;for(const r of t.targetIds)e.N_.has(r)&&(await e.remoteSyncer.rejectListen(r,n),e.N_.delete(r),e.Q_.removeTarget(r))}(e,t)}catch(n){wd("RemoteStore","Failed to remove targets %s: %s ",t.targetIds.join(","),n),await Zg(e,n)}else if(t instanceof Zf?e.Q_.Ke(t):t instanceof em?e.Q_.He(t):e.Q_.We(t),!n.isEqual(jd.min()))try{const t=await pg(e.localStore);n.compareTo(t)>=0&&await function(e,t){const n=e.Q_.rt(t);return n.targetChanges.forEach(((n,r)=>{if(n.resumeToken.approximateByteSize()>0){const a=e.N_.get(r);a&&e.N_.set(r,a.withResumeToken(n.resumeToken,t))}})),n.targetMismatches.forEach(((t,n)=>{const r=e.N_.get(t);if(!r)return;e.N_.set(t,r.withResumeToken(Ch.EMPTY_BYTE_STRING,r.snapshotVersion)),jg(e,t);const a=new Lm(r.target,t,n,r.sequenceNumber);Ug(e,a)})),e.remoteSyncer.applyRemoteEvent(n)}(e,n)}catch(t){wd("RemoteStore","Failed to raise snapshot:",t),await Zg(e,t)}}async function Zg(e,t,n){if(!ih(t))throw t;e.L_.add(1),await Bg(e),e.q_.set("Offline"),n||(n=()=>pg(e.localStore)),e.asyncQueue.enqueueRetryable((async()=>{wd("RemoteStore","Retrying IndexedDB access"),await n(),e.L_.delete(1),await zg(e)}))}function ey(e,t){return t().catch((n=>Zg(e,n,t)))}async function ty(e){const t=Td(e),n=py(t);let r=t.O_.length>0?t.O_[t.O_.length-1].batchId:-1;for(;ny(t);)try{const e=await mg(t.localStore,r);if(null===e){0===t.O_.length&&n.o_();break}r=e.batchId,ry(t,e)}catch(e){await Zg(t,e)}ay(t)&&sy(t)}function ny(e){return qg(e)&&e.O_.length<10}function ry(e,t){e.O_.push(t);const n=py(e);n.r_()&&n.V_&&n.m_(t.mutations)}function ay(e){return qg(e)&&!py(e).n_()&&e.O_.length>0}function sy(e){py(e).start()}async function iy(e){py(e).p_()}async function oy(e){const t=py(e);for(const n of e.O_)t.m_(n.mutations)}async function ly(e,t,n){const r=e.O_.shift(),a=Pf.from(r,t,n);await ey(e,(()=>e.remoteSyncer.applySuccessfulWrite(a))),await ty(e)}async function uy(e,t){t&&py(e).V_&&await async function(e,t){if(function(e){return Vf(e)&&e!==Ed.ABORTED}(t.code)){const n=e.O_.shift();py(e).s_(),await ey(e,(()=>e.remoteSyncer.rejectFailedWrite(n.batchId,t))),await ty(e)}}(e,t),ay(e)&&sy(e)}async function cy(e,t){const n=Td(e);n.asyncQueue.verifyOperationInProgress(),wd("RemoteStore","RemoteStore received new credentials");const r=qg(n);n.L_.add(3),await Bg(n),r&&n.q_.set("Unknown"),await n.remoteSyncer.handleCredentialChange(t),n.L_.delete(3),await zg(n)}async function dy(e,t){const n=Td(e);t?(n.L_.delete(2),await zg(n)):t||(n.L_.add(2),await Bg(n),n.q_.set("Unknown"))}function hy(e){return e.K_||(e.K_=function(e,t,n){const r=Td(e);return r.w_(),new Mg(t,r.connection,r.authCredentials,r.appCheckCredentials,r.serializer,n)}(e.datastore,e.asyncQueue,{Eo:Xg.bind(null,e),Ro:Yg.bind(null,e),mo:Qg.bind(null,e),d_:Jg.bind(null,e)}),e.B_.push((async t=>{t?(e.K_.s_(),Hg(e)?Gg(e):e.q_.set("Unknown")):(await e.K_.stop(),Kg(e))}))),e.K_}function py(e){return e.U_||(e.U_=function(e,t,n){const r=Td(e);return r.w_(),new Fg(t,r.connection,r.authCredentials,r.appCheckCredentials,r.serializer,n)}(e.datastore,e.asyncQueue,{Eo:()=>Promise.resolve(),Ro:iy.bind(null,e),mo:uy.bind(null,e),f_:oy.bind(null,e),g_:ly.bind(null,e)}),e.B_.push((async t=>{t?(e.U_.s_(),await ty(e)):(await e.U_.stop(),e.O_.length>0&&(wd("RemoteStore",`Stopping write stream with ${e.O_.length} pending writes`),e.O_=[]))}))),e.U_}class fy{constructor(e,t,n,r,a){this.asyncQueue=e,this.timerId=t,this.targetTimeMs=n,this.op=r,this.removalCallback=a,this.deferred=new _d,this.then=this.deferred.promise.then.bind(this.deferred.promise),this.deferred.promise.catch((e=>{}))}get promise(){return this.deferred.promise}static createAndSchedule(e,t,n,r,a){const s=Date.now()+n,i=new fy(e,t,s,r,a);return i.start(n),i}start(e){this.timerHandle=setTimeout((()=>this.handleDelayElapsed()),e)}skipDelay(){return this.handleDelayElapsed()}cancel(e){null!==this.timerHandle&&(this.clearTimeout(),this.deferred.reject(new Ad(Ed.CANCELLED,"Operation cancelled"+(e?": "+e:""))))}handleDelayElapsed(){this.asyncQueue.enqueueAndForget((()=>null!==this.timerHandle?(this.clearTimeout(),this.op().then((e=>this.deferred.resolve(e)))):Promise.resolve()))}clearTimeout(){null!==this.timerHandle&&(this.removalCallback(this),clearTimeout(this.timerHandle),this.timerHandle=null)}}function my(e,t){if(kd("AsyncQueue",`${t}: ${e}`),ih(e))return new Ad(Ed.UNAVAILABLE,`${t}: ${e}`);throw e}class gy{constructor(e){this.comparator=e?(t,n)=>e(t,n)||Xd.comparator(t.key,n.key):(e,t)=>Xd.comparator(e.key,t.key),this.keyedMap=Kp(),this.sortedSet=new bh(this.comparator)}static emptySet(e){return new gy(e.comparator)}has(e){return null!=this.keyedMap.get(e)}get(e){return this.keyedMap.get(e)}first(){return this.sortedSet.minKey()}last(){return this.sortedSet.maxKey()}isEmpty(){return this.sortedSet.isEmpty()}indexOf(e){const t=this.keyedMap.get(e);return t?this.sortedSet.indexOf(t):-1}get size(){return this.sortedSet.size}forEach(e){this.sortedSet.inorderTraversal(((t,n)=>(e(t),!1)))}add(e){const t=this.delete(e.key);return t.copy(t.keyedMap.insert(e.key,e),t.sortedSet.insert(e,null))}delete(e){const t=this.get(e);return t?this.copy(this.keyedMap.remove(e),this.sortedSet.remove(t)):this}isEqual(e){if(!(e instanceof gy))return!1;if(this.size!==e.size)return!1;const t=this.sortedSet.getIterator(),n=e.sortedSet.getIterator();for(;t.hasNext();){const e=t.getNext().key,r=n.getNext().key;if(!e.isEqual(r))return!1}return!0}toString(){const e=[];return this.forEach((t=>{e.push(t.toString())})),0===e.length?"DocumentSet ()":"DocumentSet (\n  "+e.join("  \n")+"\n)"}copy(e,t){const n=new gy;return n.comparator=this.comparator,n.keyedMap=e,n.sortedSet=t,n}}class yy{constructor(){this.W_=new bh(Xd.comparator)}track(e){const t=e.doc.key,n=this.W_.get(t);n?0!==e.type&&3===n.type?this.W_=this.W_.insert(t,e):3===e.type&&1!==n.type?this.W_=this.W_.insert(t,{type:n.type,doc:e.doc}):2===e.type&&2===n.type?this.W_=this.W_.insert(t,{type:2,doc:e.doc}):2===e.type&&0===n.type?this.W_=this.W_.insert(t,{type:0,doc:e.doc}):1===e.type&&0===n.type?this.W_=this.W_.remove(t):1===e.type&&2===n.type?this.W_=this.W_.insert(t,{type:1,doc:n.doc}):0===e.type&&1===n.type?this.W_=this.W_.insert(t,{type:2,doc:e.doc}):Cd():this.W_=this.W_.insert(t,e)}G_(){const e=[];return this.W_.inorderTraversal(((t,n)=>{e.push(n)})),e}}class by{constructor(e,t,n,r,a,s,i,o,l){this.query=e,this.docs=t,this.oldDocs=n,this.docChanges=r,this.mutatedKeys=a,this.fromCache=s,this.syncStateChanged=i,this.excludesMetadataChanges=o,this.hasCachedResults=l}static fromInitialDocuments(e,t,n,r,a){const s=[];return t.forEach((e=>{s.push({type:0,doc:e})})),new by(e,t,gy.emptySet(t),s,n,r,!0,!1,a)}get hasPendingWrites(){return!this.mutatedKeys.isEmpty()}isEqual(e){if(!(this.fromCache===e.fromCache&&this.hasCachedResults===e.hasCachedResults&&this.syncStateChanged===e.syncStateChanged&&this.mutatedKeys.isEqual(e.mutatedKeys)&&Pp(this.query,e.query)&&this.docs.isEqual(e.docs)&&this.oldDocs.isEqual(e.oldDocs)))return!1;const t=this.docChanges,n=e.docChanges;if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++)if(t[r].type!==n[r].type||!t[r].doc.isEqual(n[r].doc))return!1;return!0}}class vy{constructor(){this.z_=void 0,this.j_=[]}H_(){return this.j_.some((e=>e.J_()))}}class xy{constructor(){this.queries=wy(),this.onlineState="Unknown",this.Y_=new Set}terminate(){!function(e,t){const n=Td(e),r=n.queries;n.queries=wy(),r.forEach(((e,n)=>{for(const r of n.j_)r.onError(t)}))}(this,new Ad(Ed.ABORTED,"Firestore shutting down"))}}function wy(){return new jp((e=>Lp(e)),Pp)}async function ky(e,t){const n=Td(e);let r=3;const a=t.query;let s=n.queries.get(a);s?!s.H_()&&t.J_()&&(r=2):(s=new vy,r=t.J_()?0:1);try{switch(r){case 0:s.z_=await n.onListen(a,!0);break;case 1:s.z_=await n.onListen(a,!1);break;case 2:await n.onFirstRemoteStoreListen(a)}}catch(e){const n=my(e,`Initialization of query '${zp(t.query)}' failed`);return void t.onError(n)}n.queries.set(a,s),s.j_.push(t),t.Z_(n.onlineState),s.z_&&t.X_(s.z_)&&Ny(n)}async function Sy(e,t){const n=Td(e),r=t.query;let a=3;const s=n.queries.get(r);if(s){const e=s.j_.indexOf(t);e>=0&&(s.j_.splice(e,1),0===s.j_.length?a=t.J_()?0:1:!s.H_()&&t.J_()&&(a=2))}switch(a){case 0:return n.queries.delete(r),n.onUnlisten(r,!0);case 1:return n.queries.delete(r),n.onUnlisten(r,!1);case 2:return n.onLastRemoteStoreUnlisten(r);default:return}}function Iy(e,t){const n=Td(e);let r=!1;for(const a of t){const e=a.query,t=n.queries.get(e);if(t){for(const e of t.j_)e.X_(a)&&(r=!0);t.z_=a}}r&&Ny(n)}function Cy(e,t,n){const r=Td(e),a=r.queries.get(t);if(a)for(const s of a.j_)s.onError(n);r.queries.delete(t)}function Ny(e){e.Y_.forEach((e=>{e.next()}))}var Ty,Ey;(Ey=Ty||(Ty={})).ea="default",Ey.Cache="cache";class Ay{constructor(e,t,n){this.query=e,this.ta=t,this.na=!1,this.ra=null,this.onlineState="Unknown",this.options=n||{}}X_(e){if(!this.options.includeMetadataChanges){const t=[];for(const n of e.docChanges)3!==n.type&&t.push(n);e=new by(e.query,e.docs,e.oldDocs,t,e.mutatedKeys,e.fromCache,e.syncStateChanged,!0,e.hasCachedResults)}let t=!1;return this.na?this.ia(e)&&(this.ta.next(e),t=!0):this.sa(e,this.onlineState)&&(this.oa(e),t=!0),this.ra=e,t}onError(e){this.ta.error(e)}Z_(e){this.onlineState=e;let t=!1;return this.ra&&!this.na&&this.sa(this.ra,e)&&(this.oa(this.ra),t=!0),t}sa(e,t){if(!e.fromCache)return!0;if(!this.J_())return!0;const n="Offline"!==t;return(!this.options._a||!n)&&(!e.docs.isEmpty()||e.hasCachedResults||"Offline"===t)}ia(e){if(e.docChanges.length>0)return!0;const t=this.ra&&this.ra.hasPendingWrites!==e.hasPendingWrites;return!(!e.syncStateChanged&&!t)&&!0===this.options.includeMetadataChanges}oa(e){e=by.fromInitialDocuments(e.query,e.docs,e.mutatedKeys,e.fromCache,e.hasCachedResults),this.na=!0,this.ta.next(e)}J_(){return this.options.source!==Ty.Cache}}class _y{constructor(e){this.key=e}}class $y{constructor(e){this.key=e}}class Ry{constructor(e,t){this.query=e,this.Ta=t,this.Ea=null,this.hasCachedResults=!1,this.current=!1,this.da=tf(),this.mutatedKeys=tf(),this.Aa=Vp(e),this.Ra=new gy(this.Aa)}get Va(){return this.Ta}ma(e,t){const n=t?t.fa:new yy,r=t?t.Ra:this.Ra;let a=t?t.mutatedKeys:this.mutatedKeys,s=r,i=!1;const o="F"===this.query.limitType&&r.size===this.query.limit?r.last():null,l="L"===this.query.limitType&&r.size===this.query.limit?r.first():null;if(e.inorderTraversal(((e,t)=>{const u=r.get(e),c=Bp(this.query,t)?t:null,d=!!u&&this.mutatedKeys.has(u.key),h=!!c&&(c.hasLocalMutations||this.mutatedKeys.has(c.key)&&c.hasCommittedMutations);let p=!1;u&&c?u.data.isEqual(c.data)?d!==h&&(n.track({type:3,doc:c}),p=!0):this.ga(u,c)||(n.track({type:2,doc:c}),p=!0,(o&&this.Aa(c,o)>0||l&&this.Aa(c,l)<0)&&(i=!0)):!u&&c?(n.track({type:0,doc:c}),p=!0):u&&!c&&(n.track({type:1,doc:u}),p=!0,(o||l)&&(i=!0)),p&&(c?(s=s.add(c),a=h?a.add(e):a.delete(e)):(s=s.delete(e),a=a.delete(e)))})),null!==this.query.limit)for(;s.size>this.query.limit;){const e="F"===this.query.limitType?s.last():s.first();s=s.delete(e.key),a=a.delete(e.key),n.track({type:1,doc:e})}return{Ra:s,fa:n,ns:i,mutatedKeys:a}}ga(e,t){return e.hasLocalMutations&&t.hasCommittedMutations&&!t.hasLocalMutations}applyChanges(e,t,n,r){const a=this.Ra;this.Ra=e.Ra,this.mutatedKeys=e.mutatedKeys;const s=e.fa.G_();s.sort(((e,t)=>function(e,t){const n=e=>{switch(e){case 0:return 1;case 2:case 3:return 2;case 1:return 0;default:return Cd()}};return n(e)-n(t)}(e.type,t.type)||this.Aa(e.doc,t.doc))),this.pa(n),r=null!=r&&r;const i=t&&!r?this.ya():[],o=0===this.da.size&&this.current&&!r?1:0,l=o!==this.Ea;return this.Ea=o,0!==s.length||l?{snapshot:new by(this.query,e.Ra,a,s,e.mutatedKeys,0===o,l,!1,!!n&&n.resumeToken.approximateByteSize()>0),wa:i}:{wa:i}}Z_(e){return this.current&&"Offline"===e?(this.current=!1,this.applyChanges({Ra:this.Ra,fa:new yy,mutatedKeys:this.mutatedKeys,ns:!1},!1)):{wa:[]}}Sa(e){return!this.Ta.has(e)&&!!this.Ra.has(e)&&!this.Ra.get(e).hasLocalMutations}pa(e){e&&(e.addedDocuments.forEach((e=>this.Ta=this.Ta.add(e))),e.modifiedDocuments.forEach((e=>{})),e.removedDocuments.forEach((e=>this.Ta=this.Ta.delete(e))),this.current=e.current)}ya(){if(!this.current)return[];const e=this.da;this.da=tf(),this.Ra.forEach((e=>{this.Sa(e.key)&&(this.da=this.da.add(e.key))}));const t=[];return e.forEach((e=>{this.da.has(e)||t.push(new $y(e))})),this.da.forEach((n=>{e.has(n)||t.push(new _y(n))})),t}ba(e){this.Ta=e.Ts,this.da=tf();const t=this.ma(e.documents);return this.applyChanges(t,!0)}Da(){return by.fromInitialDocuments(this.query,this.Ra,this.mutatedKeys,0===this.Ea,this.hasCachedResults)}}class Dy{constructor(e,t,n){this.query=e,this.targetId=t,this.view=n}}class My{constructor(e){this.key=e,this.va=!1}}class Fy{constructor(e,t,n,r,a,s){this.localStore=e,this.remoteStore=t,this.eventManager=n,this.sharedClientState=r,this.currentUser=a,this.maxConcurrentLimboResolutions=s,this.Ca={},this.Fa=new jp((e=>Lp(e)),Pp),this.Ma=new Map,this.xa=new Set,this.Oa=new bh(Xd.comparator),this.Na=new Map,this.La=new Jm,this.Ba={},this.ka=new Map,this.qa=Gm.kn(),this.onlineState="Unknown",this.Qa=void 0}get isPrimaryClient(){return!0===this.Qa}}async function Oy(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=rb(e);let a;const s=r.Fa.get(t);return s?(r.sharedClientState.addLocalQueryTarget(s.targetId),a=s.view.Da()):a=await Ly(r,t,n,!0),a}async function Py(e,t){const n=rb(e);await Ly(n,t,!0,!1)}async function Ly(e,t,n,r){const a=await gg(e.localStore,Mp(t)),s=a.targetId,i=n?e.sharedClientState.addLocalQueryTarget(s):"not-current";let o;return r&&(o=await zy(e,t,s,"current"===i,a.resumeToken)),e.isPrimaryClient&&n&&Wg(e.remoteStore,a),o}async function zy(e,t,n,r,a){e.Ka=(t,n,r)=>async function(e,t,n,r){let a=t.view.ma(n);a.ns&&(a=await bg(e.localStore,t.query,!1).then((e=>{let{documents:n}=e;return t.view.ma(n,a)})));const s=r&&r.targetChanges.get(t.targetId),i=r&&null!=r.targetMismatches.get(t.targetId),o=t.view.applyChanges(a,e.isPrimaryClient,s,i);return Qy(e,t.targetId,o.wa),o.snapshot}(e,t,n,r);const s=await bg(e.localStore,t,!0),i=new Ry(t,s.Ts),o=i.ma(s.documents),l=Jf.createSynthesizedTargetChangeForCurrentChange(n,r&&"Offline"!==e.onlineState,a),u=i.applyChanges(o,e.isPrimaryClient,l);Qy(e,n,u.wa);const c=new Dy(t,n,i);return e.Fa.set(t,c),e.Ma.has(n)?e.Ma.get(n).push(t):e.Ma.set(n,[t]),u.snapshot}async function By(e,t,n){const r=Td(e),a=r.Fa.get(t),s=r.Ma.get(a.targetId);if(s.length>1)return r.Ma.set(a.targetId,s.filter((e=>!Pp(e,t)))),void r.Fa.delete(t);r.isPrimaryClient?(r.sharedClientState.removeLocalQueryTarget(a.targetId),r.sharedClientState.isActiveQueryTarget(a.targetId)||await yg(r.localStore,a.targetId,!1).then((()=>{r.sharedClientState.clearQueryState(a.targetId),n&&Vg(r.remoteStore,a.targetId),Xy(r,a.targetId)})).catch(rh)):(Xy(r,a.targetId),await yg(r.localStore,a.targetId,!0))}async function Wy(e,t){const n=Td(e),r=n.Fa.get(t),a=n.Ma.get(r.targetId);n.isPrimaryClient&&1===a.length&&(n.sharedClientState.removeLocalQueryTarget(r.targetId),Vg(n.remoteStore,r.targetId))}async function Vy(e,t){const n=Td(e);try{const e=await function(e,t){const n=Td(e),r=t.snapshotVersion;let a=n.os;return n.persistence.runTransaction("Apply remote event","readwrite-primary",(e=>{const s=n.cs.newChangeBuffer({trackRemovals:!0});a=n.os;const i=[];t.targetChanges.forEach(((s,o)=>{const l=a.get(o);if(!l)return;i.push(n.Ur.removeMatchingKeys(e,s.removedDocuments,o).next((()=>n.Ur.addMatchingKeys(e,s.addedDocuments,o))));let u=l.withSequenceNumber(e.currentSequenceNumber);null!==t.targetMismatches.get(o)?u=u.withResumeToken(Ch.EMPTY_BYTE_STRING,jd.min()).withLastLimboFreeSnapshotVersion(jd.min()):s.resumeToken.approximateByteSize()>0&&(u=u.withResumeToken(s.resumeToken,r)),a=a.insert(o,u),function(e,t,n){return 0===e.resumeToken.approximateByteSize()||t.snapshotVersion.toMicroseconds()-e.snapshotVersion.toMicroseconds()>=3e8||n.addedDocuments.size+n.modifiedDocuments.size+n.removedDocuments.size>0}(l,u,s)&&i.push(n.Ur.updateTargetData(e,u))}));let o=Hp(),l=tf();if(t.documentUpdates.forEach((r=>{t.resolvedLimboDocuments.has(r)&&i.push(n.persistence.referenceDelegate.updateLimboDocument(e,r))})),i.push(fg(e,s,t.documentUpdates).next((e=>{o=e.Ps,l=e.Is}))),!r.isEqual(jd.min())){const t=n.Ur.getLastRemoteSnapshotVersion(e).next((t=>n.Ur.setTargetsMetadata(e,e.currentSequenceNumber,r)));i.push(t)}return ah.waitFor(i).next((()=>s.apply(e))).next((()=>n.localDocuments.getLocalViewOfDocuments(e,o,l))).next((()=>o))})).then((e=>(n.os=a,e)))}(n.localStore,t);t.targetChanges.forEach(((e,t)=>{const r=n.Na.get(t);r&&(Nd(e.addedDocuments.size+e.modifiedDocuments.size+e.removedDocuments.size<=1),e.addedDocuments.size>0?r.va=!0:e.modifiedDocuments.size>0?Nd(r.va):e.removedDocuments.size>0&&(Nd(r.va),r.va=!1))})),await eb(n,e,t)}catch(e){await rh(e)}}function Uy(e,t,n){const r=Td(e);if(r.isPrimaryClient&&0===n||!r.isPrimaryClient&&1===n){const e=[];r.Fa.forEach(((n,r)=>{const a=r.view.Z_(t);a.snapshot&&e.push(a.snapshot)})),function(e,t){const n=Td(e);n.onlineState=t;let r=!1;n.queries.forEach(((e,n)=>{for(const a of n.j_)a.Z_(t)&&(r=!0)})),r&&Ny(n)}(r.eventManager,t),e.length&&r.Ca.d_(e),r.onlineState=t,r.isPrimaryClient&&r.sharedClientState.setOnlineState(t)}}async function jy(e,t,n){const r=Td(e);r.sharedClientState.updateQueryState(t,"rejected",n);const a=r.Na.get(t),s=a&&a.key;if(s){let e=new bh(Xd.comparator);e=e.insert(s,ep.newNoDocument(s,jd.min()));const n=tf().add(s),a=new Qf(jd.min(),new Map,new bh(Wd),e,n);await Vy(r,a),r.Oa=r.Oa.remove(s),r.Na.delete(t),Zy(r)}else await yg(r.localStore,t,!1).then((()=>Xy(r,t,n))).catch(rh)}async function Gy(e,t){const n=Td(e),r=t.batch.batchId;try{const e=await function(e,t){const n=Td(e);return n.persistence.runTransaction("Acknowledge batch","readwrite-primary",(e=>{const r=t.batch.keys(),a=n.cs.newChangeBuffer({trackRemovals:!0});return function(e,t,n,r){const a=n.batch,s=a.keys();let i=ah.resolve();return s.forEach((e=>{i=i.next((()=>r.getEntry(t,e))).next((t=>{const s=n.docVersions.get(e);Nd(null!==s),t.version.compareTo(s)<0&&(a.applyToRemoteDocument(t,n),t.isValidDocument()&&(t.setReadTime(n.commitVersion),r.addEntry(t)))}))})),i.next((()=>e.mutationQueue.removeMutationBatch(t,a)))}(n,e,t,a).next((()=>a.apply(e))).next((()=>n.mutationQueue.performConsistencyCheck(e))).next((()=>n.documentOverlayCache.removeOverlaysForBatchId(e,r,t.batch.batchId))).next((()=>n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e,function(e){let t=tf();for(let n=0;n<e.mutationResults.length;++n)e.mutationResults[n].transformResults.length>0&&(t=t.add(e.batch.mutations[n].key));return t}(t)))).next((()=>n.localDocuments.getDocuments(e,r)))}))}(n.localStore,t);Ky(n,r,null),qy(n,r),n.sharedClientState.updateMutationState(r,"acknowledged"),await eb(n,e)}catch(e){await rh(e)}}async function Hy(e,t,n){const r=Td(e);try{const e=await function(e,t){const n=Td(e);return n.persistence.runTransaction("Reject batch","readwrite-primary",(e=>{let r;return n.mutationQueue.lookupMutationBatch(e,t).next((t=>(Nd(null!==t),r=t.keys(),n.mutationQueue.removeMutationBatch(e,t)))).next((()=>n.mutationQueue.performConsistencyCheck(e))).next((()=>n.documentOverlayCache.removeOverlaysForBatchId(e,r,t))).next((()=>n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e,r))).next((()=>n.localDocuments.getDocuments(e,r)))}))}(r.localStore,t);Ky(r,t,n),qy(r,t),r.sharedClientState.updateMutationState(t,"rejected",n),await eb(r,e)}catch(n){await rh(n)}}function qy(e,t){(e.ka.get(t)||[]).forEach((e=>{e.resolve()})),e.ka.delete(t)}function Ky(e,t,n){const r=Td(e);let a=r.Ba[r.currentUser.toKey()];if(a){const e=a.get(t);e&&(n?e.reject(n):e.resolve(),a=a.remove(t)),r.Ba[r.currentUser.toKey()]=a}}function Xy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;e.sharedClientState.removeLocalQueryTarget(t);for(const r of e.Ma.get(t))e.Fa.delete(r),n&&e.Ca.$a(r,n);e.Ma.delete(t),e.isPrimaryClient&&e.La.gr(t).forEach((t=>{e.La.containsKey(t)||Yy(e,t)}))}function Yy(e,t){e.xa.delete(t.path.canonicalString());const n=e.Oa.get(t);null!==n&&(Vg(e.remoteStore,n),e.Oa=e.Oa.remove(t),e.Na.delete(n),Zy(e))}function Qy(e,t,n){for(const r of n)r instanceof _y?(e.La.addReference(r.key,t),Jy(e,r)):r instanceof $y?(wd("SyncEngine","Document no longer in limbo: "+r.key),e.La.removeReference(r.key,t),e.La.containsKey(r.key)||Yy(e,r.key)):Cd()}function Jy(e,t){const n=t.key,r=n.path.canonicalString();e.Oa.get(n)||e.xa.has(r)||(wd("SyncEngine","New document in limbo: "+n),e.xa.add(r),Zy(e))}function Zy(e){for(;e.xa.size>0&&e.Oa.size<e.maxConcurrentLimboResolutions;){const t=e.xa.values().next().value;e.xa.delete(t);const n=new Xd(Hd.fromString(t)),r=e.qa.next();e.Na.set(r,new My(n)),e.Oa=e.Oa.insert(n,r),Wg(e.remoteStore,new Lm(Mp(_p(n.path)),r,"TargetPurposeLimboResolution",oh.oe))}}async function eb(e,t,n){const r=Td(e),a=[],s=[],i=[];r.Fa.isEmpty()||(r.Fa.forEach(((e,o)=>{i.push(r.Ka(o,t,n).then((e=>{var t;if((e||n)&&r.isPrimaryClient){const a=e?!e.fromCache:null===(t=null==n?void 0:n.targetChanges.get(o.targetId))||void 0===t?void 0:t.current;r.sharedClientState.updateQueryState(o.targetId,a?"current":"not-current")}if(e){a.push(e);const t=og.Wi(o.targetId,e);s.push(t)}})))})),await Promise.all(i),r.Ca.d_(a),await async function(e,t){const n=Td(e);try{await n.persistence.runTransaction("notifyLocalViewChanges","readwrite",(e=>ah.forEach(t,(t=>ah.forEach(t.$i,(r=>n.persistence.referenceDelegate.addReference(e,t.targetId,r))).next((()=>ah.forEach(t.Ui,(r=>n.persistence.referenceDelegate.removeReference(e,t.targetId,r)))))))))}catch(e){if(!ih(e))throw e;wd("LocalStore","Failed to update sequence numbers: "+e)}for(const r of t){const e=r.targetId;if(!r.fromCache){const t=n.os.get(e),r=t.snapshotVersion,a=t.withLastLimboFreeSnapshotVersion(r);n.os=n.os.insert(e,a)}}}(r.localStore,s))}async function tb(e,t){const n=Td(e);if(!n.currentUser.isEqual(t)){wd("SyncEngine","User change. New user:",t.toKey());const e=await hg(n.localStore,t);n.currentUser=t,function(e,t){e.ka.forEach((e=>{e.forEach((e=>{e.reject(new Ad(Ed.CANCELLED,t))}))})),e.ka.clear()}(n,"'waitForPendingWrites' promise is rejected due to a user change."),n.sharedClientState.handleUserChange(t,e.removedBatchIds,e.addedBatchIds),await eb(n,e.hs)}}function nb(e,t){const n=Td(e),r=n.Na.get(t);if(r&&r.va)return tf().add(r.key);{let e=tf();const r=n.Ma.get(t);if(!r)return e;for(const t of r){const r=n.Fa.get(t);e=e.unionWith(r.view.Va)}return e}}function rb(e){const t=Td(e);return t.remoteStore.remoteSyncer.applyRemoteEvent=Vy.bind(null,t),t.remoteStore.remoteSyncer.getRemoteKeysForTarget=nb.bind(null,t),t.remoteStore.remoteSyncer.rejectListen=jy.bind(null,t),t.Ca.d_=Iy.bind(null,t.eventManager),t.Ca.$a=Cy.bind(null,t.eventManager),t}function ab(e){const t=Td(e);return t.remoteStore.remoteSyncer.applySuccessfulWrite=Gy.bind(null,t),t.remoteStore.remoteSyncer.rejectFailedWrite=Hy.bind(null,t),t}class sb{constructor(){this.synchronizeTabs=!1}async initialize(e){this.serializer=$g(e.databaseInfo.databaseId),this.sharedClientState=this.createSharedClientState(e),this.persistence=this.createPersistence(e),await this.persistence.start(),this.localStore=this.createLocalStore(e),this.gcScheduler=this.createGarbageCollectionScheduler(e,this.localStore),this.indexBackfillerScheduler=this.createIndexBackfillerScheduler(e,this.localStore)}createGarbageCollectionScheduler(e,t){return null}createIndexBackfillerScheduler(e,t){return null}createLocalStore(e){return dg(this.persistence,new ug,e.initialUser,this.serializer)}createPersistence(e){return new ag(ig.Zr,this.serializer)}createSharedClientState(e){return new wg}async terminate(){var e,t;null===(e=this.gcScheduler)||void 0===e||e.stop(),null===(t=this.indexBackfillerScheduler)||void 0===t||t.stop(),this.sharedClientState.shutdown(),await this.persistence.shutdown()}}class ib{async initialize(e,t){this.localStore||(this.localStore=e.localStore,this.sharedClientState=e.sharedClientState,this.datastore=this.createDatastore(t),this.remoteStore=this.createRemoteStore(t),this.eventManager=this.createEventManager(t),this.syncEngine=this.createSyncEngine(t,!e.synchronizeTabs),this.sharedClientState.onlineStateHandler=e=>Uy(this.syncEngine,e,1),this.remoteStore.remoteSyncer.handleCredentialChange=tb.bind(null,this.syncEngine),await dy(this.remoteStore,this.syncEngine.isPrimaryClient))}createEventManager(e){return new xy}createDatastore(e){const t=$g(e.databaseInfo.databaseId),n=function(e){return new Ag(e)}(e.databaseInfo);return function(e,t,n,r){return new Og(e,t,n,r)}(e.authCredentials,e.appCheckCredentials,n,t)}createRemoteStore(e){return function(e,t,n,r,a){return new Lg(e,t,n,r,a)}(this.localStore,this.datastore,e.asyncQueue,(e=>Uy(this.syncEngine,e,0)),Sg.D()?new Sg:new kg)}createSyncEngine(e,t){return function(e,t,n,r,a,s,i){const o=new Fy(e,t,n,r,a,s);return i&&(o.Qa=!0),o}(this.localStore,this.remoteStore,this.eventManager,this.sharedClientState,e.initialUser,e.maxConcurrentLimboResolutions,t)}async terminate(){var e,t;await async function(e){const t=Td(e);wd("RemoteStore","RemoteStore shutting down."),t.L_.add(5),await Bg(t),t.k_.shutdown(),t.q_.set("Unknown")}(this.remoteStore),null===(e=this.datastore)||void 0===e||e.terminate(),null===(t=this.eventManager)||void 0===t||t.terminate()}}class ob{constructor(e){this.observer=e,this.muted=!1}next(e){this.observer.next&&this.Ga(this.observer.next,e)}error(e){this.observer.error?this.Ga(this.observer.error,e):kd("Uncaught Error in snapshot listener:",e.toString())}za(){this.muted=!0}Ga(e,t){this.muted||setTimeout((()=>{this.muted||e(t)}),0)}}class lb{constructor(e,t,n,r){this.authCredentials=e,this.appCheckCredentials=t,this.asyncQueue=n,this.databaseInfo=r,this.user=yd.UNAUTHENTICATED,this.clientId=Bd.newId(),this.authCredentialListener=()=>Promise.resolve(),this.appCheckCredentialListener=()=>Promise.resolve(),this.authCredentials.start(n,(async e=>{wd("FirestoreClient","Received user=",e.uid),await this.authCredentialListener(e),this.user=e})),this.appCheckCredentials.start(n,(e=>(wd("FirestoreClient","Received new app check token=",e),this.appCheckCredentialListener(e,this.user))))}get configuration(){return{asyncQueue:this.asyncQueue,databaseInfo:this.databaseInfo,clientId:this.clientId,authCredentials:this.authCredentials,appCheckCredentials:this.appCheckCredentials,initialUser:this.user,maxConcurrentLimboResolutions:100}}setCredentialChangeListener(e){this.authCredentialListener=e}setAppCheckTokenChangeListener(e){this.appCheckCredentialListener=e}verifyNotTerminated(){if(this.asyncQueue.isShuttingDown)throw new Ad(Ed.FAILED_PRECONDITION,"The client has already been terminated.")}terminate(){this.asyncQueue.enterRestrictedMode();const e=new _d;return this.asyncQueue.enqueueAndForgetEvenWhileRestricted((async()=>{try{this._onlineComponents&&await this._onlineComponents.terminate(),this._offlineComponents&&await this._offlineComponents.terminate(),this.authCredentials.shutdown(),this.appCheckCredentials.shutdown(),e.resolve()}catch(t){const n=my(t,"Failed to shutdown persistence");e.reject(n)}})),e.promise}}async function ub(e,t){e.asyncQueue.verifyOperationInProgress(),wd("FirestoreClient","Initializing OfflineComponentProvider");const n=e.configuration;await t.initialize(n);let r=n.initialUser;e.setCredentialChangeListener((async e=>{r.isEqual(e)||(await hg(t.localStore,e),r=e)})),t.persistence.setDatabaseDeletedListener((()=>e.terminate())),e._offlineComponents=t}async function cb(e,t){e.asyncQueue.verifyOperationInProgress();const n=await hb(e);wd("FirestoreClient","Initializing OnlineComponentProvider"),await t.initialize(n,e.configuration),e.setCredentialChangeListener((e=>cy(t.remoteStore,e))),e.setAppCheckTokenChangeListener(((e,n)=>cy(t.remoteStore,n))),e._onlineComponents=t}function db(e){return"FirebaseError"===e.name?e.code===Ed.FAILED_PRECONDITION||e.code===Ed.UNIMPLEMENTED:!("undefined"!=typeof DOMException&&e instanceof DOMException)||22===e.code||20===e.code||11===e.code}async function hb(e){if(!e._offlineComponents)if(e._uninitializedComponentsProvider){wd("FirestoreClient","Using user provided OfflineComponentProvider");try{await ub(e,e._uninitializedComponentsProvider._offline)}catch(t){const n=t;if(!db(n))throw n;Sd("Error using user provided cache. Falling back to memory cache: "+n),await ub(e,new sb)}}else wd("FirestoreClient","Using default OfflineComponentProvider"),await ub(e,new sb);return e._offlineComponents}async function pb(e){return e._onlineComponents||(e._uninitializedComponentsProvider?(wd("FirestoreClient","Using user provided OnlineComponentProvider"),await cb(e,e._uninitializedComponentsProvider._online)):(wd("FirestoreClient","Using default OnlineComponentProvider"),await cb(e,new ib))),e._onlineComponents}function fb(e){return pb(e).then((e=>e.syncEngine))}async function mb(e){const t=await pb(e),n=t.eventManager;return n.onListen=Oy.bind(null,t.syncEngine),n.onUnlisten=By.bind(null,t.syncEngine),n.onFirstRemoteStoreListen=Py.bind(null,t.syncEngine),n.onLastRemoteStoreUnlisten=Wy.bind(null,t.syncEngine),n}function gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new _d;return e.asyncQueue.enqueueAndForget((async()=>function(e,t,n,r,a){const s=new ob({next:s=>{t.enqueueAndForget((()=>Sy(e,i)));const o=s.docs.has(n);!o&&s.fromCache?a.reject(new Ad(Ed.UNAVAILABLE,"Failed to get document because the client is offline.")):o&&s.fromCache&&r&&"server"===r.source?a.reject(new Ad(Ed.UNAVAILABLE,'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')):a.resolve(s)},error:e=>a.reject(e)}),i=new Ay(_p(n.path),s,{includeMetadataChanges:!0,_a:!0});return ky(e,i)}(await mb(e),e.asyncQueue,t,n,r))),r.promise}function yb(e){const t={};return void 0!==e.timeoutSeconds&&(t.timeoutSeconds=e.timeoutSeconds),t}const bb=new Map;function vb(e,t,n){if(!n)throw new Ad(Ed.INVALID_ARGUMENT,`Function ${e}() cannot be called with an empty ${t}.`)}function xb(e){if(!Xd.isDocumentKey(e))throw new Ad(Ed.INVALID_ARGUMENT,`Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`)}function wb(e){if(Xd.isDocumentKey(e))throw new Ad(Ed.INVALID_ARGUMENT,`Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`)}function kb(e){if(void 0===e)return"undefined";if(null===e)return"null";if("string"==typeof e)return e.length>20&&(e=`${e.substring(0,20)}...`),JSON.stringify(e);if("number"==typeof e||"boolean"==typeof e)return""+e;if("object"==typeof e){if(e instanceof Array)return"an array";{const t=function(e){return e.constructor?e.constructor.name:null}(e);return t?`a custom ${t} object`:"an object"}}return"function"==typeof e?"a function":Cd()}function Sb(e,t){if("_delegate"in e&&(e=e._delegate),!(e instanceof t)){if(t.name===e.constructor.name)throw new Ad(Ed.INVALID_ARGUMENT,"Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");{const n=kb(e);throw new Ad(Ed.INVALID_ARGUMENT,`Expected type '${t.name}', but it was: ${n}`)}}return e}class Ib{constructor(e){var t,n;if(void 0===e.host){if(void 0!==e.ssl)throw new Ad(Ed.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");this.host="firestore.googleapis.com",this.ssl=!0}else this.host=e.host,this.ssl=null===(t=e.ssl)||void 0===t||t;if(this.credentials=e.credentials,this.ignoreUndefinedProperties=!!e.ignoreUndefinedProperties,this.localCache=e.localCache,void 0===e.cacheSizeBytes)this.cacheSizeBytes=41943040;else{if(-1!==e.cacheSizeBytes&&e.cacheSizeBytes<1048576)throw new Ad(Ed.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");this.cacheSizeBytes=e.cacheSizeBytes}(function(e,t,n,r){if(!0===t&&!0===r)throw new Ad(Ed.INVALID_ARGUMENT,`${e} and ${n} cannot be used together.`)})("experimentalForceLongPolling",e.experimentalForceLongPolling,"experimentalAutoDetectLongPolling",e.experimentalAutoDetectLongPolling),this.experimentalForceLongPolling=!!e.experimentalForceLongPolling,this.experimentalForceLongPolling?this.experimentalAutoDetectLongPolling=!1:void 0===e.experimentalAutoDetectLongPolling?this.experimentalAutoDetectLongPolling=!0:this.experimentalAutoDetectLongPolling=!!e.experimentalAutoDetectLongPolling,this.experimentalLongPollingOptions=yb(null!==(n=e.experimentalLongPollingOptions)&&void 0!==n?n:{}),function(e){if(void 0!==e.timeoutSeconds){if(isNaN(e.timeoutSeconds))throw new Ad(Ed.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (must not be NaN)`);if(e.timeoutSeconds<5)throw new Ad(Ed.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (minimum allowed value is 5)`);if(e.timeoutSeconds>30)throw new Ad(Ed.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (maximum allowed value is 30)`)}}(this.experimentalLongPollingOptions),this.useFetchStreams=!!e.useFetchStreams}isEqual(e){return this.host===e.host&&this.ssl===e.ssl&&this.credentials===e.credentials&&this.cacheSizeBytes===e.cacheSizeBytes&&this.experimentalForceLongPolling===e.experimentalForceLongPolling&&this.experimentalAutoDetectLongPolling===e.experimentalAutoDetectLongPolling&&function(e,t){return e.timeoutSeconds===t.timeoutSeconds}(this.experimentalLongPollingOptions,e.experimentalLongPollingOptions)&&this.ignoreUndefinedProperties===e.ignoreUndefinedProperties&&this.useFetchStreams===e.useFetchStreams}}class Cb{constructor(e,t,n,r){this._authCredentials=e,this._appCheckCredentials=t,this._databaseId=n,this._app=r,this.type="firestore-lite",this._persistenceKey="(lite)",this._settings=new Ib({}),this._settingsFrozen=!1}get app(){if(!this._app)throw new Ad(Ed.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is not available");return this._app}get _initialized(){return this._settingsFrozen}get _terminated(){return void 0!==this._terminateTask}_setSettings(e){if(this._settingsFrozen)throw new Ad(Ed.FAILED_PRECONDITION,"Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");this._settings=new Ib(e),void 0!==e.credentials&&(this._authCredentials=function(e){if(!e)return new Rd;switch(e.type){case"firstParty":return new Od(e.sessionIndex||"0",e.iamToken||null,e.authTokenFactory||null);case"provider":return e.client;default:throw new Ad(Ed.INVALID_ARGUMENT,"makeAuthCredentialsProvider failed due to invalid credential type")}}(e.credentials))}_getSettings(){return this._settings}_freezeSettings(){return this._settingsFrozen=!0,this._settings}_delete(){return this._terminateTask||(this._terminateTask=this._terminate()),this._terminateTask}toJSON(){return{app:this._app,databaseId:this._databaseId,settings:this._settings}}_terminate(){return function(e){const t=bb.get(e);t&&(wd("ComponentProvider","Removing Datastore"),bb.delete(e),t.terminate())}(this),Promise.resolve()}}function Nb(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};var a;const s=(e=Sb(e,Cb))._getSettings(),i=`${t}:${n}`;if("firestore.googleapis.com"!==s.host&&s.host!==i&&Sd("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."),e._setSettings(Object.assign(Object.assign({},s),{host:i,ssl:!1})),r.mockUserToken){let t,n;if("string"==typeof r.mockUserToken)t=r.mockUserToken,n=yd.MOCK_USER;else{t=function(e,t){if(e.uid)throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');const n=t||"demo-project",r=e.iat||0,a=e.sub||e.user_id;if(!a)throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");const s=Object.assign({iss:`https://securetoken.google.com/${n}`,aud:n,iat:r,exp:r+3600,auth_time:r,sub:a,user_id:a,firebase:{sign_in_provider:"custom",identities:{}}},e);return[du(JSON.stringify({alg:"none",type:"JWT"})),du(JSON.stringify(s)),""].join(".")}(r.mockUserToken,null===(a=e._app)||void 0===a?void 0:a.options.projectId);const s=r.mockUserToken.sub||r.mockUserToken.user_id;if(!s)throw new Ad(Ed.INVALID_ARGUMENT,"mockUserToken must contain 'sub' or 'user_id' field!");n=new yd(s)}e._authCredentials=new Dd(new $d(t,n))}}class Tb{constructor(e,t,n){this.converter=t,this._query=n,this.type="query",this.firestore=e}withConverter(e){return new Tb(this.firestore,e,this._query)}}class Eb{constructor(e,t,n){this.converter=t,this._key=n,this.type="document",this.firestore=e}get _path(){return this._key.path}get id(){return this._key.path.lastSegment()}get path(){return this._key.path.canonicalString()}get parent(){return new Ab(this.firestore,this.converter,this._key.path.popLast())}withConverter(e){return new Eb(this.firestore,e,this._key)}}class Ab extends Tb{constructor(e,t,n){super(e,t,_p(n)),this._path=n,this.type="collection"}get id(){return this._query.path.lastSegment()}get path(){return this._query.path.canonicalString()}get parent(){const e=this._path.popLast();return e.isEmpty()?null:new Eb(this.firestore,null,new Xd(e))}withConverter(e){return new Ab(this.firestore,e,this._path)}}function _b(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),a=2;a<n;a++)r[a-2]=arguments[a];if(e=Nu(e),vb("collection","path",t),e instanceof Cb){const n=Hd.fromString(t,...r);return wb(n),new Ab(e,null,n)}{if(!(e instanceof Eb||e instanceof Ab))throw new Ad(Ed.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const n=e._path.child(Hd.fromString(t,...r));return wb(n),new Ab(e.firestore,null,n)}}function $b(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),a=2;a<n;a++)r[a-2]=arguments[a];if(e=Nu(e),1===arguments.length&&(t=Bd.newId()),vb("doc","path",t),e instanceof Cb){const n=Hd.fromString(t,...r);return xb(n),new Eb(e,null,new Xd(n))}{if(!(e instanceof Eb||e instanceof Ab))throw new Ad(Ed.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const n=e._path.child(Hd.fromString(t,...r));return xb(n),new Eb(e.firestore,e instanceof Ab?e.converter:null,new Xd(n))}}class Rb{constructor(){this.au=Promise.resolve(),this.uu=[],this.cu=!1,this.lu=[],this.hu=null,this.Pu=!1,this.Iu=!1,this.Tu=[],this.t_=new Rg(this,"async_queue_retry"),this.Eu=()=>{const e=_g();e&&wd("AsyncQueue","Visibility state changed to "+e.visibilityState),this.t_.jo()};const e=_g();e&&"function"==typeof e.addEventListener&&e.addEventListener("visibilitychange",this.Eu)}get isShuttingDown(){return this.cu}enqueueAndForget(e){this.enqueue(e)}enqueueAndForgetEvenWhileRestricted(e){this.du(),this.Au(e)}enterRestrictedMode(e){if(!this.cu){this.cu=!0,this.Iu=e||!1;const t=_g();t&&"function"==typeof t.removeEventListener&&t.removeEventListener("visibilitychange",this.Eu)}}enqueue(e){if(this.du(),this.cu)return new Promise((()=>{}));const t=new _d;return this.Au((()=>this.cu&&this.Iu?Promise.resolve():(e().then(t.resolve,t.reject),t.promise))).then((()=>t.promise))}enqueueRetryable(e){this.enqueueAndForget((()=>(this.uu.push(e),this.Ru())))}async Ru(){if(0!==this.uu.length){try{await this.uu[0](),this.uu.shift(),this.t_.reset()}catch(gD){if(!ih(gD))throw gD;wd("AsyncQueue","Operation failed with retryable error: "+gD)}this.uu.length>0&&this.t_.Go((()=>this.Ru()))}}Au(e){const t=this.au.then((()=>(this.Pu=!0,e().catch((e=>{this.hu=e,this.Pu=!1;const t=function(e){let t=e.message||"";return e.stack&&(t=e.stack.includes(e.message)?e.stack:e.message+"\n"+e.stack),t}(e);throw kd("INTERNAL UNHANDLED ERROR: ",t),e})).then((e=>(this.Pu=!1,e))))));return this.au=t,t}enqueueAfterDelay(e,t,n){this.du(),this.Tu.indexOf(e)>-1&&(t=0);const r=fy.createAndSchedule(this,e,t,n,(e=>this.Vu(e)));return this.lu.push(r),r}du(){this.hu&&Cd()}verifyOperationInProgress(){}async mu(){let e;do{e=this.au,await e}while(e!==this.au)}fu(e){for(const t of this.lu)if(t.timerId===e)return!0;return!1}gu(e){return this.mu().then((()=>{this.lu.sort(((e,t)=>e.targetTimeMs-t.targetTimeMs));for(const t of this.lu)if(t.skipDelay(),"all"!==e&&t.timerId===e)break;return this.mu()}))}pu(e){this.Tu.push(e)}Vu(e){const t=this.lu.indexOf(e);this.lu.splice(t,1)}}class Db extends Cb{constructor(e,t,n,r){super(e,t,n,r),this.type="firestore",this._queue=new Rb,this._persistenceKey=(null==r?void 0:r.name)||"[DEFAULT]"}_terminate(){return this._firestoreClient||Fb(this),this._firestoreClient.terminate()}}function Mb(e){return e._firestoreClient||Fb(e),e._firestoreClient.verifyNotTerminated(),e._firestoreClient}function Fb(e){var t,n,r;const a=e._freezeSettings(),s=function(e,t,n,r){return new Dh(e,t,n,r.host,r.ssl,r.experimentalForceLongPolling,r.experimentalAutoDetectLongPolling,yb(r.experimentalLongPollingOptions),r.useFetchStreams)}(e._databaseId,(null===(t=e._app)||void 0===t?void 0:t.options.appId)||"",e._persistenceKey,a);e._firestoreClient=new lb(e._authCredentials,e._appCheckCredentials,e._queue,s),(null===(n=a.localCache)||void 0===n?void 0:n._offlineComponentProvider)&&(null===(r=a.localCache)||void 0===r?void 0:r._onlineComponentProvider)&&(e._firestoreClient._uninitializedComponentsProvider={_offlineKind:a.localCache.kind,_offline:a.localCache._offlineComponentProvider,_online:a.localCache._onlineComponentProvider})}class Ob{constructor(e){this._byteString=e}static fromBase64String(e){try{return new Ob(Ch.fromBase64String(e))}catch(e){throw new Ad(Ed.INVALID_ARGUMENT,"Failed to construct data from Base64 string: "+e)}}static fromUint8Array(e){return new Ob(Ch.fromUint8Array(e))}toBase64(){return this._byteString.toBase64()}toUint8Array(){return this._byteString.toUint8Array()}toString(){return"Bytes(base64: "+this.toBase64()+")"}isEqual(e){return this._byteString.isEqual(e._byteString)}}class Pb{constructor(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];for(let r=0;r<t.length;++r)if(0===t[r].length)throw new Ad(Ed.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). Field names must not be empty.");this._internalPath=new Kd(t)}isEqual(e){return this._internalPath.isEqual(e._internalPath)}}class Lb{constructor(e){this._methodName=e}}class zb{constructor(e,t){if(!isFinite(e)||e<-90||e>90)throw new Ad(Ed.INVALID_ARGUMENT,"Latitude must be a number between -90 and 90, but was: "+e);if(!isFinite(t)||t<-180||t>180)throw new Ad(Ed.INVALID_ARGUMENT,"Longitude must be a number between -180 and 180, but was: "+t);this._lat=e,this._long=t}get latitude(){return this._lat}get longitude(){return this._long}isEqual(e){return this._lat===e._lat&&this._long===e._long}toJSON(){return{latitude:this._lat,longitude:this._long}}_compareTo(e){return Wd(this._lat,e._lat)||Wd(this._long,e._long)}}class Bb{constructor(e){this._values=(e||[]).map((e=>e))}toArray(){return this._values.map((e=>e))}isEqual(e){return function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(this._values,e._values)}}const Wb=/^__.*__$/;class Vb{constructor(e,t,n){this.data=e,this.fieldMask=t,this.fieldTransforms=n}toMutation(e,t){return null!==this.fieldMask?new _f(e,this.data,this.fieldMask,t,this.fieldTransforms):new Af(e,this.data,t,this.fieldTransforms)}}function Ub(e){switch(e){case 0:case 2:case 1:return!0;case 3:case 4:return!1;default:throw Cd()}}class jb{constructor(e,t,n,r,a,s){this.settings=e,this.databaseId=t,this.serializer=n,this.ignoreUndefinedProperties=r,void 0===a&&this.yu(),this.fieldTransforms=a||[],this.fieldMask=s||[]}get path(){return this.settings.path}get wu(){return this.settings.wu}Su(e){return new jb(Object.assign(Object.assign({},this.settings),e),this.databaseId,this.serializer,this.ignoreUndefinedProperties,this.fieldTransforms,this.fieldMask)}bu(e){var t;const n=null===(t=this.path)||void 0===t?void 0:t.child(e),r=this.Su({path:n,Du:!1});return r.vu(e),r}Cu(e){var t;const n=null===(t=this.path)||void 0===t?void 0:t.child(e),r=this.Su({path:n,Du:!1});return r.yu(),r}Fu(e){return this.Su({path:void 0,Du:!0})}Mu(e){return tv(e,this.settings.methodName,this.settings.xu||!1,this.path,this.settings.Ou)}contains(e){return void 0!==this.fieldMask.find((t=>e.isPrefixOf(t)))||void 0!==this.fieldTransforms.find((t=>e.isPrefixOf(t.field)))}yu(){if(this.path)for(let e=0;e<this.path.length;e++)this.vu(this.path.get(e))}vu(e){if(0===e.length)throw this.Mu("Document fields must not be empty");if(Ub(this.wu)&&Wb.test(e))throw this.Mu('Document fields cannot begin and end with "__"')}}class Gb{constructor(e,t,n){this.databaseId=e,this.ignoreUndefinedProperties=t,this.serializer=n||$g(e)}Nu(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return new jb({wu:e,methodName:t,Ou:n,path:Kd.emptyPath(),Du:!1,xu:r},this.databaseId,this.serializer,this.ignoreUndefinedProperties)}}function Hb(e){const t=e._freezeSettings(),n=$g(e._databaseId);return new Gb(e._databaseId,!!t.ignoreUndefinedProperties,n)}function qb(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};const i=e.Nu(s.merge||s.mergeFields?2:0,t,n,a);Qb("Data must be an object, but it was:",i,r);const o=Xb(r,i);let l,u;if(s.merge)l=new Sh(i.fieldMask),u=i.fieldTransforms;else if(s.mergeFields){const e=[];for(const r of s.mergeFields){const a=Jb(t,r,n);if(!i.contains(a))throw new Ad(Ed.INVALID_ARGUMENT,`Field '${a}' is specified in your field mask but missing from your input data.`);nv(e,a)||e.push(a)}l=new Sh(e),u=i.fieldTransforms.filter((e=>l.covers(e.field)))}else l=null,u=i.fieldTransforms;return new Vb(new Jh(o),l,u)}function Kb(e,t){if(Yb(e=Nu(e)))return Qb("Unsupported field value:",t,e),Xb(e,t);if(e instanceof Lb)return function(e,t){if(!Ub(t.wu))throw t.Mu(`${e._methodName}() can only be used with update() and set()`);if(!t.path)throw t.Mu(`${e._methodName}() is not currently supported inside arrays`);const n=e._toFieldTransform(t);n&&t.fieldTransforms.push(n)}(e,t),null;if(void 0===e&&t.ignoreUndefinedProperties)return null;if(t.path&&t.fieldMask.push(t.path),e instanceof Array){if(t.settings.Du&&4!==t.wu)throw t.Mu("Nested arrays are not supported");return function(e,t){const n=[];let r=0;for(const a of e){let e=Kb(a,t.Fu(r));null==e&&(e={nullValue:"NULL_VALUE"}),n.push(e),r++}return{arrayValue:{values:n}}}(e,t)}return function(e,t){if(null===(e=Nu(e)))return{nullValue:"NULL_VALUE"};if("number"==typeof e)return of(t.serializer,e);if("boolean"==typeof e)return{booleanValue:e};if("string"==typeof e)return{stringValue:e};if(e instanceof Date){const n=Ud.fromDate(e);return{timestampValue:dm(t.serializer,n)}}if(e instanceof Ud){const n=new Ud(e.seconds,1e3*Math.floor(e.nanoseconds/1e3));return{timestampValue:dm(t.serializer,n)}}if(e instanceof zb)return{geoPointValue:{latitude:e.latitude,longitude:e.longitude}};if(e instanceof Ob)return{bytesValue:hm(t.serializer,e._byteString)};if(e instanceof Eb){const n=t.databaseId,r=e.firestore._databaseId;if(!r.isEqual(n))throw t.Mu(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`);return{referenceValue:mm(e.firestore._databaseId||t.databaseId,e._key.path)}}if(e instanceof Bb)return function(e,t){return{mapValue:{fields:{__type__:{stringValue:"__vector__"},value:{arrayValue:{values:e.toArray().map((e=>{if("number"!=typeof e)throw t.Mu("VectorValues must only contain numeric values.");return af(t.serializer,e)}))}}}}}}(e,t);throw t.Mu(`Unsupported field value: ${kb(e)}`)}(e,t)}function Xb(e,t){const n={};return yh(e)?t.path&&t.path.length>0&&t.fieldMask.push(t.path):gh(e,((e,r)=>{const a=Kb(r,t.bu(e));null!=a&&(n[e]=a)})),{mapValue:{fields:n}}}function Yb(e){return!("object"!=typeof e||null===e||e instanceof Array||e instanceof Date||e instanceof Ud||e instanceof zb||e instanceof Ob||e instanceof Eb||e instanceof Lb||e instanceof Bb)}function Qb(e,t,n){if(!Yb(n)||!function(e){return"object"==typeof e&&null!==e&&(Object.getPrototypeOf(e)===Object.prototype||null===Object.getPrototypeOf(e))}(n)){const r=kb(n);throw"an object"===r?t.Mu(e+" a custom object"):t.Mu(e+" "+r)}}function Jb(e,t,n){if((t=Nu(t))instanceof Pb)return t._internalPath;if("string"==typeof t)return ev(e,t);throw tv("Field path arguments must be of type string or ",e,!1,void 0,n)}const Zb=new RegExp("[~\\*/\\[\\]]");function ev(e,t,n){if(t.search(Zb)>=0)throw tv(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`,e,!1,void 0,n);try{return new Pb(...t.split("."))._internalPath}catch(zge){throw tv(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,e,!1,void 0,n)}}function tv(e,t,n,r,a){const s=r&&!r.isEmpty(),i=void 0!==a;let o=`Function ${t}() called with invalid data`;n&&(o+=" (via `toFirestore()`)"),o+=". ";let l="";return(s||i)&&(l+=" (found",s&&(l+=` in field ${r}`),i&&(l+=` in document ${a}`),l+=")"),new Ad(Ed.INVALID_ARGUMENT,o+e+l)}function nv(e,t){return e.some((e=>e.isEqual(t)))}class rv{constructor(e,t,n,r,a){this._firestore=e,this._userDataWriter=t,this._key=n,this._document=r,this._converter=a}get id(){return this._key.path.lastSegment()}get ref(){return new Eb(this._firestore,this._converter,this._key)}exists(){return null!==this._document}data(){if(this._document){if(this._converter){const e=new av(this._firestore,this._userDataWriter,this._key,this._document,null);return this._converter.fromFirestore(e)}return this._userDataWriter.convertValue(this._document.data.value)}}get(e){if(this._document){const t=this._document.data.field(sv("DocumentSnapshot.get",e));if(null!==t)return this._userDataWriter.convertValue(t)}}}class av extends rv{data(){return super.data()}}function sv(e,t){return"string"==typeof t?ev(e,t):t instanceof Pb?t._internalPath:t._delegate._internalPath}class iv{convertValue(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"none";switch(Oh(e)){case 0:return null;case 1:return e.booleanValue;case 2:return Eh(e.integerValue||e.doubleValue);case 3:return this.convertTimestamp(e.timestampValue);case 4:return this.convertServerTimestamp(e,t);case 5:return e.stringValue;case 6:return this.convertBytes(Ah(e.bytesValue));case 7:return this.convertReference(e.referenceValue);case 8:return this.convertGeoPoint(e.geoPointValue);case 9:return this.convertArray(e.arrayValue,t);case 11:return this.convertObject(e.mapValue,t);case 10:return this.convertVectorValue(e.mapValue);default:throw Cd()}}convertObject(e,t){return this.convertObjectMap(e.fields,t)}convertObjectMap(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"none";const n={};return gh(e,((e,r)=>{n[e]=this.convertValue(r,t)})),n}convertVectorValue(e){var t,n,r;const a=null===(r=null===(n=null===(t=e.fields)||void 0===t?void 0:t.value.arrayValue)||void 0===n?void 0:n.values)||void 0===r?void 0:r.map((e=>Eh(e.doubleValue)));return new Bb(a)}convertGeoPoint(e){return new zb(Eh(e.latitude),Eh(e.longitude))}convertArray(e,t){return(e.values||[]).map((e=>this.convertValue(e,t)))}convertServerTimestamp(e,t){switch(t){case"previous":const n=$h(e);return null==n?null:this.convertValue(n,t);case"estimate":return this.convertTimestamp(Rh(e));default:return null}}convertTimestamp(e){const t=Th(e);return new Ud(t.seconds,t.nanos)}convertDocumentKey(e,t){const n=Hd.fromString(e);Nd(Pm(n));const r=new Mh(n.get(1),n.get(3)),a=new Xd(n.popFirst(5));return r.isEqual(t)||kd(`Document ${a} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`),a}}function ov(e,t,n){let r;return r=e?n&&(n.merge||n.mergeFields)?e.toFirestore(t,n):e.toFirestore(t):t,r}class lv{constructor(e,t){this.hasPendingWrites=e,this.fromCache=t}isEqual(e){return this.hasPendingWrites===e.hasPendingWrites&&this.fromCache===e.fromCache}}class uv extends rv{constructor(e,t,n,r,a,s){super(e,t,n,r,s),this._firestore=e,this._firestoreImpl=e,this.metadata=a}exists(){return super.exists()}data(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._document){if(this._converter){const t=new cv(this._firestore,this._userDataWriter,this._key,this._document,this.metadata,null);return this._converter.fromFirestore(t,e)}return this._userDataWriter.convertValue(this._document.data.value,e.serverTimestamps)}}get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(this._document){const n=this._document.data.field(sv("DocumentSnapshot.get",e));if(null!==n)return this._userDataWriter.convertValue(n,t.serverTimestamps)}}}class cv extends uv{data(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return super.data(e)}}class dv extends iv{constructor(e){super(),this.firestore=e}convertBytes(e){return new Ob(e)}convertReference(e){const t=this.convertDocumentKey(e,this.firestore._databaseId);return new Eb(this.firestore,null,t)}}function hv(e,t){const n=Sb(e.firestore,Db),r=$b(e),a=ov(e.converter,t);return pv(n,[qb(Hb(e.firestore),"addDoc",r._key,a,null!==e.converter,{}).toMutation(r._key,wf.exists(!1))]).then((()=>r))}function pv(e,t){return function(e,t){const n=new _d;return e.asyncQueue.enqueueAndForget((async()=>async function(e,t,n){const r=ab(e);try{const e=await function(e,t){const n=Td(e),r=Ud.now(),a=t.reduce(((e,t)=>e.add(t.key)),tf());let s,i;return n.persistence.runTransaction("Locally write mutations","readwrite",(e=>{let o=Hp(),l=tf();return n.cs.getEntries(e,a).next((e=>{o=e,o.forEach(((e,t)=>{t.isValidDocument()||(l=l.add(e))}))})).next((()=>n.localDocuments.getOverlayedDocuments(e,o))).next((a=>{s=a;const i=[];for(const e of t){const t=Tf(e,s.get(e.key).overlayedDocument);null!=t&&i.push(new _f(e.key,t,Zh(t.value.mapValue),wf.exists(!0)))}return n.mutationQueue.addMutationBatch(e,r,i,t)})).next((t=>{i=t;const r=t.applyToLocalDocumentSet(s,l);return n.documentOverlayCache.saveOverlays(e,t.batchId,r)}))})).then((()=>({batchId:i.batchId,changes:Xp(s)})))}(r.localStore,t);r.sharedClientState.addPendingMutation(e.batchId),function(e,t,n){let r=e.Ba[e.currentUser.toKey()];r||(r=new bh(Wd)),r=r.insert(t,n),e.Ba[e.currentUser.toKey()]=r}(r,e.batchId,n),await eb(r,e.changes),await ty(r.remoteStore)}catch(e){const t=my(e,"Failed to persist write");n.reject(t)}}(await fb(e),t,n))),n.promise}(Mb(e),t)}function fv(e,t,n){const r=n.docs.get(t._key),a=new dv(e);return new uv(e,a,t._key,r,new lv(n.hasPendingWrites,n.fromCache),t.converter)}new WeakMap;!function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];!function(e){bd=e}("10.13.1"),Pc(new Tu("firestore",((e,n)=>{let{instanceIdentifier:r,options:a}=n;const s=e.getProvider("app").getImmediate(),i=new Db(new Md(e.getProvider("auth-internal")),new Ld(e.getProvider("app-check-internal")),function(e,t){if(!Object.prototype.hasOwnProperty.apply(e.options,["projectId"]))throw new Ad(Ed.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');return new Mh(e.options.projectId,t)}(s,r),s);return a=Object.assign({useFetchStreams:t},a),i._setSettings(a),i}),"PUBLIC").setMultipleInstances(!0)),Vc(gd,"4.7.1",e),Vc(gd,"4.7.1","esm2017")}();Vc("firebase","10.13.1","app");const mv={NODE_ENV:"production",PUBLIC_URL:"",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0,REACT_APP_API_KEY:"'AIzaSyCMm9VBymR43tOkkv4wQ6szA2yGfH3j3RE';",REACT_APP_APP_ID:"1:1021363670094:web:252b1088a0266e0573c71f",REACT_APP_ENV_SENDER_ID:"1021363670094",REACT_APP_TOKEN:"d891e715-d5ab-49ee-8c4c-d14c25d7fb7a"},gv=function(e,t){const n="object"==typeof e?e:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:$c;const t=Dc.get(e);if(!t&&e===$c&&gu())return Wc();if(!t)throw zc.create("no-app",{appName:e});return t}(),r="string"==typeof e?e:t||"(default)",a=Lc(n,"firestore").getImmediate({identifier:r});if(!a._initialized){const e=mu("firestore");e&&Nb(a,...e)}return a}(Wc({apiKey:mv.REACT_APP_API_KEY,authDomain:"auth-tfjs.firebaseapp.com",projectId:"auth-tfjs",storageBucket:"auth-tfjs.appspot.com",messagingSenderId:mv.REACT_APP_SENDER_ID,appId:mv.REACT_APP_APP_ID})),yv=async e=>{const t=$b(gv,"users",e);return await function(e){e=Sb(e,Eb);const t=Sb(e.firestore,Db);return gb(Mb(t),e._key).then((n=>fv(t,e,n)))}(t)},bv=async e=>{const t=$b(gv,"users",e);var n;await(n=t,pv(Sb(n.firestore,Db),[new Mf(n._key,wf.none())]))},vv=()=>{const e=U((e=>e.user)),t=ee(),n=xn(),[r,a]=(0,T.useState)(!1),[s,i]=(0,T.useState)(""),[o,l]=(0,T.useState)(!1),u=()=>{a(!1),i("")},c=()=>{l(!1),n("/")};return(0,Zn.jsxs)(Wl,{maxWidth:"sm",children:[(0,Zn.jsx)(or,{sx:{mt:8,mb:4},children:(0,Zn.jsxs)(xr,{elevation:3,sx:{p:4,textAlign:"center"},children:[e.name?(0,Zn.jsxs)(Zn.Fragment,{children:[(0,Zn.jsx)(iu.A,{color:"success",sx:{fontSize:60,mb:2}}),(0,Zn.jsxs)(Pr,{variant:"h5",gutterBottom:!0,children:["Welcome, ",e.name,"!"]}),(0,Zn.jsx)(Pr,{variant:"body1",sx:{mb:3},children:"You are successfully logged in."}),(0,Zn.jsxs)(Pr,{variant:"body2",sx:{mb:3},children:["Email: ",e.email]}),(0,Zn.jsxs)(Pr,{variant:"body2",sx:{mb:3},children:["Date of Birth: ",(e=>{const t=new Date(e);return`${String(t.getDate()).padStart(2,"0")}/${String(t.getMonth()+1).padStart(2,"0")}/${t.getFullYear()}`})(e.dateOfBirth)," "]}),(0,Zn.jsx)(sl,{variant:"contained",color:"error",onClick:()=>{a(!0)},children:"Delete Account"})]}):(0,Zn.jsxs)(Zn.Fragment,{children:[(0,Zn.jsx)(ou.A,{color:"error",sx:{fontSize:60,mb:2}}),(0,Zn.jsx)(Pr,{variant:"h5",gutterBottom:!0,children:"Authentication Error"}),(0,Zn.jsx)(Pr,{variant:"body1",sx:{mb:3},children:"Please try again."})]}),!o&&(0,Zn.jsx)(or,{sx:{mt:2},children:(0,Zn.jsx)(sl,{variant:"contained",color:"primary",onClick:()=>n("/login"),children:"Login Again"})})]})}),(0,Zn.jsxs)(Xl,{open:r,onClose:u,children:[(0,Zn.jsx)(Zl,{children:"Delete Account"}),(0,Zn.jsxs)(nu,{children:[(0,Zn.jsx)(Pr,{children:"Please type your email to confirm account deletion:"}),(0,Zn.jsx)(No,{autoFocus:!0,margin:"dense",label:"Email",type:"email",fullWidth:!0,variant:"outlined",value:s,onChange:e=>i(e.target.value)})]}),(0,Zn.jsxs)(su,{children:[(0,Zn.jsx)(sl,{onClick:u,color:"primary",children:"Cancel"}),(0,Zn.jsx)(sl,{onClick:async()=>{if(s===e.email)try{await bv(e.userId),t(kt()),l(!0)}catch(n){console.error("Error deleting user data: ",n)}u()},color:"error",children:"Delete"})]})]}),(0,Zn.jsxs)(Xl,{open:o,onClose:c,children:[(0,Zn.jsx)(Zl,{children:"Account Deleted"}),(0,Zn.jsx)(nu,{children:(0,Zn.jsx)(Pr,{children:"Your account has been deleted successfully. Please note that your biometric is also been deleted."})}),(0,Zn.jsx)(su,{children:(0,Zn.jsx)(sl,{onClick:c,color:"primary",children:"OK"})})]})]})};function xv(e){return(0,gr.Ay)("MuiCard",e)}(0,rr.A)("MuiCard",["root"]);const wv=(0,cr.Ay)(xr,{name:"MuiCard",slot:"Root",overridesResolver:(e,t)=>t.root})({overflow:"hidden"}),kv=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiCard"}),{className:r,raised:a=!1,...s}=n,i={...n,raised:a},o=(e=>{const{classes:t}=e;return(0,lr.A)({root:["root"]},xv,t)})(i);return(0,Zn.jsx)(wv,{className:(0,Wn.A)(o.root,r),elevation:a?8:void 0,ref:t,ownerState:i,...s})}));function Sv(e){return(0,gr.Ay)("MuiCardContent",e)}(0,rr.A)("MuiCardContent",["root"]);const Iv=(0,cr.Ay)("div",{name:"MuiCardContent",slot:"Root",overridesResolver:(e,t)=>t.root})({padding:16,"&:last-child":{paddingBottom:24}}),Cv=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiCardContent"}),{className:r,component:a="div",...s}=n,i={...n,component:a},o=(e=>{const{classes:t}=e;return(0,lr.A)({root:["root"]},Sv,t)})(i);return(0,Zn.jsx)(Iv,{as:a,className:(0,Wn.A)(o.root,r),ownerState:i,ref:t,...s})})),Nv=["localeText"],Tv=T.createContext(null);const Ev=function(e){const{localeText:t}=e,n=$s(e,Nv),{utils:r,localeText:a}=T.useContext(Tv)??{utils:void 0,localeText:void 0},s=mo({props:n,name:"MuiLocalizationProvider"}),{children:i,dateAdapter:o,dateFormats:l,dateLibInstance:u,adapterLocale:c,localeText:d}=s,h=T.useMemo((()=>(0,_o.A)({},d,a,t)),[d,a,t]),p=T.useMemo((()=>{if(!o)return r||null;const e=new o({locale:c,formats:l,instance:u});if(!e.isMUIAdapter)throw new Error(["MUI X: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`","For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`","More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join("\n"));return e}),[o,c,l,u,r]),f=T.useMemo((()=>p?{minDate:p.date("1900-01-01T00:00:00.000"),maxDate:p.date("2099-12-31T00:00:00.000")}:null),[p]),m=T.useMemo((()=>({utils:p,defaultDates:f,localeText:h})),[f,p,h]);return(0,Zn.jsx)(Tv.Provider,{value:m,children:i})};function Av(e,t,n,r,a){const[s,i]=T.useState((()=>a&&n?n(e).matches:r?r(e).matches:t));return(0,Vr.A)((()=>{if(!n)return;const t=n(e),r=()=>{i(t.matches)};return r(),t.addEventListener("change",r),()=>{t.removeEventListener("change",r)}}),[e,n]),s}const _v=E.useSyncExternalStore;function $v(e,t,n,r,a){const s=T.useCallback((()=>t),[t]),i=T.useMemo((()=>{if(a&&n)return()=>n(e).matches;if(null!==r){const{matches:t}=r(e);return()=>t}return s}),[s,e,r,a,n]),[o,l]=T.useMemo((()=>{if(null===n)return[s,()=>()=>{}];const t=n(e);return[()=>t.matches,e=>(t.addEventListener("change",e),()=>{t.removeEventListener("change",e)})]}),[s,n,e]);return _v(l,o,i)}function Rv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Yn(),r="undefined"!==typeof window&&"undefined"!==typeof window.matchMedia,{defaultMatches:a=!1,matchMedia:s=(r?window.matchMedia:null),ssrMatchMedia:i=null,noSsr:o=!1}=po({name:"MuiUseMediaQuery",props:t,theme:n});let l="function"===typeof e?e(n):e;l=l.replace(/^@media( ?)/m,"");return(void 0!==_v?$v:Av)(l,a,s,i,o)}var Dv=n(5173),Mv=n.n(Dv);const Fv=function(e,t,n){return"function"===typeof e?e(t,n):e},Ov=Mv().oneOfType([Mv().func,Mv().object]),Pv=(e,t)=>e.length===t.length&&t.every((t=>e.includes(t))),Lv=(e,t,n)=>{let r=t;return r=e.setHours(r,e.getHours(n)),r=e.setMinutes(r,e.getMinutes(n)),r=e.setSeconds(r,e.getSeconds(n)),r=e.setMilliseconds(r,e.getMilliseconds(n)),r},zv=e=>{let{date:t,disableFuture:n,disablePast:r,maxDate:a,minDate:s,isDateDisabled:i,utils:o,timezone:l}=e;const u=Lv(o,o.date(void 0,l),t);r&&o.isBefore(s,u)&&(s=u),n&&o.isAfter(a,u)&&(a=u);let c=t,d=t;for(o.isBefore(t,s)&&(c=s,d=null),o.isAfter(t,a)&&(d&&(d=a),c=null);c||d;){if(c&&o.isAfter(c,a)&&(c=null),d&&o.isBefore(d,s)&&(d=null),c){if(!i(c))return c;c=o.addDays(c,1)}if(d){if(!i(d))return d;d=o.addDays(d,-1)}}return null},Bv=(e,t,n)=>null!=t&&e.isValid(t)?t:n,Wv=(e,t)=>{const n=[e.startOfYear(t)];for(;n.length<12;){const t=n[n.length-1];n.push(e.addMonths(t,1))}return n},Vv=(e,t,n)=>"date"===n?e.startOfDay(e.date(void 0,t)):e.date(void 0,t),Uv=["year","month","day"],jv=e=>Uv.includes(e),Gv=(e,t,n)=>{let{format:r,views:a}=t;if(null!=r)return r;const s=e.formats;return Pv(a,["year"])?s.year:Pv(a,["month"])?s.month:Pv(a,["day"])?s.dayOfMonth:Pv(a,["month","year"])?`${s.month} ${s.year}`:Pv(a,["day","month"])?`${s.month} ${s.dayOfMonth}`:n?/en/.test(e.getCurrentLocaleCode())?s.normalDateWithWeekday:s.normalDate:s.keyboardDate},Hv=(e,t)=>{const n=e.startOfWeek(t);return[0,1,2,3,4,5,6].map((t=>e.addDays(n,t)))},qv=["hours","minutes","seconds"],Kv=(e,t)=>3600*t.getHours(e)+60*t.getMinutes(e)+t.getSeconds(e),Xv={year:1,month:2,day:3,hours:4,minutes:5,seconds:6,milliseconds:7},Yv=(e,t,n)=>{if(t===Xv.year)return e.startOfYear(n);if(t===Xv.month)return e.startOfMonth(n);if(t===Xv.day)return e.startOfDay(n);let r=n;return t<Xv.minutes&&(r=e.setMinutes(r,0)),t<Xv.seconds&&(r=e.setSeconds(r,0)),t<Xv.milliseconds&&(r=e.setMilliseconds(r,0)),r},Qv=e=>{let{props:t,utils:n,granularity:r,timezone:a,getTodayDate:s}=e,i=s?s():Yv(n,r,Vv(n,a));null!=t.minDate&&n.isAfterDay(t.minDate,i)&&(i=Yv(n,r,t.minDate)),null!=t.maxDate&&n.isBeforeDay(t.maxDate,i)&&(i=Yv(n,r,t.maxDate));const o=((e,t)=>(n,r)=>e?t.isAfter(n,r):Kv(n,t)>Kv(r,t))(t.disableIgnoringDatePartForTimeValidation??!1,n);return null!=t.minTime&&o(t.minTime,i)&&(i=Yv(n,r,t.disableIgnoringDatePartForTimeValidation?t.minTime:Lv(n,i,t.minTime))),null!=t.maxTime&&o(i,t.maxTime)&&(i=Yv(n,r,t.disableIgnoringDatePartForTimeValidation?t.maxTime:Lv(n,i,t.maxTime))),i},Jv=(e,t)=>{const n=e.formatTokenMap[t];if(null==n)throw new Error([`MUI X: The token "${t}" is not supported by the Date and Time Pickers.`,"Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));return"string"===typeof n?{type:n,contentType:"meridiem"===n?"letter":"digit",maxLength:void 0}:{type:n.sectionType,contentType:n.contentType,maxLength:n.maxLength}},Zv=(e,t,n)=>{const r=[],a=e.date(void 0,t),s=e.startOfWeek(a),i=e.endOfWeek(a);let o=s;for(;e.isBefore(o,i);)r.push(o),o=e.addDays(o,1);return r.map((t=>e.formatByString(t,n)))},ex=(e,t,n,r)=>{switch(n){case"month":return Wv(e,e.date(void 0,t)).map((t=>e.formatByString(t,r)));case"weekDay":return Zv(e,t,r);case"meridiem":{const n=e.date(void 0,t);return[e.startOfDay(n),e.endOfDay(n)].map((t=>e.formatByString(t,r)))}default:return[]}},tx=["0","1","2","3","4","5","6","7","8","9"],nx=(e,t)=>{if("0"===t[0])return e;const n=[];let r="";for(let a=0;a<e.length;a+=1){r+=e[a];const s=t.indexOf(r);s>-1&&(n.push(s.toString()),r="")}return n.join("")},rx=(e,t)=>"0"===t[0]?e:e.split("").map((e=>t[Number(e)])).join(""),ax=(e,t)=>{const n=nx(e,t);return" "!==n&&!Number.isNaN(Number(n))},sx=(e,t)=>{let n=e;for(n=Number(n).toString();n.length<t;)n=`0${n}`;return n},ix=(e,t,n,r,a)=>{if("day"===a.type&&"digit-with-letter"===a.contentType){const r=e.setDate(n.longestMonth,t);return e.formatByString(r,a.format)}let s=t.toString();return a.hasLeadingZerosInInput&&(s=sx(s,a.maxLength)),rx(s,r)},ox=(e,t,n,r,a,s,i,o)=>{const l=(e=>{switch(e){case"ArrowUp":return 1;case"ArrowDown":return-1;case"PageUp":return 5;case"PageDown":return-5;default:return 0}})(r),u="Home"===r,c="End"===r,d=""===n.value||u||c;return"digit"===n.contentType||"digit-with-letter"===n.contentType?(()=>{const r=a[n.type]({currentDate:i,format:n.format,contentType:n.contentType}),h=t=>ix(e,t,r,s,n),p="minutes"===n.type&&o?.minutesStep?o.minutesStep:1;let f=parseInt(nx(n.value,s),10)+l*p;if(d){if("year"===n.type&&!c&&!u)return e.formatByString(e.date(void 0,t),n.format);f=l>0||u?r.minimum:r.maximum}return f%p!==0&&((l<0||u)&&(f+=p-(p+f)%p),(l>0||c)&&(f-=f%p)),f>r.maximum?h(r.minimum+(f-r.maximum-1)%(r.maximum-r.minimum+1)):f<r.minimum?h(r.maximum-(r.minimum-f-1)%(r.maximum-r.minimum+1)):h(f)})():(()=>{const r=ex(e,t,n.type,n.format);if(0===r.length)return n.value;if(d)return l>0||u?r[0]:r[r.length-1];const a=r.indexOf(n.value);return r[((a+l)%r.length+r.length)%r.length]})()},lx=(e,t,n)=>{let r=e.value||e.placeholder;const a="non-input"===t?e.hasLeadingZerosInFormat:e.hasLeadingZerosInInput;"non-input"===t&&e.hasLeadingZerosInInput&&!e.hasLeadingZerosInFormat&&(r=Number(nx(r,n)).toString());return["input-rtl","input-ltr"].includes(t)&&"digit"===e.contentType&&!a&&1===r.length&&(r=`${r}\u200e`),"input-rtl"===t&&(r=`\u2068${r}\u2069`),r},ux=(e,t,n,r)=>e.formatByString(e.parse(t,n),r),cx=(e,t,n)=>4===e.formatByString(e.date(void 0,t),n).length,dx=(e,t,n,r,a)=>{if("digit"!==n)return!1;const s=e.date(void 0,t);switch(r){case"year":if(cx(e,t,a)){return"0001"===e.formatByString(e.setYear(s,1),a)}return"01"===e.formatByString(e.setYear(s,2001),a);case"month":return e.formatByString(e.startOfYear(s),a).length>1;case"day":return e.formatByString(e.startOfMonth(s),a).length>1;case"weekDay":return e.formatByString(e.startOfWeek(s),a).length>1;case"hours":return e.formatByString(e.setHours(s,1),a).length>1;case"minutes":return e.formatByString(e.setMinutes(s,1),a).length>1;case"seconds":return e.formatByString(e.setSeconds(s,1),a).length>1;default:throw new Error("Invalid section type")}};const hx=(e,t)=>{0},px={year:1,month:2,day:3,weekDay:4,hours:5,minutes:6,seconds:7,meridiem:8,empty:9},fx=(e,t,n,r,a,s)=>[...r].sort(((e,t)=>px[e.type]-px[t.type])).reduce(((r,a)=>!s||a.modified?((e,t,n,r,a)=>{switch(n.type){case"year":return e.setYear(a,e.getYear(r));case"month":return e.setMonth(a,e.getMonth(r));case"weekDay":{const a=Zv(e,t,n.format),s=e.formatByString(r,n.format),i=a.indexOf(s),o=a.indexOf(n.value)-i;return e.addDays(r,o)}case"day":return e.setDate(a,e.getDate(r));case"meridiem":{const t=e.getHours(r)<12,n=e.getHours(a);return t&&n>=12?e.addHours(a,-12):!t&&n<12?e.addHours(a,12):a}case"hours":return e.setHours(a,e.getHours(r));case"minutes":return e.setMinutes(a,e.getMinutes(r));case"seconds":return e.setSeconds(a,e.getSeconds(r));default:return a}})(e,t,a,n,r):r),a),mx=(e,t)=>null==e?null:"all"===e?"all":"string"===typeof e?t.findIndex((t=>t.type===e)):e,gx=(e,t)=>{if(e.value)switch(e.type){case"month":{if("digit"===e.contentType)return t.format(t.setMonth(t.date(),Number(e.value)-1),"month");const n=t.parse(e.value,e.format);return n?t.format(n,"month"):void 0}case"day":return"digit"===e.contentType?t.format(t.setDate(t.startOfYear(t.date()),Number(e.value)),"dayOfMonthFull"):e.value;default:return}},yx=(e,t)=>{if(e.value)switch(e.type){case"weekDay":if("letter"===e.contentType)return;return Number(e.value);case"meridiem":{const n=t.parse(`01:00 ${e.value}`,`${t.formats.hours12h}:${t.formats.minutes} ${e.format}`);return n?t.getHours(n)>=12?1:0:void 0}case"day":return"digit-with-letter"===e.contentType?parseInt(e.value,10):Number(e.value);case"month":{if("digit"===e.contentType)return Number(e.value);const n=t.parse(e.value,e.format);return n?t.getMonth(n)+1:void 0}default:return"letter"!==e.contentType?Number(e.value):void 0}},bx=["value","referenceDate"],vx={emptyValue:null,getTodayValue:Vv,getInitialReferenceValue:e=>{let{value:t,referenceDate:n}=e,r=$s(e,bx);return null!=t&&r.utils.isValid(t)?t:null!=n?n:Qv(r)},cleanValue:(e,t)=>null!=t&&e.isValid(t)?t:null,areValuesEqual:(e,t,n)=>!e.isValid(t)&&null!=t&&!e.isValid(n)&&null!=n||e.isEqual(t,n),isSameError:(e,t)=>e===t,hasError:e=>null!=e,defaultErrorState:null,getTimezone:(e,t)=>null!=t&&e.isValid(t)?e.getTimezone(t):null,setTimezone:(e,t,n)=>null==n?null:e.setTimezone(n,t)},xx={updateReferenceValue:(e,t,n)=>null!=t&&e.isValid(t)?t:n,getSectionsFromValue:(e,t,n,r)=>!e.isValid(t)&&!!n?n:r(t),getV7HiddenInputValueFromSections:e=>e.map((e=>`${e.startSeparator}${e.value||e.placeholder}${e.endSeparator}`)).join(""),getV6InputValueFromSections:(e,t,n)=>{const r=e.map((e=>{const r=lx(e,n?"input-rtl":"input-ltr",t);return`${e.startSeparator}${r}${e.endSeparator}`})).join("");return n?`\u2066${r}\u2069`:r},getActiveDateManager:(e,t)=>({date:t.value,referenceDate:t.referenceValue,getSections:e=>e,getNewValuesFromNewActiveDate:n=>({value:n,referenceValue:null!=n&&e.isValid(n)?n:t.referenceValue})}),parseValueStr:(e,t,n)=>n(e.trim(),t)},wx={previousMonth:"Previous month",nextMonth:"Next month",openPreviousView:"Open previous view",openNextView:"Open next view",calendarViewSwitchingButtonAriaLabel:e=>"year"===e?"year view is open, switch to calendar view":"calendar view is open, switch to year view",start:"Start",end:"End",startDate:"Start date",startTime:"Start time",endDate:"End date",endTime:"End time",cancelButtonLabel:"Cancel",clearButtonLabel:"Clear",okButtonLabel:"OK",todayButtonLabel:"Today",datePickerToolbarTitle:"Select date",dateTimePickerToolbarTitle:"Select date & time",timePickerToolbarTitle:"Select time",dateRangePickerToolbarTitle:"Select date range",clockLabelText:(e,t,n)=>`Select ${e}. ${null===t?"No time selected":`Selected time is ${n.format(t,"fullTime")}`}`,hoursClockNumberText:e=>`${e} hours`,minutesClockNumberText:e=>`${e} minutes`,secondsClockNumberText:e=>`${e} seconds`,selectViewText:e=>`Select ${e}`,calendarWeekNumberHeaderLabel:"Week number",calendarWeekNumberHeaderText:"#",calendarWeekNumberAriaLabelText:e=>`Week ${e}`,calendarWeekNumberText:e=>`${e}`,openDatePickerDialogue:(e,t)=>null!==e&&t.isValid(e)?`Choose date, selected date is ${t.format(e,"fullDate")}`:"Choose date",openTimePickerDialogue:(e,t)=>null!==e&&t.isValid(e)?`Choose time, selected time is ${t.format(e,"fullTime")}`:"Choose time",fieldClearLabel:"Clear value",timeTableLabel:"pick time",dateTableLabel:"pick date",fieldYearPlaceholder:e=>"Y".repeat(e.digitAmount),fieldMonthPlaceholder:e=>"letter"===e.contentType?"MMMM":"MM",fieldDayPlaceholder:()=>"DD",fieldWeekDayPlaceholder:e=>"letter"===e.contentType?"EEEE":"EE",fieldHoursPlaceholder:()=>"hh",fieldMinutesPlaceholder:()=>"mm",fieldSecondsPlaceholder:()=>"ss",fieldMeridiemPlaceholder:()=>"aa",year:"Year",month:"Month",day:"Day",weekDay:"Week day",hours:"Hours",minutes:"Minutes",seconds:"Seconds",meridiem:"Meridiem",empty:"Empty"},kx=wx;Sx=wx,(0,_o.A)({},Sx);var Sx;const Ix=()=>{const e=T.useContext(Tv);if(null===e)throw new Error(["MUI X: Can not find the date and time pickers localization context.","It looks like you forgot to wrap your component in LocalizationProvider.","This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join("\n"));if(null===e.utils)throw new Error(["MUI X: Can not find the date and time pickers adapter from its localization context.","It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join("\n"));const t=T.useMemo((()=>(0,_o.A)({},kx,e.localeText)),[e.localeText]);return T.useMemo((()=>(0,_o.A)({},e,{localeText:t})),[e,t])},Cx=()=>Ix().utils,Nx=()=>Ix().defaultDates,Tx=e=>{const t=Cx(),n=T.useRef();return void 0===n.current&&(n.current=t.date(void 0,e)),n.current};function Ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;const r={};return Object.keys(e).forEach((a=>{r[a]=e[a].reduce(((e,r)=>{if(r){const a=t(r);""!==a&&e.push(a),n&&n[r]&&e.push(n[r])}return e}),[]).join(" ")})),r}const Ax=e=>e,_x=(()=>{let e=Ax;return{configure(t){e=t},generate:t=>e(t),reset(){e=Ax}}})(),$x=_x,Rx={active:"active",checked:"checked",completed:"completed",disabled:"disabled",error:"error",expanded:"expanded",focused:"focused",focusVisible:"focusVisible",open:"open",readOnly:"readOnly",required:"required",selected:"selected"};function Dx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const r=Rx[t];return r?`${n}-${r}`:`${$x.generate(e)}-${t}`}function Mx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const r={};return t.forEach((t=>{r[t]=Dx(e,t,n)})),r}function Fx(e){return Dx("MuiPickersToolbar",e)}Mx("MuiPickersToolbar",["root","content"]);const Ox=["children","className","toolbarTitle","hidden","titleId","isLandscape","classes","landscapeDirection"],Px=(0,cr.Ay)("div",{name:"MuiPickersToolbar",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;return{display:"flex",flexDirection:"column",alignItems:"flex-start",justifyContent:"space-between",padding:t.spacing(2,3),variants:[{props:{isLandscape:!0},style:{height:"auto",maxWidth:160,padding:16,justifyContent:"flex-start",flexWrap:"wrap"}}]}})),Lx=(0,cr.Ay)("div",{name:"MuiPickersToolbar",slot:"Content",overridesResolver:(e,t)=>t.content})({display:"flex",flexWrap:"wrap",width:"100%",flex:1,justifyContent:"space-between",alignItems:"center",flexDirection:"row",variants:[{props:{isLandscape:!0},style:{justifyContent:"flex-start",alignItems:"flex-start",flexDirection:"column"}},{props:{isLandscape:!0,landscapeDirection:"row"},style:{flexDirection:"row"}}]}),zx=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiPickersToolbar"}),{children:r,className:a,toolbarTitle:s,hidden:i,titleId:o}=n,l=$s(n,Ox),u=n,c=(e=>{const{classes:t,isLandscape:n}=e;return Ex({root:["root"],content:["content"],penIconButton:["penIconButton",n&&"penIconButtonLandscape"]},Fx,t)})(u);return i?null:(0,Zn.jsxs)(Px,(0,_o.A)({ref:t,className:(0,Wn.A)(c.root,a),ownerState:u},l,{children:[(0,Zn.jsx)(Pr,{color:"text.secondary",variant:"overline",id:o,children:s}),(0,Zn.jsx)(Lx,{className:c.content,ownerState:u,children:r})]}))})),Bx=()=>Ix().localeText;function Wx(e){return Dx("MuiDatePickerToolbar",e)}Mx("MuiDatePickerToolbar",["root","title"]);const Vx=["value","isLandscape","onChange","toolbarFormat","toolbarPlaceholder","views","className","onViewChange","view"],Ux=(0,cr.Ay)(zx,{name:"MuiDatePickerToolbar",slot:"Root",overridesResolver:(e,t)=>t.root})({}),jx=(0,cr.Ay)(Pr,{name:"MuiDatePickerToolbar",slot:"Title",overridesResolver:(e,t)=>t.title})({variants:[{props:{isLandscape:!0},style:{margin:"auto 16px auto auto"}}]}),Gx=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiDatePickerToolbar"}),{value:r,isLandscape:a,toolbarFormat:s,toolbarPlaceholder:i="\u2013\u2013",views:o,className:l}=n,u=$s(n,Vx),c=Cx(),d=Bx(),h=(e=>{const{classes:t}=e;return Ex({root:["root"],title:["title"]},Wx,t)})(n),p=T.useMemo((()=>{if(!r)return i;const e=Gv(c,{format:s,views:o},!0);return c.formatByString(r,e)}),[r,s,i,c,o]),f=n;return(0,Zn.jsx)(Ux,(0,_o.A)({ref:t,toolbarTitle:d.datePickerToolbarTitle,isLandscape:a,className:(0,Wn.A)(h.root,l)},u,{children:(0,Zn.jsx)(jx,{variant:"h4",align:a?"left":"center",ownerState:f,className:h.title,children:p})}))}));function Hx(e,t){const n=Cx(),r=Nx(),a=mo({props:e,name:t}),s=T.useMemo((()=>null==a.localeText?.toolbarTitle?a.localeText:(0,_o.A)({},a.localeText,{datePickerToolbarTitle:a.localeText.toolbarTitle})),[a.localeText]);return(0,_o.A)({},a,{localeText:s},(e=>{let{openTo:t,defaultOpenTo:n,views:r,defaultViews:a}=e;const s=r??a;let i;if(null!=t)i=t;else if(s.includes(n))i=n;else{if(!(s.length>0))throw new Error("MUI X: The `views` prop must contain at least one view.");i=s[0]}return{views:s,openTo:i}})({views:a.views,openTo:a.openTo,defaultViews:["year","day"],defaultOpenTo:"day"}),{disableFuture:a.disableFuture??!1,disablePast:a.disablePast??!1,minDate:Bv(n,a.minDate,r.minDate),maxDate:Bv(n,a.maxDate,r.maxDate),slots:(0,_o.A)({toolbar:Gx},a.slots)})}const qx=e=>{let{props:t,value:n,adapter:r}=e;if(null===n)return null;const{shouldDisableDate:a,shouldDisableMonth:s,shouldDisableYear:i,disablePast:o,disableFuture:l,timezone:u}=t,c=r.utils.date(void 0,u),d=Bv(r.utils,t.minDate,r.defaultDates.minDate),h=Bv(r.utils,t.maxDate,r.defaultDates.maxDate);switch(!0){case!r.utils.isValid(n):return"invalidDate";case Boolean(a&&a(n)):return"shouldDisableDate";case Boolean(s&&s(n)):return"shouldDisableMonth";case Boolean(i&&i(n)):return"shouldDisableYear";case Boolean(l&&r.utils.isAfterDay(n,c)):return"disableFuture";case Boolean(o&&r.utils.isBeforeDay(n,c)):return"disablePast";case Boolean(d&&r.utils.isBeforeDay(n,d)):return"minDate";case Boolean(h&&r.utils.isAfterDay(n,h)):return"maxDate";default:return null}};function Kx(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return T.useMemo((()=>t.every((e=>null==e))?null:e=>{t.forEach((t=>{!function(e,t){"function"===typeof e?e(t):e&&(e.current=t)}(t,e)}))}),t)}const Xx=function(e){return"string"===typeof e};const Yx=function(e,t,n){return void 0===e||Xx(e)?t:(0,_o.A)({},t,{ownerState:(0,_o.A)({},t.ownerState,n)})};const Qx=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];if(void 0===e)return{};const n={};return Object.keys(e).filter((n=>n.match(/^on[A-Z]/)&&"function"===typeof e[n]&&!t.includes(n))).forEach((t=>{n[t]=e[t]})),n};const Jx=function(e){if(void 0===e)return{};const t={};return Object.keys(e).filter((t=>!(t.match(/^on[A-Z]/)&&"function"===typeof e[t]))).forEach((n=>{t[n]=e[n]})),t};const Zx=function(e){const{getSlotProps:t,additionalProps:n,externalSlotProps:r,externalForwardedProps:a,className:s}=e;if(!t){const e=(0,Wn.A)(null==n?void 0:n.className,s,null==a?void 0:a.className,null==r?void 0:r.className),t=(0,_o.A)({},null==n?void 0:n.style,null==a?void 0:a.style,null==r?void 0:r.style),i=(0,_o.A)({},n,a,r);return e.length>0&&(i.className=e),Object.keys(t).length>0&&(i.style=t),{props:i,internalRef:void 0}}const i=Qx((0,_o.A)({},a,r)),o=Jx(r),l=Jx(a),u=t(i),c=(0,Wn.A)(null==u?void 0:u.className,null==n?void 0:n.className,s,null==a?void 0:a.className,null==r?void 0:r.className),d=(0,_o.A)({},null==u?void 0:u.style,null==n?void 0:n.style,null==a?void 0:a.style,null==r?void 0:r.style),h=(0,_o.A)({},u,n,l,o);return c.length>0&&(h.className=c),Object.keys(d).length>0&&(h.style=d),{props:h,internalRef:u.ref}},ew=["elementType","externalSlotProps","ownerState","skipResolvingSlotProps"];const tw=function(e){var t;const{elementType:n,externalSlotProps:r,ownerState:a,skipResolvingSlotProps:s=!1}=e,i=$s(e,ew),o=s?{}:Fv(r,a),{props:l,internalRef:u}=Zx((0,_o.A)({},i,{externalSlotProps:o})),c=Kx(u,null==o?void 0:o.ref,null==(t=e.additionalProps)?void 0:t.ref);return Yx(n,(0,_o.A)({},l,{ref:c}),a)};function nw(e){return(0,gr.Ay)("MuiInputAdornment",e)}const rw=(0,rr.A)("MuiInputAdornment",["root","filled","standard","outlined","positionStart","positionEnd","disablePointerEvents","hiddenLabel","sizeSmall"]);var aw;const sw=(0,cr.Ay)("div",{name:"MuiInputAdornment",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`position${(0,_r.A)(n.position)}`],!0===n.disablePointerEvents&&t.disablePointerEvents,t[n.variant]]}})((0,pr.A)((e=>{let{theme:t}=e;return{display:"flex",maxHeight:"2em",alignItems:"center",whiteSpace:"nowrap",color:(t.vars||t).palette.action.active,variants:[{props:{variant:"filled"},style:{[`&.${rw.positionStart}&:not(.${rw.hiddenLabel})`]:{marginTop:16}}},{props:{position:"start"},style:{marginRight:8}},{props:{position:"end"},style:{marginLeft:8}},{props:{disablePointerEvents:!0},style:{pointerEvents:"none"}}]}}))),iw=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiInputAdornment"}),{children:r,className:a,component:s="div",disablePointerEvents:i=!1,disableTypography:o=!1,position:l,variant:u,...c}=n,d=Qr()||{};let h=u;u&&d.variant,d&&!h&&(h=d.variant);const p={...n,hiddenLabel:d.hiddenLabel,size:d.size,disablePointerEvents:i,position:l,variant:h},f=(e=>{const{classes:t,disablePointerEvents:n,hiddenLabel:r,position:a,size:s,variant:i}=e,o={root:["root",n&&"disablePointerEvents",a&&`position${(0,_r.A)(a)}`,i,r&&"hiddenLabel",s&&`size${(0,_r.A)(s)}`]};return(0,lr.A)(o,nw,t)})(p);return(0,Zn.jsx)(Yr.Provider,{value:null,children:(0,Zn.jsx)(sw,{as:s,ownerState:p,className:(0,Wn.A)(f.root,a),ref:t,...c,children:"string"!==typeof r||o?(0,Zn.jsxs)(T.Fragment,{children:["start"===l?aw||(aw=(0,Zn.jsx)("span",{className:"notranslate",children:"\u200b"})):null,r]}):(0,Zn.jsx)(Pr,{color:"textSecondary",children:r})})})})),ow=iw;let lw=0;const uw=E["useId".toString()];function cw(e){if(void 0!==uw){const t=uw();return null!=e?e:t}return function(e){const[t,n]=T.useState(e),r=e||t;return T.useEffect((()=>{null==t&&(lw+=1,n(`mui-${lw}`))}),[t]),r}(e)}function dw(e){if(null==e)return window;if("[object Window]"!==e.toString()){var t=e.ownerDocument;return t&&t.defaultView||window}return e}function hw(e){return e instanceof dw(e).Element||e instanceof Element}function pw(e){return e instanceof dw(e).HTMLElement||e instanceof HTMLElement}function fw(e){return"undefined"!==typeof ShadowRoot&&(e instanceof dw(e).ShadowRoot||e instanceof ShadowRoot)}var mw=Math.max,gw=Math.min,yw=Math.round;function bw(){var e=navigator.userAgentData;return null!=e&&e.brands&&Array.isArray(e.brands)?e.brands.map((function(e){return e.brand+"/"+e.version})).join(" "):navigator.userAgent}function vw(){return!/^((?!chrome|android).)*safari/i.test(bw())}function xw(e,t,n){void 0===t&&(t=!1),void 0===n&&(n=!1);var r=e.getBoundingClientRect(),a=1,s=1;t&&pw(e)&&(a=e.offsetWidth>0&&yw(r.width)/e.offsetWidth||1,s=e.offsetHeight>0&&yw(r.height)/e.offsetHeight||1);var i=(hw(e)?dw(e):window).visualViewport,o=!vw()&&n,l=(r.left+(o&&i?i.offsetLeft:0))/a,u=(r.top+(o&&i?i.offsetTop:0))/s,c=r.width/a,d=r.height/s;return{width:c,height:d,top:u,right:l+c,bottom:u+d,left:l,x:l,y:u}}function ww(e){var t=dw(e);return{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function kw(e){return e?(e.nodeName||"").toLowerCase():null}function Sw(e){return((hw(e)?e.ownerDocument:e.document)||window.document).documentElement}function Iw(e){return xw(Sw(e)).left+ww(e).scrollLeft}function Cw(e){return dw(e).getComputedStyle(e)}function Nw(e){var t=Cw(e),n=t.overflow,r=t.overflowX,a=t.overflowY;return/auto|scroll|overlay|hidden/.test(n+a+r)}function Tw(e,t,n){void 0===n&&(n=!1);var r=pw(t),a=pw(t)&&function(e){var t=e.getBoundingClientRect(),n=yw(t.width)/e.offsetWidth||1,r=yw(t.height)/e.offsetHeight||1;return 1!==n||1!==r}(t),s=Sw(t),i=xw(e,a,n),o={scrollLeft:0,scrollTop:0},l={x:0,y:0};return(r||!r&&!n)&&(("body"!==kw(t)||Nw(s))&&(o=function(e){return e!==dw(e)&&pw(e)?{scrollLeft:(t=e).scrollLeft,scrollTop:t.scrollTop}:ww(e);var t}(t)),pw(t)?((l=xw(t,!0)).x+=t.clientLeft,l.y+=t.clientTop):s&&(l.x=Iw(s))),{x:i.left+o.scrollLeft-l.x,y:i.top+o.scrollTop-l.y,width:i.width,height:i.height}}function Ew(e){var t=xw(e),n=e.offsetWidth,r=e.offsetHeight;return Math.abs(t.width-n)<=1&&(n=t.width),Math.abs(t.height-r)<=1&&(r=t.height),{x:e.offsetLeft,y:e.offsetTop,width:n,height:r}}function Aw(e){return"html"===kw(e)?e:e.assignedSlot||e.parentNode||(fw(e)?e.host:null)||Sw(e)}function _w(e){return["html","body","#document"].indexOf(kw(e))>=0?e.ownerDocument.body:pw(e)&&Nw(e)?e:_w(Aw(e))}function $w(e,t){var n;void 0===t&&(t=[]);var r=_w(e),a=r===(null==(n=e.ownerDocument)?void 0:n.body),s=dw(r),i=a?[s].concat(s.visualViewport||[],Nw(r)?r:[]):r,o=t.concat(i);return a?o:o.concat($w(Aw(i)))}function Rw(e){return["table","td","th"].indexOf(kw(e))>=0}function Dw(e){return pw(e)&&"fixed"!==Cw(e).position?e.offsetParent:null}function Mw(e){for(var t=dw(e),n=Dw(e);n&&Rw(n)&&"static"===Cw(n).position;)n=Dw(n);return n&&("html"===kw(n)||"body"===kw(n)&&"static"===Cw(n).position)?t:n||function(e){var t=/firefox/i.test(bw());if(/Trident/i.test(bw())&&pw(e)&&"fixed"===Cw(e).position)return null;var n=Aw(e);for(fw(n)&&(n=n.host);pw(n)&&["html","body"].indexOf(kw(n))<0;){var r=Cw(n);if("none"!==r.transform||"none"!==r.perspective||"paint"===r.contain||-1!==["transform","perspective"].indexOf(r.willChange)||t&&"filter"===r.willChange||t&&r.filter&&"none"!==r.filter)return n;n=n.parentNode}return null}(e)||t}var Fw="top",Ow="bottom",Pw="right",Lw="left",zw="auto",Bw=[Fw,Ow,Pw,Lw],Ww="start",Vw="end",Uw="clippingParents",jw="viewport",Gw="popper",Hw="reference",qw=Bw.reduce((function(e,t){return e.concat([t+"-"+Ww,t+"-"+Vw])}),[]),Kw=[].concat(Bw,[zw]).reduce((function(e,t){return e.concat([t,t+"-"+Ww,t+"-"+Vw])}),[]),Xw=["beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite"];function Yw(e){var t=new Map,n=new Set,r=[];function a(e){n.add(e.name),[].concat(e.requires||[],e.requiresIfExists||[]).forEach((function(e){if(!n.has(e)){var r=t.get(e);r&&a(r)}})),r.push(e)}return e.forEach((function(e){t.set(e.name,e)})),e.forEach((function(e){n.has(e.name)||a(e)})),r}function Qw(e){var t;return function(){return t||(t=new Promise((function(n){Promise.resolve().then((function(){t=void 0,n(e())}))}))),t}}var Jw={placement:"bottom",modifiers:[],strategy:"absolute"};function Zw(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return!t.some((function(e){return!(e&&"function"===typeof e.getBoundingClientRect)}))}function ek(e){void 0===e&&(e={});var t=e,n=t.defaultModifiers,r=void 0===n?[]:n,a=t.defaultOptions,s=void 0===a?Jw:a;return function(e,t,n){void 0===n&&(n=s);var a={placement:"bottom",orderedModifiers:[],options:Object.assign({},Jw,s),modifiersData:{},elements:{reference:e,popper:t},attributes:{},styles:{}},i=[],o=!1,l={state:a,setOptions:function(n){var o="function"===typeof n?n(a.options):n;u(),a.options=Object.assign({},s,a.options,o),a.scrollParents={reference:hw(e)?$w(e):e.contextElement?$w(e.contextElement):[],popper:$w(t)};var c=function(e){var t=Yw(e);return Xw.reduce((function(e,n){return e.concat(t.filter((function(e){return e.phase===n})))}),[])}(function(e){var t=e.reduce((function(e,t){var n=e[t.name];return e[t.name]=n?Object.assign({},n,t,{options:Object.assign({},n.options,t.options),data:Object.assign({},n.data,t.data)}):t,e}),{});return Object.keys(t).map((function(e){return t[e]}))}([].concat(r,a.options.modifiers)));return a.orderedModifiers=c.filter((function(e){return e.enabled})),a.orderedModifiers.forEach((function(e){var t=e.name,n=e.options,r=void 0===n?{}:n,s=e.effect;if("function"===typeof s){var o=s({state:a,name:t,instance:l,options:r}),u=function(){};i.push(o||u)}})),l.update()},forceUpdate:function(){if(!o){var e=a.elements,t=e.reference,n=e.popper;if(Zw(t,n)){a.rects={reference:Tw(t,Mw(n),"fixed"===a.options.strategy),popper:Ew(n)},a.reset=!1,a.placement=a.options.placement,a.orderedModifiers.forEach((function(e){return a.modifiersData[e.name]=Object.assign({},e.data)}));for(var r=0;r<a.orderedModifiers.length;r++)if(!0!==a.reset){var s=a.orderedModifiers[r],i=s.fn,u=s.options,c=void 0===u?{}:u,d=s.name;"function"===typeof i&&(a=i({state:a,options:c,name:d,instance:l})||a)}else a.reset=!1,r=-1}}},update:Qw((function(){return new Promise((function(e){l.forceUpdate(),e(a)}))})),destroy:function(){u(),o=!0}};if(!Zw(e,t))return l;function u(){i.forEach((function(e){return e()})),i=[]}return l.setOptions(n).then((function(e){!o&&n.onFirstUpdate&&n.onFirstUpdate(e)})),l}}var tk={passive:!0};function nk(e){return e.split("-")[0]}function rk(e){return e.split("-")[1]}function ak(e){return["top","bottom"].indexOf(e)>=0?"x":"y"}function sk(e){var t,n=e.reference,r=e.element,a=e.placement,s=a?nk(a):null,i=a?rk(a):null,o=n.x+n.width/2-r.width/2,l=n.y+n.height/2-r.height/2;switch(s){case Fw:t={x:o,y:n.y-r.height};break;case Ow:t={x:o,y:n.y+n.height};break;case Pw:t={x:n.x+n.width,y:l};break;case Lw:t={x:n.x-r.width,y:l};break;default:t={x:n.x,y:n.y}}var u=s?ak(s):null;if(null!=u){var c="y"===u?"height":"width";switch(i){case Ww:t[u]=t[u]-(n[c]/2-r[c]/2);break;case Vw:t[u]=t[u]+(n[c]/2-r[c]/2)}}return t}var ik={top:"auto",right:"auto",bottom:"auto",left:"auto"};function ok(e){var t,n=e.popper,r=e.popperRect,a=e.placement,s=e.variation,i=e.offsets,o=e.position,l=e.gpuAcceleration,u=e.adaptive,c=e.roundOffsets,d=e.isFixed,h=i.x,p=void 0===h?0:h,f=i.y,m=void 0===f?0:f,g="function"===typeof c?c({x:p,y:m}):{x:p,y:m};p=g.x,m=g.y;var y=i.hasOwnProperty("x"),b=i.hasOwnProperty("y"),v=Lw,x=Fw,w=window;if(u){var k=Mw(n),S="clientHeight",I="clientWidth";if(k===dw(n)&&"static"!==Cw(k=Sw(n)).position&&"absolute"===o&&(S="scrollHeight",I="scrollWidth"),a===Fw||(a===Lw||a===Pw)&&s===Vw)x=Ow,m-=(d&&k===w&&w.visualViewport?w.visualViewport.height:k[S])-r.height,m*=l?1:-1;if(a===Lw||(a===Fw||a===Ow)&&s===Vw)v=Pw,p-=(d&&k===w&&w.visualViewport?w.visualViewport.width:k[I])-r.width,p*=l?1:-1}var C,N=Object.assign({position:o},u&&ik),T=!0===c?function(e,t){var n=e.x,r=e.y,a=t.devicePixelRatio||1;return{x:yw(n*a)/a||0,y:yw(r*a)/a||0}}({x:p,y:m},dw(n)):{x:p,y:m};return p=T.x,m=T.y,l?Object.assign({},N,((C={})[x]=b?"0":"",C[v]=y?"0":"",C.transform=(w.devicePixelRatio||1)<=1?"translate("+p+"px, "+m+"px)":"translate3d("+p+"px, "+m+"px, 0)",C)):Object.assign({},N,((t={})[x]=b?m+"px":"",t[v]=y?p+"px":"",t.transform="",t))}const lk={name:"applyStyles",enabled:!0,phase:"write",fn:function(e){var t=e.state;Object.keys(t.elements).forEach((function(e){var n=t.styles[e]||{},r=t.attributes[e]||{},a=t.elements[e];pw(a)&&kw(a)&&(Object.assign(a.style,n),Object.keys(r).forEach((function(e){var t=r[e];!1===t?a.removeAttribute(e):a.setAttribute(e,!0===t?"":t)})))}))},effect:function(e){var t=e.state,n={popper:{position:t.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(t.elements.popper.style,n.popper),t.styles=n,t.elements.arrow&&Object.assign(t.elements.arrow.style,n.arrow),function(){Object.keys(t.elements).forEach((function(e){var r=t.elements[e],a=t.attributes[e]||{},s=Object.keys(t.styles.hasOwnProperty(e)?t.styles[e]:n[e]).reduce((function(e,t){return e[t]="",e}),{});pw(r)&&kw(r)&&(Object.assign(r.style,s),Object.keys(a).forEach((function(e){r.removeAttribute(e)})))}))}},requires:["computeStyles"]};const uk={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(e){var t=e.state,n=e.options,r=e.name,a=n.offset,s=void 0===a?[0,0]:a,i=Kw.reduce((function(e,n){return e[n]=function(e,t,n){var r=nk(e),a=[Lw,Fw].indexOf(r)>=0?-1:1,s="function"===typeof n?n(Object.assign({},t,{placement:e})):n,i=s[0],o=s[1];return i=i||0,o=(o||0)*a,[Lw,Pw].indexOf(r)>=0?{x:o,y:i}:{x:i,y:o}}(n,t.rects,s),e}),{}),o=i[t.placement],l=o.x,u=o.y;null!=t.modifiersData.popperOffsets&&(t.modifiersData.popperOffsets.x+=l,t.modifiersData.popperOffsets.y+=u),t.modifiersData[r]=i}};var ck={left:"right",right:"left",bottom:"top",top:"bottom"};function dk(e){return e.replace(/left|right|bottom|top/g,(function(e){return ck[e]}))}var hk={start:"end",end:"start"};function pk(e){return e.replace(/start|end/g,(function(e){return hk[e]}))}function fk(e,t){var n=t.getRootNode&&t.getRootNode();if(e.contains(t))return!0;if(n&&fw(n)){var r=t;do{if(r&&e.isSameNode(r))return!0;r=r.parentNode||r.host}while(r)}return!1}function mk(e){return Object.assign({},e,{left:e.x,top:e.y,right:e.x+e.width,bottom:e.y+e.height})}function gk(e,t,n){return t===jw?mk(function(e,t){var n=dw(e),r=Sw(e),a=n.visualViewport,s=r.clientWidth,i=r.clientHeight,o=0,l=0;if(a){s=a.width,i=a.height;var u=vw();(u||!u&&"fixed"===t)&&(o=a.offsetLeft,l=a.offsetTop)}return{width:s,height:i,x:o+Iw(e),y:l}}(e,n)):hw(t)?function(e,t){var n=xw(e,!1,"fixed"===t);return n.top=n.top+e.clientTop,n.left=n.left+e.clientLeft,n.bottom=n.top+e.clientHeight,n.right=n.left+e.clientWidth,n.width=e.clientWidth,n.height=e.clientHeight,n.x=n.left,n.y=n.top,n}(t,n):mk(function(e){var t,n=Sw(e),r=ww(e),a=null==(t=e.ownerDocument)?void 0:t.body,s=mw(n.scrollWidth,n.clientWidth,a?a.scrollWidth:0,a?a.clientWidth:0),i=mw(n.scrollHeight,n.clientHeight,a?a.scrollHeight:0,a?a.clientHeight:0),o=-r.scrollLeft+Iw(e),l=-r.scrollTop;return"rtl"===Cw(a||n).direction&&(o+=mw(n.clientWidth,a?a.clientWidth:0)-s),{width:s,height:i,x:o,y:l}}(Sw(e)))}function yk(e,t,n,r){var a="clippingParents"===t?function(e){var t=$w(Aw(e)),n=["absolute","fixed"].indexOf(Cw(e).position)>=0&&pw(e)?Mw(e):e;return hw(n)?t.filter((function(e){return hw(e)&&fk(e,n)&&"body"!==kw(e)})):[]}(e):[].concat(t),s=[].concat(a,[n]),i=s[0],o=s.reduce((function(t,n){var a=gk(e,n,r);return t.top=mw(a.top,t.top),t.right=gw(a.right,t.right),t.bottom=gw(a.bottom,t.bottom),t.left=mw(a.left,t.left),t}),gk(e,i,r));return o.width=o.right-o.left,o.height=o.bottom-o.top,o.x=o.left,o.y=o.top,o}function bk(e){return Object.assign({},{top:0,right:0,bottom:0,left:0},e)}function vk(e,t){return t.reduce((function(t,n){return t[n]=e,t}),{})}function xk(e,t){void 0===t&&(t={});var n=t,r=n.placement,a=void 0===r?e.placement:r,s=n.strategy,i=void 0===s?e.strategy:s,o=n.boundary,l=void 0===o?Uw:o,u=n.rootBoundary,c=void 0===u?jw:u,d=n.elementContext,h=void 0===d?Gw:d,p=n.altBoundary,f=void 0!==p&&p,m=n.padding,g=void 0===m?0:m,y=bk("number"!==typeof g?g:vk(g,Bw)),b=h===Gw?Hw:Gw,v=e.rects.popper,x=e.elements[f?b:h],w=yk(hw(x)?x:x.contextElement||Sw(e.elements.popper),l,c,i),k=xw(e.elements.reference),S=sk({reference:k,element:v,strategy:"absolute",placement:a}),I=mk(Object.assign({},v,S)),C=h===Gw?I:k,N={top:w.top-C.top+y.top,bottom:C.bottom-w.bottom+y.bottom,left:w.left-C.left+y.left,right:C.right-w.right+y.right},T=e.modifiersData.offset;if(h===Gw&&T){var E=T[a];Object.keys(N).forEach((function(e){var t=[Pw,Ow].indexOf(e)>=0?1:-1,n=[Fw,Ow].indexOf(e)>=0?"y":"x";N[e]+=E[n]*t}))}return N}const wk={name:"flip",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name;if(!t.modifiersData[r]._skip){for(var a=n.mainAxis,s=void 0===a||a,i=n.altAxis,o=void 0===i||i,l=n.fallbackPlacements,u=n.padding,c=n.boundary,d=n.rootBoundary,h=n.altBoundary,p=n.flipVariations,f=void 0===p||p,m=n.allowedAutoPlacements,g=t.options.placement,y=nk(g),b=l||(y===g||!f?[dk(g)]:function(e){if(nk(e)===zw)return[];var t=dk(e);return[pk(e),t,pk(t)]}(g)),v=[g].concat(b).reduce((function(e,n){return e.concat(nk(n)===zw?function(e,t){void 0===t&&(t={});var n=t,r=n.placement,a=n.boundary,s=n.rootBoundary,i=n.padding,o=n.flipVariations,l=n.allowedAutoPlacements,u=void 0===l?Kw:l,c=rk(r),d=c?o?qw:qw.filter((function(e){return rk(e)===c})):Bw,h=d.filter((function(e){return u.indexOf(e)>=0}));0===h.length&&(h=d);var p=h.reduce((function(t,n){return t[n]=xk(e,{placement:n,boundary:a,rootBoundary:s,padding:i})[nk(n)],t}),{});return Object.keys(p).sort((function(e,t){return p[e]-p[t]}))}(t,{placement:n,boundary:c,rootBoundary:d,padding:u,flipVariations:f,allowedAutoPlacements:m}):n)}),[]),x=t.rects.reference,w=t.rects.popper,k=new Map,S=!0,I=v[0],C=0;C<v.length;C++){var N=v[C],T=nk(N),E=rk(N)===Ww,A=[Fw,Ow].indexOf(T)>=0,_=A?"width":"height",$=xk(t,{placement:N,boundary:c,rootBoundary:d,altBoundary:h,padding:u}),R=A?E?Pw:Lw:E?Ow:Fw;x[_]>w[_]&&(R=dk(R));var D=dk(R),M=[];if(s&&M.push($[T]<=0),o&&M.push($[R]<=0,$[D]<=0),M.every((function(e){return e}))){I=N,S=!1;break}k.set(N,M)}if(S)for(var F=function(e){var t=v.find((function(t){var n=k.get(t);if(n)return n.slice(0,e).every((function(e){return e}))}));if(t)return I=t,"break"},O=f?3:1;O>0;O--){if("break"===F(O))break}t.placement!==I&&(t.modifiersData[r]._skip=!0,t.placement=I,t.reset=!0)}},requiresIfExists:["offset"],data:{_skip:!1}};function kk(e,t,n){return mw(e,gw(t,n))}const Sk={name:"preventOverflow",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name,a=n.mainAxis,s=void 0===a||a,i=n.altAxis,o=void 0!==i&&i,l=n.boundary,u=n.rootBoundary,c=n.altBoundary,d=n.padding,h=n.tether,p=void 0===h||h,f=n.tetherOffset,m=void 0===f?0:f,g=xk(t,{boundary:l,rootBoundary:u,padding:d,altBoundary:c}),y=nk(t.placement),b=rk(t.placement),v=!b,x=ak(y),w="x"===x?"y":"x",k=t.modifiersData.popperOffsets,S=t.rects.reference,I=t.rects.popper,C="function"===typeof m?m(Object.assign({},t.rects,{placement:t.placement})):m,N="number"===typeof C?{mainAxis:C,altAxis:C}:Object.assign({mainAxis:0,altAxis:0},C),T=t.modifiersData.offset?t.modifiersData.offset[t.placement]:null,E={x:0,y:0};if(k){if(s){var A,_="y"===x?Fw:Lw,$="y"===x?Ow:Pw,R="y"===x?"height":"width",D=k[x],M=D+g[_],F=D-g[$],O=p?-I[R]/2:0,P=b===Ww?S[R]:I[R],L=b===Ww?-I[R]:-S[R],z=t.elements.arrow,B=p&&z?Ew(z):{width:0,height:0},W=t.modifiersData["arrow#persistent"]?t.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},V=W[_],U=W[$],j=kk(0,S[R],B[R]),G=v?S[R]/2-O-j-V-N.mainAxis:P-j-V-N.mainAxis,H=v?-S[R]/2+O+j+U+N.mainAxis:L+j+U+N.mainAxis,q=t.elements.arrow&&Mw(t.elements.arrow),K=q?"y"===x?q.clientTop||0:q.clientLeft||0:0,X=null!=(A=null==T?void 0:T[x])?A:0,Y=D+H-X,Q=kk(p?gw(M,D+G-X-K):M,D,p?mw(F,Y):F);k[x]=Q,E[x]=Q-D}if(o){var J,Z="x"===x?Fw:Lw,ee="x"===x?Ow:Pw,te=k[w],ne="y"===w?"height":"width",re=te+g[Z],ae=te-g[ee],se=-1!==[Fw,Lw].indexOf(y),ie=null!=(J=null==T?void 0:T[w])?J:0,oe=se?re:te-S[ne]-I[ne]-ie+N.altAxis,le=se?te+S[ne]+I[ne]-ie-N.altAxis:ae,ue=p&&se?function(e,t,n){var r=kk(e,t,n);return r>n?n:r}(oe,te,le):kk(p?oe:re,te,p?le:ae);k[w]=ue,E[w]=ue-te}t.modifiersData[r]=E}},requiresIfExists:["offset"]};const Ik={name:"arrow",enabled:!0,phase:"main",fn:function(e){var t,n=e.state,r=e.name,a=e.options,s=n.elements.arrow,i=n.modifiersData.popperOffsets,o=nk(n.placement),l=ak(o),u=[Lw,Pw].indexOf(o)>=0?"height":"width";if(s&&i){var c=function(e,t){return bk("number"!==typeof(e="function"===typeof e?e(Object.assign({},t.rects,{placement:t.placement})):e)?e:vk(e,Bw))}(a.padding,n),d=Ew(s),h="y"===l?Fw:Lw,p="y"===l?Ow:Pw,f=n.rects.reference[u]+n.rects.reference[l]-i[l]-n.rects.popper[u],m=i[l]-n.rects.reference[l],g=Mw(s),y=g?"y"===l?g.clientHeight||0:g.clientWidth||0:0,b=f/2-m/2,v=c[h],x=y-d[u]-c[p],w=y/2-d[u]/2+b,k=kk(v,w,x),S=l;n.modifiersData[r]=((t={})[S]=k,t.centerOffset=k-w,t)}},effect:function(e){var t=e.state,n=e.options.element,r=void 0===n?"[data-popper-arrow]":n;null!=r&&("string"!==typeof r||(r=t.elements.popper.querySelector(r)))&&fk(t.elements.popper,r)&&(t.elements.arrow=r)},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function Ck(e,t,n){return void 0===n&&(n={x:0,y:0}),{top:e.top-t.height-n.y,right:e.right-t.width+n.x,bottom:e.bottom-t.height+n.y,left:e.left-t.width-n.x}}function Nk(e){return[Fw,Pw,Ow,Lw].some((function(t){return e[t]>=0}))}var Tk=ek({defaultModifiers:[{name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(e){var t=e.state,n=e.instance,r=e.options,a=r.scroll,s=void 0===a||a,i=r.resize,o=void 0===i||i,l=dw(t.elements.popper),u=[].concat(t.scrollParents.reference,t.scrollParents.popper);return s&&u.forEach((function(e){e.addEventListener("scroll",n.update,tk)})),o&&l.addEventListener("resize",n.update,tk),function(){s&&u.forEach((function(e){e.removeEventListener("scroll",n.update,tk)})),o&&l.removeEventListener("resize",n.update,tk)}},data:{}},{name:"popperOffsets",enabled:!0,phase:"read",fn:function(e){var t=e.state,n=e.name;t.modifiersData[n]=sk({reference:t.rects.reference,element:t.rects.popper,strategy:"absolute",placement:t.placement})},data:{}},{name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(e){var t=e.state,n=e.options,r=n.gpuAcceleration,a=void 0===r||r,s=n.adaptive,i=void 0===s||s,o=n.roundOffsets,l=void 0===o||o,u={placement:nk(t.placement),variation:rk(t.placement),popper:t.elements.popper,popperRect:t.rects.popper,gpuAcceleration:a,isFixed:"fixed"===t.options.strategy};null!=t.modifiersData.popperOffsets&&(t.styles.popper=Object.assign({},t.styles.popper,ok(Object.assign({},u,{offsets:t.modifiersData.popperOffsets,position:t.options.strategy,adaptive:i,roundOffsets:l})))),null!=t.modifiersData.arrow&&(t.styles.arrow=Object.assign({},t.styles.arrow,ok(Object.assign({},u,{offsets:t.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:l})))),t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-placement":t.placement})},data:{}},lk,uk,wk,Sk,Ik,{name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(e){var t=e.state,n=e.name,r=t.rects.reference,a=t.rects.popper,s=t.modifiersData.preventOverflow,i=xk(t,{elementContext:"reference"}),o=xk(t,{altBoundary:!0}),l=Ck(i,r),u=Ck(o,a,s),c=Nk(l),d=Nk(u);t.modifiersData[n]={referenceClippingOffsets:l,popperEscapeOffsets:u,isReferenceHidden:c,hasPopperEscaped:d},t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-reference-hidden":c,"data-popper-escaped":d})}}]});function Ek(e){return(0,gr.Ay)("MuiPopper",e)}(0,rr.A)("MuiPopper",["root"]);function Ak(e){return"function"===typeof e?e():e}function _k(e){return void 0!==e.nodeType}const $k={},Rk=T.forwardRef((function(e,t){const{anchorEl:n,children:r,direction:a,disablePortal:s,modifiers:i,open:o,placement:l,popperOptions:u,popperRef:c,slotProps:d={},slots:h={},TransitionProps:p,ownerState:f,...m}=e,g=T.useRef(null),y=(0,Br.A)(g,t),b=T.useRef(null),v=(0,Br.A)(b,c),x=T.useRef(v);(0,Vr.A)((()=>{x.current=v}),[v]),T.useImperativeHandle(c,(()=>b.current),[]);const w=function(e,t){if("ltr"===t)return e;switch(e){case"bottom-end":return"bottom-start";case"bottom-start":return"bottom-end";case"top-end":return"top-start";case"top-start":return"top-end";default:return e}}(l,a),[k,S]=T.useState(w),[I,C]=T.useState(Ak(n));T.useEffect((()=>{b.current&&b.current.forceUpdate()})),T.useEffect((()=>{n&&C(Ak(n))}),[n]),(0,Vr.A)((()=>{if(!I||!o)return;let e=[{name:"preventOverflow",options:{altBoundary:s}},{name:"flip",options:{altBoundary:s}},{name:"onUpdate",enabled:!0,phase:"afterWrite",fn:e=>{let{state:t}=e;(e=>{S(e.placement)})(t)}}];null!=i&&(e=e.concat(i)),u&&null!=u.modifiers&&(e=e.concat(u.modifiers));const t=Tk(I,g.current,{placement:w,...u,modifiers:e});return x.current(t),()=>{t.destroy(),x.current(null)}}),[I,s,i,o,u,w]);const N={placement:k};null!==p&&(N.TransitionProps=p);const E=(e=>{const{classes:t}=e;return(0,lr.A)({root:["root"]},Ek,t)})(e),A=h.root??"div",_=cs({elementType:A,externalSlotProps:d.root,externalForwardedProps:m,additionalProps:{role:"tooltip",ref:y},ownerState:e,className:E.root});return(0,Zn.jsx)(A,{..._,children:"function"===typeof r?r(N):r})})),Dk=T.forwardRef((function(e,t){const{anchorEl:n,children:r,container:a,direction:s="ltr",disablePortal:i=!1,keepMounted:o=!1,modifiers:l,open:u,placement:c="bottom",popperOptions:d=$k,popperRef:h,style:p,transition:f=!1,slotProps:m={},slots:g={},...y}=e,[b,v]=T.useState(!0);if(!o&&!u&&(!f||b))return null;let x;if(a)x=a;else if(n){const e=Ak(n);x=e&&_k(e)?(0,Js.A)(e).body:(0,Js.A)(null).body}const w=u||!o||f&&!b?void 0:"none",k=f?{in:u,onEnter:()=>{v(!1)},onExited:()=>{v(!0)}}:void 0;return(0,Zn.jsx)(ai,{disablePortal:i,container:x,children:(0,Zn.jsx)(Rk,{anchorEl:n,direction:s,disablePortal:i,modifiers:l,ref:t,open:f?!b:u,placement:c,popperOptions:d,popperRef:h,slotProps:m,slots:g,...y,style:{position:"fixed",top:0,left:0,display:w,...p},TransitionProps:k,children:r})})})),Mk=Dk,Fk=(0,cr.Ay)(Mk,{name:"MuiPopper",slot:"Root",overridesResolver:(e,t)=>t.root})({}),Ok=T.forwardRef((function(e,t){const n=rs(),r=(0,fr.b)({props:e,name:"MuiPopper"}),{anchorEl:a,component:s,components:i,componentsProps:o,container:l,disablePortal:u,keepMounted:c,modifiers:d,open:h,placement:p,popperOptions:f,popperRef:m,transition:g,slots:y,slotProps:b,...v}=r,x=y?.root??i?.Root,w={anchorEl:a,container:l,disablePortal:u,keepMounted:c,modifiers:d,open:h,placement:p,popperOptions:f,popperRef:m,transition:g,...v};return(0,Zn.jsx)(Fk,{as:s,direction:n?"rtl":"ltr",slots:{root:x},slotProps:b??o,...w,ref:t})})),Pk="undefined"!==typeof window?T.useLayoutEffect:T.useEffect;const Lk=function(e){const t=T.useRef(e);return Pk((()=>{t.current=e})),T.useRef((function(){return(0,t.current)(...arguments)})).current};function zk(e){return e&&e.ownerDocument||document}function Bk(e){return Dx("MuiPickersPopper",e)}Mx("MuiPickersPopper",["root","paper"]);const Wk=function(){const e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:document).activeElement;return e?e.shadowRoot?Wk(e.shadowRoot):e:null},Vk="@media (pointer: fine)",Uk="undefined"!==typeof navigator&&navigator.userAgent.match(/android\s(\d+)|OS\s(\d+)/i),jk=Uk&&Uk[1]?parseInt(Uk[1],10):null,Gk=Uk&&Uk[2]?parseInt(Uk[2],10):null,Hk=jk&&jk<10||Gk&&Gk<13||!1,qk=()=>Rv("@media (prefers-reduced-motion: reduce)",{defaultMatches:!1})||Hk,Kk=["PaperComponent","popperPlacement","ownerState","children","paperSlotProps","paperClasses","onPaperClick","onPaperTouchStart"],Xk=(0,cr.Ay)(Ok,{name:"MuiPickersPopper",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;return{zIndex:t.zIndex.modal}})),Yk=(0,cr.Ay)(xr,{name:"MuiPickersPopper",slot:"Paper",overridesResolver:(e,t)=>t.paper})({outline:0,transformOrigin:"top center",variants:[{props:e=>{let{placement:t}=e;return["top","top-start","top-end"].includes(t)},style:{transformOrigin:"bottom center"}}]});const Qk=T.forwardRef(((e,t)=>{const{PaperComponent:n,popperPlacement:r,ownerState:a,children:s,paperSlotProps:i,paperClasses:o,onPaperClick:l,onPaperTouchStart:u}=e,c=$s(e,Kk),d=(0,_o.A)({},a,{placement:r}),h=tw({elementType:n,externalSlotProps:i,additionalProps:{tabIndex:-1,elevation:8,ref:t},className:o,ownerState:d});return(0,Zn.jsx)(n,(0,_o.A)({},c,h,{onClick:e=>{l(e),h.onClick?.(e)},onTouchStart:e=>{u(e),h.onTouchStart?.(e)},ownerState:d,children:s}))}));function Jk(e){const t=mo({props:e,name:"MuiPickersPopper"}),{anchorEl:n,children:r,containerRef:a=null,shouldRestoreFocus:s,onBlur:i,onDismiss:o,open:l,role:u,placement:c,slots:d,slotProps:h,reduceAnimations:p}=t;T.useEffect((()=>{function e(e){l&&"Escape"===e.key&&o()}return document.addEventListener("keydown",e),()=>{document.removeEventListener("keydown",e)}}),[o,l]);const f=T.useRef(null);T.useEffect((()=>{"tooltip"===u||s&&!s()||(l?f.current=Wk(document):f.current&&f.current instanceof HTMLElement&&setTimeout((()=>{f.current instanceof HTMLElement&&f.current.focus()})))}),[l,u,s]);const[m,g,y]=function(e,t){const n=T.useRef(!1),r=T.useRef(!1),a=T.useRef(null),s=T.useRef(!1);T.useEffect((()=>{if(e)return document.addEventListener("mousedown",t,!0),document.addEventListener("touchstart",t,!0),()=>{document.removeEventListener("mousedown",t,!0),document.removeEventListener("touchstart",t,!0),s.current=!1};function t(){s.current=!0}}),[e]);const i=Lk((e=>{if(!s.current)return;const i=r.current;r.current=!1;const o=zk(a.current);if(!a.current||"clientX"in e&&function(e,t){return t.documentElement.clientWidth<e.clientX||t.documentElement.clientHeight<e.clientY}(e,o))return;if(n.current)return void(n.current=!1);let l;l=e.composedPath?e.composedPath().indexOf(a.current)>-1:!o.documentElement.contains(e.target)||a.current.contains(e.target),l||i||t(e)})),o=()=>{r.current=!0};return T.useEffect((()=>{if(e){const e=zk(a.current),t=()=>{n.current=!0};return e.addEventListener("touchstart",i),e.addEventListener("touchmove",t),()=>{e.removeEventListener("touchstart",i),e.removeEventListener("touchmove",t)}}}),[e,i]),T.useEffect((()=>{if(e){const e=zk(a.current);return e.addEventListener("click",i),()=>{e.removeEventListener("click",i),r.current=!1}}}),[e,i]),[a,o,o]}(l,i??o),b=Kx(T.useRef(null),a),v=Kx(b,m),x=t,w=(e=>{const{classes:t}=e;return Ex({root:["root"],paper:["paper"]},Bk,t)})(x),k=qk(),S=p??k,I=d?.desktopTransition??S?li:Qs,C=d?.desktopTrapFocus??ni,N=d?.desktopPaper??Yk,E=d?.popper??Xk,A=tw({elementType:E,externalSlotProps:h?.popper,additionalProps:{transition:!0,role:u,open:l,anchorEl:n,placement:c,onKeyDown:e=>{"Escape"===e.key&&(e.stopPropagation(),o())}},className:w.root,ownerState:t});return(0,Zn.jsx)(E,(0,_o.A)({},A,{children:e=>{let{TransitionProps:t,placement:n}=e;return(0,Zn.jsx)(C,(0,_o.A)({open:l,disableAutoFocus:!0,disableRestoreFocus:!0,disableEnforceFocus:"tooltip"===u,isEnabled:()=>!0},h?.desktopTrapFocus,{children:(0,Zn.jsx)(I,(0,_o.A)({},t,h?.desktopTransition,{children:(0,Zn.jsx)(Qk,{PaperComponent:N,ownerState:x,popperPlacement:n,ref:v,onPaperClick:g,onPaperTouchStart:y,paperClasses:w.paper,paperSlotProps:h?.desktopPaper,children:r})}))}))}}))}function Zk(e,t,n,r){const{value:a,onError:s}=e,i=Ix(),o=T.useRef(r),l=t({adapter:i,value:a,props:e});return T.useEffect((()=>{s&&!n(l,o.current)&&s(l,a),o.current=l}),[n,s,o,l,a]),l}function eS(e){let{controlled:t,default:n,name:r,state:a="value"}=e;const{current:s}=T.useRef(void 0!==t),[i,o]=T.useState(n);return[s?t:i,T.useCallback((e=>{s||o(e)}),[])]}const tS=e=>{let{timezone:t,value:n,defaultValue:r,onChange:a,valueManager:s}=e;const i=Cx(),o=T.useRef(r),l=n??o.current??s.emptyValue,u=T.useMemo((()=>s.getTimezone(i,l)),[i,s,l]),c=Lk((e=>null==u?e:s.setTimezone(i,u,e))),d=t??u??"default";return{value:T.useMemo((()=>s.setTimezone(i,d,l)),[s,i,d,l]),handleValueChange:Lk((function(e){const t=c(e);for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];a?.(t,...r)})),timezone:d}},nS=e=>{let{name:t,timezone:n,value:r,defaultValue:a,onChange:s,valueManager:i}=e;const[o,l]=eS({name:t,state:"value",controlled:r,default:a??i.emptyValue}),u=Lk((function(e){l(e);for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];s?.(e,...n)}));return tS({timezone:n,value:o,defaultValue:void 0,onChange:u,valueManager:i})},rS=e=>{let{props:t,valueManager:n,valueType:r,wrapperVariant:a,validator:s}=e;const{onAccept:i,onChange:o,value:l,defaultValue:u,closeOnSelect:c="desktop"===a,timezone:d}=t,{current:h}=T.useRef(u),{current:p}=T.useRef(void 0!==l);const f=Cx(),m=Ix(),{isOpen:g,setIsOpen:y}=(e=>{let{open:t,onOpen:n,onClose:r}=e;const a=T.useRef("boolean"===typeof t).current,[s,i]=T.useState(!1);return T.useEffect((()=>{if(a){if("boolean"!==typeof t)throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");i(t)}}),[a,t]),{isOpen:s,setIsOpen:T.useCallback((e=>{a||i(e),e&&n&&n(),!e&&r&&r()}),[a,n,r])}})(t),{timezone:b,value:v,handleValueChange:x}=tS({timezone:d,value:l,defaultValue:h,onChange:o,valueManager:n}),[w,k]=T.useState((()=>{let e;return e=void 0!==v?v:void 0!==h?h:n.emptyValue,{draft:e,lastPublishedValue:e,lastCommittedValue:e,lastControlledValue:v,hasBeenModifiedSinceMount:!1}}));Zk((0,_o.A)({},t,{value:w.draft,timezone:b}),s,n.isSameError,n.defaultErrorState);const S=Lk((e=>{const r={action:e,dateState:w,hasChanged:t=>!n.areValuesEqual(f,e.value,t),isControlled:p,closeOnSelect:c},a=(e=>{const{action:t,hasChanged:n,dateState:r,isControlled:a}=e,s=!a&&!r.hasBeenModifiedSinceMount;return"setValueFromField"===t.name||("setValueFromAction"===t.name?!(!s||!["accept","today","clear"].includes(t.pickerAction))||n(r.lastPublishedValue):("setValueFromView"===t.name&&"shallow"!==t.selectionState||"setValueFromShortcut"===t.name)&&(!!s||n(r.lastPublishedValue)))})(r),o=(e=>{const{action:t,hasChanged:n,dateState:r,isControlled:a,closeOnSelect:s}=e,i=!a&&!r.hasBeenModifiedSinceMount;return"setValueFromAction"===t.name?!(!i||!["accept","today","clear"].includes(t.pickerAction))||n(r.lastCommittedValue):"setValueFromView"===t.name&&"finish"===t.selectionState&&s?!!i||n(r.lastCommittedValue):"setValueFromShortcut"===t.name&&"accept"===t.changeImportance&&n(r.lastCommittedValue)})(r),l=(e=>{const{action:t,closeOnSelect:n}=e;return"setValueFromAction"===t.name||("setValueFromView"===t.name?"finish"===t.selectionState&&n:"setValueFromShortcut"===t.name&&"accept"===t.changeImportance)})(r);k((t=>(0,_o.A)({},t,{draft:e.value,lastPublishedValue:a?e.value:t.lastPublishedValue,lastCommittedValue:o?e.value:t.lastCommittedValue,hasBeenModifiedSinceMount:!0})));let u=null;const d=()=>{if(!u){const n="setValueFromField"===e.name?e.context.validationError:s({adapter:m,value:e.value,props:(0,_o.A)({},t,{value:e.value,timezone:b})});u={validationError:n},"setValueFromShortcut"===e.name&&(u.shortcut=e.shortcut)}return u};a&&x(e.value,d()),o&&i&&i(e.value,d()),l&&y(!1)}));if(void 0!==v&&(void 0===w.lastControlledValue||!n.areValuesEqual(f,w.lastControlledValue,v))){const e=n.areValuesEqual(f,w.draft,v);k((t=>(0,_o.A)({},t,{lastControlledValue:v},e?{}:{lastCommittedValue:v,lastPublishedValue:v,draft:v,hasBeenModifiedSinceMount:!0})))}const I=Lk((()=>{S({value:n.emptyValue,name:"setValueFromAction",pickerAction:"clear"})})),C=Lk((()=>{S({value:w.lastPublishedValue,name:"setValueFromAction",pickerAction:"accept"})})),N=Lk((()=>{S({value:w.lastPublishedValue,name:"setValueFromAction",pickerAction:"dismiss"})})),E=Lk((()=>{S({value:w.lastCommittedValue,name:"setValueFromAction",pickerAction:"cancel"})})),A=Lk((()=>{S({value:n.getTodayValue(f,b,r),name:"setValueFromAction",pickerAction:"today"})})),_=Lk((e=>{e.preventDefault(),y(!0)})),$=Lk((e=>{e?.preventDefault(),y(!1)})),R=Lk((function(e){return S({name:"setValueFromView",value:e,selectionState:arguments.length>1&&void 0!==arguments[1]?arguments[1]:"partial"})})),D=Lk(((e,t,n)=>S({name:"setValueFromShortcut",value:e,changeImportance:t,shortcut:n}))),M=Lk(((e,t)=>S({name:"setValueFromField",value:e,context:t}))),F={onClear:I,onAccept:C,onDismiss:N,onCancel:E,onSetToday:A,onOpen:_,onClose:$},O={value:w.draft,onChange:M},P=T.useMemo((()=>n.cleanValue(f,w.draft)),[f,n,w.draft]);return{open:g,fieldProps:O,viewProps:{value:P,onChange:R,onClose:$,open:g},layoutProps:(0,_o.A)({},F,{value:P,onChange:R,onSelectShortcut:D,isValid:e=>{const r=s({adapter:m,value:e,props:(0,_o.A)({},t,{value:e,timezone:b})});return!n.hasError(r)}}),actions:F}};function aS(e){let{onChange:t,onViewChange:n,openTo:r,view:a,views:s,autoFocus:i,focusedView:o,onFocusedViewChange:l}=e;const u=T.useRef(r),c=T.useRef(s),d=T.useRef(s.includes(r)?r:s[0]),[h,p]=eS({name:"useViews",state:"view",controlled:a,default:d.current}),f=T.useRef(i?h:null),[m,g]=eS({name:"useViews",state:"focusedView",controlled:o,default:f.current});T.useEffect((()=>{(u.current&&u.current!==r||c.current&&c.current.some((e=>!s.includes(e))))&&(p(s.includes(r)?r:s[0]),c.current=s,u.current=r)}),[r,p,h,s]);const y=s.indexOf(h),b=s[y-1]??null,v=s[y+1]??null,x=Lk(((e,t)=>{g(t?e:t=>e===t?null:t),l?.(e,t)})),w=Lk((e=>{x(e,!0),e!==h&&(p(e),n&&n(e))})),k=Lk((()=>{v&&w(v)})),S=Lk(((e,n,r)=>{const a="finish"===n,i=r?s.indexOf(r)<s.length-1:Boolean(v);if(t(e,a&&i?"partial":n,r),r&&r!==h){const e=s[s.indexOf(r)+1];e&&w(e)}else a&&k()}));return{view:h,setView:w,focusedView:m,setFocusedView:x,nextView:v,previousView:b,defaultView:s.includes(r)?r:s[0],goToNextView:k,setValueAndGoToNextView:S}}const sS=["className","sx"],iS=e=>{let{props:t,propsFromPickerValue:n,additionalViewProps:r,autoFocusView:a,rendererInterceptor:s,fieldRef:i}=e;const{onChange:o,open:l,onClose:u}=n,{view:c,views:d,openTo:h,onViewChange:p,viewRenderers:f,timezone:m}=t,g=$s(t,sS),{view:y,setView:b,defaultView:v,focusedView:x,setFocusedView:w,setValueAndGoToNextView:k}=aS({view:c,views:d,openTo:h,onChange:o,onViewChange:p,autoFocus:a}),{hasUIView:S,viewModeLookup:I}=T.useMemo((()=>d.reduce(((e,t)=>{let n;return n=null!=f[t]?"UI":"field",e.viewModeLookup[t]=n,"UI"===n&&(e.hasUIView=!0),e}),{hasUIView:!1,viewModeLookup:{}})),[f,d]),C=T.useMemo((()=>d.reduce(((e,t)=>null!=f[t]&&(e=>qv.includes(e))(t)?e+1:e),0)),[f,d]),N=I[y],E=Lk((()=>"UI"===N)),[A,_]=T.useState("UI"===N?y:null);A!==y&&"UI"===I[y]&&_(y),Pk((()=>{"field"===N&&l&&(u(),setTimeout((()=>{i?.current?.setSelectedSections(y),i?.current?.focusField(y)})))}),[y]),Pk((()=>{if(!l)return;let e=y;"field"===N&&null!=A&&(e=A),e!==v&&"UI"===I[e]&&"UI"===I[v]&&(e=v),e!==y&&b(e),w(e,!0)}),[l]);return{hasUIView:S,shouldRestoreFocus:E,layoutProps:{views:d,view:A,onViewChange:b},renderCurrentView:()=>{if(null==A)return null;const e=f[A];if(null==e)return null;const t=(0,_o.A)({},g,r,n,{views:d,timezone:m,onChange:k,view:A,onViewChange:b,focusedView:x,onFocusedViewChange:w,showViewSwitcher:C>1,timeViewsCount:C});return s?s(f,A,t):e(t)}}};function oS(){return"undefined"===typeof window?"portrait":window.screen&&window.screen.orientation&&window.screen.orientation.angle?90===Math.abs(window.screen.orientation.angle)?"landscape":"portrait":window.orientation&&90===Math.abs(Number(window.orientation))?"landscape":"portrait"}const lS=(e,t)=>{const[n,r]=T.useState(oS);if(Pk((()=>{const e=()=>{r(oS())};return window.addEventListener("orientationchange",e),()=>{window.removeEventListener("orientationchange",e)}}),[]),function(e,t){return Array.isArray(t)?t.every((t=>-1!==e.indexOf(t))):-1!==e.indexOf(t)}(e,["hours","minutes","seconds"]))return!1;return"landscape"===(t||n)},uS=e=>{let{props:t,valueManager:n,valueType:r,wrapperVariant:a,additionalViewProps:s,validator:i,autoFocusView:o,rendererInterceptor:l,fieldRef:u}=e;const c=rS({props:t,valueManager:n,valueType:r,wrapperVariant:a,validator:i}),d=iS({props:t,additionalViewProps:s,autoFocusView:o,fieldRef:u,propsFromPickerValue:c.viewProps,rendererInterceptor:l}),h=(e=>{let{props:t,propsFromPickerValue:n,propsFromPickerViews:r,wrapperVariant:a}=e;const{orientation:s}=t,i=lS(r.views,s),o=rs();return{layoutProps:(0,_o.A)({},r,n,{isLandscape:i,isRtl:o,wrapperVariant:a,disabled:t.disabled,readOnly:t.readOnly})}})({props:t,wrapperVariant:a,propsFromPickerValue:c.layoutProps,propsFromPickerViews:d.layoutProps});return{open:c.open,actions:c.actions,fieldProps:c.fieldProps,renderCurrentView:d.renderCurrentView,hasUIView:d.hasUIView,shouldRestoreFocus:d.shouldRestoreFocus,layoutProps:h.layoutProps}};function cS(e){return Dx("MuiPickersLayout",e)}const dS=Mx("MuiPickersLayout",["root","landscape","contentWrapper","toolbar","actionBar","tabs","shortcuts"]),hS=["onAccept","onClear","onCancel","onSetToday","actions"];function pS(e){const{onAccept:t,onClear:n,onCancel:r,onSetToday:a,actions:s}=e,i=$s(e,hS),o=Bx();if(null==s||0===s.length)return null;const l=s?.map((e=>{switch(e){case"clear":return(0,Zn.jsx)(sl,{onClick:n,children:o.clearButtonLabel},e);case"cancel":return(0,Zn.jsx)(sl,{onClick:r,children:o.cancelButtonLabel},e);case"accept":return(0,Zn.jsx)(sl,{onClick:t,children:o.okButtonLabel},e);case"today":return(0,Zn.jsx)(sl,{onClick:a,children:o.todayButtonLabel},e);default:return null}}));return(0,Zn.jsx)(su,(0,_o.A)({},i,{children:l}))}function fS(e){return(0,gr.Ay)("MuiListItem",e)}(0,rr.A)("MuiListItem",["root","container","dense","alignItemsFlexStart","divider","gutters","padding","secondaryAction"]);const mS=(0,rr.A)("MuiListItemButton",["root","focusVisible","dense","alignItemsFlexStart","disabled","divider","gutters","selected"]);function gS(e){return(0,gr.Ay)("MuiListItemSecondaryAction",e)}(0,rr.A)("MuiListItemSecondaryAction",["root","disableGutters"]);const yS=(0,cr.Ay)("div",{name:"MuiListItemSecondaryAction",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.disableGutters&&t.disableGutters]}})({position:"absolute",right:16,top:"50%",transform:"translateY(-50%)",variants:[{props:e=>{let{ownerState:t}=e;return t.disableGutters},style:{right:0}}]}),bS=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiListItemSecondaryAction"}),{className:r,...a}=n,s=T.useContext(ds),i={...n,disableGutters:s.disableGutters},o=(e=>{const{disableGutters:t,classes:n}=e,r={root:["root",t&&"disableGutters"]};return(0,lr.A)(r,gS,n)})(i);return(0,Zn.jsx)(yS,{className:(0,Wn.A)(o.root,r),ownerState:i,ref:t,...a})}));bS.muiName="ListItemSecondaryAction";const vS=bS,xS=(0,cr.Ay)("div",{name:"MuiListItem",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.dense&&t.dense,"flex-start"===n.alignItems&&t.alignItemsFlexStart,n.divider&&t.divider,!n.disableGutters&&t.gutters,!n.disablePadding&&t.padding,n.hasSecondaryAction&&t.secondaryAction]}})((0,pr.A)((e=>{let{theme:t}=e;return{display:"flex",justifyContent:"flex-start",alignItems:"center",position:"relative",textDecoration:"none",width:"100%",boxSizing:"border-box",textAlign:"left",variants:[{props:e=>{let{ownerState:t}=e;return!t.disablePadding},style:{paddingTop:8,paddingBottom:8}},{props:e=>{let{ownerState:t}=e;return!t.disablePadding&&t.dense},style:{paddingTop:4,paddingBottom:4}},{props:e=>{let{ownerState:t}=e;return!t.disablePadding&&!t.disableGutters},style:{paddingLeft:16,paddingRight:16}},{props:e=>{let{ownerState:t}=e;return!t.disablePadding&&!!t.secondaryAction},style:{paddingRight:48}},{props:e=>{let{ownerState:t}=e;return!!t.secondaryAction},style:{[`& > .${mS.root}`]:{paddingRight:48}}},{props:{alignItems:"flex-start"},style:{alignItems:"flex-start"}},{props:e=>{let{ownerState:t}=e;return t.divider},style:{borderBottom:`1px solid ${(t.vars||t).palette.divider}`,backgroundClip:"padding-box"}},{props:e=>{let{ownerState:t}=e;return t.button},style:{transition:t.transitions.create("background-color",{duration:t.transitions.duration.shortest}),"&:hover":{textDecoration:"none",backgroundColor:(t.vars||t).palette.action.hover,"@media (hover: none)":{backgroundColor:"transparent"}}}},{props:e=>{let{ownerState:t}=e;return t.hasSecondaryAction},style:{paddingRight:48}}]}}))),wS=(0,cr.Ay)("li",{name:"MuiListItem",slot:"Container",overridesResolver:(e,t)=>t.container})({position:"relative"}),kS=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiListItem"}),{alignItems:r="center",children:a,className:s,component:i,components:o={},componentsProps:l={},ContainerComponent:u="li",ContainerProps:{className:c,...d}={},dense:h=!1,disableGutters:p=!1,disablePadding:f=!1,divider:m=!1,secondaryAction:g,slotProps:y={},slots:b={},...v}=n,x=T.useContext(ds),w=T.useMemo((()=>({dense:h||x.dense||!1,alignItems:r,disableGutters:p})),[r,x.dense,h,p]),k=T.useRef(null),S=T.Children.toArray(a),I=S.length&&(0,ja.A)(S[S.length-1],["ListItemSecondaryAction"]),C={...n,alignItems:r,dense:w.dense,disableGutters:p,disablePadding:f,divider:m,hasSecondaryAction:I},N=(e=>{const{alignItems:t,classes:n,dense:r,disableGutters:a,disablePadding:s,divider:i,hasSecondaryAction:o}=e,l={root:["root",r&&"dense",!a&&"gutters",!s&&"padding",i&&"divider","flex-start"===t&&"alignItemsFlexStart",o&&"secondaryAction"],container:["container"]};return(0,lr.A)(l,fS,n)})(C),E=(0,Jr.A)(k,t),A=b.root||o.Root||xS,_=y.root||l.root||{},$={className:(0,Wn.A)(N.root,_.className,s),...v};let R=i||"li";return I?(R=$.component||i?R:"div","li"===u&&("li"===R?R="div":"li"===$.component&&($.component="div")),(0,Zn.jsx)(ds.Provider,{value:w,children:(0,Zn.jsxs)(wS,{as:u,className:(0,Wn.A)(N.container,c),ref:E,ownerState:C,...d,children:[(0,Zn.jsx)(A,{..._,...!Kr(A)&&{as:R,ownerState:{...C,..._.ownerState}},...$,children:S}),S.pop()]})})):(0,Zn.jsx)(ds.Provider,{value:w,children:(0,Zn.jsxs)(A,{..._,as:R,ref:E,...!Kr(A)&&{ownerState:{...C,..._.ownerState}},...$,children:[S,g&&(0,Zn.jsx)(vS,{children:g})]})})})),SS=kS,IS=(0,uo.A)((0,Zn.jsx)("path",{d:"M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"}),"Cancel");function CS(e){return(0,gr.Ay)("MuiChip",e)}const NS=(0,rr.A)("MuiChip",["root","sizeSmall","sizeMedium","colorDefault","colorError","colorInfo","colorPrimary","colorSecondary","colorSuccess","colorWarning","disabled","clickable","clickableColorPrimary","clickableColorSecondary","deletable","deletableColorPrimary","deletableColorSecondary","outlined","filled","outlinedPrimary","outlinedSecondary","filledPrimary","filledSecondary","avatar","avatarSmall","avatarMedium","avatarColorPrimary","avatarColorSecondary","icon","iconSmall","iconMedium","iconColorPrimary","iconColorSecondary","label","labelSmall","labelMedium","deleteIcon","deleteIconSmall","deleteIconMedium","deleteIconColorPrimary","deleteIconColorSecondary","deleteIconOutlinedColorPrimary","deleteIconOutlinedColorSecondary","deleteIconFilledColorPrimary","deleteIconFilledColorSecondary","focusVisible"]),TS=(0,cr.Ay)("div",{name:"MuiChip",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e,{color:r,iconColor:a,clickable:s,onDelete:i,size:o,variant:l}=n;return[{[`& .${NS.avatar}`]:t.avatar},{[`& .${NS.avatar}`]:t[`avatar${(0,_r.A)(o)}`]},{[`& .${NS.avatar}`]:t[`avatarColor${(0,_r.A)(r)}`]},{[`& .${NS.icon}`]:t.icon},{[`& .${NS.icon}`]:t[`icon${(0,_r.A)(o)}`]},{[`& .${NS.icon}`]:t[`iconColor${(0,_r.A)(a)}`]},{[`& .${NS.deleteIcon}`]:t.deleteIcon},{[`& .${NS.deleteIcon}`]:t[`deleteIcon${(0,_r.A)(o)}`]},{[`& .${NS.deleteIcon}`]:t[`deleteIconColor${(0,_r.A)(r)}`]},{[`& .${NS.deleteIcon}`]:t[`deleteIcon${(0,_r.A)(l)}Color${(0,_r.A)(r)}`]},t.root,t[`size${(0,_r.A)(o)}`],t[`color${(0,_r.A)(r)}`],s&&t.clickable,s&&"default"!==r&&t[`clickableColor${(0,_r.A)(r)})`],i&&t.deletable,i&&"default"!==r&&t[`deletableColor${(0,_r.A)(r)}`],t[l],t[`${l}${(0,_r.A)(r)}`]]}})((0,pr.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?t.palette.grey[700]:t.palette.grey[300];return{maxWidth:"100%",fontFamily:t.typography.fontFamily,fontSize:t.typography.pxToRem(13),display:"inline-flex",alignItems:"center",justifyContent:"center",height:32,color:(t.vars||t).palette.text.primary,backgroundColor:(t.vars||t).palette.action.selected,borderRadius:16,whiteSpace:"nowrap",transition:t.transitions.create(["background-color","box-shadow"]),cursor:"unset",outline:0,textDecoration:"none",border:0,padding:0,verticalAlign:"middle",boxSizing:"border-box",[`&.${NS.disabled}`]:{opacity:(t.vars||t).palette.action.disabledOpacity,pointerEvents:"none"},[`& .${NS.avatar}`]:{marginLeft:5,marginRight:-6,width:24,height:24,color:t.vars?t.vars.palette.Chip.defaultAvatarColor:n,fontSize:t.typography.pxToRem(12)},[`& .${NS.avatarColorPrimary}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.dark},[`& .${NS.avatarColorSecondary}`]:{color:(t.vars||t).palette.secondary.contrastText,backgroundColor:(t.vars||t).palette.secondary.dark},[`& .${NS.avatarSmall}`]:{marginLeft:4,marginRight:-4,width:18,height:18,fontSize:t.typography.pxToRem(10)},[`& .${NS.icon}`]:{marginLeft:5,marginRight:-6},[`& .${NS.deleteIcon}`]:{WebkitTapHighlightColor:"transparent",color:t.vars?`rgba(${t.vars.palette.text.primaryChannel} / 0.26)`:(0,ur.X4)(t.palette.text.primary,.26),fontSize:22,cursor:"pointer",margin:"0 5px 0 -6px","&:hover":{color:t.vars?`rgba(${t.vars.palette.text.primaryChannel} / 0.4)`:(0,ur.X4)(t.palette.text.primary,.4)}},variants:[{props:{size:"small"},style:{height:24,[`& .${NS.icon}`]:{fontSize:18,marginLeft:4,marginRight:-4},[`& .${NS.deleteIcon}`]:{fontSize:16,marginRight:4,marginLeft:-4}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.contrastText})).map((e=>{let[n]=e;return{props:{color:n},style:{backgroundColor:(t.vars||t).palette[n].main,color:(t.vars||t).palette[n].contrastText,[`& .${NS.deleteIcon}`]:{color:t.vars?`rgba(${t.vars.palette[n].contrastTextChannel} / 0.7)`:(0,ur.X4)(t.palette[n].contrastText,.7),"&:hover, &:active":{color:(t.vars||t).palette[n].contrastText}}}}})),{props:e=>e.iconColor===e.color,style:{[`& .${NS.icon}`]:{color:t.vars?t.vars.palette.Chip.defaultIconColor:n}}},{props:e=>e.iconColor===e.color&&"default"!==e.color,style:{[`& .${NS.icon}`]:{color:"inherit"}}},{props:{onDelete:!0},style:{[`&.${NS.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.focusOpacity}))`:(0,ur.X4)(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.focusOpacity)}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.dark})).map((e=>{let[n]=e;return{props:{color:n,onDelete:!0},style:{[`&.${NS.focusVisible}`]:{background:(t.vars||t).palette[n].dark}}}})),{props:{clickable:!0},style:{userSelect:"none",WebkitTapHighlightColor:"transparent",cursor:"pointer","&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.hoverOpacity}))`:(0,ur.X4)(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.hoverOpacity)},[`&.${NS.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.focusOpacity}))`:(0,ur.X4)(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.focusOpacity)},"&:active":{boxShadow:(t.vars||t).shadows[1]}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.dark})).map((e=>{let[n]=e;return{props:{color:n,clickable:!0},style:{[`&:hover, &.${NS.focusVisible}`]:{backgroundColor:(t.vars||t).palette[n].dark}}}})),{props:{variant:"outlined"},style:{backgroundColor:"transparent",border:t.vars?`1px solid ${t.vars.palette.Chip.defaultBorder}`:`1px solid ${"light"===t.palette.mode?t.palette.grey[400]:t.palette.grey[700]}`,[`&.${NS.clickable}:hover`]:{backgroundColor:(t.vars||t).palette.action.hover},[`&.${NS.focusVisible}`]:{backgroundColor:(t.vars||t).palette.action.focus},[`& .${NS.avatar}`]:{marginLeft:4},[`& .${NS.avatarSmall}`]:{marginLeft:2},[`& .${NS.icon}`]:{marginLeft:4},[`& .${NS.iconSmall}`]:{marginLeft:2},[`& .${NS.deleteIcon}`]:{marginRight:5},[`& .${NS.deleteIconSmall}`]:{marginRight:3}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{variant:"outlined",color:n},style:{color:(t.vars||t).palette[n].main,border:`1px solid ${t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.7)`:(0,ur.X4)(t.palette[n].main,.7)}`,[`&.${NS.clickable}:hover`]:{backgroundColor:t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,ur.X4)(t.palette[n].main,t.palette.action.hoverOpacity)},[`&.${NS.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.focusOpacity})`:(0,ur.X4)(t.palette[n].main,t.palette.action.focusOpacity)},[`& .${NS.deleteIcon}`]:{color:t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.7)`:(0,ur.X4)(t.palette[n].main,.7),"&:hover, &:active":{color:(t.vars||t).palette[n].main}}}}}))]}}))),ES=(0,cr.Ay)("span",{name:"MuiChip",slot:"Label",overridesResolver:(e,t)=>{const{ownerState:n}=e,{size:r}=n;return[t.label,t[`label${(0,_r.A)(r)}`]]}})({overflow:"hidden",textOverflow:"ellipsis",paddingLeft:12,paddingRight:12,whiteSpace:"nowrap",variants:[{props:{variant:"outlined"},style:{paddingLeft:11,paddingRight:11}},{props:{size:"small"},style:{paddingLeft:8,paddingRight:8}},{props:{size:"small",variant:"outlined"},style:{paddingLeft:7,paddingRight:7}}]});function AS(e){return"Backspace"===e.key||"Delete"===e.key}const _S=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiChip"}),{avatar:r,className:a,clickable:s,color:i="default",component:o,deleteIcon:l,disabled:u=!1,icon:c,label:d,onClick:h,onDelete:p,onKeyDown:f,onKeyUp:m,size:g="medium",variant:y="filled",tabIndex:b,skipFocusWhenDisabled:v=!1,...x}=n,w=T.useRef(null),k=(0,Jr.A)(w,t),S=e=>{e.stopPropagation(),p&&p(e)},I=!(!1===s||!h)||s,C=I||p?Xo:o||"div",N={...n,component:C,disabled:u,size:g,color:i,iconColor:T.isValidElement(c)&&c.props.color||i,onDelete:!!p,clickable:I,variant:y},E=(e=>{const{classes:t,disabled:n,size:r,color:a,iconColor:s,onDelete:i,clickable:o,variant:l}=e,u={root:["root",l,n&&"disabled",`size${(0,_r.A)(r)}`,`color${(0,_r.A)(a)}`,o&&"clickable",o&&`clickableColor${(0,_r.A)(a)}`,i&&"deletable",i&&`deletableColor${(0,_r.A)(a)}`,`${l}${(0,_r.A)(a)}`],label:["label",`label${(0,_r.A)(r)}`],avatar:["avatar",`avatar${(0,_r.A)(r)}`,`avatarColor${(0,_r.A)(a)}`],icon:["icon",`icon${(0,_r.A)(r)}`,`iconColor${(0,_r.A)(s)}`],deleteIcon:["deleteIcon",`deleteIcon${(0,_r.A)(r)}`,`deleteIconColor${(0,_r.A)(a)}`,`deleteIcon${(0,_r.A)(l)}Color${(0,_r.A)(a)}`]};return(0,lr.A)(u,CS,t)})(N),A=C===Xo?{component:o||"div",focusVisibleClassName:E.focusVisible,...p&&{disableRipple:!0}}:{};let _=null;p&&(_=l&&T.isValidElement(l)?T.cloneElement(l,{className:(0,Wn.A)(l.props.className,E.deleteIcon),onClick:S}):(0,Zn.jsx)(IS,{className:(0,Wn.A)(E.deleteIcon),onClick:S}));let $=null;r&&T.isValidElement(r)&&($=T.cloneElement(r,{className:(0,Wn.A)(E.avatar,r.props.className)}));let R=null;return c&&T.isValidElement(c)&&(R=T.cloneElement(c,{className:(0,Wn.A)(E.icon,c.props.className)})),(0,Zn.jsxs)(TS,{as:C,className:(0,Wn.A)(E.root,a),disabled:!(!I||!u)||void 0,onClick:h,onKeyDown:e=>{e.currentTarget===e.target&&AS(e)&&e.preventDefault(),f&&f(e)},onKeyUp:e=>{e.currentTarget===e.target&&p&&AS(e)&&p(e),m&&m(e)},ref:k,tabIndex:v&&u?-1:b,ownerState:N,...A,...x,children:[$||R,(0,Zn.jsx)(ES,{className:(0,Wn.A)(E.label),ownerState:N,children:d}),_]})})),$S=_S,RS=320,DS=["items","changeImportance","isLandscape","onChange","isValid"],MS=["getValue"];function FS(e){const{items:t,changeImportance:n="accept",onChange:r,isValid:a}=e,s=$s(e,DS);if(null==t||0===t.length)return null;const i=t.map((e=>{let{getValue:t}=e,s=$s(e,MS);const i=t({isValid:a});return(0,_o.A)({},s,{label:s.label,onClick:()=>{r(i,n,s)},disabled:!a(i)})}));return(0,Zn.jsx)(ms,(0,_o.A)({dense:!0,sx:[{maxHeight:336,maxWidth:200,overflow:"auto"},...Array.isArray(s.sx)?s.sx:[s.sx]]},s,{children:i.map((e=>(0,Zn.jsx)(SS,{children:(0,Zn.jsx)($S,(0,_o.A)({},e))},e.id??e.label)))}))}const OS=e=>{const{wrapperVariant:t,onAccept:n,onClear:r,onCancel:a,onSetToday:s,view:i,views:o,onViewChange:l,value:u,onChange:c,onSelectShortcut:d,isValid:h,isLandscape:p,disabled:f,readOnly:m,children:g,slots:y,slotProps:b}=e,v=(e=>{const{classes:t,isLandscape:n}=e;return Ex({root:["root",n&&"landscape"],contentWrapper:["contentWrapper"],toolbar:["toolbar"],actionBar:["actionBar"],tabs:["tabs"],landscape:["landscape"],shortcuts:["shortcuts"]},cS,t)})(e),x=y?.actionBar??pS,w=tw({elementType:x,externalSlotProps:b?.actionBar,additionalProps:{onAccept:n,onClear:r,onCancel:a,onSetToday:s,actions:"desktop"===t?[]:["cancel","accept"]},className:v.actionBar,ownerState:(0,_o.A)({},e,{wrapperVariant:t})}),k=(0,Zn.jsx)(x,(0,_o.A)({},w)),S=y?.toolbar,I=tw({elementType:S,externalSlotProps:b?.toolbar,additionalProps:{isLandscape:p,onChange:c,value:u,view:i,onViewChange:l,views:o,disabled:f,readOnly:m},className:v.toolbar,ownerState:(0,_o.A)({},e,{wrapperVariant:t})}),C=function(e){return null!==e.view}(I)&&S?(0,Zn.jsx)(S,(0,_o.A)({},I)):null,N=g,T=y?.tabs,E=i&&T?(0,Zn.jsx)(T,(0,_o.A)({view:i,onViewChange:l,className:v.tabs},b?.tabs)):null,A=y?.shortcuts??FS,_=tw({elementType:A,externalSlotProps:b?.shortcuts,additionalProps:{isValid:h,isLandscape:p,onChange:d},className:v.shortcuts,ownerState:{isValid:h,isLandscape:p,onChange:d,wrapperVariant:t}});return{toolbar:C,content:N,tabs:E,actionBar:k,shortcuts:i&&A?(0,Zn.jsx)(A,(0,_o.A)({},_)):null}},PS=(0,cr.Ay)("div",{name:"MuiPickersLayout",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"grid",gridAutoColumns:"max-content auto max-content",gridAutoRows:"max-content auto max-content",[`& .${dS.actionBar}`]:{gridColumn:"1 / 4",gridRow:3},variants:[{props:{isLandscape:!0},style:{[`& .${dS.toolbar}`]:{gridColumn:1,gridRow:"2 / 3"},[`.${dS.shortcuts}`]:{gridColumn:"2 / 4",gridRow:1}}},{props:{isLandscape:!0,isRtl:!0},style:{[`& .${dS.toolbar}`]:{gridColumn:3}}},{props:{isLandscape:!1},style:{[`& .${dS.toolbar}`]:{gridColumn:"2 / 4",gridRow:1},[`& .${dS.shortcuts}`]:{gridColumn:1,gridRow:"2 / 3"}}},{props:{isLandscape:!1,isRtl:!0},style:{[`& .${dS.shortcuts}`]:{gridColumn:3}}}]}),LS=(0,cr.Ay)("div",{name:"MuiPickersLayout",slot:"ContentWrapper",overridesResolver:(e,t)=>t.contentWrapper})({gridColumn:2,gridRow:2,display:"flex",flexDirection:"column"}),zS=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiPickersLayout"}),{toolbar:r,content:a,tabs:s,actionBar:i,shortcuts:o}=OS(n),{sx:l,className:u,isLandscape:c,wrapperVariant:d}=n,h=(e=>{const{isLandscape:t,classes:n}=e;return Ex({root:["root",t&&"landscape"],contentWrapper:["contentWrapper"]},cS,n)})(n);return(0,Zn.jsxs)(PS,{ref:t,sx:l,className:(0,Wn.A)(u,h.root),ownerState:n,children:[c?o:r,c?r:o,(0,Zn.jsx)(LS,{className:h.contentWrapper,children:"desktop"===d?(0,Zn.jsxs)(T.Fragment,{children:[a,s]}):(0,Zn.jsxs)(T.Fragment,{children:[s,a]})}),i]})})),BS=["props","getOpenDialogAriaText"],WS=["ownerState"],VS=["ownerState"],US=(0,uo.A)((0,Zn.jsx)("path",{d:"M7 10l5 5 5-5z"}),"ArrowDropDown"),jS=(0,uo.A)((0,Zn.jsx)("path",{d:"M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"}),"ArrowLeft"),GS=(0,uo.A)((0,Zn.jsx)("path",{d:"M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"}),"ArrowRight"),HS=(0,uo.A)((0,Zn.jsx)("path",{d:"M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"}),"Calendar"),qS=((0,uo.A)((0,Zn.jsxs)(T.Fragment,{children:[(0,Zn.jsx)("path",{d:"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"}),(0,Zn.jsx)("path",{d:"M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"})]}),"Clock"),(0,uo.A)((0,Zn.jsx)("path",{d:"M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"}),"DateRange"),(0,uo.A)((0,Zn.jsxs)(T.Fragment,{children:[(0,Zn.jsx)("path",{d:"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"}),(0,Zn.jsx)("path",{d:"M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"})]}),"Time"),(0,uo.A)((0,Zn.jsx)("path",{d:"M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"}),"Clear")),KS=(e,t,n,r,a)=>{switch(r.type){case"year":return n.fieldYearPlaceholder({digitAmount:e.formatByString(e.date(void 0,t),a).length,format:a});case"month":return n.fieldMonthPlaceholder({contentType:r.contentType,format:a});case"day":return n.fieldDayPlaceholder({format:a});case"weekDay":return n.fieldWeekDayPlaceholder({contentType:r.contentType,format:a});case"hours":return n.fieldHoursPlaceholder({format:a});case"minutes":return n.fieldMinutesPlaceholder({format:a});case"seconds":return n.fieldSecondsPlaceholder({format:a});case"meridiem":return n.fieldMeridiemPlaceholder({format:a});default:return a}},XS=e=>{let{utils:t,timezone:n,date:r,shouldRespectLeadingZeros:a,localeText:s,localizedDigits:i,now:o,token:l,startSeparator:u}=e;if(""===l)throw new Error("MUI X: Should not call `commitToken` with an empty token");const c=Jv(t,l),d=dx(t,n,c.contentType,c.type,l),h=a?d:"digit"===c.contentType,p=null!=r&&t.isValid(r);let f=p?t.formatByString(r,l):"",m=null;if(h)if(d)m=""===f?t.formatByString(o,l).length:f.length;else{if(null==c.maxLength)throw new Error(`MUI X: The token ${l} should have a 'maxDigitNumber' property on it's adapter`);m=c.maxLength,p&&(f=rx(sx(nx(f,i),m),i))}return(0,_o.A)({},c,{format:l,maxLength:m,value:f,placeholder:KS(t,n,s,c,l),hasLeadingZerosInFormat:d,hasLeadingZerosInInput:h,startSeparator:u,endSeparator:"",modified:!1})},YS=e=>{let t=(e=>{let{utils:t,format:n}=e,r=10,a=n,s=t.expandFormat(n);for(;s!==a;)if(a=s,s=t.expandFormat(a),r-=1,r<0)throw new Error("MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.");return s})(e);e.isRtl&&e.enableAccessibleFieldDOMStructure&&(t=t.split(" ").reverse().join(" "));const n=(e=>{let{utils:t,expandedFormat:n}=e;const r=[],{start:a,end:s}=t.escapedCharacters,i=new RegExp(`(\\${a}[^\\${s}]*\\${s})+`,"g");let o=null;for(;o=i.exec(n);)r.push({start:o.index,end:i.lastIndex-1});return r})((0,_o.A)({},e,{expandedFormat:t})),r=(e=>{const{utils:t,expandedFormat:n,escapedParts:r}=e,a=t.date(void 0),s=[];let i="";const o=Object.keys(t.formatTokenMap).sort(((e,t)=>t.length-e.length)),l=/^([a-zA-Z]+)/,u=new RegExp(`^(${o.join("|")})*$`),c=new RegExp(`^(${o.join("|")})`),d=e=>r.find((t=>t.start<=e&&t.end>=e));let h=0;for(;h<n.length;){const t=d(h),r=null!=t,o=l.exec(n.slice(h))?.[1];if(!r&&null!=o&&u.test(o)){let t=o;for(;t.length>0;){const n=c.exec(t)[1];t=t.slice(n.length),s.push(XS((0,_o.A)({},e,{now:a,token:n,startSeparator:i}))),i=""}h+=o.length}else{const e=n[h];r&&t?.start===h||t?.end===h||(0===s.length?i+=e:s[s.length-1].endSeparator+=e),h+=1}}return 0===s.length&&i.length>0&&s.push({type:"empty",contentType:"letter",maxLength:null,format:"",value:"",placeholder:"",hasLeadingZerosInFormat:!1,hasLeadingZerosInInput:!1,startSeparator:i,endSeparator:"",modified:!1}),s})((0,_o.A)({},e,{expandedFormat:t,escapedParts:n}));return(e=>{let{isRtl:t,formatDensity:n,sections:r}=e;return r.map((e=>{const r=e=>{let r=e;return t&&null!==r&&r.includes(" ")&&(r=`\u2069${r}\u2066`),"spacious"===n&&["/",".","-"].includes(r)&&(r=` ${r} `),r};return e.startSeparator=r(e.startSeparator),e.endSeparator=r(e.endSeparator),e}))})((0,_o.A)({},e,{sections:r}))},QS=e=>{const t=Cx(),n=Bx(),r=Ix(),a=rs(),{valueManager:s,fieldValueManager:i,valueType:o,validator:l,internalProps:u,internalProps:{value:c,defaultValue:d,referenceDate:h,onChange:p,format:f,formatDensity:m="dense",selectedSections:g,onSelectedSectionsChange:y,shouldRespectLeadingZeros:b=!1,timezone:v,enableAccessibleFieldDOMStructure:x=!1}}=e,{timezone:w,value:k,handleValueChange:S}=tS({timezone:v,value:c,defaultValue:d,onChange:p,valueManager:s}),I=T.useMemo((()=>(e=>{const t=e.date(void 0);return"0"===e.formatByString(e.setSeconds(t,0),"s")?tx:Array.from({length:10}).map(((n,r)=>e.formatByString(e.setSeconds(t,r),"s")))})(t)),[t]),C=T.useMemo((()=>((e,t,n)=>{const r=e.date(void 0,n),a=e.endOfYear(r),s=e.endOfDay(r),{maxDaysInMonth:i,longestMonth:o}=Wv(e,r).reduce(((t,n)=>{const r=e.getDaysInMonth(n);return r>t.maxDaysInMonth?{maxDaysInMonth:r,longestMonth:n}:t}),{maxDaysInMonth:0,longestMonth:null});return{year:t=>{let{format:r}=t;return{minimum:0,maximum:cx(e,n,r)?9999:99}},month:()=>({minimum:1,maximum:e.getMonth(a)+1}),day:t=>{let{currentDate:n}=t;return{minimum:1,maximum:null!=n&&e.isValid(n)?e.getDaysInMonth(n):i,longestMonth:o}},weekDay:t=>{let{format:r,contentType:a}=t;if("digit"===a){const t=Zv(e,n,r).map(Number);return{minimum:Math.min(...t),maximum:Math.max(...t)}}return{minimum:1,maximum:7}},hours:n=>{let{format:a}=n;const i=e.getHours(s);return nx(e.formatByString(e.endOfDay(r),a),t)!==i.toString()?{minimum:1,maximum:Number(nx(e.formatByString(e.startOfDay(r),a),t))}:{minimum:0,maximum:i}},minutes:()=>({minimum:0,maximum:e.getMinutes(s)}),seconds:()=>({minimum:0,maximum:e.getSeconds(s)}),meridiem:()=>({minimum:0,maximum:1}),empty:()=>({minimum:0,maximum:0})}})(t,I,w)),[t,I,w]),N=T.useCallback((function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return i.getSectionsFromValue(t,e,r,(e=>YS({utils:t,timezone:w,localeText:n,localizedDigits:I,format:f,date:e,formatDensity:m,shouldRespectLeadingZeros:b,enableAccessibleFieldDOMStructure:x,isRtl:a})))}),[i,f,n,I,a,b,t,m,w,x]),[E,A]=T.useState((()=>{const e=N(k);hx();const n={sections:e,value:k,referenceValue:s.emptyValue,tempValueStrAndroid:null},r=(e=>Math.max(...e.map((e=>Xv[e.type]??1))))(e),a=s.getInitialReferenceValue({referenceDate:h,value:k,utils:t,props:u,granularity:r,timezone:w});return(0,_o.A)({},n,{referenceValue:a})})),[_,$]=eS({controlled:g,default:null,name:"useField",state:"selectedSections"}),R=e=>{$(e),y?.(e)},D=T.useMemo((()=>mx(_,E.sections)),[_,E.sections]),M="all"===D?0:D,F=e=>{let{value:n,referenceValue:a,sections:i}=e;if(A((e=>(0,_o.A)({},e,{sections:i,value:n,referenceValue:a,tempValueStrAndroid:null}))),s.areValuesEqual(t,E.value,n))return;const o={validationError:l({adapter:r,value:n,props:(0,_o.A)({},u,{value:n,timezone:w})})};S(n,o)},O=(e,t)=>{const n=[...E.sections];return n[e]=(0,_o.A)({},n[e],{value:t,modified:!0}),n};return T.useEffect((()=>{const e=N(E.value);hx(),A((t=>(0,_o.A)({},t,{sections:e})))}),[f,t.locale,a]),T.useEffect((()=>{let e;e=!s.areValuesEqual(t,E.value,k)||s.getTimezone(t,E.value)!==s.getTimezone(t,k),e&&A((e=>(0,_o.A)({},e,{value:k,referenceValue:i.updateReferenceValue(t,k,e.referenceValue),sections:N(k)})))}),[k]),{state:E,activeSectionIndex:M,parsedSelectedSections:D,setSelectedSections:R,clearValue:()=>{F({value:s.emptyValue,referenceValue:E.referenceValue,sections:N(s.emptyValue)})},clearActiveSection:()=>{if(null==M)return;const e=E.sections[M],n=i.getActiveDateManager(t,E,e),r=n.getSections(E.sections).filter((e=>""!==e.value)).length===(""===e.value?0:1),a=O(M,""),s=r?null:t.getInvalidDate(),o=n.getNewValuesFromNewActiveDate(s);F((0,_o.A)({},o,{sections:a}))},updateSectionValue:e=>{let{activeSection:n,newSectionValue:r,shouldGoToNextSection:a}=e;a&&M<E.sections.length-1&&R(M+1);const s=i.getActiveDateManager(t,E,n),o=O(M,r),l=s.getSections(o),u=((e,t,n)=>{const r=t.some((e=>"day"===e.type)),a=[],s=[];for(let l=0;l<t.length;l+=1){const e=t[l];r&&"weekDay"===e.type||(a.push(e.format),s.push(lx(e,"non-input",n)))}const i=a.join(" "),o=s.join(" ");return e.parse(o,i)})(t,l,I);let c,d;if(null!=u&&t.isValid(u)){const e=fx(t,w,u,l,s.referenceDate,!0);c=s.getNewValuesFromNewActiveDate(e),d=!0}else c=s.getNewValuesFromNewActiveDate(u),d=(null!=u&&!t.isValid(u))!==(null!=s.date&&!t.isValid(s.date));return d?F((0,_o.A)({},c,{sections:o})):A((e=>(0,_o.A)({},e,c,{sections:o,tempValueStrAndroid:null})))},updateValueFromValueStr:e=>{const r=i.parseValueStr(e,E.referenceValue,((e,r)=>{const s=t.parse(e,f);if(null==s||!t.isValid(s))return null;const i=YS({utils:t,timezone:w,localeText:n,localizedDigits:I,format:f,date:s,formatDensity:m,shouldRespectLeadingZeros:b,enableAccessibleFieldDOMStructure:x,isRtl:a});return fx(t,w,s,i,r,!1)})),s=i.updateReferenceValue(t,r,E.referenceValue);F({value:r,referenceValue:s,sections:N(r,E.sections)})},setTempAndroidValueStr:e=>A((t=>(0,_o.A)({},t,{tempValueStrAndroid:e}))),getSectionsFromValue:N,sectionsValueBoundaries:C,localizedDigits:I,timezone:w}},JS=e=>null!=e.saveQuery,ZS=e=>{let{sections:t,updateSectionValue:n,sectionsValueBoundaries:r,localizedDigits:a,setTempAndroidValueStr:s,timezone:i}=e;const o=Cx(),[l,u]=T.useState(null),c=Lk((()=>u(null)));T.useEffect((()=>{null!=l&&t[l.sectionIndex]?.type!==l.sectionType&&c()}),[t,l,c]),T.useEffect((()=>{if(null!=l){const e=setTimeout((()=>c()),5e3);return()=>{clearTimeout(e)}}return()=>{}}),[l,c]);const d=(e,n,r)=>{let{keyPressed:a,sectionIndex:s}=e;const i=a.toLowerCase(),o=t[s];if(null!=l&&(!r||r(l.value))&&l.sectionIndex===s){const e=`${l.value}${i}`,t=n(e,o);if(!JS(t))return u({sectionIndex:s,value:e,sectionType:o.type}),t}const d=n(i,o);return JS(d)&&!d.saveQuery?(c(),null):(u({sectionIndex:s,value:i,sectionType:o.type}),JS(d)?null:d)};return{applyCharacterEditing:Lk((e=>{const l=t[e.sectionIndex],u=ax(e.keyPressed,a)?(e=>{const t=(e,t)=>{const n=nx(e,a),s=Number(n),i=r[t.type]({currentDate:null,format:t.format,contentType:t.contentType});if(s>i.maximum)return{saveQuery:!1};if(s<i.minimum)return{saveQuery:!0};const l=10*s>i.maximum||n.length===i.maximum.toString().length;return{sectionValue:ix(o,s,i,a,t),shouldGoToNextSection:l}};return d(e,((e,n)=>{if("digit"===n.contentType||"digit-with-letter"===n.contentType)return t(e,n);if("month"===n.type){const r=dx(o,i,"digit","month","MM"),a=t(e,{type:n.type,format:"MM",hasLeadingZerosInFormat:r,hasLeadingZerosInInput:!0,contentType:"digit",maxLength:2});if(JS(a))return a;const s=ux(o,a.sectionValue,"MM",n.format);return(0,_o.A)({},a,{sectionValue:s})}if("weekDay"===n.type){const r=t(e,n);if(JS(r))return r;const a=Zv(o,i,n.format)[Number(r.sectionValue)-1];return(0,_o.A)({},r,{sectionValue:a})}return{saveQuery:!1}}),(e=>ax(e,a)))})((0,_o.A)({},e,{keyPressed:rx(e.keyPressed,a)})):(e=>{const t=(e,t,n)=>{const r=t.filter((e=>e.toLowerCase().startsWith(n)));return 0===r.length?{saveQuery:!1}:{sectionValue:r[0],shouldGoToNextSection:1===r.length}},n=(e,n,r,a)=>{const s=e=>ex(o,i,n.type,e);if("letter"===n.contentType)return t(n.format,s(n.format),e);if(r&&null!=a&&"letter"===Jv(o,r).contentType){const n=s(r),i=t(0,n,e);return JS(i)?{saveQuery:!1}:(0,_o.A)({},i,{sectionValue:a(i.sectionValue,n)})}return{saveQuery:!1}};return d(e,((e,t)=>{switch(t.type){case"month":{const r=e=>ux(o,e,o.formats.month,t.format);return n(e,t,o.formats.month,r)}case"weekDay":{const r=(e,t)=>t.indexOf(e).toString();return n(e,t,o.formats.weekday,r)}case"meridiem":return n(e,t);default:return{saveQuery:!1}}}))})(e);null!=u?n({activeSection:l,newSectionValue:u.sectionValue,shouldGoToNextSection:u.shouldGoToNextSection}):s(null)})),resetCharacterQuery:c}},eI=e=>{const{internalProps:{disabled:t,readOnly:n=!1},forwardedProps:{sectionListRef:r,onBlur:a,onClick:s,onFocus:i,onInput:o,onPaste:l,focused:u,autoFocus:c=!1},fieldValueManager:d,applyCharacterEditing:h,resetCharacterQuery:p,setSelectedSections:f,parsedSelectedSections:m,state:g,clearActiveSection:y,clearValue:b,updateSectionValue:v,updateValueFromValueStr:x,sectionOrder:w,areAllSectionsEmpty:k,sectionsValueBoundaries:S}=e,I=T.useRef(null),C=Kx(r,I),N=Bx(),E=Cx(),A=cw(),[_,$]=T.useState(!1),R=T.useMemo((()=>({syncSelectionToDOM:()=>{if(!I.current)return;const e=document.getSelection();if(!e)return;if(null==m)return e.rangeCount>0&&I.current.getRoot().contains(e.getRangeAt(0).startContainer)&&e.removeAllRanges(),void(_&&I.current.getRoot().blur());if(!I.current.getRoot().contains(Wk(document)))return;const t=new window.Range;let n;if("all"===m)n=I.current.getRoot();else{n="empty"===g.sections[m].type?I.current.getSectionContainer(m):I.current.getSectionContent(m)}t.selectNodeContents(n),n.focus(),e.removeAllRanges(),e.addRange(t)},getActiveSectionIndexFromDOM:()=>{const e=Wk(document);return e&&I.current&&I.current.getRoot().contains(e)?I.current.getSectionIndexFromDOMElement(e):null},focusField:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(!I.current)return;const t=mx(e,g.sections);$(!0),I.current.getSectionContent(t).focus()},setSelectedSections:e=>{if(!I.current)return;const t=mx(e,g.sections);$(null!==("all"===t?0:t)),f(e)},isFieldFocused:()=>{const e=Wk(document);return!!I.current&&I.current.getRoot().contains(e)}})),[m,f,g.sections,_]),D=Lk((e=>{if(!I.current)return;const t=g.sections[e];I.current.getSectionContent(e).innerHTML=t.value||t.placeholder,R.syncSelectionToDOM()})),M=Lk((function(e){if(!e.isDefaultPrevented()&&I.current){$(!0);for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];if(s?.(e,...n),"all"===m)setTimeout((()=>{const e=document.getSelection().getRangeAt(0).startOffset;if(0===e)return void f(w.startIndex);let t=0,n=0;for(;n<e&&t<g.sections.length;){const e=g.sections[t];t+=1,n+=`${e.startSeparator}${e.value||e.placeholder}${e.endSeparator}`.length}f(t-1)}));else if(_){I.current.getRoot().contains(e.target)||f(w.startIndex)}else $(!0),f(w.startIndex)}})),F=Lk((e=>{if(o?.(e),!I.current||"all"!==m)return;const t=e.target.textContent??"";I.current.getRoot().innerHTML=g.sections.map((e=>`${e.startSeparator}${e.value||e.placeholder}${e.endSeparator}`)).join(""),R.syncSelectionToDOM(),0===t.length||10===t.charCodeAt(0)?(p(),b(),f("all")):t.length>1?x(t):h({keyPressed:t,sectionIndex:0})})),O=Lk((e=>{if(l?.(e),n||"all"!==m)return void e.preventDefault();const t=e.clipboardData.getData("text");e.preventDefault(),p(),x(t)})),P=Lk((function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(i?.(...t),_||!I.current)return;$(!0);null!=I.current.getSectionIndexFromDOMElement(Wk(document))||f(w.startIndex)})),L=Lk((function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];a?.(...t),setTimeout((()=>{if(!I.current)return;const e=Wk(document);!I.current.getRoot().contains(e)&&($(!1),f(null))}))})),z=Lk((e=>t=>{t.isDefaultPrevented()||f(e)})),B=Lk((e=>{e.preventDefault()})),W=Lk((e=>()=>{f(e)})),V=Lk((e=>{if(e.preventDefault(),n||t||"number"!==typeof m)return;const r=g.sections[m],a=e.clipboardData.getData("text"),s=/^[a-zA-Z]+$/.test(a),i=/^[0-9]+$/.test(a),o=/^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(a);"letter"===r.contentType&&s||"digit"===r.contentType&&i||"digit-with-letter"===r.contentType&&o?(p(),v({activeSection:r,newSectionValue:a,shouldGoToNextSection:!0})):s||i||(p(),x(a))})),U=Lk((e=>{e.preventDefault(),e.dataTransfer.dropEffect="none"})),j=Lk((e=>{if(!I.current)return;const t=e.target,r=t.textContent??"",a=I.current.getSectionIndexFromDOMElement(t),s=g.sections[a];if(!n&&I.current){if(0===r.length){if(""===s.value)return void D(a);const t=e.nativeEvent.inputType;return"insertParagraph"===t||"insertLineBreak"===t?void D(a):(p(),void y())}h({keyPressed:r,sectionIndex:a}),D(a)}else D(a)}));Pk((()=>{if(_&&I.current)if("all"===m)I.current.getRoot().focus();else if("number"===typeof m){const e=I.current.getSectionContent(m);e&&e.focus()}}),[m,_]);const G=T.useMemo((()=>g.sections.reduce(((e,t)=>(e[t.type]=S[t.type]({currentDate:null,contentType:t.contentType,format:t.format}),e)),{})),[S,g.sections]),H="all"===m,q=T.useMemo((()=>g.sections.map(((e,r)=>{const a=!H&&!t&&!n;return{container:{"data-sectionindex":r,onClick:z(r)},content:{tabIndex:H||r>0?-1:0,contentEditable:!H&&!t&&!n,role:"spinbutton",id:`${A}-${e.type}`,"aria-labelledby":`${A}-${e.type}`,"aria-readonly":n,"aria-valuenow":yx(e,E),"aria-valuemin":G[e.type].minimum,"aria-valuemax":G[e.type].maximum,"aria-valuetext":e.value?gx(e,E):N.empty,"aria-label":N[e.type],"aria-disabled":t,spellCheck:!a&&void 0,autoCapitalize:a?"off":void 0,autoCorrect:a?"off":void 0,[parseInt(T.version,10)>=17?"enterKeyHint":"enterkeyhint"]:a?"next":void 0,children:e.value||e.placeholder,onInput:j,onPaste:V,onFocus:W(r),onDragOver:U,onMouseUp:B,inputMode:"letter"===e.contentType?"text":"numeric"},before:{children:e.startSeparator},after:{children:e.endSeparator}}}))),[g.sections,W,V,U,j,z,B,t,n,H,N,E,G,A]),K=Lk((e=>{x(e.target.value)})),X=T.useMemo((()=>k?"":d.getV7HiddenInputValueFromSections(g.sections)),[k,g.sections,d]);return T.useEffect((()=>{if(null==I.current)throw new Error(["MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`","You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.","","If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:","","<DatePicker slots={{ textField: MyCustomTextField }} />","","Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element"].join("\n"));c&&I.current&&I.current.getSectionContent(w.startIndex).focus()}),[]),{interactions:R,returnedValue:{autoFocus:c,readOnly:n,focused:u??_,sectionListRef:C,onBlur:L,onClick:M,onFocus:P,onInput:F,onPaste:O,enableAccessibleFieldDOMStructure:!0,elements:q,tabIndex:0===m?-1:0,contentEditable:H,value:X,onChange:K,areAllSectionsEmpty:k}}},tI=e=>e.replace(/[\u2066\u2067\u2068\u2069]/g,""),nI=e=>{const t=rs(),n=T.useRef(),r=T.useRef(),{forwardedProps:{onFocus:a,onClick:s,onPaste:i,onBlur:o,inputRef:l,placeholder:u},internalProps:{readOnly:c=!1,disabled:d=!1},parsedSelectedSections:h,activeSectionIndex:p,state:f,fieldValueManager:m,valueManager:g,applyCharacterEditing:y,resetCharacterQuery:b,updateSectionValue:v,updateValueFromValueStr:x,clearActiveSection:w,clearValue:k,setTempAndroidValueStr:S,setSelectedSections:I,getSectionsFromValue:C,areAllSectionsEmpty:N,localizedDigits:E}=e,A=T.useRef(null),_=Kx(l,A),$=T.useMemo((()=>((e,t,n)=>{let r=0,a=n?1:0;const s=[];for(let i=0;i<e.length;i+=1){const o=e[i],l=lx(o,n?"input-rtl":"input-ltr",t),u=`${o.startSeparator}${l}${o.endSeparator}`,c=tI(u).length,d=u.length,h=tI(l),p=a+(""===h?0:l.indexOf(h[0]))+o.startSeparator.length,f=p+h.length;s.push((0,_o.A)({},o,{start:r,end:r+c,startInInput:p,endInInput:f})),r+=c,a+=d}return s})(f.sections,E,t)),[f.sections,E,t]),R=T.useMemo((()=>({syncSelectionToDOM:()=>{if(!A.current)return;if(null==h)return void(A.current.scrollLeft&&(A.current.scrollLeft=0));if(A.current!==Wk(document))return;const e=A.current.scrollTop;if("all"===h)A.current.select();else{const e=$[h],t="empty"===e.type?e.startInInput-e.startSeparator.length:e.startInInput,n="empty"===e.type?e.endInInput+e.endSeparator.length:e.endInInput;t===A.current.selectionStart&&n===A.current.selectionEnd||A.current===Wk(document)&&A.current.setSelectionRange(t,n),clearTimeout(r.current),r.current=setTimeout((()=>{!A.current||A.current!==Wk(document)||A.current.selectionStart!==A.current.selectionEnd||A.current.selectionStart===t&&A.current.selectionEnd===n||R.syncSelectionToDOM()}))}A.current.scrollTop=e},getActiveSectionIndexFromDOM:()=>{const e=A.current.selectionStart??0,t=A.current.selectionEnd??0;if(0===e&&0===t)return null;const n=e<=$[0].startInInput?1:$.findIndex((t=>t.startInInput-t.startSeparator.length>e));return-1===n?$.length-1:n-1},focusField:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;A.current?.focus(),I(e)},setSelectedSections:e=>I(e),isFieldFocused:()=>A.current===Wk(document)})),[A,h,$,I]),D=()=>{const e=A.current.selectionStart??0;let t;t=e<=$[0].startInInput||e>=$[$.length-1].endInInput?1:$.findIndex((t=>t.startInInput-t.startSeparator.length>e));const n=-1===t?$.length-1:t-1;I(n)},M=Lk((function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];a?.(...t);const s=A.current;clearTimeout(n.current),n.current=setTimeout((()=>{s&&s===A.current&&null==p&&(s.value.length&&Number(s.selectionEnd)-Number(s.selectionStart)===s.value.length?I("all"):D())}))})),F=Lk((function(e){if(!e.isDefaultPrevented()){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];s?.(e,...n),D()}})),O=Lk((e=>{if(i?.(e),e.preventDefault(),c||d)return;const t=e.clipboardData.getData("text");if("number"===typeof h){const e=f.sections[h],n=/^[a-zA-Z]+$/.test(t),r=/^[0-9]+$/.test(t),a=/^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(t);if("letter"===e.contentType&&n||"digit"===e.contentType&&r||"digit-with-letter"===e.contentType&&a)return b(),void v({activeSection:e,newSectionValue:t,shouldGoToNextSection:!0});if(n||r)return}b(),x(t)})),P=Lk((function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];o?.(...t),I(null)})),L=Lk((e=>{if(c)return;const n=e.target.value;if(""===n)return b(),void k();const r=e.nativeEvent.data,a=r&&r.length>1,s=a?r:n,i=tI(s);if(null==p||a)return void x(a?r:i);let o;if("all"===h&&1===i.length)o=i;else{const e=tI(m.getV6InputValueFromSections($,E,t));let n=-1,r=-1;for(let t=0;t<e.length;t+=1)-1===n&&e[t]!==i[t]&&(n=t),-1===r&&e[e.length-t-1]!==i[i.length-t-1]&&(r=t);const a=$[p];if(n<a.start||e.length-r-1>a.end)return;const s=i.length-e.length+a.end-tI(a.endSeparator||"").length;o=i.slice(a.start+tI(a.startSeparator||"").length,s)}if(0===o.length)return navigator.userAgent.toLowerCase().includes("android")&&S(s),b(),void w();y({keyPressed:o,sectionIndex:p})})),z=T.useMemo((()=>void 0!==u?u:m.getV6InputValueFromSections(C(g.emptyValue),E,t)),[u,m,C,g.emptyValue,E,t]),B=T.useMemo((()=>f.tempValueStrAndroid??m.getV6InputValueFromSections(f.sections,E,t)),[f.sections,m,f.tempValueStrAndroid,E,t]);T.useEffect((()=>(A.current&&A.current===Wk(document)&&I("all"),()=>{clearTimeout(n.current),clearTimeout(r.current)})),[]);const W=T.useMemo((()=>null==p||"letter"===f.sections[p].contentType?"text":"numeric"),[p,f.sections]),V=A.current&&A.current===Wk(document);return{interactions:R,returnedValue:{readOnly:c,onBlur:P,onClick:F,onFocus:M,onPaste:O,inputRef:_,enableAccessibleFieldDOMStructure:!1,placeholder:z,inputMode:W,autoComplete:"off",value:!V&&N?"":B,onChange:L}}},rI=["disablePast","disableFuture","minDate","maxDate","shouldDisableDate","shouldDisableMonth","shouldDisableYear"],aI=["disablePast","disableFuture","minTime","maxTime","shouldDisableTime","minutesStep","ampm","disableIgnoringDatePartForTimeValidation"],sI=["minDateTime","maxDateTime"],iI=[...rI,...aI,...sI],oI=e=>iI.reduce(((t,n)=>(e.hasOwnProperty(n)&&(t[n]=e[n]),t)),{}),lI=["value","defaultValue","referenceDate","format","formatDensity","onChange","timezone","onError","shouldRespectLeadingZeros","selectedSections","onSelectedSectionsChange","unstableFieldRef","enableAccessibleFieldDOMStructure","disabled","readOnly","dateSeparator"],uI=e=>{const t=(e=>{const t=Cx(),n=Nx();return(0,_o.A)({},e,{disablePast:e.disablePast??!1,disableFuture:e.disableFuture??!1,format:e.format??t.formats.keyboardDate,minDate:Bv(t,e.minDate,n.minDate),maxDate:Bv(t,e.maxDate,n.maxDate)})})(e),{forwardedProps:n,internalProps:r}=((e,t)=>{const n=(0,_o.A)({},e),r={},a=e=>{n.hasOwnProperty(e)&&(r[e]=n[e],delete n[e])};return lI.forEach(a),"date"===t?rI.forEach(a):"time"===t?aI.forEach(a):"date-time"===t&&(rI.forEach(a),aI.forEach(a),sI.forEach(a)),{forwardedProps:n,internalProps:r}})(t,"date");return(e=>{const t=Cx(),{internalProps:n,internalProps:{unstableFieldRef:r,minutesStep:a,enableAccessibleFieldDOMStructure:s=!1,disabled:i=!1,readOnly:o=!1},forwardedProps:{onKeyDown:l,error:u,clearable:c,onClear:d},fieldValueManager:h,valueManager:p,validator:f}=e,m=rs(),g=QS(e),{state:y,activeSectionIndex:b,parsedSelectedSections:v,setSelectedSections:x,clearValue:w,clearActiveSection:k,updateSectionValue:S,setTempAndroidValueStr:I,sectionsValueBoundaries:C,localizedDigits:N,timezone:E}=g,A=ZS({sections:y.sections,updateSectionValue:S,sectionsValueBoundaries:C,localizedDigits:N,setTempAndroidValueStr:I,timezone:E}),{resetCharacterQuery:_}=A,$=p.areValuesEqual(t,y.value,p.emptyValue),R=s?eI:nI,D=T.useMemo((()=>((e,t)=>{const n={};if(!t)return e.forEach(((t,r)=>{const a=0===r?null:r-1,s=r===e.length-1?null:r+1;n[r]={leftIndex:a,rightIndex:s}})),{neighbors:n,startIndex:0,endIndex:e.length-1};const r={},a={};let s=0,i=0,o=e.length-1;for(;o>=0;){i=e.findIndex(((e,t)=>t>=s&&e.endSeparator?.includes(" ")&&" / "!==e.endSeparator)),-1===i&&(i=e.length-1);for(let e=i;e>=s;e-=1)a[e]=o,r[o]=e,o-=1;s=i+1}return e.forEach(((t,s)=>{const i=a[s],o=0===i?null:r[i-1],l=i===e.length-1?null:r[i+1];n[s]={leftIndex:o,rightIndex:l}})),{neighbors:n,startIndex:r[0],endIndex:r[e.length-1]}})(y.sections,m&&!s)),[y.sections,m,s]),{returnedValue:M,interactions:F}=R((0,_o.A)({},e,g,A,{areAllSectionsEmpty:$,sectionOrder:D})),O=Lk((e=>{if(l?.(e),!i)switch(!0){case(e.ctrlKey||e.metaKey)&&"a"===e.key.toLowerCase()&&!e.shiftKey&&!e.altKey:e.preventDefault(),x("all");break;case"ArrowRight"===e.key:if(e.preventDefault(),null==v)x(D.startIndex);else if("all"===v)x(D.endIndex);else{const e=D.neighbors[v].rightIndex;null!==e&&x(e)}break;case"ArrowLeft"===e.key:if(e.preventDefault(),null==v)x(D.endIndex);else if("all"===v)x(D.startIndex);else{const e=D.neighbors[v].leftIndex;null!==e&&x(e)}break;case"Delete"===e.key:if(e.preventDefault(),o)break;null==v||"all"===v?w():k(),_();break;case["ArrowUp","ArrowDown","Home","End","PageUp","PageDown"].includes(e.key):{if(e.preventDefault(),o||null==b)break;const n=y.sections[b],r=h.getActiveDateManager(t,y,n),s=ox(t,E,n,e.key,C,N,r.date,{minutesStep:a});S({activeSection:n,newSectionValue:s,shouldGoToNextSection:!1});break}}}));Pk((()=>{F.syncSelectionToDOM()}));const P=Zk((0,_o.A)({},n,{value:y.value,timezone:E}),f,p.isSameError,p.defaultErrorState),L=T.useMemo((()=>void 0!==u?u:p.hasError(P)),[p,P,u]);T.useEffect((()=>{L||null!=b||_()}),[y.referenceValue,b,L]),T.useEffect((()=>{null!=y.tempValueStrAndroid&&null!=b&&(_(),k())}),[y.sections]),T.useImperativeHandle(r,(()=>({getSections:()=>y.sections,getActiveSectionIndex:F.getActiveSectionIndexFromDOM,setSelectedSections:F.setSelectedSections,focusField:F.focusField,isFieldFocused:F.isFieldFocused})));const z={onKeyDown:O,onClear:Lk((function(e){e.preventDefault();for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];d?.(e,...n),w(),F.isFieldFocused()?x(D.startIndex):F.focusField(0)})),error:L,clearable:Boolean(c&&!$&&!o&&!i)},B={disabled:i,readOnly:o};return(0,_o.A)({},e.forwardedProps,z,B,M)})({forwardedProps:n,internalProps:r,valueManager:vx,fieldValueManager:xx,validator:qx,valueType:"date"})},cI=["clearable","onClear","InputProps","sx","slots","slotProps"],dI=["ownerState"];function hI(e){return Dx("MuiPickersTextField",e)}Mx("MuiPickersTextField",["root","focused","disabled","error","required"]);function pI(e){return Dx("MuiPickersInputBase",e)}const fI=Mx("MuiPickersInputBase",["root","focused","disabled","error","notchedOutline","sectionContent","sectionBefore","sectionAfter","adornedStart","adornedEnd","input"]);function mI(e){return Dx("MuiPickersOutlinedInput",e)}const gI=(0,_o.A)({},fI,Mx("MuiPickersOutlinedInput",["root","notchedOutline","input"])),yI=["children","className","label","notched","shrink"],bI=(0,cr.Ay)("fieldset",{name:"MuiPickersOutlinedInput",slot:"NotchedOutline",overridesResolver:(e,t)=>t.notchedOutline})((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{textAlign:"left",position:"absolute",bottom:0,right:0,top:-5,left:0,margin:0,padding:"0 8px",pointerEvents:"none",borderRadius:"inherit",borderStyle:"solid",borderWidth:1,overflow:"hidden",minWidth:"0%",borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}})),vI=(0,cr.Ay)("span")((e=>{let{theme:t}=e;return{fontFamily:t.typography.fontFamily,fontSize:"inherit"}})),xI=(0,cr.Ay)("legend")((e=>{let{theme:t}=e;return{float:"unset",width:"auto",overflow:"hidden",variants:[{props:{withLabel:!1},style:{padding:0,lineHeight:"11px",transition:t.transitions.create("width",{duration:150,easing:t.transitions.easing.easeOut})}},{props:{withLabel:!0},style:{display:"block",padding:0,height:11,fontSize:"0.75em",visibility:"hidden",maxWidth:.01,transition:t.transitions.create("max-width",{duration:50,easing:t.transitions.easing.easeOut}),whiteSpace:"nowrap","& > span":{paddingLeft:5,paddingRight:5,display:"inline-block",opacity:0,visibility:"visible"}}},{props:{withLabel:!0,notched:!0},style:{maxWidth:"100%",transition:t.transitions.create("max-width",{duration:100,easing:t.transitions.easing.easeOut,delay:50})}}]}}));function wI(e){const{className:t,label:n}=e,r=$s(e,yI),a=null!=n&&""!==n,s=(0,_o.A)({},e,{withLabel:a});return(0,Zn.jsx)(bI,(0,_o.A)({"aria-hidden":!0,className:t},r,{ownerState:s,children:(0,Zn.jsx)(xI,{ownerState:s,children:a?(0,Zn.jsx)(vI,{children:n}):(0,Zn.jsx)(vI,{className:"notranslate",children:"\u200b"})})}))}function kI(e){if("string"!==typeof e)throw new Error(function(e){let t="https://mui.com/production-error/?code="+e;for(let n=1;n<arguments.length;n+=1)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified MUI error #"+e+"; visit "+t+" for the full message."}(7));return e.charAt(0).toUpperCase()+e.slice(1)}const SI={border:0,clip:"rect(0 0 0 0)",height:"1px",margin:"-1px",overflow:"hidden",padding:0,position:"absolute",whiteSpace:"nowrap",width:"1px"};function II(e){return Dx("MuiPickersSectionList",e)}const CI=Mx("MuiPickersSectionList",["root","section","sectionContent"]),NI=["slots","slotProps","elements","sectionListRef"],TI=(0,cr.Ay)("div",{name:"MuiPickersSectionList",slot:"Root",overridesResolver:(e,t)=>t.root})({direction:"ltr /*! @noflip */",outline:"none"}),EI=(0,cr.Ay)("span",{name:"MuiPickersSectionList",slot:"Section",overridesResolver:(e,t)=>t.section})({}),AI=(0,cr.Ay)("span",{name:"MuiPickersSectionList",slot:"SectionSeparator",overridesResolver:(e,t)=>t.sectionSeparator})({whiteSpace:"pre"}),_I=(0,cr.Ay)("span",{name:"MuiPickersSectionList",slot:"SectionContent",overridesResolver:(e,t)=>t.sectionContent})({outline:"none"});function $I(e){const{slots:t,slotProps:n,element:r,classes:a}=e,s=t?.section??EI,i=tw({elementType:s,externalSlotProps:n?.section,externalForwardedProps:r.container,className:a.section,ownerState:{}}),o=t?.sectionContent??_I,l=tw({elementType:o,externalSlotProps:n?.sectionContent,externalForwardedProps:r.content,additionalProps:{suppressContentEditableWarning:!0},className:a.sectionContent,ownerState:{}}),u=t?.sectionSeparator??AI,c=tw({elementType:u,externalSlotProps:n?.sectionSeparator,externalForwardedProps:r.before,ownerState:{position:"before"}}),d=tw({elementType:u,externalSlotProps:n?.sectionSeparator,externalForwardedProps:r.after,ownerState:{position:"after"}});return(0,Zn.jsxs)(s,(0,_o.A)({},i,{children:[(0,Zn.jsx)(u,(0,_o.A)({},c)),(0,Zn.jsx)(o,(0,_o.A)({},l)),(0,Zn.jsx)(u,(0,_o.A)({},d))]}))}const RI=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiPickersSectionList"}),{slots:r,slotProps:a,elements:s,sectionListRef:i}=n,o=$s(n,NI),l=(e=>{const{classes:t}=e;return Ex({root:["root"],section:["section"],sectionContent:["sectionContent"]},II,t)})(n),u=T.useRef(null),c=Kx(t,u),d=e=>{if(!u.current)throw new Error(`MUI X: Cannot call sectionListRef.${e} before the mount of the component.`);return u.current};T.useImperativeHandle(i,(()=>({getRoot:()=>d("getRoot"),getSectionContainer:e=>d("getSectionContainer").querySelector(`.${CI.section}[data-sectionindex="${e}"]`),getSectionContent:e=>d("getSectionContent").querySelector(`.${CI.section}[data-sectionindex="${e}"] .${CI.sectionContent}`),getSectionIndexFromDOMElement(e){const t=d("getSectionIndexFromDOMElement");if(null==e||!t.contains(e))return null;let n=null;return e.classList.contains(CI.section)?n=e:e.classList.contains(CI.sectionContent)&&(n=e.parentElement),null==n?null:Number(n.dataset.sectionindex)}})));const h=r?.root??TI,p=tw({elementType:h,externalSlotProps:a?.root,externalForwardedProps:o,additionalProps:{ref:c,suppressContentEditableWarning:!0},className:l.root,ownerState:{}});return(0,Zn.jsx)(h,(0,_o.A)({},p,{children:p.contentEditable?s.map((e=>{let{content:t,before:n,after:r}=e;return`${n.children}${t.children}${r.children}`})).join(""):(0,Zn.jsx)(T.Fragment,{children:s.map(((e,t)=>(0,Zn.jsx)($I,{slots:r,slotProps:a,element:e,classes:l},t)))})}))})),DI=["elements","areAllSectionsEmpty","defaultValue","label","value","onChange","id","autoFocus","endAdornment","startAdornment","renderSuffix","slots","slotProps","contentEditable","tabIndex","onInput","onPaste","onKeyDown","fullWidth","name","readOnly","inputProps","inputRef","sectionListRef"],MI=(0,cr.Ay)("div",{name:"MuiPickersInputBase",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;return(0,_o.A)({},t.typography.body1,{color:(t.vars||t).palette.text.primary,cursor:"text",padding:0,display:"flex",justifyContent:"flex-start",alignItems:"center",position:"relative",boxSizing:"border-box",letterSpacing:(n=.15/16,Math.round(1e5*n)/1e5)+"em",variants:[{props:{fullWidth:!0},style:{width:"100%"}}]});var n})),FI=(0,cr.Ay)(TI,{name:"MuiPickersInputBase",slot:"SectionsContainer",overridesResolver:(e,t)=>t.sectionsContainer})((e=>{let{theme:t}=e;return{padding:"4px 0 5px",fontFamily:t.typography.fontFamily,fontSize:"inherit",lineHeight:"1.4375em",flexGrow:1,outline:"none",display:"flex",flexWrap:"nowrap",overflow:"hidden",letterSpacing:"inherit",width:"182px",variants:[{props:{isRtl:!0},style:{textAlign:"right /*! @noflip */"}},{props:{size:"small"},style:{paddingTop:1}},{props:{adornedStart:!1,focused:!1,filled:!1},style:{color:"currentColor",opacity:0}},{props:e=>{let{adornedStart:t,focused:n,filled:r,label:a}=e;return!t&&!n&&!r&&null==a},style:t.vars?{opacity:t.vars.opacity.inputPlaceholder}:{opacity:"light"===t.palette.mode?.42:.5}}]}})),OI=(0,cr.Ay)(EI,{name:"MuiPickersInputBase",slot:"Section",overridesResolver:(e,t)=>t.section})((e=>{let{theme:t}=e;return{fontFamily:t.typography.fontFamily,fontSize:"inherit",letterSpacing:"inherit",lineHeight:"1.4375em",display:"flex"}})),PI=(0,cr.Ay)(_I,{name:"MuiPickersInputBase",slot:"SectionContent",overridesResolver:(e,t)=>t.content})((e=>{let{theme:t}=e;return{fontFamily:t.typography.fontFamily,lineHeight:"1.4375em",letterSpacing:"inherit",width:"fit-content",outline:"none"}})),LI=(0,cr.Ay)(AI,{name:"MuiPickersInputBase",slot:"Separator",overridesResolver:(e,t)=>t.separator})((()=>({whiteSpace:"pre",letterSpacing:"inherit"}))),zI=(0,cr.Ay)("input",{name:"MuiPickersInputBase",slot:"Input",overridesResolver:(e,t)=>t.hiddenInput})((0,_o.A)({},SI)),BI=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiPickersInputBase"}),{elements:r,areAllSectionsEmpty:a,value:s,onChange:i,id:o,endAdornment:l,startAdornment:u,renderSuffix:c,slots:d,slotProps:h,contentEditable:p,tabIndex:f,onInput:m,onPaste:g,onKeyDown:y,name:b,readOnly:v,inputProps:x,inputRef:w,sectionListRef:k}=n,S=$s(n,DI),I=Kx(t,T.useRef(null)),C=Kx(x?.ref,w),N=rs(),E=Qr();if(!E)throw new Error("MUI X: PickersInputBase should always be used inside a PickersTextField component");T.useEffect((()=>{E&&E.setAdornedStart(Boolean(u))}),[E,u]),T.useEffect((()=>{E&&(a?E.onEmpty():E.onFilled())}),[E,a]);const A=(0,_o.A)({},n,E,{isRtl:N}),_=(e=>{const{focused:t,disabled:n,error:r,classes:a,fullWidth:s,readOnly:i,color:o,size:l,endAdornment:u,startAdornment:c}=e;return Ex({root:["root",t&&!n&&"focused",n&&"disabled",i&&"readOnly",r&&"error",s&&"fullWidth",`color${kI(o)}`,"small"===l&&"inputSizeSmall",Boolean(c)&&"adornedStart",Boolean(u)&&"adornedEnd"],notchedOutline:["notchedOutline"],input:["input"],sectionsContainer:["sectionsContainer"],sectionContent:["sectionContent"],sectionBefore:["sectionBefore"],sectionAfter:["sectionAfter"]},pI,a)})(A),$=d?.root||MI,R=tw({elementType:$,externalSlotProps:h?.root,externalForwardedProps:S,additionalProps:{"aria-invalid":E.error,ref:I},className:_.root,ownerState:A}),D=d?.input||FI;return(0,Zn.jsxs)($,(0,_o.A)({},R,{children:[u,(0,Zn.jsx)(RI,{sectionListRef:k,elements:r,contentEditable:p,tabIndex:f,className:_.sectionsContainer,onFocus:e=>{E.disabled?e.stopPropagation():E.onFocus?.(e)},onBlur:E.onBlur,onInput:m,onPaste:g,onKeyDown:y,slots:{root:D,section:OI,sectionContent:PI,sectionSeparator:LI},slotProps:{root:{ownerState:A},sectionContent:{className:fI.sectionContent},sectionSeparator:e=>{let{position:t}=e;return{className:"before"===t?fI.sectionBefore:fI.sectionAfter}}}}),l,c?c((0,_o.A)({},E)):null,(0,Zn.jsx)(zI,(0,_o.A)({name:b,className:_.input,value:s,onChange:i,id:o,"aria-hidden":"true",tabIndex:-1,readOnly:v,required:E.required,disabled:E.disabled},x,{ref:C}))]}))})),WI=["label","autoFocus","ownerState","notched"],VI=(0,cr.Ay)(MI,{name:"MuiPickersOutlinedInput",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{padding:"0 14px",borderRadius:(t.vars||t).shape.borderRadius,[`&:hover .${gI.notchedOutline}`]:{borderColor:(t.vars||t).palette.text.primary},"@media (hover: none)":{[`&:hover .${gI.notchedOutline}`]:{borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}},[`&.${gI.focused} .${gI.notchedOutline}`]:{borderStyle:"solid",borderWidth:2},[`&.${gI.disabled}`]:{[`& .${gI.notchedOutline}`]:{borderColor:(t.vars||t).palette.action.disabled},"*":{color:(t.vars||t).palette.action.disabled}},[`&.${gI.error} .${gI.notchedOutline}`]:{borderColor:(t.vars||t).palette.error.main},variants:Object.keys((t.vars??t).palette).filter((e=>(t.vars??t).palette[e]?.main??!1)).map((e=>({props:{color:e},style:{[`&.${gI.focused}:not(.${gI.error}) .${gI.notchedOutline}`]:{borderColor:(t.vars||t).palette[e].main}}})))}})),UI=(0,cr.Ay)(FI,{name:"MuiPickersOutlinedInput",slot:"SectionsContainer",overridesResolver:(e,t)=>t.sectionsContainer})({padding:"16.5px 0",variants:[{props:{size:"small"},style:{padding:"8.5px 0"}}]}),jI=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiPickersOutlinedInput"}),{label:r,ownerState:a,notched:s}=n,i=$s(n,WI),o=Qr(),l=(0,_o.A)({},n,a,o,{color:o?.color||"primary"}),u=(e=>{const{classes:t}=e,n=Ex({root:["root"],notchedOutline:["notchedOutline"],input:["input"]},mI,t);return(0,_o.A)({},t,n)})(l);return(0,Zn.jsx)(BI,(0,_o.A)({slots:{root:VI,input:UI},renderSuffix:e=>(0,Zn.jsx)(wI,{shrink:Boolean(s||e.adornedStart||e.focused||e.filled),notched:Boolean(s||e.adornedStart||e.focused||e.filled),className:u.notchedOutline,label:null!=r&&""!==r&&o?.required?(0,Zn.jsxs)(T.Fragment,{children:[r,"\u2009","*"]}):r,ownerState:l})},i,{label:r,classes:u,ref:t}))}));function GI(e){return Dx("MuiPickersFilledInput",e)}jI.muiName="Input";const HI=(0,_o.A)({},fI,Mx("MuiPickersFilledInput",["root","underline","input"])),qI=["label","autoFocus","disableUnderline","ownerState"],KI=(0,cr.Ay)(MI,{name:"MuiPickersFilledInput",slot:"Root",overridesResolver:(e,t)=>t.root,shouldForwardProp:e=>(0,Fl.MC)(e)&&"disableUnderline"!==e})((e=>{let{theme:t}=e;const n="light"===t.palette.mode,r=n?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)",a=n?"rgba(0, 0, 0, 0.06)":"rgba(255, 255, 255, 0.09)",s=n?"rgba(0, 0, 0, 0.09)":"rgba(255, 255, 255, 0.13)",i=n?"rgba(0, 0, 0, 0.12)":"rgba(255, 255, 255, 0.12)";return{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a,borderTopLeftRadius:(t.vars||t).shape.borderRadius,borderTopRightRadius:(t.vars||t).shape.borderRadius,transition:t.transitions.create("background-color",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),"&:hover":{backgroundColor:t.vars?t.vars.palette.FilledInput.hoverBg:s,"@media (hover: none)":{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a}},[`&.${HI.focused}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a},[`&.${HI.disabled}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.disabledBg:i},variants:[...Object.keys((t.vars??t).palette).filter((e=>(t.vars??t).palette[e].main)).map((e=>({props:{color:e,disableUnderline:!1},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[e]?.main}`}}}))),{props:{disableUnderline:!1},style:{"&::after":{left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${HI.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${HI.error}`]:{"&:before, &:after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`:r}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${HI.disabled}, .${HI.error}):before`]:{borderBottom:`1px solid ${(t.vars||t).palette.text.primary}`},[`&.${HI.disabled}:before`]:{borderBottomStyle:"dotted"}}},{props:e=>{let{startAdornment:t}=e;return!!t},style:{paddingLeft:12}},{props:e=>{let{endAdornment:t}=e;return!!t},style:{paddingRight:12}}]}})),XI=(0,cr.Ay)(FI,{name:"MuiPickersFilledInput",slot:"sectionsContainer",overridesResolver:(e,t)=>t.sectionsContainer})({paddingTop:25,paddingRight:12,paddingBottom:8,paddingLeft:12,variants:[{props:{size:"small"},style:{paddingTop:21,paddingBottom:4}},{props:e=>{let{startAdornment:t}=e;return!!t},style:{paddingLeft:0}},{props:e=>{let{endAdornment:t}=e;return!!t},style:{paddingRight:0}},{props:{hiddenLabel:!0},style:{paddingTop:16,paddingBottom:17}},{props:{hiddenLabel:!0,size:"small"},style:{paddingTop:8,paddingBottom:9}}]}),YI=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiPickersFilledInput"}),{label:r,disableUnderline:a=!1,ownerState:s}=n,i=$s(n,qI),o=Qr(),l=(e=>{const{classes:t,disableUnderline:n}=e,r=Ex({root:["root",!n&&"underline"],input:["input"]},GI,t);return(0,_o.A)({},t,r)})((0,_o.A)({},n,s,o,{color:o?.color||"primary"}));return(0,Zn.jsx)(BI,(0,_o.A)({slots:{root:KI,input:XI},slotProps:{root:{disableUnderline:a}}},i,{label:r,classes:l,ref:t}))}));function QI(e){return Dx("MuiPickersFilledInput",e)}YI.muiName="Input";const JI=(0,_o.A)({},fI,Mx("MuiPickersInput",["root","input"])),ZI=["label","autoFocus","disableUnderline","ownerState"],eC=(0,cr.Ay)(MI,{name:"MuiPickersInput",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;let n="light"===t.palette.mode?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)";return t.vars&&(n=`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`),{"label + &":{marginTop:16},variants:[...Object.keys((t.vars??t).palette).filter((e=>(t.vars??t).palette[e].main)).map((e=>({props:{color:e},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[e].main}`}}}))),{props:{disableUnderline:!1},style:{"&::after":{background:"red",left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${JI.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${JI.error}`]:{"&:before, &:after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${n}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${JI.disabled}, .${JI.error}):before`]:{borderBottom:`2px solid ${(t.vars||t).palette.text.primary}`,"@media (hover: none)":{borderBottom:`1px solid ${n}`}},[`&.${JI.disabled}:before`]:{borderBottomStyle:"dotted"}}}]}})),tC=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiPickersInput"}),{label:r,disableUnderline:a=!1,ownerState:s}=n,i=$s(n,ZI),o=Qr(),l=(e=>{const{classes:t,disableUnderline:n}=e,r=Ex({root:["root",!n&&"underline"],input:["input"]},QI,t);return(0,_o.A)({},t,r)})((0,_o.A)({},n,s,o,{disableUnderline:a,color:o?.color||"primary"}));return(0,Zn.jsx)(BI,(0,_o.A)({slots:{root:eC}},i,{label:r,classes:l,ref:t}))}));tC.muiName="Input";const nC=["onFocus","onBlur","className","color","disabled","error","variant","required","InputProps","inputProps","inputRef","sectionListRef","elements","areAllSectionsEmpty","onClick","onKeyDown","onKeyUp","onPaste","onInput","endAdornment","startAdornment","tabIndex","contentEditable","focused","value","onChange","fullWidth","id","name","helperText","FormHelperTextProps","label","InputLabelProps"],rC={standard:tC,filled:YI,outlined:jI},aC=(0,cr.Ay)(Ka,{name:"MuiPickersTextField",slot:"Root",overridesResolver:(e,t)=>t.root})({}),sC=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiPickersTextField"}),{onFocus:r,onBlur:a,className:s,color:i="primary",disabled:o=!1,error:l=!1,variant:u="outlined",required:c=!1,InputProps:d,inputProps:h,inputRef:p,sectionListRef:f,elements:m,areAllSectionsEmpty:g,onClick:y,onKeyDown:b,onKeyUp:v,onPaste:x,onInput:w,endAdornment:k,startAdornment:S,tabIndex:I,contentEditable:C,focused:N,value:E,onChange:A,fullWidth:_,id:$,name:R,helperText:D,FormHelperTextProps:M,label:F,InputLabelProps:O}=n,P=$s(n,nC),L=Kx(t,T.useRef(null)),z=cw($),B=D&&z?`${z}-helper-text`:void 0,W=F&&z?`${z}-label`:void 0,V=(0,_o.A)({},n,{color:i,disabled:o,error:l,focused:N,required:c,variant:u}),U=(e=>{const{focused:t,disabled:n,classes:r,required:a}=e;return Ex({root:["root",t&&!n&&"focused",n&&"disabled",a&&"required"]},hI,r)})(V),j=rC[u];return(0,Zn.jsxs)(aC,(0,_o.A)({className:(0,Wn.A)(U.root,s),ref:L,focused:N,onFocus:r,onBlur:a,disabled:o,variant:u,error:l,color:i,fullWidth:_,required:c,ownerState:V},P,{children:[(0,Zn.jsx)(Ua,(0,_o.A)({htmlFor:z,id:W},O,{children:F})),(0,Zn.jsx)(j,(0,_o.A)({elements:m,areAllSectionsEmpty:g,onClick:y,onKeyDown:b,onKeyUp:v,onInput:w,onPaste:x,endAdornment:k,startAdornment:S,tabIndex:I,contentEditable:C,value:E,onChange:A,id:z,fullWidth:_,inputProps:h,inputRef:p,sectionListRef:f,label:F,name:R,role:"group","aria-labelledby":W},d)),D&&(0,Zn.jsx)(Za,(0,_o.A)({id:B},M,{children:D}))]}))})),iC=["enableAccessibleFieldDOMStructure"],oC=["InputProps","readOnly"],lC=["onPaste","onKeyDown","inputMode","readOnly","InputProps","inputProps","inputRef"],uC=["slots","slotProps","InputProps","inputProps"],cC=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiDateField"}),{slots:r,slotProps:a,InputProps:s,inputProps:i}=n,o=$s(n,uC),l=n,u=r?.textField??(e.enableAccessibleFieldDOMStructure?sC:No),c=tw({elementType:u,externalSlotProps:a?.textField,externalForwardedProps:o,additionalProps:{ref:t},ownerState:l});c.inputProps=(0,_o.A)({},i,c.inputProps),c.InputProps=(0,_o.A)({},s,c.InputProps);const d=(e=>{let{enableAccessibleFieldDOMStructure:t}=e,n=$s(e,iC);if(t){const{InputProps:e,readOnly:t}=n,r=$s(n,oC);return(0,_o.A)({},r,{InputProps:(0,_o.A)({},e??{},{readOnly:t})})}const{onPaste:r,onKeyDown:a,inputMode:s,readOnly:i,InputProps:o,inputProps:l,inputRef:u}=n,c=$s(n,lC);return(0,_o.A)({},c,{InputProps:(0,_o.A)({},o??{},{readOnly:i}),inputProps:(0,_o.A)({},l??{},{inputMode:s,onPaste:r,onKeyDown:a,ref:u})})})(uI(c)),h=(e=>{const t=Bx(),{clearable:n,onClear:r,InputProps:a,sx:s,slots:i,slotProps:o}=e,l=$s(e,cI),u=i?.clearButton??dl,c=$s(tw({elementType:u,externalSlotProps:o?.clearButton,ownerState:{},className:"clearButton",additionalProps:{title:t.fieldClearLabel}}),dI),d=i?.clearIcon??qS,h=tw({elementType:d,externalSlotProps:o?.clearIcon,ownerState:{}});return(0,_o.A)({},l,{InputProps:(0,_o.A)({},a,{endAdornment:(0,Zn.jsxs)(T.Fragment,{children:[n&&(0,Zn.jsx)(ow,{position:"end",sx:{marginRight:a?.endAdornment?-1:-1.5},children:(0,Zn.jsx)(u,(0,_o.A)({},c,{onClick:r,children:(0,Zn.jsx)(d,(0,_o.A)({fontSize:"small"},h))}))}),a?.endAdornment]})}),sx:[{"& .clearButton":{opacity:1},"@media (pointer: fine)":{"& .clearButton":{opacity:0},"&:hover, &:focus-within":{".clearButton":{opacity:1}}}},...Array.isArray(s)?s:[s]]})})((0,_o.A)({},d,{slots:r,slotProps:a}));return(0,Zn.jsx)(u,(0,_o.A)({},h))})),dC=e=>{let{shouldDisableDate:t,shouldDisableMonth:n,shouldDisableYear:r,minDate:a,maxDate:s,disableFuture:i,disablePast:o,timezone:l}=e;const u=Ix();return T.useCallback((e=>null!==qx({adapter:u,value:e,props:{shouldDisableDate:t,shouldDisableMonth:n,shouldDisableYear:r,minDate:a,maxDate:s,disableFuture:i,disablePast:o,timezone:l}})),[u,t,n,r,a,s,i,o,l])},hC=e=>{const{value:t,referenceDate:n,disableFuture:r,disablePast:a,disableSwitchToMonthOnDayFocus:s=!1,maxDate:i,minDate:o,onMonthChange:l,reduceAnimations:u,shouldDisableDate:c,timezone:d}=e,h=Cx(),p=T.useRef(((e,t,n)=>(r,a)=>{switch(a.type){case"changeMonth":return(0,_o.A)({},r,{slideDirection:a.direction,currentMonth:a.newMonth,isMonthSwitchingAnimating:!e});case"finishMonthSwitchingAnimation":return(0,_o.A)({},r,{isMonthSwitchingAnimating:!1});case"changeFocusedDay":{if(null!=r.focusedDay&&null!=a.focusedDay&&n.isSameDay(a.focusedDay,r.focusedDay))return r;const s=null!=a.focusedDay&&!t&&!n.isSameMonth(r.currentMonth,a.focusedDay);return(0,_o.A)({},r,{focusedDay:a.focusedDay,isMonthSwitchingAnimating:s&&!e&&!a.withoutMonthSwitchingAnimation,currentMonth:s?n.startOfMonth(a.focusedDay):r.currentMonth,slideDirection:null!=a.focusedDay&&n.isAfterDay(a.focusedDay,r.currentMonth)?"left":"right"})}default:throw new Error("missing support")}})(Boolean(u),s,h)).current,f=T.useMemo((()=>vx.getInitialReferenceValue({value:t,utils:h,timezone:d,props:e,referenceDate:n,granularity:Xv.day})),[]),[m,g]=T.useReducer(p,{isMonthSwitchingAnimating:!1,focusedDay:f,currentMonth:h.startOfMonth(f),slideDirection:"left"}),y=T.useCallback((e=>{g((0,_o.A)({type:"changeMonth"},e)),l&&l(e.newMonth)}),[l]),b=T.useCallback((e=>{const t=e;h.isSameMonth(t,m.currentMonth)||y({newMonth:h.startOfMonth(t),direction:h.isAfterDay(t,m.currentMonth)?"left":"right"})}),[m.currentMonth,y,h]),v=dC({shouldDisableDate:c,minDate:o,maxDate:i,disableFuture:r,disablePast:a,timezone:d}),x=T.useCallback((()=>{g({type:"finishMonthSwitchingAnimation"})}),[]),w=Lk(((e,t)=>{v(e)||g({type:"changeFocusedDay",focusedDay:e,withoutMonthSwitchingAnimation:t})}));return{referenceDate:f,calendarState:m,changeMonth:b,changeFocusedDay:w,isDateDisabled:v,onMonthSwitchingAnimationEnd:x,handleChangeMonth:y}},pC=e=>Dx("MuiPickersFadeTransitionGroup",e),fC=(Mx("MuiPickersFadeTransitionGroup",["root"]),(0,cr.Ay)(Oo,{name:"MuiPickersFadeTransitionGroup",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"block",position:"relative"}));function mC(e){const t=mo({props:e,name:"MuiPickersFadeTransitionGroup"}),{children:n,className:r,reduceAnimations:a,transKey:s}=t,i=(e=>{const{classes:t}=e;return Ex({root:["root"]},pC,t)})(t),o=hr();return a?n:(0,Zn.jsx)(fC,{className:(0,Wn.A)(i.root,r),children:(0,Zn.jsx)(li,{appear:!1,mountOnEnter:!0,unmountOnExit:!0,timeout:{appear:o.transitions.duration.enteringScreen,enter:o.transitions.duration.enteringScreen,exit:0},children:n},s)})}function gC(e){return Dx("MuiPickersDay",e)}const yC=Mx("MuiPickersDay",["root","dayWithMargin","dayOutsideMonth","hiddenDaySpacingFiller","today","selected","disabled"]),bC=["autoFocus","className","day","disabled","disableHighlightToday","disableMargin","hidden","isAnimating","onClick","onDaySelect","onFocus","onBlur","onKeyDown","onMouseDown","onMouseEnter","outsideCurrentMonth","selected","showDaysOutsideCurrentMonth","children","today","isFirstVisibleCell","isLastVisibleCell"],vC=e=>{let{theme:t}=e;return(0,_o.A)({},t.typography.caption,{width:36,height:36,borderRadius:"50%",padding:0,backgroundColor:"transparent",transition:t.transitions.create("background-color",{duration:t.transitions.duration.short}),color:(t.vars||t).palette.text.primary,"@media (pointer: fine)":{"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,ur.X4)(t.palette.primary.main,t.palette.action.hoverOpacity)}},"&:focus":{backgroundColor:t.vars?`rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.focusOpacity})`:(0,ur.X4)(t.palette.primary.main,t.palette.action.focusOpacity),[`&.${yC.selected}`]:{willChange:"background-color",backgroundColor:(t.vars||t).palette.primary.dark}},[`&.${yC.selected}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.main,fontWeight:t.typography.fontWeightMedium,"&:hover":{willChange:"background-color",backgroundColor:(t.vars||t).palette.primary.dark}},[`&.${yC.disabled}:not(.${yC.selected})`]:{color:(t.vars||t).palette.text.disabled},[`&.${yC.disabled}&.${yC.selected}`]:{opacity:.6},variants:[{props:{disableMargin:!1},style:{margin:"0 2px"}},{props:{outsideCurrentMonth:!0,showDaysOutsideCurrentMonth:!0},style:{color:(t.vars||t).palette.text.secondary}},{props:{disableHighlightToday:!1,today:!0},style:{[`&:not(.${yC.selected})`]:{border:`1px solid ${(t.vars||t).palette.text.secondary}`}}}]})},xC=(e,t)=>{const{ownerState:n}=e;return[t.root,!n.disableMargin&&t.dayWithMargin,!n.disableHighlightToday&&n.today&&t.today,!n.outsideCurrentMonth&&n.showDaysOutsideCurrentMonth&&t.dayOutsideMonth,n.outsideCurrentMonth&&!n.showDaysOutsideCurrentMonth&&t.hiddenDaySpacingFiller]},wC=(0,cr.Ay)(Xo,{name:"MuiPickersDay",slot:"Root",overridesResolver:xC})(vC),kC=(0,cr.Ay)("div",{name:"MuiPickersDay",slot:"Root",overridesResolver:xC})((e=>{let{theme:t}=e;return(0,_o.A)({},vC({theme:t}),{opacity:0,pointerEvents:"none"})})),SC=()=>{},IC=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiPickersDay"}),{autoFocus:r=!1,className:a,day:s,disabled:i=!1,disableHighlightToday:o=!1,disableMargin:l=!1,isAnimating:u,onClick:c,onDaySelect:d,onFocus:h=SC,onBlur:p=SC,onKeyDown:f=SC,onMouseDown:m=SC,onMouseEnter:g=SC,outsideCurrentMonth:y,selected:b=!1,showDaysOutsideCurrentMonth:v=!1,children:x,today:w=!1}=n,k=$s(n,bC),S=(0,_o.A)({},n,{autoFocus:r,disabled:i,disableHighlightToday:o,disableMargin:l,selected:b,showDaysOutsideCurrentMonth:v,today:w}),I=(e=>{const{selected:t,disableMargin:n,disableHighlightToday:r,today:a,disabled:s,outsideCurrentMonth:i,showDaysOutsideCurrentMonth:o,classes:l}=e,u=i&&!o;return Ex({root:["root",t&&!u&&"selected",s&&"disabled",!n&&"dayWithMargin",!r&&a&&"today",i&&o&&"dayOutsideMonth",u&&"hiddenDaySpacingFiller"],hiddenDaySpacingFiller:["hiddenDaySpacingFiller"]},gC,l)})(S),C=Cx(),N=T.useRef(null),E=Kx(N,t);Pk((()=>{!r||i||u||y||N.current.focus()}),[r,i,u,y]);return y&&!v?(0,Zn.jsx)(kC,{className:(0,Wn.A)(I.root,I.hiddenDaySpacingFiller,a),ownerState:S,role:k.role}):(0,Zn.jsx)(wC,(0,_o.A)({className:(0,Wn.A)(I.root,a),ref:E,centerRipple:!0,disabled:i,tabIndex:b?0:-1,onKeyDown:e=>f(e,s),onFocus:e=>h(e,s),onBlur:e=>p(e,s),onMouseEnter:e=>g(e,s),onClick:e=>{i||d(s),y&&e.currentTarget.focus(),c&&c(e)},onMouseDown:e=>{m(e),y&&e.preventDefault()}},k,{ownerState:S,children:x||C.format(s,"dayOfMonth")}))})),CC=T.memo(IC);function NC(e,t){return e.replace(new RegExp("(^|\\s)"+t+"(?:\\s|$)","g"),"$1").replace(/\s+/g," ").replace(/^\s*|\s*$/g,"")}var TC=function(e,t){return e&&t&&t.split(" ").forEach((function(t){return r=t,void((n=e).classList?n.classList.remove(r):"string"===typeof n.className?n.className=NC(n.className,r):n.setAttribute("class",NC(n.className&&n.className.baseVal||"",r)));var n,r}))},EC=function(e){function t(){for(var t,n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];return(t=e.call.apply(e,[this].concat(r))||this).appliedClasses={appear:{},enter:{},exit:{}},t.onEnter=function(e,n){var r=t.resolveArguments(e,n),a=r[0],s=r[1];t.removeClasses(a,"exit"),t.addClass(a,s?"appear":"enter","base"),t.props.onEnter&&t.props.onEnter(e,n)},t.onEntering=function(e,n){var r=t.resolveArguments(e,n),a=r[0],s=r[1]?"appear":"enter";t.addClass(a,s,"active"),t.props.onEntering&&t.props.onEntering(e,n)},t.onEntered=function(e,n){var r=t.resolveArguments(e,n),a=r[0],s=r[1]?"appear":"enter";t.removeClasses(a,s),t.addClass(a,s,"done"),t.props.onEntered&&t.props.onEntered(e,n)},t.onExit=function(e){var n=t.resolveArguments(e)[0];t.removeClasses(n,"appear"),t.removeClasses(n,"enter"),t.addClass(n,"exit","base"),t.props.onExit&&t.props.onExit(e)},t.onExiting=function(e){var n=t.resolveArguments(e)[0];t.addClass(n,"exit","active"),t.props.onExiting&&t.props.onExiting(e)},t.onExited=function(e){var n=t.resolveArguments(e)[0];t.removeClasses(n,"exit"),t.addClass(n,"exit","done"),t.props.onExited&&t.props.onExited(e)},t.resolveArguments=function(e,n){return t.props.nodeRef?[t.props.nodeRef.current,e]:[e,n]},t.getClassNames=function(e){var n=t.props.classNames,r="string"===typeof n,a=r?""+(r&&n?n+"-":"")+e:n[e];return{baseClassName:a,activeClassName:r?a+"-active":n[e+"Active"],doneClassName:r?a+"-done":n[e+"Done"]}},t}Ds(t,e);var n=t.prototype;return n.addClass=function(e,t,n){var r=this.getClassNames(t)[n+"ClassName"],a=this.getClassNames("enter").doneClassName;"appear"===t&&"done"===n&&a&&(r+=" "+a),"active"===n&&e&&Os(e),r&&(this.appliedClasses[t][n]=r,function(e,t){e&&t&&t.split(" ").forEach((function(t){return r=t,void((n=e).classList?n.classList.add(r):function(e,t){return e.classList?!!t&&e.classList.contains(t):-1!==(" "+(e.className.baseVal||e.className)+" ").indexOf(" "+t+" ")}(n,r)||("string"===typeof n.className?n.className=n.className+" "+r:n.setAttribute("class",(n.className&&n.className.baseVal||"")+" "+r)));var n,r}))}(e,r))},n.removeClasses=function(e,t){var n=this.appliedClasses[t],r=n.base,a=n.active,s=n.done;this.appliedClasses[t]={},r&&TC(e,r),a&&TC(e,a),s&&TC(e,s)},n.render=function(){var e=this.props,t=(e.classNames,$s(e,["classNames"]));return T.createElement(js,(0,_o.A)({},t,{onEnter:this.onEnter,onEntered:this.onEntered,onEntering:this.onEntering,onExit:this.onExit,onExiting:this.onExiting,onExited:this.onExited}))},t}(T.Component);EC.defaultProps={classNames:""},EC.propTypes={};const AC=EC,_C=e=>Dx("MuiPickersSlideTransition",e),$C=Mx("MuiPickersSlideTransition",["root","slideEnter-left","slideEnter-right","slideEnterActive","slideExit","slideExitActiveLeft-left","slideExitActiveLeft-right"]),RC=["children","className","reduceAnimations","slideDirection","transKey","classes"],DC=(0,cr.Ay)(Oo,{name:"MuiPickersSlideTransition",slot:"Root",overridesResolver:(e,t)=>[t.root,{[`.${$C["slideEnter-left"]}`]:t["slideEnter-left"]},{[`.${$C["slideEnter-right"]}`]:t["slideEnter-right"]},{[`.${$C.slideEnterActive}`]:t.slideEnterActive},{[`.${$C.slideExit}`]:t.slideExit},{[`.${$C["slideExitActiveLeft-left"]}`]:t["slideExitActiveLeft-left"]},{[`.${$C["slideExitActiveLeft-right"]}`]:t["slideExitActiveLeft-right"]}]})((e=>{let{theme:t}=e;const n=t.transitions.create("transform",{duration:t.transitions.duration.complex,easing:"cubic-bezier(0.35, 0.8, 0.4, 1)"});return{display:"block",position:"relative",overflowX:"hidden","& > *":{position:"absolute",top:0,right:0,left:0},[`& .${$C["slideEnter-left"]}`]:{willChange:"transform",transform:"translate(100%)",zIndex:1},[`& .${$C["slideEnter-right"]}`]:{willChange:"transform",transform:"translate(-100%)",zIndex:1},[`& .${$C.slideEnterActive}`]:{transform:"translate(0%)",transition:n},[`& .${$C.slideExit}`]:{transform:"translate(0%)"},[`& .${$C["slideExitActiveLeft-left"]}`]:{willChange:"transform",transform:"translate(-100%)",transition:n,zIndex:0},[`& .${$C["slideExitActiveLeft-right"]}`]:{willChange:"transform",transform:"translate(100%)",transition:n,zIndex:0}}}));const MC=e=>Dx("MuiDayCalendar",e),FC=(Mx("MuiDayCalendar",["root","header","weekDayLabel","loadingContainer","slideTransition","monthContainer","weekContainer","weekNumberLabel","weekNumber"]),["parentProps","day","focusableDay","selectedDays","isDateDisabled","currentMonthNumber","isViewFocused"]),OC=["ownerState"],PC=(0,cr.Ay)("div",{name:"MuiDayCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({}),LC=(0,cr.Ay)("div",{name:"MuiDayCalendar",slot:"Header",overridesResolver:(e,t)=>t.header})({display:"flex",justifyContent:"center",alignItems:"center"}),zC=(0,cr.Ay)(Pr,{name:"MuiDayCalendar",slot:"WeekDayLabel",overridesResolver:(e,t)=>t.weekDayLabel})((e=>{let{theme:t}=e;return{width:36,height:40,margin:"0 2px",textAlign:"center",display:"flex",justifyContent:"center",alignItems:"center",color:(t.vars||t).palette.text.secondary}})),BC=(0,cr.Ay)(Pr,{name:"MuiDayCalendar",slot:"WeekNumberLabel",overridesResolver:(e,t)=>t.weekNumberLabel})((e=>{let{theme:t}=e;return{width:36,height:40,margin:"0 2px",textAlign:"center",display:"flex",justifyContent:"center",alignItems:"center",color:t.palette.text.disabled}})),WC=(0,cr.Ay)(Pr,{name:"MuiDayCalendar",slot:"WeekNumber",overridesResolver:(e,t)=>t.weekNumber})((e=>{let{theme:t}=e;return(0,_o.A)({},t.typography.caption,{width:36,height:36,padding:0,margin:"0 2px",color:t.palette.text.disabled,fontSize:"0.75rem",alignItems:"center",justifyContent:"center",display:"inline-flex"})})),VC=(0,cr.Ay)("div",{name:"MuiDayCalendar",slot:"LoadingContainer",overridesResolver:(e,t)=>t.loadingContainer})({display:"flex",justifyContent:"center",alignItems:"center",minHeight:240}),UC=(0,cr.Ay)((function(e){const t=mo({props:e,name:"MuiPickersSlideTransition"}),{children:n,className:r,reduceAnimations:a,transKey:s}=t,i=$s(t,RC),o=(e=>{const{classes:t,slideDirection:n}=e;return Ex({root:["root"],exit:["slideExit"],enterActive:["slideEnterActive"],enter:[`slideEnter-${n}`],exitActive:[`slideExitActiveLeft-${n}`]},_C,t)})(t),l=hr();if(a)return(0,Zn.jsx)("div",{className:(0,Wn.A)(o.root,r),children:n});const u={exit:o.exit,enterActive:o.enterActive,enter:o.enter,exitActive:o.exitActive};return(0,Zn.jsx)(DC,{className:(0,Wn.A)(o.root,r),childFactory:e=>T.cloneElement(e,{classNames:u}),role:"presentation",children:(0,Zn.jsx)(AC,(0,_o.A)({mountOnEnter:!0,unmountOnExit:!0,timeout:l.transitions.duration.complex,classNames:u},i,{children:n}),s)})}),{name:"MuiDayCalendar",slot:"SlideTransition",overridesResolver:(e,t)=>t.slideTransition})({minHeight:240}),jC=(0,cr.Ay)("div",{name:"MuiDayCalendar",slot:"MonthContainer",overridesResolver:(e,t)=>t.monthContainer})({overflow:"hidden"}),GC=(0,cr.Ay)("div",{name:"MuiDayCalendar",slot:"WeekContainer",overridesResolver:(e,t)=>t.weekContainer})({margin:"2px 0",display:"flex",justifyContent:"center"});function HC(e){let{parentProps:t,day:n,focusableDay:r,selectedDays:a,isDateDisabled:s,currentMonthNumber:i,isViewFocused:o}=e,l=$s(e,FC);const{disabled:u,disableHighlightToday:c,isMonthSwitchingAnimating:d,showDaysOutsideCurrentMonth:h,slots:p,slotProps:f,timezone:m}=t,g=Cx(),y=Tx(m),b=null!==r&&g.isSameDay(n,r),v=a.some((e=>g.isSameDay(e,n))),x=g.isSameDay(n,y),w=p?.day??CC,k=$s(tw({elementType:w,externalSlotProps:f?.day,additionalProps:(0,_o.A)({disableHighlightToday:c,showDaysOutsideCurrentMonth:h,role:"gridcell",isAnimating:d,"data-timestamp":g.toJsDate(n).valueOf()},l),ownerState:(0,_o.A)({},t,{day:n,selected:v})}),OC),S=T.useMemo((()=>u||s(n)),[u,s,n]),I=T.useMemo((()=>g.getMonth(n)!==i),[g,n,i]),C=T.useMemo((()=>{const e=g.startOfMonth(g.setMonth(n,i));return h?g.isSameDay(n,g.startOfWeek(e)):g.isSameDay(n,e)}),[i,n,h,g]),N=T.useMemo((()=>{const e=g.endOfMonth(g.setMonth(n,i));return h?g.isSameDay(n,g.endOfWeek(e)):g.isSameDay(n,e)}),[i,n,h,g]);return(0,Zn.jsx)(w,(0,_o.A)({},k,{day:n,disabled:S,autoFocus:o&&b,today:x,outsideCurrentMonth:I,isFirstVisibleCell:C,isLastVisibleCell:N,selected:v,tabIndex:b?0:-1,"aria-selected":v,"aria-current":x?"date":void 0}))}function qC(e){const t=mo({props:e,name:"MuiDayCalendar"}),n=Cx(),{onFocusedDayChange:r,className:a,currentMonth:s,selectedDays:i,focusedDay:o,loading:l,onSelectedDaysChange:u,onMonthSwitchingAnimationEnd:c,readOnly:d,reduceAnimations:h,renderLoading:p=()=>(0,Zn.jsx)("span",{children:"..."}),slideDirection:f,TransitionProps:m,disablePast:g,disableFuture:y,minDate:b,maxDate:v,shouldDisableDate:x,shouldDisableMonth:w,shouldDisableYear:k,dayOfWeekFormatter:S=e=>n.format(e,"weekdayShort").charAt(0).toUpperCase(),hasFocus:I,onFocusedViewChange:C,gridLabelId:N,displayWeekNumber:E,fixedWeekNumber:A,autoFocus:_,timezone:$}=t,R=Tx($),D=(e=>{const{classes:t}=e;return Ex({root:["root"],header:["header"],weekDayLabel:["weekDayLabel"],loadingContainer:["loadingContainer"],slideTransition:["slideTransition"],monthContainer:["monthContainer"],weekContainer:["weekContainer"],weekNumberLabel:["weekNumberLabel"],weekNumber:["weekNumber"]},MC,t)})(t),M=rs(),F=dC({shouldDisableDate:x,shouldDisableMonth:w,shouldDisableYear:k,minDate:b,maxDate:v,disablePast:g,disableFuture:y,timezone:$}),O=Bx(),[P,L]=eS({name:"DayCalendar",state:"hasFocus",controlled:I,default:_??!1}),[z,B]=T.useState((()=>o||R)),W=Lk((e=>{d||u(e)})),V=e=>{F(e)||(r(e),B(e),C?.(!0),L(!0))},U=Lk(((e,t)=>{switch(e.key){case"ArrowUp":V(n.addDays(t,-7)),e.preventDefault();break;case"ArrowDown":V(n.addDays(t,7)),e.preventDefault();break;case"ArrowLeft":{const r=n.addDays(t,M?1:-1),a=n.addMonths(t,M?1:-1),s=zv({utils:n,date:r,minDate:M?r:n.startOfMonth(a),maxDate:M?n.endOfMonth(a):r,isDateDisabled:F,timezone:$});V(s||r),e.preventDefault();break}case"ArrowRight":{const r=n.addDays(t,M?-1:1),a=n.addMonths(t,M?-1:1),s=zv({utils:n,date:r,minDate:M?n.startOfMonth(a):r,maxDate:M?r:n.endOfMonth(a),isDateDisabled:F,timezone:$});V(s||r),e.preventDefault();break}case"Home":V(n.startOfWeek(t)),e.preventDefault();break;case"End":V(n.endOfWeek(t)),e.preventDefault();break;case"PageUp":V(n.addMonths(t,1)),e.preventDefault();break;case"PageDown":V(n.addMonths(t,-1)),e.preventDefault()}})),j=Lk(((e,t)=>V(t))),G=Lk(((e,t)=>{P&&n.isSameDay(z,t)&&C?.(!1)})),H=n.getMonth(s),q=n.getYear(s),K=T.useMemo((()=>i.filter((e=>!!e)).map((e=>n.startOfDay(e)))),[n,i]),X=`${q}-${H}`,Y=T.useMemo((()=>T.createRef()),[X]),Q=T.useMemo((()=>{const e=n.startOfMonth(s),t=n.endOfMonth(s);return F(z)||n.isAfterDay(z,t)||n.isBeforeDay(z,e)?zv({utils:n,date:z,minDate:e,maxDate:t,disablePast:g,disableFuture:y,isDateDisabled:F,timezone:$}):z}),[s,y,g,z,F,n,$]),J=T.useMemo((()=>{const e=n.setTimezone(s,$),t=n.getWeekArray(e);let r=n.addMonths(e,1);for(;A&&t.length<A;){const e=n.getWeekArray(r),a=n.isSameDay(t[t.length-1][0],e[0][0]);e.slice(a?1:0).forEach((e=>{t.length<A&&t.push(e)})),r=n.addMonths(r,1)}return t}),[s,A,n,$]);return(0,Zn.jsxs)(PC,{role:"grid","aria-labelledby":N,className:D.root,children:[(0,Zn.jsxs)(LC,{role:"row",className:D.header,children:[E&&(0,Zn.jsx)(BC,{variant:"caption",role:"columnheader","aria-label":O.calendarWeekNumberHeaderLabel,className:D.weekNumberLabel,children:O.calendarWeekNumberHeaderText}),Hv(n,R).map(((e,t)=>(0,Zn.jsx)(zC,{variant:"caption",role:"columnheader","aria-label":n.format(e,"weekday"),className:D.weekDayLabel,children:S(e)},t.toString())))]}),l?(0,Zn.jsx)(VC,{className:D.loadingContainer,children:p()}):(0,Zn.jsx)(UC,(0,_o.A)({transKey:X,onExited:c,reduceAnimations:h,slideDirection:f,className:(0,Wn.A)(a,D.slideTransition)},m,{nodeRef:Y,children:(0,Zn.jsx)(jC,{ref:Y,role:"rowgroup",className:D.monthContainer,children:J.map(((e,r)=>(0,Zn.jsxs)(GC,{role:"row",className:D.weekContainer,"aria-rowindex":r+1,children:[E&&(0,Zn.jsx)(WC,{className:D.weekNumber,role:"rowheader","aria-label":O.calendarWeekNumberAriaLabelText(n.getWeekNumber(e[0])),children:O.calendarWeekNumberText(n.getWeekNumber(e[0]))}),e.map(((e,n)=>(0,Zn.jsx)(HC,{parentProps:t,day:e,selectedDays:K,focusableDay:Q,onKeyDown:U,onFocus:j,onBlur:G,onDaySelect:W,isDateDisabled:F,currentMonthNumber:H,isViewFocused:P,"aria-colindex":n+1},e.toString())))]},`week-${e[0]}`)))})}))]})}function KC(e){return Dx("MuiPickersMonth",e)}const XC=Mx("MuiPickersMonth",["root","monthButton","disabled","selected"]),YC=["autoFocus","className","children","disabled","selected","value","tabIndex","onClick","onKeyDown","onFocus","onBlur","aria-current","aria-label","monthsPerRow","slots","slotProps"],QC=(0,cr.Ay)("div",{name:"MuiPickersMonth",slot:"Root",overridesResolver:(e,t)=>[t.root]})({display:"flex",alignItems:"center",justifyContent:"center",flexBasis:"33.3%",variants:[{props:{monthsPerRow:4},style:{flexBasis:"25%"}}]}),JC=(0,cr.Ay)("button",{name:"MuiPickersMonth",slot:"MonthButton",overridesResolver:(e,t)=>[t.monthButton,{[`&.${XC.disabled}`]:t.disabled},{[`&.${XC.selected}`]:t.selected}]})((e=>{let{theme:t}=e;return(0,_o.A)({color:"unset",backgroundColor:"transparent",border:0,outline:0},t.typography.subtitle1,{margin:"8px 0",height:36,width:72,borderRadius:18,cursor:"pointer","&:focus":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,ur.X4)(t.palette.action.active,t.palette.action.hoverOpacity)},"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,ur.X4)(t.palette.action.active,t.palette.action.hoverOpacity)},"&:disabled":{cursor:"auto",pointerEvents:"none"},[`&.${XC.disabled}`]:{color:(t.vars||t).palette.text.secondary},[`&.${XC.selected}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.main,"&:focus, &:hover":{backgroundColor:(t.vars||t).palette.primary.dark}}})})),ZC=T.memo((function(e){const t=mo({props:e,name:"MuiPickersMonth"}),{autoFocus:n,className:r,children:a,disabled:s,selected:i,value:o,tabIndex:l,onClick:u,onKeyDown:c,onFocus:d,onBlur:h,"aria-current":p,"aria-label":f,slots:m,slotProps:g}=t,y=$s(t,YC),b=T.useRef(null),v=(e=>{const{disabled:t,selected:n,classes:r}=e;return Ex({root:["root"],monthButton:["monthButton",t&&"disabled",n&&"selected"]},KC,r)})(t);Pk((()=>{n&&b.current?.focus()}),[n]);const x=m?.monthButton??JC,w=tw({elementType:x,externalSlotProps:g?.monthButton,additionalProps:{children:a,disabled:s,tabIndex:l,ref:b,type:"button",role:"radio","aria-current":p,"aria-checked":i,"aria-label":f,onClick:e=>u(e,o),onKeyDown:e=>c(e,o),onFocus:e=>d(e,o),onBlur:e=>h(e,o)},ownerState:t,className:v.monthButton});return(0,Zn.jsx)(QC,(0,_o.A)({className:(0,Wn.A)(v.root,r),ownerState:t},y,{children:(0,Zn.jsx)(x,(0,_o.A)({},w))}))}));function eN(e){return Dx("MuiMonthCalendar",e)}Mx("MuiMonthCalendar",["root"]);const tN=["className","value","defaultValue","referenceDate","disabled","disableFuture","disablePast","maxDate","minDate","onChange","shouldDisableMonth","readOnly","disableHighlightToday","autoFocus","onMonthFocus","hasFocus","onFocusedViewChange","monthsPerRow","timezone","gridLabelId","slots","slotProps"];const nN=(0,cr.Ay)("div",{name:"MuiMonthCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",flexWrap:"wrap",alignContent:"stretch",padding:"0 4px",width:RS,boxSizing:"border-box"}),rN=T.forwardRef((function(e,t){const n=function(e,t){const n=Cx(),r=Nx(),a=mo({props:e,name:t});return(0,_o.A)({disableFuture:!1,disablePast:!1},a,{minDate:Bv(n,a.minDate,r.minDate),maxDate:Bv(n,a.maxDate,r.maxDate)})}(e,"MuiMonthCalendar"),{className:r,value:a,defaultValue:s,referenceDate:i,disabled:o,disableFuture:l,disablePast:u,maxDate:c,minDate:d,onChange:h,shouldDisableMonth:p,readOnly:f,autoFocus:m=!1,onMonthFocus:g,hasFocus:y,onFocusedViewChange:b,monthsPerRow:v=3,timezone:x,gridLabelId:w,slots:k,slotProps:S}=n,I=$s(n,tN),{value:C,handleValueChange:N,timezone:E}=nS({name:"MonthCalendar",timezone:x,value:a,defaultValue:s,onChange:h,valueManager:vx}),A=Tx(E),_=rs(),$=Cx(),R=T.useMemo((()=>vx.getInitialReferenceValue({value:C,utils:$,props:n,timezone:E,referenceDate:i,granularity:Xv.month})),[]),D=n,M=(e=>{const{classes:t}=e;return Ex({root:["root"]},eN,t)})(D),F=T.useMemo((()=>$.getMonth(A)),[$,A]),O=T.useMemo((()=>null!=C?$.getMonth(C):null),[C,$]),[P,L]=T.useState((()=>O||$.getMonth(R))),[z,B]=eS({name:"MonthCalendar",state:"hasFocus",controlled:y,default:m??!1}),W=Lk((e=>{B(e),b&&b(e)})),V=T.useCallback((e=>{const t=$.startOfMonth(u&&$.isAfter(A,d)?A:d),n=$.startOfMonth(l&&$.isBefore(A,c)?A:c),r=$.startOfMonth(e);return!!$.isBefore(r,t)||(!!$.isAfter(r,n)||!!p&&p(r))}),[l,u,c,d,A,p,$]),U=Lk(((e,t)=>{if(f)return;const n=$.setMonth(C??R,t);N(n)})),j=Lk((e=>{V($.setMonth(C??R,e))||(L(e),W(!0),g&&g(e))}));T.useEffect((()=>{L((e=>null!==O&&e!==O?O:e))}),[O]);const G=Lk(((e,t)=>{const n=12;switch(e.key){case"ArrowUp":j((n+t-3)%n),e.preventDefault();break;case"ArrowDown":j((n+t+3)%n),e.preventDefault();break;case"ArrowLeft":j((n+t+(_?1:-1))%n),e.preventDefault();break;case"ArrowRight":j((n+t+(_?-1:1))%n),e.preventDefault()}})),H=Lk(((e,t)=>{j(t)})),q=Lk(((e,t)=>{P===t&&W(!1)}));return(0,Zn.jsx)(nN,(0,_o.A)({ref:t,className:(0,Wn.A)(M.root,r),ownerState:D,role:"radiogroup","aria-labelledby":w},I,{children:Wv($,C??R).map((e=>{const t=$.getMonth(e),n=$.format(e,"monthShort"),r=$.format(e,"month"),a=t===O,s=o||V(e);return(0,Zn.jsx)(ZC,{selected:a,value:t,onClick:U,onKeyDown:G,autoFocus:z&&t===P,disabled:s,tabIndex:t!==P||s?-1:0,onFocus:H,onBlur:q,"aria-current":F===t?"date":void 0,"aria-label":r,monthsPerRow:v,slots:k,slotProps:S,children:n},n)}))}))}));function aN(e){return Dx("MuiPickersYear",e)}const sN=Mx("MuiPickersYear",["root","yearButton","selected","disabled"]),iN=["autoFocus","className","children","disabled","selected","value","tabIndex","onClick","onKeyDown","onFocus","onBlur","aria-current","yearsPerRow","slots","slotProps"],oN=(0,cr.Ay)("div",{name:"MuiPickersYear",slot:"Root",overridesResolver:(e,t)=>[t.root]})({display:"flex",alignItems:"center",justifyContent:"center",flexBasis:"33.3%",variants:[{props:{yearsPerRow:4},style:{flexBasis:"25%"}}]}),lN=(0,cr.Ay)("button",{name:"MuiPickersYear",slot:"YearButton",overridesResolver:(e,t)=>[t.yearButton,{[`&.${sN.disabled}`]:t.disabled},{[`&.${sN.selected}`]:t.selected}]})((e=>{let{theme:t}=e;return(0,_o.A)({color:"unset",backgroundColor:"transparent",border:0,outline:0},t.typography.subtitle1,{margin:"6px 0",height:36,width:72,borderRadius:18,cursor:"pointer","&:focus":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.focusOpacity})`:(0,ur.X4)(t.palette.action.active,t.palette.action.focusOpacity)},"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,ur.X4)(t.palette.action.active,t.palette.action.hoverOpacity)},"&:disabled":{cursor:"auto",pointerEvents:"none"},[`&.${sN.disabled}`]:{color:(t.vars||t).palette.text.secondary},[`&.${sN.selected}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.main,"&:focus, &:hover":{backgroundColor:(t.vars||t).palette.primary.dark}}})})),uN=T.memo((function(e){const t=mo({props:e,name:"MuiPickersYear"}),{autoFocus:n,className:r,children:a,disabled:s,selected:i,value:o,tabIndex:l,onClick:u,onKeyDown:c,onFocus:d,onBlur:h,"aria-current":p,slots:f,slotProps:m}=t,g=$s(t,iN),y=T.useRef(null),b=(e=>{const{disabled:t,selected:n,classes:r}=e;return Ex({root:["root"],yearButton:["yearButton",t&&"disabled",n&&"selected"]},aN,r)})(t);Pk((()=>{n&&y.current?.focus()}),[n]);const v=f?.yearButton??lN,x=tw({elementType:v,externalSlotProps:m?.yearButton,additionalProps:{children:a,disabled:s,tabIndex:l,ref:y,type:"button",role:"radio","aria-current":p,"aria-checked":i,onClick:e=>u(e,o),onKeyDown:e=>c(e,o),onFocus:e=>d(e,o),onBlur:e=>h(e,o)},ownerState:t,className:b.yearButton});return(0,Zn.jsx)(oN,(0,_o.A)({className:(0,Wn.A)(b.root,r),ownerState:t},g,{children:(0,Zn.jsx)(v,(0,_o.A)({},x))}))}));function cN(e){return Dx("MuiYearCalendar",e)}Mx("MuiYearCalendar",["root"]);const dN=["autoFocus","className","value","defaultValue","referenceDate","disabled","disableFuture","disablePast","maxDate","minDate","onChange","readOnly","shouldDisableYear","disableHighlightToday","onYearFocus","hasFocus","onFocusedViewChange","yearsPerRow","timezone","gridLabelId","slots","slotProps"];const hN=(0,cr.Ay)("div",{name:"MuiYearCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",flexDirection:"row",flexWrap:"wrap",overflowY:"auto",height:"100%",padding:"0 4px",width:RS,maxHeight:280,boxSizing:"border-box",position:"relative"}),pN=T.forwardRef((function(e,t){const n=function(e,t){const n=Cx(),r=Nx(),a=mo({props:e,name:t});return(0,_o.A)({disablePast:!1,disableFuture:!1},a,{yearsPerRow:a.yearsPerRow??3,minDate:Bv(n,a.minDate,r.minDate),maxDate:Bv(n,a.maxDate,r.maxDate)})}(e,"MuiYearCalendar"),{autoFocus:r,className:a,value:s,defaultValue:i,referenceDate:o,disabled:l,disableFuture:u,disablePast:c,maxDate:d,minDate:h,onChange:p,readOnly:f,shouldDisableYear:m,onYearFocus:g,hasFocus:y,onFocusedViewChange:b,yearsPerRow:v,timezone:x,gridLabelId:w,slots:k,slotProps:S}=n,I=$s(n,dN),{value:C,handleValueChange:N,timezone:E}=nS({name:"YearCalendar",timezone:x,value:s,defaultValue:i,onChange:p,valueManager:vx}),A=Tx(E),_=rs(),$=Cx(),R=T.useMemo((()=>vx.getInitialReferenceValue({value:C,utils:$,props:n,timezone:E,referenceDate:o,granularity:Xv.year})),[]),D=n,M=(e=>{const{classes:t}=e;return Ex({root:["root"]},cN,t)})(D),F=T.useMemo((()=>$.getYear(A)),[$,A]),O=T.useMemo((()=>null!=C?$.getYear(C):null),[C,$]),[P,L]=T.useState((()=>O||$.getYear(R))),[z,B]=eS({name:"YearCalendar",state:"hasFocus",controlled:y,default:r??!1}),W=Lk((e=>{B(e),b&&b(e)})),V=T.useCallback((e=>{if(c&&$.isBeforeYear(e,A))return!0;if(u&&$.isAfterYear(e,A))return!0;if(h&&$.isBeforeYear(e,h))return!0;if(d&&$.isAfterYear(e,d))return!0;if(!m)return!1;const t=$.startOfYear(e);return m(t)}),[u,c,d,h,A,m,$]),U=Lk(((e,t)=>{if(f)return;const n=$.setYear(C??R,t);N(n)})),j=Lk((e=>{V($.setYear(C??R,e))||(L(e),W(!0),g?.(e))}));T.useEffect((()=>{L((e=>null!==O&&e!==O?O:e))}),[O]);const G=Lk(((e,t)=>{switch(e.key){case"ArrowUp":j(t-v),e.preventDefault();break;case"ArrowDown":j(t+v),e.preventDefault();break;case"ArrowLeft":j(t+(_?1:-1)),e.preventDefault();break;case"ArrowRight":j(t+(_?-1:1)),e.preventDefault()}})),H=Lk(((e,t)=>{j(t)})),q=Lk(((e,t)=>{P===t&&W(!1)})),K=T.useRef(null),X=Kx(t,K);return T.useEffect((()=>{if(r||null===K.current)return;const e=K.current.querySelector('[tabindex="0"]');if(!e)return;const t=e.offsetHeight,n=e.offsetTop,a=K.current.clientHeight,s=K.current.scrollTop,i=n+t;t>a||n<s||(K.current.scrollTop=i-a/2-t/2)}),[r]),(0,Zn.jsx)(hN,(0,_o.A)({ref:X,className:(0,Wn.A)(M.root,a),ownerState:D,role:"radiogroup","aria-labelledby":w},I,{children:$.getYearRange([h,d]).map((e=>{const t=$.getYear(e),n=t===O,r=l||V(e);return(0,Zn.jsx)(uN,{selected:n,value:t,onClick:U,onKeyDown:G,autoFocus:z&&t===P,disabled:r,tabIndex:t!==P||r?-1:0,onFocus:H,onBlur:q,"aria-current":F===t?"date":void 0,yearsPerRow:v,slots:k,slotProps:S,children:$.format(e,"year")},$.format(e,"year"))}))}))}));function fN(e){return Dx("MuiPickersArrowSwitcher",e)}Mx("MuiPickersArrowSwitcher",["root","spacer","button","previousIconButton","nextIconButton","leftArrowIcon","rightArrowIcon"]);const mN=["children","className","slots","slotProps","isNextDisabled","isNextHidden","onGoToNext","nextLabel","isPreviousDisabled","isPreviousHidden","onGoToPrevious","previousLabel","labelId"],gN=["ownerState"],yN=["ownerState"],bN=(0,cr.Ay)("div",{name:"MuiPickersArrowSwitcher",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex"}),vN=(0,cr.Ay)("div",{name:"MuiPickersArrowSwitcher",slot:"Spacer",overridesResolver:(e,t)=>t.spacer})((e=>{let{theme:t}=e;return{width:t.spacing(3)}})),xN=(0,cr.Ay)(dl,{name:"MuiPickersArrowSwitcher",slot:"Button",overridesResolver:(e,t)=>t.button})({variants:[{props:{hidden:!0},style:{visibility:"hidden"}}]}),wN=T.forwardRef((function(e,t){const n=rs(),r=mo({props:e,name:"MuiPickersArrowSwitcher"}),{children:a,className:s,slots:i,slotProps:o,isNextDisabled:l,isNextHidden:u,onGoToNext:c,nextLabel:d,isPreviousDisabled:h,isPreviousHidden:p,onGoToPrevious:f,previousLabel:m,labelId:g}=r,y=$s(r,mN),b=r,v=(e=>{const{classes:t}=e;return Ex({root:["root"],spacer:["spacer"],button:["button"],previousIconButton:["previousIconButton"],nextIconButton:["nextIconButton"],leftArrowIcon:["leftArrowIcon"],rightArrowIcon:["rightArrowIcon"]},fN,t)})(b),x={isDisabled:l,isHidden:u,goTo:c,label:d},w={isDisabled:h,isHidden:p,goTo:f,label:m},k=i?.previousIconButton??xN,S=tw({elementType:k,externalSlotProps:o?.previousIconButton,additionalProps:{size:"medium",title:w.label,"aria-label":w.label,disabled:w.isDisabled,edge:"end",onClick:w.goTo},ownerState:(0,_o.A)({},b,{hidden:w.isHidden}),className:(0,Wn.A)(v.button,v.previousIconButton)}),I=i?.nextIconButton??xN,C=tw({elementType:I,externalSlotProps:o?.nextIconButton,additionalProps:{size:"medium",title:x.label,"aria-label":x.label,disabled:x.isDisabled,edge:"start",onClick:x.goTo},ownerState:(0,_o.A)({},b,{hidden:x.isHidden}),className:(0,Wn.A)(v.button,v.nextIconButton)}),N=i?.leftArrowIcon??jS,T=$s(tw({elementType:N,externalSlotProps:o?.leftArrowIcon,additionalProps:{fontSize:"inherit"},ownerState:b,className:v.leftArrowIcon}),gN),E=i?.rightArrowIcon??GS,A=$s(tw({elementType:E,externalSlotProps:o?.rightArrowIcon,additionalProps:{fontSize:"inherit"},ownerState:b,className:v.rightArrowIcon}),yN);return(0,Zn.jsxs)(bN,(0,_o.A)({ref:t,className:(0,Wn.A)(v.root,s),ownerState:b},y,{children:[(0,Zn.jsx)(k,(0,_o.A)({},S,{children:n?(0,Zn.jsx)(E,(0,_o.A)({},A)):(0,Zn.jsx)(N,(0,_o.A)({},T))})),a?(0,Zn.jsx)(Pr,{variant:"subtitle1",component:"span",id:g,children:a}):(0,Zn.jsx)(vN,{className:v.spacer,ownerState:b}),(0,Zn.jsx)(I,(0,_o.A)({},C,{children:n?(0,Zn.jsx)(N,(0,_o.A)({},T)):(0,Zn.jsx)(E,(0,_o.A)({},A))}))]}))}));const kN=e=>Dx("MuiPickersCalendarHeader",e),SN=Mx("MuiPickersCalendarHeader",["root","labelContainer","label","switchViewButton","switchViewIcon"]),IN=["slots","slotProps","currentMonth","disabled","disableFuture","disablePast","maxDate","minDate","onMonthChange","onViewChange","view","reduceAnimations","views","labelId","className","timezone","format"],CN=["ownerState"],NN=(0,cr.Ay)("div",{name:"MuiPickersCalendarHeader",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",alignItems:"center",marginTop:12,marginBottom:4,paddingLeft:24,paddingRight:12,maxHeight:40,minHeight:40}),TN=(0,cr.Ay)("div",{name:"MuiPickersCalendarHeader",slot:"LabelContainer",overridesResolver:(e,t)=>t.labelContainer})((e=>{let{theme:t}=e;return(0,_o.A)({display:"flex",overflow:"hidden",alignItems:"center",cursor:"pointer",marginRight:"auto"},t.typography.body1,{fontWeight:t.typography.fontWeightMedium})})),EN=(0,cr.Ay)("div",{name:"MuiPickersCalendarHeader",slot:"Label",overridesResolver:(e,t)=>t.label})({marginRight:6}),AN=(0,cr.Ay)(dl,{name:"MuiPickersCalendarHeader",slot:"SwitchViewButton",overridesResolver:(e,t)=>t.switchViewButton})({marginRight:"auto",variants:[{props:{view:"year"},style:{[`.${SN.switchViewIcon}`]:{transform:"rotate(180deg)"}}}]}),_N=(0,cr.Ay)(US,{name:"MuiPickersCalendarHeader",slot:"SwitchViewIcon",overridesResolver:(e,t)=>t.switchViewIcon})((e=>{let{theme:t}=e;return{willChange:"transform",transition:t.transitions.create("transform"),transform:"rotate(0deg)"}})),$N=T.forwardRef((function(e,t){const n=Bx(),r=Cx(),a=mo({props:e,name:"MuiPickersCalendarHeader"}),{slots:s,slotProps:i,currentMonth:o,disabled:l,disableFuture:u,disablePast:c,maxDate:d,minDate:h,onMonthChange:p,onViewChange:f,view:m,reduceAnimations:g,views:y,labelId:b,className:v,timezone:x,format:w=`${r.formats.month} ${r.formats.year}`}=a,k=$s(a,IN),S=a,I=(e=>{const{classes:t}=e;return Ex({root:["root"],labelContainer:["labelContainer"],label:["label"],switchViewButton:["switchViewButton"],switchViewIcon:["switchViewIcon"]},kN,t)})(a),C=s?.switchViewButton??AN,N=tw({elementType:C,externalSlotProps:i?.switchViewButton,additionalProps:{size:"small","aria-label":n.calendarViewSwitchingButtonAriaLabel(m)},ownerState:S,className:I.switchViewButton}),E=s?.switchViewIcon??_N,A=$s(tw({elementType:E,externalSlotProps:i?.switchViewIcon,ownerState:S,className:I.switchViewIcon}),CN),_=function(e,t){let{disableFuture:n,maxDate:r,timezone:a}=t;const s=Cx();return T.useMemo((()=>{const t=s.date(void 0,a),i=s.startOfMonth(n&&s.isBefore(t,r)?t:r);return!s.isAfter(i,e)}),[n,r,e,s,a])}(o,{disableFuture:u,maxDate:d,timezone:x}),$=function(e,t){let{disablePast:n,minDate:r,timezone:a}=t;const s=Cx();return T.useMemo((()=>{const t=s.date(void 0,a),i=s.startOfMonth(n&&s.isAfter(t,r)?t:r);return!s.isBefore(i,e)}),[n,r,e,s,a])}(o,{disablePast:c,minDate:h,timezone:x});if(1===y.length&&"year"===y[0])return null;const R=r.formatByString(o,w);return(0,Zn.jsxs)(NN,(0,_o.A)({},k,{ownerState:S,className:(0,Wn.A)(v,I.root),ref:t,children:[(0,Zn.jsxs)(TN,{role:"presentation",onClick:()=>{if(1!==y.length&&f&&!l)if(2===y.length)f(y.find((e=>e!==m))||y[0]);else{const e=0!==y.indexOf(m)?0:1;f(y[e])}},ownerState:S,"aria-live":"polite",className:I.labelContainer,children:[(0,Zn.jsx)(mC,{reduceAnimations:g,transKey:R,children:(0,Zn.jsx)(EN,{id:b,ownerState:S,className:I.label,children:R})}),y.length>1&&!l&&(0,Zn.jsx)(C,(0,_o.A)({},N,{children:(0,Zn.jsx)(E,(0,_o.A)({},A))}))]}),(0,Zn.jsx)(li,{in:"day"===m,children:(0,Zn.jsx)(wN,{slots:s,slotProps:i,onGoToPrevious:()=>p(r.addMonths(o,-1),"right"),isPreviousDisabled:$,previousLabel:n.previousMonth,onGoToNext:()=>p(r.addMonths(o,1),"left"),isNextDisabled:_,nextLabel:n.nextMonth})})]}))})),RN=(0,cr.Ay)("div")({overflow:"hidden",width:RS,maxHeight:336,display:"flex",flexDirection:"column",margin:"0 auto"}),DN=e=>Dx("MuiDateCalendar",e),MN=(Mx("MuiDateCalendar",["root","viewTransitionContainer"]),["autoFocus","onViewChange","value","defaultValue","referenceDate","disableFuture","disablePast","onChange","onYearChange","onMonthChange","reduceAnimations","shouldDisableDate","shouldDisableMonth","shouldDisableYear","view","views","openTo","className","disabled","readOnly","minDate","maxDate","disableHighlightToday","focusedView","onFocusedViewChange","showDaysOutsideCurrentMonth","fixedWeekNumber","dayOfWeekFormatter","slots","slotProps","loading","renderLoading","displayWeekNumber","yearsPerRow","monthsPerRow","timezone"]);const FN=(0,cr.Ay)(RN,{name:"MuiDateCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",flexDirection:"column",height:336}),ON=(0,cr.Ay)(mC,{name:"MuiDateCalendar",slot:"ViewTransitionContainer",overridesResolver:(e,t)=>t.viewTransitionContainer})({}),PN=T.forwardRef((function(e,t){const n=Cx(),r=cw(),a=function(e,t){const n=Cx(),r=Nx(),a=qk(),s=mo({props:e,name:t});return(0,_o.A)({},s,{loading:s.loading??!1,disablePast:s.disablePast??!1,disableFuture:s.disableFuture??!1,openTo:s.openTo??"day",views:s.views??["year","day"],reduceAnimations:s.reduceAnimations??a,renderLoading:s.renderLoading??(()=>(0,Zn.jsx)("span",{children:"..."})),minDate:Bv(n,s.minDate,r.minDate),maxDate:Bv(n,s.maxDate,r.maxDate)})}(e,"MuiDateCalendar"),{autoFocus:s,onViewChange:i,value:o,defaultValue:l,referenceDate:u,disableFuture:c,disablePast:d,onChange:h,onYearChange:p,onMonthChange:f,reduceAnimations:m,shouldDisableDate:g,shouldDisableMonth:y,shouldDisableYear:b,view:v,views:x,openTo:w,className:k,disabled:S,readOnly:I,minDate:C,maxDate:N,disableHighlightToday:E,focusedView:A,onFocusedViewChange:_,showDaysOutsideCurrentMonth:$,fixedWeekNumber:R,dayOfWeekFormatter:D,slots:M,slotProps:F,loading:O,renderLoading:P,displayWeekNumber:L,yearsPerRow:z,monthsPerRow:B,timezone:W}=a,V=$s(a,MN),{value:U,handleValueChange:j,timezone:G}=nS({name:"DateCalendar",timezone:W,value:o,defaultValue:l,onChange:h,valueManager:vx}),{view:H,setView:q,focusedView:K,setFocusedView:X,goToNextView:Y,setValueAndGoToNextView:Q}=aS({view:v,views:x,openTo:w,onChange:j,onViewChange:i,autoFocus:s,focusedView:A,onFocusedViewChange:_}),{referenceDate:J,calendarState:Z,changeFocusedDay:ee,changeMonth:te,handleChangeMonth:ne,isDateDisabled:re,onMonthSwitchingAnimationEnd:ae}=hC({value:U,referenceDate:u,reduceAnimations:m,onMonthChange:f,minDate:C,maxDate:N,shouldDisableDate:g,disablePast:d,disableFuture:c,timezone:G}),se=S&&U||C,ie=S&&U||N,oe=`${r}-grid-label`,le=null!==K,ue=M?.calendarHeader??$N,ce=tw({elementType:ue,externalSlotProps:F?.calendarHeader,additionalProps:{views:x,view:H,currentMonth:Z.currentMonth,onViewChange:q,onMonthChange:(e,t)=>ne({newMonth:e,direction:t}),minDate:se,maxDate:ie,disabled:S,disablePast:d,disableFuture:c,reduceAnimations:m,timezone:G,labelId:oe},ownerState:a}),de=Lk((e=>{const t=n.startOfMonth(e),r=n.endOfMonth(e),a=re(e)?zv({utils:n,date:e,minDate:n.isBefore(C,t)?t:C,maxDate:n.isAfter(N,r)?r:N,disablePast:d,disableFuture:c,isDateDisabled:re,timezone:G}):e;a?(Q(a,"finish"),f?.(t)):(Y(),te(t)),ee(a,!0)})),he=Lk((e=>{const t=n.startOfYear(e),r=n.endOfYear(e),a=re(e)?zv({utils:n,date:e,minDate:n.isBefore(C,t)?t:C,maxDate:n.isAfter(N,r)?r:N,disablePast:d,disableFuture:c,isDateDisabled:re,timezone:G}):e;a?(Q(a,"finish"),p?.(a)):(Y(),te(t)),ee(a,!0)})),pe=Lk((e=>j(e?Lv(n,e,U??J):e,"finish",H)));T.useEffect((()=>{null!=U&&n.isValid(U)&&te(U)}),[U]);const fe=a,me=(e=>{const{classes:t}=e;return Ex({root:["root"],viewTransitionContainer:["viewTransitionContainer"]},DN,t)})(fe),ge={disablePast:d,disableFuture:c,maxDate:N,minDate:C},ye={disableHighlightToday:E,readOnly:I,disabled:S,timezone:G,gridLabelId:oe,slots:M,slotProps:F},be=T.useRef(H);T.useEffect((()=>{be.current!==H&&(K===be.current&&X(H,!0),be.current=H)}),[K,X,H]);const ve=T.useMemo((()=>[U]),[U]);return(0,Zn.jsxs)(FN,(0,_o.A)({ref:t,className:(0,Wn.A)(me.root,k),ownerState:fe},V,{children:[(0,Zn.jsx)(ue,(0,_o.A)({},ce,{slots:M,slotProps:F})),(0,Zn.jsx)(ON,{reduceAnimations:m,className:me.viewTransitionContainer,transKey:H,ownerState:fe,children:(0,Zn.jsxs)("div",{children:["year"===H&&(0,Zn.jsx)(pN,(0,_o.A)({},ge,ye,{value:U,onChange:he,shouldDisableYear:b,hasFocus:le,onFocusedViewChange:e=>X("year",e),yearsPerRow:z,referenceDate:J})),"month"===H&&(0,Zn.jsx)(rN,(0,_o.A)({},ge,ye,{hasFocus:le,className:k,value:U,onChange:de,shouldDisableMonth:y,onFocusedViewChange:e=>X("month",e),monthsPerRow:B,referenceDate:J})),"day"===H&&(0,Zn.jsx)(qC,(0,_o.A)({},Z,ge,ye,{onMonthSwitchingAnimationEnd:ae,onFocusedDayChange:ee,reduceAnimations:m,selectedDays:ve,onSelectedDaysChange:pe,shouldDisableDate:g,shouldDisableMonth:y,shouldDisableYear:b,hasFocus:le,onFocusedViewChange:e=>X("day",e),showDaysOutsideCurrentMonth:$,fixedWeekNumber:R,dayOfWeekFormatter:D,displayWeekNumber:L,loading:O,renderLoading:P}))]})})]}))})),LN=e=>{let{view:t,onViewChange:n,views:r,focusedView:a,onFocusedViewChange:s,value:i,defaultValue:o,referenceDate:l,onChange:u,className:c,classes:d,disableFuture:h,disablePast:p,minDate:f,maxDate:m,shouldDisableDate:g,shouldDisableMonth:y,shouldDisableYear:b,reduceAnimations:v,onMonthChange:x,monthsPerRow:w,onYearChange:k,yearsPerRow:S,slots:I,slotProps:C,loading:N,renderLoading:T,disableHighlightToday:E,readOnly:A,disabled:_,showDaysOutsideCurrentMonth:$,dayOfWeekFormatter:R,sx:D,autoFocus:M,fixedWeekNumber:F,displayWeekNumber:O,timezone:P}=e;return(0,Zn.jsx)(PN,{view:t,onViewChange:n,views:r.filter(jv),focusedView:a&&jv(a)?a:null,onFocusedViewChange:s,value:i,defaultValue:o,referenceDate:l,onChange:u,className:c,classes:d,disableFuture:h,disablePast:p,minDate:f,maxDate:m,shouldDisableDate:g,shouldDisableMonth:y,shouldDisableYear:b,reduceAnimations:v,onMonthChange:x,monthsPerRow:w,onYearChange:k,yearsPerRow:S,slots:I,slotProps:C,loading:N,renderLoading:T,disableHighlightToday:E,readOnly:A,disabled:_,showDaysOutsideCurrentMonth:$,dayOfWeekFormatter:R,sx:D,autoFocus:M,fixedWeekNumber:F,displayWeekNumber:O,timezone:P})},zN=T.forwardRef((function(e,t){const n=Bx(),r=Cx(),a=Hx(e,"MuiDesktopDatePicker"),s=(0,_o.A)({day:LN,month:LN,year:LN},a.viewRenderers),i=(0,_o.A)({},a,{viewRenderers:s,format:Gv(r,a,!1),yearsPerRow:a.yearsPerRow??4,slots:(0,_o.A)({openPickerIcon:HS,field:cC},a.slots),slotProps:(0,_o.A)({},a.slotProps,{field:e=>(0,_o.A)({},Fv(a.slotProps?.field,e),oI(a),{ref:t}),toolbar:(0,_o.A)({hidden:!0},a.slotProps?.toolbar)})}),{renderPicker:o}=(e=>{let{props:t,getOpenDialogAriaText:n}=e,r=$s(e,BS);const{slots:a,slotProps:s,className:i,sx:o,format:l,formatDensity:u,enableAccessibleFieldDOMStructure:c,selectedSections:d,onSelectedSectionsChange:h,timezone:p,name:f,label:m,inputRef:g,readOnly:y,disabled:b,autoFocus:v,localeText:x,reduceAnimations:w}=t,k=Cx(),S=T.useRef(null),I=T.useRef(null),C=cw(),N=s?.toolbar?.hidden??!1,{open:E,actions:A,hasUIView:_,layoutProps:$,renderCurrentView:R,shouldRestoreFocus:D,fieldProps:M}=uS((0,_o.A)({},r,{props:t,fieldRef:I,autoFocusView:!0,additionalViewProps:{},wrapperVariant:"desktop"})),F={open:E},O=a.inputAdornment??ow,P=$s(tw({elementType:O,externalSlotProps:s?.inputAdornment,additionalProps:{position:"end"},ownerState:t}),WS),L=a.openPickerButton??dl,z=$s(tw({elementType:L,externalSlotProps:s?.openPickerButton,additionalProps:{disabled:b||y,onClick:E?A.onClose:A.onOpen,"aria-label":n(M.value,k),edge:P.position},ownerState:t}),VS),B=a.openPickerIcon,W=tw({elementType:B,externalSlotProps:s?.openPickerIcon,ownerState:F}),V=a.field,U=tw({elementType:V,externalSlotProps:s?.field,additionalProps:(0,_o.A)({},M,N&&{id:C},{readOnly:y,disabled:b,className:i,sx:o,format:l,formatDensity:u,enableAccessibleFieldDOMStructure:c,selectedSections:d,onSelectedSectionsChange:h,timezone:p,label:m,name:f,autoFocus:v&&!t.open,focused:!!E||void 0},g?{inputRef:g}:{}),ownerState:t});_&&(U.InputProps=(0,_o.A)({},U.InputProps,{ref:S},!t.disableOpenPicker&&{[`${P.position}Adornment`]:(0,Zn.jsx)(O,(0,_o.A)({},P,{children:(0,Zn.jsx)(L,(0,_o.A)({},z,{children:(0,Zn.jsx)(B,(0,_o.A)({},W))}))}))}));const j=(0,_o.A)({textField:a.textField,clearIcon:a.clearIcon,clearButton:a.clearButton},U.slots),G=a.layout??zS;let H=C;N&&(H=m?`${C}-label`:void 0);const q=(0,_o.A)({},s,{toolbar:(0,_o.A)({},s?.toolbar,{titleId:C}),popper:(0,_o.A)({"aria-labelledby":H},s?.popper)}),K=Kx(I,U.unstableFieldRef);return{renderPicker:()=>(0,Zn.jsxs)(Ev,{localeText:x,children:[(0,Zn.jsx)(V,(0,_o.A)({},U,{slots:j,slotProps:q,unstableFieldRef:K})),(0,Zn.jsx)(Jk,(0,_o.A)({role:"dialog",placement:"bottom-start",anchorEl:S.current},A,{open:E,slots:a,slotProps:q,shouldRestoreFocus:D,reduceAnimations:w,children:(0,Zn.jsx)(G,(0,_o.A)({},$,q?.layout,{slots:a,slotProps:q,children:R()}))}))]})}})({props:i,valueManager:vx,valueType:"date",getOpenDialogAriaText:i.localeText?.openDatePickerDialogue??n.openDatePickerDialogue,validator:qx});return o()}));zN.propTypes={autoFocus:Mv().bool,className:Mv().string,closeOnSelect:Mv().bool,dayOfWeekFormatter:Mv().func,defaultValue:Mv().object,disabled:Mv().bool,disableFuture:Mv().bool,disableHighlightToday:Mv().bool,disableOpenPicker:Mv().bool,disablePast:Mv().bool,displayWeekNumber:Mv().bool,enableAccessibleFieldDOMStructure:Mv().any,fixedWeekNumber:Mv().number,format:Mv().string,formatDensity:Mv().oneOf(["dense","spacious"]),inputRef:Ov,label:Mv().node,loading:Mv().bool,localeText:Mv().object,maxDate:Mv().object,minDate:Mv().object,monthsPerRow:Mv().oneOf([3,4]),name:Mv().string,onAccept:Mv().func,onChange:Mv().func,onClose:Mv().func,onError:Mv().func,onMonthChange:Mv().func,onOpen:Mv().func,onSelectedSectionsChange:Mv().func,onViewChange:Mv().func,onYearChange:Mv().func,open:Mv().bool,openTo:Mv().oneOf(["day","month","year"]),orientation:Mv().oneOf(["landscape","portrait"]),readOnly:Mv().bool,reduceAnimations:Mv().bool,referenceDate:Mv().object,renderLoading:Mv().func,selectedSections:Mv().oneOfType([Mv().oneOf(["all","day","empty","hours","meridiem","minutes","month","seconds","weekDay","year"]),Mv().number]),shouldDisableDate:Mv().func,shouldDisableMonth:Mv().func,shouldDisableYear:Mv().func,showDaysOutsideCurrentMonth:Mv().bool,slotProps:Mv().object,slots:Mv().object,sx:Mv().oneOfType([Mv().arrayOf(Mv().oneOfType([Mv().func,Mv().object,Mv().bool])),Mv().func,Mv().object]),timezone:Mv().string,value:Mv().object,view:Mv().oneOf(["day","month","year"]),viewRenderers:Mv().shape({day:Mv().func,month:Mv().func,year:Mv().func}),views:Mv().arrayOf(Mv().oneOf(["day","month","year"]).isRequired),yearsPerRow:Mv().oneOf([3,4])};const BN=(0,cr.Ay)(Xl)({[`& .${Ul.container}`]:{outline:0},[`& .${Ul.paper}`]:{outline:0,minWidth:RS}}),WN=(0,cr.Ay)(nu)({"&:first-of-type":{padding:0}});function VN(e){const{children:t,onDismiss:n,open:r,slots:a,slotProps:s}=e,i=a?.dialog??BN,o=a?.mobileTransition??li;return(0,Zn.jsx)(i,(0,_o.A)({open:r,onClose:n},s?.dialog,{TransitionComponent:o,TransitionProps:s?.mobileTransition,PaperComponent:a?.mobilePaper,PaperProps:s?.mobilePaper,children:(0,Zn.jsx)(WN,{children:t})}))}const UN=["props","getOpenDialogAriaText"],jN=T.forwardRef((function(e,t){const n=Bx(),r=Cx(),a=Hx(e,"MuiMobileDatePicker"),s=(0,_o.A)({day:LN,month:LN,year:LN},a.viewRenderers),i=(0,_o.A)({},a,{viewRenderers:s,format:Gv(r,a,!1),slots:(0,_o.A)({field:cC},a.slots),slotProps:(0,_o.A)({},a.slotProps,{field:e=>(0,_o.A)({},Fv(a.slotProps?.field,e),oI(a),{ref:t}),toolbar:(0,_o.A)({hidden:!1},a.slotProps?.toolbar)})}),{renderPicker:o}=(e=>{let{props:t,getOpenDialogAriaText:n}=e,r=$s(e,UN);const{slots:a,slotProps:s,className:i,sx:o,format:l,formatDensity:u,enableAccessibleFieldDOMStructure:c,selectedSections:d,onSelectedSectionsChange:h,timezone:p,name:f,label:m,inputRef:g,readOnly:y,disabled:b,localeText:v}=t,x=Cx(),w=T.useRef(null),k=cw(),S=s?.toolbar?.hidden??!1,{open:I,actions:C,layoutProps:N,renderCurrentView:E,fieldProps:A}=uS((0,_o.A)({},r,{props:t,fieldRef:w,autoFocusView:!0,additionalViewProps:{},wrapperVariant:"mobile"})),_=a.field,$=tw({elementType:_,externalSlotProps:s?.field,additionalProps:(0,_o.A)({},A,S&&{id:k},!(b||y)&&{onClick:C.onOpen,onKeyDown:(R=C.onOpen,e=>{"Enter"!==e.key&&" "!==e.key||(R(e),e.preventDefault(),e.stopPropagation()),D&&D(e)})},{readOnly:y??!0,disabled:b,className:i,sx:o,format:l,formatDensity:u,enableAccessibleFieldDOMStructure:c,selectedSections:d,onSelectedSectionsChange:h,timezone:p,label:m,name:f},g?{inputRef:g}:{}),ownerState:t});var R,D;$.inputProps=(0,_o.A)({},$.inputProps,{"aria-label":n(A.value,x)});const M=(0,_o.A)({textField:a.textField},$.slots),F=a.layout??zS;let O=k;S&&(O=m?`${k}-label`:void 0);const P=(0,_o.A)({},s,{toolbar:(0,_o.A)({},s?.toolbar,{titleId:k}),mobilePaper:(0,_o.A)({"aria-labelledby":O},s?.mobilePaper)}),L=Kx(w,$.unstableFieldRef);return{renderPicker:()=>(0,Zn.jsxs)(Ev,{localeText:v,children:[(0,Zn.jsx)(_,(0,_o.A)({},$,{slots:M,slotProps:P,unstableFieldRef:L})),(0,Zn.jsx)(VN,(0,_o.A)({},C,{open:I,slots:a,slotProps:P,children:(0,Zn.jsx)(F,(0,_o.A)({},N,P?.layout,{slots:a,slotProps:P,children:E()}))}))]})}})({props:i,valueManager:vx,valueType:"date",getOpenDialogAriaText:i.localeText?.openDatePickerDialogue??n.openDatePickerDialogue,validator:qx});return o()}));jN.propTypes={autoFocus:Mv().bool,className:Mv().string,closeOnSelect:Mv().bool,dayOfWeekFormatter:Mv().func,defaultValue:Mv().object,disabled:Mv().bool,disableFuture:Mv().bool,disableHighlightToday:Mv().bool,disableOpenPicker:Mv().bool,disablePast:Mv().bool,displayWeekNumber:Mv().bool,enableAccessibleFieldDOMStructure:Mv().any,fixedWeekNumber:Mv().number,format:Mv().string,formatDensity:Mv().oneOf(["dense","spacious"]),inputRef:Ov,label:Mv().node,loading:Mv().bool,localeText:Mv().object,maxDate:Mv().object,minDate:Mv().object,monthsPerRow:Mv().oneOf([3,4]),name:Mv().string,onAccept:Mv().func,onChange:Mv().func,onClose:Mv().func,onError:Mv().func,onMonthChange:Mv().func,onOpen:Mv().func,onSelectedSectionsChange:Mv().func,onViewChange:Mv().func,onYearChange:Mv().func,open:Mv().bool,openTo:Mv().oneOf(["day","month","year"]),orientation:Mv().oneOf(["landscape","portrait"]),readOnly:Mv().bool,reduceAnimations:Mv().bool,referenceDate:Mv().object,renderLoading:Mv().func,selectedSections:Mv().oneOfType([Mv().oneOf(["all","day","empty","hours","meridiem","minutes","month","seconds","weekDay","year"]),Mv().number]),shouldDisableDate:Mv().func,shouldDisableMonth:Mv().func,shouldDisableYear:Mv().func,showDaysOutsideCurrentMonth:Mv().bool,slotProps:Mv().object,slots:Mv().object,sx:Mv().oneOfType([Mv().arrayOf(Mv().oneOfType([Mv().func,Mv().object,Mv().bool])),Mv().func,Mv().object]),timezone:Mv().string,value:Mv().object,view:Mv().oneOf(["day","month","year"]),viewRenderers:Mv().shape({day:Mv().func,month:Mv().func,year:Mv().func}),views:Mv().arrayOf(Mv().oneOf(["day","month","year"]).isRequired),yearsPerRow:Mv().oneOf([3,4])};const GN=["desktopModeMediaQuery"],HN=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiDatePicker"}),{desktopModeMediaQuery:r=Vk}=n,a=$s(n,GN);return Rv(r,{defaultMatches:!0})?(0,Zn.jsx)(zN,(0,_o.A)({ref:t},a)):(0,Zn.jsx)(jN,(0,_o.A)({ref:t},a))}));var qN=n(446),KN=n.n(qN),XN=n(6865),YN=n.n(XN),QN=n(8988),JN=n.n(QN),ZN=n(4443),eT=n.n(ZN),tT=n(1525),nT=n.n(tT),rT=n(7076),aT=n.n(rT);KN().extend(eT()),KN().extend(YN()),KN().extend(nT()),KN().extend(aT());const sT={YY:"year",YYYY:{sectionType:"year",contentType:"digit",maxLength:4},M:{sectionType:"month",contentType:"digit",maxLength:2},MM:"month",MMM:{sectionType:"month",contentType:"letter"},MMMM:{sectionType:"month",contentType:"letter"},D:{sectionType:"day",contentType:"digit",maxLength:2},DD:"day",Do:{sectionType:"day",contentType:"digit-with-letter"},d:{sectionType:"weekDay",contentType:"digit",maxLength:2},dd:{sectionType:"weekDay",contentType:"letter"},ddd:{sectionType:"weekDay",contentType:"letter"},dddd:{sectionType:"weekDay",contentType:"letter"},A:"meridiem",a:"meridiem",H:{sectionType:"hours",contentType:"digit",maxLength:2},HH:"hours",h:{sectionType:"hours",contentType:"digit",maxLength:2},hh:"hours",m:{sectionType:"minutes",contentType:"digit",maxLength:2},mm:"minutes",s:{sectionType:"seconds",contentType:"digit",maxLength:2},ss:"seconds"},iT={year:"YYYY",month:"MMMM",monthShort:"MMM",dayOfMonth:"D",dayOfMonthFull:"Do",weekday:"dddd",weekdayShort:"dd",hours24h:"HH",hours12h:"hh",meridiem:"A",minutes:"mm",seconds:"ss",fullDate:"ll",keyboardDate:"L",shortDate:"MMM D",normalDate:"D MMMM",normalDateWithWeekday:"ddd, MMM D",fullTime:"LT",fullTime12h:"hh:mm A",fullTime24h:"HH:mm",keyboardDateTime:"L LT",keyboardDateTime12h:"L hh:mm A",keyboardDateTime24h:"L HH:mm"},oT=["Missing UTC plugin","To be able to use UTC or timezones, you have to enable the `utc` plugin","Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-utc"].join("\n"),lT=["Missing timezone plugin","To be able to use timezones, you have to enable both the `utc` and the `timezone` plugin","Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-timezone"].join("\n");class uT{constructor(){var e=this;let{locale:t,formats:n}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};var r,a;this.isMUIAdapter=!0,this.isTimezoneCompatible=!0,this.lib="dayjs",this.dayjs=void 0,this.locale=void 0,this.formats=void 0,this.escapedCharacters={start:"[",end:"]"},this.formatTokenMap=sT,this.setLocaleToValue=e=>{const t=this.getCurrentLocaleCode();return t===e.locale()?e:e.locale(t)},this.hasUTCPlugin=()=>"undefined"!==typeof KN().utc,this.hasTimezonePlugin=()=>"undefined"!==typeof KN().tz,this.isSame=(e,t,n)=>{const r=this.setTimezone(t,this.getTimezone(e));return e.format(n)===r.format(n)},this.cleanTimezone=e=>{switch(e){case"default":return;case"system":return KN().tz.guess();default:return e}},this.createSystemDate=e=>{if(this.hasUTCPlugin()&&this.hasTimezonePlugin()){const t=KN().tz.guess();return"UTC"!==t?KN().tz(e,t):KN()(e)}return KN()(e)},this.createUTCDate=e=>{if(!this.hasUTCPlugin())throw new Error(oT);return KN().utc(e)},this.createTZDate=(e,t)=>{if(!this.hasUTCPlugin())throw new Error(oT);if(!this.hasTimezonePlugin())throw new Error(lT);const n=void 0!==e&&!e.endsWith("Z");return KN()(e).tz(this.cleanTimezone(t),n)},this.getLocaleFormats=()=>{const e=KN().Ls;let t=e[this.locale||"en"];return void 0===t&&(t=e.en),t.formats},this.adjustOffset=e=>{if(!this.hasTimezonePlugin())return e;const t=this.getTimezone(e);if("UTC"!==t){const n=e.tz(this.cleanTimezone(t),!0);if(n.$offset===(e.$offset??0))return e;e.$offset=n.$offset}return e},this.date=function(t){let n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default";return null===t?null:(n="UTC"===r?e.createUTCDate(t):"system"===r||"default"===r&&!e.hasTimezonePlugin()?e.createSystemDate(t):e.createTZDate(t,r),void 0===e.locale?n:n.locale(e.locale))},this.getInvalidDate=()=>KN()(new Date("Invalid date")),this.getTimezone=e=>{if(this.hasTimezonePlugin()){const t=e.$x?.$timezone;if(t)return t}return this.hasUTCPlugin()&&e.isUTC()?"UTC":"system"},this.setTimezone=(e,t)=>{if(this.getTimezone(e)===t)return e;if("UTC"===t){if(!this.hasUTCPlugin())throw new Error(oT);return e.utc()}if("system"===t)return e.local();if(!this.hasTimezonePlugin()){if("default"===t)return e;throw new Error(lT)}return KN().tz(e,this.cleanTimezone(t))},this.toJsDate=e=>e.toDate(),this.parse=(e,t)=>""===e?null:this.dayjs(e,t,this.locale,!0),this.getCurrentLocaleCode=()=>this.locale||"en",this.is12HourCycleInCurrentLocale=()=>/A|a/.test(this.getLocaleFormats().LT||""),this.expandFormat=e=>{const t=this.getLocaleFormats();return e.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,((e,n,r)=>{const a=r&&r.toUpperCase();return n||t[r]||t[a].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,((e,t,n)=>t||n.slice(1)))}))},this.isValid=e=>null!=e&&e.isValid(),this.format=(e,t)=>this.formatByString(e,this.formats[t]),this.formatByString=(e,t)=>this.dayjs(e).format(t),this.formatNumber=e=>e,this.isEqual=(e,t)=>null===e&&null===t||null!==e&&null!==t&&e.toDate().getTime()===t.toDate().getTime(),this.isSameYear=(e,t)=>this.isSame(e,t,"YYYY"),this.isSameMonth=(e,t)=>this.isSame(e,t,"YYYY-MM"),this.isSameDay=(e,t)=>this.isSame(e,t,"YYYY-MM-DD"),this.isSameHour=(e,t)=>e.isSame(t,"hour"),this.isAfter=(e,t)=>e>t,this.isAfterYear=(e,t)=>this.hasUTCPlugin()?!this.isSameYear(e,t)&&e.utc()>t.utc():e.isAfter(t,"year"),this.isAfterDay=(e,t)=>this.hasUTCPlugin()?!this.isSameDay(e,t)&&e.utc()>t.utc():e.isAfter(t,"day"),this.isBefore=(e,t)=>e<t,this.isBeforeYear=(e,t)=>this.hasUTCPlugin()?!this.isSameYear(e,t)&&e.utc()<t.utc():e.isBefore(t,"year"),this.isBeforeDay=(e,t)=>this.hasUTCPlugin()?!this.isSameDay(e,t)&&e.utc()<t.utc():e.isBefore(t,"day"),this.isWithinRange=(e,t)=>{let[n,r]=t;return e>=n&&e<=r},this.startOfYear=e=>this.adjustOffset(e.startOf("year")),this.startOfMonth=e=>this.adjustOffset(e.startOf("month")),this.startOfWeek=e=>this.adjustOffset(this.setLocaleToValue(e).startOf("week")),this.startOfDay=e=>this.adjustOffset(e.startOf("day")),this.endOfYear=e=>this.adjustOffset(e.endOf("year")),this.endOfMonth=e=>this.adjustOffset(e.endOf("month")),this.endOfWeek=e=>this.adjustOffset(this.setLocaleToValue(e).endOf("week")),this.endOfDay=e=>this.adjustOffset(e.endOf("day")),this.addYears=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"year"):e.add(t,"year")),this.addMonths=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"month"):e.add(t,"month")),this.addWeeks=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"week"):e.add(t,"week")),this.addDays=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"day"):e.add(t,"day")),this.addHours=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"hour"):e.add(t,"hour")),this.addMinutes=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"minute"):e.add(t,"minute")),this.addSeconds=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"second"):e.add(t,"second")),this.getYear=e=>e.year(),this.getMonth=e=>e.month(),this.getDate=e=>e.date(),this.getHours=e=>e.hour(),this.getMinutes=e=>e.minute(),this.getSeconds=e=>e.second(),this.getMilliseconds=e=>e.millisecond(),this.setYear=(e,t)=>this.adjustOffset(e.set("year",t)),this.setMonth=(e,t)=>this.adjustOffset(e.set("month",t)),this.setDate=(e,t)=>this.adjustOffset(e.set("date",t)),this.setHours=(e,t)=>this.adjustOffset(e.set("hour",t)),this.setMinutes=(e,t)=>this.adjustOffset(e.set("minute",t)),this.setSeconds=(e,t)=>this.adjustOffset(e.set("second",t)),this.setMilliseconds=(e,t)=>this.adjustOffset(e.set("millisecond",t)),this.getDaysInMonth=e=>e.daysInMonth(),this.getWeekArray=e=>{const t=this.startOfWeek(this.startOfMonth(e)),n=this.endOfWeek(this.endOfMonth(e));let r=0,a=t;const s=[];for(;a<n;){const e=Math.floor(r/7);s[e]=s[e]||[],s[e].push(a),a=this.addDays(a,1),r+=1}return s},this.getWeekNumber=e=>e.week(),this.getYearRange=e=>{let[t,n]=e;const r=this.startOfYear(t),a=this.endOfYear(n),s=[];let i=r;for(;this.isBefore(i,a);)s.push(i),i=this.addYears(i,1);return s},this.dayjs=(r=KN(),(a=t)?function(){return r(...arguments).locale(a)}:r),this.locale=t,this.formats=(0,_o.A)({},iT,n),KN().extend(JN())}getDayOfWeek(e){return e.day()+1}}var cT=n(7029),dT=n.n(cT),hT="/index.js",pT=Object.defineProperty,fT=n(7291),mT=(e,t)=>{for(var n in t)pT(e,n,{get:t[n],enumerable:!0})};mT({},{Abs:()=>QE,Acos:()=>JE,Acosh:()=>ZE,AdadeltaOptimizer:()=>VW,AdagradOptimizer:()=>UW,AdamOptimizer:()=>jW,AdamaxOptimizer:()=>GW,Add:()=>eA,AddN:()=>tA,All:()=>nA,Any:()=>rA,ArgMax:()=>aA,ArgMin:()=>sA,Asin:()=>iA,Asinh:()=>oA,Atan:()=>lA,Atan2:()=>cA,Atanh:()=>uA,AvgPool:()=>dA,AvgPool3D:()=>pA,AvgPool3DGrad:()=>fA,AvgPoolGrad:()=>hA,BackendWasm:()=>Rme,BatchMatMul:()=>mA,BatchToSpaceND:()=>gA,Bincount:()=>yA,BitwiseAnd:()=>bA,BroadcastArgs:()=>xA,BroadcastTo:()=>vA,Callback:()=>v0,CallbackList:()=>rX,Cast:()=>wA,Ceil:()=>kA,ClipByValue:()=>SA,Complex:()=>IA,ComplexAbs:()=>CA,Concat:()=>NA,Conv2D:()=>TA,Conv2DBackpropFilter:()=>EA,Conv2DBackpropInput:()=>AA,Conv3D:()=>_A,Conv3DBackpropFilterV2:()=>$A,Conv3DBackpropInputV2:()=>RA,Cos:()=>DA,Cosh:()=>MA,CropAndResize:()=>PA,Cumprod:()=>FA,Cumsum:()=>OA,CustomCallback:()=>iX,DataStorage:()=>HT,DenseBincount:()=>LA,DepthToSpace:()=>zA,DepthwiseConv2dNative:()=>BA,DepthwiseConv2dNativeBackpropFilter:()=>WA,DepthwiseConv2dNativeBackpropInput:()=>VA,Diag:()=>UA,Dilation2D:()=>jA,Dilation2DBackpropFilter:()=>HA,Dilation2DBackpropInput:()=>GA,Draw:()=>qA,ENV:()=>KE,EarlyStopping:()=>k0,Einsum:()=>XA,Elu:()=>YA,EluGrad:()=>QA,Environment:()=>jE,Equal:()=>ZA,Erf:()=>JA,Exp:()=>e_,ExpandDims:()=>t_,Expm1:()=>n_,FFT:()=>r_,Fill:()=>a_,FlipLeftRight:()=>s_,Floor:()=>i_,FloorDiv:()=>o_,FromPixels:()=>cR,FusedBatchNorm:()=>l_,FusedConv2D:()=>pR,FusedDepthwiseConv2D:()=>fR,GPGPUContext:()=>wne,GatherNd:()=>c_,GatherV2:()=>u_,GraphModel:()=>c2,Greater:()=>d_,GreaterEqual:()=>h_,History:()=>sX,IFFT:()=>f_,Identity:()=>p_,Imag:()=>m_,InputSpec:()=>sK,IsFinite:()=>g_,IsInf:()=>y_,IsNan:()=>b_,KernelBackend:()=>qT,LRN:()=>$_,LRNGrad:()=>R_,LayerVariable:()=>nK,LayersModel:()=>oY,LeakyRelu:()=>v_,Less:()=>x_,LessEqual:()=>w_,LinSpace:()=>k_,Log:()=>S_,Log1p:()=>I_,LogSoftmax:()=>A_,LogicalAnd:()=>C_,LogicalNot:()=>N_,LogicalOr:()=>T_,LogicalXor:()=>E_,LowerBound:()=>__,MathBackendCPU:()=>A3,MathBackendWebGL:()=>jre,MatrixBandPart:()=>D_,Max:()=>M_,MaxPool:()=>O_,MaxPool3D:()=>L_,MaxPool3DGrad:()=>z_,MaxPoolGrad:()=>P_,MaxPoolWithArgmax:()=>B_,Maximum:()=>F_,Mean:()=>W_,Min:()=>V_,Minimum:()=>U_,MirrorPad:()=>j_,Mod:()=>G_,MomentumOptimizer:()=>qW,Multinomial:()=>H_,Multiply:()=>q_,Neg:()=>K_,NonMaxSuppressionV3:()=>Y_,NonMaxSuppressionV4:()=>Q_,NonMaxSuppressionV5:()=>J_,NotEqual:()=>X_,OP_SCOPE_SUFFIX:()=>XD,OneHot:()=>e$,OnesLike:()=>Z_,Optimizer:()=>WW,OptimizerConstructors:()=>JV,Pack:()=>t$,PadV2:()=>n$,Pool:()=>r$,Pow:()=>a$,Prelu:()=>s$,Prod:()=>i$,RMSPropOptimizer:()=>KW,RNN:()=>pQ,RaggedGather:()=>o$,RaggedRange:()=>l$,RaggedTensorToTensor:()=>u$,Range:()=>c$,Rank:()=>mD,Real:()=>d$,RealDiv:()=>KA,Reciprocal:()=>h$,Reduction:()=>lW,Relu:()=>p$,Relu6:()=>v$,Reshape:()=>f$,ResizeBilinear:()=>y$,ResizeBilinearGrad:()=>b$,ResizeNearestNeighbor:()=>m$,ResizeNearestNeighborGrad:()=>g$,Reverse:()=>x$,RotateWithOffset:()=>dR,Round:()=>w$,Rsqrt:()=>k$,SGDOptimizer:()=>HW,ScatterNd:()=>S$,SearchSorted:()=>C$,Select:()=>N$,Selu:()=>T$,Sequential:()=>dY,Sigmoid:()=>R$,Sign:()=>$$,Sin:()=>A$,Sinh:()=>_$,Slice:()=>E$,Softmax:()=>L$,Softplus:()=>D$,SpaceToBatchND:()=>O$,SparseFillEmptyRows:()=>z$,SparseReshape:()=>B$,SparseSegmentMean:()=>W$,SparseSegmentSum:()=>V$,SparseToDense:()=>U$,SplitV:()=>P$,Sqrt:()=>M$,Square:()=>G$,SquaredDifference:()=>j$,StaticRegexReplace:()=>H$,Step:()=>uR,StridedSlice:()=>q$,StringNGrams:()=>K$,StringSplit:()=>X$,StringToHashBucketFast:()=>Y$,Sub:()=>Q$,Sum:()=>F$,SymbolicTensor:()=>iK,Tan:()=>J$,Tanh:()=>Z$,Tensor:()=>hD,TensorBuffer:()=>uD,TensorScatterUpdate:()=>I$,Tile:()=>eR,TopK:()=>tR,Transform:()=>nR,Transpose:()=>rR,Unique:()=>aR,Unpack:()=>sR,UnsortedSegmentSum:()=>iR,UpperBound:()=>oR,Variable:()=>fD,ZerosLike:()=>lR,_FusedMatMul:()=>hR,abs:()=>AF,acos:()=>_F,acosh:()=>$F,add:()=>CF,addN:()=>RF,all:()=>DF,any:()=>MF,argMax:()=>FF,argMin:()=>OF,asin:()=>PF,asinh:()=>LF,atan:()=>zF,atan2:()=>BF,atanh:()=>WF,avgPool:()=>aO,avgPool3d:()=>sO,backend:()=>wM,backend_util:()=>rU,basicLSTMCell:()=>dO,batchNorm:()=>fO,batchNorm2d:()=>mO,batchNorm3d:()=>gO,batchNorm4d:()=>yO,batchToSpaceND:()=>hO,bincount:()=>bO,bitwiseAnd:()=>vO,booleanMaskAsync:()=>uB,broadcastArgs:()=>xO,broadcastTo:()=>wO,broadcast_util:()=>GO,browser:()=>vV,buffer:()=>wF,callbacks:()=>C0,cast:()=>kF,ceil:()=>kO,clipByValue:()=>IO,clone:()=>SF,complex:()=>QD,concat:()=>iO,concat1d:()=>CO,concat2d:()=>NO,concat3d:()=>TO,concat4d:()=>EO,constraints:()=>wK,conv1d:()=>_O,conv2d:()=>AO,conv2dTranspose:()=>RO,conv3d:()=>DO,conv3dTranspose:()=>FO,copyRegisteredKernels:()=>NR,cos:()=>OO,cosh:()=>PO,cosineWindow:()=>yB,cumprod:()=>LO,cumsum:()=>zO,customGrad:()=>qP,data:()=>f2,denseBincount:()=>BO,deprecationWarn:()=>sM,depthToSpace:()=>WO,depthwiseConv2d:()=>VO,deregisterOp:()=>A0,device_util:()=>zD,diag:()=>UO,dilation2d:()=>jO,disableDeprecationWarnings:()=>aM,dispose:()=>dM,disposeVariables:()=>iM,div:()=>TF,divNoNan:()=>JO,dot:()=>ZO,dropout:()=>mB,einsum:()=>eP,elu:()=>tP,enableDebugMode:()=>rM,enableProdMode:()=>nM,enclosingPowerOfTwo:()=>gB,engine:()=>oM,ensureShape:()=>nP,env:()=>HE,equal:()=>XO,erf:()=>rP,euclideanNorm:()=>wP,exp:()=>kP,expandDims:()=>SP,expm1:()=>IP,eye:()=>NP,fft:()=>Rz,fill:()=>SO,findBackend:()=>bM,findBackendFactory:()=>vM,floor:()=>TP,floorDiv:()=>NF,forceHalfFloat:()=>Hre,fused:()=>vB,gather:()=>EP,gatherND:()=>fB,gather_util:()=>AV,getBackend:()=>gM,getGradient:()=>xR,getKernel:()=>vR,getKernelsForBackend:()=>wR,getThreadsCount:()=>Hme,gpgpu_util:()=>Jte,grad:()=>VP,grads:()=>UP,greater:()=>AP,greaterEqual:()=>_P,ifft:()=>Dz,imag:()=>$P,image:()=>AW,inTopKAsync:()=>bB,initializers:()=>OK,input:()=>fY,io:()=>YW,irfft:()=>Mz,isFinite:()=>RP,isInf:()=>DP,isNaN:()=>MP,keep:()=>hM,kernel_impls:()=>uj,layers:()=>ZK,leakyRelu:()=>FP,less:()=>OP,lessEqual:()=>PP,linalg:()=>_W,linspace:()=>LP,loadGraphModel:()=>d2,loadGraphModelSync:()=>h2,loadLayersModel:()=>cY,localResponseNormalization:()=>zP,log:()=>BP,log1p:()=>WP,logSigmoid:()=>QP,logSoftmax:()=>ZP,logSumExp:()=>eL,logicalAnd:()=>tL,logicalNot:()=>nL,logicalOr:()=>rL,logicalXor:()=>aL,losses:()=>$W,lowerBound:()=>oL,matMul:()=>oO,math:()=>yV,max:()=>hP,maxPool:()=>lL,maxPool3d:()=>uL,maxPoolWithArgmax:()=>cL,maximum:()=>dL,mean:()=>hL,memory:()=>lM,meshgrid:()=>mL,metrics:()=>JZ,min:()=>pP,minimum:()=>gL,mirrorPad:()=>yL,mod:()=>bL,model:()=>hY,models:()=>f0,moments:()=>vL,movingAverage:()=>dB,mul:()=>EF,multiRNNCell:()=>xL,multinomial:()=>wL,neg:()=>XP,nextFrame:()=>tU,norm:()=>xP,notEqual:()=>kL,oneHot:()=>SL,ones:()=>fL,onesLike:()=>IL,op:()=>YD,outerProduct:()=>CL,pad:()=>NL,pad1d:()=>TL,pad2d:()=>EL,pad3d:()=>AL,pad4d:()=>_L,pool:()=>RL,pow:()=>fP,prelu:()=>DL,print:()=>IF,prod:()=>ML,profile:()=>uM,raggedGather:()=>FL,raggedRange:()=>OL,raggedTensorToTensor:()=>PL,rand:()=>LL,randomGamma:()=>az,randomNormal:()=>sz,randomStandardNormal:()=>iz,randomUniform:()=>oz,randomUniformInt:()=>lz,range:()=>uz,ready:()=>mM,real:()=>cz,reciprocal:()=>dz,registerBackend:()=>xM,registerCallbackConstructor:()=>mY,registerGradient:()=>SR,registerKernel:()=>kR,registerOp:()=>T0,regularizers:()=>m0,relu:()=>hz,relu6:()=>pz,removeBackend:()=>yM,reshape:()=>rO,reverse:()=>fz,reverse1d:()=>mz,reverse2d:()=>gz,reverse3d:()=>yz,reverse4d:()=>bz,rfft:()=>Oz,round:()=>vz,rsqrt:()=>xz,scalar:()=>mP,scatterND:()=>hB,scatter_util:()=>Xz,searchSorted:()=>iL,selu:()=>wz,separableConv2d:()=>kz,sequential:()=>pY,serialization:()=>MW,setBackend:()=>fM,setPlatform:()=>kM,setThreadsCount:()=>Gme,setWasmPath:()=>Wme,setWasmPaths:()=>Vme,setWebGLContext:()=>gee,setdiff1dAsync:()=>Sz,shared:()=>_3,sigmoid:()=>lO,sign:()=>Iz,signal:()=>EW,sin:()=>Cz,sinh:()=>Nz,slice:()=>uO,slice1d:()=>Tz,slice2d:()=>Ez,slice3d:()=>Az,slice4d:()=>_z,slice_util:()=>$V,softmax:()=>$z,softplus:()=>YP,spaceToBatchND:()=>$L,sparse:()=>RW,sparseToDense:()=>pB,spectral:()=>TW,split:()=>Fz,sqrt:()=>gP,square:()=>yP,squaredDifference:()=>Pz,squeeze:()=>Lz,stack:()=>zz,step:()=>Bz,stridedSlice:()=>Wz,string:()=>DW,sub:()=>JP,sum:()=>bP,sumOutType:()=>ID,tan:()=>Vz,tanh:()=>cO,tensor:()=>ZD,tensor1d:()=>Uz,tensor2d:()=>jz,tensor3d:()=>Gz,tensor4d:()=>Hz,tensor5d:()=>qz,tensor6d:()=>Kz,tensorScatterUpdate:()=>Zz,tensor_util:()=>wD,test_util:()=>BL,tidy:()=>cM,tile:()=>CP,time:()=>pM,topk:()=>eB,train:()=>ZV,transpose:()=>cB,truncatedNormal:()=>tB,unique:()=>nB,unregisterGradient:()=>CR,unregisterKernel:()=>IR,unsortedSegmentSum:()=>rB,unstack:()=>aB,upcastType:()=>SD,upperBound:()=>sB,util:()=>ER,valueAndGrad:()=>jP,valueAndGrads:()=>GP,variable:()=>iB,variableGrads:()=>HP,version:()=>Xme,version_converter:()=>p2,version_core:()=>QV,version_cpu:()=>r6,version_layers:()=>VX,version_wasm:()=>qme,version_webgl:()=>Gre,webgl:()=>qre,webgl_util:()=>cee,where:()=>YO,whereAsync:()=>lB,zeros:()=>pL,zerosLike:()=>QO});var gT=Object.create,yT=Object.defineProperty,bT=Object.getOwnPropertyDescriptor,vT=Object.getOwnPropertyNames,xT=Object.getPrototypeOf,wT=Object.prototype.hasOwnProperty,kT=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),ST=(e,t)=>{for(var n in t)yT(e,n,{get:t[n],enumerable:!0})},IT=(e,t,n)=>(n=null!=e?gT(xT(e)):{},((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of vT(t))!wT.call(e,a)&&a!==n&&yT(e,a,{get:()=>t[a],enumerable:!(r=bT(t,a))||r.enumerable});return e})(!t&&e&&e.__esModule?n:yT(n,"default",{value:e,enumerable:!0}),e)),CT=kT(((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(gd){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var s={},i={};function o(e,t){var n,r,a;return t?(a=0<=(e>>>=0)&&e<256)&&(r=i[e])?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(i[e]=n),n):(a=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=u(e,e<0?-1:0,!1),a&&(s[e]=n),n)}function l(e,t){if(isNaN(e))return t?b:y;if(t){if(e<0)return b;if(e>=f)return S}else{if(e<=-m)return I;if(e+1>=m)return k}return e<0?l(-e,t).neg():u(e%p|0,e/p|0,t)}function u(e,t,n){return new r(e,t,n)}r.fromInt=o,r.fromNumber=l,r.fromBits=u;var c=Math.pow;function d(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return y;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return d(e.substring(1),t,n).neg();for(var a=l(c(n,8)),s=y,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),u=parseInt(e.substring(i,i+o),n);if(o<8){var h=l(c(n,o));s=s.mul(h).add(l(u))}else s=(s=s.mul(a)).add(l(u))}return s.unsigned=t,s}function h(e,t){return"number"==typeof e?l(e,t):"string"==typeof e?d(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=d,r.fromValue=h;var p=4294967296,f=p*p,m=f/2,g=o(1<<24),y=o(0);r.ZERO=y;var b=o(0,!0);r.UZERO=b;var v=o(1);r.ONE=v;var x=o(1,!0);r.UONE=x;var w=o(-1);r.NEG_ONE=w;var k=u(-1,2147483647,!1);r.MAX_VALUE=k;var S=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=S;var I=u(0,-2147483648,!1);r.MIN_VALUE=I;var C=r.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},C.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(I)){var t=l(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=l(c(e,6),this.unsigned),s=this,i="";;){var o=s.div(a),u=(s.sub(o.mul(a)).toInt()>>>0).toString(e);if((s=o).isZero())return u+i;for(;u.length<6;)u="0"+u;i=""+u+i}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1===(1&this.low)},C.isEven=function(){return 0===(1&this.low)},C.equals=function(e){return a(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return this.comp(e)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return this.comp(e)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(a(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(v)},C.neg=C.negate,C.add=function(e){a(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,d+=(p+=r+l)>>>16,c+=(d+=n+o)>>>16,c+=t+i,u((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},C.subtract=function(e){return a(e)||(e=h(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return y;if(a(e)||(e=h(e)),n)return u(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return y;if(this.eq(I))return e.isOdd()?I:y;if(e.eq(I))return this.isOdd()?I:y;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return l(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,r=65535&this.high,s=this.low>>>16,i=65535&this.low,o=e.high>>>16,c=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,m=0,b=0,v=0;return b+=(v+=i*p)>>>16,m+=(b+=s*p)>>>16,b&=65535,m+=(b+=i*d)>>>16,f+=(m+=r*p)>>>16,m&=65535,f+=(m+=s*d)>>>16,m&=65535,f+=(m+=i*c)>>>16,f+=t*p+r*d+s*c+i*o,u((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(m&=65535),this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(a(e)||(e=h(e)),e.isZero())throw Error("division by zero");var t,r,s;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:y;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return x;s=b}else{if(this.eq(I))return e.eq(v)||e.eq(w)?I:e.eq(I)?v:(t=this.shr(1).div(e).shl(1)).eq(y)?e.isNegative()?v:w:(r=this.sub(e.mul(t)),s=t.add(r.div(e)));if(e.eq(I))return this.unsigned?b:y;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=y}for(r=this;r.gte(e);){t=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(t)/Math.LN2),o=i<=48?1:c(2,i-48),d=l(t),p=d.mul(e);p.isNegative()||p.gt(r);)p=(d=l(t-=o,this.unsigned)).mul(e);d.isZero()&&(d=v),s=s.add(d),r=r.sub(p)}return s},C.div=C.divide,C.modulo=function(e){return a(e)||(e=h(e)),n?u((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return u(~this.low,~this.high,this.unsigned)},C.and=function(e){return a(e)||(e=h(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return a(e)||(e=h(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return a(e)||(e=h(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}})),NT=kT((()=>{})),TT=kT((()=>{})),ET=kT(((e,t)=>{!function(e,t,n){function r(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new r(e),s=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),AT=kT(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),_T=kT(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),$T=kT(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&(s.x&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),RT=kT(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,a=0==(n=o[127&s]^=r+i)?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&(s.X&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),DT=kT(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),MT=kT((()=>{})),FT=kT(((e,t)=>{!function(e,r,a){var s,i=256,o="random",l=a.pow(i,6),u=a.pow(2,52),c=2*u,d=i-1;function h(t,n,d){var h=[],b=g(m((n=1==n?{entropy:!0}:n||{}).entropy?[t,y(r)]:null==t?function(){try{var t;return s&&(t=s.randomBytes)?t=t(i):(t=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(t)),y(t)}catch(h){var n=e.navigator,a=n&&n.plugins;return[+new Date,e,a,e.screen,y(r)]}}():t,3),h),v=new p(h),x=function(){for(var e=v.g(6),t=l,n=0;e<u;)e=(e+n)*i,t*=i,n=v.g(1);for(;e>=c;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|v.g(4)},x.quick=function(){return v.g(4)/4294967296},x.double=x,g(y(v.S),r),(n.pass||d||function(e,t,n,r){return r&&(r.S&&f(r,v),e.state=function(){return f(v,{})}),n?(a[o]=e,t):e})(x,b,"global"in n?n.global:this==a,n.state)}function p(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);a<i;)o[a]=a++;for(a=0;a<i;a++)o[a]=o[s=d&s+e[a%n]+(t=o[a])],o[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,o=r.S;e--;)t=o[a=d&a+1],n=n*i+o[d&(o[a]=o[s=d&s+t])+(o[s]=t)];return r.i=a,r.j=s,n})(i)}function f(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function m(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(m(e[n],t-1))}catch(vd){}return r.length?r:"string"==a?e:e+"\0"}function g(e,t){for(var n,r=e+"",a=0;a<r.length;)t[d&a]=d&(n^=19*t[d&a])+r.charCodeAt(a++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(g(a.random(),r),"object"==typeof t&&t.exports){t.exports=h;try{s=MT()}catch(A6e){}}else"function"==typeof define&&n.amdO?define((function(){return h})):a["seed"+o]=h}("undefined"!=typeof self?self:e,[],Math)})),OT=kT(((e,t)=>{var n=ET(),r=AT(),a=_T(),s=$T(),i=RT(),o=DT(),l=FT();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l})),PT=kT((()=>{})),LT=kT((()=>{})),zT=kT((()=>{})),BT=kT((()=>{})),WT=kT((()=>{})),VT=kT((()=>{})),UT=kT(((e,t)=>{var r=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||hT,function(t){function r(){return $.buffer!=F&&j($.buffer),P}function a(){return $.buffer!=F&&j($.buffer),L}function s(){return $.buffer!=F&&j($.buffer),z}function i(){return $.buffer!=F&&j($.buffer),B}var o,l,u,c="undefined"!=typeof(t=t||{})?t:{};c.ready=new Promise((function(e,t){o=e,l=t})),"undefined"!=typeof process&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d,h,p,f=Object.assign({},c),m=[],g=(e,t)=>{throw t},y="object"==typeof window,b="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=c.ENVIRONMENT_IS_PTHREAD||!1,w="";function k(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var S=LT(),I=zT();let e;w=b?I.dirname(w)+"/":"//",d=(e,t)=>(e=oe(e)?new URL(e):I.normalize(e),S.readFileSync(e,t?void 0:"utf8")),p=e=>{var t=d(e,!0);return t.buffer||(t=new Uint8Array(t)),t},h=(e,t,n)=>{e=oe(e)?new URL(e):I.normalize(e),S.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),m=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ce))throw e})),process.on("unhandledRejection",(function(e){throw e})),g=(e,t)=>{if(Y())throw process.exitCode=e,t;(function(e){e instanceof ce||E("exiting due to exception: "+e)})(t),process.exit(e)},c.inspect=function(){return"[Emscripten Module object]"};try{e=BT()}catch(Je){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Je}n.g.Worker=e.Worker}else(y||b)&&(b?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),"undefined"!=typeof e&&e&&(w=e),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},b&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),h=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}),e=>document.title=e);v&&"undefined"==typeof performance&&(n.g.performance=WT().performance);var C=console.log.bind(console),N=console.warn.bind(console);v&&(C=e=>S.writeSync(1,e+"\n"),N=e=>S.writeSync(2,e+"\n"));var T=c.print||C,E=c.printErr||N;Object.assign(c,f),f=null,c.arguments&&(m=c.arguments),c.thisProgram&&c.thisProgram,c.quit&&(g=c.quit);var A;Atomics.load,Atomics.store,Atomics.compareExchange;c.wasmBinary&&(A=c.wasmBinary);var _=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&re("no native wasm support detected");var $,R,D,M=!1;var F,O,P,L,z,B,W="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function V(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&W)return W.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,a):e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if((i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function U(e,t){return(e>>>=0)?V(r(),e,t):""}function j(e){F=e,c.HEAP8=O=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=L=new Int32Array(e),c.HEAPU8=P=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=z=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=B=new Float64Array(e)}x&&(F=c.buffer);var G=c.INITIAL_MEMORY||16777216;if(x)$=c.wasmMemory,F=c.buffer;else if(c.wasmMemory)$=c.wasmMemory;else if(!(($=new WebAssembly.Memory({initial:G/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw E("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&E("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");$&&(F=$.buffer),G=F.byteLength,j(F);var H,q=[],K=[],X=[];function Y(){return _}function Q(){!x&&ge(K)}function J(e){q.unshift(e)}function Z(e){X.unshift(e)}var ee=0,te=null,ne=null;function re(e){c.onAbort&&c.onAbort(e),E(e="Aborted("+e+")"),M=!0,D=1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw l(t),t}var ae,se="data:application/octet-stream;base64,";function ie(e){return e.startsWith(se)}function oe(e){return e.startsWith("file://")}function le(e){try{if(e==ae&&A)return new Uint8Array(A);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(Je){re(Je)}}ie(ae="tfjs-backend-wasm-threaded-simd.wasm")||(ae=k(ae));var ue={};function ce(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function de(e){var t=me.pthreads[e];(function(e,t){e||re(t)})(t),me.returnWorkerToPool(t)}function he(e){var t=me.getNewWorker();if(!t)return 6;me.runningWorkers.push(t),me.pthreads[e.pthread_ptr]=t,t.pthread_ptr=e.pthread_ptr;var n={cmd:"run",start_routine:e.startRoutine,arg:e.arg,pthread_ptr:e.pthread_ptr};return t.runPthread=()=>{v&&t.ref(),t.postMessage(n,e.transferList),delete t.runPthread},t.loaded&&t.runPthread(),0}function pe(e){if(x)return Ie(1,1,e);D=e,Y()||(me.terminateAllThreads(),c.onExit&&c.onExit(e),M=!0),g(e,new ce(e))}var fe=function(e,t){if(D=e,!t&&x)throw ye(e),"unwind";pe(e)};var me={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?me.initWorker():me.initMainThread()},initMainThread:function(){for(var e=8;e--;)me.allocateUnusedWorker()},initWorker:function(){_=!1},setExitStatus:function(e){D=e},terminateAllThreads:function(){for(var e of Object.values(me.pthreads))me.returnWorkerToPool(e);for(var e of me.unusedWorkers)e.terminate();me.unusedWorkers=[]},returnWorkerToPool:function(e){var t=e.pthread_ptr;delete me.pthreads[t],me.unusedWorkers.push(e),me.runningWorkers.splice(me.runningWorkers.indexOf(e),1),e.pthread_ptr=0,v&&e.unref(),je(t)},receiveObjectTransfer:function(e){},threadInitTLS:function(){me.tlsInitFunctions.forEach((e=>e()))},loadWasmModuleToWorker:function(t,n){t.onmessage=e=>{var r=e.data,a=r.cmd;if(t.pthread_ptr&&(me.currentProxiedOperationCallerThread=t.pthread_ptr),r.targetThread&&r.targetThread!=Be()){var s=me.pthreads[r.targetThread];return s?s.postMessage(r,r.transferList):E('Internal error! Worker sent a message "'+a+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(me.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===a?ke(r.queue):"spawnThread"===a?he(r):"cleanupThread"===a?de(r.thread):"killThread"===a?function(e){var t=me.pthreads[e];delete me.pthreads[e],t.terminate(),je(e),me.runningWorkers.splice(me.runningWorkers.indexOf(t),1),t.pthread_ptr=0}(r.thread):"cancelThread"===a?function(e){me.pthreads[e].postMessage({cmd:"cancel"})}(r.thread):"loaded"===a?(t.loaded=!0,v&&t.unref(),n&&n(t),t.runPthread&&t.runPthread()):"print"===a?T("Thread "+r.threadId+": "+r.text):"printErr"===a?E("Thread "+r.threadId+": "+r.text):"alert"===a?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?t.postMessage(r):"callHandler"===a?c[r.handler](...r.args):a&&E("worker sent an unknown command "+a),me.currentProxiedOperationCallerThread=void 0},t.onerror=e=>{throw E("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){})));var r=[];for(var a of["onExit","onAbort","print","printErr"])c.hasOwnProperty(a)&&r.push(a);t.postMessage({cmd:"load",handlers:r,urlOrBlob:c.mainScriptUrlOrBlob||e,wasmMemory:$,wasmModule:R})},allocateUnusedWorker:function(){var e,t=k("tfjs-backend-wasm-threaded-simd.worker.js");e=new Worker(t),me.unusedWorkers.push(e)},getNewWorker:function(){return 0==me.unusedWorkers.length&&(me.allocateUnusedWorker(),me.loadWasmModuleToWorker(me.unusedWorkers[0])),me.unusedWorkers.pop()}};function ge(e){for(;e.length>0;)e.shift()(c)}function ye(e){if(x)return Ie(2,0,e);try{fe(e)}catch(Je){!function(e){if(e instanceof ce||"unwind"==e)return D;g(1,e)}(Je)}}c.PThread=me,c.establishStackSpace=function(){var e=Be(),t=a()[e+52>>>2],n=a()[e+56>>>2];He(t,t-n),Ke(t)};var be=[];function ve(e,t,n,r){return x?Ie(3,1,e,t,n,r):xe(e,t,n,r)}function xe(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return E("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];if(x&&0===a.length)return ve(e,t,n,r);var s={startRoutine:n,pthread_ptr:e,arg:r,transferList:a};return x?(s.cmd="spawnThread",postMessage(s,a),0):he(s)}c.invokeEntryPoint=function(e,t){var n=function(e){var t=be[e];return t||(e>=be.length&&(be.length=e+1),be[e]=t=H.get(e)),t}(e)(t);Y()?me.setExitStatus(n):Ge(n)};var we;function ke(e){Atomics.store(a(),e>>2,1),Be()&&Ue(e),Atomics.compareExchange(a(),e>>2,1,0)}function Se(e){Se.shown||(Se.shown={}),Se.shown[e]||(Se.shown[e]=1,v&&(e="warning: "+e),E(e))}function Ie(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=qe(),n=e();return Ke(t),n}((()=>{for(var a=n,s=Xe(8*a),o=s>>3,l=0;l<n;l++){var u=r[2+l];i()[o+l>>>0]=u}return Ve(e,a,s,t)}))}c.executeNotifiedProxyingQueue=ke,we=v?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.timeOrigin+performance.now();var Ce=[];function Ne(e){try{return $.grow(e-F.byteLength+65535>>>16),j($.buffer),1}catch(Je){}}function Te(e){return x?Ie(4,1,e):52}function Ee(e,t,n,r,a){return x?Ie(5,1,e,t,n,r,a):70}var Ae=[null,[],[]];function _e(e,t){var n=Ae[e];0===t||10===t?((1===e?T:E)(V(n,0)),n.length=0):n.push(t)}function $e(e,t,n,a){if(x)return Ie(6,1,e,t,n,a);for(var i=0,o=0;o<n;o++){var l=s()[t>>>2],u=s()[t+4>>>2];t+=8;for(var c=0;c<u;c++)_e(e,r()[l+c>>>0]);i+=u}return s()[a>>>2]=i,0}function Re(e){return c["_"+e]}function De(e,t){($.buffer!=F&&j($.buffer),O).set(e,t>>>0)}function Me(e,t,n,a,s){var i={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);(function(e,t,n){(function(e,t,n,r){if(!(r>0))return 0;for(var a=n>>>=0,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),o<=127){if(n>=s)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=s)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=s)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0})(e,r(),t,n)})(e,t=Xe(n),n)}return t},array:e=>{var t=Xe(e.length);return De(e,t),t}};var o=Re(e),l=[],u=0;if(a)for(var c=0;c<a.length;c++){var d=i[n[c]];d?(0===u&&(u=qe()),l[c]=d(a[c])):l[c]=a[c]}var h,p=o.apply(null,l);return h=p,0!==u&&Ke(u),p=function(e){return"string"===t?U(e):"boolean"===t?!!e:e}(h),p}me.init();var Fe,Oe,Pe,Le=[null,pe,ye,ve,Te,Ee,$e],ze={__emscripten_init_main_thread_js:function(e){We(e,!b,1,!y),me.threadInitTLS()},__emscripten_thread_cleanup:function(e){x?postMessage({cmd:"cleanupThread",thread:e}):de(e)},__pthread_create_js:xe,_emscripten_default_pthread_stack_size:function(){return 65536},_emscripten_get_now_is_monotonic:function(){return true},_emscripten_notify_task_queue:function(e,t,n,r){if(e==t)setTimeout((()=>ke(r)));else if(x)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{var a=me.pthreads[e];if(!a)return;a.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},_emscripten_set_offscreencanvas_size:function(e,t,n){return-1},abort:function(){re("")},emscripten_check_blocking_allowed:function(){v||b||Se("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function(){return Date.now()},emscripten_get_heap_max:function(){return 4294901760},emscripten_get_now:we,emscripten_memcpy_big:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_num_logical_cores:function(){return v?VT().cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(e,t,n){Ce.length=t;for(var r=n>>3,a=0;a<t;a++)Ce[a]=i()[r+a>>>0];return(e<0?ue[-e-1]:Le[e]).apply(null,Ce)},emscripten_resize_heap:function(e){var t=r().length;if((e>>>=0)<=t)return!1;var n,a,s=4294901760;if(e>s)return!1;for(var i=1;i<=4;i*=2){var o=t*(1+.2/i);if(o=Math.min(o,e+100663296),Ne(Math.min(s,(n=Math.max(e,o))+((a=65536)-n%a)%a)))return!0}return!1},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},exit:fe,fd_close:Te,fd_seek:Ee,fd_write:$e,memory:$||c.wasmMemory},Be=(function(){var e={env:ze,wasi_snapshot_preview1:ze};function t(e,t){var n=e.exports;if(c.asm=n,function(e){me.tlsInitFunctions.push(e)}(c.asm._emscripten_tls_init),H=c.asm.__indirect_function_table,function(e){K.unshift(e)}(c.asm.__wasm_call_ctors),R=t,!x){var r=me.unusedWorkers.length;me.unusedWorkers.forEach((function(e){me.loadWasmModuleToWorker(e,(function(){--r||function(){if(ee--,c.monitorRunDependencies&&c.monitorRunDependencies(ee),0==ee&&(null!==te&&(clearInterval(te),te=null),ne)){var e=ne;ne=null,e()}}()}))}))}}function n(e){t(e.instance,e.module)}function r(t){return function(){if(!A&&(y||b)){if("function"==typeof fetch&&!oe(ae))return fetch(ae,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+ae+"'";return e.arrayBuffer()})).catch((function(){return le(ae)}));if(h)return new Promise((function(e,t){h(ae,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return le(ae)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){E("failed to asynchronously prepare wasm: "+e),re(e)}))}if(x||(ee++,c.monitorRunDependencies&&c.monitorRunDependencies(ee)),c.instantiateWasm)try{return c.instantiateWasm(e,t)}catch(a){E("Module.instantiateWasm callback failed with error: "+a),l(a)}(A||"function"!=typeof WebAssembly.instantiateStreaming||ie(ae)||oe(ae)||v||"function"!=typeof fetch?r(n):fetch(ae,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return E("wasm streaming compile failed: "+e),E("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(l)}(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Acos=function(){return(c._Acos=c.asm.Acos).apply(null,arguments)},c._Acosh=function(){return(c._Acosh=c.asm.Acosh).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._ArgMin=function(){return(c._ArgMin=c.asm.ArgMin).apply(null,arguments)},c._Asin=function(){return(c._Asin=c.asm.Asin).apply(null,arguments)},c._Asinh=function(){return(c._Asinh=c.asm.Asinh).apply(null,arguments)},c._Atan=function(){return(c._Atan=c.asm.Atan).apply(null,arguments)},c._Atan2=function(){return(c._Atan2=c.asm.Atan2).apply(null,arguments)},c._Atanh=function(){return(c._Atanh=c.asm.Atanh).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._AvgPool3D=function(){return(c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},c._AvgPool3DGrad=function(){return(c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},c._AvgPoolGrad=function(){return(c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Bincount=function(){return(c._Bincount=c.asm.Bincount).apply(null,arguments)},c._BitwiseAnd=function(){return(c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Conv3D=function(){return(c._Conv3D=c.asm.Conv3D).apply(null,arguments)},c._Conv3DBackpropFilterV2=function(){return(c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},c._Conv3DBackpropInputV2=function(){return(c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DenseBincount=function(){return(c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Diag=function(){return(c._Diag=c.asm.Diag).apply(null,arguments)},c._Dilation2D=function(){return(c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},c._Dilation2DBackpropFilter=function(){return(c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},c._Dilation2DBackpropInput=function(){return(c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._EluGrad=function(){return(c._EluGrad=c.asm.EluGrad).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Erf=function(){return(c._Erf=c.asm.Erf).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._Expm1=function(){return(c._Expm1=c.asm.Expm1).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._IsFinite=function(){return(c._IsFinite=c.asm.IsFinite).apply(null,arguments)},c._IsInf=function(){return(c._IsInf=c.asm.IsInf).apply(null,arguments)},c._IsNan=function(){return(c._IsNan=c.asm.IsNan).apply(null,arguments)},c._LRN=function(){return(c._LRN=c.asm.LRN).apply(null,arguments)},c._LRNGrad=function(){return(c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._LinSpace=function(){return(c._LinSpace=c.asm.LinSpace).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._Log1p=function(){return(c._Log1p=c.asm.Log1p).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._MaxPool3D=function(){return(c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},c._MaxPool3DGrad=function(){return(c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},c._MaxPoolGrad=function(){return(c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},c._MaxPoolWithArgmax=function(){return(c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Mod=function(){return(c._Mod=c.asm.Mod).apply(null,arguments)},c._Multinomial=function(){return(c._Multinomial=c.asm.Multinomial).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Reciprocal=function(){return(c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeBilinearGrad=function(){return(c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._ResizeNearestNeighborGrad=function(){return(c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SearchSorted=function(){return(c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Selu=function(){return(c._Selu=c.asm.Selu).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sign=function(){return(c._Sign=c.asm.Sign).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Sinh=function(){return(c._Sinh=c.asm.Sinh).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._Softplus=function(){return(c._Softplus=c.asm.Softplus).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._SparseToDense=function(){return(c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._TensorScatterUpdate=function(){return(c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)},c._pthread_self=function(){return(Be=c._pthread_self=c.asm.pthread_self).apply(null,arguments)}),We=(c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)},c.__emscripten_thread_init=function(){return(We=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)}),Ve=(c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)},c._emscripten_run_in_main_runtime_thread_js=function(){return(Ve=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),Ue=(c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},c.__emscripten_proxy_execute_task_queue=function(){return(Ue=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),je=c.__emscripten_thread_free_data=function(){return(je=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},Ge=c.__emscripten_thread_exit=function(){return(Ge=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},He=c._emscripten_stack_set_limits=function(){return(He=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},qe=c.stackSave=function(){return(qe=c.stackSave=c.asm.stackSave).apply(null,arguments)},Ke=c.stackRestore=function(){return(Ke=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},Xe=c.stackAlloc=function(){return(Xe=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)};function Ye(e){if(e=e||m,!(ee>0)){if(x)return o(c),Q(),void startWorker(c);(function(){if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)J(c.preRun.shift());ge(q)})(),ee>0||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),t()}),1)):t())}function t(){Fe||(Fe=!0,c.calledRun=!0,!M&&(Q(),o(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),function(){if(!x){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;)Z(c.postRun.shift());ge(X)}}()))}}if(c.keepRuntimeAlive=Y,c.wasmMemory=$,c.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?Re(e):function(){return Me(e,t,n,arguments)}},c.ExitStatus=ce,c.PThread=me,ne=function e(){Fe||Ye(),Fe||(ne=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();if(Ye(),u&&(Oe={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!u.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!u.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)Pe=WasmBackendModule;else{if("undefined"==typeof t)throw new Error("Could not find wasm module in post.js");Pe=t}if(Oe){var Qe=Pe._dispose;Pe._dispose=function(){Qe(),Oe.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Oe.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&n.amdO?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=r)})),jT=kT(((e,t)=>{t.exports.wasmWorkerContents='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'})),GT=kT(((e,t)=>{var r=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||hT,function(t){var n,r,a,s="undefined"!=typeof(t=t||{})?t:{};s.ready=new Promise((function(e,t){n=e,r=t})),"undefined"!=typeof process&&process.listeners&&(a={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i,o,l,u=Object.assign({},s),c=[],d="object"==typeof window,h="function"==typeof importScripts,p="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,f="";if(p){var m=LT(),g=zT();f=h?g.dirname(f)+"/":"//",i=(e,t)=>(e=U(e)?new URL(e):g.normalize(e),m.readFileSync(e,t?void 0:"utf8")),l=e=>{var t=i(e,!0);return t.buffer||(t=new Uint8Array(t)),t},o=(e,t,n)=>{e=U(e)?new URL(e):g.normalize(e),m.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),c=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof G))throw e})),process.on("unhandledRejection",(function(e){throw e})),s.inspect=function(){return"[Emscripten Module object]"}}else(d||h)&&(h?f=self.location.href:"undefined"!=typeof document&&document.currentScript&&(f=document.currentScript.src),e&&(f=e),f=0!==f.indexOf("blob:")?f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},h&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)},e=>document.title=e);var y=s.print||console.log.bind(console),b=s.printErr||console.warn.bind(console);Object.assign(s,u),u=null,s.arguments&&(c=s.arguments),s.thisProgram&&s.thisProgram,s.quit&&s.quit;var v;s.wasmBinary&&(v=s.wasmBinary);var x=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&z("no native wasm support detected");var w,k=!1;var S,I,C,N,T="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function E(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&T)return T.decode(e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if((i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function A(e,t){return(e>>>=0)?E(C,e,t):""}function _(e){S=e,s.HEAP8=I=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=new Int32Array(e),s.HEAPU8=C=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=N=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=new Float64Array(e)}s.INITIAL_MEMORY;var $=[],R=[],D=[];function M(e){$.unshift(e)}function F(e){D.unshift(e)}var O=0,P=null,L=null;function z(e){s.onAbort&&s.onAbort(e),b(e="Aborted("+e+")"),k=!0,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw r(t),t}var B,W="data:application/octet-stream;base64,";function V(e){return e.startsWith(W)}function U(e){return e.startsWith("file://")}function j(e){try{if(e==B&&v)return new Uint8Array(v);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(t){z(t)}}function G(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function H(e){for(;e.length>0;)e.shift()(s)}function q(e){try{return w.grow(e-S.byteLength+65535>>>16),_(w.buffer),1}catch(t){}}V(B="tfjs-backend-wasm.wasm")||(B=function(e){return s.locateFile?s.locateFile(e,f):f+e}(B));var K=[null,[],[]];function X(e,t){var n=K[e];0===t||10===t?((1===e?y:b)(E(n,0)),n.length=0):n.push(t)}function Y(e){return s["_"+e]}function Q(e,t,n,r,a){var s={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);(function(e,t,n){(function(e,t,n,r){if(!(r>0))return 0;for(var a=n>>>=0,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),o<=127){if(n>=s)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=s)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=s)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0})(e,C,t,n)})(e,t=ae(n),n)}return t},array:e=>{var t=ae(e.length);return function(e,t){I.set(e,t>>>0)}(e,t),t}};var i=Y(e),o=[],l=0;if(r)for(var u=0;u<r.length;u++){var c=s[n[u]];c?(0===l&&(l=ne()),o[u]=c(r[u])):o[u]=r[u]}var d,h=i.apply(null,o);return d=h,0!==l&&re(l),h=function(e){return"string"===t?A(e):"boolean"===t?!!e:e}(d),h}var J,Z,ee,te={abort:function(){z("")},emscripten_get_heap_max:function(){return 4294901760},emscripten_memcpy_big:function(e,t,n){C.copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_resize_heap:function(e){var t,n,r=C.length,a=4294901760;if((e>>>=0)>a)return!1;for(var s=1;s<=4;s*=2){var i=r*(1+.2/s);if(i=Math.min(i,e+100663296),q(Math.min(a,(t=Math.max(e,i))+((n=65536)-t%n)%n)))return!0}return!1},fd_close:function(e){return 52},fd_seek:function(e,t,n,r,a){return 70},fd_write:function(e,t,n,r){for(var a=0,s=0;s<n;s++){var i=N[t>>>2],o=N[t+4>>>2];t+=8;for(var l=0;l<o;l++)X(e,C[i+l>>>0]);a+=o}return N[r>>>2]=a,0}},ne=(function(){var e={env:te,wasi_snapshot_preview1:te};function t(e,t){var n=e.exports;s.asm=n,_((w=s.asm.memory).buffer),s.asm.__indirect_function_table,function(e){R.unshift(e)}(s.asm.__wasm_call_ctors),function(){if(O--,s.monitorRunDependencies&&s.monitorRunDependencies(O),0==O&&(null!==P&&(clearInterval(P),P=null),L)){var e=L;L=null,e()}}()}function n(e){t(e.instance)}function a(t){return function(){if(!v&&(d||h)){if("function"==typeof fetch&&!U(B))return fetch(B,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+B+"'";return e.arrayBuffer()})).catch((function(){return j(B)}));if(o)return new Promise((function(e,t){o(B,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return j(B)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){b("failed to asynchronously prepare wasm: "+e),z(e)}))}if(O++,s.monitorRunDependencies&&s.monitorRunDependencies(O),s.instantiateWasm)try{return s.instantiateWasm(e,t)}catch(i){b("Module.instantiateWasm callback failed with error: "+i),r(i)}(v||"function"!=typeof WebAssembly.instantiateStreaming||V(B)||U(B)||p||"function"!=typeof fetch?a(n):fetch(B,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return b("wasm streaming compile failed: "+e),b("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(r)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)},s.stackSave=function(){return(ne=s.stackSave=s.asm.stackSave).apply(null,arguments)}),re=s.stackRestore=function(){return(re=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},ae=s.stackAlloc=function(){return(ae=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)};function se(e){function t(){J||(J=!0,s.calledRun=!0,!k&&(H(R),n(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),function(){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;)F(s.postRun.shift());H(D)}()))}e=e||c,O>0||(function(){if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)M(s.preRun.shift());H($)}(),O>0)||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),t()}),1)):t())}if(s.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?Y(e):function(){return Q(e,t,n,arguments)}},L=function e(){J||se(),J||(L=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();if(se(),a&&(Z={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!a.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!a.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof t)ee=t;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");ee=WasmBackendModuleThreadedSimd}if(Z){var ie=ee._dispose;ee._dispose=function(){ie(),Z.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Z.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&n.amdO?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModule=r)})),HT=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},qT=class{refCount(e){return KT("refCount")}incRef(e){return KT("incRef")}timerAvailable(){return!0}time(e){return KT("time")}read(e){return KT("read")}readSync(e){return KT("readSync")}readToGPU(e,t){return KT("readToGPU")}numDataIds(){return KT("numDataIds")}disposeData(e,t){return KT("disposeData")}write(e,t,n){return KT("write")}move(e,t,n,r,a){return KT("move")}createTensorFromGPUData(e,t,n){return KT("createTensorFromGPUData")}memory(){return KT("memory")}floatPrecision(){return KT("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return KT("dispose")}};function KT(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function XT(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,ZT(e,t,n)}function YT(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,ZT(e,n,r),ZT(t,n,r)}function QT(e,t,n){return Math.max(e,Math.min(t,n))}function JT(e){return e%2===0?e:e+1}function ZT(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function eE(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function tE(e,t){let n=Math.random();return t*n+(1-n)*e}function nE(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function rE(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function aE(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";rE(uE(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function sE(e){rE(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function iE(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function oE(e){return 0===e.length}function lE(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function uE(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function cE(e){return e%1===0}function dE(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function hE(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function pE(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return XT(t),t}function fE(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function mE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,s)=>{let i=0,o=()=>{if(e())return void a();i++;let l=t(i);null!=n&&i>=n?s():null!=r?r(o,l):setTimeout(o,l)};o()}))}function gE(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function yE(e,t){let n=t.length;return rE((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),rE(e.every((e=>cE(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function bE(e,t){let n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:yE(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function vE(e,t){return xE(e,t)}function xE(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function wE(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function kE(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function SE(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function IE(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function CE(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function NE(e){return"string"==typeof e||e instanceof String}function TE(e){return"boolean"==typeof e}function EE(e){return"number"==typeof e}function AE(e){return Array.isArray(e)?AE(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":EE(e)?"float32":NE(e)?"string":TE(e)?"bool":"float32"}function _E(e){return!!(e&&e.constructor&&e.call&&e.apply)}function $E(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function RE(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function DE(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=new Array;if(1===t.length){let s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{let s=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=DE(e+t*o,i,n,r)}return a}function ME(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];let r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return DE(0,e,t,n)}function FE(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function OE(e,t){let n=PE(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function PE(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function LE(e,t){let n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return ME(e,new Float32Array(n));if("int32"===t)return ME(e,new Int32Array(n));if("bool"===t)return ME(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function zE(e){e.forEach((t=>{rE(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function BE(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function WE(e,t,n){if(0===t)return[];if(1===t)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function VE(e){return e&&e.then&&"function"==typeof e.then}var UE="tfjsflags",jE=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=GE,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(HE().getBool("IS_TEST")||HE().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];HE().getBool("IS_TEST")||HE().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(VE(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"==typeof this.global||"undefined"==typeof this.global.location||"undefined"==typeof this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);UE in e&&e[UE].split(",").forEach((e=>{let[t,n]=e.split(":");this.urlFlags[t]=function(e,t){let n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}};function GE(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function HE(){return KE}var qE,KE=null;function XE(){if(null==qE){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}qE=e}return qE}function YE(e,t){let n=function(){let e=XE();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var QE="Abs",JE="Acos",ZE="Acosh",eA="Add",tA="AddN",nA="All",rA="Any",aA="ArgMax",sA="ArgMin",iA="Asin",oA="Asinh",lA="Atan",uA="Atanh",cA="Atan2",dA="AvgPool",hA="AvgPoolGrad",pA="AvgPool3D",fA="AvgPool3DGrad",mA="BatchMatMul",gA="BatchToSpaceND",yA="Bincount",bA="BitwiseAnd",vA="BroadcastTo",xA="BroadcastArgs",wA="Cast",kA="Ceil",SA="ClipByValue",IA="Complex",CA="ComplexAbs",NA="Concat",TA="Conv2D",EA="Conv2DBackpropFilter",AA="Conv2DBackpropInput",_A="Conv3D",$A="Conv3DBackpropFilterV2",RA="Conv3DBackpropInputV2",DA="Cos",MA="Cosh",FA="Cumprod",OA="Cumsum",PA="CropAndResize",LA="DenseBincount",zA="DepthToSpace",BA="DepthwiseConv2dNative",WA="DepthwiseConv2dNativeBackpropFilter",VA="DepthwiseConv2dNativeBackpropInput",UA="Diag",jA="Dilation2D",GA="Dilation2DBackpropInput",HA="Dilation2DBackpropFilter",qA="Draw",KA="RealDiv",XA="Einsum",YA="Elu",QA="EluGrad",JA="Erf",ZA="Equal",e_="Exp",t_="ExpandDims",n_="Expm1",r_="FFT",a_="Fill",s_="FlipLeftRight",i_="Floor",o_="FloorDiv",l_="FusedBatchNorm",u_="GatherV2",c_="GatherNd",d_="Greater",h_="GreaterEqual",p_="Identity",f_="IFFT",m_="Imag",g_="IsFinite",y_="IsInf",b_="IsNan",v_="LeakyRelu",x_="Less",w_="LessEqual",k_="LinSpace",S_="Log",I_="Log1p",C_="LogicalAnd",N_="LogicalNot",T_="LogicalOr",E_="LogicalXor",A_="LogSoftmax",__="LowerBound",$_="LRN",R_="LRNGrad",D_="MatrixBandPart",M_="Max",F_="Maximum",O_="MaxPool",P_="MaxPoolGrad",L_="MaxPool3D",z_="MaxPool3DGrad",B_="MaxPoolWithArgmax",W_="Mean",V_="Min",U_="Minimum",j_="MirrorPad",G_="Mod",H_="Multinomial",q_="Multiply",K_="Neg",X_="NotEqual",Y_="NonMaxSuppressionV3",Q_="NonMaxSuppressionV4",J_="NonMaxSuppressionV5",Z_="OnesLike",e$="OneHot",t$="Pack",n$="PadV2",r$="Pool",a$="Pow",s$="Prelu",i$="Prod",o$="RaggedGather",l$="RaggedRange",u$="RaggedTensorToTensor",c$="Range",d$="Real",h$="Reciprocal",p$="Relu",f$="Reshape",m$="ResizeNearestNeighbor",g$="ResizeNearestNeighborGrad",y$="ResizeBilinear",b$="ResizeBilinearGrad",v$="Relu6",x$="Reverse",w$="Round",k$="Rsqrt",S$="ScatterNd",I$="TensorScatterUpdate",C$="SearchSorted",N$="Select",T$="Selu",E$="Slice",A$="Sin",_$="Sinh",$$="Sign",R$="Sigmoid",D$="Softplus",M$="Sqrt",F$="Sum",O$="SpaceToBatchND",P$="SplitV",L$="Softmax",z$="SparseFillEmptyRows",B$="SparseReshape",W$="SparseSegmentMean",V$="SparseSegmentSum",U$="SparseToDense",j$="SquaredDifference",G$="Square",H$="StaticRegexReplace",q$="StridedSlice",K$="StringNGrams",X$="StringSplit",Y$="StringToHashBucketFast",Q$="Sub",J$="Tan",Z$="Tanh",eR="Tile",tR="TopK",nR="Transform",rR="Transpose",aR="Unique",sR="Unpack",iR="UnsortedSegmentSum",oR="UpperBound",lR="ZerosLike",uR="Step",cR="FromPixels",dR="RotateWithOffset",hR="_FusedMatMul",pR="FusedConv2D",fR="FusedDepthwiseConv2D";function mR(){HE().getBool("IS_TEST")||HE().getBool("PROD")||console.warn(...arguments)}function gR(){HE().getBool("IS_TEST")||HE().getBool("PROD")||console.log(...arguments)}var yR=YE("kernelRegistry",(()=>new Map)),bR=YE("gradRegistry",(()=>new Map));function vR(e,t){let n=TR(e,t);return yR.get(n)}function xR(e){return bR.get(e)}function wR(e){let t=yR.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function kR(e){let{kernelName:t,backendName:n}=e,r=TR(t,n);yR.has(r)&&mR(`The kernel '${t}' for backend '${n}' is already registered`),yR.set(r,e)}function SR(e){let{kernelName:t}=e;bR.has(t)&&HE().getBool("DEBUG")&&mR(`Overriding the gradient for '${t}'`),bR.set(t,e)}function IR(e,t){let n=TR(e,t);if(!yR.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);yR.delete(n)}function CR(e){if(!bR.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);bR.delete(e)}function NR(e,t){wR(e).forEach((e=>{kR(Object.assign({},e,{backendName:t}))}))}function TR(e,t){return`${t}_${e}`}var ER={};function AR(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}ST(ER,{arraysEqual:()=>uE,arraysEqualWithNull:()=>lE,assert:()=>rE,assertNonNegativeIntegerDimensions:()=>zE,assertNonNull:()=>sE,assertShapesMatch:()=>aE,bytesFromStringArray:()=>CE,bytesPerElement:()=>IE,checkConversionForErrors:()=>wE,clamp:()=>QT,computeStrides:()=>RE,convertBackendValuesAndArrayBuffer:()=>FE,createScalarValue:()=>jR,createShuffledIndices:()=>pE,decodeString:()=>XR,distSquared:()=>nE,encodeString:()=>KR,fetch:()=>qR,fingerPrint64:()=>UR,flatten:()=>QR,getArrayFromDType:()=>xE,getTypedArrayFromDType:()=>vE,hasEncodingLoss:()=>SE,hexToLong:()=>RR,indexToLoc:()=>WE,inferDtype:()=>AE,inferFromImplicitShape:()=>gE,isBoolean:()=>TE,isFunction:()=>_E,isInt:()=>cE,isNumber:()=>EE,isPromise:()=>VE,isScalarShape:()=>oE,isString:()=>NE,isTypedArray:()=>YR,isValidDtype:()=>kE,locToIndex:()=>BE,makeOnesTypedArray:()=>OE,makeZerosNestedTypedArray:()=>LE,makeZerosTypedArray:()=>PE,nearestDivisor:()=>$E,nearestLargerEven:()=>JT,now:()=>HR,parseAxisParam:()=>yE,randUniform:()=>tE,repeatedTry:()=>mE,rightPad:()=>fE,shuffle:()=>XT,shuffleCombo:()=>YT,sizeFromShape:()=>iE,sizeToSquarishShape:()=>hE,squeezeShape:()=>bE,sum:()=>eE,swap:()=>ZT,tanh:()=>dE,toNestedArray:()=>ME,toTypedArray:()=>GR});var _R=IT(CT()),$R=_R.default||_R;function RR(e){return $R.fromString(e,!0,16)}var DR=RR("c3a5c85c97cb3127"),MR=RR("b492b66fbe98f273"),FR=RR("9ae16a3b2f90404f");function OR(e){return e.xor(e.shru(47))}function PR(e,t,n){let r=e.slice(t,t+n);return $R.fromBytes(Array.from(r),!0,!0)}function LR(e,t){return PR(e,t,8)}function zR(e,t){return PR(e,t,4)}function BR(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function WR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:RR("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function VR(e,t,n,r){return function(e,t,n,r,a,s){a=a.add(e),s=BR(s.add(a).add(r),21);let i=a;return a=(a=a.add(t)).add(n),s=s.add(BR(a,44)),[a.add(r),s.add(i)]}(LR(e,t),LR(e,t+8),LR(e,t+16),LR(e,t+24),n,r)}function UR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=$R.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){let n=FR.add(2*t),r=LR(e,0).add(FR),a=LR(e,t-8);return WR(BR(a,37).mul(n).add(r),BR(r,25).add(a).mul(n),n)}if(t>=4){let n=FR.add(2*t);return WR(zR(e,0).shl(3).add(t),zR(e,t-4),n)}if(t>0){let n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return OR(FR.mul(n).xor(DR.mul(r))).mul(FR)}return FR}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=FR.add(2*t),r=LR(e,0).mul(MR),a=LR(e,8),s=LR(e,t-8).mul(n),i=LR(e,t-16).mul(FR);return WR(BR(r.add(a),43).add(BR(s,30)).add(i),r.add(BR(a.add(FR),18)).add(s),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=FR.add(2*t),r=LR(e,0).mul(FR),a=LR(e,8),s=LR(e,t-8).mul(n),i=LR(e,t-16).mul(FR),o=BR(r.add(a),43).add(BR(s,30)).add(i),l=WR(o,r.add(BR(a.add(FR),18)).add(s),n),u=LR(e,16).mul(n),c=LR(e,24),d=o.add(LR(e,t-32)).mul(n),h=l.add(LR(e,t-24)).mul(n);return WR(BR(u.add(c),43).add(BR(d,30)).add(h),u.add(BR(c.add(r),18)).add(d),n)}(e,t);let r=n,a=n.mul(MR).add(113),s=OR(a.mul(FR).add(113)).mul(FR),i=[$R.UZERO,$R.UZERO],o=[$R.UZERO,$R.UZERO];r=r.mul(FR).add(LR(e,0));let l=0,u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=BR(r.add(a).add(i[0]).add(LR(e,l+8)),37).mul(MR),a=BR(a.add(i[1]).add(LR(e,l+48)),42).mul(MR),r=r.xor(o[1]),a=a.add(i[0]).add(LR(e,l+40)),s=BR(s.add(o[0]),33).mul(MR),i=VR(e,l,i[1].mul(MR),r.add(o[0])),o=VR(e,l+32,s.add(o[1]),a.add(LR(e,l+16))),[s,r]=[r,s],l+=64}while(l!==u);let d=MR.add(s.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=BR(r.add(a).add(i[0]).add(LR(e,l+8)),37).mul(d),a=BR(a.add(i[1]).add(LR(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(LR(e,l+40))),s=BR(s.add(o[0]),33).mul(d),i=VR(e,l,i[1].mul(d),r.add(o[0])),o=VR(e,l+32,s.add(o[1]),a.add(LR(e,l+16))),[s,r]=[r,s],WR(WR(i[0],o[0],d).add(OR(a).mul(DR)).add(s),WR(i[1],o[1],d).add(r),d)}function jR(e,t){return"string"===t?KR(e):GR([e],t)}function GR(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=QR(e)),HE().getBool("DEBUG")&&wE(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function HR(){return HE().platform.now()}function qR(e,t){return HE().platform.fetch(e,t)}function KR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",HE().platform.encode(e,t)}function XR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",HE().platform.decode(e,t)}function YR(e){return null!=HE().platform.isTypedArray?HE().platform.isTypedArray(e):AR(e)}function QR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||VE(e)||null==e||YR(e)&&n)t.push(e);else if(Array.isArray(e)||YR(e))for(let r=0;r<e.length;++r)QR(e[r],t,n);else{let r=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)QR(e[a],t,n)}return t}var JR=class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new eD)}profileKernel(e,t,n){let r,a,s=()=>{r=n()},i=HR();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let e of r)e.dataSync();a=Promise.resolve({kernelMs:HR()-i})}if(HE().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let t=r[o];t.data().then((n=>{ZR(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}};function ZR(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){let t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}var eD=class{logKernelProfile(e,t,n,r,a,s){let i="number"==typeof r?fE(`${r}ms`,9):r.error,o=fE(e,25),l=t.rank,u=t.size,c=fE(t.shape.toString(),14),d="";for(let h in a){let e=a[h];if(null!=e){let n=e.shape||t.shape,r=n.length;d+=`${h}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};var tD=20,nD=3,rD=7;function aD(e,t,n,r){let a=RE(t),s=function(e,t,n,r){let a=iE(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l="complex64"===n?lD(e):e;if(o>1)for(let u=0;u<a/s;u++){let e=u*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],sD(l[e+t],0,n).length)}return i}(e,t,n,a),i=t.length,o=oD(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function sD(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(rD))} + ${parseFloat(e[1].toFixed(rD))}j`:NE(e)?`'${e}'`:"bool"===n?iD(e):parseFloat(e.toFixed(rD)).toString(),fE(r,t)}function iD(e){return 0===e?"false":"true"}function oD(e,t,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[sD(lD(e)[0],0,n)]}return"bool"===n?[iD(e[0])]:[e[0].toString()]}if(1===l){if(o>tD){let t=nD*i,r=Array.from(e.slice(0,t)),s=Array.from(e.slice((o-nD)*i,o*i));return"complex64"===n&&(r=lD(r),s=lD(s)),["["+r.map(((e,t)=>sD(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>sD(e,a[o-nD+t],n))).join(", ")+"]"]}return["["+("complex64"===n?lD(e):Array.from(e)).map(((e,t)=>sD(e,a[t],n))).join(", ")+"]"]}let u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>tD){for(let t=0;t<nD;t++){let r=t*d,s=r+d;h.push(...oD(e.slice(r,s),u,n,c,a,!1))}h.push("...");for(let t=o-nD;t<o;t++){let r=t*d,s=r+d;h.push(...oD(e.slice(r,s),u,n,c,a,t===o-1))}}else for(let m=0;m<o;m++){let t=m*d,r=t+d;h.push(...oD(e.slice(t,r),u,n,c,a,m===o-1))}let p=2===l?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(s?"":f),h}function lD(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var uD=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=iE(e),null!=n){let e=n.length;rE(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||xE(t,this.size),this.strides=RE(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),rE(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));let a=this.locToIndex(n);this.values[a]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(let s of t){if(s<0||s>=this.shape[r]){let e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let a=t[t.length-1];for(let s=0;s<t.length-1;++s)a+=this.strides[s]*t[s];return this.values[a]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return cD().makeTensor(this.values,this.shape,this.dtype)}},cD=null,dD=null;var hD=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=iE(e),this.strides=RE(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return dD.buffer(this.shape,this.dtype,e)}bufferSync(){return dD.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return ME(this.shape,e,"complex64"===this.dtype)}arraySync(){return ME(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=cD().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map((e=>XR(e)))}catch(Lye){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),cD().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=cD().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>XR(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await cD().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),cD().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return dD.print(this,e)}clone(){return this.throwIfDisposed(),dD.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return aD(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),dD.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),cD().makeVariable(this,e,t,n)}};function pD(){return YE("Tensor",(()=>hD))}Object.defineProperty(hD,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),pD();var fD=class extends hD{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!uE(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);cD().disposeTensor(this),this.dataId=e.dataId,cD().incRef(this,null)}dispose(){cD().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(fD,Symbol.hasInstance,{value:e=>e instanceof hD&&null!=e.assign&&e.assign instanceof Function});var mD,gD,yD,bD,vD,xD,wD={};ST(wD,{assertTypesMatch:()=>ED,getTensorsInContainer:()=>_D,isTensorInList:()=>AD,makeTypesMatch:()=>TD}),(gD=mD||(mD={})).R0="R0",gD.R1="R1",gD.R2="R2",gD.R3="R3",gD.R4="R4",gD.R5="R5",gD.R6="R6",function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(yD||(yD={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(bD||(bD={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(vD||(vD={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(xD||(xD={}));var kD={float32:vD,int32:yD,bool:bD,complex64:xD};function SD(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return kD[e][t]}function ID(e){return SD(e,"int32")}function CD(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function ND(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function TD(e,t){if(e.dtype===t.dtype)return[e,t];let n=SD(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function ED(e,t){rE(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function AD(e,t){return t.some((t=>t.id===e.id))}function _D(e){let t=[];return $D(e,t,new Set),t}function $D(e,t,n){if(null==e)return;if(e instanceof hD)return void t.push(e);if(!function(e){return Array.isArray(e)||"object"==typeof e}(e))return;let r=e;for(let a in r){let e=r[a];n.has(e)||(n.add(e),$D(e,t,n))}}function RD(e){return null!=e.kernelName}var DD=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},MD=class e{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new DD}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(mR(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new JR(this.backendInstance),!0}setupRegisteredKernels(){wR(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){wR(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(!n||n instanceof qT||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,mR(`Initialization of backend ${e} failed`),mR(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return mR(`Initialization of backend ${e} failed`),mR(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(zge){throw t(),zge}}nextTensorId(){return e.nextTensorId++}nextVariableId(){return e.nextVariableId++}clone(e){let t=OD.runKernel(p_,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{let t={x:e},n={dtype:"float32"};return OD.runKernel(wA,t,n)}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==vR(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n,r=[],a=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let o,l=RD(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(RD(e)){let{kernelName:t,inputs:s,attrs:i}=e;null==this.backendName&&this.backend;let l=vR(t,this.backendName);rE(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),n=()=>{let e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:i,backend:this.backend});let n=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let u=n.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){let e=this.getTensorsForGradient(t,s,u);r=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,s=e=>{a&&(r=e.map((e=>this.keep(this.clone(e)))))};n=()=>{let e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));let n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}let u,{inputs:c,attrs:d}=e,h=RD(e)?null:e.backwardsFunc;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(u=this.profiler.profileKernel(l,c,(()=>n())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(u),t=u.outputs):t=n()})),a&&this.addTapeNode(l,c,t,h,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((e=>null!=c[e]?c[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:u.timeMs,extraInfo:u.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){let r=xR(e);if(null!=r){let e,a=r.inputsToSave||[],s=r.outputsToSave||[];r.saveAllInputs?(rE(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),e=Object.keys(t).map((e=>t[e]))):e=a.map((e=>t[e]));let i=n.filter(((e,t)=>s[t]));return e.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&NE(e[0])&&(a=e.map((e=>KR(e))));let s=r.write(a,t,n),i=new hD(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){let e=this.state.tensorInfo.get(s),t=CE(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){let a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:a}=e,s=new hD(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));let a=new fD(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*IE(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof fD||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*IE(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=xR(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){let e=n[t],r=PE(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=_D(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){let e=this.state.activeScope.track[a];!e.kept&&!n.has(e.id)&&e.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{!e.kept&&e.scopeId===r.id&&this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(rE(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));rE(a instanceof hD,(()=>"The result y returned by f() must be a tensor."));let s=function(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let n=e[l],s=n.inputs;for(let e in s){let i=s[e],o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[n.id]=!0;break}if(o)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(let e in n)s[n[e].id]=!0,i[t.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let t=e[l];if(a[t.id]&&i[t.id]){let e={};for(let a in t.inputs){let n=t.inputs[a];r[n.id]&&(e[a]=n)}let n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{let e={};e[a.id]=null==n?function(e){let t=OE(iE(e),"float32");return OD.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach((t=>{let n=e[t.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);let a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let i=s.inputs[t];if(!uE(a.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{let t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}(e,s,(e=>this.tidy(e)),PD);let r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(let t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){var t=this;return rE(_E(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];rE(r.every((e=>e instanceof hD)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));let s,i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(s=e(...r,n),rE(s.value instanceof hD,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),rE(_E(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(e,t)=>{let n=s.gradFunc(e,t),a=Array.isArray(n)?n:[n];rE(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),rE(a.every((e=>e instanceof hD)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));let i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=HR(),n=await this.backend.time(e);return n.wallMs=HR()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new DD;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function FD(){let e=XE();if(null==e._tfengine){let t=new jE(e);e._tfengine=new MD(t)}return function(e){KE=e}(e._tfengine.ENV),function(e){cD=e}((()=>e._tfengine)),e._tfengine}MD.nextTensorId=0,MD.nextVariableId=0;var OD=FD();function PD(e,t){let n={a:e,b:t};return OD.runKernel(eA,n)}var LD,zD={};function BD(e){LD=e}function WD(e){if(void 0!==LD)return LD;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function VD(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}ST(zD,{isBrowser:()=>VD,isMobile:()=>WD,mockIsMobile:()=>BD});var UD=HE();function jD(e,t){let n=e;if(YR(e))return"string"===t?[]:[e.length];if(CD(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(ND(e))return[e.buffer.size/(null==t?4:IE(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||YR(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&HE().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&GD(e,r,[]),r}function GD(e,t,n){if(n=n||[],!Array.isArray(e)&&!YR(e))return void rE(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));rE(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),rE(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));let r=t.slice(1);for(let a=0;a<e.length;++a)GD(e[a],r,n.concat(a))}function HD(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function qD(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof pD())return HD(r,e.dtype,t,n),e;let a=AE(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),HD(r,a,t,n),null==e||!YR(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let s=jD(e,a);!YR(e)&&!Array.isArray(e)&&(e=[e]);let i="string"!==a?GR(e,a):QR(e,[],!0);return OD.makeTensor(i,s,a)}function KD(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>qD(e,`${t}[${a}]`,n,r)))}UD.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),UD.registerFlag("IS_BROWSER",(()=>VD())),UD.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&"undefined"!=typeof process.versions&&"undefined"!=typeof process.versions.node)),UD.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),UD.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),UD.registerFlag("PROD",(()=>!1)),UD.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>UD.getBool("DEBUG"))),UD.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),UD.registerFlag("IS_TEST",(()=>!1)),UD.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>UD.getBool("DEBUG"))),UD.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),UD.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),UD.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));var XD="__op";function YD(e){let t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=XD;let a=function(){OD.startScope(n);try{let e=r(...arguments);return VE(e)&&console.error("Cannot return a Promise inside of tidy."),OD.endScope(e),e}catch(e){throw OD.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}var QD=YD({complex_:function(e,t){let n=qD(e,"real","complex"),r=qD(t,"imag","complex");aE(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return OD.runKernel(IA,a)}});function JD(e,t,n,r){if(null==r)r=AE(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(ND(e)||CD(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return OD.backend.createTensorFromGPUData(e,t||n,r)}if(!YR(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){zE(t);let e=iE(t),r=iE(n);rE(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){let e=n[a],r=a!==n.length-1||e!==iE(t.slice(a));rE(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return!YR(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e="string"!==r?GR(e,r):QR(e,[],!0),OD.makeTensor(e,t,r)}function ZD(e,t,n){return JD(e,t,jD(e,n),n)}var eM={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},tM=class e{static join(t){return new e(t).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),0===(e=e.map((e=>YR(e)?e.buffer:e))).length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){let r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);let n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);let r=new ArrayBuffer(t-e),a=new Uint8Array(r),s=0;for(let i=n;i<this.shards.length;i++){let n=this.shards[i],r=e+s-n.start,o=s,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(a.set(u,o),s+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;let n=function(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,s=t(e[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}};function nM(){HE().set("PROD",!0)}function rM(){HE().set("DEBUG",!0)}function aM(){HE().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function sM(e){HE().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function iM(){OD.disposeVariables()}function oM(){return OD}function lM(){return OD.memory()}function uM(e){return OD.profile(e)}function cM(e,t){return OD.tidy(e,t)}function dM(e){_D(e).forEach((e=>e.dispose()))}function hM(e){return OD.keep(e)}function pM(e){return OD.time(e)}function fM(e){return OD.setBackend(e)}function mM(){return OD.ready()}function gM(){return OD.backendName}function yM(e){OD.removeBackend(e)}function bM(e){return OD.findBackend(e)}function vM(e){return OD.findBackendFactory(e)}function xM(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return OD.registerBackend(e,t,n)}function wM(){return OD.backend}function kM(e,t){HE().setPlatform(e,t)}!function(e){e}(sM);var SM=4;async function IM(e,t){let n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<a.length;++s){let i=a[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);let l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise((async e=>{let t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+SM*t.length,r=new Uint8Array(n),a=0;for(let s=0;s<t.length;s++){let e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=SM,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:$M(await Promise.all(r)),specs:n}}function CM(e,t){let n=new tM(e),r={},a=0;for(let s of t){let e=NM(s,((e,t)=>n.slice(a+e,a+t)));r[s.name]=EM(s,n.slice(a,a+e)),a+=e}return r}function NM(e,t){let n,r=iE(e.shape);if("quantization"in e){let t=e.quantization;n=eM[t.dtype]}else{if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=SM+new Uint32Array(t(e,e+SM))[0];return e}n=eM[e.dtype]}return r*n}async function TM(e,t){let n,r=iE(e.shape);if("quantization"in e){let t=e.quantization;n=eM[t.dtype]}else{if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=SM+new Uint32Array(await t(e,e+SM))[0];return e}n=eM[e.dtype]}return r*n}function EM(e,t){let n,r=e.name,a=e.dtype,s=e.shape,i=iE(s),o=0;if("quantization"in e){let s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${a}.`)}let l=eM[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===s.dtype||"uint16"===s.dtype){n=new Float32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);n=function(){let e=function(){let e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){let a=r[i],o=e[n[a>>10]+(1023&a)]+t[a>>10];s[i]=o}return new Float32Array(a)}}()(u)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${r}': ${a}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);n=new Int32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=Math.round(t*s.scale+s.min)}}o+=i*l}else if("string"===a){let r=iE(e.shape);n=[];for(let e=0;e<r;e++){let e=new Uint32Array(t.slice(o,o+SM))[0];o+=SM;let r=new Uint8Array(t.slice(o,o+e));n.push(r),o+=e}}else{let e=eM[a];if("float32"===a)n=new Float32Array(t);else if("int32"===a)n=new Int32Array(t);else{if("bool"!==a){if("complex64"===a){n=new Float32Array(t);let e=new Float32Array(n.length/2),r=new Float32Array(n.length/2);for(let t=0;t<e.length;t++)e[t]=n[2*t],r[t]=n[2*t+1];let a=ZD(e,s,"float32"),i=ZD(r,s,"float32"),o=QD(a,i);return a.dispose(),i.dispose(),o}throw new Error(`Unsupported dtype in weight '${r}': ${a}`)}n=new Uint8Array(t)}o+=i*e}return ZD(n,s,a)}async function AM(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:t,value:a}=await e.read();if(t&&null==a){let e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}let s=new Uint8Array(r.length+a.byteLength);s.set(r,0),s.set(new Uint8Array(a),r.length),r=s}return r.buffer}async function _M(e,t){let n={},r=e.getReader(),a=new ArrayBuffer(0);for(let s of t){let e=await TM(s,(async(e,t)=>(a=await AM(r,a,t),a.slice(e,t))));a=await AM(r,a,e);let t=a.slice(0,e);a=a.slice(e);let i=EM(s,t);if(n[s.name]=i,"webgpu"===gM()){let e=wM();"uploadToGPU"in e&&iE(i.shape)>=HE().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function $M(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));let r=new Uint8Array(t),a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}var RM="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function DM(e){return RM?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function MM(e){return tM.join(e)}function FM(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function OM(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function PM(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function LM(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),PM(e,n,r)}function zM(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:DM(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:DM(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new tM(e.weightData).byteLength}}function BM(e){let t=[];for(let n of e)t.push(...n.weights);return t}var WM=class e{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==e.instance&&(e.instance=new e),e.instance}static registerSaveRouter(t){e.getInstance().saveRouters.push(t)}static registerLoadRouter(t){e.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return e.getHandlers(t,"save")}static getLoadHandlers(t,n){return e.getHandlers(t,"load",n)}static getHandlers(t,n,r){let a=[];return("load"===n?e.getInstance().loadRouters:e.getInstance().saveRouters).forEach((e=>{let n=e(t,r);null!==n&&a.push(n)})),a}},VM=e=>WM.registerSaveRouter(e),UM=e=>WM.registerLoadRouter(e),jM=e=>WM.getSaveHandlers(e),GM=(e,t)=>WM.getLoadHandlers(e,t),HM="tensorflowjs",qM="models_store",KM="model_info_store";function XM(){if(!HE().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function YM(e){let t=e.result;t.createObjectStore(qM,{keyPath:"modelPath"}),t.createObjectStore(KM,{keyPath:"modelPath"})}var QM=class{constructor(e){if(this.indexedDB=XM(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{let r=this.indexedDB.open(HM,1);r.onupgradeneeded=()=>YM(r),r.onsuccess=()=>{let a=r.result;if(null==t){let t=a.transaction(qM,"readonly"),r=t.objectStore(qM).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=tM.join(t.weightData);let r,i,o=zM(t),l=a.transaction(KM,"readwrite"),u=l.objectStore(KM);try{r=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(s){return n(s)}r.onsuccess=()=>{i=a.transaction(qM,"readwrite");let r,s=i.objectStore(qM);try{r=s.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(c){return n(c)}r.onsuccess=()=>e({modelArtifactsInfo:o}),r.onerror=e=>{u=l.objectStore(KM);let t=u.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(r.error)),t.onerror=e=>(a.close(),n(r.error))}},r.onerror=e=>(a.close(),n(r.error)),l.oncomplete=()=>{null==i?a.close():i.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}};QM.URL_SCHEME="indexeddb://";var JM=e=>HE().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(QM.URL_SCHEME)?function(e){return new QM(e)}(e.slice(QM.URL_SCHEME.length)):null;WM.registerSaveRouter(JM),WM.registerLoadRouter(JM);var ZM="/",eF="tensorflowjs_models",tF="info",nF="model_topology",rF="weight_specs",aF="weight_data",sF="model_metadata";function iF(e){return{info:[eF,e,tF].join(ZM),topology:[eF,e,nF].join(ZM),weightSpecs:[eF,e,rF].join(ZM),weightData:[eF,e,aF].join(ZM),modelMetadata:[eF,e,sF].join(ZM)}}function oF(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function lF(e){let t=e.split(ZM);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(ZM)}var uF=class{constructor(e){if(!HE().getBool("IS_BROWSER")||"undefined"==typeof window||"undefined"==typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=iF(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=zM(e),s=tM.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(RM)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(s));let t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw oF(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(RM){let t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(s),t}};uF.URL_SCHEME="localstorage://";var cF=e=>HE().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(uF.URL_SCHEME)?function(e){return new uF(e)}(e.slice(uF.URL_SCHEME.length)):null;WM.registerSaveRouter(cF),WM.registerLoadRouter(cF);var dF="://",hF=class e{constructor(){this.managers={}}static getInstance(){return null==e.instance&&(e.instance=new e),e.instance}static registerManager(t,n){rE(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(dF)&&(t=t.slice(0,t.indexOf(dF))),rE(t.length>0,(()=>"scheme must not be an empty string."));let r=e.getInstance();rE(null==r.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),r.managers[t]=n}static getManager(t){let n=e.getInstance().managers[t];if(null==n)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(e.getInstance().managers)}};function pF(e){if(-1===e.indexOf(dF))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${hF.getSchemes().join(",")}`);return{scheme:e.split(dF)[0],path:e.split(dF)[1]}}async function fF(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];rE(e!==t,(()=>`Old path and new path are the same: '${e}'`));let r=WM.getLoadHandlers(e);rE(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),rE(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));let a=r[0],s=WM.getSaveHandlers(t);rE(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),rE(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));let i=s[0],o=pF(e).scheme,l=pF(e).path,u=o===pF(e).scheme,c=await a.load();n&&u&&await hF.getManager(o).removeModel(l);let d=await i.save(c);return n&&!u&&await hF.getManager(o).removeModel(l),d.modelArtifactsInfo}async function mF(){let e=hF.getSchemes(),t={};for(let n of e){let e=await hF.getManager(n).listModels();for(let r in e){t[n+dF+r]=e[r]}}return t}async function gF(e){let t=pF(e);return hF.getManager(t.scheme).removeModel(t.path)}async function yF(e,t){return fF(e,t,!1)}async function bF(e,t){return fF(e,t,!0)}if(HE().get("IS_BROWSER")){HE().setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&HE().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return AR(e)}});try{hF.registerManager(uF.URL_SCHEME,new class{constructor(){rE(HE().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),rE("undefined"==typeof window||"undefined"!=typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){let e={},t=eF+ZM,n=ZM+tF;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);a.startsWith(t)&&a.endsWith(n)&&(e[lF(a)]=JSON.parse(this.LS.getItem(a)))}return e}async removeModel(e){let t=iF(e=function(e){return e.startsWith(uF.URL_SCHEME)?e.slice(uF.URL_SCHEME.length):e}(e));if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return oF(t),n}})}catch(gD){}try{hF.registerManager(QM.URL_SCHEME,new class{constructor(){this.indexedDB=XM()}async listModels(){return new Promise(((e,t)=>{let n=this.indexedDB.open(HM,1);n.onupgradeneeded=()=>YM(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(KM,"readonly"),s=a.objectStore(KM).getAll();s.onsuccess=()=>{let t={};for(let e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){return e=function(e){return e.startsWith(QM.URL_SCHEME)?e.slice(QM.URL_SCHEME.length):e}(e),new Promise(((t,n)=>{let r=this.indexedDB.open(HM,1);r.onupgradeneeded=()=>YM(r),r.onsuccess=()=>{let a,s=r.result,i=s.transaction(KM,"readwrite"),o=i.objectStore(KM),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=o.delete(e),i=()=>{a=s.transaction(qM,"readwrite");let r=a.objectStore(qM).delete(e);r.onsuccess=()=>t(l.result.modelArtifactsInfo),r.onerror=e=>n(l.error)};r.onsuccess=i,r.onerror=e=>(i(),s.close(),n(l.error))}},l.onerror=e=>(s.close(),n(l.error)),i.oncomplete=()=>{null==a?s.close():a.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}})}catch(gD){}}var vF,xF=()=>NT();function wF(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",zE(e),new uD(e,t,n)}HE().get("IS_NODE")&&!HE().get("IS_BROWSER")&&HE().setPlatform("node",new class{constructor(){this.util=TT(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=HE().global.fetch?HE().global.fetch(e,t):(null==vF&&(vF=xF()),vF(e,t))}now(){let e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});var kF=YD({cast_:function(e,t){let n=qD(e,"x","cast");if(!kE(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return OD.runKernel(wA,r,a)}});var SF=YD({clone_:function(e){let t={x:qD(e,"x","clone","string_or_numeric")};return OD.runKernel(p_,t)}});function IF(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}FD(),function(e){dD=e}({buffer:wF,cast:kF,clone:SF,print:IF});var CF=YD({add_:function(e,t){let n=qD(e,"a","add"),r=qD(t,"b","add");[n,r]=TD(n,r);let a={a:n,b:r};return OD.runKernel(eA,a)}});var NF=YD({floorDiv_:function(e,t){let n=qD(e,"a","floorDiv"),r=qD(t,"b","floorDiv");[n,r]=TD(n,r);let a={a:n,b:r};return OD.runKernel(o_,a)}});var TF=YD({div_:function(e,t){let n=qD(e,"a","div"),r=qD(t,"b","div");if([n,r]=TD(n,r),"int32"===n.dtype&&"int32"===r.dtype)return NF(n,r);let a={a:n,b:r};return OD.runKernel(KA,a,{})}});var EF=YD({mul_:function(e,t){let n=qD(e,"a","mul"),r=qD(t,"b","mul");[n,r]=TD(n,r);let a={a:n,b:r};return OD.runKernel(q_,a)}});var AF=YD({abs_:function(e){let t=qD(e,"x","abs");if("complex64"===t.dtype){let e={x:t};return OD.runKernel(CA,e)}{let e={x:t};return OD.runKernel(QE,e)}}});var _F=YD({acos_:function(e){let t={x:qD(e,"x","acos")};return OD.runKernel(JE,t)}});var $F=YD({acosh_:function(e){let t={x:qD(e,"x","acosh")};return OD.runKernel(ZE,t)}});var RF=YD({addN_:function(e){rE(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),rE(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));let t=e.map(((e,t)=>qD(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!uE(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));let r=t;return OD.runKernel(tA,r)}});var DF=YD({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:qD(e,"x","all","bool")},a={axis:t,keepDims:n};return OD.runKernel(nA,r,a)}});var MF=YD({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:qD(e,"x","any","bool")},a={axis:t,keepDims:n};return OD.runKernel(rA,r,a)}});var FF=YD({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:qD(e,"x","argMax")},r={axis:t};return OD.runKernel(aA,n,r)}});var OF=YD({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:qD(e,"x","argMin")},r={axis:t};return OD.runKernel(sA,n,r)}});var PF=YD({asin_:function(e){let t={x:qD(e,"x","asin")};return OD.runKernel(iA,t)}});var LF=YD({asinh_:function(e){let t={x:qD(e,"x","asinh")};return OD.runKernel(oA,t)}});var zF=YD({atan_:function(e){let t={x:qD(e,"x","atan")};return OD.runKernel(lA,t)}});var BF=YD({atan2_:function(e,t){let n=qD(e,"a","atan2"),r=qD(t,"b","atan2");[n,r]=TD(n,r);let a={a:n,b:r};return OD.runKernel(cA,a)}});var WF=YD({atanh_:function(e){let t={x:qD(e,"x","atanh")};return OD.runKernel(uA,t)}});function VF(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return GF(e,[...t,e[3]],n,s,r,null,null,tO(a))}function UF(e,t,n,r,a,s){let i,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",[l,u]=KF(t);if("channelsLast"===o)i=[l,u,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);i=[l,u,e[1],e[1]]}return GF(e,i,n,r,a,s,!1,o)}function jF(e,t,n,r,a,s){let i,o,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC",[u,c,d]=XF(t);if("NDHWC"===l)o="channelsLast",i=[u,c,d,e[4],e[4]];else{if("NCDHW"!==l)throw new Error(`Unknown dataFormat ${l}`);o="channelsFirst",i=[u,c,d,e[1],e[1]]}return HF(e,i,n,r,a,!1,o,s)}function GF(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,c]=e}let h,[p,f,,m]=t,[g,y]=KF(n),[b,v]=KF(r),x=YF(p,b),w=YF(f,v),{padInfo:k,outHeight:S,outWidth:I}=function(e,t,n,r,a,s,i,o,l){let u,c,d;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};let a=function(e,t,n,r,a){null==r&&(r=qF(e,t,n));let s=e[0],i=e[1],o=QF((s-t+2*r)/n+1,a),l=QF((i-t+2*r)/n+1,a);return[o,l]}([t,n],s,r,e,o);c=a[0],d=a[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/a);let e=Math.max(0,(c-1)*r+s-t),o=Math.max(0,(d-1)*a+i-n),l=Math.floor(e/2),h=e-l,p=Math.floor(o/2);u={top:l,bottom:h,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/r),d=Math.ceil((n-i+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{let h="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=QF((t-s+h+p)/r+1,o),d=QF((n-i+f+m)/a+1,o)}}return{padInfo:u,outHeight:c,outWidth:d}}(a,u,c,g,y,x,w,s,o),C=i?m*d:m;return"channelsFirst"===o?h=[l,C,S,I]:"channelsLast"===o&&(h=[l,S,I,C]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:S,outWidth:I,outChannels:C,padInfo:k,strideHeight:g,strideWidth:y,filterHeight:p,filterWidth:f,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:v,inShape:e,outShape:h,filterShape:t}}function HF(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=e}let p,[f,m,g,,y]=t,[b,v,x]=XF(n),[w,k,S]=XF(r),I=YF(f,w),C=YF(m,k),N=YF(g,S),{padInfo:T,outDepth:E,outHeight:A,outWidth:_}=function(e,t,n,r,a,s,i,o,l,u,c){let d,h,p,f;if("valid"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};let m=function(e,t,n,r,a,s){null==a&&(a=qF(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=QF((e[o]-t[o]+2*a)/r[o]+1,s));return i}([t,n,r,1],[o,l,u],1,[a,s,i],e,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(t/a),p=Math.ceil(n/s),f=Math.ceil(r/i);let e=(h-1)*a+o-t,c=(p-1)*s+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),v=c-b,x=Math.floor(m/2);d={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(a,u,c,d,b,v,x,I,C,N,o),$=s?y*h:y;return"channelsFirst"===i?p=[l,$,E,A,_]:"channelsLast"===i&&(p=[l,E,A,_,$]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:E,outHeight:A,outWidth:_,outChannels:$,padInfo:T,strideDepth:b,strideHeight:v,strideWidth:x,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:I,effectiveFilterHeight:C,effectiveFilterWidth:N,dilationDepth:w,dilationHeight:k,dilationWidth:S,inShape:e,outShape:p,filterShape:t}}function qF(e,t,n){let r=YF(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function KF(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function XF(e){return"number"==typeof e?[e,e,e]:e}function YF(e,t){return t<=1?e:e+(e-1)*(t-1)}function QF(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function JF(e){let[t,n,r]=KF(e);return 1===t&&1===n&&1===r}function ZF(e,t){return JF(e)||JF(t)}function eO(e){return KF(e).every((e=>e>0))}function tO(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function nO(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)rE(cE(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{rE(cE(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}var rO=YD({reshape_:function(e,t){let n={x:qD(e,"x","reshape","string_or_numeric")},r={shape:t};return OD.runKernel(f$,n,r)}});var aO=YD({avgPool_:function(e,t,n,r,a){let s=qD(e,"x","avgPool","float32");rE(ZF(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=s,o=!1;3===s.rank&&(o=!0,i=rO(s,[1,s.shape[0],s.shape[1],s.shape[2]])),rE(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),nO("avgPool",r,a);let l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=OD.runKernel(dA,l,u);return c=kF(c,s.dtype),o?rO(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var sO=YD({avgPool3d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC",i=qD(e,"x","avgPool3d","float32"),o=i,l=!1;4===i.rank&&(l=!0,o=rO(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),rE(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),rE("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),rE("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),nO("avgPool3d",r,a);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=OD.runKernel(pA,u,c);return d=kF(d,o.dtype),l?rO(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var iO=YD({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;rE(e.length>=1,(()=>"Pass at least one tensor to concat"));let n=KD(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return SF(n[0]);let r=n,a={axis:t};return OD.runKernel(NA,r,a)}});var oO=YD({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=qD(e,"a","matMul"),s=qD(t,"b","matMul");[a,s]=TD(a,s);let i={a:a,b:s},o={transposeA:n,transposeB:r};return OD.runKernel(mA,i,o)}});var lO=YD({sigmoid_:function(e){let t={x:qD(e,"x","sigmoid","float32")};return OD.runKernel(R$,t)}});var uO=YD({slice_:function(e,t,n){let r=qD(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return OD.runKernel(E$,a,s)}});var cO=YD({tanh_:function(e){let t={x:qD(e,"x","tanh","float32")};return OD.runKernel(Z$,t)}});var dO=YD({basicLSTMCell_:function(e,t,n,r,a,s){let i=qD(e,"forgetBias","basicLSTMCell"),o=qD(t,"lstmKernel","basicLSTMCell"),l=qD(n,"lstmBias","basicLSTMCell"),u=qD(r,"data","basicLSTMCell"),c=qD(a,"c","basicLSTMCell"),d=qD(s,"h","basicLSTMCell"),h=iO([u,d],1),p=oO(h,o),f=CF(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=uO(f,[0,0],y),v=uO(f,[0,g],y),x=uO(f,[0,2*g],y),w=uO(f,[0,3*g],y),k=CF(EF(lO(b),cO(v)),EF(c,lO(CF(i,x))));return[k,EF(cO(k),lO(w))]}});var hO=YD({batchToSpaceND_:function(e,t,n){let r=qD(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));rE(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),rE(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),rE(r.shape[0]%a===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));let s={x:r},i={blockShape:t,crops:n};return OD.runKernel(gA,s,i)}});function pO(e){let t;return t=0===e.rank||1===e.rank?rO(e,[1,1,1,e.size]):2===e.rank?rO(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?rO(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}var fO=YD({batchNorm_:function(e,t,n,r,a,s){null==s&&(s=.001);let i,o,l=qD(e,"x","batchNorm"),u=qD(t,"mean","batchNorm"),c=qD(n,"variance","batchNorm");null!=a&&(i=qD(a,"scale","batchNorm")),null!=r&&(o=qD(r,"offset","batchNorm")),rE(u.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),rE(null==o||u.rank===o.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),rE(null==i||u.rank===i.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let d={x:pO(l),scale:i,offset:o,mean:u,variance:c},h={varianceEpsilon:s},p=OD.runKernel(l_,d,h);return rO(p,l.shape)}});var mO=YD({batchNorm2d_:function(e,t,n,r,a,s){let i,o,l=qD(e,"x","batchNorm"),u=qD(t,"mean","batchNorm"),c=qD(n,"variance","batchNorm");return null!=a&&(i=qD(a,"scale","batchNorm")),null!=r&&(o=qD(r,"offset","batchNorm")),rE(2===l.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`)),rE(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`)),rE(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`)),null!=i&&rE(2===i.rank||1===i.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${i.rank}.`)),null!=o&&rE(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${o.rank}.`)),fO(l,u,c,o,i,s)}});var gO=YD({batchNorm3d_:function(e,t,n,r,a,s){let i,o,l=qD(e,"x","batchNorm"),u=qD(t,"mean","batchNorm"),c=qD(n,"variance","batchNorm");return null!=a&&(i=qD(a,"scale","batchNorm")),null!=r&&(o=qD(r,"offset","batchNorm")),rE(3===l.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`)),rE(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`)),rE(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`)),null!=i&&rE(3===i.rank||1===i.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${i.rank}.`)),null!=o&&rE(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${o.rank}.`)),fO(l,u,c,o,i,s)}});var yO=YD({batchNorm4d_:function(e,t,n,r,a,s){let i,o,l=qD(e,"x","batchNorm"),u=qD(t,"mean","batchNorm"),c=qD(n,"variance","batchNorm");return null!=a&&(i=qD(a,"scale","batchNorm")),null!=r&&(o=qD(r,"offset","batchNorm")),rE(4===l.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`)),rE(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`)),rE(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`)),null!=i&&rE(4===i.rank||1===i.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${i.rank}.`)),null!=o&&rE(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${o.rank}.`)),fO(l,u,c,o,i,s)}});var bO=YD({bincount_:function(e,t,n){let r=qD(e,"x","bincount"),a=qD(t,"weights","bincount");rE("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),rE(n>=0,(()=>`size must be non-negative, but got ${n}.`)),rE(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));let s={x:r,weights:a},i={size:n};return OD.runKernel(yA,s,i)}});var vO=YD({bitwiseAnd_:function(e,t){let n=qD(e,"x","bitwiseAnd"),r=qD(t,"y","bitwiseAnd");if(!uE(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let a={a:n,b:r};return OD.runKernel(bA,a)}});var xO=YD({broadcastArgs_:function(e,t){let n=qD(e,"s0","broadcastArgs","int32"),r=qD(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return OD.runKernel(xA,a)}});var wO=YD({broadcastTo_:function(e,t){let n=qD(e,"broadcastTo","x"),r=n.shape;if(zE(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=rO(n,e)}let a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return SF(n);let i={x:n},o={reps:s};return OD.runKernel(eR,i,o)}});var kO=YD({ceil_:function(e){let t={x:qD(e,"x","ceil","float32")};return OD.runKernel(kA,t)}});function SO(e,t,n){zE(e);let r={shape:e,value:t,dtype:n=n||AE(t)};return OD.runKernel(a_,{},r)}var IO=YD({clipByValue_:function(e,t,n){let r=qD(e,"x","clipByValue");if(rE(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return SO(r.shape,t,r.dtype);let a={x:r},s={clipValueMin:t,clipValueMax:n};return OD.runKernel(SA,a,s)}});var CO=YD({concat1d_:function(e){return iO(e,0)}});var NO=YD({concat2d_:function(e,t){return iO(e,t)}});var TO=YD({concat3d_:function(e,t){return iO(e,t)}});var EO=YD({concat4d_:function(e,t){return iO(e,t)}});var AO=YD({conv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=qD(e,"x","conv2d","float32"),l=qD(t,"filter","conv2d","float32"),u=o,c=!1;3===o.rank&&(c=!0,u=rO(o,[1,o.shape[0],o.shape[1],o.shape[2]])),rE(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),rE(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),nO("conv2d",r,i);let d="NHWC"===a?u.shape[3]:u.shape[1];rE(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),rE(ZF(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),rE(eO(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),rE(eO(n),(()=>"Error in conv2D: Strides should be larger than 0."));let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=OD.runKernel(TA,h,p);return c?rO(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var _O=YD({conv1d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0,o=qD(e,"x","conv1d"),l=qD(t,"filter","conv1d"),u=o,c=!1;2===o.rank&&(c=!0,u=rO(o,[1,o.shape[0],o.shape[1]])),rE(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),rE(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),nO("conv1d",r,i),rE(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),rE(ZF(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),rE(eO(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),rE(eO(n),(()=>"Error in conv1D: Stride should be larger than 0.")),rE("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));let d=rO(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=rO(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=AO(h,d,[1,n],r,"NHWC",[1,s],i);return rO(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});var $O=YD({conv2DBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;rE(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=rO(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),rE(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),rE(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),rE(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));let c="NHWC"===s?o[3]:o[1],d="NHWC"===s?l.shape[3]:l.shape[1];rE(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),rE(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),nO("conv2dDerInput",a,i);let h={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=OD.runKernel(AA,h,p);return u?rO(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var RO=YD({conv2dTranspose_:function(e,t,n,r,a,s){let i=qD(e,"x","conv2dTranspose"),o=qD(t,"filter","conv2dTranspose");return $O(n,i,o,r,a,"NHWC",s)}});var DO=YD({conv3d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1],i=qD(e,"x","conv3d"),o=qD(t,"filter","conv3d"),l=i,u=!1;4===i.rank&&(u=!0,l=rO(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),rE(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),rE(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),rE(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),rE(ZF(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),rE("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),rE(eO(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),rE(eO(n),(()=>"Error in conv3D: Strides should be larger than 0."));let c={x:l,filter:o},d={strides:n,pad:r,dataFormat:a,dilations:s},h=OD.runKernel(_A,c,d);return u?rO(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var MO=YD({conv3DBackpropInput_:function(e,t,n,r,a){rE(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=rO(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];rE(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),rE(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),rE(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),rE(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),rE(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));let c={dy:i,filter:n},d={pad:a,strides:r,inputShape:s},h=OD.runKernel(RA,c,d);return o?rO(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var FO=YD({conv3dTranspose_:function(e,t,n,r,a){let s=qD(e,"x","conv3dTranspose"),i=qD(t,"filter","conv3dTranspose");return MO(n,s,i,r,a)}});var OO=YD({cos_:function(e){let t={x:qD(e,"x","cos","float32")};return OD.runKernel(DA,t)}});var PO=YD({cosh_:function(e){let t={x:qD(e,"x","cosh","float32")};return OD.runKernel(MA,t)}});var LO=YD({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={x:qD(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return OD.runKernel(FA,a,s)}});var zO=YD({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={x:qD(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return OD.runKernel(OA,a,s)}});var BO=YD({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=qD(e,"x","denseBincount"),s=qD(t,"weights","denseBincount");rE("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),rE(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),rE(n>=0,(()=>`size must be non-negative, but got ${n}.`)),rE(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));let i={x:a,weights:s},o={size:n,binaryOutput:r};return OD.runKernel(LA,i,o)}});var WO=YD({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC",r=qD(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];rE(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),rE(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),rE(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),rE(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));let o={x:r},l={blockSize:t,dataFormat:n};return OD.runKernel(zA,o,l)}});var VO=YD({depthwiseConv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=qD(e,"x","depthwiseConv2d","float32"),l=qD(t,"filter","depthwiseConv2d","float32"),u=o,c=!1;3===o.rank&&(c=!0,u=rO(o,[1,o.shape[0],o.shape[1],o.shape[2]])),rE(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),rE(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));let d="NHWC"===a?u.shape[3]:u.shape[1];rE(d===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`)),nO("depthwiseConv2d",r,i);let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=OD.runKernel(BA,h,p);return c?rO(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var UO=YD({diag_:function(e){let t={x:qD(e,"x","diag")};return OD.runKernel(UA,t)}});var jO=YD({dilation2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=qD(e,"x","dilation2d"),o=qD(t,"filter","dilation2d");rE(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),rE(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),rE("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=i,u=!1;3===i.rank&&(l=rO(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),rE(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));let c={x:l,filter:o},d={strides:n,pad:r,dilations:a},h=OD.runKernel(jA,c,d);return u?rO(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),GO={};function HO(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function qO(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function KO(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];null==s&&(s=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===s)r[n-a-1]=i;else if(1===i)r[n-a-1]=s;else{if(s!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-a-1]=s}}return r}ST(GO,{assertAndGetBroadcastShape:()=>KO,getBroadcastDims:()=>HO,getReductionAxes:()=>qO});var XO=YD({equal_:function(e,t){let n=qD(e,"a","equal","string_or_numeric"),r=qD(t,"b","equal","string_or_numeric");[n,r]=TD(n,r),KO(n.shape,r.shape);let a={a:n,b:r};return OD.runKernel(ZA,a)}});var YO=YD({where_:function(e,t,n){let r=qD(t,"a","where"),a=qD(n,"b","where"),s=qD(e,"condition","where","bool"),i=KO(KO(s.shape,r.shape),a.shape),o={condition:wO(s,i),t:wO(r,i),e:wO(a,i)};return OD.runKernel(N$,o)}});var QO=YD({zerosLike_:function(e){let t={x:qD(e,"x","zerosLike")};return OD.runKernel(lR,t)}});var JO=YD({divNoNan_:function(e,t){let n=qD(e,"a","div"),r=qD(t,"b","div");[n,r]=TD(n,r);let a=TF(n,r),s=QO(a),i=XO(r,s);return YO(i,s,a)}});var ZO=YD({dot_:function(e,t){let n=qD(e,"t1","dot"),r=qD(t,"t2","dot");rE((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));let a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(rE(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){let e=rO(n,[1,-1]),t=rO(r,[-1,1]),a=oO(e,t);return rO(a,[])}if(1===n.rank&&2===r.rank){let e=rO(n,[1,-1]),t=rO(r,[r.shape[0],r.shape[1]]),a=oO(e,t);return rO(a,[a.size])}if(2===n.rank&&1===r.rank){let e=rO(r,[-1,1]),t=oO(n,e);return rO(t,[t.size])}{let e=rO(r,[r.shape[0],r.shape[1]]);return oO(n,e)}}});var eP=YD({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];let a=n.map(((e,t)=>qD(e,`tensors${t}`,"einsum"))),s={equation:e};return OD.runKernel(XA,a,s)}});var tP=YD({elu_:function(e){let t={x:qD(e,"x","elu","float32")};return OD.runKernel(YA,t)}});var nP=YD({ensureShape_:function(e,t){let n=qD(e,"x","ensureShape","string_or_numeric");if(!lE(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});var rP=YD({erf_:function(e){let t=qD(e,"x","erf");rE("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=kF(t,"float32"));let n={x:t};return OD.runKernel(JA,n)}});function aP(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function sP(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function iP(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function oP(e,t){return sP(e,t.map((e=>1)),t)}function lP(e,t,n){rE(aP(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function uP(e,t){if(aP(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function cP(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function dP(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}var hP=YD({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:qD(e,"x","max")},a={reductionIndices:t,keepDims:n};return OD.runKernel(M_,r,a)}});var pP=YD({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:qD(e,"x","min")},a={axis:t,keepDims:n};return OD.runKernel(V_,r,a)}});var fP=YD({pow_:function(e,t){let n=qD(e,"base","pow"),r=qD(t,"exp","pow");[n,r]=TD(n,r);let a={a:n,b:r};return OD.runKernel(a$,a)}});function mP(e,t){if((YR(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&YR(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return JD(e,[],[],t)}var gP=YD({sqrt_:function(e){let t={x:qD(e,"x","sqrt","float32")};return OD.runKernel(M$,t)}});var yP=YD({square_:function(e){let t=qD(e,"x","square");return OD.runKernel("Square",{x:t},{})}});var bP=YD({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=qD(e,"x","sum");"bool"===r.dtype&&(r=kF(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return OD.runKernel(F$,a,s)}});function vP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return AF(e);if(1!==e.rank&&null===n)return vP(rO(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return bP(AF(e),n);if(t===1/0)return hP(AF(e),n);if(t===-1/0)return pP(AF(e),n);if("euclidean"===t||2===t)return gP(bP(fP(AF(e),mP(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return hP(bP(AF(e),n[0]),n[1]-1);if(t===1/0)return hP(bP(AF(e),n[1]),n[0]);if(t===-1/0)return pP(bP(AF(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return gP(bP(yP(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var xP=YD({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=vP(e=qD(e,"x","norm"),t,n),s=a.shape;if(r){let t=yE(n,e.shape);s=oP(a.shape,t)}return rO(a,s)}});var wP=YD({euclideanNorm_:function(e){return xP(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});var kP=YD({exp_:function(e){let t={x:qD(e,"x","exp")};return OD.runKernel(e_,t)}});var SP=YD({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=qD(e,"x","expandDims","string_or_numeric");rE(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));let r={input:n},a={dim:t};return OD.runKernel(t_,r,a)}});var IP=YD({expm1_:function(e){let t={x:qD(e,"x","expm1")};return OD.runKernel(n_,t)}});var CP=YD({tile_:function(e,t){let n=qD(e,"x","tile","string_or_numeric");rE(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));let r={x:n},a={reps:t};return OD.runKernel(eR,r,a)}});var NP=YD({eye_:function(e,t,n){null==t&&(t=e);let r=wF([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=e<=t?e:t;for(let i=0;i<a;++i)r.set(1,i,i);let s=rO(r.toTensor(),[e,t]);if(null==n)return s;if(1===n.length)return CP(SP(s,0),[n[0],1,1]);if(2===n.length)return CP(SP(SP(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return CP(SP(SP(SP(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var TP=YD({floor_:function(e){let t={x:qD(e,"x","floor","float32")};return OD.runKernel(i_,t)}});var EP=YD({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a={x:qD(e,"x","gather"),indices:qD(t,"indices","gather","int32")},s={axis:n,batchDims:r};return OD.runKernel(u_,a,s)}});var AP=YD({greater_:function(e,t){let n=qD(e,"a","greater","string_or_numeric"),r=qD(t,"b","greater","string_or_numeric");[n,r]=TD(n,r),KO(n.shape,r.shape);let a={a:n,b:r};return OD.runKernel(d_,a)}});var _P=YD({greaterEqual_:function(e,t){let n=qD(e,"a","greaterEqual","string_or_numeric"),r=qD(t,"b","greaterEqual","string_or_numeric");[n,r]=TD(n,r),KO(n.shape,r.shape);let a={a:n,b:r};return OD.runKernel(h_,a)}});var $P=YD({imag_:function(e){let t={input:qD(e,"input","imag")};return OD.runKernel(m_,t)}});var RP=YD({isFinite_:function(e){let t={x:qD(e,"x","isFinite")};return OD.runKernel(g_,t)}});var DP=YD({isInf_:function(e){let t={x:qD(e,"x","isInf")};return OD.runKernel(y_,t)}});var MP=YD({isNaN_:function(e){let t={x:qD(e,"x","isNaN")};return OD.runKernel(b_,t)}});var FP=YD({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2,n={x:qD(e,"x","leakyRelu")},r={alpha:t};return OD.runKernel(v_,n,r)}});var OP=YD({less_:function(e,t){let n=qD(e,"a","less","string_or_numeric"),r=qD(t,"b","less","string_or_numeric");[n,r]=TD(n,r),KO(n.shape,r.shape);let a={a:n,b:r};return OD.runKernel(x_,a)}});var PP=YD({lessEqual_:function(e,t){let n=qD(e,"a","lessEqual","string_or_numeric"),r=qD(t,"b","lessEqual","string_or_numeric");[n,r]=TD(n,r),KO(n.shape,r.shape);let a={a:n,b:r};return OD.runKernel(w_,a)}});function LP(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return OD.runKernel(k_,{},r)}var zP=YD({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=qD(e,"x","localResponseNormalization");rE(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),rE(cE(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=s,o=!1;3===s.rank&&(o=!0,i=rO(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:a},c=OD.runKernel($_,l,u);return o?rO(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var BP=YD({log_:function(e){let t={x:qD(e,"x","log","float32")};return OD.runKernel(S_,t)}});var WP=YD({log1p_:function(e){let t={x:qD(e,"x","log1p")};return OD.runKernel(I_,t)}});function VP(e){return rE(_E(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{let r=qD(t,"x","tf.grad","string_or_numeric"),a=null!=n?qD(n,"dy","tf.grad"):null;return OD.tidy((()=>{let{value:t,grads:n}=OD.gradients((()=>e(r)),[r],a);return null!=a&&aE(t.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),KP(n),n[0]}))}}function UP(e){return rE(_E(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{rE(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));let r=KD(t,"args","tf.grads","string_or_numeric"),a=null!=n?qD(n,"dy","tf.grads"):null;return OD.tidy((()=>{let{value:t,grads:n}=OD.gradients((()=>e(...r)),r,a);return null!=a&&aE(t.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),KP(n),n}))}}function jP(e){return rE(_E(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{rE(t instanceof hD,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),rE(null==n||n instanceof hD,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));let{grads:r,value:a}=OD.gradients((()=>e(t)),[t],n);return KP(r),{grad:r[0],value:a}}}function GP(e){return rE(_E(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{rE(Array.isArray(t)&&t.every((e=>e instanceof hD)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),rE(null==n||n instanceof hD,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));let r=OD.gradients((()=>e(...t)),t,n);return null!=n&&aE(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),KP(r.grads),r}}function HP(e,t){rE(_E(e),(()=>"The f passed in variableGrads(f) must be a function")),rE(null==t||Array.isArray(t)&&t.every((e=>e instanceof fD)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));let n=null!=t;if(!n){t=[];for(let e in OD.registeredVariables)t.push(OD.registeredVariables[e])}let r=n?t.filter((e=>!e.trainable)):null,a=t.length;rE((t=t.filter((e=>e.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));let{value:s,grads:i}=OD.gradients(e,t,null,!0);rE(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),rE(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));let o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:s,grads:o}}function qP(e){return OD.customGrad(e)}function KP(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var XP=YD({neg_:function(e){let t={x:qD(e,"x","neg")};return OD.runKernel(K_,t)}});var YP=YD({softplus_:function(e){let t={x:qD(e,"x","softplus")};return OD.runKernel(D$,t)}});var QP=YD({logSigmoid_:function(e){let t=qD(e,"x","logSigmoid");return qP((e=>({value:XP(YP(XP(e))),gradFunc:t=>EF(t,lO(XP(e)))})))(t)}});var JP=YD({sub_:function(e,t){let n=qD(e,"a","sub"),r=qD(t,"b","sub");[n,r]=TD(n,r);let a={a:n,b:r};return OD.runKernel(Q$,a)}});var ZP=YD({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=qD(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return qP(((e,n)=>{let r=hP(e,t,!0),a=JP(e,r),s=JP(kF(a,"float32"),BP(bP(kP(a),t,!0)));return n([s]),{value:s,gradFunc:(e,n)=>{let[r]=n,a=kP(r);return JP(e,EF(bP(e,t,!0),a))}}}))(n)}});var eL=YD({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=qD(e,"x","logSumExp"),a=yE(t,r.shape),s=hP(r,a,!0),i=JP(r,s),o=kP(i),l=bP(o,a),u=BP(l),c=CF(rO(s,u.shape),u);if(n){let e=oP(c.shape,a);return rO(c,e)}return c}});var tL=YD({logicalAnd_:function(e,t){let n=qD(e,"a","logicalAnd","bool"),r=qD(t,"b","logicalAnd","bool");KO(n.shape,r.shape);let a={a:n,b:r};return OD.runKernel(C_,a)}});var nL=YD({logicalNot_:function(e){let t={x:qD(e,"x","logicalNot","bool")};return OD.runKernel(N_,t)}});var rL=YD({logicalOr_:function(e,t){let n=qD(e,"a","logicalOr","bool"),r=qD(t,"b","logicalOr","bool");KO(n.shape,r.shape);let a={a:n,b:r};return OD.runKernel(T_,a)}});var aL=YD({logicalXor_:function(e,t){let n=qD(e,"a","logicalXor","bool"),r=qD(t,"b","logicalXor","bool");return KO(n.shape,r.shape),tL(rL(e,t),nL(tL(e,t)))}}),sL=2147483648;var iL=YD({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left",r=qD(e,"sortedSequence","searchSorted"),a=qD(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=rO(r,[-1,s]),l=rO(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(iE(l.shape)>=sL)throw new Error(`values tensor size must less than ${sL}`);if(o.shape[1]>=sL)throw new Error(`trailing dim_size must less than ${sL} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},c={side:n};return OD.runKernel(C$,u,c)}});function oL(e,t){return iL(e,t,"left")}var lL=YD({maxPool_:function(e,t,n,r,a){let s=qD(e,"x","maxPool"),i=s,o=!1;3===s.rank&&(o=!0,i=rO(s,[1,s.shape[0],s.shape[1],s.shape[2]])),rE(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),rE(ZF(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),nO("maxPool",r,a);let l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=OD.runKernel(O_,l,u);return o?rO(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var uL=YD({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC",i=qD(e,"x","maxPool3d"),o=i,l=!1;4===i.rank&&(l=!0,o=rO(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),rE(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),rE("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),nO("maxPool3d",r,a);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=OD.runKernel(L_,u,c);return l?rO(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var cL=YD({maxPoolWithArgmax_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s={x:qD(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=OD.runKernel(B_,s,i);return{result:o[0],indexes:o[1]}}});var dL=YD({maximum_:function(e,t){let n=qD(e,"a","maximum"),r=qD(t,"b","maximum");[n,r]=TD(n,r),"bool"===n.dtype&&(n=kF(n,"int32"),r=kF(r,"int32")),KO(n.shape,r.shape);let a={a:n,b:r};return OD.runKernel(F_,a)}});var hL=YD({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:qD(e,"x","mean")},a={axis:t,keepDims:n};return OD.runKernel(W_,r,a)}});function pL(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(zE(e),"complex64"===t){let t=pL(e,"float32"),n=pL(e,"float32");return QD(t,n)}let n=PE(iE(e),t);return OD.makeTensor(n,e,t)}function fL(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(zE(e),"complex64"===t){let t=fL(e,"float32"),n=pL(e,"float32");return QD(t,n)}let n=OE(iE(e),t);return OD.makeTensor(n,e,t)}function mL(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=qD(e,"x","meshgrid",e instanceof hD?e.dtype:"float32");if(void 0===t)return[r];let a=qD(t,"y","meshgrid",t instanceof hD?t.dtype:"float32"),s=iE(r.shape),i=iE(a.shape);return"xy"===n?(r=rO(r,[1,-1]),a=rO(a,[-1,1]),[oO(fL([i,1],r.dtype),r),oO(a,fL([1,s],a.dtype))]):(r=rO(r,[-1,1]),a=rO(a,[1,-1]),[oO(r,fL([1,i],r.dtype)),oO(fL([s,1],a.dtype),a)])}var gL=YD({minimum_:function(e,t){let n=qD(e,"a","minimum"),r=qD(t,"b","minimum");[n,r]=TD(n,r),"bool"===n.dtype&&(n=kF(n,"int32"),r=kF(r,"int32")),KO(n.shape,r.shape);let a={a:n,b:r};return OD.runKernel(U_,a)}});var yL=YD({mirrorPad_:function(e,t,n){rE("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));let r=qD(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");rE(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));let a="reflect"===n?1:0;for(let o=0;o<r.rank;o++)rE(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),rE(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`));let s={paddings:t,mode:n},i={x:r};return OD.runKernel(j_,i,s)}});var bL=YD({mod_:function(e,t){let n=qD(e,"a","mod"),r=qD(t,"b","mod");[n,r]=TD(n,r);let a={a:n,b:r};return OD.runKernel(G_,a)}});var vL=YD({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=yE(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=qD(e,"x","moments")).shape),r=hL(e,n,t),a=r.shape;t||(a=oP(r.shape,n));let s=yP(JP(kF(e,"float32"),rO(r,a)));return{mean:r,variance:hL(s,n,t)}}});var xL=YD({multiRNNCell_:function(e,t,n,r){let a=qD(t,"data","multiRNNCell"),s=KD(n,"c","multiRNNCell"),i=KD(r,"h","multiRNNCell"),o=a,l=[];for(let d=0;d<e.length;d++){let t=e[d](o,s[d],i[d]);l.push(t[0]),l.push(t[1]),o=t[1]}let u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}});var wL=YD({multinomial_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=qD(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:1===i?rO(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=OD.runKernel(H_,o,l);return 1===i?rO(u,[u.size]):u}});var kL=YD({notEqual_:function(e,t){let n=qD(e,"a","notEqual","string_or_numeric"),r=qD(t,"b","notEqual","string_or_numeric");[n,r]=TD(n,r),KO(n.shape,r.shape);let a={a:n,b:r};return OD.runKernel(X_,a)}});var SL=YD({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:qD(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return OD.runKernel(e$,s,i)}});var IL=YD({onesLike_:function(e){let t={x:qD(e,"x","onesLike")};return OD.runKernel(Z_,t)}});var CL=YD({outerProduct_:function(e,t){let n=qD(e,"v1","outerProduct"),r=qD(t,"v2","outerProduct");rE(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));let a=rO(n,[-1,1]),s=rO(r,[1,-1]);return oO(a,s)}});var NL=YD({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=qD(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return OD.runKernel(n$,s,a)}});var TL=YD({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return rE(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),NL(e,[t],n)}});var EL=YD({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return rE(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),NL(e,t,n)}});var AL=YD({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return rE(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),NL(e,t,n)}});var _L=YD({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return rE(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),NL(e,t,n)}});var $L=YD({spaceToBatchND_:function(e,t,n){let r=qD(e,"x","spaceToBatchND");rE(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),rE(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),rE(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));let a={x:r},s={blockShape:t,paddings:n};return OD.runKernel(O$,a,s)}});var RL=YD({pool_:function(e,t,n,r,a,s,i){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");let o=qD(e,"x","maxPool"),l=o,u=!1;3===o.rank&&(u=!0,l=rO(o,[1,o.shape[0],o.shape[1],o.shape[2]])),rE(ZF(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));let c,d=UF(l.shape,t,s,a,r),h=[d.dilationHeight,d.dilationWidth];c="same"===r?function(e,t){let n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),a=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],a[t]]))}([d.filterHeight,d.filterWidth],h):[[0,0],[0,0]];let p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){let r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),i=t.map(((e,t)=>(e-s[t]%e)%e)),o=a.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([d.inHeight,d.inWidth],h,c),g=p?r:"valid",y=p?l:$L(l,h,f),b=("avg"===n?()=>aO(y,t,s,g,i):()=>lL(y,t,s,g,i))(),v=p?b:hO(b,h,m);return u?rO(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});var DL=YD({prelu_:function(e,t){let n={x:qD(e,"x","prelu"),alpha:qD(t,"alpha","prelu")};return OD.runKernel(s$,n)}});var ML=YD({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=qD(e,"x","prod");"bool"===r.dtype&&(r=kF(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return OD.runKernel(i$,a,s)}});var FL=YD({raggedGather_:function(e,t,n,r){let a=e.map(((e,t)=>qD(e,`tensors${t}`,"raggedGather","int32"))),s={paramsNestedSplits:a,paramsDenseValues:qD(t,"paramsDenseValues","raggedGather"),indices:qD(n,"indices","raggedGather","int32")},i={outputRaggedRank:r},o=OD.runKernel(o$,s,i);return{outputNestedSplits:o.slice(0,o.length-1),outputDenseValues:o[o.length-1]}}});var OL=YD({raggedRange_:function(e,t,n){let r=qD(e,"starts","raggedRange"),a={starts:r,limits:qD(t,"limits","raggedRange",r.dtype),deltas:qD(n,"deltas","raggedRange",r.dtype)},s=OD.runKernel(l$,a);return{rtNestedSplits:s[0],rtDenseValues:s[1]}}});var PL=YD({raggedTensorToTensor_:function(e,t,n,r,a){let s=qD(e,"shape","raggedTensorToTensor","int32"),i=qD(t,"values","raggedTensorToTensor"),o={shape:s,values:i,defaultValue:qD(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>qD(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:a};return OD.runKernel(u$,o,l)}});var LL=YD({rand_:function(e,t,n){zE(e);let r=iE(e),a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let s=0;s<r;s++)a[s]=t();return OD.makeTensor(a,e,n)}}),zL=IT(OT()),BL={};ST(BL,{TEST_EPSILON_FLOAT16:()=>VL,createVideoElement:()=>ZL,encodeStrings:()=>JL,expectArrayBuffersEqual:()=>QL,expectArraysClose:()=>UL,expectArraysEqual:()=>qL,expectNumbersClose:()=>KL,expectPromiseToFail:()=>HL,expectValuesInRange:()=>YL,play:()=>ez,testEpsilon:()=>jL});var WL=.001,VL=.1;function UL(e,t,n){return null==n&&(n=jL()),GL(e,t,((e,t)=>XL(e,t,n)))}function jL(){return 32===OD.backend.floatPrecision()?WL:VL}function GL(e,t,n){let r=!0;if((YR(e)||YR(t))&&(r=!1),YR(e)&&YR(t)&&(r=!0),r){let n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){let n=jD(e),r=jD(t);if(!uE(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}let a=YR(e)?e:QR(e),s=YR(t)?t:QR(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.\nActual:   ${a}.\nExpected: ${s}.`);for(let i=0;i<s.length;++i){let e=a[i],t=s[i];if(!n(e,t))throw new Error(`Arrays differ: actual[${i}] = ${e}, expected[${i}] = ${t}.\nActual:   ${a}.\nExpected: ${s}.`)}"undefined"!=typeof expect&&expect().nothing()}function HL(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!=typeof expect&&expect().nothing()}function qL(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return NE(e)||NE(e[0])||NE(t)||NE(t[0])?GL(e,n,((e,t)=>e==t)):GL(e,t,((e,t)=>XL(e,t,0)))}function KL(e,t,n){if(null==n&&(n=jL()),!XL(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function XL(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function YL(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function QL(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function JL(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?JL(n):e[t]=KR(n)}return e}function ZL(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function ez(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}var tz=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let s=a||Math.random();this.random=zL.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},nz=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=zL.alea(a.toString()),this.randn=new tz(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}},rz=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=zL.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};var az=YD({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;if(zE(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);let s=new nz(t,n,r,a),i=wF(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var sz=YD({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(zE(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);let s=new tz(t,n,r,!1,a),i=wF(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var iz=YD({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return sz(e,0,1,t,n)}});var oz=YD({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;zE(e);let s=wF(e,r),i=new rz(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});var lz=YD({randomUniformInt_:function(e,t,n,r){return oz(e,t,n,"int32",r)}});function uz(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return OD.runKernel(c$,{},a)}var cz=YD({real_:function(e){let t={input:qD(e,"input","real")};return OD.runKernel(d$,t)}});var dz=YD({reciprocal_:function(e){let t={x:qD(e,"x","reciprocal")};return OD.runKernel(h$,t)}});var hz=YD({relu_:function(e){let t={x:qD(e,"x","relu")};return OD.runKernel(p$,t)}});var pz=YD({relu6_:function(e){let t={x:qD(e,"x","relu6")};return OD.runKernel(v$,t)}});var fz=YD({reverse_:function(e,t){let n={x:qD(e,"x","reverse")},r={dims:t};return OD.runKernel(x$,n,r)}});var mz=YD({reverse1d_:function(e){let t=qD(e,"x","reverse");return rE(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),fz(t,0)}});var gz=YD({reverse2d_:function(e,t){let n=qD(e,"x","reverse");return rE(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),fz(n,t)}});var yz=YD({reverse3d_:function(e,t){let n=qD(e,"x","reverse");return rE(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),fz(n,t)}});var bz=YD({reverse4d_:function(e,t){let n=qD(e,"x","reverse");return rE(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),fz(n,t)}});var vz=YD({round_:function(e){let t={x:qD(e,"x","round")};return OD.runKernel(w$,t)}});var xz=YD({rsqrt_:function(e){let t={x:qD(e,"x","rsqrt","float32")};return OD.runKernel(k$,t)}});var wz=YD({selu_:function(e){let t={x:qD(e,"x","selu")};return OD.runKernel(T$,t)}});var kz=YD({separableConv2d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC",o=qD(e,"x","separableConv2d"),l=qD(t,"depthwiseFilter","separableConv2d"),u=qD(n,"pointwiseFilter","separableConv2d"),c=o,d=!1;if(3===o.rank&&(d=!0,c=rO(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");rE(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),rE(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),rE(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),rE(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),rE(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));let h=l.shape[2],p=l.shape[3];rE(u.shape[2]===h*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`));let f=VO(c,l,r,a,i,s),m=AO(f,u,1,"valid",i);return d?rO(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});var Sz=async function(e,t){let n=qD(e,"x","setdiff1d"),r=qD(t,"y","setdiff1d");rE(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),rE(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),rE(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let c=0;c<a.length;c++)i.has(a[c])||o++;let l=new uD([o],n.dtype),u=new uD([o],"int32");for(let c=0,d=0;c<a.length;c++)i.has(a[c])||(l.values[d]=a[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]};var Iz=YD({sign_:function(e){let t={x:qD(e,"x","sign")};return OD.runKernel($$,t)}});var Cz=YD({sin_:function(e){let t={x:qD(e,"x","sin","float32")};return OD.runKernel(A$,t)}});var Nz=YD({sinh_:function(e){let t={x:qD(e,"x","sinh")};return OD.runKernel(_$,t)}});var Tz=YD({slice1d_:function(e,t,n){let r=qD(e,"x","slice1d");return rE(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),uO(r,[t],[n])}});var Ez=YD({slice2d_:function(e,t,n){let r=qD(e,"x","slice2d");return rE(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),uO(r,t,n)}});var Az=YD({slice3d_:function(e,t,n){let r=qD(e,"x","slice3d");return rE(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),uO(r,t,n)}});var _z=YD({slice4d_:function(e,t,n){let r=qD(e,"x","slice4d");return rE(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),uO(r,t,n)}});var $z=YD({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=qD(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return OD.runKernel(L$,r,a)}});var Rz=YD({fft_:function(e){rE("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));let t={input:e};return OD.runKernel(r_,t)}});var Dz=YD({ifft_:function(e){rE("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));let t={input:e};return OD.runKernel(f_,t)}});var Mz=YD({irfft_:function(e){let t,n=e.shape[e.shape.length-1],r=e.size/n;if(n<=2){let a=rO(e,[r,n]);t=Dz(a)}else{let a=[r,2*(n-1)],s=rO(cz(e),[r,n]),i=rO($P(e),[r,n]),o=fz(uO(s,[0,1],[r,n-2]),1),l=EF(fz(uO(i,[0,1],[r,n-2]),1),mP(-1)),u=iO([s,o],1),c=iO([i,l],1),d=rO(QD(u,c),[a[0],a[1]]);t=Dz(d)}if(t=cz(t),3===e.rank&&0!==e.shape[0]){let n=t,r=e.shape[0];t=rO(t,[r,t.shape[0]/r,t.shape[1]]),n.dispose()}return t}});var Fz=YD({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r={x:qD(e,"x","split")},a={numOrSizeSplits:t,axis:n};return OD.runKernel(P$,r,a)}});var Oz=YD({rfft_:function(e,t){rE("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n,r=e.shape[e.shape.length-1],a=e.size/r;if(null!=t&&t<r){let a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,n=uO(e,a,s),r=t}else if(null!=t&&t>r){let a=e.shape.map((e=>e));a[e.shape.length-1]=t-r,n=iO([e,pL(a)],e.shape.length-1),r=t}else n=e;let s=QO(n),i=rO(QD(n,s),[a,r]),o=Rz(i),l=Math.floor(r/2)+1,u=cz(o),c=$P(o),d=Fz(u,[l,r-l],u.shape.length-1),h=Fz(c,[l,r-l],c.shape.length-1),p=n.shape.slice();return p[n.shape.length-1]=l,rO(QD(d[0],h[0]),p)}});var Pz=YD({squaredDifference_:function(e,t){let n=qD(e,"a","squaredDifference"),r=qD(t,"b","squaredDifference");[n,r]=TD(n,r),KO(n.shape,r.shape);let a={a:n,b:r};return OD.runKernel(j$,a,{})}});var Lz=YD({squeeze_:function(e,t){let n=qD(e,"x","squeeze","string_or_numeric");return rO(n,bE(n.shape,t).newShape)}});var zz=YD({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=KD(e,"tensors","stack","string_or_numeric");rE(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&rE(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));let r=n,a={axis:t};return OD.runKernel(t$,r,a)}});var Bz=YD({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:qD(e,"x","step")},r={alpha:t};return OD.runKernel(uR,n,r)}});var Wz=YD({stridedSlice_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,u={x:qD(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return OD.runKernel(q$,u,c)}});var Vz=YD({tan_:function(e){let t={x:qD(e,"x","tan","float32")};return OD.runKernel(J$,t)}});function Uz(e,t){sE(e);let n=jD(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return JD(e,null,n,t)}function jz(e,t,n){if(sE(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");let r=jD(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return JD(e,t,r,n)}function Gz(e,t,n){if(sE(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");let r=jD(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return JD(e,t,r,n)}function Hz(e,t,n){if(sE(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");let r=jD(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return JD(e,t,r,n)}function qz(e,t,n){if(sE(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");let r=jD(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return JD(e,t,r,n)}function Kz(e,t,n){if(sE(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");let r=jD(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return JD(e,t=t||r,r,n)}var Xz={};function Yz(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function Qz(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Yz(n,t,e)}function Jz(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let l=a;l<s;++l)i*=n[l];let o=a<1?1:a;return{sliceRank:a,numUpdates:iE(t.shape)/o,sliceSize:i,strides:[...RE(n.slice(0,a)),1],outputSize:iE(n)}}ST(Xz,{calculateShapes:()=>Jz,validateInput:()=>Qz,validateUpdateShape:()=>Yz});var Zz=YD({tensorScatterUpdate_:function(e,t,n){let r=qD(e,"tensor","tensorScatterupdate"),a=qD(t,"indices","tensorScatterupdate","int32"),s=qD(n,"updates","tensorScatterupdate");if(Qz(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:a,updates:s};return OD.runKernel(I$,i,{})}});var eB=YD({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=qD(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=OD.runKernel(tR,s,i);return{values:o,indices:l}}});var tB=YD({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(zE(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");let s=new tz(t,n,r,!0,a),i=wF(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var nB=YD({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=qD(e,"x","unique","string_or_numeric");rE(n.rank>0,(()=>"The input tensor must be at least 1D"));let r={x:n},a={axis:t},[s,i]=OD.runKernel(aR,r,a);return{values:s,indices:i}}});var rB=YD({unsortedSegmentSum_:function(e,t,n){let r=qD(e,"x","unsortedSegmentSum"),a=qD(t,"segmentIds","unsortedSegmentSum","int32");rE(cE(n),(()=>"numSegments must be of dtype int"));let s={x:r,segmentIds:a},i={numSegments:n};return OD.runKernel(iR,s,i)}});var aB=YD({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=qD(e,"x","unstack","string_or_numeric");rE(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));let r={value:n},a={axis:t};return OD.runKernel(sR,r,a)}});function sB(e,t){return iL(e,t,"right")}function iB(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return OD.makeVariable(e,t,n,r)}function oB(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let r=wF(e,"int32"),a=wF([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let t=r.indexToLoc(n[s]),i=s*e.length;a.values.set(t,i)}return a.toTensor()}var lB=async function(e){let t=qD(e,"condition","whereAsync","bool"),n=await t.data(),r=oB(t.shape,n);return e!==t&&t.dispose(),r};var uB=async function(e,t,n){let r=qD(e,"tensor","boolMask"),a=qD(t,"mask","boolMask","bool"),s=null==n?0:n,i=a.rank,o=r.shape;rE(i>0,(()=>"mask cannot be scalar")),aE(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];let u=o.slice(0,s).concat([l],o.slice(s+i)),c=rO(r,u),d=rO(a,[-1]),h=await lB(d),p=Lz(h,[1]),f=EP(c,p,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f};var cB=YD({transpose_:function(e,t,n){let r=qD(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),rE(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{rE(e>=0&&e<r.rank,(()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`))})),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return"complex64"===r.dtype?cM((()=>{let e=cz(r),t=$P(r);return e=OD.runKernel(rR,{x:e},s),t=OD.runKernel(rR,{x:t},s),n&&(t=XP(t)),QD(e,t)})):OD.runKernel(rR,a,s)}});var dB=YD({movingAverage_:function(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=qD(e,"v","movingAverage"),i=qD(t,"x","movingAverage"),o=qD(n,"decay","movingAverage");ED(s,i),rE(uE(s.shape,i.shape),(()=>"Shape mismatch in v and x"));let l=mP(1),u=JP(l,o),c=EF(JP(i,s),u);if(a){rE(null!=r,(()=>"When using zeroDebias: true, step is required."));let e=qD(r,"step","movingAverage");c=TF(c,JP(l,fP(o,e)))}return CF(s,c)}});var hB=YD({scatterND_:function(e,t,n){zE(n);let r=qD(e,"indices","scatterND","int32"),a=qD(t,"updates","scatterND");Qz(a,r,n);let s={indices:r,updates:a},i={shape:n};return OD.runKernel(S$,s,i)}});var pB=YD({sparseToDense_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;zE(n);let a=qD(e,"sparseIndices","sparseToDense","int32"),s=qD(t,"sparseValues","sparseToDense","string_or_numeric"),i=qD(r,"defaultValue","sparseToDense",s.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(0!==t.rank&&(1!==t.rank||i!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return OD.runKernel(U$,o,l)}});var fB=YD({gatherND_:function(e,t){let n=qD(t,"indices","gatherND","int32"),r={params:qD(e,"x","gatherND","string_or_numeric"),indices:n};return OD.runKernel(c_,r)}});var mB=YD({dropout_:function(e,t,n,r){let a=qD(e,"x","dropout");if(rE("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),rE(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof hD?a.clone():a;let s=function(e,t){if(null==t)return e.shape.slice();if(uE(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),i=1-t,o=TF(TP(CF(oz(s,0,1,"float32",r),i)),i);return EF(a,o)}});function gB(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function yB(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return Uz(a,"float32")}var bB=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=qD(e,"predictions","inTopK"),a=qD(t,"targets","inTopK");rE(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),rE(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),aE(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];rE(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));let i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],c=vE("bool",l);for(let d=0;d<l;d++){let e=d*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),c[d]=0;for(let a=0;a<n;a++)if(r[a].index===o[d]){c[d]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),ZD(c,a.shape,"bool")},vB={};ST(vB,{conv2d:()=>CB,depthwiseConv2d:()=>EB,matMul:()=>AB});var xB=YD({conv2DBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=rO(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=rO(t,[1,t.shape[0],t.shape[1],t.shape[2]])),rE(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),rE(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),rE(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));let u="NHWC"===s?o.shape[3]:o.shape[1],c="NHWC"===s?l.shape[3]:l.shape[1];rE(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),rE(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),nO("conv2dDerFilter",a,i);let d={x:o,dy:l},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return OD.runKernel(EA,d,h)}});function wB(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return EF(e,Bz(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function kB(e,t){let n=t,r=qO(e.shape,t.shape);return r.length>0&&(n=bP(n,r)),rO(n,e.shape)}function SB(e,t,n,r){if("linear"===t)return e;if("relu"===t)return hz(e);if("elu"===t)return tP(e);if("relu6"===t)return pz(e);if("prelu"===t)return DL(e,n);if("leakyrelu"===t)return FP(e,r);if("sigmoid"===t)return lO(e);throw new Error(`Unknown fused activation ${t}.`)}var IB=(e,t)=>!(e>0)||"linear"===t;var CB=YD({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(u=u||"linear",!1===IB(OD.state.gradientDepth,u)){rE("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=AO(t,n,r,a,s,i,o);return null!=l&&(e=CF(e,l)),SB(e,u,c,d)}let h=qD(t,"x","conv2d","float32"),p=qD(n,"filter","conv2d","float32"),f=h,m=!1;3===h.rank&&(m=!0,f=rO(h,[1,h.shape[0],h.shape[1],h.shape[2]])),rE(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),rE(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),nO("fused conv2d",a,o);let g="NHWC"===s?f.shape[3]:f.shape[1];rE(p.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`)),rE(ZF(r,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`));let y,b,v=GF(f.shape,p.shape,r,i,a,o);if(null!=l&&(y=qD(l,"bias","fused conv2d"),[y]=TD(y,h),"NHWC"===s?KO(v.outShape,y.shape):(rE(y.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`)),rE(0===y.shape.length||y.shape[0]===v.outChannels||1===y.shape[0],(()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${v.outChannels})`)))),null!=c){let e=c.shape;if(rE(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)rE(1===e[0]||e[0]===v.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${v.outChannels}).`));else if(3===e.length)try{KO(e,v.outShape)}catch(qd){let n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${v.outShape}).`;throw Error(n)}b=qD(c,"prelu weights","fused conv2d")}let x=(e,t)=>{rE("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));let[n,o,l,c]=t,d=wB(e,l,u);rE(JF(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));let h=[$O(o.shape,d,n,r,a),xB(o,d,n.shape,r,a)];if(null!=c){let e=kB(c,d);h.push(e)}return h},w={x:f,filter:p,bias:y,preluActivationWeights:b},k={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};return null==l?qP(((e,t,n)=>{let r=OD.runKernel(pR,w,k);return n([t,e,r]),m&&(r=rO(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}))(f,p):qP(((e,t,n,r)=>{let a=OD.runKernel(pR,w,k);return r([t,e,a,n]),m&&(a=rO(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}))(f,p,y)}});var NB=YD({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=rO(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=rO(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return OD.runKernel(WA,u,c)}});var TB=YD({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,l=!1;3===t.rank&&(l=!0,o=rO(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},d=OD.runKernel(VA,u,c);return l?rO(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});var EB=YD({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(!1===IB(OD.state.gradientDepth,u)){let e=VO(t,n,r,a,s,i,o);return null!=l&&(e=CF(e,l)),SB(e,u,c,d)}let h=qD(t,"x","depthwiseConv2d","float32"),p=qD(n,"filter","depthwiseConv2d","float32"),f=h,m=!1;3===h.rank&&(m=!0,f=rO(h,[1,h.shape[0],h.shape[1],h.shape[2]])),rE(4===f.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`)),rE(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),rE(f.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==i&&(i=[1,1]),rE(ZF(r,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`)),nO("fused depthwiseConv2d",a,o);let g,y,b=GF(f.shape,p.shape,r,i,a,o,!0);null!=l&&(g=qD(l,"bias","fused conv2d"),[g]=TD(g,h),KO(b.outShape,g.shape)),null!=c&&(y=qD(c,"prelu weights","fused depthwiseConv2d"));let v=(e,t)=>{rE(JF(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));let[n,s,l,c]=t,d=wB(e,l,u),h=TB(s.shape,d,n,r,a,i,o),p=NB(s,d,n.shape,r,a,i,o);if(null!=c){return[h,p,kB(g,d)]}return[h,p]},x={x:f,filter:p,bias:g,preluActivationWeights:y},w={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};return null==l?qP(((e,t,n)=>{let r=OD.runKernel(fR,x,w);return n([t,e,r]),m&&(r=rO(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}))(f,p):qP(((e,t,n,r)=>{let a=OD.runKernel(fR,x,w);return r([t,e,a,n]),m&&(a=rO(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}))(f,p,g)}});var AB=YD({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}=e;if(!1===IB(OD.state.gradientDepth,i)){let e=oO(t,n,r,a);return null!=s&&(e=CF(e,s)),SB(e,i,o,l)}let u=qD(t,"a","fused matMul"),c=qD(n,"b","fused matMul");[u,c]=TD(u,c);let d=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=a?c.shape[c.rank-1]:c.shape[c.rank-2],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=a?c.shape[c.rank-2]:c.shape[c.rank-1],m=u.shape.slice(0,-2),g=c.shape.slice(0,-2),y=iE(m),b=iE(g);rE(d===h,(()=>`Error in fused matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${r} and transposeB=${a} must match.`));let v,x,w=KO(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),k=rO(u,r?[y,d,p]:[y,p,d]),S=rO(c,a?[b,f,h]:[b,h,f]);null!=s&&(v=qD(s,"bias","fused matMul"),[v]=TD(v,u),KO(w,v.shape)),null!=o&&(x=qD(o,"prelu weights","fused matMul"));let I=(e,t)=>{let n,o,[l,u,c,d]=t,h=wB(rO(e,c.shape),c,i);if(r||a?!r&&a?(n=oO(h,u,!1,!1),o=oO(h,l,!0,!1)):r&&!a?(n=oO(u,h,!1,!0),o=oO(l,h,!1,!1)):(n=oO(u,h,!0,!0),o=oO(h,l,!0,!0)):(n=oO(h,u,!1,!0),o=oO(l,h,!0,!1)),null!=s){return[n,o,kB(d,h)]}return[n,o]},C={a:k,b:S,bias:v,preluActivationWeights:x},N={transposeA:r,transposeB:a,activation:i,leakyreluAlpha:l};return null==s?qP(((e,t,n)=>{let r=OD.runKernel(hR,C,N);return n([e,t,r]),{value:rO(r,w),gradFunc:I}}))(k,S):qP(((e,t,n,r)=>{let a=OD.runKernel(hR,C,N);return r([e,t,a,n]),{value:rO(a,w),gradFunc:I}}))(k,S,v)}});var _B=YD({hammingWindow_:function(e){return yB(e,.54,.46)}});var $B=YD({hannWindow_:function(e){return yB(e,.5,.5)}});var RB=YD({frame_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0,i=[];for(;s+t<=e.size;)i.push(uO(e,s,t)),s+=n;if(r)for(;s<e.size;){let r=s+t-e.size,o=iO([uO(e,s,t-r),SO([r],a)]);i.push(o),s+=n}return 0===i.length?jz([],[0,t]):rO(iO(i),[i.length,t])}});var DB=YD({stft_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:$B;null==r&&(r=gB(t));let s=RB(e,t,n),i=EF(s,a(t));return Oz(i,r)}});var MB=YD({cropAndResize_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=qD(e,"image","cropAndResize"),o=qD(t,"boxes","cropAndResize","float32"),l=qD(n,"boxInd","cropAndResize","int32"),u=o.shape[0];rE(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),rE(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),rE(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),rE(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),rE(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),rE("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));let c={image:i,boxes:o,boxInd:l},d={method:a,extrapolationValue:s,cropSize:r};return OD.runKernel(PA,c,d)}});var FB=YD({flipLeftRight_:function(e){let t=qD(e,"image","flipLeftRight","float32");rE(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));let n={image:t};return OD.runKernel(s_,n,{})}});var OB=YD({grayscaleToRGB_:function(e){let t=qD(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];rE(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),rE(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,CP(t,a)}});var PB=YD({rgbToGrayscale_:function(e){let t=qD(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];rE(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),rE(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));let a,s=t.dtype,i=kF(t,"float32"),o=Uz([.2989,.587,.114]);switch(t.rank){case 2:a=eP("ij,j->i",i,o);break;case 3:a=eP("ijk,k->ij",i,o);break;case 4:a=eP("ijkl,l->ijk",i,o);break;case 5:a=eP("ijklm,m->ijkl",i,o);break;case 6:a=eP("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=SP(a,-1),kF(a,s)}});var LB=YD({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=qD(e,"image","rotateWithOffset","float32");rE(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));let s={image:a},i={radians:t,fillValue:n,center:r};return OD.runKernel(dR,s,i)}});function zB(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);let i=e.shape[0];return n=Math.min(n,i),rE(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),rE(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),rE(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),rE(1===t.rank,(()=>"scores must be a 1D tensor")),rE(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),rE(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}var BB=YD({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=qD(e,"boxes","nonMaxSuppression","float32"),i=qD(t,"scores","nonMaxSuppression","float32"),o=zB(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return OD.runKernel(Y_,{boxes:s,scores:i},l)}});function WB(e,t,n){let r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}(e,t,n||VB)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function VB(e,t){return e>t?1:e<t?-1:0}function UB(e,t,n,r,a){return HB(e,t,n,r,a,0)}function jB(e,t,n,r,a,s){return HB(e,t,n,r,a,0,!1,s,!0)}function GB(e,t,n,r,a,s){return HB(e,t,n,r,a,s,!0)}function HB(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8],u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(XB);let c=s>0?-.5/s:0,d=[],h=[];for(;d.length<n&&u.length>0;){let t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<a)break;let o=!1;for(let l=d.length-1;l>=i;--l){let n=qB(e,s,d[l]);if(n>=r){o=!0;break}if(t.score=t.score*KB(r,c,n),t.score<=a)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(s),h.push(t.score)):t.score>a&&WB(u,t,XB))}let p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));let m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function qB(e,t,n){let r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),h=Math.max(a[1],a[3]),p=(o-s)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;let m=Math.max(s,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function KB(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function XB(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}var YB=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=qD(e,"boxes","nonMaxSuppressionAsync"),i=qD(t,"scores","nonMaxSuppressionAsync"),o=zB(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=UB(u,c,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),Uz(d,"int32")};var QB=YD({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=qD(e,"boxes","nonMaxSuppression"),o=qD(t,"scores","nonMaxSuppression"),l=zB(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},d=OD.runKernel(J_,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}});var JB=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=qD(e,"boxes","nonMaxSuppressionAsync"),o=qD(t,"scores","nonMaxSuppressionAsync"),l=zB(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=GB(c,d,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Uz(h,"int32"),selectedScores:Uz(p)}};var ZB=YD({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=qD(e,"boxes","nonMaxSuppression"),o=qD(t,"scores","nonMaxSuppression"),l=zB(i,o,n,r,a,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},d=OD.runKernel(Q_,u,c);return{selectedIndices:d[0],validOutputs:d[1]}}});var eW=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=qD(e,"boxes","nonMaxSuppressionAsync"),o=qD(t,"scores","nonMaxSuppressionAsync"),l=zB(i,o,n,r,a,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=jB(h,p,u,c,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Uz(f,"int32"),validOutputs:mP(m,"int32")}};var tW=YD({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=qD(e,"images","resizeBilinear");rE(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),rE(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),rE(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=rO(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=OD.runKernel(y$,o,l);return i?rO(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var nW=YD({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=qD(e,"images","resizeNearestNeighbor");rE(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),rE(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),rE("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),rE(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=rO(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=OD.runKernel(m$,o,l);return i?rO(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var rW=YD({threshold_:function(e){let t,n,r,a,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,l=qD(e,"image","threshold"),u=l.shape[0]*l.shape[1],c=EF(Uz([o]),255);if(rE(3===l.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`)),rE(3===l.shape[2]||1===l.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`)),rE("int32"===l.dtype||"float32"===l.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`)),rE("otsu"===s||"binary"===s,(()=>`Method must be binary or otsu, but was ${s}`)),3===l.shape[2]){[t,n,r]=Fz(l,[1,1,1],-1);let e=EF(t,.2989),s=EF(n,.587),i=EF(r,.114);a=CF(CF(e,s),i)}else a=e;if("otsu"===s){c=function(e,t){let n,r,a,s,i,o,l=Uz([-1]),u=Uz([0]),c=Uz([0]);for(let d=0;d<e.size-1;d++){n=uO(e,0,d+1),r=uO(e,d+1),i=TF(bP(n),t),o=TF(bP(r),t);let h=bP(EF(n,uz(0,n.size)));a=TF(h,bP(n));let p=SO(r.shape,n.size),f=CF(uz(0,r.size),p),m=EF(r,f);s=TF(bP(m),bP(r));let g=JP(a,s),y=JP(a,s),b=EF(i,o);c=EF(EF(b,g),y);let v=AP(c,u);u=YO(v,c,u),l=YO(v,Uz([d]),l)}return l}(bO(kF(vz(a),"int32"),ZD([]),256),u)}let d=i?PP(a,c):AP(a,c);return kF(EF(d,255),"int32")}});var aW=YD({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0,i=qD(e,"image","transform","float32"),o=qD(t,"transforms","transform","float32");rE(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),rE(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),rE(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));let l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return OD.runKernel(nR,l,u)}});var sW=YD({bandPart_:function(e,t,n){let r=qD(e,"a","bandPart");rE(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));let a,s,i=r.shape,[o,l]=r.shape.slice(-2);"number"==typeof t?(rE(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),rE(t<=o,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`)),a=qD(t<0?o:t,"numLower","bandPart")):(rE("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),a=YO(OP(t,0),o,gL(t,o))),"number"==typeof n?(rE(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),rE(n<=l,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${l}).`)),s=qD(n<0?l:n,"numUpper","bandPart")):(rE("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),s=YO(OP(n,0),l,gL(n,l)));let u=rO(uz(0,o,1,"int32"),[-1,1]),c=uz(0,l,1,"int32"),d=JP(u,c),h=tL(PP(d,a),_P(d,XP(s))),p=pL([o,l],r.dtype);return rO(zz(aB(rO(r,[-1,o,l])).map((e=>YO(h,e,p)))),i)}});var iW=YD({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,rE(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));let n=e[0].shape[0];for(let t=1;t<e.length;++t)rE(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=Fz(e,e.shape[0],0).map((e=>Lz(e,[0])));rE(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));let n=[],r=e;for(let a=0;a<e.length;++a)n.push(OD.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){let r=EF(bP(EF(n[t],e)),n[t]);e=JP(e,r)}return TF(e,xP(e,"euclidean"))})));return t?zz(n,0):n}});function oW(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return OD.tidy((()=>{rE(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));let n=e.shape[0],r=e.shape[1],a=NP(n),s=SF(e),i=jz([[1]],[1,1]),o=SF(i),l=n>=r?r:n;for(let e=0;e<l;++e){let t=s,l=o,u=a;[o,s,a]=OD.tidy((()=>{let t=uO(s,[e,e],[n-e,1]),l=xP(t),u=uO(s,[e,e],[1,1]),c=YO(AP(u,0),jz([[-1]]),jz([[1]])),d=JP(u,EF(c,l)),h=TF(t,d);o=1===h.shape[0]?SF(i):iO([i,uO(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);let p=XP(TF(oO(c,d),l)),f=uO(s,[e,0],[n-e,r]),m=EF(p,o),g=cB(o);if(0===e)s=JP(f,oO(m,oO(g,f)));else{let t=JP(f,oO(m,oO(g,f)));s=iO([uO(s,[0,0],[e,r]),t],0)}let y=cB(m),b=uO(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=JP(b,oO(oO(b,o),y));else{let t=JP(b,oO(oO(b,o),y));a=iO([uO(a,[0,0],[n,e]),t],1)}return[o,s,a]})),dM([t,l,u])}return!t&&n>r&&(a=uO(a,[0,0],[n,r]),s=uO(s,[0,0],[r,r])),[a,s]}))}var lW,uW=YD({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(rE(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return oW(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=aB(rO(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];return r.forEach((e=>{let[n,r]=oW(e,t);a.push(n),s.push(r)})),[rO(zz(a,0),e.shape),rO(zz(s,0),e.shape)]}}});!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(lW||(lW={}));var cW=YD({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:lW.SUM_BY_NONZERO_WEIGHTS,r=qD(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=qD(t,"weights","computeWeightedLoss"));let s=null==a?r:EF(r,a);if(n===lW.NONE)return s;if(n===lW.SUM)return bP(s);if(n===lW.MEAN){if(null==a)return hL(s);{let e=r.size/a.size,t=TF(bP(s),bP(a));return e>1?TF(t,mP(e)):t}}if(n===lW.SUM_BY_NONZERO_WEIGHTS){if(null==a)return TF(bP(s),mP(r.size));{let e=EF(a,fL(r.shape)),t=kF(bP(kL(e,mP(0))),"float32");return TF(bP(s),t)}}throw Error(`Unknown reduction: ${n}`)}});var dW=YD({absoluteDifference_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:lW.SUM_BY_NONZERO_WEIGHTS,a=qD(e,"labels","absoluteDifference"),s=qD(t,"predictions","absoluteDifference"),i=null;null!=n&&(i=qD(n,"weights","absoluteDifference")),aE(a.shape,s.shape,"Error in absoluteDifference: ");let o=AF(JP(a,s));return cW(o,i,r)}});var hW=YD({cosineDistance_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:lW.SUM_BY_NONZERO_WEIGHTS,s=qD(e,"labels","cosineDistance"),i=qD(t,"predictions","cosineDistance"),o=null;null!=r&&(o=qD(r,"weights","cosineDistance")),aE(s.shape,i.shape,"Error in cosineDistance: ");let l=mP(1),u=JP(l,bP(EF(s,i),n,!0));return cW(u,o,a)}});var pW=YD({hingeLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:lW.SUM_BY_NONZERO_WEIGHTS,a=qD(e,"labels","hingeLoss"),s=qD(t,"predictions","hingeLoss"),i=null;null!=n&&(i=qD(n,"weights","hingeLoss")),aE(a.shape,s.shape,"Error in hingeLoss: ");let o=mP(1);a=JP(EF(mP(2),a),o);let l=hz(JP(o,EF(a,s)));return cW(l,i,r)}});var fW=YD({huberLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:lW.SUM_BY_NONZERO_WEIGHTS,s=qD(e,"labels","huberLoss"),i=qD(t,"predictions","huberLoss"),o=null;null!=n&&(o=qD(n,"weights","huberLoss")),aE(s.shape,i.shape,"Error in huberLoss: ");let l=mP(r),u=AF(JP(i,s)),c=gL(u,l),d=JP(u,c),h=CF(EF(mP(.5),yP(c)),EF(l,d));return cW(h,o,a)}});var mW=YD({logLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:lW.SUM_BY_NONZERO_WEIGHTS,s=qD(e,"labels","logLoss"),i=qD(t,"predictions","logLoss"),o=null;null!=n&&(o=qD(n,"weights","logLoss")),aE(s.shape,i.shape,"Error in logLoss: ");let l=mP(1),u=mP(r),c=XP(EF(s,BP(CF(i,u)))),d=EF(JP(l,s),BP(CF(JP(l,i),u))),h=JP(c,d);return cW(h,o,a)}});var gW=YD({meanSquaredError_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:lW.SUM_BY_NONZERO_WEIGHTS,a=qD(e,"labels","meanSquaredError"),s=qD(t,"predictions","meanSquaredError"),i=null;null!=n&&(i=qD(n,"weights","meanSquaredError")),aE(a.shape,s.shape,"Error in meanSquaredError: ");let o=Pz(a,s);return cW(o,i,r)}});var yW=YD({sigmoidCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:lW.SUM_BY_NONZERO_WEIGHTS,s=qD(e,"multiClassLabels","sigmoidCrossEntropy"),i=qD(t,"logits","sigmoidCrossEntropy"),o=null;if(null!=n&&(o=qD(n,"weights","sigmoidCrossEntropy")),aE(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let e=mP(r),t=mP(1),n=mP(.5);s=CF(EF(s,JP(t,e)),EF(n,e))}let l=function(e,t){let n=qD(e,"labels","sigmoidCrossEntropyWithLogits"),r=qD(t,"logits","sigmoidCrossEntropyWithLogits");aE(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=hz(r),s=EF(r,n),i=WP(kP(XP(AF(r))));return CF(JP(a,s),i)}(s,i);return cW(l,o,a)}});var bW=YD({softmaxCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:lW.SUM_BY_NONZERO_WEIGHTS,s=qD(e,"onehotLabels","softmaxCrossEntropy"),i=qD(t,"logits","softmaxCrossEntropy"),o=null;if(null!=n&&(o=qD(n,"weights","softmaxCrossEntropy")),aE(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let e=mP(r),t=mP(1),n=mP(s.shape[1]);s=CF(EF(s,JP(t,e)),TF(e,n))}let l=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return qP(((e,t,r)=>{let a=eL(t,[n],!0),s=JP(kF(t,"float32"),a);r([e,s]);let i=XP(EF(s,e));return{value:bP(i,[n]),gradFunc:(e,t)=>{let[r,a]=t,s=oP(e.shape,[n]);return[EF(rO(e,s),JP(kF(r,"float32"),kP(a))),EF(rO(e,s),JP(kP(a),kF(r,"float32")))]}}}))(e,t)}(s,i);return cW(l,o,a)}});var vW=YD({sparseFillEmptyRows_:function(e,t,n,r){let a=qD(e,"indices","sparseFillEmptyRows","int32"),s=qD(t,"values","sparseFillEmptyRows"),i=qD(n,"denseShape","sparseFillEmptyRows","int32"),o=qD(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},u=OD.runKernel(z$,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});var xW=YD({sparseReshape_:function(e,t,n){let r=qD(e,"inputIndices","sparseReshape","int32"),a=qD(t,"inputShape","sparseReshape","int32"),s=qD(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=OD.runKernel(B$,i);return{outputIndices:o[0],outputShape:o[1]}}});var wW=YD({sparseSegmentMean_:function(e,t,n){let r=qD(e,"data","sparseSegmentMean"),a=qD(t,"indices","sparseSegmentMean","int32"),s=qD(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return OD.runKernel(W$,i)}});var kW=YD({sparseSegmentSum_:function(e,t,n){let r=qD(e,"data","sparseSegmentSum"),a=qD(t,"indices","sparseSegmentSum","int32"),s=qD(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return OD.runKernel(V$,i)}});var SW=YD({stringNGrams_:function(e,t,n,r,a,s,i,o){let l=qD(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=qD(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=OD.runKernel(K$,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}});var IW=YD({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=qD(e,"input","stringSplit","string"),a=qD(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=OD.runKernel(X$,i,s);return{indices:o[0],values:o[1],shape:o[2]}}});var CW=YD({stringToHashBucketFast_:function(e,t){let n=qD(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return OD.runKernel(Y$,a,r)}});var NW=YD({staticRegexReplace_:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=qD(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return OD.runKernel(H$,{x:a},s)}}),TW={fft:Rz,ifft:Dz,rfft:Oz,irfft:Mz},EW={hammingWindow:_B,hannWindow:$B,frame:RB,stft:DB},AW={flipLeftRight:FB,grayscaleToRGB:OB,resizeNearestNeighbor:nW,resizeBilinear:tW,rgbToGrayscale:PB,rotateWithOffset:LB,cropAndResize:MB,nonMaxSuppression:BB,nonMaxSuppressionAsync:YB,nonMaxSuppressionWithScore:QB,nonMaxSuppressionWithScoreAsync:JB,nonMaxSuppressionPadded:ZB,nonMaxSuppressionPaddedAsync:eW,threshold:rW,transform:aW},_W={bandPart:sW,gramSchmidt:iW,qr:uW},$W={absoluteDifference:dW,computeWeightedLoss:cW,cosineDistance:hW,hingeLoss:pW,huberLoss:fW,logLoss:mW,meanSquaredError:gW,sigmoidCrossEntropy:yW,softmaxCrossEntropy:bW},RW={sparseFillEmptyRows:vW,sparseReshape:xW,sparseSegmentMean:wW,sparseSegmentSum:kW},DW={stringNGrams:SW,stringSplit:IW,stringToHashBucketFast:CW,staticRegexReplace:NW},MW={};ST(MW,{Serializable:()=>PW,SerializationMap:()=>LW,getRegisteredName:()=>BW,registerClass:()=>zW});var FW=new Map,OW=new Map,PW=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},LW=class e{constructor(){this.classNameMap={}}static getMap(){return null==e.instance&&(e.instance=new e),e.instance}static register(t){e.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function zW(e,t,n){rE(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),rE("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),rE(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"==typeof t&&(t="Custom"),"undefined"==typeof n&&(n=e.className);let r=t+">"+n;return LW.register(e),FW.set(r,e),OW.set(e,r),e}function BW(e){return OW.has(e)?OW.get(e):e.className}var WW=class extends PW{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0,{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){let e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return dM(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return HP(e,t)}dispose(){null!=this.iterations_&&dM(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:mP(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(WW,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var VW=class extends WW{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=OD.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=OD.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:cM((()=>QO(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:cM((()=>QO(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;cM((()=>{let e=CF(EF(i,this.rho),EF(yP(s),1-this.rho)),t=EF(TF(gP(CF(o,this.epsilon)),gP(CF(i,this.epsilon))),s),n=CF(EF(o,this.rho),EF(yP(t),1-this.rho));i.assign(e),o.assign(n);let a=CF(EF(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(dM(this.accumulatedGrads.map((e=>e.variable))),dM(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){let t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},UW=class extends WW{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=OD.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:cM((()=>SO(r.shape,this.initialAccumulatorValue).variable(!1)))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[n].variable;cM((()=>{let e=CF(s,yP(a));s.assign(e);let t=CF(EF(TF(a,gP(CF(e,OD.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&dM(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},jW=class extends WW{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],cM((()=>{this.accBeta1=mP(t).variable(),this.accBeta2=mP(n).variable()})),null==r&&(this.epsilon=OD.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);cM((()=>{let n=JP(1,this.accBeta1),r=JP(1,this.accBeta2);t.forEach(((t,a)=>{let s=OD.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:cM((()=>QO(s).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:cM((()=>QO(s).variable(i)))});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,c=CF(EF(l,this.beta1),EF(o,1-this.beta1)),d=CF(EF(u,this.beta2),EF(yP(o),1-this.beta2)),h=TF(c,n),p=TF(d,r);l.assign(c),u.assign(d);let f=CF(EF(TF(h,CF(gP(p),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(EF(this.accBeta1,this.beta1)),this.accBeta2.assign(EF(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&dM(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&dM(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),cM((()=>{this.accBeta1.assign(fP(this.beta1,this.iterations_+1)),this.accBeta2.assign(fP(this.beta2,this.iterations_+1))}));let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},GW=class extends WW{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],cM((()=>{this.iteration=mP(0).variable(),this.accBeta1=mP(t).variable()})),null==r&&(this.epsilon=OD.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);cM((()=>{let n=JP(1,this.accBeta1),r=TF(-this.learningRate,CF(EF(this.iteration,this.decay),1));t.forEach(((t,a)=>{let s=OD.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:QO(s).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:QO(s).variable(i)});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,c=CF(EF(l,this.beta1),EF(o,1-this.beta1)),d=EF(u,this.beta2),h=AF(o),p=dL(d,h);l.assign(c),u.assign(p);let f=CF(EF(TF(r,n),TF(c,CF(p,this.epsilon))),s);s.assign(f)})),this.iteration.assign(CF(this.iteration,1)),this.accBeta1.assign(EF(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&dM(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&dM(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},HW=class extends WW{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let a=OD.registeredVariables[t];cM((()=>{let e=CF(EF(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=hM(mP(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},qW=class extends HW{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=mP(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=OD.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:cM((()=>QO(r).variable(!1)))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&cM((()=>{let e,t=CF(EF(this.m,a),s);e=this.useNesterov?CF(EF(this.c,CF(s,EF(t,this.m))),r):CF(EF(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&dM(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},KW=class extends WW{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=OD.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=OD.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:cM((()=>QO(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:cM((()=>QO(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:cM((()=>QO(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;cM((()=>{let e=CF(EF(i,this.decay),EF(yP(s),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,a=CF(EF(t,this.decay),EF(s,1-this.decay)),l=TF(EF(s,this.learningRate),gP(JP(e,CF(yP(a),this.epsilon)))),u=CF(EF(o,this.momentum),l);i.assign(e),t.assign(a),o.assign(u);let c=JP(r,u);r.assign(c)}else{let e=CF(EF(i,this.decay),EF(yP(s),1-this.decay)),t=CF(EF(o,this.momentum),TF(EF(s,this.learningRate),gP(CF(e,this.epsilon))));i.assign(e),o.assign(t);let n=JP(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&dM(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&dM(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&dM(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},XW=[VW,UW,jW,GW,qW,KW,HW];var YW={};ST(YW,{CompositeArrayBuffer:()=>tM,browserFiles:()=>eV,browserHTTPRequest:()=>uV,concatenateArrayBuffers:()=>MM,copyModel:()=>yF,decodeWeights:()=>CM,decodeWeightsStream:()=>_M,encodeWeights:()=>IM,fromMemory:()=>pV,fromMemorySync:()=>fV,getLoadHandlers:()=>GM,getModelArtifactsForJSON:()=>LM,getModelArtifactsForJSONSync:()=>PM,getModelArtifactsInfoForJSON:()=>zM,getSaveHandlers:()=>jM,getWeightSpecs:()=>BM,http:()=>lV,isHTTPScheme:()=>iV,listModels:()=>mF,loadWeights:()=>rV,moveModel:()=>bF,registerLoadRouter:()=>UM,registerSaveRouter:()=>VM,removeModel:()=>gF,weightsLoaderFactory:()=>aV,withSaveHandler:()=>mV,withSaveHandlerSync:()=>gV});function QW(e){return new Promise((e=>setTimeout(e))).then(e)}var JW=class e{constructor(t){if(!HE().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),(null==t||0===t.length)&&(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=tM.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=OM(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await QW((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await QW((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:zM(e)}}}};JW.URL_SCHEME="downloads://";var ZW=class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});let s=LM(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{let a=new FileReader;a.onload=e=>{let t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map((e=>FM(e.name))),r={};for(let a of e)a.paths.forEach((e=>{let a=FM(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}};function eV(e){return new ZW(e)}function tV(e,t,n,r){var a;rE(null!=(a=e)&&Array.isArray(a)&&a.length>0,(()=>"promises must be a none empty array")),function(e,t){rE(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),rE(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),rE(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((a=>(a.then((a=>{let i=n+ ++s/e.length*(r-n);return t(i),a})),a))))}async function nV(e,t){null==t&&(t={});let n=null==t.fetchFunc?HE().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await tV(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await tV(a,t.onProgress,.5,1)}async function rV(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return aV((e=>nV(e,{requestInit:r})))(e,t,n)}function aV(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0,a=t.map((()=>!1)),s={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{let l="quantization"in e?e.quantization.dtype:e.dtype,u=eM[l]*iE(e.shape),c=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){let e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{let t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));let c=await e(u),d={},h=0;return l.forEach((e=>{let n=t[e].paths.length,r=new tM(c.slice(h,h+n));s[e].forEach((e=>{let t=CM(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(let n in t)d[n]=t[n]})),h+=n})),d}}WM.registerSaveRouter((e=>HE().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(JW.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new JW(e)}(e.slice(JW.URL_SCHEME.length)):null));var sV=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(rE("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=HE().platform.fetch,rE(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&rE(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=OM(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){let n=tM.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:zM(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(zge){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}let n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return LM(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=BM(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;let r,a=null==t.fetchFunc?HE().platform.fetch:t.fetchFunc,s=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;s<e.length;){r||(r=(await a(e[s],t.requestInit,{isBinary:!0})).body.getReader());let{done:o,value:l}=await r.read();if(!o)return void n.enqueue(l);s++,r=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,s/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):s.push(a+e+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e);return[BM(e),await nV(t,this.loadOptions)]}};function iV(e){return null!=e.match(sV.URL_SCHEME_REGEX)}sV.URL_SCHEME_REGEX=/^https?:\/\//;var oV=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>iV(e))):iV(e),n)return lV(e,t)}return null};function lV(e,t){return new sV(e,t)}function uV(e,t){return lV(e,t)}WM.registerSaveRouter(oV),WM.registerLoadRouter(oV);var cV=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},dV=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},hV=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function pV(e,t,n,r){return new hV(fV(...arguments))}function fV(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new cV(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new cV({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new cV({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function mV(e){return new dV(e)}function gV(e){return new dV(e)}var yV={};ST(yV,{confusionMatrix:()=>bV});var bV=YD({confusionMatrix_:function(e,t,n){let r=qD(e,"labels","confusionMatrix"),a=qD(t,"predictions","confusionMatrix");rE(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),rE(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),rE(1===a.rank,(()=>`Expected the rank of predictions to be 1, but got ${a.rank}`)),rE(r.shape[0]===a.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`)),rE(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));let s=SL(kF(r,"int32"),n),i=SL(kF(a,"int32"),n),o=cB(s),l=oO(o,i);return kF(l,"int32")}}),vV={};ST(vV,{draw:()=>TV,fromPixels:()=>EV,fromPixelsAsync:()=>IV,toPixels:()=>NV});var xV,wV=!1;function kV(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=vR(cR,OD.backendName)){let n={pixels:e},r={numChannels:t};return OD.runKernel(cR,n,r)}let l,u,[c,d]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(i)l=e.getContext("2d").getImageData(0,0,c,d).data;else if(r||n)l=e.data;else if(s||a||o){if(null==xV)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");xV=new OffscreenCanvas(1,1).getContext("2d")}else xV=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});xV.canvas.width=c,xV.canvas.height=d,xV.drawImage(e,0,0,c,d),l=xV.getImageData(0,0,c,d).data}if(4===t)u=new Int32Array(l);else{let e=c*d;u=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)u[n*t+e]=l[4*n+e]}return Gz(u,[d,c,t],"int32")}function SV(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function IV(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,n=null;if(HE().getBool("WRAP_TO_IMAGEBITMAP")&&SV(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(zge){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return kV(n,t)}function CV(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function NV(e,t){let n=qD(e,"img","toPixels");if(!(e instanceof hD)){let e=n;n=kF(e,"int32"),e.dispose()}CV(n);let[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){let e=[0,0,0,255];for(let r=0;r<s;r++){let t=i[u*s+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===s?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[r]=t*o}let t=4*u;l[t+0]=Math.round(e[0]),l[t+1]=Math.round(e[1]),l[t+2]=Math.round(e[2]),l[t+3]=Math.round(e[3])}if(null!=t){wV||null!=vR(qA,OD.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),wV=!0),t.width=a,t.height=r;let e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function TV(e,t,n){let r=qD(e,"img","draw");if(!(e instanceof hD)){let e=r;r=kF(e,"int32"),e.dispose()}CV(r),function(e){let t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);let a={image:r},s={canvas:t,options:n};OD.runKernel(qA,a,s)}var EV=YD({fromPixels_:kV}),AV={};function _V(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===iE(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let d=0;d<a.length-1;++d)i*=a[d];let o=e.shape,l=a.slice();l.pop();let u=1;for(let d=s;d<n;++d)u*=o[d],l.push(o[d]);let c=[...RE(e.shape).map((e=>e/u)),1].slice(0,s);return[l,i,u,c]}ST(AV,{prepareAndValidate:()=>_V});var $V={};ST($V,{assertParamsValid:()=>MV,computeFlatOffset:()=>qV,computeOutShape:()=>OV,getNormalizedAxes:()=>BV,isSliceContinous:()=>HV,maskToAxes:()=>FV,parseSliceParams:()=>KV,sliceInfo:()=>XV,startForAxis:()=>jV,startIndicesWithElidedDims:()=>WV,stopForAxis:()=>GV,stopIndicesWithElidedDims:()=>VV,stridesForAxis:()=>UV,stridesWithElidedDims:()=>PV});var RV=-2,DV=-1;function MV(e,t,n){let r=e.shape.length;rE(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),rE(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)rE(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function FV(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function OV(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function PV(e,t,n,r){let a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[t]=1:(a.splice(t,0,1),a.pop());return a}function LV(e,t,n){return n<=e?n:n-(t-1)}function zV(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function BV(e,t,n,r,a,s,i,o,l){let u=e.length,c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){let l=t[0],u=n+1;c=WV(i,l,u,r,e),d=VV(o,l,u,a,e),h=PV(s,l,u,e)}else for(let p=0;p<u;p++)c[p]=jV(i,r,s,e,p,l),d[p]=GV(o,a,s,e,p,l),h[p]=UV(s,p,l);return{begin:c,end:d,strides:h}}function WV(e,t,n,r,a){let s=[...a],i=zV(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let a=LV(t,n,o),i=r[a];e&1<<a&&(i=0),s[o]=i}return s}function VV(e,t,n,r,a){let s=[...a],i=zV(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let a=LV(t,n,o),i=r[a];e&1<<a&&(i=Number.MAX_SAFE_INTEGER),s[o]=i}for(let o=0;o<s.length;o++){let e=a[o];s[o]<0&&(s[o]+=e),s[o]=QT(0,s[o],a[o])}return s}function UV(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function jV(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=QT(0,i,l-1),i}function GV(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=o>0?QT(0,i,l):QT(-1,i,l-1),i}function HV(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function qV(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function KV(e,t,n){let r,a,s=e.shape.length;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{rE(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(rE(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function XV(e,t,n,r,a,s,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&1<<b&o&&d.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);let h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(RV),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(DV),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(0===h.strides[b])throw Error(`strides[${b}] must be non-zero`);let t=!!(h.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}let r=[h.beginMask&1<<b,h.endMask&1<<b],a=[h.strides[b]>0?0:-1,h.strides[b]>0?n:n-1];if(t&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[b];let s=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(t){let e=h.begin[b]<0?n+h.begin[b]:h.begin[b];if(h.begin[b]=e,h.end[b]=h.begin[b]+1,e<0||e>=n)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=YV(h.begin[b],0,h.strides[b],n,r,a),h.end[b]=YV(h.end[b],1,h.strides[b],n,r,a);let e=1===h.strides[b]&&0===h.begin[b]&&h.end[b]===n;p=p&&e,f=f&&(0===b&&1===h.strides[b]||e)}else p=p&&1===h.strides[b]&&s,f=f&&(0===b&&1===h.strides[b]||s);let i,o=!1;if(h.beginValid&&h.endValid?(i=h.end[b]-h.begin[b],o=!0):t?(i=1,o=!0):s&&n>=0&&(i=h.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!=h.strides[b]<0?0:Math.trunc(i/h.strides[b])+(i%h.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){let e=h.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===RV&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>h.finalShapeGatherIndices[t]!==RV)),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function YV(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}var QV="4.16.0",JV=class{static sgd(e){return new HW(e)}static momentum(e,t){return new qW(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new KW(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new jW(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new VW(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new GW(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new UW(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},ZV=JV,eU="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function tU(){return new Promise((e=>eU((()=>e()))))}var nU,rU={};function aU(e,t){let n=e[0].length;e.forEach(((e,t)=>{rE(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),rE(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));let r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)rE(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function sU(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function iU(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function oU(e){let t={FIRST_DIM_SIZE:nU.FIRST_DIM_SIZE,VALUE_ROWIDS:nU.VALUE_ROWIDS,ROW_LENGTHS:nU.ROW_LENGTHS,ROW_SPLITS:nU.ROW_SPLITS,ROW_LIMITS:nU.ROW_LIMITS,ROW_STARTS:nU.ROW_STARTS},n=[];for(let r of e){if(!(r in t))break;n.push(t[r])}return n}function lU(e){return 0===e.length?0:e[0]===nU.FIRST_DIM_SIZE?e.length-1:e.length}function uU(e,t){if(null==e||null==t)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}ST(rU,{ERF_A1:()=>wU,ERF_A2:()=>kU,ERF_A3:()=>SU,ERF_A4:()=>IU,ERF_A5:()=>CU,ERF_P:()=>xU,PARALLELIZE_THRESHOLD:()=>cU,RowPartitionType:()=>nU,SELU_SCALE:()=>vU,SELU_SCALEALPHA:()=>bU,applyActivation:()=>SB,assertAndGetBroadcastShape:()=>KO,assertAxesAreInnerMostDims:()=>lP,assertParamsConsistent:()=>aU,assignToTypedArray:()=>$U,axesAreInnerMostDims:()=>aP,calculateShapes:()=>Jz,checkEinsumDimSizes:()=>BU,checkPadOnDimRoundingMode:()=>nO,combineLocations:()=>sP,combineRaggedTensorToTensorShapes:()=>iU,complexWithEvenIndex:()=>EU,complexWithOddIndex:()=>AU,computeConv2DInfo:()=>GF,computeConv3DInfo:()=>HF,computeDefaultPad:()=>qF,computeDilation2DInfo:()=>VF,computeOptimalWindowSize:()=>dU,computeOutAndReduceShapes:()=>iP,computeOutShape:()=>sU,computePool2DInfo:()=>UF,computePool3DInfo:()=>jF,convertConv2DDataFormat:()=>tO,decodeEinsumEquation:()=>LU,eitherStridesOrDilationsAreOne:()=>ZF,expandShapeToKeepDim:()=>oP,exponent:()=>DU,exponents:()=>RU,fromStringArrayToUint8:()=>lj,fromUint8ToStringArray:()=>oj,getAxesPermutation:()=>uP,getBroadcastDims:()=>HO,getComplexWithIndex:()=>_U,getEinsumComputePath:()=>WU,getEinsumPermutation:()=>zU,getFusedBiasGradient:()=>kB,getFusedDyActivation:()=>wB,getImageCenter:()=>hU,getInnerMostAxes:()=>dP,getPermuted:()=>fU,getRaggedRank:()=>lU,getReductionAxes:()=>qO,getReshaped:()=>pU,getReshapedPermuted:()=>mU,getRowPartitionTypesHelper:()=>oU,getSliceBeginCoords:()=>gU,getSliceSize:()=>yU,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>GU,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>HU,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>qU,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>YU,getSparseReshapeInputOutputMismatchErrorMessage:()=>JU,getSparseReshapeInputOutputMultipleErrorMessage:()=>QU,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>KU,getSparseReshapeNegativeOutputDimErrorMessage:()=>XU,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>nj,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>ZU,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>ej,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>tj,getUndoAxesPermutation:()=>cP,isIdentityPermutation:()=>VU,log:()=>gR,mergeRealAndImagArrays:()=>NU,prepareAndValidate:()=>_V,prepareSplitSize:()=>jU,segment_util:()=>rj,shouldFuse:()=>IB,slice_util:()=>$V,splitRealAndImagArrays:()=>TU,stridesOrDilationsArePositive:()=>eO,tupleValuesAreOne:()=>JF,upcastType:()=>SD,validateDefaultValueShape:()=>uU,validateInput:()=>Qz,validateUpdateShape:()=>Yz,warn:()=>mR}),function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(nU||(nU={}));var cU=30;function dU(e){return e<=cU?e:$E(e,Math.floor(Math.sqrt(e)))}function hU(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function pU(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function fU(e,t){let n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{let r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function mU(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function gU(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function yU(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var bU=1.7580993408473768,vU=1.0507009873554805,xU=.3275911,wU=.254829592,kU=-.284496736,SU=1.421413741,IU=-1.453152027,CU=1.061405429;function NU(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function TU(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function EU(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function AU(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function _U(e,t){return{real:e[2*t],imag:e[2*t+1]}}function $U(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function RU(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function DU(e,t,n){let r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}var MU="->",FU=/->/g,OU=",",PU="...";function LU(e,t){let n=((e=e.replace(/\s/g,"")).length-e.replace(FU,"").length)/MU.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${MU}").`);let[r,a]=e.split(MU);rE(-1===r.indexOf(PU),(()=>`The ellipsis notation ("${PU}") is not supported yet.`));let s=r.split(OU),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let d=0;d<a.length;++d){let e=a[d];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<r.length;++d){let e=r[d];-1===o.indexOf(e)&&e!==OU&&o.push(e)}let l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let e=0;e<s[d].length;++e)l[d].push(o.indexOf(s[d][e]))}let u=o.length,c=[];for(let d=a.length;d<u;++d)c.push(d);return{allDims:o,summedDims:c,idDims:l}}function zU(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function BU(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:rE(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function WU(e,t){let n=e,r=[],a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);let s=[];for(let i=0;i<n.length;++i){let e=UU(t,n[i]);for(let t of e)-1===s.indexOf(t)&&(r[i].push(t),s.push(t))}return{path:n,steps:r}}function VU(e){return e.every(((e,t)=>e===t))}function UU(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}function jU(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"==typeof t)rE(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{rE(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));let a=t.indexOf(-1);if(-1!==a){let r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}rE(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function GU(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function HU(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function qU(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function KU(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function XU(e,t){return`size ${e} must be non-negative, not ${t}`}function YU(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function QU(e,t){return`Input to reshape is a SparseTensor with ${iE(e)}\n  dense values, but the requested shape requires a multiple of ${iE(t)}. inputShape=${e} outputShape= ${t}`}function JU(e,t){return`Input to reshape is a tensor with ${iE(e)} dense values, but the requested shape has ${iE(t)}. inputShape=${e} outputShape=${t}`}function ZU(){return"segment ids must be >= 0"}function ej(){return"segment ids are not increasing"}function tj(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function nj(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var rj={};function aj(e,t){let n,r=!1;for(e<=cU?(n=e,r=!0):n=$E(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=$E(e,n+1);return n}function sj(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function ij(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let i=e.shape[n],o=[],l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<a;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function oj(e){try{return e.map((e=>XR(e)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function lj(e){return e.map((e=>KR(e)))}ST(rj,{collectGatherOpShapeInfo:()=>ij,computeOutShape:()=>sj,segOpComputeOptimalWindowSize:()=>aj});var uj={};ST(uj,{nonMaxSuppressionV3Impl:()=>UB,nonMaxSuppressionV4Impl:()=>jB,nonMaxSuppressionV5Impl:()=>GB,whereImpl:()=>oB}),function(){for(let e of XW)zW(e)}();var cj={kernelName:QE,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(e,Bz(kF(n,"float32"),-1))}}},dj={kernelName:JE,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=yP(kF(n,"float32")),r=gP(JP(mP(1),t));return XP(TF(e,r))}}}},hj={kernelName:ZE,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=gP(JP(yP(kF(n,"float32")),1));return TF(e,t)}}}},pj={kernelName:eA,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=KO(n.shape,r.shape);return{a:()=>{let t=e,r=qO(n.shape,a);return r.length>0&&(t=bP(t,r)),rO(t,n.shape)},b:()=>{let t=e,n=qO(r.shape,a);return n.length>0&&(t=bP(t,n)),rO(t,r.shape)}}}},fj={kernelName:tA,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},mj={kernelName:aA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>QO(n)}}},gj={kernelName:sA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>QO(n)}}},yj={kernelName:iA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,gP(JP(mP(1),yP(kF(n,"float32")))))}}},bj={kernelName:oA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=gP(CF(mP(1),yP(kF(n,"float32"))));return TF(e,t)}}}},vj={kernelName:cA,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=KO(n.shape,r.shape);return{a:()=>{let t=CF(yP(n),yP(r)),s=EF(e,TF(r,t)),i=qO(n.shape,a);return i.length>0&&(s=bP(s,i)),rO(s,n.shape)},b:()=>{let t=CF(yP(n),yP(r)),s=XP(EF(e,TF(n,t))),i=qO(r.shape,a);return i.length>0&&(s=bP(s,i)),rO(s,r.shape)}}}},xj={kernelName:lA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,CF(yP(kF(n,"float32")),1))}}},wj={kernelName:uA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,JP(mP(1),yP(kF(n,"float32"))))}}};var kj=YD({avgPool3dGrad_:function(e,t,n,r,a,s){let i=qD(e,"dy","avgPool3dGrad"),o=qD(t,"input","avgPool3dGrad"),l=i,u=o,c=!1;4===o.rank&&(c=!0,l=rO(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=rO(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),rE(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),rE(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),nO("avgPool3dGrad",a,s);let d={dy:l,input:u},h={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=OD.runKernel(fA,d,h);return c?rO(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),Sj={kernelName:pA,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>kj(e,r,a,s,i,o)}}};var Ij=YD({avgPoolGrad_:function(e,t,n,r,a){let s=qD(e,"dy","avgPoolGrad"),i=qD(t,"input","avgPoolGrad");rE(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=rO(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=rO(s,[1,s.shape[0],s.shape[1],s.shape[2]])),rE(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),rE(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));let c={dy:l,input:o},d={filterSize:n,strides:r,pad:a},h=OD.runKernel(hA,c,d);return u?rO(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Cj={kernelName:dA,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>Ij(e,r,a,s,i)}}},Nj={kernelName:mA,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>oO(e,a,!1,!1),b:()=>oO(e,r,!0,!1)}:s&&!i?{a:()=>oO(a,e,!1,!0),b:()=>oO(r,e,!1,!1)}:{a:()=>oO(a,e,!0,!0),b:()=>oO(e,r,!0,!0)}:{a:()=>oO(e,a,!1,!0),b:()=>oO(r,e,!0,!1)}}},Tj={kernelName:gA,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>$L(e,r,a)}}},Ej={kernelName:vA,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>bP(e,o,!0)}}},Aj={kernelName:wA,gradFunc:e=>({x:()=>e.clone()})},_j={kernelName:kA,gradFunc:e=>({x:()=>QO(e)})},$j={kernelName:SA,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>YO(tL(_P(r,a),PP(r,s)),e,QO(e))}}},Rj={kernelName:CA,inputsToSave:["x"],gradFunc:cj.gradFunc},Dj={kernelName:NA,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map((e=>e.shape)),{axis:a}=n,s=yE(a,t[0].shape)[0],i=r.map((e=>e[s]));return Fz(e,i,s).map((e=>()=>e))}},Mj={kernelName:TA,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return rE(JF(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>$O(r.shape,e,a,i,o,l),filter:()=>xB(r,e,a.shape,i,o,l)}}},Fj={kernelName:AA,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>AO(e,a,s,i,o,1,l),filter:()=>xB(e,r,a.shape,s,i,o,l)}}};var Oj=YD({conv3DBackpropFilter_:function(e,t,n,r,a){let s=e;4===e.rank&&(s=rO(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=rO(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),rE(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),rE(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),rE(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),rE(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),rE(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return OD.runKernel($A,o,l)}}),Pj={kernelName:_A,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;rE(JF(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));let[i,o]=t;return{x:()=>MO(i.shape,e,o,a,s),filter:()=>Oj(i,e,o.shape,a,s)}}},Lj={kernelName:DA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(XP(Cz(kF(n,"float32"))),e)}}},zj={kernelName:MA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(Nz(kF(n,"float32")),e)}}},Bj={kernelName:OA,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let t=uP([a],r.rank),n=zO(e,a,s,!i);return null!=t&&(n=cB(n,t)),n}}}},Wj={kernelName:BA,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;rE(JF(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));let[l,u]=t;return rE(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),rE(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),rE(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),rE(ZF(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),nO("depthwiseConv2d",s,i),{x:()=>TB(l.shape,e,u,a,s,o,i),filter:()=>NB(l,e,u.shape,a,s,o,i)}}},Vj={kernelName:jA,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>OD.runKernel(GA,s,n),filter:()=>OD.runKernel(HA,i,n)}}},Uj={kernelName:YA,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>OD.runKernel(QA,r)}}},jj={kernelName:JA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=EF(kP(XP(yP(n))),2/Math.sqrt(Math.PI));return{x:()=>EF(e,r)}}},Gj={kernelName:e_,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(e,n)}}},Hj={kernelName:t_,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>rO(e,n.shape)}}},qj={kernelName:n_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(e,kP(n))}}},Kj={kernelName:i_,gradFunc:e=>({x:()=>QO(e)})},Xj={kernelName:o_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=KO(n.shape,r.shape);return{a:()=>{let t=TF(e,kF(r,"float32")),s=qO(n.shape,a);return s.length>0?rO(bP(t,s),n.shape):t},b:()=>{let t=EF(e,kF(n,"float32")),s=qO(r.shape,a);s.length>0&&(t=rO(bP(t,s),r.shape));let i=yP(r);return XP(TF(t,kF(i,"float32")))}}}},Yj={kernelName:l_,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?mP(1):o,u=qO(s.shape,a.shape),c=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)c.push(a.shape[e]);c.push(1)}let d=JP(a,s),h=EF(e,l),p=xz(CF(i,mP(r))),f=EF(EF(EF(p,p),p),mP(-.5));return{x:()=>1===s.rank?rO(EF(EF(e,CP(rO(p,[1,1,1,s.shape[0]]),c)),l),a.shape):rO(EF(EF(e,p),l),a.shape),mean:()=>{let e=EF(EF(p,mP(-1)),h);return 1===s.rank&&(e=bP(e,u)),rO(e,s.shape)},variance:()=>{let e=EF(EF(f,d),h);return 1===s.rank&&(e=bP(e,u)),rO(e,s.shape)},scale:()=>{let t=EF(d,p),n=EF(e,t);return 1===s.rank&&(n=bP(n,u)),rO(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=bP(t,u)),rO(t,s.shape)}}}},Qj={kernelName:u_,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s,batchDims:i}=n,o=yE(s,r.shape)[0],l=(e,t,n)=>()=>{let r=e.shape,a=t.size,i=r.slice(0,o),l=i.length,u=r.slice(s,r.length).slice(1),c=u.length,d=Jj(0,l),h=Jj(l+1,l+1+c),p=Zj([i,[a],u]),f=rO(n,p),m=rO(t,[a]),g=Zj([[l],d,h]),y=cB(f,g),b=rB(y,m,e.shape[o]),v=cP(g);return b=cB(b,v),b};if(1===i){let t=r.shape[0],n=r.split(t,0);return{x:()=>zz(n.map(((t,n)=>l(t,a.slice(n,1),e.slice(n,1))()))).reshape(r.shape),indices:()=>a}}return{x:l(r,a,e),indices:()=>a}}};function Jj(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Zj(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var eG={kernelName:h_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>QO(n),b:()=>QO(r)}}},tG={kernelName:p_,gradFunc:e=>({x:()=>kF(e,"float32")})},nG={kernelName:g_,gradFunc:e=>({x:()=>QO(e)})},rG={kernelName:y_,gradFunc:e=>({x:()=>QO(e)})},aG={kernelName:b_,gradFunc:e=>({x:()=>QO(e)})},sG={kernelName:v_,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=AP(r,0);return{x:()=>YO(s,e,EF(e,a))}}},iG={kernelName:I_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,CF(n,1))}}},oG={kernelName:S_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,kF(n,"float32"))}}},lG={kernelName:A_,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let t=kP(r);return JP(e,EF(bP(e,a,!0),t))}}}};var uG=YD({localResponseNormalizationBackprop_:function(e,t,n){let r={x:e,y:t,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return OD.runKernel(R_,r,a)}}),cG={kernelName:$_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>uG(r,a,e,s,i,o,l)}}};function dG(e,t,n,r){return t.rank<n.rank&&(t=rO(t,oP(t.shape,r))),e.rank<n.rank&&(e=rO(e,oP(e.shape,r))),{x:()=>EF(e,kF(XO(n,t),e.dtype))}}var hG={kernelName:M_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=dG(e,t[1],s,yE(a,s.shape));return{x:()=>i.x()}}},pG={kernelName:F_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>EF(e,kF(_P(n,r),"float32")),b:()=>EF(e,kF(OP(n,r),"float32"))}}};var fG=YD({maxPool3dGrad_:function(e,t,n,r,a,s,i){let o=qD(e,"dy","maxPool3dGrad"),l=qD(t,"input","maxPool3dGrad"),u=qD(n,"output","maxPool3dGrad"),c=o,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=rO(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=rO(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=rO(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),rE(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),rE(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),rE(5===h.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),nO("maxPool3dGrad",s,i);let f={dy:c,input:d,output:h},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=OD.runKernel(z_,f,m);return p?rO(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),mG={kernelName:L_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>fG(e,r,a,s,i,o,l)}}};var gG=YD({maxPoolGrad_:function(e,t,n,r,a,s,i){let o=qD(e,"dy","maxPoolGrad"),l=qD(t,"input","maxPoolGrad"),u=qD(n,"output","maxPoolGrad");rE(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),rE(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),rE(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),nO("maxPoolGrad",s,i);let c={dy:o,input:l,output:u},d={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return OD.runKernel(P_,c,d)}}),yG={kernelName:O_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>gG(e,r,a,s,i,o)}}},bG={kernelName:W_,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=yE(a,r.shape),i=iE(iP(r.shape,s)[1]);return{x:()=>{let t=r.shape.slice();s.forEach((e=>{t[e]=1}));let n=rO(e,t);return TF(EF(n,fL(r.shape,"float32")),i)}}}},vG={kernelName:V_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=dG(e,i,s,yE(a,s.shape));return{x:()=>o.x()}}},xG={kernelName:U_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>EF(e,kF(PP(n,r),"float32")),b:()=>EF(e,kF(AP(n,r),"float32"))}}},wG={kernelName:j_,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>uO(e,s,r.shape)}}},kG={kernelName:G_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=KO(n.shape,r.shape);return{a:()=>{let t=qO(n.shape,a);return t.length>0?rO(bP(e,t),n.shape):e},b:()=>{let t=EF(e,XP(TP(TF(n,r)))),s=qO(r.shape,a);return s.length>0?rO(bP(t,s),r.shape):t}}}},SG={kernelName:q_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=KO(n.shape,r.shape);return{a:()=>{let t=EF(e,kF(r,"float32")),s=qO(n.shape,a);return s.length>0?rO(bP(t,s),n.shape):t},b:()=>{let t=EF(e,kF(n,"float32")),s=qO(r.shape,a);return s.length>0?rO(bP(t,s),r.shape):t}}}},IG={kernelName:K_,gradFunc:e=>({x:()=>XP(e)})},CG={kernelName:e$,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>pL(n.shape,"float32")}}},NG={kernelName:Z_,gradFunc:e=>({x:()=>QO(e)})},TG={kernelName:t$,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return aB(e,r).map((e=>()=>e))}},EG={kernelName:n$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>uO(e,s,r.shape)}}},AG={kernelName:a$,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=KO(s.shape,i.shape);return{a:()=>{let t=kF(i,"float32"),n=EF(e,EF(t,fP(s,JP(t,mP(1))))),r=qO(s.shape,o);return r.length>0&&(n=bP(n,r)),rO(n,s.shape)},b:()=>{let t=AP(s,0),n=YO(t,BP(s),QO(s)),r=EF(e,EF(a,n)),l=qO(i.shape,o);return l.length>0&&(r=bP(r,l)),rO(r,i.shape)}}}},_G={kernelName:s$,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=AP(n,0);return{x:()=>YO(a,e,EF(e,r)),alpha:()=>{let t=YO(a,QO(e),EF(e,n)),s=qO(r.shape,e.shape);return s.length>0&&(t=bP(t,s)),rO(t,r.shape)}}}};function $G(e,t,n){let r=e.shape.length,a=r-n.length,s=rU.getAxesPermutation(n,r),i=e;null!=s&&(i=cB(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){let r=e.shape.slice();r[n]=1;let a=rO(t,r),s=LO(e,n,!0,!1),i=LO(e,n,!0,!0),o=EF(s,i);return EF(a,o)}(i.reshape(o),t,a);if(u=u.reshape(i.shape),null!=s){let e=rU.getUndoAxesPermutation(s);u=cB(u,e)}return u}var RG={kernelName:i$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return s=null==a?r.shape.map(((e,t)=>t)):"number"==typeof a?[a]:a,{x:()=>$G(r,e,s)}}},DG={kernelName:KA,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=KO(n.shape,r.shape);return{a:()=>{let t=TF(e,kF(r,"float32")),s=qO(n.shape,a);return s.length>0?rO(bP(t,s),n.shape):t},b:()=>{let t=EF(e,kF(n,"float32")),s=qO(r.shape,a);s.length>0&&(t=rO(bP(t,s),r.shape));let i=yP(r);return XP(TF(t,kF(i,"float32")))}}}},MG={kernelName:h$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,XP(yP(n)))}}},FG={kernelName:v$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=EF(PP(n,6),Bz(n));return{x:()=>EF(e,kF(r,"float32"))}}},OG={kernelName:p$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(e,kF(Bz(n),"float32"))}}},PG={kernelName:f$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>rO(e,n.shape)}}},LG={kernelName:y$,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>OD.runKernel(b$,a,n)}}},zG={kernelName:m$,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>OD.runKernel(g$,a,n)}}},BG={kernelName:x$,gradFunc:(e,t,n)=>{let{dims:r}=n,a=yE(r,e.shape);return{x:()=>fz(e,a)}}},WG={kernelName:w$,gradFunc:e=>({x:()=>QO(e)})},VG={kernelName:k$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>XP(TF(e,EF(fP(n,1.5),2)))}}},UG={kernelName:N$,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>kF(QO(n),"float32"),t:()=>EF(e,kF(n,e.dtype)),e:()=>EF(e,kF(nL(n),e.dtype))}}},jG={kernelName:T$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=AP(n,mP(0)),r=mP(bU),a=mP(vU),s=EF(e,a),i=EF(EF(e,r),kP(kF(n,"float32")));return YO(t,s,i)}}}},GG={kernelName:R$,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(e,EF(n,JP(mP(1),n)))}}},HG={kernelName:$$,gradFunc:e=>({x:()=>QO(e)})},qG={kernelName:A$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(OO(kF(n,"float32")),e)}}},KG={kernelName:_$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(PO(kF(n,"float32")),e)}}},XG={kernelName:E$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=KV(r,a,s),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>NL(e,u)}}},YG={kernelName:L$,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=EF(e,r);return{logits:()=>JP(s,EF(bP(s,[a],true),r))}}},QG={kernelName:D$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(e,lO(n))}}},JG={kernelName:O$,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>hO(e,r,a)}}},ZG={kernelName:P$,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>iO(e,r)}}},eH={kernelName:M$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,EF(gP(kF(n,"float32")),2))}}},tH={kernelName:G$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(e,EF(kF(n,"float32"),2))}}},nH={kernelName:j$,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=mP(2);return{a:()=>EF(e,EF(a,JP(n,r))),b:()=>EF(e,EF(a,JP(r,n)))}}},rH={kernelName:uR,gradFunc:e=>({x:()=>QO(e)})},aH={kernelName:Q$,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=KO(n.shape,r.shape);return{a:()=>{let t=e,r=qO(n.shape,a);return r.length>0&&(t=bP(t,r)),rO(t,n.shape)},b:()=>{let t=e,n=qO(r.shape,a);return n.length>0&&(t=bP(t,n)),rO(XP(t),r.shape)}}}},sH={kernelName:F$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;yE(s,r.shape).forEach((e=>{a[e]=1}));let i=rO(e,a),o=EF(i,fL(r.shape,"float32"));return{x:()=>o}}},iH={kernelName:J$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>TF(e,yP(OO(n)))}}},oH={kernelName:Z$,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EF(JP(mP(1),yP(n)),e)}}},lH={kernelName:eR,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let t=QO(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=CF(t,uO(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=CF(t,uO(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=CF(t,uO(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=CF(t,uO(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},uH={kernelName:rR,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=cP(a);return{x:()=>cB(e,s)}}},cH={kernelName:sR,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>zz(e,a)}}},dH={kernelName:iR,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>function(e,t){let n=dL(t,QO(t)),r=EP(e,n),a=_P(t,mP(0,"int32")),s=r.rank-a.rank;for(let o=0;o<s;++o)a=SP(a,o+1);a=tL(a,fL(r.shape,"bool"));let i=QO(r);return YO(a,r,i)}(e,n)}}};var hH={kernelName:lR,gradFunc:e=>({x:()=>QO(e)})},pH=[cj,dj,hj,pj,fj,mj,gj,yj,bj,vj,xj,wj,Sj,Cj,Nj,Tj,Ej,Aj,_j,$j,Rj,Dj,Fj,Mj,Pj,Lj,zj,Bj,Wj,Vj,DG,Uj,jj,Gj,Hj,qj,Xj,Kj,Yj,Qj,eG,tG,nG,rG,aG,sG,iG,oG,lG,cG,hG,hG,pG,mG,yG,bG,vG,xG,wG,kG,SG,IG,CG,NG,TG,EG,EG,AG,_G,RG,MG,FG,OG,PG,LG,zG,BG,WG,VG,UG,jG,GG,HG,qG,KG,XG,YG,QG,JG,JG,ZG,ZG,eH,nH,tH,rH,aH,sH,iH,oH,lH,uH,cH,dH,hH];for(let n of pH)SR(n);pD().prototype.abs=function(){return this.throwIfDisposed(),AF(this)},pD().prototype.acos=function(){return this.throwIfDisposed(),_F(this)},pD().prototype.acosh=function(){return this.throwIfDisposed(),$F(this)},pD().prototype.add=function(e){return this.throwIfDisposed(),CF(this,e)},pD().prototype.all=function(e,t){return this.throwIfDisposed(),DF(this,e,t)},pD().prototype.any=function(e,t){return this.throwIfDisposed(),MF(this,e,t)},pD().prototype.argMax=function(e){return this.throwIfDisposed(),FF(this,e)},pD().prototype.argMin=function(e){return this.throwIfDisposed(),OF(this,e)},pD().prototype.asScalar=function(){return this.throwIfDisposed(),rE(1===this.size,(()=>"The array must have only 1 element.")),rO(this,[])},pD().prototype.asType=function(e){return this.throwIfDisposed(),kF(this,e)},pD().prototype.as1D=function(){return this.throwIfDisposed(),rO(this,[this.size])},pD().prototype.as2D=function(e,t){return this.throwIfDisposed(),rO(this,[e,t])},pD().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),rO(this,[e,t,n])},pD().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),rO(this,[e,t,n,r])},pD().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),rO(this,[e,t,n,r,a])},pD().prototype.asin=function(){return this.throwIfDisposed(),PF(this)},pD().prototype.asinh=function(){return this.throwIfDisposed(),LF(this)},pD().prototype.atan=function(){return this.throwIfDisposed(),zF(this)},pD().prototype.atan2=function(e){return this.throwIfDisposed(),BF(this,e)},pD().prototype.atanh=function(){return this.throwIfDisposed(),WF(this)},pD().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),aO(this,e,t,n,r)},pD().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),hO(this,e,t)},pD().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),fO(this,e,t,n,r,a)},pD().prototype.broadcastTo=function(e){return this.throwIfDisposed(),wO(this,e)},pD().prototype.cast=function(e){return this.throwIfDisposed(),kF(this,e)},pD().prototype.ceil=function(){return this.throwIfDisposed(),kO(this)},pD().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),IO(this,e,t)},pD().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof hD&&(e=[e]),iO([this,...e],t)},pD().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),_O(this,e,t,n,r,a,s)},pD().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),RO(this,e,t,n,r,a)},pD().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),AO(this,e,t,n,r,a,s)},pD().prototype.cos=function(){return this.throwIfDisposed(),OO(this)},pD().prototype.cosh=function(){return this.throwIfDisposed(),PO(this)},pD().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),LO(this,e,t,n)},pD().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),zO(this,e,t,n)},pD().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),WO(this,e,t)},pD().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),VO(this,e,t,n,r,a,s)},pD().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),jO(this,e,t,n,r,a)},pD().prototype.divNoNan=function(e){return this.throwIfDisposed(),JO(this,e)},pD().prototype.div=function(e){return this.throwIfDisposed(),TF(this,e)},pD().prototype.dot=function(e){return this.throwIfDisposed(),ZO(this,e)},pD().prototype.elu=function(){return this.throwIfDisposed(),tP(this)},pD().prototype.equal=function(e){return this.throwIfDisposed(),XO(this,e)},pD().prototype.erf=function(){return this.throwIfDisposed(),rP(this)},pD().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),wP(this,e,t)},pD().prototype.exp=function(){return this.throwIfDisposed(),kP(this)},pD().prototype.expandDims=function(e){return this.throwIfDisposed(),SP(this,e)},pD().prototype.expm1=function(){return this.throwIfDisposed(),IP(this)},pD().prototype.fft=function(){return this.throwIfDisposed(),Rz(this)},pD().prototype.flatten=function(){return this.throwIfDisposed(),rO(this,[this.size])},pD().prototype.floor=function(){return this.throwIfDisposed(),TP(this)},pD().prototype.floorDiv=function(e){return this.throwIfDisposed(),NF(this,e)},pD().prototype.gather=function(e,t,n){return this.throwIfDisposed(),EP(this,e,t,n)},pD().prototype.greaterEqual=function(e){return this.throwIfDisposed(),_P(this,e)},pD().prototype.greater=function(e){return this.throwIfDisposed(),AP(this,e)},pD().prototype.ifft=function(){return this.throwIfDisposed(),Dz(this)},pD().prototype.irfft=function(){return this.throwIfDisposed(),Mz(this)},pD().prototype.isFinite=function(){return this.throwIfDisposed(),RP(this)},pD().prototype.isInf=function(){return this.throwIfDisposed(),DP(this)},pD().prototype.isNaN=function(){return this.throwIfDisposed(),MP(this)},pD().prototype.leakyRelu=function(e){return this.throwIfDisposed(),FP(this,e)},pD().prototype.lessEqual=function(e){return this.throwIfDisposed(),PP(this,e)},pD().prototype.less=function(e){return this.throwIfDisposed(),OP(this,e)},pD().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),zP(this,e,t,n,r)},pD().prototype.logSigmoid=function(){return this.throwIfDisposed(),QP(this)},pD().prototype.logSoftmax=function(e){return this.throwIfDisposed(),ZP(this,e)},pD().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),eL(this,e,t)},pD().prototype.log=function(){return this.throwIfDisposed(),BP(this)},pD().prototype.log1p=function(){return this.throwIfDisposed(),WP(this)},pD().prototype.logicalAnd=function(e){return this.throwIfDisposed(),tL(this,e)},pD().prototype.logicalNot=function(){return this.throwIfDisposed(),nL(this)},pD().prototype.logicalOr=function(e){return this.throwIfDisposed(),rL(this,e)},pD().prototype.logicalXor=function(e){return this.throwIfDisposed(),aL(this,e)},pD().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),oO(this,e,t,n)},pD().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),lL(this,e,t,n,r)},pD().prototype.max=function(e,t){return this.throwIfDisposed(),hP(this,e,t)},pD().prototype.maximum=function(e){return this.throwIfDisposed(),dL(this,e)},pD().prototype.mean=function(e,t){return this.throwIfDisposed(),hL(this,e,t)},pD().prototype.min=function(e,t){return this.throwIfDisposed(),pP(this,e,t)},pD().prototype.minimum=function(e){return this.throwIfDisposed(),gL(this,e)},pD().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),yL(this,e,t)},pD().prototype.mod=function(e){return this.throwIfDisposed(),bL(this,e)},pD().prototype.mul=function(e){return this.throwIfDisposed(),EF(this,e)},pD().prototype.neg=function(){return this.throwIfDisposed(),XP(this)},pD().prototype.norm=function(e,t,n){return this.throwIfDisposed(),xP(this,e,t,n)},pD().prototype.notEqual=function(e){return this.throwIfDisposed(),kL(this,e)},pD().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),SL(this,e,t,n)},pD().prototype.onesLike=function(){return this.throwIfDisposed(),IL(this)},pD().prototype.pad=function(e,t){return this.throwIfDisposed(),NL(this,e,t)},pD().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),RL(this,e,t,n,r,a,s)},pD().prototype.pow=function(e){return this.throwIfDisposed(),fP(this,e)},pD().prototype.prelu=function(e){return this.throwIfDisposed(),DL(this,e)},pD().prototype.prod=function(e,t){return this.throwIfDisposed(),ML(this,e,t)},pD().prototype.reciprocal=function(){return this.throwIfDisposed(),dz(this)},pD().prototype.relu=function(){return this.throwIfDisposed(),hz(this)},pD().prototype.relu6=function(){return this.throwIfDisposed(),pz(this)},pD().prototype.reshapeAs=function(e){return this.throwIfDisposed(),rO(this,e.shape)},pD().prototype.reshape=function(e){return this.throwIfDisposed(),rO(this,e)},pD().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),tW(this,e,t,n)},pD().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),nW(this,e,t,n)},pD().prototype.reverse=function(e){return this.throwIfDisposed(),fz(this,e)},pD().prototype.rfft=function(){return this.throwIfDisposed(),Oz(this)},pD().prototype.round=function(){return this.throwIfDisposed(),vz(this)},pD().prototype.rsqrt=function(){return this.throwIfDisposed(),xz(this)},pD().prototype.selu=function(){return this.throwIfDisposed(),wz(this)},pD().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),kz(this,e,t,n,r,a,s)},pD().prototype.sigmoid=function(){return this.throwIfDisposed(),lO(this)},pD().prototype.sign=function(){return this.throwIfDisposed(),Iz(this)},pD().prototype.sin=function(){return this.throwIfDisposed(),Cz(this)},pD().prototype.sinh=function(){return this.throwIfDisposed(),Nz(this)},pD().prototype.slice=function(e,t){return this.throwIfDisposed(),uO(this,e,t)},pD().prototype.softmax=function(e){return this.throwIfDisposed(),$z(this,e)},pD().prototype.softplus=function(){return this.throwIfDisposed(),YP(this)},pD().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),$L(this,e,t)},pD().prototype.split=function(e,t){return this.throwIfDisposed(),Fz(this,e,t)},pD().prototype.sqrt=function(){return this.throwIfDisposed(),gP(this)},pD().prototype.square=function(){return this.throwIfDisposed(),yP(this)},pD().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Pz(this,e)},pD().prototype.squeeze=function(e){return this.throwIfDisposed(),Lz(this,e)},pD().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof hD?[this,e]:[this,...e];return zz(n,t)},pD().prototype.step=function(e){return this.throwIfDisposed(),Bz(this,e)},pD().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),Wz(this,e,t,n,r,a,s,i,o)},pD().prototype.sub=function(e){return this.throwIfDisposed(),JP(this,e)},pD().prototype.sum=function(e,t){return this.throwIfDisposed(),bP(this,e,t)},pD().prototype.tan=function(){return this.throwIfDisposed(),Vz(this)},pD().prototype.tanh=function(){return this.throwIfDisposed(),cO(this)},pD().prototype.tile=function(e){return this.throwIfDisposed(),CP(this,e)},pD().prototype.toBool=function(){return this.throwIfDisposed(),kF(this,"bool")},pD().prototype.toFloat=function(){return this.throwIfDisposed(),kF(this,"float32")},pD().prototype.toInt=function(){return this.throwIfDisposed(),kF(this,"int32")},pD().prototype.topk=function(e,t){return this.throwIfDisposed(),eB(this,e,t)},pD().prototype.transpose=function(e){return this.throwIfDisposed(),cB(this,e)},pD().prototype.unique=function(e){return this.throwIfDisposed(),nB(this,e)},pD().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),rB(this,e,t)},pD().prototype.unstack=function(e){return this.throwIfDisposed(),aB(this,e)},pD().prototype.where=function(e,t){return this.throwIfDisposed(),YO(e,this,t)},pD().prototype.zerosLike=function(){return this.throwIfDisposed(),QO(this)};var fH=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},mH=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},gH=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},yH=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},bH=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},vH=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}};function xH(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{let n=new Array(t);return n.fill(e),n}}function wH(e,t){if(!e)throw new bH(t)}function kH(e,t){let n=0;for(let r of e)r===t&&n++;return n}function SH(e){return 1===e.length?e[0]:e}function IH(e){return Array.isArray(e)?e:[e]}function CH(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function NH(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}var TH={};function EH(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function AH(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>AH(e)));else{let t=Object.keys(e);for(let n of t){let t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?AH(t):e[n]=t.value)}}}function _H(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"==typeof e){let a,s=e;if(s in n)a=n[s];else if(s in TH)a=TH[s];else if(a=t[s],null==a)throw new gH(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{let s=e;if(null==s.className||null==s.config)throw new gH(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);let i,o,l=s.className;if(l in n?[i,o]=n[l]:l in TH?[i,o]=TH.className:l in t&&([i,o]=t[l]),null==i)throw new gH(`Unknown ${r}: ${l}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=o){let e={};for(let n of Object.keys(TH))e[n]=TH[n];for(let a of Object.keys(n))e[a]=n[a];s.config.customObjects=e;let t=Object.assign({},TH);for(let a of Object.keys(n))TH[a]=n[a];AH(s.config);let r=o(i,s.config,n,a);return TH=Object.assign({},t),r}{let e=Object.assign({},TH);for(let r of Object.keys(n))TH[r]=n[r];let t=new i(s.config);return TH=Object.assign({},e),t}}}function $H(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function RH(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function DH(e){if(null==e)throw new gH(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function MH(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new gH(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function FH(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return wH(n>=0),wH(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function OH(e,t){Array.isArray(e)?(ER.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>OH(e,`element ${n+1} of ${t}`)))):ER.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${PH(e)}.`))}function PH(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>PH(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function LH(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var zH=0;function BH(){return zH++}var WH={};function VH(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in WH||(WH[e]=0),WH[e]+=1,e+WH[e].toString()}var UH=["channelsFirst","channelsLast"],jH=["nearest","bilinear"],GH=["valid","same","causal"],HH=["max","avg"],qH=["sum","mul","concat","ave"],KH=new Map;function XH(e){MH(UH,"DataFormat",e)}function YH(e){MH(GH,"PaddingMode",e)}function QH(e){MH(HH,"PoolMode",e)}var JH=[],ZH="/";function eq(e,t){JH.push(e);try{let e=t();return JH.pop(),e}catch(Lye){throw JH.pop(),Lye}}function tq(e){if(!sq(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===JH.length?"":JH.join(ZH)+ZH)+e}function nq(e){if(!sq(e))throw new Error("Not a valid tensor name: '"+e+"'");KH.has(e)||KH.set(e,0);let t=KH.get(e);if(KH.set(e,KH.get(e)+1),t>0){let n=`${e}_${t}`;return KH.set(n,1),n}return e}var rq,aq=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function sq(e){return!!e.match(aq)}function iq(e){return e===parseInt(e.toString(),10)}function oq(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function lq(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function uq(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function cq(e,t){if(t<e)throw new gH(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function dq(){return null==rq&&(rq=wM().epsilon()),rq}function hq(e,t){return kF(e,t)}function pq(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),rO(e,n)}function fq(e,t,n){return cM((()=>{switch(e.rank){case 1:return Tz(e,t,n);case 2:return Ez(e,[t,0],[n,e.shape[1]]);case 3:return Az(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return _z(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return uO(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return uO(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new gH(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function mq(e,t,n){return cM((()=>{switch(e.rank){case 1:return Tz(e,t,n);case 2:return Ez(e,[0,t],[e.shape[0],n]);case 3:return Az(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return _z(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new gH(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function gq(e,t,n,r){return cM((()=>{switch(e.rank){case 1:return Tz(e,t,n);case 2:switch(r){case 1:return fq(e,t,n);case 2:return mq(e,t,n);default:throw new gH(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return fq(e,t,n);case 2:return Az(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return mq(e,t,n);default:throw new gH(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return fq(e,t,n);case 2:return _z(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return _z(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return mq(e,t,n);default:throw new gH(`The axis is not within the rank of the tensor ${r}`)}default:throw new gH(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function yq(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),iO(e,n)}function bq(e,t){switch(e.rank){case 1:return CO([e,t]);case 2:return NO([e,t],0);case 3:return TO([e,t],0);case 4:return EO([e,t],0);default:throw new gH(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function vq(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new gH(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return CP(e,t)}function xq(e){return sz(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function wq(e,t,n,r){if(e.rank<2||t.rank<2)throw new yH(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new yH(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank)return vB.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Iq(e.rank,r,"channelsLast"):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=rO(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=rO(cB(t,c),[l,-1]);let d=[...a,...u];return rO(vB.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?Iq(e.rank,r,"channelsLast"):null,activation:n}),d)}}function kq(e,t,n){return cM((()=>(t=Array.isArray(t)?Uz(t,"int32"):kF(t,"int32"),EP(e,t,n))))}function Sq(e){return EF(e,e)}function Iq(e,t,n){let r=t.shape;if(1!==t.rank&&t.rank!==e)throw new gH(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?rO(t,[1,r[0],1,1,1]):rO(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?rO(t,[1,1,1,1,r[0]]):rO(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?rO(t,[1,r[0],1,1]):rO(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?rO(t,[1,1,1,r[0]]):rO(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?rO(t,[1,r[0],1]):rO(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?rO(t,[1,1,r[0]]):rO(t,[1].concat(r))}else if(e<3)return t;throw new gH(`Unsupported input rank by biasAdd: ${t.rank}`)}function Cq(e,t,n){return cM((()=>(null==n&&(n="channelsLast"),XH(n),CF(e,Iq(e.rank,t,n)))))}function Nq(e,t,n,r){return cM((()=>mB(e,t,n,r)))}function Tq(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}var Eq=["fanIn","fanOut","fanAvg"],Aq=["normal","uniform","truncatedNormal"];var _q=class extends MW.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},$q=class extends _q{apply(e,t){return pL(e,t)}};$q.className="Zeros",MW.registerClass($q);var Rq=class extends _q{apply(e,t){return fL(e,t)}};Rq.className="Ones",MW.registerClass(Rq);var Dq=class extends _q{constructor(e){if(super(),"object"!=typeof e)throw new gH(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new gH(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return cM((()=>EF(mP(this.value),fL(e,t))))}getConfig(){return{value:this.value}}};Dq.className="Constant",MW.registerClass(Dq);var Mq=class extends _q{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return oz(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Mq.className="RandomUniform",MW.registerClass(Mq);var Fq=class extends _q{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new yH(`randomNormal does not support dType ${t}.`);return xq(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Fq.className="RandomNormal",MW.registerClass(Fq);var Oq=class extends _q{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new yH(`truncatedNormal does not support dType ${t}.`);return tB(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Oq.className="TruncatedNormal",MW.registerClass(Oq);var Pq=class extends _q{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return cM((()=>{if(2!==e.length||e[0]!==e[1])throw new gH("Identity matrix initializer can only be used for 2D square matrices.");return EF(this.gain,NP(e[0]))}))}getConfig(){return{gain:this.gain}}};Pq.className="Identity",MW.registerClass(Pq);var Lq=class extends _q{constructor(e){if(super(),e.scale<0)throw new gH(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function(e){MH(Eq,"FanMode",e)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function(e){MH(Aq,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){let n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(XH(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){let r=oq(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){let r=oq(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{let r=oq(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],a=n[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){let n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new yH(`${this.getClassName()} does not support dType ${t}.`);return tB(e,0,n,t,this.seed)}{let n=Math.sqrt(3*s);return oz(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Lq.className="VarianceScaling",MW.registerClass(Lq);var zq=class extends Lq{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Lq.className}};zq.className="GlorotUniform",MW.registerClass(zq);var Bq=class extends Lq{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Lq.className}};Bq.className="GlorotNormal",MW.registerClass(Bq);var Wq=class extends Lq{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Lq.className}};Wq.className="HeNormal",MW.registerClass(Wq);var Vq=class extends Lq{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Lq.className}};Vq.className="HeUniform",MW.registerClass(Vq);var Uq=class extends Lq{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Lq.className}};Uq.className="LeCunNormal",MW.registerClass(Uq);var jq=class extends Lq{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Lq.className}};jq.className="LeCunUniform",MW.registerClass(jq);var Gq=class extends _q{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return cM((()=>{if(e.length<2)throw new yH("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);let n=ER.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let s=xq([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=_W.qr(s,!1),o=i[0],l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=EF(o,l.sign()),n<r&&(o=o.transpose()),EF(mP(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}};Gq.className="Orthogonal",MW.registerClass(Gq);var Hq={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function qq(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _H(e,MW.SerializationMap.getMap().classNameMap,t,"initializer")}function Kq(e){return EH(e)}function Xq(e){if("string"==typeof e){let t=e in Hq?Hq[e]:e;if("GlorotNormal"===t)return new Bq;if("GlorotUniform"===t)return new zq;if("HeNormal"===t)return new Wq;if("HeUniform"===t)return new Vq;if("LeCunNormal"===t)return new Uq;if("LeCunUniform"===t)return new jq;{let e={};return e.className=t,e.config={},qq(e)}}return e instanceof _q?e:qq(e)}function Yq(e){return Array.isArray(e)&&Array.isArray(e[0])}function Qq(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Jq(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new gH(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Zq(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new gH(`Expected exactly 1 Shape; got ${e.length}`)}return e}function eK(e){let t=0;for(let n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}var tK="Variable",nK=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:tK,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=BH(),n=null==n?tK:n,this.originalName=tq(n),this.name=nq(this.originalName),this.trainable_=r,this.constraint=a,this.val=iB(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function rK(e){return e.map((e=>e.read()))}function aK(e){e.forEach((e=>{e[0].write(e[1])}))}var sK=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},iK=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=BH(),null!=s&&(this.originalName=tq(s),this.name=nq(this.originalName)),this.rank=t.length}},oK=0,lK=class{constructor(e,t){this.callArgs=t,this.id=oK++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},uK=0,cK=class extends MW.Serializable{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=uK++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let e=this.getClassName();t=CH(e)+"_"+VH(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new mH(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new gH(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return SH(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return SH(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new fH(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new fH(`Layer ${this.name} is not connected, no input to return.`);return SH(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new fH(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new fH(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return SH(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=IH(e);if(null==this.inputSpec||0===this.inputSpec.length)return;let n=IH(this.inputSpec);if(t.length!==n.length)throw new gH(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let e=t[r],a=n[r];if(null==a)continue;let s=e.rank;if(null!=a.ndim&&s!==a.ndim)throw new gH(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new gH(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new gH(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&e.dtype!==a.dtype)throw new gH(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${e.dtype}.`);if(a.axes){let t=e.shape;for(let e in a.axes){let n=Number(e),s=a.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=s&&-1===[s,null].indexOf(i))throw new gH(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){let n=a.shape[t],s=e.shape[t];if(null!=n&&null!=s&&n!==s)throw new gH(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=IH(e),r=function(e){let t=!0;for(let n of IH(e))if(!(n instanceof iK)){t=!1;break}return t}(e),a=function(e){let t=!0;for(let n of IH(e))if(n instanceof iK){t=!1;break}return t}(e);if(r===a)throw new gH("Arguments to apply() must be all SymbolicTensors or all Tensors");return eq(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of IH(e))t.push(n.shape);this.build(SH(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);let a=IH(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=SH(s),null!=this.activityRegularizer)throw new yH("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{let n,r=function(e){e=IH(e);let t=[];for(let n of e)t.push(n.shape);return SH(t)}(e),a=this.computeOutputShape(r),s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?r[0]:r),n=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,r)=>new iK(s,n,this,IH(e),t,this.name,r))):new iK(s,a,this,IH(e),t,this.name),this.addInboundNode(e,n,null,null,r,a,t),this._refCount++,null!=this.activityRegularizer)throw new yH("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new fH(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new fH(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new mH(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return eK(this.weights)}build(e){this.built=!0}getWeights(){return rK(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){cM((()=>{let t=this.weights;if(t.length!==e.length)throw new gH(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let n=[],r=rK(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!ER.arraysEqual(s.shape,o.shape))throw new gH(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}aK(n)}))}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new gH(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():Xq("zeros"));let l=r.apply(t,n),u=new nK(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=IH(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),a=IH(t),s=IH(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=s[i]}addInboundNode(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=IH(e);t=IH(t),n=IH(n),r=IH(r),a=Qq(a),s=Qq(s);let l=[],u=[],c=[];for(let d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new lK({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function dK(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{let e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{let t=[];for(let n=0;n<e.inboundLayers.length;n++){let r=dK(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(let e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}var hK=class extends cK{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:VH("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new gH("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new gH("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new gH("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new iK(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new lK({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new gH(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function pK(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new gH("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new hK({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}hK.className="InputLayer",MW.registerClass(hK);var fK=class e{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof e)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(let e of t)this.add(e.key,e.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new gH(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,n){if(null==e.dtype||e.dtype===n.dtype)return n;try{return kF(n,e.dtype)}catch(t){throw new gH(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof iK){if(null==this.id2Value[e.id])throw new gH(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{let t=this.name2Id[e];if(null==t)throw new gH(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof iK){if(null==this.id2Value[e.id])throw new gH(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{let t=this.name2Id[e];if(null==t)throw new gH(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&dM(this.id2Mask)}},mK=new vH,gK=new vH;function yK(e,t,n,r){let a=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(let f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let c,d=o.join(",")+"|"+t.names().sort().join(","),h=mK.get(d);if(null==h){let e=function(e,t){ER.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){let a=vK(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:e,recipientMap:i}=vK(s,t);for(let t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(let t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:bK(r)}}(i,t);h=e.sorted,c=e.recipientCounts,mK.put(d,h),gK.put(d,c)}c={},a||Object.assign(c,gK.get(d));let p=new fK(t);for(let f=0;f<h.length;++f){if(null!=r){let e=lM().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}let e=h[f],s=e.sourceLayer;if(s instanceof hK)continue;let i=[],u=[],d=[],m=!1;for(let n of e.inputs){let e=p.getValue(n),r=p.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),a||(c[n.name]--,0===c[n.name]&&!t.hasKey(n)&&-1===o.indexOf(n.name)&&!e.isDisposed&&!0!==n.sourceLayer.stateful&&d.push(e))}m&&((n=n||{}).mask=u[0]);let g=IH(s.apply(i,n)),y=null;s.supportsMasking&&(y=s.computeMask(i,u));let b=xK(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);let e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}a||dM(d)}return p.disposeMasks(),s?l:l[0]}function bK(e){let t={};for(let n in e)t[n]=e[n].size;return t}function vK(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let e=s[s.length-1];if(n.has(e.name)){s.pop();continue}let t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(let t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),!n.has(t.name)&&s.push(t)}}return{sorted:r,recipientMap:a}}function xK(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}HE().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=mK&&mK.setMaxEntries(e),null!=gK&&gK.setMaxEntries(e)}));var wK={};function kK(e,t){return cM((()=>gP(bP(EF(e,e),t,!0))))}ST(wK,{maxNorm:()=>RK,minMaxNorm:()=>FK,nonNeg:()=>MK,unitNorm:()=>DK});var SK=class extends MW.Serializable{getConfig(){return{}}},IK=class extends SK{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return cM((()=>{let t=kK(e,this.axis),n=IO(t,0,this.maxValue);return EF(e,TF(n,CF(dq(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};IK.className="MaxNorm",MW.registerClass(IK);var CK=class extends SK{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return cM((()=>TF(e,CF(dq(),kK(e,this.axis)))))}getConfig(){return{axis:this.axis}}};CK.className="UnitNorm",MW.registerClass(CK);var NK=class extends SK{apply(e){return hz(e)}};NK.className="NonNeg",MW.registerClass(NK);var TK=class extends SK{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return cM((()=>{let t=kK(e,this.axis),n=CF(EF(this.rate,IO(t,this.minValue,this.maxValue)),EF(1-this.rate,t));return EF(e,TF(n,CF(dq(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};TK.className="MinMaxNorm",MW.registerClass(TK);var EK={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function AK(e){return EH(e)}function _K(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _H(e,MW.SerializationMap.getMap().classNameMap,t,"constraint")}function $K(e){if(null==e)return null;if("string"==typeof e){return _K({className:e in EK?EK[e]:e,config:{}})}return e instanceof SK?e:_K(e)}function RK(e){return new IK(e)}function DK(e){return new CK(e)}function MK(){return new NK}function FK(e){return new TK(e)}var OK={};function PK(){return new $q}function LK(){return new Rq}function zK(e){return new Dq(e)}function BK(e){return new Mq(e)}function WK(e){return new Fq(e)}function VK(e){return new Oq(e)}function UK(e){return new Pq(e)}function jK(e){return new Lq(e)}function GK(e){return new zq(e)}function HK(e){return new Bq(e)}function qK(e){return new Wq(e)}function KK(e){return new Vq(e)}function XK(e){return new Uq(e)}function YK(e){return new jq(e)}function QK(e){return new Gq(e)}ST(OK,{constant:()=>zK,glorotNormal:()=>HK,glorotUniform:()=>GK,heNormal:()=>qK,heUniform:()=>KK,identity:()=>UK,leCunNormal:()=>XK,leCunUniform:()=>YK,ones:()=>LK,orthogonal:()=>QK,randomNormal:()=>WK,randomUniform:()=>BK,truncatedNormal:()=>VK,varianceScaling:()=>jK,zeros:()=>PK});var JK,ZK={};async function eX(e){if(null==e)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if("number"!=typeof s){let e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){let a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];dM(r)}}function tX(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}ST(ZK,{Layer:()=>cK,RNN:()=>pQ,RNNCell:()=>fQ,activation:()=>HJ,add:()=>tZ,alphaDropout:()=>GZ,average:()=>nZ,averagePooling1d:()=>dZ,averagePooling2d:()=>fZ,averagePooling3d:()=>yZ,avgPool1d:()=>hZ,avgPool2d:()=>mZ,avgPool3d:()=>bZ,avgPooling1d:()=>pZ,avgPooling2d:()=>gZ,avgPooling3d:()=>vZ,batchNormalization:()=>lZ,bidirectional:()=>PZ,categoryEncoding:()=>YZ,centerCrop:()=>KZ,concatenate:()=>rZ,conv1d:()=>PJ,conv2d:()=>LJ,conv2dTranspose:()=>zJ,conv3d:()=>BJ,conv3dTranspose:()=>WJ,convLstm2d:()=>DZ,convLstm2dCell:()=>MZ,cropping2D:()=>UJ,dense:()=>qJ,depthwiseConv2d:()=>GJ,dot:()=>oZ,dropout:()=>KJ,elu:()=>$J,embedding:()=>eZ,flatten:()=>YJ,gaussianDropout:()=>jZ,gaussianNoise:()=>UZ,globalAveragePooling1d:()=>xZ,globalAveragePooling2d:()=>wZ,globalMaxPool1d:()=>zZ,globalMaxPool2d:()=>BZ,globalMaxPooling1d:()=>kZ,globalMaxPooling2d:()=>SZ,gru:()=>TZ,gruCell:()=>EZ,input:()=>fY,inputLayer:()=>_J,layerNormalization:()=>uZ,leakyReLU:()=>DJ,lstm:()=>AZ,lstmCell:()=>_Z,masking:()=>HZ,maxPool1d:()=>WZ,maxPool2d:()=>VZ,maxPooling1d:()=>IZ,maxPooling2d:()=>CZ,maxPooling3d:()=>NZ,maximum:()=>aZ,minimum:()=>sZ,multiply:()=>iZ,permute:()=>ZJ,prelu:()=>MJ,randomWidth:()=>QZ,reLU:()=>RJ,repeatVector:()=>QJ,rescaling:()=>qZ,reshape:()=>JJ,resizing:()=>XZ,rnn:()=>FZ,separableConv2d:()=>VJ,simpleRNN:()=>$Z,simpleRNNCell:()=>RZ,softmax:()=>FJ,spatialDropout1d:()=>XJ,stackedRNNCells:()=>OZ,thresholdedReLU:()=>OJ,timeDistributed:()=>LZ,upSampling2d:()=>jJ,zeroPadding2d:()=>cZ}),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(JK||(JK={}));var nX=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},rX=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},aX=class extends nX{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let n=null==t.size?0:t.size;this.seen+=n;for(let r in t){let e=t[r];if("number"==typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;let a=cM((()=>CF(this.totals[r],EF(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?t[n]=this.totals[n]/this.seen:cM((()=>{let e=EF(TF(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),hM(t[n])})))}},sX=class extends nX{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(let n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let r=this.history[a];for(let s=0;s<r.length;++s)if("number"!=typeof r[s]){let i=r[s];e.push(i.data()),t.push(a),n.push(s)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},iX=class extends nX{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||tU,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");ER.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():ER.now();return function(){let s=null!=n?n():ER.now();return s-a<t||(a=s,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];null!=this.yield&&(await eX(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await eX(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];null!=this.epochEnd&&(await eX(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await eX(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];null!=this.batchEnd&&(await eX(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):ER.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await eX(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await eX(e),await this.trainEnd(e))}};function oX(e,t){return null==e&&(e={}),e instanceof nX?[e]:Array.isArray(e)&&e[0]instanceof nX?e:IH(e).map((e=>new iX(e,t)))}var lX=class e{constructor(){}static registerCallbackConstructor(t,n){ER.assert(t>=0&&Number.isInteger(t),(()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`)),e.checkForDuplicate(n),null==e.constructors[t]&&(e.constructors[t]=[]),e.constructors[t].push(n)}static checkForDuplicate(t){for(let n in e.constructors)e.constructors[+n].forEach((e=>{if(e===t)throw new gH("Duplicate callback constructor.")}))}static clear(){e.constructors={}}static createCallbacks(t){let n=[];for(let r in e.constructors){let a=+r;t>=a&&n.push(...e.constructors[a])}return n.map((e=>new e))}};function uX(e,t,n,r,a,s,i,o,l){let u=new sX,c=[new aX,...lX.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);let d=new rX(c);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function cX(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return _H(e,MW.SerializationMap.getMap().classNameMap,t,"layer",n)}function dX(e,t){return cM((()=>{"float32"!==e.dtype&&(e=kF(e,"float32"));let n=bP(Sq(e),t,!0),r=SO(n.shape,dq()),a=gP(dL(n,r));return TF(e,a)}))}function hX(e,t){return cM((()=>hL(Sq(JP(t,e)),-1)))}function pX(e,t){return cM((()=>hL(AF(JP(t,e)),-1)))}function fX(e,t){return cM((()=>{let n=JP(e,t),r=IO(AF(e),dq(),Number.MAX_VALUE),a=AF(TF(n,r));return EF(100,hL(a,-1))}))}function mX(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return cM((()=>{if(n)t=$z(t);else{let e=bP(t,t.shape.length-1,!0);t=TF(t,e)}return t=IO(t,dq(),1-dq()),XP(bP(EF(kF(e,"float32"),BP(t)),t.shape.length-1))}))}function gX(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return cM((()=>{let r=kF(TP(function(e){let t=[oq(e.shape)];return rO(e,t)}(e)),"int32"),a=(t=IO(t,dq(),1-dq())).shape;return mX(rO(SL(r,a[a.length-1]),a),t,n)}))}function yX(e,t){return cM((()=>{let n;return n=IO(t,dq(),1-dq()),n=BP(TF(n,JP(1,n))),hL(function(e,t){if(!ER.arraysEqual(e.shape,t.shape))throw new gH(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return cM((()=>{let n=hz(t),r=XP(AF(t));return CF(JP(n,EF(t,e)),WP(kP(r)))}))}(e,n),-1)}))}function bX(e,t){return cM((()=>{let n=dX(e,-1),r=dX(t,-1),a=EF(n,r);return XP(bP(a,-1))}))}lX.constructors={};var vX={meanSquaredError:hX,meanAbsoluteError:pX,meanAbsolutePercentageError:fX,meanSquaredLogarithmicError:function(e,t){return cM((()=>{let n=IO(t,dq(),Number.MAX_VALUE),r=BP(CF(1,n)),a=IO(e,dq(),Number.MAX_VALUE),s=BP(CF(1,a));return hL(Sq(JP(r,s)),-1)}))},squaredHinge:function(e,t){return cM((()=>{let n=dL(0,JP(1,EF(e,t)));return hL(Sq(n),-1)}))},hinge:function(e,t){return cM((()=>{let n=dL(0,JP(1,EF(e,t)));return hL(n,-1)}))},categoricalHinge:function(e,t){return cM((()=>{let n=bP(EF(e,t),-1),r=hP(EF(JP(1,e),t),-1);return dL(0,CF(1,JP(r,n)))}))},logcosh:function(e,t){return cM((()=>{let n=Math.log(2),r=JP(t,e),a=JP(CF(r,YP(EF(-2,r))),n);return hL(a,-1)}))},categoricalCrossentropy:mX,sparseCategoricalCrossentropy:gX,binaryCrossentropy:yX,kullbackLeiblerDivergence:function(e,t){return cM((()=>{let n=IO(e,dq(),1),r=IO(t,dq(),1);return bP(EF(e,BP(TF(n,r))),-1)}))},poisson:function(e,t){return cM((()=>{let n=BP(CF(dq(),t));return hL(JP(t,EF(e,n)),-1)}))},cosineProximity:bX};function xX(e){if("string"==typeof e){if(e in vX)return vX[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new gH(t)}return e}function wX(e,t){return cM((()=>{let n=EF(.5,IL(t)),r=hq(AP(t,n),e.dtype);return hL(XO(e,r),-1)}))}function kX(e,t){return cM((()=>hq(XO(FF(e,-1),FF(t,-1)),"float32")))}function SX(e,t){return cM((()=>kF(bP(tL(XO(e,1),XO(t,1))),"float32")))}function IX(e,t){return cM((()=>{let n=SX(e,t),r=function(e,t){return cM((()=>kF(bP(tL(XO(e,0),XO(t,1))),"float32")))}(e,t),a=CF(n,r);return kF(YO(AP(a,0),TF(n,a),0),"float32")}))}function CX(e,t){return cM((()=>{let n=SX(e,t),r=function(e,t){return cM((()=>kF(bP(tL(XO(e,1),XO(t,0))),"float32")))}(e,t),a=CF(n,r);return kF(YO(AP(a,0),TF(n,a),0),"float32")}))}function NX(e,t){return yX(e,t)}function TX(e,t){return e.rank===t.rank&&(e=Lz(e,[e.rank-1])),(t=FF(t,-1)).dtype!==e.dtype&&(t=kF(t,e.dtype)),kF(XO(e,t),"float32")}var EX=mX,AX=gX,_X={binaryAccuracy:wX,categoricalAccuracy:kX,precision:IX,categoricalCrossentropy:EX,sparseCategoricalCrossentropy:AX,mse:hX,MSE:hX,mae:pX,MAE:pX,mape:fX,MAPE:fX,cosine:bX};function $X(e){if("string"==typeof e&&e in _X)return _X[e];if("string"!=typeof e&&null!=e)return e;throw new gH(`Unknown metric ${e}`)}function RX(e){if(wH(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let n of Object.keys(vX))if(vX[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(_X))if(_X[n]===e){t=n;break}return void 0!==t?t:e.name}}function DX(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!MX(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function MX(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if("string"!=typeof n||!MX(e[n]))return!1;return!0}if(Array.isArray(e)){for(let t of e)if(!MX(t))return!1;return!0}return!1}{let t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function FX(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log,s=function(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let e=!1;for(let n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),i=["Layer (type)","Input Shape","Output shape","Param #"];if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){i.push("Receives inputs"),r=[];for(let t in e.nodesByDepth)r.push(...e.nodesByDepth[t])}a("_".repeat(t)),OX(i,n,a),a("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)s?PX(o[c],n,a):LX(o[c],n,r,a),a((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=function(e){let t;return t=null!=e.collectedTrainableWeights?eK(e.collectedTrainableWeights):eK(e.trainableWeights),t}(e),u=eK(e.nonTrainableWeights);a(`Total params: ${l+u}`),a(`Trainable params: ${l}`),a(`Non-trainable params: ${u}`),a("_".repeat(t))}function OX(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function PX(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(s){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(s){r="multiple"}OX([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function LX(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(c){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(c){a="multiple"}let i=[];for(let d of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(d)))for(let e=0;e<d.inboundLayers.length;++e){let t=d.inboundLayers[e].name,n=d.nodeIndices[e],r=d.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}let o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];OX([`${o} (${l})`,s,a,e.countParams().toString(),u],t,r);for(let d=1;d<i.length;++d)OX(["","","","",i[d]],t,r)}function zX(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function BX(e,t){if(null===e)return null;if("string"==typeof e)return NH(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];zX(t,a,r)?n.push(r):n.push(BX(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{let e=NH(n);t[e]=BX(r,e)}}return t}}function WX(e,t){if(null==e)return null;if("string"==typeof e)return CH(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];zX(t,a,r)?n.push(r):n.push(WX(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n],a=CH(n);t[a]="name"!==n&&"className"!==n||"string"!=typeof r?WX(r,n):r}return t}}var VX="4.16.0",UX=class e extends cK{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){let e=this.getClassName().toLowerCase();this.name=VH(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],RH(this.inputs).length!==this.inputs.length)throw new gH(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);RH(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let e of this.outputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(let e of this.inputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;wH(0===n,"input layer has >1 nodes"),wH(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let e=0;e<this.inputLayers.length;e++){let n=this.inputLayers[e];if(!(n instanceof hK))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${e} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(let e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));let n={},r={},a={},s={},i={},o=[],l=(t,n,r,a,s,u)=>{(null==a||null==s||null==u)&&(a=t.sourceLayer,s=t.nodeIndex,u=t.tensorIndex);let c=a.inboundNodes[s];if(-1!==r.indexOf(c))throw new mH(`The tensor ${t.name} at layer "${a.name}" is part of a cycle.`);if(-1!==n.indexOf(c))return;this.containerNodes.add(e.nodeKey(a,s)),a.id in i||(i[a.id]=Object.keys(i).length),-1===r.indexOf(c)&&r.push(c);let d=c.inboundLayers.length;for(let e=0;e<d;e++){let t=c.inputTensors[e],a=c.inboundLayers[e],s=c.nodeIndices[e],i=c.tensorIndices[e];l(t,n,r,a,s,i)}for(n.push(c);r.indexOf(c)>=0;)r.splice(r.indexOf(c),1);o.push(c)},u=[],c=[];for(let e of this.outputs)l(e,u,c);let d=o.slice().reverse();for(let e of d){r[e.id]=e,e.id in n||(n[e.id]=0);let t=n[e.id],i=null==a[e.outboundLayer.id]?0:a[e.outboundLayer.id];t=Math.max(t,i),a[e.outboundLayer.id]=t,s[e.outboundLayer.id]=e.outboundLayer,n[e.id]=t;for(let a=0;a<e.inboundLayers.length;a++){let s=e.inboundLayers[a],i=e.nodeIndices[a],o=s.inboundNodes[i],l=null==n[o.id]?0:n[o.id];n[o.id]=Math.max(t+1,l),r[o.id]=o}}let h={};for(let e in n){let t=n[e];t in h||(h[t]=[]),h[t].push(r[e])}let p={};for(let e in a){let t=a[e];t in p||(p[t]=[]),p[t].push(s[e])}let f=Object.keys(p).map((e=>parseInt(e,10))).sort($H);this.layers=[];for(let b of f){let t=p[b];t.sort(((e,t)=>{let n=i[e.id],r=i[t.id];return n<r?-1:n>r?1:0}));for(let n of t)n instanceof e&&this.internalContainerRefs.push(n),this.layers.push(n)}this.layersByDepth=p,f=Object.keys(h).map((e=>parseInt(e,10))).sort($H);let m=this.inputs.slice(),g=[];for(let e of f)for(let t of h[e]){let e=t.outboundLayer;if(null!=e){for(let n of t.inputTensors)if(-1===m.indexOf(n))throw new mH(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${g}`);for(let e of t.outputTensors)m.push(e);g.push(e.name)}}this.nodesByDepth=h;let y=this.layers.map((e=>e.name));for(let e of y){let t=y.filter((t=>t===e)).length;if(1!==t)throw new mH(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new lK({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new gH("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n={},r=0,a=(e=>{let t=Object.keys(e);if(0===t.length)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);a&&this.parseWeights(e);for(let i of this.layers)for(let[e,t]of i.weights.entries()){let s=a?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[s])throw new gH(`Duplicate weight name: ${s}`);n[s]=t,r++}let s=[];for(let i in e){let r=i;if(null==n[i]){let e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])s.push([n[r],e[i]]);else if(t)throw new gH(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new gH(`${e.length} of ${r} weights are not set: ${e}`)}aK(s)}parseWeights(e){for(let t in Object.keys(e)){let n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${VX}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=WX(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return cM((()=>{e=IH(e);let n=new fK;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return yK(this.outputs,n,t)}))}computeMask(e,t){return cM((()=>{let n;return e=IH(e),n=null==t?xH(null,e.length):IH(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){let t=Qq(e);if(t.length!==this.inputLayers.length)throw new gH(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort($H);if(r.length>1)for(let i of r){let e=this.nodesByDepth[i];for(let t of e){let e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;let r=[];for(let i=0;i<t.inboundLayers.length;i++){let e=t.inboundLayers[i],a=t.nodeIndices[i],s=t.tensorIndices[i],o=n[`${e.name}_${a}_${s}`];r.push(o)}let a=Qq(e.computeOutputShape(SH(r))),s=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++){n[`${e.name}_${s}_${t}`]=a[t]}}}let a=[],s=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;s.push(r)}for(let i=0;i<s.length;i++){let e=s[i];wH(e in n),a.push(n[e])}return SH(a)}runInternalGraph(e,t){null==t&&(t=xH(null,e.length));let n={};for(let o=0;o<this.inputs.length;++o){let r=this.inputs[o],a=e[o],s=t[o];n[r.id]=[a,s]}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort($H);for(let o of r){let e=this.nodesByDepth[o];for(let t of e){let e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,s=new Array;for(let t of r)t.id in n&&s.push(n[t.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){let[t,n]=s[0];null==u.mask&&(u.mask=n),o=IH(e.call(t,u)),l=IH(e.computeMask(t,n)),r=[t],i=[n]}else r=s.map((e=>e[0])),i=s.map((e=>e[1])),null==u.mask&&(u.mask=i),o=IH(e.call(r,u)),l=IH(e.computeMask(r,i));if(e.activityRegularizer)throw new yH("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){let t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}let a=[],s=[],i=[];for(let o of this.outputs){wH(o.id in n,`Could not compute output ${o.name} : ${o.id}`);let[e,t]=n[o.id];i.push(e.shape),a.push(e),s.push(t)}return[a,s,i]}buildNodeConversionMap(t){let n,r={};for(let a of this.layers){n=a instanceof e?1:0;for(let t=0;t<a.inboundNodes.length;t++){let s=e.nodeKey(a,t);this.containerNodes.has(s)&&(r[s]=n,n+=1)}}return r}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new gH("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(let n of this.layers)if(n.name===e)return n;throw new gH(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new gH(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return cM((()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let a=e.nodeKey(n,r);this.containerNodes.has(a)&&t.push(...n.calculateLosses())}return t}))}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let o of this.layers){let t=o.getClassName(),a=o.getConfig(),s=[];for(let r=0;r<o.inboundNodes.length;r++){let t=o.inboundNodes[r],a=e.nodeKey(o,r),l={};if(this.containerNodes.has(a)){if(t.callArgs)try{JSON.stringify(t.callArgs),l=t.callArgs}catch(i){console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${t.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),l={}}if(t.inboundLayers.length>0){let r=[];for(let a=0;a<t.inboundLayers.length;a++){let s=t.inboundLayers[a],i=t.nodeIndices[a],o=t.tensorIndices[a],u=n[e.nodeKey(s,i)];null==u&&(u=0),r.push([s.name,u,o,l])}s.push(r)}}}let l={};l.name=o.name,l.className=t,l.config=a,l.inboundNodes=s,r.push(l)}t.layers=r;let a=[];for(let o=0;o<this.inputLayers.length;o++){let t=this.inputLayers[o],r=this.inputLayersNodeIndices[o],s=e.nodeKey(t,r);if(!this.containerNodes.has(s))continue;let i=n[s];null==i&&(i=0);let l=this.inputLayersTensorIndices[o];a.push([t.name,i,l])}t.inputLayers=a;let s=[];for(let o=0;o<this.outputLayers.length;o++){let t=this.outputLayers[o],r=this.outputLayersNodeIndices[o],a=e.nodeKey(t,r);if(!this.containerNodes.has(a))continue;let i=n[a];null==i&&(i=0);let l=this.outputLayersTensorIndices[o];s.push([t.name,i,l])}return t.outputLayers=s,t}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={},a={};function s(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function i(e,t){let n,a=[];for(let i of t){let o=i[0],l=i[1],u=i[2];if(n=null==i[3]?{}:i[3],!(o in r))return void s(e,t);let c=r[o];if(c.inboundNodes.length<=l)return void s(e,t);let d=c.inboundNodes[l];a.push(d.outputTensors[u])}a.length>0&&e.apply(SH(a),n)}function o(e){let a=e.name,i=cX(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[a]=i,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new gH(`Corrupted configuration, expected array for nodeData: ${e}`);s(i,e)}))}let l=t.name,u=t.layers;for(let f of u)o(f);for(;!DH(a);)for(let e of u){let t=r[e.name];if(t.name in a){let e=a[t.name];delete a[t.name];for(let n of e)i(t,n)}}let c=[],d=[],h=t.inputLayers;for(let f of h){let e=f[0],t=f[1],n=f[2];wH(e in r);let a=r[e].inboundNodes[t].outputTensors;c.push(a[n])}let p=t.outputLayers;for(let f of p){let e=f[0],t=f[1],n=f[2];wH(e in r);let a=r[e].inboundNodes[t].outputTensors;d.push(a[n])}return new e({inputs:c,outputs:d,name:l})}get stateful(){if(this._stateful)throw new gH("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){cM((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}};function jX(e,t){return function(e,t,n){let r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function GX(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){let t=cM((()=>{if(1===e.shape.length)return SF(e);if(2===e.shape.length){if(e.shape[1]>1)return FF(e,1);if(1===e.shape[1])return rO(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());dM(t);let a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),Uz(a,"float32")}return null}function HX(e,t){return EF(e,t)}function qX(e,t){let n,r,a=t;n=a.xs,r=a.ys,ER.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));let s=KX("input",e.inputNames,n),i=KX("output",e.outputNames,r),o=s[0].shape[0];ER.assert(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),ER.assert(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<s.length;l++)ER.assert(s[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)ER.assert(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:i}}function KX(e,t,n){if(n instanceof hD)return[n];if(Array.isArray(n))return ER.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{let r=[];for(let a of t){if(null==n[a])throw new gH(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function XX(e,t,n){let r=null!=n.batchesPerEpoch;if(ER.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),ER.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),ER.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),ER.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),ER.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a,s,i=null!=n.validationData;if(i)if(YX(n.validationData))ER.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{let e=function(e){if(3===e.length)throw new yH("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,s=e.ys}let o,l=e.makeTrainFunction(),u=e.getDedupedMetricsNames();o=i?u.slice().concat(u.map((e=>"val_"+e))):u.slice();let c=oX(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=uX(c,d,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,i,o);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let o={};await h.onEpochBegin(f);let c=0,d=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){let t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){let{xs:r,ys:a}=qX(e,t.value),s={};s.batch=d,s.size=r[0].shape[0],await h.onBatchBegin(d,s);let i=[];if(null!=n.classWeight){let t=jX(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await GX(a[e],null,t[e]))}let o=r.concat(a).concat(i),p=l(o);dM(o);for(let e=0;e<u.length;++e){let t=u[e],n=p[e];s[t]=n,hM(n)}await h.onBatchEnd(d,s),tX(s),d++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(i){let t;t=YX(n.validationData)?IH(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):IH(e.evaluate(a,s,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)o[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,o),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function YX(e){return"function"==typeof e.iterator}function QX(e){ER.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function JX(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>fq(e,t,n-t))):fq(e,t,n-t)}function ZX(e,t){return cM((()=>null==e?null:Array.isArray(e)?e.map((e=>ZX(e,t))):kq(e,"int32"===t.dtype?t:kF(t,"int32"))))}function eY(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function tY(e){let t=[];e instanceof hD&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(1===r.rank)t.push(pq(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function nY(e,t){if(null==e)return;let n=[];if(t instanceof hD)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(let a in t){let e=t[a];n.push(e.id)}let r=[];if(e instanceof hD)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(let a in e){let t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function rY(e){return Array.isArray(e)}function aY(e){return!function(e){return e instanceof hD}(e)&&!rY(e)}function sY(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(rY(e)&&e.length>0)t=!0;else if(aY(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new gH(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(aY(e)){r=[];for(let n of t){if(null==e[n])throw new gH(`No data provided for "${n}". Need data for each key in: ${t}`);r.push(e[n])}}else if(rY(e)){if(e.length!==t.length)throw new gH(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);r=e}else{if(t.length>1)throw new gH(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);r=[e]}if(r=tY(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=r[i];if(e.shape.length!==n[i].length)throw new gH(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!a)continue;let r=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&r!==o)throw new gH(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return r}function iY(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new gH(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);r=e}else{if(t.length>1)throw new gH(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=r[i];if(e.shape.length!==n[i].length)throw new gH(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let r=0;r<n[i].length;++r){if(0===r&&!a)continue;let o=e.shape[r],l=n[i][r];if(null!=l&&l!==o)throw new gH(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}var oY=class extends UX{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new gH("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");FX(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){let t={Adagrad:()=>ZV.adagrad(.01),Adadelta:()=>ZV.adadelta(1,.95,dq()),Adam:()=>ZV.adam(.001,.9,.999,dq()),Adamax:()=>ZV.adamax(.002,.9,.999,dq(),0),RMSProp:()=>ZV.rmsprop(.001,.9,0,dq()),SGD:()=>ZV.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new gH(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof WW))throw new gH("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new gH(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map((e=>xX(e)))}else{let n=xX(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(let t in e.loss)if(-1===this.outputNames.indexOf(t))throw new gH(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(xX(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],eq("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));let r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{let e=[];for(let r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};eq("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,s;for(let i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){let t,a=this.internalOutputShapes[e];1===a[a.length-1]||this.lossFunctions[e]===yX?-1!==["accuracy","acc"].indexOf(i)?r=wX:-1!==["crossentropy","ce"].indexOf(i)&&(r=NX):this.lossFunctions[e]===gX?-1!==["accuracy","acc"].indexOf(i)?r=TX:-1!==["crossentropy","ce"].indexOf(i)&&(r=AX):-1!==["accuracy","acc"].indexOf(i)?r=kX:-1!==["crossentropy","ce"].indexOf(i)&&(r=EX),-1!==["accuracy","acc"].indexOf(i)?t="acc":-1!==["crossentropy","ce"].indexOf(i)&&(t="ce"),s=r,n=""+t}else s=$X(i),n=""+RX(i);let t;eq(n,(()=>{t=s})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=null==n.batchSize?32:n.batchSize;QX(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let e=a[0].concat(a[1]);this.makeTestFunction();let t=this.testFunction;return SH(this.testLoop(t,e,r,n.verbose,n.steps))}finally{nY(a[0],e),nY(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){let r=null!=(n=n||{}).batches,a=e.testFunction,s=[];if(n.verbose>0)throw new yH("Verbose mode is not implemented yet.");ER.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));let i=function(e){return"function"==typeof e.next}(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let t=await i.next();if(s=cM((()=>{if(t.value){let{xs:n,ys:r}=qX(e,t.value),i=n.concat(r),u=cM((()=>a(i)));if(dM(i),0===l)for(let e=0;e<u.length;++e)s.push(mP(0));let c=i[0].shape[0];for(let e=0;e<u.length;++e){let t=u[e],n=s[e];s[e]=cM((()=>CF(s[e],EF(c,t)))),l>0&&dM(n)}dM(u),o+=c,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let e=s[u];s[u]=TF(s[u],o),dM(e)}return SH(s)}(this,e,t)}checkNumSamples(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new gH(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new gH(`Either the input data should have a defined shape, or ${a} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new gH("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new fK;if(e instanceof hD&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new gH(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(let o of this.inputs){let t=e[o.name];if(null==t)throw new gH(`No value is provided for the model's input ${o.name}`);s.add(o,t)}let i=yK(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=xH(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){let i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){let n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new gH(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return cM((()=>{let r=this.checkNumSamples(e);if(n)throw new yH("Verbose predictLoop() is not implemented yet.");let a=eY(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t)cM((()=>{let n=a[t][0],r=a[t][1],s=JX(e,n,r),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});let o=new fK(i);return yK(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)));return SH(s.map((e=>iO(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=tY(e);iY(n,this.inputNames,this.feedInputShapes,!1);try{let e=null==t.batchSize?32:t.batchSize;return QX(e),this.predictLoop(n,e)}finally{nY(n,e)}}predictOnBatch(e){iY(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new mH("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let r=[];for(let a=0;a<this.feedOutputShapes.length;++a){let e=this.feedOutputShapes[a];this.feedLossFns[a]===gX?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){let n=RH(e.map((e=>e.shape[0])));n.sort();let r=RH(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new gH(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new gH(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!ER.arraysEqual(n,r))throw new gH(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=sY(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=sY(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){let r=[hX,yX,mX];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(null!=i){if(i===mX&&1===s.shape[s.shape.length-1])throw new gH(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){let e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){let r=e[n],a=t[n];if(null!=a&&r!==a)throw new gH(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new gH(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0,[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){let e=jX(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await GX(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return cM((()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new yH("Verbose mode is not implemented yet.");if(null!=a)throw new yH("steps mode in testLoop() is not implemented yet");{let r=eY(s,n),a=Uz(cq(0,s));for(let n=0;n<r.length;++n){let s=r[n][0],o=r[n][1],l=fq(a,s,o-s),u=ZX(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(mP(0));for(let e=0;e<c.length;++e){let t=c[e];i[e]=CF(i[e],EF(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=TF(i[e],s)}return i}))}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(kH(e,r)>1){a+=`_${kH(e.slice(0,n),r)}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{let e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});let i,o=new fK(e),l=yK(this.outputs,o,{training:!0});for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],l[n]);null!=a[n]&&(e=HX(e,a[n]));let s=hL(e);t.push(s),i=0===n?e:CF(i,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{let t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=hL(t(r[a],l[a]))}hM(e),s.push(e)}return i=hL(i),this.calculateLosses().forEach((e=>{i=CF(i,e)})),i}),!0,i)].concat(s)}}makeTestFunction(){this.testFunction=e=>cM((()=>{let t,n=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});let i=new fK(s),o=yK(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){let r=this.lossFunctions[e],s=hL(r(a[e],o[e]));t=0===e?s:CF(t,s),n.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=hL(t(a[r],o[r]));n.push(s)}return n}))}async fit(e,t){let n,r,a,s,i,o,l,u,c,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{let h=null==d.batchSize?32:d.batchSize;QX(h);let p=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,!1,h);n=p[0],r=p[1],c=p[2];let f,m=!1;if(null!=d.validationData&&d.validationData.length>0){if(m=!0,2!==d.validationData.length)throw 3===d.validationData.length?new yH("validationData including sample weights is not supported yet."):new gH(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${d.validationData} is invalid.`);i=d.validationData[0],o=d.validationData[1];let e=await this.standardizeUserData(i,o,null,null,!0,h);l=e[0],u=e[1],f=l.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){m=!0;let e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];l=JX(n,e,t),a=n,n=JX(n,0,e),u=JX(r,e,t),s=r,r=JX(r,0,e),f=l.concat(u)}else null!=d.validationSteps&&(m=!0);let g=n.concat(r).concat(c);this.checkTrainableWeightsConsistency();let y,b,v=this.makeTrainFunction(),x=this.getDedupedMetricsNames();m?(this.makeTestFunction(),y=this.testFunction,b=x.slice().concat(x.map((e=>"val_"+e)))):(y=null,f=[],b=x.slice());let w=oX(d.callbacks,d.yieldEvery);return await this.fitLoop(v,g,x,h,d.epochs,d.verbose,w,y,f,d.shuffle,b,d.initialEpoch,null,null)}finally{this.isTraining=!1,nY(n,e),nY(r,t),nY(a,e),nY(s,t),nY(l,i),nY(u,o),null!=c&&dM(c)}}async fitLoop(e,t,n,r,a,s,i,o,l,u,c,d,h,p){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==h))throw new gH("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m,g=this.checkNumSamples(t,r,h,"steps_per_epoch");null!=g&&(m=cq(0,g)),null==s&&(s=1);let{callbackList:y,history:b}=uX(i,s,a,d,g,h,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=d;v<a;++v){await y.onEpochBegin(v);let a={};if(null!=h)throw new yH("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new yH("batch shuffling is not implemneted yet");u&&ER.shuffle(m);let s=Uz(m),i=eY(g,r);for(let u=0;u<i.length;++u){let c={};if(await y.onBatchBegin(u,c),cM((()=>{let d=i[u][0],h=i[u][1],p=fq(s,d,h-d);c.batch=u,c.size=h-d;let m=ZX(t,p),g=e(m);for(let e=0;e<n.length;++e){let t=n[e],r=g[e];c[t]=r,hM(r)}if(u===i.length-1&&f){let e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){let r=n[t],s=e[t];hM(s),a["val_"+r]=s}}})),await y.onBatchEnd(u,c),tX(c),this.stopTraining_)break}s.dispose()}if(await y.onEpochEnd(v,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return XX(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let o of s){let e=await o.data();i.push(e[0])}return dM(s),nY(n[0],e),nY(n[1],t),SH(i)}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=lM().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-lM().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=CH(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>CH(e)))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=CH(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[CH(RX(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>CH(RX(e))));{let e={};for(let t in this.metrics)e[t]=CH(RX(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");let t,n,r=cX(BX(e.optimizer_config));if("string"==typeof e.loss)t=NH(e.loss);else if(Array.isArray(e.loss))t=e.loss.map((e=>NH(e)));else if(null!=e.loss){t={};for(let n in e.loss)t[n]=NH(e.loss[n])}if(Array.isArray(e.metrics))n=e.metrics.map((e=>NH(e)));else if(null!=e.metrics){n={};for(let t in e.metrics)n[t]=NH(e.metrics[t])}this.compile({loss:t,metrics:n,optimizer:r})}async save(e,t){if("string"==typeof e){let t=YW.getSaveHandlers(e);if(0===t.length)throw new gH(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new gH(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new gH("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await YW.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${VX}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();let e="optimizer",{data:t,specs:a}=await YW.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...a),n.data=YW.concatenateArrayBuffers([n.data,t])}return null!=this.userDefinedMetadata&&(DX(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){DX(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};oY.className="Model",MW.registerClass(oY);var lY=class extends oY{};async function uY(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);let r=cX(BX(n),t);if(null!=e.weightsManifest){let t=await YW.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map((e=>e.originalName))),n={};for(let e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),dM(t)}return r}async function cY(e,t){if(null==t&&(t={}),"string"==typeof e){let n=YW.getLoadHandlers(e,t);if(0===n.length)n.push(YW.browserHTTPRequest(e,t));else if(n.length>1)throw new gH(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return async function(e,t,n){if(null==n&&(n={}),null==e.load)throw new gH("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;null!=a.model_config&&(a=a.model_config);let s=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&s,o=cX(BX(a),t,i),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new gH("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:e,optimizerWeights:t}=function(e,t){let n=YW.decodeWeights(e,t),r={},a=[];return t.forEach((e=>{"optimizer"===e.group?a.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);o.loadWeights(e,s),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),dM(e),dM(t.map((e=>e.tensor)))}return o}(e,void 0,t)}lY.className="Functional",MW.registerClass(lY);var dY=class e extends oY{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:VH("sequential_"),null!=e.layers)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new gH(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n,r=t instanceof e||t instanceof oY;if(r){if(n=t,1!==n.outputs.length)throw new gH("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new gH("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new gH("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let e=pK({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(r)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new gH(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new gH("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=dK(this.outputs[0])}this.inboundNodes=[],new lK({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:xH(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{let e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(Zq(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new oY({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new mH("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new mH("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new mH("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new mH("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(t,n){let r,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s={};if(n instanceof Array){if(null==n[0].className||"Merge"===n[0].className)throw new gH("Legacy serialization format not supported yet.");r=n}else ER.assert(null!=n.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),r=n.layers,delete n.layers,s=n;let i=new t(s);if(!(i instanceof e))throw new yH(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let e of r){let t=cX(e,void 0,a);a&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new gH("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new gH("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};function hY(e){return new oY(e)}function pY(e){return new dY(e)}function fY(e){return pK(e)}function mY(e,t){lX.registerCallbackConstructor(e,t)}dY.className="Sequential",MW.registerClass(dY);var gY=class extends MW.Serializable{getConfig(){return{}}},yY=class extends gY{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new yH(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return tP(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}};yY.className="elu",MW.registerClass(yY);var bY=class extends gY{apply(e){return wz(e)}};bY.className="selu",MW.registerClass(bY);var vY=class extends gY{apply(e){return hz(e)}};vY.className="relu",MW.registerClass(vY);var xY=class extends gY{apply(e){return cM((()=>gL(6,hz(e))))}};xY.className="relu6",MW.registerClass(xY);var wY=class extends gY{apply(e){return e}};wY.className="linear",MW.registerClass(wY);var kY=class extends gY{apply(e){return lO(e)}};kY.className="sigmoid",MW.registerClass(kY);var SY=class extends gY{apply(e){return function(e){return cM((()=>{let t=CF(.5,EF(.2,e));return IO(t,0,1)}))}(e)}};SY.className="hardSigmoid",MW.registerClass(SY);var IY=class extends gY{apply(e){return YP(e)}};IY.className="softplus",MW.registerClass(IY);var CY=class extends gY{apply(e){return function(e){return cM((()=>TF(e,CF(AF(e),1))))}(e)}};CY.className="softsign",MW.registerClass(CY);var NY=class extends gY{apply(e){return cO(e)}};NY.className="tanh",MW.registerClass(NY);var TY=class extends gY{apply(e){return $z(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}};TY.className="softmax",MW.registerClass(TY);var EY=class extends gY{apply(e){return ZP(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}};EY.className="logSoftmax",MW.registerClass(EY);var AY=class extends gY{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return cM((()=>EF(lO(EF(e,t)),e)))}};AY.className="swish",MW.registerClass(AY);var _Y=class extends gY{apply(e){return cM((()=>EF(e,cO(YP(e)))))}};function $Y(e){return e.getClassName()}function RY(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _H(e,MW.SerializationMap.getMap().classNameMap,t,"activation")}function DY(e){if(null==e){let e={className:"linear",config:{}};return RY(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},RY(t)}return e instanceof gY?e:RY(e)}function MY(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}_Y.className="mish",MW.registerClass(_Y);var FY=class extends MW.Serializable{},OY=class extends FY{constructor(e){super(),MY(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return cM((()=>{let t=pL([1]);return this.hasL1&&(t=CF(t,bP(EF(this.l1,AF(e))))),this.hasL2&&(t=CF(t,bP(EF(this.l2,Sq(e))))),rO(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};OY.className="L1L2",MW.registerClass(OY);var PY={l1l2:"L1L2"};function LY(e){return EH(e)}function zY(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _H(e,MW.SerializationMap.getMap().classNameMap,t,"regularizer")}function BY(e){if(null==e)return null;if("string"==typeof e){return zY({className:e in PY?PY[e]:e,config:{}})}return e instanceof FY?e:zY(e)}var WY=class extends cK{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Jq(e);let n=hz(e);return null!=this.maxValue&&(n=IO(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};WY.className="ReLU",MW.registerClass(WY);var VY=class extends cK{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Jq(e);return FP(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};VY.className="LeakyReLU",MW.registerClass(VY);var UY=class extends cK{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Xq(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=BY(e.alphaRegularizer),this.alphaConstraint=$K(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new gH(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){let t=(e=Zq(e)).slice(1);if(null!=this.sharedAxes)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new sK({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Jq(e),DL(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Kq(this.alphaInitializer),alphaRegularizer:LY(this.alphaRegularizer),alphaConstraint:AK(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};UY.className="PReLU",MW.registerClass(UY);var jY=class extends cK{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new yH(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Jq(e);return tP(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};jY.className="ELU",MW.registerClass(jY);var GY=class extends cK{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let n=Jq(e);return EF(n,kF(AP(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};GY.className="ThresholdedReLU",MW.registerClass(GY);var HY=class extends cK{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new TY).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return cM((()=>{let n=Jq(e),r=t.mask;if(null!=r){let e=EF(JP(fL(n.shape),kF(r,n.dtype)),mP(-1e9));n=CF(n,e)}return this.axis instanceof Array?this.axis.length>1?kP(JP(n,eL(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function qY(e,t,n){if("number"==typeof e)return xH(e,t);if(e.length!==t)throw new gH(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!iq(a))throw new gH(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function KY(e,t,n,r){let a;return null==e?e:(a="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r))}function XY(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+uq([n-t,0]);else{if("same"!==r)throw new gH(`Unsupport padding mode: ${r}.`);e*=t}return e}function YY(e,t){return cM((()=>(XH(t),"channelsFirst"===t?cB(e,[0,2,3,1]):e)))}function QY(e,t){return cM((()=>(XH(t),"channelsFirst"===t?cB(e,[0,2,3,4,1]):e)))}function JY(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return cM((()=>{if(null==s&&(s="channelsLast"),XH(s),3!==e.rank&&4!==e.rank)throw new gH(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new gH(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=YY(e,s);if("causal"===a)throw new yH("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=vB.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=cB(l,[0,3,1,2])),l}))}HY.className="Softmax",MW.registerClass(HY);var ZY=class e extends cK{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.verifyArgs(n),this.rank=t,OH(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new yH(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=qY(n.kernelSize,t,"kernelSize"),this.strides=qY(null==n.strides?1:n.strides,t,"strides"),this.padding=null==n.padding?"valid":n.padding,YH(this.padding),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,XH(this.dataFormat),this.activation=DY(n.activation),this.useBias=null==n.useBias||n.useBias,this.biasInitializer=Xq(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=$K(n.biasConstraint),this.biasRegularizer=BY(n.biasRegularizer),this.activityRegularizer=BY(n.activityRegularizer),this.dilationRate=qY(null==n.dilationRate?1:n.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new gH(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new gH(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new gH(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(wH("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!FH(e.kernelSize,"number",1,3))throw new gH(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:$Y(this.activation),useBias:this.useBias,biasInitializer:Kq(this.biasInitializer),biasRegularizer:LY(this.biasRegularizer),activityRegularizer:LY(this.activityRegularizer),biasConstraint:AK(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},eQ=class e extends ZY{constructor(t,n){super(t,n),this.kernel=null,e.verifyArgs(n),this.filters=n.filters,OH(this.filters,"filters"),this.kernelInitializer=Xq(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=$K(n.kernelConstraint),this.kernelRegularizer=BY(n.kernelRegularizer)}build(e){e=Zq(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new gH(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return cM((()=>{e=Jq(e);let t,n=null==this.bias?null:this.bias.read(),r=LH(this.activation.getClassName());if(null!=r&&2===this.rank)t=JY(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return cM((()=>{if(null==s&&(s="channelsLast"),XH(s),3!==e.shape.length)throw new gH(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new gH(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new gH(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===s&&(e=cB(e,[0,2,1])),"causal"===a)throw new yH("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=_O(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=Cq(o,n)),o}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=JY(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new yH("convolutions greater than 3D are not implemented yet.");t=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return cM((()=>{if(null==s&&(s="channelsLast"),XH(s),4!==e.rank&&5!==e.rank)throw new gH(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new gH(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=QY(e,s);if("causal"===a)throw new yH("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=DO(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=Cq(o,n)),"channelsFirst"===s&&(o=cB(o,[0,4,1,2,3])),o}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=Zq(e);let t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){let e=KY(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:Kq(this.kernelInitializer),kernelRegularizer:LY(this.kernelRegularizer),kernelConstraint:AK(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new gH(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},tQ=class e extends eQ{constructor(t){super(2,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!FH(e.kernelSize,"number",1,2))throw new gH(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};tQ.className="Conv2D",MW.registerClass(tQ);var nQ=class e extends eQ{constructor(t){super(3,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new gH(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};nQ.className="Conv3D",MW.registerClass(nQ);var rQ=class extends tQ{constructor(e){if(super(e),this.inputSpec=[new sK({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new gH(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Zq(e)).length)throw new gH("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new gH("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new sK({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return cM((()=>{let t=Jq(e);if(4!==t.shape.length)throw new gH(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a=t.shape,s=a[0];"channelsFirst"===this.dataFormat?(n=2,r=3):(n=1,r=2);let i=a[n],o=a[r],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],h=[s,XY(i,c,l,this.padding),XY(o,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=cB(t,[0,2,3,1]));let p=RO(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=cB(p,[0,3,1,2])),null!=this.bias&&(p=Cq(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){let t,n,r,a=(e=Zq(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return a[t]=this.filters,a[n]=XY(a[n],o,s,this.padding),a[r]=XY(a[r],l,i,this.padding),a}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};rQ.className="Conv2DTranspose",MW.registerClass(rQ);var aQ=class extends nQ{constructor(e){if(super(e),this.inputSpec=[new sK({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new gH(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Zq(e)).length)throw new gH("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new gH("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new sK({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return cM((()=>{let t=Jq(e);if(5!==t.shape.length)throw new gH(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a,s=t.shape,i=s[0];"channelsFirst"===this.dataFormat?(a=2,n=3,r=4):(a=1,n=2,r=3);let o=s[a],l=s[n],u=s[r],c=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[i,XY(o,p,c,this.padding),XY(l,f,d,this.padding),XY(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=cB(t,[0,2,3,4,1]));let y=FO(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=cB(y,[0,4,1,2,3])),null!==this.bias&&(y=Cq(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){let t,n,r,a,s=(e=Zq(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3,a=4):(t=4,n=1,r=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return s[t]=this.filters,s[n]=XY(s[n],u,i,this.padding),s[r]=XY(s[r],c,o,this.padding),s[a]=XY(s[a],d,l,this.padding),s}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};aQ.className="Conv3DTranspose",MW.registerClass(aQ);var sQ=class extends eQ{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new gH("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new gH("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new gH(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Xq(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=BY(t.depthwiseRegularizer),this.depthwiseConstraint=$K(t.depthwiseConstraint),this.pointwiseInitializer=Xq(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=BY(t.pointwiseRegularizer),this.pointwiseConstraint=$K(t.pointwiseConstraint)}build(e){if((e=Zq(e)).length<this.rank+2)throw new gH(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new gH(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new sK({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return cM((()=>{let t;if(e=Jq(e),1===this.rank)throw new yH("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=cB(e,[0,2,3,1])),t=kz(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=Cq(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=cB(t,[0,3,1,2])),t}))}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Kq(this.depthwiseInitializer),e.pointwiseInitializer=Kq(this.pointwiseInitializer),e.depthwiseRegularizer=LY(this.depthwiseRegularizer),e.pointwiseRegularizer=LY(this.pointwiseRegularizer),e.depthwiseConstraint=AK(this.depthwiseConstraint),e.pointwiseConstraint=AK(this.pointwiseConstraint),e}};sQ.className="SeparableConv";var iQ=class extends sQ{constructor(e){super(2,e)}};iQ.className="SeparableConv2D",MW.registerClass(iQ);var oQ=class e extends eQ{constructor(t){super(1,t),e.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!FH(e.kernelSize,"number",1,1))throw new gH(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};oQ.className="Conv1D",MW.registerClass(oQ);var lQ=class extends cK{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return cM((()=>{if(e=Jq(e),"channelsLast"===this.dataFormat){let t=gq(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return gq(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=gq(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return gq(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};lQ.className="Cropping2D",MW.registerClass(lQ);var uQ=class extends cK{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,XH(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function(e){MH(jH,"InterpolationFormat",e)}(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{let t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return cM((()=>{let t=Jq(e),n=t.shape;if("channelsFirst"===this.dataFormat){t=cB(t,[0,2,3,1]);let e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?AW.resizeNearestNeighbor(t,[e,r]):AW.resizeBilinear(t,[e,r]);return cB(a,[0,3,1,2])}{let e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?AW.resizeNearestNeighbor(t,[e,r]):AW.resizeBilinear(t,[e,r])}}))}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};uQ.className="UpSampling2D",MW.registerClass(uQ);var cQ=class extends ZY{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Xq(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=$K(e.depthwiseConstraint),this.depthwiseRegularizer=BY(e.depthwiseRegularizer)}build(e){if((e=Zq(e)).length<4)throw new gH(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new gH(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return cM((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return cM((()=>{null==a&&(a="channelsLast"),XH(a);let i=YY(e,a);if(4!==e.rank)throw new gH(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new gH(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=VO(i,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(i=cB(i,[0,3,1,2])),i}))}(e=Jq(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=Cq(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=Zq(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=KY(t,this.kernelSize[0],this.padding,this.strides[0]),s=KY(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Kq(this.depthwiseInitializer),e.depthwiseRegularizer=LY(this.depthwiseRegularizer),e.depthwiseConstraint=AK(this.depthwiseRegularizer),e}};function dQ(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new gH("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function hQ(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return cM((()=>{let l=t.shape.length;if(l<3)throw new gH(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(cq(2,l));if(t=cB(t,u),null!=s)throw new yH("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=kF(kF(a,"bool"),"float32"),a.rank===l-1&&(a=SP(a,-1)),a=cB(a,u)),r&&(t=fz(t,0),null!=a&&(a=fz(a,0)));let c,d,h,p=[],f=n,m=t.shape[0],g=aB(t);null!=a&&(d=aB(a));for(let t=0;t<m;++t){let n=g[t],r=cM((()=>e(n,f)));if(null==a)c=r[0],f=r[1];else{let e=cM((()=>{let e=d[t],n=JP(IL(e),e),a=CF(EF(r[0],e),EF(f[0],n)),s=f.map(((t,a)=>CF(EF(r[1][a],e),EF(t,n))));return{output:a,newStates:s}}));c=e.output,f=e.newStates}o&&p.push(c)}return o&&(h=zz(p,1)),[c,h,f]}))}cQ.className="DepthwiseConv2D",MW.registerClass(cQ);var pQ=class e extends cK{constructor(e){let t;if(super(e),null==e.cell)throw new gH("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new wQ({cells:e.cell}):e.cell,null==t.stateSize)throw new gH("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new sK({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return cq(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Yq(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){let r=[];for(let n of t)r.push([e[0],n]);return[n].concat(r)}return n}computeMask(e,t){return cM((()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;if(this.returnState){let t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new yH("Constants support is not implemented in RNN yet.");Yq(e)&&(e=e[0]);let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new sK({shape:[t,null,...n]});let r,a=[e[0]].concat(e.slice(2));if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!ER.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new gH(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((e=>new sK({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];cM((()=>{if(!this.stateful)throw new fH("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(null==n)throw new gH("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>pL([n,e]))):this.states_=[pL([n,this.cell.stateSize])];else if(null==e)dM(this.states_),null!=this.keptStates&&(dM(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>pL([n,e]))):this.states_[0]=pL([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new gH(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):dM(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!ER.arraysEqual(r.shape,s))throw new gH(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>hM(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=dQ(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(let e of n)this.stateSpec.push(new sK({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof iK){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return cM((()=>{let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;e=Jq(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new gH(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:r},o=hQ(((e,t)=>{let n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);let d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return cM((()=>{let t=pL(e.shape);return t=bP(t,[1,2]),t=pq(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?vq(t,[1,e]):t)):this.cell.stateSize>1?[vq(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===e.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=cX(t.cell,n);return new e(Object.assign(t,{cell:r}))}};pQ.className="RNN",MW.registerClass(pQ);var fQ=class extends cK{},mQ=class extends fQ{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,OH(this.units,"units"),this.activation=DY(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Xq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xq(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=BY(e.kernelRegularizer),this.recurrentRegularizer=BY(e.recurrentRegularizer),this.biasRegularizer=BY(e.biasRegularizer),this.kernelConstraint=$K(e.kernelConstraint),this.recurrentConstraint=$K(e.recurrentConstraint),this.biasConstraint=$K(e.biasConstraint),this.dropout=lq([1,uq([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=lq([1,uq([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Zq(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return cM((()=>{if(2!==e.length)throw new gH(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=kQ({ones:()=>IL(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=kQ({ones:()=>IL(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;a=wq(null!=s?EF(e,s):e,this.kernel.read()),null!=this.bias&&(a=Cq(a,this.bias.read())),null!=i&&(n=EF(n,i));let o=CF(a,wq(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:$Y(this.activation),useBias:this.useBias,kernelInitializer:Kq(this.kernelInitializer),recurrentInitializer:Kq(this.recurrentInitializer),biasInitializer:Kq(this.biasInitializer),kernelRegularizer:LY(this.kernelRegularizer),recurrentRegularizer:LY(this.recurrentRegularizer),biasRegularizer:LY(this.biasRegularizer),activityRegularizer:LY(this.activityRegularizer),kernelConstraint:AK(this.kernelConstraint),recurrentConstraint:AK(this.recurrentConstraint),biasConstraint:AK(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};mQ.className="SimpleRNNCell",MW.registerClass(mQ);var gQ=class extends pQ{constructor(e){e.cell=new mQ(e),super(e)}call(e,t){return cM((()=>{null!=this.cell.dropoutMask&&(dM(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dM(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}};gQ.className="SimpleRNN",MW.registerClass(gQ);var yQ=class extends fQ{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new gH("GRUCell does not support reset_after parameter set to true.");this.units=e.units,OH(this.units,"units"),this.activation=DY(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=DY(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Xq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xq(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=BY(e.kernelRegularizer),this.recurrentRegularizer=BY(e.recurrentRegularizer),this.biasRegularizer=BY(e.biasRegularizer),this.kernelConstraint=$K(e.kernelConstraint),this.recurrentConstraint=$K(e.recurrentConstraint),this.biasConstraint=$K(e.biasConstraint),this.dropout=lq([1,uq([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=lq([1,uq([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){let t=(e=Zq(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return cM((()=>{if(2!==e.length)throw new gH(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=null!=t.training&&t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=kQ({ones:()=>IL(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=kQ({ones:()=>IL(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a,s,i,o=this.dropoutMask,l=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=EF(e,o[0]));let u=wq(e,this.kernel.read());this.useBias&&(u=Cq(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=EF(r,l[0]));let c=this.recurrentKernel.read(),[d,h]=Fz(c,[2*this.units,this.units],c.rank-1),p=wq(r,d),[f,m,g]=Fz(u,3,u.rank-1),[y,b]=Fz(p,2,p.rank-1);a=this.recurrentActivation.apply(CF(f,y)),s=this.recurrentActivation.apply(CF(m,b));let v=wq(EF(s,r),h);i=this.activation.apply(CF(g,v));let x=CF(EF(a,r),EF(CF(1,XP(a)),i));return[x,x]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:$Y(this.activation),recurrentActivation:$Y(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Kq(this.kernelInitializer),recurrentInitializer:Kq(this.recurrentInitializer),biasInitializer:Kq(this.biasInitializer),kernelRegularizer:LY(this.kernelRegularizer),recurrentRegularizer:LY(this.recurrentRegularizer),biasRegularizer:LY(this.biasRegularizer),activityRegularizer:LY(this.activityRegularizer),kernelConstraint:AK(this.kernelConstraint),recurrentConstraint:AK(this.recurrentConstraint),biasConstraint:AK(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};yQ.className="GRUCell",MW.registerClass(yQ);var bQ=class extends pQ{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new yQ(e),super(e)}call(e,t){return cM((()=>{null!=this.cell.dropoutMask&&(dM(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dM(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};bQ.className="GRU",MW.registerClass(bQ);var vQ=class extends fQ{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,OH(this.units,"units"),this.activation=DY(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=DY(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Xq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xq(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=BY(e.kernelRegularizer),this.recurrentRegularizer=BY(e.recurrentRegularizer),this.biasRegularizer=BY(e.biasRegularizer),this.kernelConstraint=$K(e.kernelConstraint),this.recurrentConstraint=$K(e.recurrentConstraint),this.biasConstraint=$K(e.biasConstraint),this.dropout=lq([1,uq([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=lq([1,uq([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n,r=(e=Zq(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,r=this.units;n=new(t=class extends _q{apply(t,n){let a=e.apply([r]),s=(new Rq).apply([r]),i=e.apply([2*r]);return bq(bq(a,s),i)}},t.className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return cM((()=>{let n=null!=t.training&&t.training;if(3!==e.length)throw new gH(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=kQ({ones:()=>IL(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=kQ({ones:()=>IL(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s,i,o,l,u=this.dropoutMask,c=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=EF(e,u[0]));let d=wq(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=EF(r,c[0])),d=CF(d,wq(r,this.recurrentKernel.read())),this.useBias&&(d=Cq(d,this.bias.read()));let[h,p,f,m]=Fz(d,4,d.rank-1);s=this.recurrentActivation.apply(h),i=this.recurrentActivation.apply(p),o=CF(EF(i,a),EF(s,this.activation.apply(f))),l=this.recurrentActivation.apply(m);let g=EF(l,this.activation.apply(o));return[g,g,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:$Y(this.activation),recurrentActivation:$Y(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Kq(this.kernelInitializer),recurrentInitializer:Kq(this.recurrentInitializer),biasInitializer:Kq(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:LY(this.kernelRegularizer),recurrentRegularizer:LY(this.recurrentRegularizer),biasRegularizer:LY(this.biasRegularizer),activityRegularizer:LY(this.activityRegularizer),kernelConstraint:AK(this.kernelConstraint),recurrentConstraint:AK(this.recurrentConstraint),biasConstraint:AK(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};vQ.className="LSTMCell",MW.registerClass(vQ);var xQ=class extends pQ{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new vQ(e),super(e)}call(e,t){return cM((()=>{null!=this.cell.dropoutMask&&(dM(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dM(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};xQ.className="LSTM",MW.registerClass(xQ);var wQ=class extends fQ{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return cM((()=>{let n=e.slice(1),r=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a,s=[];for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(let e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;Yq(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{eq(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){let e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=[];for(let a of t.cells)r.push(cX(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return rK(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}aK(t)}};function kQ(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):Nq(t(),n),o=()=>Tq(i,t,r);return!a||a<=1?hM(o().clone()):Array(a).fill(void 0).map(o).map((e=>hM(e.clone())))}wQ.className="StackedRNNCells",MW.registerClass(wQ);var SQ=class extends pQ{constructor(e){if(e.unroll)throw new yH("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new yH("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new sK({ndim:5})]}call(e,t){return cM((()=>{if(null!=this.cell.dropoutMask&&(dM(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(dM(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new gH("ConvRNN2D cell does not support constants");let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return cM((()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=pL([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];cM((()=>{if(!this.stateful)throw new fH("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new gH("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>pL(a))):this.states_=[pL(a)];else if(null==e)dM(this.states_),null!=this.keptStates&&(dM(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>pL(a))):this.states_[0]=pL(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new gH(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):dM(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],r=a;if(!ER.arraysEqual(n.shape,r))throw new gH(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>hM(e.clone())))}))}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=KY(l,r[0],a,s[0],i[0]),d=KY(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}};SQ.className="ConvRNN2D";var IQ=class extends vQ{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,OH(this.filters,"filters"),this.kernelSize=qY(n,2,"kernelSize"),this.kernelSize.forEach((e=>OH(e,"kernelSize"))),this.strides=qY(r||1,2,"strides"),this.strides.forEach((e=>OH(e,"strides"))),this.padding=a||"valid",YH(this.padding),this.dataFormat=s||"channelsLast",XH(this.dataFormat),this.dilationRate=qY(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>OH(e,"dilationRate")))}build(e){var t;e=Zq(e);let n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new gH(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,r=this.filters;e=new((t=class extends _q{apply(e,t){return yq([n.apply([r]),fL([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return cM((()=>{if(3!==e.length)throw new gH(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=kQ({ones:()=>IL(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?EF(t[n],e):e,l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),d=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=kQ({ones:()=>IL(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,p=o(a,h,0),f=o(a,h,1),m=o(a,h,2),g=o(a,h,3),[y,b,v,x]=Fz(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?Fz(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,v,S,this.padding),d=this.inputConv(d,x,I,this.padding);let[C,N,T,E]=Fz(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,C),f=this.recurrentConv(f,N),m=this.recurrentConv(m,T),g=this.recurrentConv(g,E);let A=this.recurrentActivation.apply(CF(l,p)),_=this.recurrentActivation.apply(CF(u,f)),$=CF(EF(_,s),EF(A,this.activation.apply(CF(c,m)))),R=EF(this.recurrentActivation.apply(CF(d,g)),this.activation.apply($));return[R,R,$]}))}getConfig(){let e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let a=AO(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Cq(a,n,this.dataFormat):a}recurrentConv(e,t){return AO(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};IQ.className="ConvLSTM2DCell",MW.registerClass(IQ);var CQ=class extends SQ{constructor(e){let t=new IQ(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};CQ.className="ConvLSTM2D",MW.registerClass(CQ);var NQ=class extends cK{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return cM((()=>{this.invokeCallHook(e,t);let n=Jq(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,r=this.getNoiseShape(n);return Tq((()=>Nq(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};NQ.className="Dropout",MW.registerClass(NQ);var TQ=class extends NQ{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};TQ.className="SpatialDropout1D",MW.registerClass(TQ);var EQ=class extends cK{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,OH(this.units,"units"),this.activation=DY(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Xq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Xq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=$K(e.kernelConstraint),this.biasConstraint=$K(e.biasConstraint),this.kernelRegularizer=BY(e.kernelRegularizer),this.biasRegularizer=BY(e.biasRegularizer),this.activityRegularizer=BY(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){let t=(e=Zq(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){let t=(e=Zq(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return cM((()=>{this.invokeCallHook(e,t);let n,r=Jq(e),a=LH(this.activation.getClassName());return null!=a?n=wq(r,this.kernel.read(),a,this.bias?this.bias.read():null):(n=wq(r,this.kernel.read()),null!=this.bias&&(n=Cq(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n}))}getConfig(){let e={units:this.units,activation:$Y(this.activation),useBias:this.useBias,kernelInitializer:Kq(this.kernelInitializer),biasInitializer:Kq(this.biasInitializer),kernelRegularizer:LY(this.kernelRegularizer),biasRegularizer:LY(this.biasRegularizer),activityRegularizer:LY(this.activityRegularizer),kernelConstraint:AK(this.kernelConstraint),biasConstraint:AK(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};EQ.className="Dense",MW.registerClass(EQ);var AQ=class extends cK{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Zq(e);for(let t of e.slice(1))if(null==t)throw new gH(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],oq(e,1)]}call(e,t){return cM((()=>{this.invokeCallHook(e,t);let n=Jq(e);if("channelsFirst"===this.dataFormat&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=cB(n,e)}return function(e){if(e.rank<=1)throw new gH(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],oq(e.shape,1)];return rO(e,t)}(n)}))}getConfig(){let e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};AQ.className="Flatten",MW.registerClass(AQ);var _Q=class extends cK{constructor(e){super(e),this.supportsMasking=!0,this.activation=DY(e.activation)}call(e,t){return cM((()=>{this.invokeCallHook(e,t);let n=Jq(e);return this.activation.apply(n)}))}getConfig(){let e={activation:$Y(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};_Q.className="Activation",MW.registerClass(_Q);var $Q=class extends cK{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return cM((()=>function(e,t){return cM((()=>{if(2!==e.shape.length)throw new gH(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return vq(pq(e,1),[1,t,1])}))}(e=Jq(e),this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};$Q.className="RepeatVector",MW.registerClass($Q);var RQ=class extends cK{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let o=0;o<r.length;++o){let e=r[o];if(this.isUnknown(e)){if(null!==s)throw new gH("Can only specifiy one unknown dimension.");s=o}else a*=e}let i=oq(e);if(null!==s){if(0===a||i%a!==0)throw new gH(n);r[s]=i/a}else if(i!==a)throw new gH(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return cM((()=>{this.invokeCallHook(e,t);let n=Jq(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return rO(n,a)}))}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};RQ.className="Reshape",MW.registerClass(RQ);var DQ=class extends cK{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=cq(1,e.dims.length+1);if(!ER.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new sK({ndim:this.dims.length+1})]}computeOutputShape(e){let t=(e=Zq(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return cB(Jq(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};DQ.className="Permute",MW.registerClass(DQ);var MQ=class extends cK{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Jq(e);return MF(kL(n,this.maskValue),-1)}call(e,t){return cM((()=>{this.invokeCallHook(e,t);let n=Jq(e),r=MF(kL(n,this.maskValue),-1,!0);return EF(n,kF(r,n.dtype))}))}};MQ.className="Masking",MW.registerClass(MQ);var FQ=class extends cK{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(IH(e.inputLength))}this.inputDim=e.inputDim,OH(this.inputDim,"inputDim"),this.outputDim=e.outputDim,OH(this.outputDim,"outputDim"),this.embeddingsInitializer=Xq(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=BY(e.embeddingsRegularizer),this.activityRegularizer=BY(e.activityRegularizer),this.embeddingsConstraint=$K(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return cM((()=>this.maskZero?(e=Jq(e),kL(e,QO(e))):null))}computeOutputShape(e){if(e=Zq(e),null==this.inputLength)return[...e,this.outputDim];let t=IH(this.inputLength);if(t.length!==e.length-1)throw new gH(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new gH(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return cM((()=>{this.invokeCallHook(e,t);let n=Jq(e);"int32"!==n.dtype&&(n=hq(n,"int32"));let r=kq(this.embeddings.read(),rO(n,[n.size]));return rO(r,Zq(this.computeOutputShape(n.shape)))}))}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Kq(this.embeddingsInitializer),embeddingsRegularizer:LY(this.embeddingsRegularizer),activityRegularizer:LY(this.activityRegularizer),embeddingsConstraint:AK(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};FQ.className="Embedding",MW.registerClass(FQ);var OQ=class extends cK{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new yH}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new gH("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Zq(e)]),e.length<2)throw new gH(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=RH(t),t.length>1)throw new gH(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){let t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}let r=e.map((e=>e.length));-1===e.indexOf(null)&&1===RH(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return cM((()=>{if(this.reshapeRequired){let t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){let r=uq(n);for(let n of e){let e=n.rank;for(let t=0;t<r-e;++t)n=pq(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(let s of e){let e=s.rank;if(null==e){let e=s.shape,r=e[0],a=e.slice(1).concat([r]),i=rO(s,[r].concat(oq(e.slice(1))));i=cB(i,[1,0]),i=rO(i,a),t.push(i),n=!0}else if(e>1){let r=cq(1,e).concat([0]);t.push(cB(s,r)),n=!0}else t.push(s)}let r=this.mergeFunction(t),a=r.rank;if(n)if(null==a){let e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=rO(cB(rO(r,[-1,t]),[1,0]),n)}else if(a>1){let e=[a-1].concat(cq(0,a-1));r=cB(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){let n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(let r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=RH(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return cM((()=>{if(null==t)return null;if(!Array.isArray(t))throw new gH("`mask` should be an Array");if(!Array.isArray(e))throw new gH("`inputs` should be an Array");if(t.length!==e.length)throw new gH(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:SP(e,0))))[0];for(let e=1;e<t.length-1;++e)n=tL(n,t[e]);return n}))}},PQ=class extends OQ{constructor(e){super(e)}mergeFunction(e){return cM((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=CF(t,e[n]);return t}))}};PQ.className="Add",MW.registerClass(PQ);var LQ=class extends OQ{constructor(e){super(e)}mergeFunction(e){return cM((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=EF(t,e[n]);return t}))}};LQ.className="Multiply",MW.registerClass(LQ);var zQ=class extends OQ{constructor(e){super(e)}mergeFunction(e){return cM((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=CF(t,e[n]);return EF(1/e.length,t)}))}};zQ.className="Average",MW.registerClass(zQ);var BQ=class extends OQ{constructor(e){super(e)}mergeFunction(e){return cM((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=dL(t,e[n]);return t}))}};BQ.className="Maximum",MW.registerClass(BQ);var WQ=class extends OQ{constructor(e){super(e)}mergeFunction(e){return cM((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=gL(t,e[n]);return t}))}};WQ.className="Minimum",MW.registerClass(WQ);var VQ=class extends OQ{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new gH("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(let r of e)if(null!=r){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let t=e[r].slice();t.splice(this.axis,1);let a=!1;for(let e of n)if(ER.arraysEqual(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new gH("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return cM((()=>yq(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new gH("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new gH("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new gH("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new gH(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return cM((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;let r=[];for(let s=0;s<e.length;++s)null==t[s]?r.push(kF(IL(e[s]),"bool")):t[s].rank<e[s].rank?r.push(SP(t[s],-1)):r.push(t[s]);let a=iO(r,this.axis);return DF(a,-1,!1)}))}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function UQ(e,t){for(;e<0;)e+=t;return e}VQ.className="Concatenate",MW.registerClass(VQ);var jQ=class extends OQ{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){ER.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new yH("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new gH(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new gH(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>UQ(t,e[n].shape.length))):[UQ(this.axes,n.shape.length),UQ(this.axes,r.shape.length)],this.normalize&&(n=dX(n,t[0]),r=dX(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new yH("batchDot is not implemented for tensors of 4D or higher rank yet");if(ER.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),ER.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new yH("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);let s=n;return cM((()=>{let n,i;if(r>a){n=r-a;let e=[];for(let t=0;t<n;++t)e.push(1);t=rO(t,t.shape.concat(e))}else if(a>r){n=a-r;let t=[];for(let e=0;e<n;++e)t.push(1);e=rO(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?bP(EF(e,t),s[0]):bP(EF(cB(e,[1,0]),t),s[1]);else{let n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;i=oO(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;let t=[];for(let r=e;r<e+n;++r)t.push(r);i=Lz(i,t)}return 1===i.shape.length&&(i=SP(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[UQ(this.axes,e.length),UQ(this.axes,t.length)],n}computeOutputShape(e){ER.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new yH("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};jQ.className="Dot",MW.registerClass(jQ);var GQ=class extends cK{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return cM((()=>{this.invokeCallHook(e,t);let n=Jq(e);return Tq((()=>CF(xq(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}};GQ.className="GaussianNoise",MW.registerClass(GQ);var HQ=class extends cK{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return cM((()=>{this.invokeCallHook(e,t);let n=Jq(e);return this.rate>0&&this.rate<1?Tq((()=>{let e=Math.sqrt(this.rate/(1-this.rate));return EF(n,xq(n.shape,1,e))}),(()=>n),t.training||!1):n}))}};HQ.className="GaussianDropout",MW.registerClass(HQ);var qQ=class extends cK{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Jq(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return cM((()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Tq((()=>{let t=Jq(e),r=-1.7580993408473766,a=_P(oz(n),this.rate);a=hq(a,"float32");let s=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-s*r*this.rate,o=CF(EF(t,a),EF(CF(a,-1),r));return CF(EF(o,s),i)}),(()=>Jq(e)),t.training||!1)}return e}))}};function KQ(e,t,n,r,a){let s,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)s=mO(e,t,n,r,a,i);else if(3===e.rank)s=gO(e,t,n,r,a,i);else{if(4!==e.rank)throw new yH(`batchNormalization is not implemented for array of rank ${e.rank} yet`);s=yO(e,t,n,r,a,i)}return s}function XQ(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return ER.arraysEqual(r.slice().sort(),cq(0,e.rank-1))?function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return cM((()=>{let s=vL(e,r),i=s.mean,o=s.variance;return[KQ(e,i,o,n,t,a),i,o]}))}(e,t,n,r,a):function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return cM((()=>{let s=vL(e,r),i=s.mean,o=s.variance,l=[];for(let t of cq(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);let u=rO(i,l),c=rO(o,l),d=null==t?null:rO(t,l),h=null==n?null:rO(n,l);return[KQ(e,u,c,h,d,a),i,o]}))}(e,t,n,r,a)}qQ.className="AlphaDropout",MW.registerClass(qQ);var YQ=class extends cK{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Xq(e.betaInitializer||"zeros"),this.gammaInitializer=Xq(e.gammaInitializer||"ones"),this.movingMeanInitializer=Xq(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Xq(e.movingVarianceInitializer||"ones"),this.betaConstraint=$K(e.betaConstraint),this.gammaConstraint=$K(e.gammaConstraint),this.betaRegularizer=BY(e.betaRegularizer),this.gammaRegularizer=BY(e.gammaRegularizer)}build(e){e=Zq(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new gH(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new sK({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return cM((()=>{let n=null!=t.training&&t.training,r=Jq(e),a=r.shape,s=a.length,i=cq(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=xH(1,s);l[o]=a[o];let u=i.slice();u.sort();let c=!ER.arraysEqual(u,cq(0,s).slice(0,s-1));if(!n)return(()=>{if(c){let e=rO(this.movingMean.read(),l),t=rO(this.movingVariance.read(),l),n=this.center?rO(this.beta.read(),l):null,a=this.scale?rO(this.gamma.read(),l):null;return KQ(r,e,t,n,a,this.epsilon)}return KQ(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();let[d,h,p]=XQ(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{cM((()=>{let r=1-n,a=e.read(),s=EF(JP(a,t),r);e.write(JP(a,s))}))};return f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum),d}))}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Kq(this.betaInitializer),gammaInitializer:Kq(this.gammaInitializer),movingMeanInitializer:Kq(this.movingMeanInitializer),movingVarianceInitializer:Kq(this.movingVarianceInitializer),betaRegularizer:LY(this.betaRegularizer),gammaRegularizer:LY(this.gammaRegularizer),betaConstraint:AK(this.betaConstraint),gammaConstraint:AK(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};YQ.className="BatchNormalization",MW.registerClass(YQ);var QQ=class extends cK{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Xq(e.betaInitializer||"zeros"),this.gammaInitializer=Xq(e.gammaInitializer||"ones"),this.betaRegularizer=BY(e.betaRegularizer),this.gammaRegularizer=BY(e.gammaRegularizer),this.supportsMasking=!0}build(e){let t=(e=Zq(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==RH(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Jq(e),r=n.shape,a=r.length;return cM((()=>{let{mean:e,variance:t}=vL(n,this.axis,!0),s=xH(1,a);for(let n of this.axis)s[n]=r[n];let i=e=>null!=e&&e.shape.length!==a?rO(e,s):e,o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null,u=[],c=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=CP(e,u),t=CP(t,u),null!=o&&(o=CP(o,c)),null!=l&&(l=CP(l,c)),KQ(n,e,t,l,o,this.epsilon)}))}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Kq(this.betaInitializer),gammaInitializer:Kq(this.gammaInitializer),betaRegularizer:LY(this.betaRegularizer),gammaRegularizer:LY(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};QQ.className="LayerNormalization",MW.registerClass(QQ);var JQ=class extends cK{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new gH(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new gH(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new gH(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new sK({ndim:4})]}computeOutputShape(e){let t,n;return e=Zq(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return cM((()=>function(e,t,n){return cM((()=>{if(4!==e.rank)throw new gH(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new gH("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new gH(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],NL(e,r)}))}(Jq(e),this.padding,this.dataFormat)))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function ZQ(e,t,n,r,a,s){return cM((()=>{XH(a),QH(s),YH(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=YY(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?lL(e,t,n,o):aO(e,t,n,o),"channelsFirst"===a&&(i=cB(i,[0,3,1,2])),i}))}function eJ(e,t,n,r,a,s){return cM((()=>{XH(a),QH(s),YH(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=QY(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?uL(e,t,n,o):sO(e,t,n,o),"channelsFirst"===a&&(i=cB(i,[0,4,1,2,3])),i}))}JQ.className="ZeroPadding2D",MW.registerClass(JQ);var tJ=class extends cK{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new gH(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(OH(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new gH(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}OH(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,YH(this.padding),this.inputSpec=[new sK({ndim:3})]}computeOutputShape(e){let t=KY((e=Zq(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return cM((()=>{this.invokeCallHook(e,t),e=pq(Jq(e),2);let n=this.poolingFunction(Jq(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Lz(n,[2])}))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},nJ=class extends tJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return XH(a),YH(r),ZQ(e,t,n,r,a,"max")}};nJ.className="MaxPooling1D",MW.registerClass(nJ);var rJ=class extends tJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return XH(a),YH(r),ZQ(e,t,n,r,a,"avg")}};rJ.className="AveragePooling1D",MW.registerClass(rJ);var aJ=class extends cK{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new gH(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];OH(this.poolSize,"poolSize"),OH(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,XH(this.dataFormat),YH(this.padding),this.inputSpec=[new sK({ndim:4})]}computeOutputShape(e){e=Zq(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=KY(t,this.poolSize[0],this.padding,this.strides[0]),n=KY(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return cM((()=>(this.invokeCallHook(e,t),this.poolingFunction(Jq(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},sJ=class extends aJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return XH(a),YH(r),ZQ(e,t,n,r,a,"max")}};sJ.className="MaxPooling2D",MW.registerClass(sJ);var iJ=class extends aJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return XH(a),YH(r),ZQ(e,t,n,r,a,"avg")}};iJ.className="AveragePooling2D",MW.registerClass(iJ);var oJ=class extends cK{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new gH(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];OH(this.poolSize,"poolSize"),OH(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,XH(this.dataFormat),YH(this.padding),this.inputSpec=[new sK({ndim:5})]}computeOutputShape(e){e=Zq(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=KY(t,this.poolSize[0],this.padding,this.strides[0]),n=KY(n,this.poolSize[1],this.padding,this.strides[1]),r=KY(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return cM((()=>(this.invokeCallHook(e,t),this.poolingFunction(Jq(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},lJ=class extends oJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return XH(a),YH(r),eJ(e,t,n,r,a,"max")}};lJ.className="MaxPooling3D",MW.registerClass(lJ);var uJ=class extends oJ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return XH(a),YH(r),eJ(e,t,n,r,a,"avg")}};uJ.className="AveragePooling3D",MW.registerClass(uJ);var cJ=class extends cK{constructor(e){super(e),this.inputSpec=[new sK({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new yH}},dJ=class extends cJ{constructor(e){super(e||{})}call(e,t){return cM((()=>{let t=Jq(e);return hL(t,1)}))}};dJ.className="GlobalAveragePooling1D",MW.registerClass(dJ);var hJ=class extends cJ{constructor(e){super(e||{})}call(e,t){return cM((()=>{let t=Jq(e);return hP(t,1)}))}};hJ.className="GlobalMaxPooling1D",MW.registerClass(hJ);var pJ=class extends cK{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,XH(this.dataFormat),this.inputSpec=[new sK({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new yH}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},fJ=class extends pJ{call(e,t){return cM((()=>{let t=Jq(e);return"channelsLast"===this.dataFormat?hL(t,[1,2]):hL(t,[2,3])}))}};fJ.className="GlobalAveragePooling2D",MW.registerClass(fJ);var mJ=class extends pJ{call(e,t){return cM((()=>{let t=Jq(e);return"channelsLast"===this.dataFormat?hP(t,[1,2]):hP(t,[2,3])}))}};mJ.className="GlobalMaxPooling2D",MW.registerClass(mJ);var gJ=class extends cK{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=cX(t.layer,n);delete t.layer;let a={layer:r};return Object.assign(a,t),new e(a)}},yJ=class extends gJ{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Zq(e)).length<3)throw new gH(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){let t=[(e=Zq(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return cM((()=>hQ(((e,n)=>[Jq(this.layer.call(e,t)),[]]),e=Jq(e),[],!1,null,null,!1,!0)[1]))}};yJ.className="TimeDistributed",MW.registerClass(yJ);var bJ=class extends gJ{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=cX(n),t.goBackwards=!0!==t.goBackwards;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=cX(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function(e){MH(qH,"BidirectionalMergeMode",e)}(this.mergeMode),e.weights)throw new yH("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState&&(r=a.slice(1)),t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):SH(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=dQ(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);let s=[],i=[];if(null!=n){let e=n.length;if(e%2>0)throw new gH("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let r=n.map((e=>new sK({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new yH("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof iK;for(let l of s)if(l instanceof iK!==o)throw new gH("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return cM((()=>{let n,r,a,s,i=t.initialState;if(null==i)n=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let a=i.slice(0,i.length/2),s=i.slice(i.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return this.returnState&&(Array.isArray(n)&&(a=n.slice(1).concat(r.slice(1))),n=n[0],r=r[0]),this.returnSequences&&(r=fz(r,1)),"concat"===this.mergeMode?s=yq([n,r]):"sum"===this.mergeMode?s=CF(n,r):"ave"===this.mergeMode?s=EF(.5,CF(n,r)):"mul"===this.mergeMode?s=EF(n,r):null==this.mergeMode&&(s=[n,r]),this.returnState?null==this.mergeMode?s.concat(a):[s].concat(a):s}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){eq(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),eq(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){let e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=cX(t.layer);if(delete t.layer,null!=t.numConstants)throw new yH("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};bJ.className="Bidirectional",MW.registerClass(bJ);var vJ=class extends cK{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return cM((()=>("float32"!==(e=Jq(e)).dtype&&(e=hq(e,"float32")),CF(EF(e,this.scale),this.offset))))}};vJ.className="Rescaling",MW.registerClass(vJ);var{resizeBilinear:xJ,cropAndResize:wJ}=AW,kJ=class extends cK{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return cM((()=>{let l,u=!1,c=[t/s,n/i,(r+t)/s,(a+n)/i],d=[];3===e.rank?(u=!0,l=zz([e])):l=e;for(let e=0;e<l.shape[0];e++)d.push(c);let h=ZD(d,[d.length,4]),p=uz(0,d.length,1,"int32"),f=wJ(l,h,p,[r,a],"nearest");return hq(u?Jq(aB(f)):f,o)}))}upsize(e,t,n,r){return cM((()=>hq(xJ(e,[t,n]),r)))}call(e,t){return cM((()=>{let t=Jq(e),n=t.dtype,r=t.shape,a=r[r.length-3],s=r[r.length-2],i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let o=0;return s!==this.width&&(o=Math.floor((s-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,a,s,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=Zq(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};kJ.className="CenterCrop",MW.registerClass(kJ);var SJ=class extends cK{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=Zq(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return cM((()=>{let n;if("int32"!==(e=Jq(e)).dtype&&(e=hq(e,"int32")),"undefined"!=typeof t.countWeights){if("count"!==this.outputMode)throw new gH(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=Jq(t.countWeights)}let r=hP(e),a=pP(e),s=AP(this.numTokens,r).bufferSync().get(0),i=_P(a,0).bufferSync().get(0);if(!s||!i)throw new gH(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let a=Jq(e);if("int32"!==a.dtype&&(a=hq(a,"int32")),"int"===t)return a;let s=a.shape;if(0===a.rank&&(a=SP(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=SP(a,-1)),a.rank>2)throw new gH(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);let i,o=["multiHot","oneHot"].includes(t),l=a;if(i=BO(l,"undefined"!=typeof r&&"count"===t?r:[],n,o),"tfIdf"!==t)return i;if(r)return EF(i,r);throw new gH("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}};SJ.className="CategoryEncoding",MW.registerClass(SJ);var IJ=new Set(["bilinear","nearest"]),CJ=class extends cK{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!IJ.has(e.interpolation))throw new gH(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){let t=(e=Zq(e))[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return cM((()=>{let t=[this.height,this.width];if("bilinear"===this.interpolation)return AW.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return AW.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...IJ]} are supported`)}))}};CJ.className="Resizing",MW.registerClass(CJ);var NJ=class{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}};NJ.className="RandomSeed";var TJ=class extends cK{constructor(e){super(e),this.randomGenerator=new NJ(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};TJ.className="BaseRandomLayer";var EJ=new Set(["bilinear","nearest"]),AJ=class extends TJ{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new gH(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new gH(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new gH(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!EJ.has(n))throw new gH(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=Zq(e))[2];return[this.imgHeight,-1,t]}call(e,t){return cM((()=>{let t=Jq(e);this.imgHeight=t.shape[t.shape.length-3];let n=t.shape[t.shape.length-2];this.widthFactor=oz([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);let a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return AW.resizeBilinear(e,a);case"nearest":return AW.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...EJ]} are supported`)}}))}};function _J(e){return new hK(e)}function $J(e){return new jY(e)}function RJ(e){return new WY(e)}function DJ(e){return new VY(e)}function MJ(e){return new UY(e)}function FJ(e){return new HY(e)}function OJ(e){return new GY(e)}function PJ(e){return new oQ(e)}function LJ(e){return new tQ(e)}function zJ(e){return new rQ(e)}function BJ(e){return new nQ(e)}function WJ(e){return new aQ(e)}function VJ(e){return new iQ(e)}function UJ(e){return new lQ(e)}function jJ(e){return new uQ(e)}function GJ(e){return new cQ(e)}function HJ(e){return new _Q(e)}function qJ(e){return new EQ(e)}function KJ(e){return new NQ(e)}function XJ(e){return new TQ(e)}function YJ(e){return new AQ(e)}function QJ(e){return new $Q(e)}function JJ(e){return new RQ(e)}function ZJ(e){return new DQ(e)}function eZ(e){return new FQ(e)}function tZ(e){return new PQ(e)}function nZ(e){return new zQ(e)}function rZ(e){return new VQ(e)}function aZ(e){return new BQ(e)}function sZ(e){return new WQ(e)}function iZ(e){return new LQ(e)}function oZ(e){return new jQ(e)}function lZ(e){return new YQ(e)}function uZ(e){return new QQ(e)}function cZ(e){return new JQ(e)}function dZ(e){return new rJ(e)}function hZ(e){return dZ(e)}function pZ(e){return dZ(e)}function fZ(e){return new iJ(e)}function mZ(e){return fZ(e)}function gZ(e){return fZ(e)}function yZ(e){return new uJ(e)}function bZ(e){return yZ(e)}function vZ(e){return yZ(e)}function xZ(e){return new dJ(e)}function wZ(e){return new fJ(e)}function kZ(e){return new hJ(e)}function SZ(e){return new mJ(e)}function IZ(e){return new nJ(e)}function CZ(e){return new sJ(e)}function NZ(e){return new lJ(e)}function TZ(e){return new bQ(e)}function EZ(e){return new yQ(e)}function AZ(e){return new xQ(e)}function _Z(e){return new vQ(e)}function $Z(e){return new gQ(e)}function RZ(e){return new mQ(e)}function DZ(e){return new CQ(e)}function MZ(e){return new IQ(e)}function FZ(e){return new pQ(e)}function OZ(e){return new wQ(e)}function PZ(e){return new bJ(e)}function LZ(e){return new yJ(e)}AJ.className="RandomWidth",MW.registerClass(AJ);var zZ=kZ,BZ=SZ,WZ=IZ,VZ=CZ;function UZ(e){return new GQ(e)}function jZ(e){return new HQ(e)}function GZ(e){return new qQ(e)}function HZ(e){return new MQ(e)}function qZ(e){return new vJ(e)}function KZ(e){return new kJ(e)}function XZ(e){return new CJ(e)}function YZ(e){return new SJ(e)}function QZ(e){return new AJ(e)}var JZ={};function ZZ(e,t){return wX(e,t)}function e0(e,t){return NX(e,t)}function t0(e,t){return TX(e,t)}function n0(e,t){return kX(e,t)}function r0(e,t){return EX(e,t)}function a0(e,t){return IX(e,t)}function s0(e,t){return CX(e,t)}function i0(e,t){return bX(e,t)}function o0(e,t){return pX(e,t)}function l0(e,t){return fX(e,t)}function u0(e,t){return fX(e,t)}function c0(e,t){return fX(e,t)}function d0(e,t){return hX(e,t)}function h0(e,t){return hX(e,t)}function p0(e,t){return hX(e,t)}ST(JZ,{MAPE:()=>u0,MSE:()=>h0,binaryAccuracy:()=>ZZ,binaryCrossentropy:()=>e0,categoricalAccuracy:()=>n0,categoricalCrossentropy:()=>r0,cosineProximity:()=>i0,mape:()=>c0,meanAbsoluteError:()=>o0,meanAbsolutePercentageError:()=>l0,meanSquaredError:()=>d0,mse:()=>p0,precision:()=>a0,recall:()=>s0,sparseCategoricalAccuracy:()=>t0});var f0={};ST(f0,{modelFromJSON:()=>uY});var m0={};function g0(e){return new OY(e)}function y0(e){return function(e){return MY(e),new OY({l1:null!=e?e.l1:null,l2:0})}(e)}function b0(e){return function(e){return MY(e),new OY({l2:null!=e?e.l2:null,l1:0})}(e)}ST(m0,{l1:()=>y0,l1l2:()=>g0,l2:()=>b0});var v0=class extends nX{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof oY))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function x0(e,t){return e<t}function w0(e,t){return e>t}var k0=class extends v0{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new yH("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=x0:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=w0:this.monitorFunc=x0,this.monitorFunc===x0&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===x0?1/0:-1/0}async onEpochEnd(e,t){await eX(t);let n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});let t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};var S0,I0,C0={earlyStopping:function(e){return new k0(e)}};HE().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(S0||(S0={})),function(e){let t;var n;(n=t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"}(I0||(I0={}));var N0={};function T0(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};N0[e]=n}function E0(e){return N0[e]}function A0(e){delete N0[e]}function _0(e,t,n,r,a){let s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){let e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return $0(t.inputNames[o],n,r,a);if("tensors"===s.type){let s=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=s[t])||void 0===n?void 0:n.op)})).map((e=>$0(e,n,r,a)))}let l=$0(t.inputNames[o],n,r,a),u=l.dataSync();return"number"===s.type?u[0]:ER.toNestedArray(l.shape,u)}let i=t.attrParams[e];return i&&i.value}function $0(e,t,n,r){let[a,s]=F0(e,n);if(null!=r){let e=r.getHashTableHandleByName(a);if(null!=e)return e}let i=n.currentContextIds.find((e=>!!t[M0(a,e)]));return void 0!==i?t[M0(a,i)][s]:void 0}function R0(e,t,n){return t[M0(e,n.currentContextId)]}function D0(e,t){let[n,r,a]=F0(e,t);return[M0(n,t&&t.currentContextId),r,a]}function M0(e,t){return t?`${e}-${t}`:e}function F0(e,t){if(""===e)return["",0,void 0];let n=null!=t&&null!=t.parseNodeNameCache;if(n){let n=t.parseNodeNameCache.get(e);if(null!=n)return n}let r,a=e.split(":");if(1===a.length)r=[e,0,void 0];else{let e=a[0],t=3===a.length?a[1]:void 0;r=[e,Number(a[a.length-1]),t]}return n&&t.parseNodeNameCache.set(e,r),r}function O0(e,t,n){let r=_0("pad",e,t,n);if("explicit"===r){r=_0("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function P0(e){return e.kept?e:SF(e)}var L0={};ST(L0,{json:()=>z0});var z0=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],B0={};ST(B0,{json:()=>W0});var W0=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],V0={};ST(V0,{json:()=>U0});var U0=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],j0={};ST(j0,{json:()=>G0});var G0=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],H0={};ST(H0,{json:()=>q0});var q0=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],K0={};ST(K0,{json:()=>X0});var X0=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Y0={};ST(Y0,{json:()=>Q0});var Q0=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],J0={};ST(J0,{json:()=>Z0});var Z0=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],e1={};ST(e1,{json:()=>t1});var t1=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],n1={};ST(n1,{json:()=>r1});var r1=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],a1={};ST(a1,{json:()=>s1});var s1=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],i1={};ST(i1,{json:()=>o1});var o1=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],l1={};ST(l1,{json:()=>u1});var u1=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],c1={};ST(c1,{json:()=>d1});var d1=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],h1={};ST(h1,{json:()=>p1});var p1=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],f1={};ST(f1,{json:()=>m1});var m1=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],g1={};ST(g1,{json:()=>y1});var y1=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],b1={};ST(b1,{json:()=>v1});var v1=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],x1={};ST(x1,{json:()=>w1});var w1=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],k1=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[].concat(...[L0,B0,V0,j0,H0,K0,Y0,J0,e1,n1,a1,i1,l1,c1,h1,f1,g1,b1,x1].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.node,r=[],a=[],s=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):(null==t.input||0===t.input.length)&&s.push(e[t.name]),e)),{}),o=[],l=[],u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach((e=>{let t=i[e];t.inputNames.forEach(((e,n)=>{let[r,,a]=D0(e),s=i[r];if(null!=s.outputs){let e=s.outputs.indexOf(a);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{let t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{let[t]=D0(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{let[t]=D0(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));let p={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:h};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){let t=E0(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{let r,a=n.type;switch(n.type){case"string":r=I1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=I1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=M1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=M1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=N1(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=N1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=D1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=D1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=C1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=C1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=O1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=O1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=R1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=R1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=F1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=F1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=A1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=A1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=_1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=_1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=E1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=E1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){let t=e.nodeDef,n=[],r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));let a=[],s=[];e.signature.inputArg.forEach((e=>{let[t]=D0(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:T1(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,a.push(n),r[t]=n})),Object.keys(r).forEach((e=>{let t=r[e];t.inputNames.forEach(((e,n)=>{let[a,,s]=D0(e),i=r[a];if(null!=i.outputs){let e=i.outputs.indexOf(s);if(-1!==e){let r=`${a}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));let i=e.ret;e.signature.outputArg.forEach((e=>{let[t,n]=D0(i[e.name]),a=r[t];null!=a&&(a.defaultOutput=n,s.push(a))}));let o=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:s,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function S1(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){let t=HE().global;if("undefined"!=typeof t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function I1(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e[t];return null!=a?S1(a.s,r):n}function C1(e,t,n){let r=e[t];return r?r.b:n}function N1(e,t,n){let r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function T1(e){switch("string"==typeof e&&(e=S0[e]),e){case S0.DT_FLOAT:case S0.DT_HALF:return"float32";case S0.DT_INT32:case S0.DT_INT64:case S0.DT_INT8:case S0.DT_UINT8:return"int32";case S0.DT_BOOL:return"bool";case S0.DT_DOUBLE:return"float32";case S0.DT_STRING:return"string";case S0.DT_COMPLEX64:case S0.DT_COMPLEX128:return"complex64";default:return null}}function E1(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function A1(e,t,n){let r=e[t];return r&&r.type?T1(r.type):n}function _1(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>T1(e))):n}function $1(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function R1(e,t,n){let r=e[t];return r&&r.shape?$1(r.shape):n}function D1(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function M1(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>S1(e,r))):n}function F1(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>$1(e))):n}function O1(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var P1=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return $0(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(null!=n.tensor)return $0(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return N1(this.node.rawAttrs,e,t);if(null!=n.s)return I1(this.node.rawAttrs,e,t);if(null!=n.b)return C1(this.node.rawAttrs,e,t);if(null!=n.shape)return R1(this.node.rawAttrs,e,t);if(null!=n.type)return A1(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return D1(this.node.rawAttrs,e,t);if(null!=n.list.s)return M1(this.node.rawAttrs,e,t);if(null!=n.list.shape)return F1(this.node.rawAttrs,e,t);if(null!=n.list.b)return O1(this.node.rawAttrs,e,t);if(null!=n.list.type)return _1(this.node.rawAttrs,e,t)}return t}},L1={};ST(L1,{OP_SCOPE_SUFFIX:()=>XD,abs:()=>AF,acos:()=>_F,acosh:()=>$F,add:()=>CF,addN:()=>RF,all:()=>DF,any:()=>MF,argMax:()=>FF,argMin:()=>OF,asin:()=>PF,asinh:()=>LF,atan:()=>zF,atan2:()=>BF,atanh:()=>WF,avgPool:()=>aO,avgPool3d:()=>sO,basicLSTMCell:()=>dO,batchNorm:()=>fO,batchNorm2d:()=>mO,batchNorm3d:()=>gO,batchNorm4d:()=>yO,batchToSpaceND:()=>hO,bincount:()=>bO,bitwiseAnd:()=>vO,booleanMaskAsync:()=>uB,broadcastArgs:()=>xO,broadcastTo:()=>wO,buffer:()=>wF,cast:()=>kF,ceil:()=>kO,clipByValue:()=>IO,clone:()=>SF,complex:()=>QD,concat:()=>iO,concat1d:()=>CO,concat2d:()=>NO,concat3d:()=>TO,concat4d:()=>EO,conv1d:()=>_O,conv2d:()=>AO,conv2dTranspose:()=>RO,conv3d:()=>DO,conv3dTranspose:()=>FO,cos:()=>OO,cosh:()=>PO,cosineWindow:()=>yB,cumprod:()=>LO,cumsum:()=>zO,denseBincount:()=>BO,depthToSpace:()=>WO,depthwiseConv2d:()=>VO,diag:()=>UO,dilation2d:()=>jO,div:()=>TF,divNoNan:()=>JO,dot:()=>ZO,dropout:()=>mB,einsum:()=>eP,elu:()=>tP,enclosingPowerOfTwo:()=>gB,ensureShape:()=>nP,equal:()=>XO,erf:()=>rP,euclideanNorm:()=>wP,exp:()=>kP,expandDims:()=>SP,expm1:()=>IP,eye:()=>NP,fft:()=>Rz,fill:()=>SO,floor:()=>TP,floorDiv:()=>NF,fused:()=>vB,gather:()=>EP,gatherND:()=>fB,greater:()=>AP,greaterEqual:()=>_P,ifft:()=>Dz,imag:()=>$P,image:()=>AW,inTopKAsync:()=>bB,irfft:()=>Mz,isFinite:()=>RP,isInf:()=>DP,isNaN:()=>MP,leakyRelu:()=>FP,less:()=>OP,lessEqual:()=>PP,linalg:()=>_W,linspace:()=>LP,localResponseNormalization:()=>zP,log:()=>BP,log1p:()=>WP,logSigmoid:()=>QP,logSoftmax:()=>ZP,logSumExp:()=>eL,logicalAnd:()=>tL,logicalNot:()=>nL,logicalOr:()=>rL,logicalXor:()=>aL,losses:()=>$W,lowerBound:()=>oL,matMul:()=>oO,max:()=>hP,maxPool:()=>lL,maxPool3d:()=>uL,maxPoolWithArgmax:()=>cL,maximum:()=>dL,mean:()=>hL,meshgrid:()=>mL,min:()=>pP,minimum:()=>gL,mirrorPad:()=>yL,mod:()=>bL,moments:()=>vL,movingAverage:()=>dB,mul:()=>EF,multiRNNCell:()=>xL,multinomial:()=>wL,neg:()=>XP,norm:()=>xP,notEqual:()=>kL,oneHot:()=>SL,ones:()=>fL,onesLike:()=>IL,op:()=>YD,outerProduct:()=>CL,pad:()=>NL,pad1d:()=>TL,pad2d:()=>EL,pad3d:()=>AL,pad4d:()=>_L,pool:()=>RL,pow:()=>fP,prelu:()=>DL,print:()=>IF,prod:()=>ML,raggedGather:()=>FL,raggedRange:()=>OL,raggedTensorToTensor:()=>PL,rand:()=>LL,randomGamma:()=>az,randomNormal:()=>sz,randomStandardNormal:()=>iz,randomUniform:()=>oz,randomUniformInt:()=>lz,range:()=>uz,real:()=>cz,reciprocal:()=>dz,relu:()=>hz,relu6:()=>pz,reshape:()=>rO,reverse:()=>fz,reverse1d:()=>mz,reverse2d:()=>gz,reverse3d:()=>yz,reverse4d:()=>bz,rfft:()=>Oz,round:()=>vz,rsqrt:()=>xz,scalar:()=>mP,scatterND:()=>hB,searchSorted:()=>iL,selu:()=>wz,separableConv2d:()=>kz,setdiff1dAsync:()=>Sz,sigmoid:()=>lO,sign:()=>Iz,signal:()=>EW,sin:()=>Cz,sinh:()=>Nz,slice:()=>uO,slice1d:()=>Tz,slice2d:()=>Ez,slice3d:()=>Az,slice4d:()=>_z,softmax:()=>$z,softplus:()=>YP,spaceToBatchND:()=>$L,sparse:()=>RW,sparseToDense:()=>pB,spectral:()=>TW,split:()=>Fz,sqrt:()=>gP,square:()=>yP,squaredDifference:()=>Pz,squeeze:()=>Lz,stack:()=>zz,step:()=>Bz,stridedSlice:()=>Wz,string:()=>DW,sub:()=>JP,sum:()=>bP,tan:()=>Vz,tanh:()=>cO,tensor:()=>ZD,tensor1d:()=>Uz,tensor2d:()=>jz,tensor3d:()=>Gz,tensor4d:()=>Hz,tensor5d:()=>qz,tensor6d:()=>Kz,tensorScatterUpdate:()=>Zz,tile:()=>CP,topk:()=>eB,transpose:()=>cB,truncatedNormal:()=>tB,unique:()=>nB,unsortedSegmentSum:()=>rB,unstack:()=>aB,upperBound:()=>sB,variable:()=>iB,where:()=>YO,whereAsync:()=>lB,zeros:()=>pL,zerosLike:()=>QO});function z1(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!=typeof e&&"number"!=typeof t){ER.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){let a=e[r],s=t[r];ER.assert(a<0||s<0||a===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function B1(e){return!("number"==typeof e||e.some((e=>e<0)))}function W1(e,t,n){let r=V1(e,n),a=!B1(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=V1(e.shape,r)})),!B1(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function V1(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var U1=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=mP(0),hM(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),z1(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,hM(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return ZD([],[0].concat(this.elementShape));let n=this.readMany(e);return z1(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),zz(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return ZD([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return z1(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),iO(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,aB(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=0===n?0:t.size/n,s=[];cM((()=>{t=rO(t,[1,n,a]);for(let n=0;n<e.length;++n){let i=[0,0===n?0:r[n-1],0],o=[1,e[n],a];s[n]=rO(uO(t,i,o),this.elementShape)}return s}));let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},j1=class e{get id(){return this.idTensor.id}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);z1(t,e.shape,"TensorList shape mismatch: "),hM(e)})),this.idTensor=mP(0),this.maxNumElements=r,hM(this.idTensor)}copy(){return new e([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.id))&&t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);z1(e,this.elementShape,"TensorList shape mismatch: ");let r=W1(this.elementShape,this.tensors,e);return cM((()=>{let e=this.tensors.map((e=>rO(e,r)));return zz(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");let n=W1(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,z1(r.shape,e,"TensorList shape mismatch: "),rO(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(z1(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");hM(e),this.tensors.push(e)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new e([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let e=0;e<Math.min(this.tensors.length,t);++e)n.tensors[e]=this.tensors[e];return n}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);z1(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=W1(this.elementShape,this.tensors,t);return rO(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);z1(this.elementShape,t.shape,"TensorList shape mismatch: "),hM(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);z1(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=W1(this.elementShape,this.tensors,n);return 0===e.length?ZD([],[0].concat(r)):cM((()=>{let t=e.map((e=>rO(this.tensors[e],r)));return zz(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);z1(this.elementShape,t,"TensorList shape mismatch: ");let n=W1(this.elementShape,this.tensors,t);return 0===this.size()?ZD([],[0].concat(n)):cM((()=>{let e=this.tensors.map((e=>rO(e,n)));return iO(e,0)}))}};var G1=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=_0("thenBranch",e,t,n),a=_0("elseBranch",e,t,n),s=_0("cond",e,t,n),i=_0("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=_0("body",e,t,n),a=_0("cond",e,t,n),s=_0("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map((e=>e.id)),l=await i[0].data();i.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&e.dispose()}));let u=s;for(;l[0];){let e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let t=u.map((e=>e.id));e.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}));let s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}))}return u}case"LoopCond":return[P0(_0("pred",e,t,n))];case"Switch":{let r=_0("pred",e,t,n),a=_0("data",e,t,n);return a.kept||(a=P0(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find((e=>void 0!==$0(e,t,n)));if(r){return[P0($0(r,t,n))]}return}case"Enter":{let r=_0("frameName",e,t,n),a=_0("tensor",e,t,n);return n.enterFrame(r),[P0(a)]}case"Exit":{let r=_0("tensor",e,t,n);return n.exitFrame(),[P0(r)]}case"NextIteration":{let r=_0("tensor",e,t,n);return n.nextIteration(),[P0(r)]}case"TensorArrayV3":{let r=_0("size",e,t,n),a=_0("dtype",e,t,n),s=_0("elementShape",e,t,n),i=_0("dynamicSize",e,t,n),o=_0("clearAfterRead",e,t,n),l=_0("identicalElementShapes",e,t,n),u=_0("name",e,t,n),c=new U1(u,a,r,s,l,i,o);return n.addTensorArray(c),[c.idTensor,mP(1)]}case"TensorArrayWriteV3":{let r=_0("tensorArrayId",e,t,n),a=_0("index",e,t,n),s=_0("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=_0("tensorArrayId",e,t,n),a=_0("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=_0("tensorArrayId",e,t,n),a=_0("indices",e,t,n),s=_0("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=_0("tensorArrayId",e,t,n),a=_0("indices",e,t,n),s=_0("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=_0("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=_0("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=_0("tensorArrayId",e,t,n),a=_0("tensor",e,t,n),s=_0("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=_0("tensorArrayId",e,t,n);return[mP(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{let r=_0("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=_0("tensorListId",e,t,n),a=_0("index",e,t,n),s=_0("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=_0("tensorListId",e,t,n),a=_0("index",e,t,n),s=_0("elementShape",e,t,n),i=_0("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=_0("indices",e,t,n),a=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new j1([],n,e.dtype,r),i=aB(e,0);return t.forEach(((e,t)=>{s.setItem(e,i[t])})),s}(_0("tensor",e,t,n),r,_0("elementShape",e,t,n),_0("numElements",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r,a=_0("elementShape",e,t,n),s=_0("elementDType",e,t,n);r="TensorListReserve"===e.op?"numElements":"maxNumElements";let i=_0(r,e,t,n),o=function(e,t,n,r){return new j1([],e,t,r)}(a,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{let r=_0("tensorListId",e,t,n),a=_0("indices",e,t,n),s=_0("elementShape",e,t,n),i=_0("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=_0("tensorListId",e,t,n),a=_0("elementShape",e,t,n),s=_0("elementDType",e,t,n),i=_0("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=function(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);z1(e.shape.slice(1),t,"TensorList shape mismatch: ");let a=aB(e);return new j1(a,t,r)}(_0("tensor",e,t,n),_0("elementShape",e,t,n),_0("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=_0("tensorListId",e,t,n),a=n.getTensorList(r.id),s=_0("dtype",e,t,n),i=_0("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=_0("tensorListId",e,t,n),a=_0("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=_0("tensorListId",e,t,n),a=_0("elementShape",e,t,n),s=_0("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=_0("tensor",e,t,n),a=_0("elementShape",e,t,n),s=function(e,t,n){let r=0,a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);let s=V1(e.shape.slice(1),n),i=0===r?0:e.size/r,o=cM((()=>{let n=[];e=rO(e,[1,r,i]);for(let r=0;r<t.length;++r){let o=[0,0===r?0:a[r-1],0],l=[1,t[r],i];n[r]=rO(uO(e,o,l),s)}return e.dispose(),n})),l=new j1([],n,e.dtype,t.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(r,_0("lengths",e,t,n),a);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{let r=_0("tensorListId",e,t,n);return[mP(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{let r=_0("tensorListId",e,t,n),a=_0("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function H1(e,t,n){let[r,a]=_0("fusedOps",e,t,n),s="biasadd"===r,i=!s,o="prelu"===a,l="fusedbatchnorm"===r,u=_0("numArgs",e,t,n);if(s){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=_0("strides",e,t,n),d=O0(e,t,n),h=_0("dataFormat",e,t,n).toUpperCase(),p=_0("dilations",e,t,n),[f,m]=_0("args",e,t,n);return i&&(m=f,f=void 0),{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:_0("leakyreluAlpha",e,t,n)}}function q1(e,t,n){return{boxes:_0("boxes",e,t,n),scores:_0("scores",e,t,n),maxOutputSize:_0("maxOutputSize",e,t,n),iouThreshold:_0("iouThreshold",e,t,n),scoreThreshold:_0("scoreThreshold",e,t,n),softNmsSigma:_0("softNmsSigma",e,t,n)}}var K1=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=mP(0),this.tensorMap=new Map,hM(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return mP(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),cM((()=>{let e=aB(t),r=n.length,a=e.length;ER.assert(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){let r=n[t],a=e[t];hM(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return cM((()=>{let e=[];for(let r=0;r<n.length;r++){let a=n[r],s=this.findWithDefault(a,t);e.push(s)}return zz(e)}))}findWithDefault(e,t){let n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};function X1(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:cM,s=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(_0("a",e,t,n),_0("b",e,t,n))];case"AddN":return[r.addN(_0("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(_0("a",e,t,n),_0("b",e,t,n))];case"Mul":return[r.mul(_0("a",e,t,n),_0("b",e,t,n))];case"RealDiv":case"Div":return[r.div(_0("a",e,t,n),_0("b",e,t,n))];case"DivNoNan":return[r.divNoNan(_0("a",e,t,n),_0("b",e,t,n))];case"FloorDiv":return[r.floorDiv(_0("a",e,t,n),_0("b",e,t,n))];case"Sub":return[r.sub(_0("a",e,t,n),_0("b",e,t,n))];case"Minimum":return[r.minimum(_0("a",e,t,n),_0("b",e,t,n))];case"Maximum":return[r.maximum(_0("a",e,t,n),_0("b",e,t,n))];case"Pow":return[r.pow(_0("a",e,t,n),_0("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(_0("a",e,t,n),_0("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"basic_math":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(_0("x",e,t,n))];case"Acos":return[r.acos(_0("x",e,t,n))];case"Acosh":return[r.acosh(_0("x",e,t,n))];case"Asin":return[r.asin(_0("x",e,t,n))];case"Asinh":return[r.asinh(_0("x",e,t,n))];case"Atan":return[r.atan(_0("x",e,t,n))];case"Atan2":return[r.atan2(_0("x",e,t,n),_0("y",e,t,n))];case"Atanh":return[r.atanh(_0("x",e,t,n))];case"Ceil":return[r.ceil(_0("x",e,t,n))];case"Complex":return[r.complex(_0("real",e,t,n),_0("imag",e,t,n))];case"Cos":return[r.cos(_0("x",e,t,n))];case"Cosh":return[r.cosh(_0("x",e,t,n))];case"Elu":return[r.elu(_0("x",e,t,n))];case"Erf":return[r.erf(_0("x",e,t,n))];case"Exp":return[r.exp(_0("x",e,t,n))];case"Expm1":return[r.expm1(_0("x",e,t,n))];case"Floor":return[r.floor(_0("x",e,t,n))];case"Log":return[r.log(_0("x",e,t,n))];case"Log1p":return[r.log1p(_0("x",e,t,n))];case"Imag":return[r.imag(_0("x",e,t,n))];case"Neg":return[r.neg(_0("x",e,t,n))];case"Reciprocal":return[r.reciprocal(_0("x",e,t,n))];case"Real":return[r.real(_0("x",e,t,n))];case"Relu":return[r.relu(_0("x",e,t,n))];case"Round":return[r.round(_0("x",e,t,n))];case"Selu":return[r.selu(_0("x",e,t,n))];case"Sigmoid":return[r.sigmoid(_0("x",e,t,n))];case"Sin":return[r.sin(_0("x",e,t,n))];case"Sign":return[r.sign(_0("x",e,t,n))];case"Sinh":return[r.sinh(_0("x",e,t,n))];case"Softplus":return[r.softplus(_0("x",e,t,n))];case"Sqrt":return[r.sqrt(_0("x",e,t,n))];case"Square":return[r.square(_0("x",e,t,n))];case"Tanh":return[r.tanh(_0("x",e,t,n))];case"Tan":return[r.tan(_0("x",e,t,n))];case"ClipByValue":return[r.clipByValue(_0("x",e,t,n),_0("clipValueMin",e,t,n),_0("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(_0("x",e,t,n))];case"Rsqrt":return[r.rsqrt($0(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(_0("x",e,t,n),_0("alpha",e,t,n))];case"Prelu":return[r.prelu(_0("x",e,t,n),_0("alpha",e,t,n))];case"IsNan":return[r.isNaN($0(e.inputNames[0],t,n))];case"IsInf":return[r.isInf($0(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite($0(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"control":return G1(e,t,n);case"convolution":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"Conv1D":{let a=_0("stride",e,t,n),s=_0("pad",e,t,n),i=_0("dataFormat",e,t,n).toUpperCase(),o=_0("dilation",e,t,n);return[r.conv1d(_0("x",e,t,n),_0("filter",e,t,n),a,s,i,o)]}case"Conv2D":{let a=_0("strides",e,t,n),s=O0(e,t,n),i=_0("dataFormat",e,t,n).toUpperCase(),o=_0("dilations",e,t,n);return[r.conv2d(_0("x",e,t,n),_0("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=H1(e,t,n);return[r.fused.conv2d({x:_0("x",e,t,n),filter:_0("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=H1(e,t,n);return[r.fused.depthwiseConv2d({x:_0("x",e,t,n),filter:_0("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=_0("outputShape",e,t,n),s=_0("strides",e,t,n),i=O0(e,t,n);return[r.conv2dTranspose(_0("x",e,t,n),_0("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=_0("strides",e,t,n),s=O0(e,t,n),i=_0("dilations",e,t,n),o=_0("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(_0("input",e,t,n),_0("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let a=_0("strides",e,t,n),s=_0("pad",e,t,n),i=_0("dataFormat",e,t,n).toUpperCase(),o=_0("dilations",e,t,n);return[r.conv3d(_0("x",e,t,n),_0("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let a=_0("strides",e,t,n),s=_0("pad",e,t,n),i=_0("kernelSize",e,t,n);return[r.avgPool(_0("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{let a=_0("strides",e,t,n),s=_0("pad",e,t,n),i=_0("kernelSize",e,t,n);return[r.maxPool(_0("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{let a=_0("strides",e,t,n),s=_0("pad",e,t,n),i=_0("kernelSize",e,t,n),o=_0("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(_0("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,u]}case"AvgPool3D":{let a=_0("strides",e,t,n),s=_0("pad",e,t,n),i=_0("kernelSize",e,t,n);return[r.avgPool3d(_0("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{let a=_0("strides",e,t,n),s=_0("pad",e,t,n),i=_0("kernelSize",e,t,n);return[r.maxPool3d(_0("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{let a=_0("strides",e,t,n),s=_0("pad",e,t,n),i=_0("dilations",e,t,n),o=a[1],l=a[2],u=i[1],c=i[2];return[r.dilation2d(_0("x",e,t,n),_0("filter",e,t,n),[o,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"creation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"Fill":{let a=_0("shape",e,t,n),s=_0("dtype",e,t,n),i=_0("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{let a=_0("start",e,t,n),s=_0("stop",e,t,n),i=_0("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{let a=_0("logits",e,t,n),s=_0("numSamples",e,t,n),i=_0("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{let a=_0("indices",e,t,n),s=_0("depth",e,t,n),i=_0("onValue",e,t,n),o=_0("offValue",e,t,n),l=_0("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(_0("shape",e,t,n),_0("dtype",e,t,n))];case"OnesLike":return[r.onesLike(_0("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(_0("shape",e,t,n),_0("dtype",e,t,n),_0("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(_0("shape",e,t,n),_0("minval",e,t,n),_0("maxval",e,t,n),_0("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(_0("shape",e,t,n),_0("minval",e,t,n),_0("maxval",e,t,n),_0("seed",e,t,n))];case"Range":{let a=_0("start",e,t,n),s=_0("stop",e,t,n),i=_0("step",e,t,n);return[r.range(a,s,i,_0("dtype",e,t,n))]}case"TruncatedNormal":{let a=_0("shape",e,t,n),s=_0("mean",e,t,n),i=_0("stdDev",e,t,n),o=_0("seed",e,t,n);return[r.truncatedNormal(a,s,i,_0("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(_0("shape",e,t,n),_0("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(_0("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"dynamic":return async function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:L1;switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=q1(e,t,n),c=await a.image.nonMaxSuppressionWithScoreAsync(r,s,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=q1(e,t,n),u=_0("padToMaxOutputSize",e,t,n),c=await a.image.nonMaxSuppressionPaddedAsync(r,s,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=q1(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,s,i,o,l)]}case"Where":{let r=a.cast(_0("condition",e,t,n),"bool"),s=[await a.whereAsync(r)];return r.dispose(),s}case"ListDiff":return a.setdiff1dAsync(_0("x",e,t,n),_0("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n);case"evaluation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"LowerBound":{let a=_0("sortedSequence",e,t,n),s=_0("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{let a=_0("x",e,t,n),s=_0("k",e,t,n),i=_0("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{let a=_0("sortedSequence",e,t,n),s=_0("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{let a=_0("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{let a=_0("x",e,t,n),s=_0("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"image":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"ResizeBilinear":{let a=_0("images",e,t,n),s=_0("size",e,t,n),i=_0("alignCorners",e,t,n),o=_0("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let a=_0("images",e,t,n),s=_0("size",e,t,n),i=_0("alignCorners",e,t,n),o=_0("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{let a=_0("image",e,t,n),s=_0("boxes",e,t,n),i=_0("boxInd",e,t,n),o=_0("cropSize",e,t,n),l=_0("method",e,t,n),u=_0("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{let a=_0("images",e,t,n),s=_0("transforms",e,t,n),i=_0("outputShape",e,t,n),o=_0("fillValue",e,t,n),l=_0("interpolation",e,t,n),u=_0("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"graph":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=_0("default",e,t,n);return[$0(e.name,t,n)||a];case"Placeholder":return[$0(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[P0(_0("x",e,t,n))];case"IdentityN":return _0("x",e,t,n).map((e=>P0(e)));case"Shape":return[r.tensor1d(_0("x",e,t,n).shape,"int32")];case"ShapeN":return _0("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(_0("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(_0("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let s=_0("x",e,t,n),i=_0("data",e,t,n),o=_0("message",e,t,n),l=_0("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"logical":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"Equal":return[r.equal(_0("a",e,t,n),_0("b",e,t,n))];case"NotEqual":return[r.notEqual(_0("a",e,t,n),_0("b",e,t,n))];case"Greater":return[r.greater(_0("a",e,t,n),_0("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(_0("a",e,t,n),_0("b",e,t,n))];case"Less":return[r.less(_0("a",e,t,n),_0("b",e,t,n))];case"LessEqual":return[r.lessEqual(_0("a",e,t,n),_0("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(_0("a",e,t,n),_0("b",e,t,n))];case"LogicalNot":return[r.logicalNot(_0("a",e,t,n))];case"LogicalOr":return[r.logicalOr(_0("a",e,t,n),_0("b",e,t,n))];case"Select":case"SelectV2":return[r.where(_0("condition",e,t,n),_0("a",e,t,n),_0("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(_0("a",e,t,n),_0("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"matrices":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(_0("a",e,t,n),_0("b",e,t,n),_0("transposeA",e,t,n),_0("transposeB",e,t,n))];case"Einsum":return[r.einsum(_0("equation",e,t,n),..._0("tensors",e,t,n))];case"Transpose":return[r.transpose(_0("x",e,t,n),_0("perm",e,t,n))];case"_FusedMatMul":let[a,s]=_0("fusedOps",e,t,n),i="biasadd"===a,o="prelu"===s,l=_0("numArgs",e,t,n),u=_0("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,d]=_0("args",e,t,n);return[r.fused.matMul({a:_0("a",e,t,n),b:_0("b",e,t,n),transposeA:_0("transposeA",e,t,n),transposeB:_0("transposeB",e,t,n),bias:c,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(_0("a",e,t,n),_0("numLower",e,t,n),_0("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"normalization":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(_0("x",e,t,n),_0("axis",e,t,n),_0("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(_0("x",e,t,n),_0("mean",e,t,n),_0("variance",e,t,n),_0("offset",e,t,n),_0("scale",e,t,n),_0("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(_0("x",e,t,n),_0("radius",e,t,n),_0("bias",e,t,n),_0("alpha",e,t,n),_0("beta",e,t,n))];case"Softmax":return[r.softmax(_0("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(_0("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"ragged":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(_0("paramsNestedSplits",e,t,n),_0("paramsDenseValues",e,t,n),_0("indices",e,t,n),_0("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(_0("starts",e,t,n),_0("limits",e,t,n),_0("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(_0("shape",e,t,n),_0("values",e,t,n),_0("defaultValue",e,t,n),_0("rowPartitionTensors",e,t,n),_0("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"reduction":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"Max":{let a=_0("axis",e,t,n),s=_0("keepDims",e,t,n);return[r.max(_0("x",e,t,n),a,s)]}case"Mean":{let a=_0("axis",e,t,n),s=_0("keepDims",e,t,n);return[r.mean(_0("x",e,t,n),a,s)]}case"Min":{let a=_0("axis",e,t,n),s=_0("keepDims",e,t,n);return[r.min(_0("x",e,t,n),a,s)]}case"Sum":{let a=_0("axis",e,t,n),s=_0("keepDims",e,t,n);return[r.sum(_0("x",e,t,n),a,s)]}case"All":{let a=_0("axis",e,t,n),s=_0("keepDims",e,t,n);return[r.all(_0("x",e,t,n),a,s)]}case"Any":{let a=_0("axis",e,t,n),s=_0("keepDims",e,t,n);return[r.any(_0("x",e,t,n),a,s)]}case"ArgMax":{let a=_0("axis",e,t,n);return[r.argMax(_0("x",e,t,n),a)]}case"ArgMin":{let a=_0("axis",e,t,n);return[r.argMin(_0("x",e,t,n),a)]}case"Prod":{let a=_0("axis",e,t,n),s=_0("keepDims",e,t,n);return[r.prod(_0("x",e,t,n),a,s)]}case"Cumprod":{let a=_0("axis",e,t,n),s=_0("exclusive",e,t,n),i=_0("reverse",e,t,n);return[r.cumprod(_0("x",e,t,n),a,s,i)]}case"Cumsum":{let a=_0("axis",e,t,n),s=_0("exclusive",e,t,n),i=_0("reverse",e,t,n);return[r.cumsum(_0("x",e,t,n),a,s,i)]}case"Bincount":let a=_0("x",e,t,n),s=_0("weights",e,t,n),i=_0("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{let a=_0("x",e,t,n),s=_0("weights",e,t,n),i=_0("size",e,t,n),o=_0("binaryOutput",e,t,n);return[r.denseBincount(a,s,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"slice_join":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"ConcatV2":case"Concat":{let a=_0("n",e,t,n),s=_0("axis",e,t,n),i=_0("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{let a=_0("x",e,t,n),s=_0("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{let a=_0("axis",e,t,n),s=_0("batchDims",e,t,n),i=_0("x",e,t,n),o=_0("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{let a=_0("dims",e,t,n),s=[];for(let e=0;e<a.length;e++)a[e]&&s.push(e);let i=_0("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{let a=_0("axis",e,t,n),s=_0("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{let a=_0("begin",e,t,n),s=_0("size",e,t,n);return[r.slice(_0("x",e,t,n),a,s)]}case"StridedSlice":{let a=_0("begin",e,t,n),s=_0("end",e,t,n),i=_0("strides",e,t,n),o=_0("beginMask",e,t,n),l=_0("endMask",e,t,n),u=_0("ellipsisMask",e,t,n),c=_0("newAxisMask",e,t,n),d=_0("shrinkAxisMask",e,t,n),h=_0("x",e,t,n);return[r.stridedSlice(h,a,s,i,o,l,u,c,d)]}case"Pack":return cM((()=>{let a=_0("axis",e,t,n),s=_0("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map((e=>{let t=ER.arraysEqual(e.shape,i);if(!t&&!ER.arraysEqual(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,a)]}));case"Unpack":{let a=_0("axis",e,t,n),s=_0("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{let a=_0("reps",e,t,n);return[r.tile(_0("x",e,t,n),a)]}case"Split":case"SplitV":{let a=_0("axis",e,t,n),s=_0("numOrSizeSplits",e,t,n),i=_0("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{let a=_0("indices",e,t,n),s=_0("values",e,t,n),i=_0("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{let a=_0("x",e,t,n),s=_0("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{let a=_0("sparseIndices",e,t,n),s=_0("outputShape",e,t,n),i=_0("sparseValues",e,t,n),o=_0("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let a=_0("indices",e,t,n),s=_0("values",e,t,n),i=_0("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"sparse":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(_0("indices",e,t,n),_0("values",e,t,n),_0("denseShape",e,t,n),_0("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{let{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(_0("inputIndices",e,t,n),_0("inputShape",e,t,n),_0("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(_0("data",e,t,n),_0("indices",e,t,n),_0("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(_0("data",e,t,n),_0("indices",e,t,n),_0("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"spectral":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"FFT":return[r.fft(_0("x",e,t,n))];case"IFFT":return[r.ifft(_0("x",e,t,n))];case"RFFT":return[r.rfft(_0("x",e,t,n))];case"IRFFT":return[r.irfft(_0("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"string":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(_0("input",e,t,n),_0("pattern",e,t,n),_0("rewrite",e,t,n),_0("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(_0("data",e,t,n),_0("dataSplits",e,t,n),_0("separator",e,t,n),_0("nGramWidths",e,t,n),_0("leftPad",e,t,n),_0("rightPad",e,t,n),_0("padWidth",e,t,n),_0("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{let{indices:a,values:s,shape:i}=r.string.stringSplit(_0("input",e,t,n),_0("delimiter",e,t,n),_0("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(_0("input",e,t,n),_0("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"transformation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L1;switch(e.op){case"Cast":return[r.cast(_0("x",e,t,n),_0("dtype",e,t,n))];case"ExpandDims":{let a=_0("axis",e,t,n);return[r.expandDims(_0("x",e,t,n),a)]}case"Squeeze":{let a=_0("axis",e,t,n);return[r.squeeze(_0("x",e,t,n),a)]}case"Reshape":return[r.reshape(_0("x",e,t,n),_0("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(_0("x",e,t,n),_0("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(_0("x",e,t,n),_0("padding",e,t,n),_0("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(_0("x",e,t,n),_0("padding",e,t,n),_0("constantValue",e,t,n))];case"SpaceToBatchND":{let a=_0("blockShape",e,t,n),s=_0("paddings",e,t,n);return[r.spaceToBatchND(_0("x",e,t,n),a,s)]}case"BatchToSpaceND":{let a=_0("blockShape",e,t,n),s=_0("crops",e,t,n);return[r.batchToSpaceND(_0("x",e,t,n),a,s)]}case"DepthToSpace":{let a=_0("blockSize",e,t,n),s=_0("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(_0("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(_0("x",e,t,n),_0("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(_0("s0",e,t,n),_0("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(null!=a)return[a];{let a=_0("keyDType",e,t,n),s=_0("valueDType",e,t,n),i=new K1(a,s);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=_0("tableHandle",e,t,n,r),s=_0("keys",e,t,n),i=_0("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=_0("tableHandle",e,t,n,r),s=_0("keys",e,t,n),i=_0("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=_0("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":let s=E0(e.op);if(s&&s.customExecutor)return s.customExecutor(new P1(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return ER.isPromise(s)?s.then((e=>[].concat(e))):[].concat(s)}var Y1=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function Q1(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map((e=>F0(e)[0])));r=r||[];let c=new Set(r.map((e=>F0(e.name)[0]))),d=[...t];for(;d.length>0;){let e=d.pop();if((r2(e)||a2(e)||s2(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&!u.has(e.name)&&!c.has(e.name)){if(0===e.inputs.length){s.push(e.name);continue}e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))}))}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function J1(e,t){let{usedNodes:n,inputs:r}=t,a=Object.keys(r).map((e=>F0(e)[0])).map((t=>e.nodes[t])),s=e.initNodes||[],i=e=>n.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}let l=o([...a,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map((e=>[e.name,e]))),d={};for(let m of u){d[m.name]=d[m.name]||0;for(let e of m.children)i(e)||(d[e.name]=Number.POSITIVE_INFINITY),d[e.name]=(d[e.name]||0)+1}let h=Object.entries(d).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...h];for(;h.length>0;){let e=h.pop(),t=c.get(e);for(let n of t.children.filter(i))0===--d[n.name]&&(p.push(n.name),h.push(n.name))}let f=function(e,t){let n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),a=new Set(r);for(;r.length>0;){let e=r.pop(),t=n.get(e);for(let s of t.children)!n.has(s.name)||a.has(s.name)||(a.add(s.name),r.push(s.name))}return e.filter((e=>a.has(e.name)))}(p.map((e=>c.get(e))),l);return function(e,t){let n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),a=e=>r.has("string"==typeof e?e:e.name),s=new Set(e.map((e=>e.name))),i=e=>s.has("string"==typeof e?e:e.name);for(let o of e){for(let e of o.children.filter(i)){if(!n.has(e.name))throw new Z1(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new Z1(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!a(o))for(let e of o.inputs){if(!n.has(e.name))throw new Z1(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new Z1(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}var Z1=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};var e2=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),t2=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),n2=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function r2(e){return e2.has(e.op)}function a2(e){return t2.has(e.op)}function s2(e){return n2.has(e.op)}var i2=class e{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((n=>{this._functionExecutorMap[n]=new e(t.functions[n],this)}))}getCompilationKey(e,t){let n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){let n=Q1(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){let n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}let i=J1(this.graph,n),o=function(e){let t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>r2(e)?n:t)),a=e=>{let n=r[t.get(e.name)];return null==n?-1:n},s=e.map(((e,t)=>e.children.map(a).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){let t=s[o];if(t===n)continue;let r=e[o],a=e[t];i.has(a.name)||i.set(a.name,[]),i.get(a.name).push(r)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;let t=e.clone();return hM(t),t}cloneTensorList(e){return e?e.map((e=>this.cloneAndKeepTensor(e))):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map((e=>this.graph.nodes[F0(e)[0]])),a=t.map((e=>F0(e)[0])),s=new Set(a),i=a.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);let o=this.getCompilationKey(r,i),l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=HE().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let u={},c={};return cM((()=>{let n=new Y1(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{let[a,s]=F0(t,n),i=[];i[s]=e[t],r[a]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(i))}));let a=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(let e of i){if(r[e.name])continue;let t=X1(e,r,n,this._resourceManager);if(ER.isPromise(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,a,s,o.get(e.name))}return null==this.parent&&n.dispose(a),t.map((e=>$0(e,r,n)))}))}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,i){if(!r2(t)&&!s.has(e)){for(let r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(let e of t.inputs){if(r2(e))continue;let t=R0(e.name,n,r);if(null!=t)for(let e of t){if(!e||e.kept||a.has(e.id))continue;let t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,a,s){function i(e){return r2(e)||a.has(e.name)}if(!r2(e)&&null!=s)for(let o of s){if(i(o))continue;let e=R0(o.name,t,n);for(let t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=HE().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let s=new Y1(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let i=await this.executeWithControlFlow(e,s,t,n),o=t.map((e=>$0(e,i,s))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{e&&!e.isDisposed&&!c.has(e.id)&&e.dispose()}))})),null==this.parent&&s.dispose(c),o}async executeFunctionAsync(e,t,n){let r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let a=Object.keys(e),s=a.map((e=>this.graph.nodes[F0(e)[0]])),i=n.map((e=>F0(e)[0])),o=new Set(i),l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);let{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:h}=Q1(e,l,this.weightMap,this._initNodes),p=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{let[n,r]=F0(t),a=[];a[r]=e[t],f[n]=a}));let m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){let e=this.processStack(s,p,t,f,y,g,o,m,u);await Promise.all(e)}null==d&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=l.filter((e=>!r2(e)&&!$0(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,a,s,i,o,l){let u=[];for(;t.length>0;){let e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&_0("isConstant",e.node,r,n)&&([c]=D0(e.node.name,n)),null==r[e.node.name]){let d=X1(e.node,r,n,this._resourceManager);c||([c]=D0(e.node.name,n));let h=n.currentContext;ER.isPromise(d)?u.push(d.then((u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=h,this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{let[i]=D0(e.name,n);a[i]||!s.has(e.name)||("Merge"===e.op?e.inputNames.some((e=>!!$0(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!$0(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{let n=e[t],[r]=F0(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){let e=a.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));ER.assert(t,(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&ER.assert(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;let r={};for(let a in e){let s=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[a];null!=s?r[s.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){let t=Object.keys(e).filter((e=>{let[t]=F0(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;let r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{let[t]=F0(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}},o2=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},l2="?tfjs-format=file",u2="model.json",c2=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:YW;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new o2}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return ER.isPromise(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");let t=await _M(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new i2(k1.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=k1.Instance.transformGraph(e.modelInitializer);this.initializer=new i2(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){let t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t={};return(e instanceof hD?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof hD)&&!Array.isArray(e)){let n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(let t in n){let r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var a,s,i;let o=null===(i=null===(s=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===s?void 0:s[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=t[n[r]];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&dM(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function d2(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:YW;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){return e.endsWith("/")||(e+="/"),`${e}${u2}${l2}`}(e));let r=new c2(e,t,n);return await r.load(),r}function h2(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");let a=YW.getWeightSpecs(n.weightsManifest),s=YW.getModelArtifactsForJSONSync(n,a,r);t=YW.fromMemorySync(s)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=YW.fromMemorySync(e)}let n=new c2(t);return n.load(),n}var p2="4.16.0",f2={};ST(f2,{CSVDataset:()=>i3,Dataset:()=>q2,FileDataSource:()=>v3,TextLineDataset:()=>Z2,URLDataSource:()=>x3,array:()=>X2,csv:()=>w3,func:()=>k3,generator:()=>S3,microphone:()=>C3,version_data:()=>N3,webcam:()=>I3,zip:()=>Y2});var m2=IT(OT()),g2=IT(OT());function y2(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(k2(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let s in e){let i=y2(e[s],t,n,r);a[s]=i}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function b2(e){return v2(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:x2)}function v2(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set,r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(k2(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let s in r){let r=v2(e.map((e=>e[s])),t,n);a[s]=r}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function x2(e){return null===e?null:k2(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function w2(e,t){let n=new Map;y2(e,t,n);for(let r of Array.from(n.keys())){let e=n.get(r);if(ER.isPromise(e)){let t=await e;n.set(r,t)}}return y2(e,t,n)}function k2(e){let t=!1;if(HE().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=PT();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof hD)&&!(e instanceof Promise)&&!t)}function S2(e){return function(e,t){return y2(e,t)}(e,I2)}function I2(e){return e instanceof hD?{value:e.clone(),recurse:!1}:k2(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var C2=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},N2=class e extends C2{constructor(){super(e.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};function T2(e){return new $2(e)}function E2(e){return new R2(e)}N2.INITIAL_CAPACITY=32;var A2,_2=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new z2(this,e)}filter(e){return new P2(this,e)}map(e){return new L2(this,e)}mapAsync(e){return new B2(this,e)}serialMapAsync(e){return new B2(this,e).serial()}flatmap(e){return new V2(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new O2(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:x2;return this.rowMajorBatch(e,t).map((e=>b2(e,n)))}concatenate(e,t){return new U2(T2([this,e]),t)}take(e){return e<0||null==e?this:new F2(this,e)}skip(e){return e<0||null==e?this:new M2(this,e)}prefetch(e){return new G2(this,e)}shuffle(e,t){return new H2(this,e,t)}serial(){return new D2(this)}},$2=class extends _2{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:S2(e),done:!1}}},R2=class extends _2{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(gD){throw gD.message=`Error thrown while iterating through a dataset: ${gD.message}`,gD}}},D2=class extends _2{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}},M2=class extends _2{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;dM(e.value)}return this.upstream.next()}},F2=class extends _2{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},O2=class extends _2{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},P2=class extends _2{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;dM(e.value)}}},L2=class extends _2{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=wD.getTensorsInContainer(e.value),n=this.transform(e.value),r=wD.getTensorsInContainer(n);for(let a of t)wD.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},z2=class extends _2{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(gD){if(!this.handler(gD))return{value:null,done:!0}}}},B2=class extends _2{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=wD.getTensorsInContainer(e.value),n=await this.transform(e.value),r=wD.getTensorsInContainer(n);for(let a of t)wD.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},W2=class extends _2{constructor(){super(),this.outputQueue=new N2,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},V2=class extends W2{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=wD.getTensorsInContainer(e.value),n=this.transform(e.value),r=wD.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)wD.isTensorInList(a,r)||a.dispose();return!0}},U2=class extends _2{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(A2||(A2={}));var j2=class extends _2{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A2.FAIL;super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;let r=await w2(this.iterators,(function(e){return e instanceof _2?{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}:{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case A2.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case A2.SHORTEST:return{value:null,done:!0};case A2.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},G2=class extends _2{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new C2(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},H2=class extends G2{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=g2.alea(n||ER.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},q2=class{constructor(){this.size=null}batch(e){let t,n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=this;return ER.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),t=this.size===1/0||null==this.size?this.size:n?Math.ceil(this.size/e):Math.floor(this.size/e),K2((async()=>(await r.iterator()).columnMajorBatch(e,n,Q2)),t)}concatenate(e){let t,n=this;return t=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,K2((async()=>(await n.iterator()).concatenate(await e.iterator())),t)}filter(e){let t,n=this;return t=this.size===1/0?1/0:null,K2((async()=>(await n.iterator()).filter((t=>cM((()=>e(t)))))),t)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return K2((async()=>(await t.iterator()).map((t=>cM((()=>e(t)))))),this.size)}mapAsync(e){let t=this;return K2((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return K2((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){let t,n=this;return t=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,K2((async()=>function(e,t){return new U2(e,t)}(E2((async()=>({value:await n.iterator(),done:!1}))).take(e))),t)}skip(e){let t,n=this;return t=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,K2((async()=>(await n.iterator()).skip(e)),t)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=m2.alea(t||ER.now().toString());return K2((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){let t,n=this;return t=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,K2((async()=>(await n.iterator()).take(e)),t)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function K2(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends q2{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function X2(e){return K2((async()=>T2(e)),e.length)}function Y2(e){if(!k2(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return K2((async()=>function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A2.FAIL;return new j2(e,t)}(await w2(e,(e=>{if(e instanceof q2)return{value:e.iterator(),recurse:!1};if(k2(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),A2.SHORTEST)),t)}function Q2(e){if(null===e)return null;return function(e){return null==e||function(e){return null===e||"object"!=typeof e&&"function"!=typeof e}(e)||Array.isArray(e)||"object"==typeof e&&e instanceof hD||ER.isTypedArray(e)}(e[0])?{value:J2(e),recurse:!1}:{value:null,recurse:!0}}function J2(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof hD?zz(e):ZD(e)}q2.MAX_BUFFER_SIZE=1e4;var Z2=class extends q2{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}},e3='"',t3=Symbol("out"),n3=Symbol("field"),r3=Symbol("quote"),a3=Symbol("quoteafterquote"),s3=Symbol("quoteinquote"),i3=class extends q2{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&ER.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(ER.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(let r of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(r))throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new Z2(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(ER.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||i){let o=t[a],l=null;if(""===o)if(i&&void 0!==i.default)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let e=Number(o);if(isNaN(e))l=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o)}else l=e}i&&i.isLabel?r[s]=l:n[s]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=[],r=0,a=e.length,s=t3;for(let i=0;i<a;i++)switch(s){case t3:switch(e.charAt(i)){case e3:r=i+1,s=r3;break;case this.delimiter:if(r=i+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=t3;break;default:s=n3,r=i}break;case n3:if(e.charAt(i)===this.delimiter)n.push(e.substring(r,i)),s=t3,r=i+1;break;case r3:if(e.charAt(i)===e3)s=a3;break;case a3:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),s=t3,r=i+1;break;case e3:s=r3;break;default:s=s3}break;case s3:if(e.charAt(i)===e3)s=r3}if(s===a3?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},o3=class e extends _2{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!HE().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new e(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise((r=>{let a=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(ER.sizeFromShape(t));return n.set(e,n.length-e.length),ZD(n,t)}},l3=class e extends _2{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Uz([0],"int32"),this.webcamConfig.centerCrop){let e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,a=n+e,s=t+r;this.cropBox=jz([r,n,s,a],[1,4])}else this.cropBox=jz([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!HE().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new e(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&ER.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=vV.fromPixels(this.webcamVideoElement)}catch(Lye){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(Lye)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(Lye){throw new Error(`Error thrown cropping the video: ${Lye.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return cM((()=>{let t,n=SP(kF(e,"float32"),0);t=AW.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=t.shape;return rO(t,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},u3=class{},c3=class extends _2{split(e){return new d3(this,e)}},d3=class extends c3{constructor(e,t){super(),this.upstream=e,this.impl=new h3(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},h3=class extends W2{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},p3=class extends _2{decodeUTF8(){return new f3(this)}},f3=class extends c3{constructor(e){super(),this.upstream=e,this.impl=new m3(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},m3=class extends W2{constructor(e){if(super(),this.upstream=e,HE().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=PT();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e,t,n=await this.upstream.next();return!n.done&&(e=n.value,t=HE().get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(t),!0)}},g3=class extends p3{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.file=e,this.options=t,ER.assert(e instanceof Uint8Array||!!HE().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise(((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=n=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(a)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n})),done:!1}}};var y3=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function b3(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var v3=class extends u3{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.input=e,this.options=t}async iterator(){if(b3(this.input)&&HE().get("IS_NODE")){let e=LT();this.input=e.readFileSync(this.input.slice(7))}return new g3(this.input,this.options)}},x3=class extends u3{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.url=e,this.fileOptions=t}async iterator(){return b3(this.url)?new v3(this.url,this.fileOptions).iterator():async function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2?arguments[2]:void 0;"string"==typeof e?t=e:(t=e.url,n=y3(e));let s=await(a||ER.fetch)(t,n);if(s.ok){let e=new Uint8Array(await s.arrayBuffer());return new g3(e,r)}throw new Error(s.statusText)}(this.url,this.fileOptions)}};function w3(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new i3(new x3(e),t)}function k3(e){let t=E2(e);return K2((async()=>t))}function S3(e){return K2((async()=>{let t=await e();return E2((()=>t.next()))}))}async function I3(e,t){return l3.create(e,t)}async function C3(e){return o3.create(e)}var N3="4.16.0";function T3(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&ER.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}var E3=uj.whereImpl,A3=class e extends qT{nextDataId(){return e.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new HT(this,oM())}write(e,t,n){this.firstUse&&(this.firstUse=!1,HE().get("IS_NODE")&&rU.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&ER.isString(n[0])){let a=n.map((e=>ER.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return rU.mergeRealAndImagArrays(e,t)}return ER.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>ER.decodeString(e)));return wF(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return wF(e.shape,e.dtype,t)}makeOutput(e,t,n){return oM().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=ER.now();return e(),{kernelMs:ER.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){T3([e],"where");let t=this.readSync(e.dataId);return E3(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};A3.nextDataId=0;var _3={};function $3(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}ST(_3,{addImpl:()=>H3,bincountImpl:()=>Y3,bincountReduceImpl:()=>Q3,bitwiseAndImpl:()=>J3,castImpl:()=>W3,ceilImpl:()=>a4,concatImpl:()=>o4,equalImpl:()=>l4,expImpl:()=>d4,expm1Impl:()=>f4,floorDivImpl:()=>x4,floorImpl:()=>y4,gatherNdImpl:()=>S4,gatherV2Impl:()=>I4,greaterEqualImpl:()=>E4,greaterImpl:()=>C4,lessEqualImpl:()=>M4,lessImpl:()=>$4,linSpaceImpl:()=>P4,logImpl:()=>L4,maxImpl:()=>W4,maximumImpl:()=>V4,minimumImpl:()=>G4,multiplyImpl:()=>K4,negImpl:()=>J4,notEqualImpl:()=>e5,prodImpl:()=>i5,raggedGatherImpl:()=>d5,raggedRangeImpl:()=>p5,raggedTensorToTensorImpl:()=>b5,rangeImpl:()=>v5,rsqrtImpl:()=>x5,scatterImpl:()=>S5,sigmoidImpl:()=>I5,simpleAbsImpl:()=>$3,sliceImpl:()=>T5,sparseFillEmptyRowsImpl:()=>_5,sparseReshapeImpl:()=>$5,sparseSegmentReductionImpl:()=>R5,sqrtImpl:()=>D5,squaredDifferenceImpl:()=>O5,staticRegexReplaceImpl:()=>z5,stridedSliceImpl:()=>V5,stringNGramsImpl:()=>j5,stringSplitImpl:()=>H5,stringToHashBucketFastImpl:()=>q5,subImpl:()=>K5,tileImpl:()=>J5,topKImpl:()=>t6,transposeImpl:()=>r5,uniqueImpl:()=>n6});var R3={kernelName:QE,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend;T3(t,"abs");let r=new Float32Array(ER.sizeFromShape(t.shape));return r=$3(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function D3(e){return(t,n,r,a,s)=>{let i=rU.assertAndGetBroadcastShape(t,n),o=i.length,l=ER.computeStrides(i),u=ER.sizeFromShape(i),c=ER.getTypedArrayFromDType(s,u),d=t.length,h=n.length,p=ER.computeStrides(t),f=ER.computeStrides(n),m=rU.getBroadcastDims(t,i),g=rU.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<c.length;++y){let t=ER.indexToLoc(y,o,l),n=t.slice(-d);m.forEach((e=>n[e]=0));let s=ER.locToIndex(n,d,p),i=t.slice(-h);g.forEach((e=>i[e]=0));let u=ER.locToIndex(i,h,f);c[y]=e(r[s],a[u])}return[c,i]}}function M3(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var F3={kernelName:IA,backendName:"cpu",kernelFunc:M3};function O3(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return M3({inputs:{real:O3(e,t,"float32"),imag:O3(e,t,"float32")},backend:e})}let r=ER.makeZerosTypedArray(ER.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function P3(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var L3={kernelName:p_,backendName:"cpu",kernelFunc:P3};function z3(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var B3={kernelName:d$,backendName:"cpu",kernelFunc:z3};function W3(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){let r=ER.toTypedArray([0],n),[a,s]=D3(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function V3(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return P3({inputs:{x:a},backend:n});let e=O3(n,a.shape,a.dtype),t=V3({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=M3({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=z3({inputs:{input:a},backend:n}),t=V3({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!ER.hasEncodingLoss(a.dtype,s)){let e=P3({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}let i=n.data.get(a.dataId).values,[o,l,u]=W3(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,u)}var U3={kernelName:wA,backendName:"cpu",kernelFunc:V3};function j3(e,t,n,r){return null==n?n=>{let{inputs:a,backend:s}=n,{a:i,b:o}=a,l=s;T3([i,o],e);let u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d="string"===i.dtype?rU.fromUint8ToStringArray(u):u,h="string"===i.dtype?rU.fromUint8ToStringArray(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:e=>{let{inputs:a,backend:s}=e,{a:i,b:o}=a,l=s;if("complex64"===i.dtype||"complex64"===o.dtype){let e=V3({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,s=l.data.get(r.dataId).values,u=l.data.get(a.dataId).values,c=V3({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=l.data.get(h.dataId).values,m=l.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,s,u,f,m),v=l.makeTensorInfo(b,"float32",g),x=l.makeTensorInfo(b,"float32",y),w=M3({inputs:{real:v,imag:x},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(x),w}{let e=l.data.get(i.dataId).values,n=l.data.get(o.dataId).values,a=r||i.dtype,[s,u]=t(i.shape,o.shape,e,n,a);return l.makeTensorInfo(u,a,s)}}}function G3(e){return(t,n,r,a,s,i)=>{let o=rU.assertAndGetBroadcastShape(t,n),l=ER.sizeFromShape(o),u=o.length,c=ER.computeStrides(o),d=ER.getTypedArrayFromDType("float32",l),h=ER.getTypedArrayFromDType("float32",l),p=rU.getBroadcastDims(t,o),f=rU.getBroadcastDims(n,o),m=rU.mergeRealAndImagArrays(r,a),g=rU.mergeRealAndImagArrays(s,i),y=t.length,b=ER.computeStrides(t),v=n.length,x=ER.computeStrides(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){let t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=r.real,h[w]=r.imag}else for(let w=0;w<d.length;w++){let t=ER.indexToLoc(w,u,c),n=t.slice(-y);p.forEach((e=>n[e]=0));let r=ER.locToIndex(n,y,b),a=t.slice(-v);f.forEach((e=>a[e]=0));let s=ER.locToIndex(a,v,x),i=e(m[2*r],m[2*r+1],g[2*s],g[2*s+1]);d[w]=i.real,h[w]=i.imag}return[d,h,o]}}var H3=D3(((e,t)=>e+t)),q3=G3(((e,t,n,r)=>({real:e+n,imag:t+r}))),K3=j3(eA,H3,q3),X3={kernelName:eA,backendName:"cpu",kernelFunc:K3};function Y3(e,t,n,r,a){let s=ER.sizeFromShape(r),i=ER.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=s>0?t[o]:1)}return i}function Q3(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e.shape[0],s=e.shape[1],i=wF([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){let s=e.get(o,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}var J3=D3(((e,t)=>e&t)),Z3=j3(bA,J3),e4={kernelName:bA,backendName:"cpu",kernelFunc:Z3};function t4(e){return(t,n,r)=>{let a=ER.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function n4(e,t,n){return r4(e,t4(t),n)}function r4(e,t,n){return r=>{let{inputs:a,attrs:s,backend:i}=r,{x:o}=a;T3(o,e);let l,u=i,c=u.data.get(o.dataId).values;if("string"===o.dtype){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");l=rU.fromUint8ToStringArray(c)}else l=c;let d=n||o.dtype,h=t(l,d,s);return u.makeTensorInfo(o.shape,d,h)}}var a4=t4((e=>Math.ceil(e))),s4=r4(kA,a4),i4={kernelName:kA,backendName:"cpu",kernelFunc:s4};function o4(e,t,n,r){let a=ER.getArrayFromDType(n,ER.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{let n=ER.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{let s="string"===n?rU.fromUint8ToStringArray(e.vals):e.vals,i=0;for(let n=0;n<e.shape[0];++n){let o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]}))}return a}var l4=D3(((e,t)=>e===t?1:0)),u4=j3(ZA,l4,null,"bool"),c4={kernelName:ZA,backendName:"cpu",kernelFunc:u4},d4=t4((e=>Math.exp(e))),h4=r4(e_,d4,"float32"),p4={kernelName:e_,backendName:"cpu",kernelFunc:h4},f4=t4((e=>Math.expm1(e))),m4=r4(n_,f4),g4={kernelName:n_,backendName:"cpu",kernelFunc:m4},y4=t4((e=>Math.floor(e))),b4=r4(i_,y4),v4={kernelName:i_,backendName:"cpu",kernelFunc:b4},x4=D3(((e,t)=>Math.floor(e/t))),w4=j3(o_,x4,null,"int32"),k4={kernelName:o_,backendName:"cpu",kernelFunc:w4};function S4(e,t,n,r,a,s,i,o,l){let u=wF([r,s],n);for(let c=0;c<r;c++){let n=[],r=0;for(let t=0;t<a;t++){let s=e[c*a+t];r+=s*i[t],n.push(s)}if(r<0||r>=l/s)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<s;e++)u.values[c*s+e]=t.get(...t.indexToLoc(r*s+e))}return u}function I4(e,t,n){let r=wF(n,e.dtype);for(let a=0;a<r.size;++a){let n=r.indexToLoc(a).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];let l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}var C4=D3(((e,t)=>e>t?1:0)),N4=j3(d_,C4,null,"bool"),T4={kernelName:d_,backendName:"cpu",kernelFunc:N4},E4=D3(((e,t)=>e>=t?1:0)),A4=j3(h_,E4,null,"bool"),_4={kernelName:h_,backendName:"cpu",kernelFunc:A4},$4=D3(((e,t)=>e<t?1:0)),R4=j3(x_,$4,null,"bool"),D4={kernelName:x_,backendName:"cpu",kernelFunc:R4},M4=D3(((e,t)=>e<=t?1:0)),F4=j3(w_,M4,null,"bool"),O4={kernelName:w_,backendName:"cpu",kernelFunc:F4};function P4(e,t,n){let r=(t-e)/(n-1),a=ER.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}var L4=t4((e=>Math.log(e))),z4=r4(S_,L4),B4={kernelName:S_,backendName:"cpu",kernelFunc:z4};function W4(e,t,n,r){let a=ER.getTypedArrayFromDType(r,ER.sizeFromShape(n));for(let s=0;s<a.length;++s){let n=s*t,r=e[n];for(let a=0;a<t;++a){let t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[s]=r}return a}var V4=D3(((e,t)=>Math.max(e,t))),U4=j3(F_,V4),j4={kernelName:F_,backendName:"cpu",kernelFunc:U4},G4=D3(((e,t)=>Math.min(e,t))),H4=j3(U_,G4),q4={kernelName:U_,backendName:"cpu",kernelFunc:H4},K4=D3(((e,t)=>e*t)),X4=G3(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),Y4=j3(q_,K4,X4),Q4={kernelName:q_,backendName:"cpu",kernelFunc:Y4};function J4(e,t,n){let r=ER.createScalarValue(-1,n);return K4([],t,r,e,n)}var Z4={kernelName:K_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t;T3(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=J4(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}},e5=D3(((e,t)=>e!==t?1:0)),t5=j3(X_,e5,null,"bool"),n5={kernelName:X_,backendName:"cpu",kernelFunc:t5};function r5(e,t,n,r,a){let s=t.length,i=ER.sizeFromShape(t),o=ER.computeStrides(t),l=ER.computeStrides(a),u=ER.getTypedArrayFromDType(n,ER.sizeFromShape(a));for(let c=0;c<i;++c){let t=ER.indexToLoc(c,s,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[ER.locToIndex(n,s,l)]=e[c]}return u}function a5(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;T3(a,"transpose");let i=a.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=a.shape[s[u]];let l=r5(r.data.get(a.dataId).values,a.shape,a.dtype,s,o);return{dataId:r.write(l,o,a.dtype),shape:o,dtype:a.dtype}}var s5={kernelName:rR,backendName:"cpu",kernelFunc:a5};function i5(e,t,n,r){let[a,s]=rU.computeOutAndReduceShapes(e,r),i=SD(t,"int32"),o=ER.makeZerosTypedArray(ER.sizeFromShape(a),i),l=ER.sizeFromShape(s);for(let u=0;u<o.length;++u){let e=u*l,t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:a,outDtype:i}}var o5={kernelName:i$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;T3(a,"prod");let o=a.shape.length,l=ER.parseAxisParam(s,a.shape),u=rU.getAxesPermutation(l,o),c=l,d=a,h=[];null!=u&&(d=a5({inputs:{x:a},backend:n,attrs:{perm:u}}),h.push(d),c=rU.getInnerMostAxes(c.length,o));let p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=i5(d.shape,d.dtype,p,c),y=m;return i&&(y=rU.expandShapeToKeepDim(m,l)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function l5(e,t,n,r){let a=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){let a=n[e],s=e+t.length-1;if(s>=0){let e=o[s],t=e[e.length-1]-a[r];for(let n=r;n<i;++n)o[s].push(a[n+1]+t)}r=a[r],i=a[i]}i!==r&&(a.push([r,i]),s+=i-r)}return{outSplits:o,valueSlices:a,numValues:s}}function u5(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function c5(e,t,n,r,a){let s=t.slice();s[0]=a;let i=ER.getArrayFromDType(n,ER.sizeFromShape(s)),o=e.length;return function(e,t,n,r,a,s){let i=u5(t,2)[1],o=u5(s,2)[1],l=0;for(let u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)a[l*o+n]=e[t*i+n];++l}}(e,t,r,0===o?0:o/t[0],i,s),[i,s]}function d5(e,t,n,r,a,s,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){let a=ER.indexToLoc(r,t.length,ER.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(s,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");let l=r[0],{outSplits:u,valueSlices:c,numValues:d}=l5(s,i,e,l),h=function(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=ER.getArrayFromDType("int32",r);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(u),p=c5(n,r,a,c,d);return[h,p[0],p[1]]}var h5=2147483647;function p5(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=0===t.length,l=0===a.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(a[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");let d=0===c.length?1:c[0],h=ER.getArrayFromDType("int32",d+1);h[0]=0;for(let g=0;g<d;++g){let t,n=o?e[0]:e[g],a=l?r[0]:r[g],i=u?s[0]:s[g];if(0===i)throw new Error("Requires delta != 0");if(i>0&&a<n||i<0&&a>n)t=0;else if(t=Math.ceil(Math.abs((a-n)/i)),t>h5)throw new Error(`Requires ((limit - start) / delta) <= ${h5}`);h[g+1]=h[g]+t}let p=h[d],f=ER.getArrayFromDType(n,p),m=0;for(let g=0;g<d;++g){let t=h[g+1]-h[g],n=o?e[0]:e[g],r=u?s[0]:s[g];for(let e=0;e<t;++e)f[m++]=n,n+=r}return[h,f]}var f5=rU.RowPartitionType,m5=class e{constructor(e,t,n,r,a,s,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=rU.getRowPartitionTypesHelper(u),this.raggedRank=rU.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===f5.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===f5.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case f5.VALUE_ROWIDS:return e.getMaxWidthValueRowID(n);case f5.ROW_SPLITS:return e.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${f5[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){let t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){let t=e[s];t!==r&&(r=t,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return y5(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;rU.validateDefaultValueShape(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=rU.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let s=1;s<=this.raggedRank;++s)a[s]<0&&(a[s]=this.getMaxWidth(s));return a}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),a=[],s=0;for(let i=0;i<r;++i,s+=t)a.push(s);for(let i=r;i<e;++i)a.push(-1);return ER.assert(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){let a=e.length,s=[];for(let i=0;i<a-1;++i){let a=e[i+1]-e[i],o=Math.min(r,a),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)s.push(l),l+=n;for(let e=0;e<a-o;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){let a=e.length,s=[];if(0===a)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let u=1;u<a;++u){let a=e[u];if(a===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}s.push(l)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){let a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case f5.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case f5.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${f5[s]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case f5.FIRST_DIM_SIZE:return e[0];case f5.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case f5.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${f5[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];let r=y5(t,!1),a=ER.getArrayFromDType(this.valuesDType,ER.sizeFromShape(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)s=this.calculateOutputIndex(e-1,s,n[e],t[e]);this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;let a=this.values,s=n,i=r.slice();i=i.slice(e+1);let o=ER.sizeFromShape(i),l=t.length,u=this.defaultValue;if(u.length!==o&&1!==u.length){let e=this.defaultValueShape;cM((()=>{let t=rO(u,e);u=wO(t,i).dataSync()}))}let c=0,d=0,h=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==h){if(d<h){let e=a.subarray(c*o);g5(s.subarray(d*o),e,(h-d)*o)}if(p>=l){let t=n.length;e=Math.floor(t/o)}if(e>h)if(1===this.defaultValue.length)s.subarray(h*o,e*o).fill(this.defaultValue[0]),h=e;else for(;e>h;){g5(s.slice(h*o),u,o),++h}e<0?(c=p+1,d=h):(c=p,d=h,h=d+1)}else++h}}};function g5(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function y5(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function b5(e,t,n,r,a,s,i,o,l,u){return new m5(e,t,n,r,a,s,i,o,l,u).compute()}function v5(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return ER.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((t-e)/n)),s=ER.makeZerosTypedArray(a,r);t<e&&1===n&&(n=-1),s[0]=e;for(let i=1;i<s.length;i++)s[i]=s[i-1]+n;return s}var x5=t4((e=>1/Math.sqrt(e))),w5=r4(k$,x5),k5={kernelName:k$,backendName:"cpu",kernelFunc:w5};function S5(e,t,n,r,a,s,i,o,l,u){let c=[r/a,a],d=e.values,h=t.values;if(0===r)return wF(n,t.dtype);let p=l instanceof uD?l:wF(c,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let f=0;f<s;f++){let e=[],s=0;for(let t=0;t<i;t++){let n=d[f*i+t];e.push(n),s+=n*o[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?p.values[s*a+n]+=h[f*a+n]:p.values[s*a+n]=0===t.rank?h[0]:h[f*a+n]}return p}var I5=t4((e=>1/(1+Math.exp(-e)))),C5=n4(R$,(e=>1/(1+Math.exp(-e)))),N5={kernelName:R$,backendName:"cpu",kernelFunc:C5};function T5(e,t,n,r,a){let s=$V.isSliceContinous(r,t,n),i=ER.sizeFromShape(n),o=ER.computeStrides(r);if(s){let n=$V.computeFlatOffset(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}let l=wF(r,a,"string"===a?rU.fromUint8ToStringArray(e):e),u=wF(n,a);for(let c=0;c<u.size;++c){let e=u.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===a?rU.fromStringArrayToUint8(u.values):u.values}function E5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;T3(a,"slice");let[o,l]=$V.parseSliceParams(a,s,i);$V.assertParamsValid(a,o,l);let u=T5(n.data.get(a.dataId).values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var A5={kernelName:E$,backendName:"cpu",kernelFunc:E5};function _5(e,t,n,r,a,s,i){let o=t[0],l=s[0],u=new Array(l),c=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(rU.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[ER.getArrayFromDType(n,0),[0,d],ER.getArrayFromDType(a,0),u,c]}let h=!0,p=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let t=e[g*d];if(t<0)throw new Error(rU.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,t));if(t>=l)throw new Error(rU.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,t,l));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<l;++g){let e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){let t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,d],n,u,c]}{let t=f[l-1],s=ER.getArrayFromDType(n,t*d),h=ER.getArrayFromDType(a,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){let t=e[n*d],a=p[t],i=(0===t?0:f[t-1])+a;p[t]++;for(let r=0;r<d;++r)s[i*d+r]=e[n*d+r];h[i]=r[n],c[n]=i}for(let e=0;e<l;++e)if(0===p[e]){let t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;h[t]=i}return[s,[t,d],h,u,c]}}function $5(e,t,n,r,a){let s=ER.sizeFromShape(r),i=t[0],o=a.length,l=[],u=1,c=-1;for(let m=0;m<o;++m){let e=a[m];if(-1===e){if(-1!==c)throw new Error(rU.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,m));c=m,l.push(1)}else{if(e<0)throw new Error(rU.getSparseReshapeNegativeOutputDimErrorMessage(m,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error(rU.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(s/u);if(u*e!==s)throw new Error(rU.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=e}if(ER.sizeFromShape(l)!==s)throw new Error(rU.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}let p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}let f=ER.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],l]}function R5(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?a[o-1]+1:0;if(c<0)throw new Error(rU.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=c;let h=d.reduce(((e,t)=>e*t),1),p=ER.getArrayFromDType(n,h);if(0===o)return c>0&&p.fill(i),[p,d];if(c<=0)throw new Error(rU.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let t=0;if(m<o){if(t=a[m],y===t){++m;continue}if(y>=t)throw new Error(rU.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=c)throw new Error(rU.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,c));y>g&&p.fill(i,g*u,y*u);for(let n=f;n<m;++n){let t=r[n];if(t<0||t>=l[0])throw new Error(rU.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,r[n],l[0]));for(let n=0;n<u;n++)p[y*u+n]+=e[t*u+n]}if(s)for(let e=0;e<u;e++)p[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<c&&p.fill(i,g*u,c*u),[p,d]}var D5=t4((e=>Math.sqrt(e))),M5=n4(M$,(e=>Math.sqrt(e))),F5={kernelName:M$,backendName:"cpu",kernelFunc:M5},O5=D3(((e,t)=>{let n=e-t;return n*n})),P5=j3(j$,O5),L5={kernelName:j$,backendName:"cpu",kernelFunc:P5},z5=t4(((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),B5=r4(H$,z5),W5={kernelName:H$,backendName:"cpu",kernelFunc:B5};function V5(e,t,n,r){let a=wF(e,t.dtype);for(let s=0;s<a.size;s++){let e=a.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}var U5=class{constructor(e,t,n,r,a,s){this.separator=ER.encodeString(e),this.nGramWidths=t,this.leftPad=ER.encodeString(n),this.rightPad=ER.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),c=s-(l+u),d=t+(l>0?0:i-o),h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length,h+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(h);let p=n[r+i],f=0,m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}let a=r-1,s=ER.getArrayFromDType("int32",r);if(0===n||0===r){let e=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[e,s]}s[0]=0;for(let o=1;o<=a;++o){let e=t[o]-t[o-1],n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[o]=s[o-1]+n}let i=new Array(s[a]);for(let o=0;o<a;++o){let n=t[o],r=s[o];if(this.nGramWidths.forEach((a=>{let s=t[o+1]-t[o],l=this.getNumNGrams(s,a);this.createNGrams(e,n,i,r,l,a),r+=l})),this.preserveShort&&r===s[o]){let a=t[o+1]-t[o];if(0===a)continue;let s=a+2*this.padWidth;this.createNGrams(e,n,i,r,1,s)}}return[i,s]}};function j5(e,t,n,r,a,s,i,o){return new U5(n,r,a,s,i,o).compute(e,t)}function G5(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],s=e.indexOf(a);for(;-1!==s;){let t=e.subarray(0,s);(!n||0!==t.length)&&r.push(t),s=(e=e.subarray(s+1)).indexOf(a)}return void((!n||0!==e.length)&&r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){let t=e.subarray(a,s);(!n||0!==t.length)&&r.push(t),a=s+1}}function H5(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let h=0;h<r;++h){let r=a.length;G5(e[h],t,n,a);let l=a.length-r;o[h]=l,s+=l,i=Math.max(i,l)}let l=ER.getArrayFromDType("int32",2*s),u=new Array(s),c=[r,i],d=0;for(let h=0;h<r;++h)for(let e=0;e<o[h];++e)l[2*d]=h,l[2*d+1]=e,u[d]=a[d],++d;return[l,u,c]}function q5(e,t){let n=ER.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=ER.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var K5=D3(((e,t)=>e-t)),X5=G3(((e,t,n,r)=>({real:e-n,imag:t-r}))),Y5=j3(Q$,K5,X5),Q5={kernelName:Q$,backendName:"cpu",kernelFunc:Y5};function J5(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=wF(n,e.dtype);for(let a=0;a<r.values.length;++a){let t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];let s=e.locToIndex(n);r.values[a]=e.values[s]}return r}var Z5=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function e6(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){let a=r-n+1,s=t-n+1,i=Math.log(a),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(a-o)/a)*Math.sign(s-a/2);e6(e,t,Math.max(n,Math.floor(t-s*o/a+l)),Math.min(r,Math.floor(t+(a-s)*o/a+l)))}let a=e[t],s=n,i=r;for(ER.swap(e,n,t),Z5(e[r],a)>0&&ER.swap(e,n,r);s<i;){for(ER.swap(e,s,i),s++,i--;Z5(e[s],a)<0;)s+=1;for(;Z5(e[i],a)>0;)i-=1}0===Z5(e[n],a)?ER.swap(e,n,i):(i+=1,ER.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function t6(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=ER.getTypedArrayFromDType(n,i*r),u=ER.getTypedArrayFromDType("int32",i*r);for(let d=0;d<i;d++){let t=d*o,n=e.subarray(t,t+o),s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(e6(s,r),s=s.slice(0,r)),a&&s.sort(Z5);let i=d*r,c=l.subarray(i,i+r),h=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=s[e].value,h[e]=s[e].index}let c=t.slice();return c[c.length-1]=r,[wF(c,n,l),wF(c,"int32",u)]}function n6(e,t,n,r){let a=ER.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];let i=new Map,o=new Int32Array(n[a]),l=new uD(s,r,e),u=[],c=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let t;if(c)t=e[f].toString();else{let e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(l.get(t,f,n));t=e.join(",")}let n=i.get(t);if(null!=n)o[f]=n;else{let e=i.size;i.set(t,e),o[f]=e,u.push(f)}}let d=s.slice();d[1]=i.size;let h=new uD(d,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)h.set(l.get(n,e,r),n,t,r)}));let p=n.slice();return p[a]=d[1],{outputValues:h.values,outputShape:p,indices:o}}var r6="4.16.0";xM("cpu",(()=>new A3),1);var a6=n4(YA,(e=>e>=0?e:Math.exp(e)-1)),s6={kernelName:YA,backendName:"cpu",kernelFunc:a6};function i6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;T3([a],"leakyRelu");let i=ER.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=ER.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}var o6={kernelName:v_,backendName:"cpu",kernelFunc:i6},l6=D3(((e,t)=>e<0?t*e:e));function u6(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;T3([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=l6(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var c6={kernelName:s$,backendName:"cpu",kernelFunc:u6},d6=n4(p$,(e=>Math.max(0,e))),h6={kernelName:p$,backendName:"cpu",kernelFunc:d6},p6=n4(v$,(e=>Math.min(Math.max(0,e),6))),f6={kernelName:v$,backendName:"cpu",kernelFunc:p6};function m6(e,t,n,r,a){if("linear"===n)return P3({inputs:{x:t},backend:e});if("relu"===n)return d6({inputs:{x:t},backend:e});if("elu"===n)return a6({inputs:{x:t},backend:e});if("relu6"===n)return p6({inputs:{x:t},backend:e});if("prelu"===n)return u6({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return i6({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return C5({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function g6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=ER.sizeFromShape(a.shape),o=ER.inferFromImplicitShape(s,i),l=ER.sizeFromShape(o);ER.assert(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){let e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var y6={kernelName:f$,backendName:"cpu",kernelFunc:g6};function b6(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;T3([a,s],"matMul");let l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=ER.sizeFromShape(f),y=ER.sizeFromShape(m),b=GO.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);ER.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let v=o?[y,p,d]:[y,d,p],x=g6({inputs:{x:a},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=g6({inputs:{x:s},backend:n,attrs:{shape:v}}),k=i?x.shape[1]:x.shape[2],S=i?x.shape[2]:x.shape[1],I=o?w.shape[1]:w.shape[2],C=Math.max(g,y),N=n.data.get(x.dataId).values,T=n.data.get(w.dataId).values,E=ER.computeStrides(x.shape),A=ER.computeStrides(w.shape),[_,$,R]=i?[E[0],1,E[1]]:[E[0],E[1],1],[D,M,F]=o?[1,A[1],A[0]]:[A[1],1,A[0]],O=S*I,P=wF([C,S,I],x.dtype),L=P.values,z=n.blockSize;for(let B=0;B<C;B++){let e=B%g,t=B%y;for(let n=0;n<S;n+=z){let r=Math.min(n+z,S);for(let a=0;a<I;a+=z){let s=Math.min(a+z,I);for(let i=0;i<k;i+=z){let o=Math.min(i+z,k);for(let l=n;l<r;l++)for(let n=a;n<s;n++){let r=0;for(let a=i;a<o;a++){r+=N[e*_+l*$+a*R]*T[a*D+n*M+t*F]}L[B*O+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,P.dtype,P.values)}var v6={kernelName:mA,backendName:"cpu",kernelFunc:b6};var x6={kernelName:hR,backendName:"cpu",kernelFunc:function(e){let t,n,r,{inputs:a,backend:s,attrs:i}=e,{a:o,b:l,bias:u,preluActivationWeights:c}=a,{transposeA:d,transposeB:h,activation:p,leakyreluAlpha:f}=i,m=[];t=b6({inputs:{a:o,b:l},attrs:{transposeA:d,transposeB:h},backend:s}),u&&(n=K3({inputs:{a:t,b:u},backend:s}),m.push(t),t=n),p&&(r=m6(s,t,p,c,f),m.push(t),t=r);for(let g of m)s.disposeIntermediateTensorInfo(g);return t}},w6=n4(JE,(e=>Math.acos(e))),k6={kernelName:JE,backendName:"cpu",kernelFunc:w6},S6=n4(ZE,(e=>Math.acosh(e))),I6={kernelName:ZE,backendName:"cpu",kernelFunc:S6};var C6={kernelName:tA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,r=t;T3(t,"addN");let a=r.map((e=>n.data.get(e.dataId).values)),s=wF(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){let e=a[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};var N6={kernelName:nA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;T3(a,"all");let o=ER.parseAxisParam(s,a.shape),l=o,u=rU.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=a5({inputs:{x:a},backend:n,attrs:{perm:u}}),l=rU.getInnerMostAxes(l.length,a.shape.length)),rU.assertAxesAreInnerMostDims("all",l,c.shape.length);let[d,h]=rU.computeOutAndReduceShapes(c.shape,l),p=ER.sizeFromShape(h),f=ER.makeZerosTypedArray(ER.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*p,t=m[e];for(let n=0;n<p;++n){let r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let e=g6({inputs:{x:g},backend:n,attrs:{shape:rU.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var T6={kernelName:rA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;T3(a,"any");let o=ER.parseAxisParam(s,a.shape),l=o,u=rU.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=a5({inputs:{x:a},backend:n,attrs:{perm:u}}),l=rU.getInnerMostAxes(l.length,a.shape.length)),rU.assertAxesAreInnerMostDims("any",l,c.shape.length);let[d,h]=rU.computeOutAndReduceShapes(c.shape,l),p=ER.sizeFromShape(h),f=ER.makeZerosTypedArray(ER.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*p,t=m[e];for(let n=0;n<p;++n){let r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let e=g6({inputs:{x:g},backend:n,attrs:{shape:rU.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var E6={kernelName:aA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;T3(a,"argMax");let i=ER.parseAxisParam(s,a.shape),o=rU.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=a5({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=rU.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],rU.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,d]=rU.computeOutAndReduceShapes(l.shape,i),h=ER.sizeFromShape(c),p=ER.makeZerosTypedArray(h,"int32"),f=ER.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a>t&&(t=a,n=r)}p[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}};var A6={kernelName:sA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;T3(a,"argMin");let i=ER.parseAxisParam(s,a.shape),o=rU.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=a5({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=rU.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],rU.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,d]=rU.computeOutAndReduceShapes(l.shape,i),h=ER.sizeFromShape(c),p=ER.makeZerosTypedArray(h,"int32"),f=ER.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a<t&&(t=a,n=r)}p[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}},_6=n4(iA,(e=>Math.asin(e))),$6={kernelName:iA,backendName:"cpu",kernelFunc:_6},R6=n4(oA,(e=>Math.asinh(e))),D6={kernelName:oA,backendName:"cpu",kernelFunc:R6},M6=n4(lA,(e=>Math.atan(e))),F6={kernelName:lA,backendName:"cpu",kernelFunc:M6},O6=D3(((e,t)=>Math.atan2(e,t))),P6=j3(cA,O6),L6={kernelName:cA,backendName:"cpu",kernelFunc:P6},z6=n4(uA,(e=>Math.atanh(e))),B6={kernelName:uA,backendName:"cpu",kernelFunc:z6};function W6(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,c=a.effectiveFilterHeight,d=a.effectiveFilterWidth,h=a.padInfo.top,p=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=wF(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let x=0;x<a.batchSize;++x){let t=x*y,n=x*r[0];for(let m=0;m<a.inChannels;++m)for(let y=0;y<a.outHeight;++y){let x=y*i-h,w=Math.max(0,x),k=Math.min(a.inHeight,c+x),S=t+y*b;for(let t=0;t<a.outWidth;++t){let i=t*o-p,c=Math.max(0,i),h=Math.min(a.inWidth,d+i),y=f,b=0,x=0;for(let t=w;t<k;t+=l){let a=n+t*r[1];for(let t=c;t<h;t+=u){let n=e[a+t*r[2]+m];"max"===s&&n>y?y=n:"avg"===s&&(b+=n,x++)}if(isNaN(y))break}g[S+t*v+m]="avg"===s?b/x:y}}}return m}function V6(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=wF(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=wF(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){let n=t*o-p,y=n;for(;y<0;)y+=u;let b=Math.min(r.inHeight,d+n);for(let o=0;o<r.outWidth;++o){let d=o*l-f,p=d;for(;p<0;)p+=c;let v=Math.min(r.inWidth,h+d),x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=u){let i=t-n;for(let n=p;n<v;n+=c){let o=n-d,l=m.get(g,t,n,e);l>x&&(x=l,w=a?s?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*h+o)}}i.set(w,g,t,o,e)}}return i}function U6(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,c=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=wF(a.outShape,n),x=v.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let C=0;C<a.batchSize;++C){let t=C*w,n=C*r[0];for(let v=0;v<a.inChannels;++v)for(let w=0;w<a.outDepth;++w){let C=w*i-m,N=C;for(;N<0;)N+=u;let T=Math.min(a.inDepth,h+C),E=t+w*k;for(let t=0;t<a.outHeight;++t){let i=t*o-g,h=i;for(;h<0;)h+=c;let m=Math.min(a.inHeight,p+i),w=E+t*S;for(let t=0;t<a.outWidth;++t){let i=t*l-y,o=i;for(;o<0;)o+=d;let p=Math.min(a.inWidth,f+i),g=w+t*I,k=b,S=0,C=0;for(let t=N;t<T;t+=u){let a=n+t*r[1];for(let t=h;t<m;t+=c){let n=a+t*r[2];for(let t=o;t<p;t+=d){let a=e[n+t*r[3]+v];if("max"===s&&a>k?k=a:"avg"===s&&(S+=a,C++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===s?S/Math.max(C,1):k}}}}return v}var j6={kernelName:dA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;T3(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;ER.assert(rU.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u,c=rU.computePool2DInfo(a.shape,s,i,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&ER.arraysEqual(c.inShape,c.outShape))u=P3({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=ER.computeStrides(a.shape),r=W6(e,a.shape,a.dtype,t,c,"avg");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};var G6={kernelName:pA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;T3(a,"avgPool3d");let c=rU.computePool3DInfo(a.shape,s,i,1,o,l,u),d=U6(n.data.get(a.dataId).values,a.shape,a.dtype,ER.computeStrides(a.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};var H6={kernelName:fA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;T3([a,s],"avgPool3DGrad");let c=rU.computePool3DInfo(s.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=x-1-c.padInfo.front,I=k-1-c.padInfo.left,C=w-1-c.padInfo.top,N=wF(s.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(a);for(let A=0;A<c.batchSize;++A)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){let a=t-S,s=n-C,i=r-I,o=0;for(let t=0;t<x;t+=y){let n=(a+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){let r=(s+t)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){let a=(i+t)/p;a<0||a>=c.outWidth||Math.floor(a)!==a||(o+=E.get(A,n,r,a,e))}}}N.set(o*T,A,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};var q6={kernelName:hA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;T3([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=rU.computePool2DInfo(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=wF(i.shape,"float32"),k=1/(p*f),S=n.data.get(a.dataId).values,I=wF(a.shape,"float32",S);for(let C=0;C<c.batchSize;++C)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){let r=t-x,a=n-v,s=0;for(let t=0;t<y;t+=m){let n=(r+t)/d;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){let r=(a+t)/h;r<0||r>=c.outWidth||Math.floor(r)!==r||(s+=I.get(C,n,r,e))}}w.set(s*k,C,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};var K6={kernelName:l_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;ER.assert(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),ER.assert(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),ER.assert(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),T3([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);let c=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,v=d.length,x=0,w=0,k=0,S=0;for(let I=0;I<c.length;++I)m[I]=f[x++]+(c[I]-d[w++])*p[k++]/Math.sqrt(h[S++]+u),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,m)}};var X6={kernelName:gA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;T3([a],"batchToSpaceND");let o=s.reduce(((e,t)=>e*t)),l=rU.getReshaped(a.shape,s,o),u=rU.getPermuted(l.length,s.length),c=rU.getReshapedPermuted(a.shape,s,o),d=rU.getSliceBeginCoords(i,s.length),h=rU.getSliceSize(c,i,s.length),p=g6({inputs:{x:a},backend:n,attrs:{shape:l}}),f=a5({inputs:{x:p},backend:n,attrs:{perm:u}}),m=g6({inputs:{x:f},backend:n,attrs:{shape:c}}),g=E5({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};var Y6={kernelName:yA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=Y3(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}};var Q6={kernelName:xA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=rU.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},J6=n4(SA,((e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),Z6={kernelName:SA,backendName:"cpu",kernelFunc:J6},e8={kernelName:CA,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(ER.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function t8(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var n8={kernelName:m_,backendName:"cpu",kernelFunc:t8};function r8(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=ER.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));rU.assertParamsConsistent(i,s);let o=rU.computeOutShape(t.map((e=>e.shape)),s);if(0===ER.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>ER.sizeFromShape(e.shape)>0));if(1===l.length)return P3({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){let e=l.map((e=>z3({inputs:{input:e},backend:n}))),t=l.map((e=>t8({inputs:{input:e},backend:n}))),r=r8({inputs:e,backend:n,attrs:{axis:s}}),a=r8({inputs:t,backend:n,attrs:{axis:s}}),i=M3({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}let u=l.map((e=>{let t=[-1,ER.sizeFromShape(e.shape.slice(s))];return g6({inputs:{x:e},backend:n,attrs:{shape:t}})})),c=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=rU.computeOutShape(u.map((e=>e.shape)),1);let d=1===u[0].shape[0],h=o4(c,o,t[0].dtype,d),p=rU.computeOutShape(l.map((e=>e.shape)),s),f=n.makeTensorInfo(p,t[0].dtype,h);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var a8={kernelName:NA,backendName:"cpu",kernelFunc:r8};function s8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;T3([a,s],"conv2d");let d=rU.convertConv2DDataFormat(l),h=rU.computeConv2DInfo(a.shape,s.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new uD(h.outShape,a.dtype),w=ER.computeStrides(a.shape),k=ER.computeStrides(s.shape),S=w[0],I=v?w[1]:w[2],C=v?w[2]:1,N=v?1:w[1],T=x.strides[0],E=v?x.strides[1]:x.strides[2],A=v?x.strides[2]:1,_=v?1:x.strides[1],$=n.data.get(a.dataId).values,R=n.data.get(s.dataId).values,D=x.values;for(let M=0;M<h.batchSize;++M){let e=M*S,t=M*T;for(let n=0;n<h.outHeight;++n){let r=t+n*E,a=n*h.strideHeight-b;for(let t=0;t<p;++t){let n=a+t*m;if(n<0||n>=h.inHeight)continue;let s=t*k[0],i=e+n*I;for(let e=0;e<h.outWidth;++e){let t=r+e*A,n=e*h.strideWidth-y;for(let e=0;e<f;++e){let r=n+e*g;if(r<0||r>=h.inWidth)continue;let a=i+r*C,o=s+e*k[1];for(let e=0;e<h.inChannels;++e){let n=$[a+e*N];for(let e=0;e<h.outChannels;++e)D[t+e*_]+=n*R[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,D)}var i8={kernelName:TA,backendName:"cpu",kernelFunc:s8};var o8={kernelName:EA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;T3([a,s],"conv2dBackpropFilter");let d=rU.convertConv2DDataFormat(l),h=rU.computeConv2DInfo(a.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new uD(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=new uD(a.shape,a.dtype,w),I=new uD(s.shape,s.dtype,k);for(let C=0;C<m;++C){let e=Math.max(0,Math.ceil((x-C)/p)),t=Math.min(h.outHeight,(h.inHeight+x-C)/p);for(let n=0;n<g;++n){let r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(h.outWidth,(h.inWidth+v-n)/f);for(let s=0;s<h.inChannels;++s)for(let i=0;i<h.outChannels;++i){let o=0;for(let l=0;l<h.batchSize;++l)for(let u=e;u<t;++u){let e=C+u*p-x;for(let t=r;t<a;++t){let r=n+t*f-v;o+=y?S.get(l,e,r,s)*I.get(l,u,t,i):S.get(l,s,e,r)*I.get(l,i,u,t)}}b.set(o,C,n,s,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var l8={kernelName:AA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;T3([a,s],"conv2dBackpropInput");let d=ER.computeStrides(s.shape),h=ER.computeStrides(a.shape),p=rU.convertConv2DDataFormat(u),f=rU.computeConv2DInfo(i,s.shape,o,1,l,c,!1,p),m=new uD(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[v,x,w]=d,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:C,inHeight:N,inWidth:T,outChannels:E,outHeight:A,outWidth:_,strideHeight:$,strideWidth:R}=f;p=f.dataFormat;let D=S-1-f.padInfo.top,M=I-1-f.padInfo.left,F="channelsLast"===p,O=m.strides[0],P=F?m.strides[1]:m.strides[2],L=F?m.strides[2]:1,z=F?1:m.strides[1],B=h[0],W=F?h[1]:h[2],V=F?h[2]:1,U=F?1:h[1];for(let j=0;j<k;++j)for(let e=0;e<C;++e)for(let t=0;t<N;++t){let n=t-D,r=Math.max(0,Math.ceil(n/$)),a=Math.min(A,(S+n)/$);for(let s=0;s<T;++s){let i=s-M,o=Math.max(0,Math.ceil(i/R)),l=Math.min(_,(I+i)/R),u=0;for(let t=r;t<a;++t){let r=t*$-n;for(let n=o;n<l;++n){let a=B*j+W*t+V*n,s=v*(S-1-r)+x*(I-1-(n*R-i))+w*e;for(let e=0;e<E;++e){u+=y[a+U*e]*b[s+e]}}}g[O*j+P*t+L*s+z*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};var u8={kernelName:_A,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;T3([a,s],"conv3d");let u=rU.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new uD(u.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=x.values,I=ER.computeStrides(a.shape),C=ER.computeStrides(s.shape);for(let N=0;N<u.batchSize;++N){let e=N*I[0],t=N*x.strides[0];for(let n=0;n<u.outDepth;++n){let r=t+n*x.strides[1],a=n*u.strideDepth-y;for(let t=0;t<c;++t){let n=a+t*p;if(n<0||n>=u.inDepth)continue;let s=t*C[0],i=e+n*I[1];for(let e=0;e<u.outHeight;++e){let t=r+e*x.strides[2],n=e*u.strideHeight-v;for(let e=0;e<d;++e){let r=n+e*f;if(r<0||r>=u.inHeight)continue;let a=s+e*C[1],o=i+r*I[2];for(let e=0;e<u.outWidth;++e){let n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<h;++e){let t=r+e*m;if(t<0||t>=u.inWidth)continue;let s=a+e*C[2],i=o+t*u.inChannels,l=s;for(let e=0;e<u.inChannels;++e){let t=w[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};var c8={kernelName:$A,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;T3([a,s],"conv3dBackpropFilterV2");let u=ER.computeStrides(a.shape),c=ER.computeStrides(s.shape),d=rU.computeConv3DInfo(a.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new uD(d.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,I=n.data.get(s.dataId).values,[C,N,T,E]=c,A=n.data.get(a.dataId).values,[_,$,R,D]=u,M=d.padInfo.front,F=d.padInfo.left,O=d.padInfo.top;for(let P=0;P<m;++P){let e=Math.max(0,Math.ceil((M-P)/h)),t=Math.min(d.outDepth,(d.inDepth+M-P)/h),n=P*x;for(let r=0;r<g;++r){let a=Math.max(0,Math.ceil((O-r)/p)),s=Math.min(d.outHeight,(d.inHeight+O-r)/p),i=r*w+n;for(let n=0;n<y;++n){let o=Math.max(0,Math.ceil((F-n)/f)),l=Math.min(d.outWidth,(d.inWidth+F-n)/f),u=n*k+i;for(let i=0;i<d.inChannels;++i){let c=i*S+u;for(let u=0;u<d.outChannels;++u){let m=0;for(let c=0;c<d.batchSize;++c){let d=c*_,g=c*C;for(let c=e;c<t;++c){let e=(P+c*h-M)*$+d,t=c*N+g;for(let c=a;c<s;++c){let a=(r+c*p-O)*R+e,s=c*T+t;for(let e=o;e<l;++e){let t=e*E+s;m+=A[(n+e*f-F)*D+a+i]*I[t+u]}}}}v[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var d8={kernelName:RA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;T3([a],"conv3dBackpropInputV2");let u=ER.computeStrides(a.shape),c=ER.computeStrides(s.shape),d=rU.computeConv3DInfo(l,s.shape,o,1,i),h=new uD(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(a.dataId).values,[v,x,w,k]=u,S=n.data.get(s.dataId).values,[I,C,N,T]=c,{batchSize:E,filterDepth:A,filterHeight:_,filterWidth:$,inChannels:R,inDepth:D,inHeight:M,inWidth:F,outChannels:O,outDepth:P,outHeight:L,outWidth:z,strideDepth:B,strideHeight:W,strideWidth:V}=d,U=A-1-d.padInfo.front,j=_-1-d.padInfo.top,G=$-1-d.padInfo.left;for(let H=0;H<E;++H)for(let e=0;e<R;++e)for(let t=0;t<D;++t){let n=t-U,r=Math.max(0,Math.ceil(n/B)),a=Math.min(P,(A+n)/B);for(let s=0;s<M;++s){let i=s-j,o=Math.max(0,Math.ceil(i/W)),l=Math.min(L,(_+i)/W);for(let u=0;u<F;++u){let c=u-G,d=Math.max(0,Math.ceil(c/V)),h=Math.min(z,($+c)/V),E=0;for(let t=r;t<a;++t){let r=t*B-n;for(let n=o;n<l;++n){let a=n*W-i;for(let s=d;s<h;++s){let i=v*H+x*t+w*n+k*s,o=I*(A-1-r)+C*(_-1-a)+N*($-1-(s*V-c))+T*e;for(let e=0;e<O;++e){E+=b[i+e]*S[o+e]}}}}p[f*H+m*t+g*s+y*u+e]=E}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},h8=n4(DA,(e=>Math.cos(e))),p8={kernelName:DA,backendName:"cpu",kernelFunc:h8},f8=n4(MA,(e=>Math.cosh(e))),m8={kernelName:MA,backendName:"cpu",kernelFunc:f8};var g8={kernelName:PA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=a.shape,f=s.shape[0],[m,g]=o,y=wF([f,m,g,p],"float32"),b=n.data.get(s.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,w=ER.computeStrides(a.shape),k=ER.computeStrides(y.shape);for(let S=0;S<f;S++){let e=4*S,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],s=v[S];if(s>=c)continue;let i=m>1?(r-t)*(d-1)/(m-1):0,o=g>1?(a-n)*(h-1)/(g-1):0;for(let c=0;c<m;c++){let e=m>1?t*(d-1)+c*i:.5*(t+r)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){let n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}else if("bilinear"===l){let t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){let l=g>1?n*(h-1)+e*o:.5*(n+a)*(h-1);if(l<0||l>h-1){for(let t=0;t<p;t++){let n=t+e*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}let d=Math.floor(l),f=Math.ceil(l),m=l-d;for(let n=0;n<p;n++){let a=n+d*w[2]+t*w[1]+s*w[0],o=x[a];a=n+f*w[2]+t*w[1]+s*w[0];let l=x[a];a=n+d*w[2]+r*w[1]+s*w[0];let u=x[a];a=n+f*w[2]+r*w[1]+s*w[0];let h=o+(l-o)*m,p=u+(x[a]-u)*m;a=n+e*k[2]+c*k[1]+S*k[0],y.values[a]=h+(p-h)*i}}}else for(let t=0;t<g;++t){let r=g>1?n*(h-1)+t*o:.5*(n+a)*(h-1);if(r<0||r>h-1){for(let e=0;e<p;e++){let n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}let i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++){let n=e+i*w[2]+l*w[1]+s*w[0],r=e+t*k[2]+c*k[1]+S*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};var y8={kernelName:FA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;T3(a,"cumprod");let l=rU.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=a5({inputs:{x:a},backend:n,attrs:{perm:l}}));let c=rU.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=SD(u.dtype,"int32"),h=ER.makeOnesTypedArray(ER.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)h[t]=i?1:p[t];else{let n=m(y,e-1);h[t]=i?p[n]*h[n]:p[t]*h[n]}}let g=n.makeTensorInfo(u.shape,d,h);if(null!=l){let e=a5({inputs:{x:g},backend:n,attrs:{perm:rU.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};var b8={kernelName:OA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;T3(a,"cumsum");let l=rU.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=a5({inputs:{x:a},backend:n,attrs:{perm:l}}));let c=rU.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=SD(u.dtype,"int32"),h=ER.makeZerosTypedArray(ER.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)h[t]=i?0:p[t];else{let n=m(y,e-1);h[t]=i?p[n]+h[n]:p[t]+h[n]}}let g=n.makeTensorInfo(u.shape,d,h);if(null!=l){let e=a5({inputs:{x:g},backend:n,attrs:{perm:rU.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};var v8={kernelName:LA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=Y3(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){let e=Q3(n.bufferSync(a),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};var x8={kernelName:zA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;ER.assert("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));let o=a.shape[0],l=a.shape[1],u=a.shape[2],c=a.shape[3],d=l*s,h=u*s,p=c/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*d*h*p),g=0;for(let y=0;y<o;++y)for(let e=0;e<d;++e){let t=Math.floor(e/s),n=e%s;for(let e=0;e<h;++e){let r=Math.floor(e/s),a=(n*s+e%s)*p;for(let e=0;e<p;++e){let n=e+a+c*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,d,h,p],a.dtype,m)}};function w8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;T3([a,s],"depthwiseConv2DNative");let c=ER.computeStrides(a.shape),d=ER.computeStrides(s.shape),h=l;null==h&&(h=[1,1]),ER.assert(rU.eitherStridesOrDilationsAreOne(i,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`));let p=rU.computeConv2DInfo(a.shape,s.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new uD(p.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,C=k.values;for(let N=0;N<p.batchSize;++N){let e=N*c[0],t=N*k.strides[0];for(let n=0;n<p.outHeight;++n){let r=t+n*k.strides[1],a=n*p.strideHeight-x;for(let t=0;t<f;++t){let n=a+t*g;if(n<0||n>=p.inHeight)continue;let s=t*d[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){let t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){let r=n+e*y;if(r<0||r>=p.inWidth)continue;let a=s+e*d[1],o=i+r*p.inChannels,l=t,u=a;for(let e=0;e<p.inChannels;++e){let t=S[o+e];for(let e=0;e<w;++e)C[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var k8={kernelName:BA,backendName:"cpu",kernelFunc:w8};var S8={kernelName:WA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;T3([a,s],"depthwiseConv2dNativeBackpropFilter");let d=rU.computeConv2DInfo(a.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new uD(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,x=n.data.get(a.dataId).values,w=new uD(a.shape,a.dtype,x),k=n.data.get(s.dataId).values,S=new uD(s.shape,s.dtype,k);for(let I=0;I<f;++I){let e=Math.max(0,Math.ceil((b-I)/h)),t=Math.min(d.outHeight,(d.inHeight+b-I)/h);for(let n=0;n<m;++n){let r=Math.max(0,Math.ceil((y-n)/p)),a=Math.min(d.outWidth,(d.inWidth+y-n)/p);for(let s=0;s<d.outChannels;++s){let i=Math.trunc(s/v),o=s%v,l=0;for(let u=0;u<d.batchSize;++u)for(let o=e;o<t;++o){let e=I+o*h-b;for(let t=r;t<a;++t){let r=n+t*p-y;l+=w.get(u,e,r,i)*S.get(u,o,t,s)}}g.set(l,I,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};var I8={kernelName:VA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;T3([a,s],"depthwiseConv2DNativeBackpropInput");let d=ER.computeStrides(a.shape),h=ER.computeStrides(s.shape),p=rU.computeConv2DInfo(c,s.shape,i,o,l,u,!0),f=new uD(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(a.dataId).values,[x,w,k]=d,S=n.data.get(s.dataId).values,[I,C,N]=h,{batchSize:T,filterHeight:E,filterWidth:A,inChannels:_,inHeight:$,inWidth:R,outChannels:D,outHeight:M,outWidth:F,strideHeight:O,strideWidth:P}=p,L=E-1-p.padInfo.top,z=A-1-p.padInfo.left,B=D/_;for(let W=0;W<T;++W)for(let e=0;e<_;++e)for(let t=0;t<$;++t){let n=t-L,r=Math.max(0,Math.ceil(n/O)),a=Math.min(M,(E+n)/O);for(let s=0;s<R;++s){let i=s-z,o=Math.max(0,Math.ceil(i/P)),l=Math.min(F,(A+i)/P),u=0;for(let t=r;t<a;++t){let r=t*O-n;for(let n=o;n<l;++n){let a=x*W+w*t+k*n,s=I*(E-1-r)+C*(A-1-(n*P-i))+N*e;for(let t=0;t<B;++t){u+=v[a+(e*B+t)]*S[s+t]}}}m[g*W+y*t+b*s+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};var C8={kernelName:UA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=ER.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=wF([a,a],r.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*a+u]=s[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},N8={kernelName:jA,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=n,c=u.data.get(a.dataId).values,d=a.shape.length,h=u.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:C,dilationWidth:N,outShape:T}=rU.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),E=ER.sizeFromShape(T),A=T.length,_=ER.getArrayFromDType(a.dtype,E);for(let $=0;$<f;++$)for(let e=0;e<b;++e){let t=e*w-x.top;for(let n=0;n<v;++n){let r=n*k-x.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){let n=t+e*C;if(n>=0&&n<m)for(let t=0;t<I;++t){let l=r+t*N;if(l>=0&&l<g){let r=ER.locToIndex([$,n,l,i],d,ER.computeStrides(a.shape)),u=ER.locToIndex([e,t,i],p,ER.computeStrides(s.shape)),f=c[r]+h[u];f>o&&(o=f)}}}_[ER.locToIndex([$,e,n,i],A,ER.computeStrides(T))]=o}}}return{dataId:u.write(ER.toTypedArray(_,a.dtype),T,a.dtype),shape:T,dtype:a.dtype}}},T8={kernelName:HA,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=ER.toNestedArray(a.shape,c.data.get(a.dataId).values),h=ER.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=rU.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u);ER.assert(i.rank===N.length,(()=>`Error in ${HA}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));let T=ER.toNestedArray(N,c.data.get(i.dataId).values),E=ER.makeZerosNestedTypedArray(s.shape,s.dtype);for(let A=0;A<p;++A)for(let e=0;e<y;++e){let t=e*x-v.top;for(let n=0;n<b;++n){let r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){let n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){let l=r+t*C;if(l>=0&&l<m){let r=d[A][n][l][a]+h[e][t][a];r>s&&(s=r,i=e,o=t)}}}E[i][o][a]+=T[A][e][n][a]}}}return{dataId:c.write(ER.toTypedArray(E,a.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},E8={kernelName:GA,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=ER.toNestedArray(a.shape,c.data.get(a.dataId).values),h=ER.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=rU.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u);ER.assert(i.rank===N.length,(()=>`Error in ${GA}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));let T=ER.toNestedArray(N,c.data.get(i.dataId).values),E=ER.makeZerosNestedTypedArray(a.shape,a.dtype);for(let A=0;A<p;++A)for(let e=0;e<y;++e){let t=e*x-v.top;for(let n=0;n<b;++n){let r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<k;++e){let n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){let l=r+t*C;if(l>=0&&l<m){let r=d[A][n][l][a]+h[e][t][a];r>s&&(s=r,i=n,o=l)}}}E[A][i][o][a]+=T[A][e][n][a]}}}return{dataId:c.write(ER.toTypedArray(E,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};var A8={kernelName:qA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null==l?void 0:l.alpha)||1,c=(null==o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let d=s.getContext(c,(null==o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);let[h,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(p*h*4);for(let v=0;v<h*p;++v){let e=[0,0,0,255*u];for(let n=0;n<f;n++){let t=m[v*f+n];if("float32"===a.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===a.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}let t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}s.width=p,s.height=h;let b=new ImageData(y,p,h);return d.putImageData(b,0,0),a}};function _8(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a;T3(s,"sum"),t="bool"===s.dtype?V3({inputs:{x:s},backend:r,attrs:{dtype:"int32"}}):P3({inputs:{x:s},backend:r});let l=t.shape.length,u=ER.parseAxisParam(i,t.shape),c=rU.getAxesPermutation(u,l),d=u,h=t;null!=c&&(h=a5({inputs:{x:t},backend:r,attrs:{perm:c}}),d=rU.getInnerMostAxes(d.length,l)),rU.assertAxesAreInnerMostDims("sum",d,h.shape.length);let[p,f]=rU.computeOutAndReduceShapes(h.shape,d),m=O3(r,p,rU.upcastType(h.dtype,"int32")),g=ER.sizeFromShape(f),y=r.data.get(m.dataId).values,b=r.data.get(h.dataId).values;for(let v=0;v<y.length;++v){let e=v*g,t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(o){let e=m;m=g6({inputs:{x:m},backend:r,attrs:{shape:rU.expandShapeToKeepDim(m.shape,u)}}),r.disposeIntermediateTensorInfo(e)}return r.disposeIntermediateTensorInfo(t),null!=c&&r.disposeIntermediateTensorInfo(h),m}var $8={kernelName:F$,backendName:"cpu",kernelFunc:_8};var R8={kernelName:XA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=rU.decodeEinsumEquation(a,s.length);rU.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=rU.getEinsumComputePath(o,l),d=c.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let e of c[m]){let t,{permutationIndices:r,expandDims:a}=rU.getEinsumPermutation(p,l[e]);rU.isIdentityPermutation(r)?t=s[e]:(t=a5({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);ER.arraysEqual(t.shape,i)||(t=g6({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===h?h=t:(h=Y4({inputs:{a:t,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=_8({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};var D8={kernelName:QA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;T3([r,a],"eluGrad");let s=new Float32Array(ER.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let e=i[l];s[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",s)}},M8=rU.ERF_P,F8=rU.ERF_A1,O8=rU.ERF_A2,P8=rU.ERF_A3,L8=rU.ERF_A4,z8=rU.ERF_A5,B8=n4(JA,(e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+M8*n);return t*(1-((((z8*r+L8)*r+P8)*r+O8)*r+F8)*r*Math.exp(-n*n))})),W8={kernelName:JA,backendName:"cpu",kernelFunc:B8};function V8(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(ER.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),g6({inputs:{x:a},backend:n,attrs:{shape:o}})}var U8={kernelName:t_,backendName:"cpu",kernelFunc:V8},j8=D3(((e,t)=>e/t)),G8=j3(KA,j8),H8={kernelName:KA,backendName:"cpu",kernelFunc:G8};function q8(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],c=ER.sizeFromShape(u),d=ER.getTypedArrayFromDType("float32",c),h=ER.getTypedArrayFromDType("float32",c);for(let g=0;g<a;g++){let e=E5({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=E5({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=M3({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=K8(a,t,n),c=rU.mergeRealAndImagArrays(i,u);for(let t=0;t<s;t++){let e=rU.getComplexWithIndex(c,t);d[g*s+t]=e.real,h[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}let p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=M3({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function K8(e,t,n){let r=ER.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(function(e){return 0===(e&e-1)}(r)){let a=X8(s,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),s=n.makeTensorInfo([],"float32",ER.createScalarValue(r,"float32")),i=P3({inputs:{x:s},backend:n}),l=H8.kernelFunc({inputs:{a:e,b:s},backend:n}),u=H8.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return a}{let e=function(e,t,n){let r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){let o=rU.exponent(a*r,t,n),l=rU.getComplexWithIndex(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),rU.assignToTypedArray(r,s,i,a)}return r}(rU.mergeRealAndImagArrays(s,i),r,t);return rU.splitRealAndImagArrays(e)}}function X8(e,t,n,r,a){if(1===n)return{real:e,imag:t};let s=rU.mergeRealAndImagArrays(e,t),i=n/2,o=rU.complexWithEvenIndex(s),l=o.real,u=o.imag,c=[l.length],d=a.makeTensorInfo(c,"float32",l),h=a.makeTensorInfo(c,"float32",u),p=M3({inputs:{real:d,imag:h},backend:a}),f=rU.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),v=a.makeTensorInfo(y,"float32",g),x=M3({inputs:{real:b,imag:v},backend:a}),w=X8(l,u,i,r,a),k=w.real,S=w.imag,I=[k.length],C=a.makeTensorInfo(I,"float32",k),N=a.makeTensorInfo(I,"float32",S),T=M3({inputs:{real:C,imag:N},backend:a}),E=X8(m,g,i,r,a),A=E.real,_=E.imag,$=[A.length],R=a.makeTensorInfo($,"float32",A),D=a.makeTensorInfo($,"float32",_),M=M3({inputs:{real:R,imag:D},backend:a}),F=rU.exponents(n,r),O=[F.real.length],P=a.makeTensorInfo(O,"float32",F.real),L=a.makeTensorInfo(O,"float32",F.imag),z=M3({inputs:{real:P,imag:L},backend:a}),B=Y4({inputs:{a:z,b:M},backend:a}),W=K3({inputs:{a:T,b:B},backend:a}),V=Y5({inputs:{a:T,b:B},backend:a}),U=z3({inputs:{input:W},backend:a}),j=z3({inputs:{input:V},backend:a}),G=t8({inputs:{input:W},backend:a}),H=t8({inputs:{input:V},backend:a}),q=r8({inputs:[U,j],backend:a,attrs:{axis:0}}),K=r8({inputs:[G,H],backend:a,attrs:{axis:0}}),X=a.data.get(q.dataId).values,Y=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}var Y8={kernelName:r_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=ER.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=g6({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=q8(i,!1,n),l=g6({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function Q8(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||ER.inferDtype(a),o=ER.getArrayFromDType(i,ER.sizeFromShape(r));return function(e,t){e.fill(t)}(o,a),t.makeTensorInfo(r,i,o)}var J8={kernelName:a_,backendName:"cpu",kernelFunc:Q8};var Z8={kernelName:s_,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,s=r,i=ER.getTypedArrayFromDType(a.dtype,ER.sizeFromShape(a.shape)),[o,l,u,c]=a.shape,d=s.data.get(a.dataId).values;for(let h=0;h<o;h++){let e=h*u*l*c;for(let t=0;t<l;t++){let n=t*(u*c);for(let t=0;t<u;t++){let r=t*c;for(let a=0;a<c;a++){let s=Math.round(u-t-1),o=e+n+r+a,l=d[o];if(s>=0&&s<u){l=d[e+n+s*c+a]}i[o]=l}}}}return{dataId:s.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};var e7={kernelName:pR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=s8({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){let e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){let e=g6({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=K3({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=K3({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){let e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){let e=g6({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=m6(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=m6(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};var t7={kernelName:fR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=w8({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){let e=m;m=K3({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){let e=m;m=m6(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};var n7={kernelName:c_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=ER.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,u,c,d]=rU.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);let h=S4(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,o,c,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,h.values)}};var r7={kernelName:u_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;T3([a,s],"gatherV2");let l=ER.parseAxisParam(i,a.shape)[0],u=n.data.get(s.dataId).values,c=a.shape[l];for(let v=0;v<u.length;++v){let e=u[v];ER.assert(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let d=o;null==o&&(d=0);let h=ER.sizeFromShape(s.shape),p=rU.segment_util.collectGatherOpShapeInfo(a,s,l,d),f=g6({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=g6({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=I4(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}};var a7={kernelName:f_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=ER.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=g6({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=q8(i,!0,n),l=g6({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},s7=n4(g_,(e=>Number.isFinite(e)?1:0),"bool"),i7={kernelName:g_,backendName:"cpu",kernelFunc:s7},o7=n4(y_,(e=>Math.abs(e)===1/0?1:0),"bool"),l7={kernelName:y_,backendName:"cpu",kernelFunc:o7},u7=n4(b_,(e=>Number.isNaN(e)?1:0),"bool"),c7={kernelName:b_,backendName:"cpu",kernelFunc:u7};var d7={kernelName:k_,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=P4(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},h7=n4(I_,(e=>Math.log1p(e))),p7={kernelName:I_,backendName:"cpu",kernelFunc:h7},f7=D3(((e,t)=>e&&t)),m7=j3(C_,f7,null,"bool"),g7={kernelName:C_,backendName:"cpu",kernelFunc:m7},y7=n4(N_,(e=>e?0:1),"bool"),b7={kernelName:N_,backendName:"cpu",kernelFunc:y7},v7=D3(((e,t)=>e||t)),x7=j3(T_,v7,null,"bool"),w7={kernelName:T_,backendName:"cpu",kernelFunc:x7};var k7={kernelName:$_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;T3(a,"LRN");let u=a.shape[3],c=u-1,d=n.data.get(a.dataId).values,h=ER.sizeFromShape(a.shape),p=new Float32Array(h);function f(e){let t=e%u,n=e-t+Math.max(0,t-s),r=e-t+Math.min(t+s,c),a=0;for(;n<=r;n++){let e=d[n];a+=e*e}return a}for(let m=0;m<h;m++){let e=f(m),t=d[m]*Math.pow(i+o*e,-l);p[m]=t}return n.makeTensorInfo(a.shape,a.dtype,p)}};var S7={kernelName:R_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;T3(i,"LRNGrad");let d=ER.sizeFromShape(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){let e=b%h,t=b-e+Math.max(0,e-o),n=b-e+Math.min(h,e+o+1),r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*c*f[a]*m[b]/r;b===a&&(e+=Math.pow(r,-c)),e*=p[b],g[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,g)}};function I7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,u=l.length,c=ER.parseAxisParam(s,l),d=c,h=rU.getAxesPermutation(d,u),p=o.data.get(a.dataId).values;if(null!=h){let e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];p=r5(p,l,a.dtype,h,e),d=rU.getInnerMostAxes(d.length,u),l=e}T3(a,"max"),rU.assertAxesAreInnerMostDims("max",d,u);let[f,m]=rU.computeOutAndReduceShapes(l,d),g=W4(p,ER.sizeFromShape(m),f,a.dtype),y=o.write(g,f,a.dtype),b=f;return i&&(b=rU.expandShapeToKeepDim(f,c)),{dataId:y,shape:b,dtype:a.dtype}}var C7={kernelName:M_,backendName:"cpu",kernelFunc:I7};var N7={kernelName:O_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;T3(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;ER.assert(rU.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u,c=rU.computePool2DInfo(a.shape,s,i,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&ER.arraysEqual(c.inShape,c.outShape))u=P3({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=ER.computeStrides(a.shape),r=W6(e,a.shape,a.dtype,t,c,"max");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};var T7={kernelName:L_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;T3(a,"maxPool3d");let c=rU.computePool3DInfo(a.shape,s,i,1,o,l,u),d=U6(n.data.get(a.dataId).values,a.shape,a.dtype,ER.computeStrides(a.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};var E7={kernelName:z_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;T3([a,s],"maxPool3DGrad");let c=rU.computePool3DInfo(s.shape,i,o,1,l,u),d=function(e,t){let n=wF(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-h,v=b;for(;v<0;)v+=i;let x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){let u=r*a-p,h=u;for(;h<0;)h+=o;let w=Math.min(t.inHeight,c+u);for(let a=0;a<t.outWidth;++a){let p=a*s-f,k=p;for(;k<0;)k+=l;let S=Math.min(t.inWidth,d+p),I=Number.NEGATIVE_INFINITY,C=-1;for(let t=v;t<x;t+=i){let n=t-b;for(let r=h;r<w;r+=o){let a=r-u;for(let s=k;s<S;s+=l){let i=s-p,o=e.get(m,t,r,s,g);o>=I&&(I=o,C=n*c*d+a*c+i)}}}n.set(C,m,y,r,a,g)}}}return n}(n.bufferSync(s),c),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=x-1-c.padInfo.left,S=v-1-c.padInfo.top,I=wF(s.shape,"float32"),C=n.bufferSync(a);for(let N=0;N<c.batchSize;++N)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){let a=t-w,s=n-S,i=r-k,o=0;for(let t=0;t<b;t+=m){let n=(a+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){let a=(s+r)/p;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let s=0;s<x;s+=y){let l=(i+s)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;let u=b*v*x-1-d.get(N,n,a,l,e)===t*v*x+r*x+s?1:0;0!==u&&(o+=C.get(N,n,a,l,e)*u)}}}I.set(o,N,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};var A7={kernelName:P_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;T3([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=rU.computePool2DInfo(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=wF(h.outShape,o.dtype,V6(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,k=v-1-h.padInfo.top,S=wF(o.shape,"float32"),I=n.data.get(a.dataId).values,C=wF(a.shape,"float32",I);for(let N=0;N<h.batchSize;++N)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){let r=t-k,a=n-w,s=0;for(let t=0;t<v;t+=y){let n=(r+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){let i=(a+r)/g;if(i<0||i>=h.outWidth||Math.floor(i)!==i)continue;let o=v*x-1-f.get(N,n,i,e)===t*x+r?1:0;0!==o&&(s+=C.get(N,n,i,e)*o)}}S.set(s,N,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};var _7={kernelName:B_,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;T3(a,"MaxPoolWithArgmax");let c=u.data.get(a.dataId).values,d=rU.computePool2DInfo(a.shape,s,i,[1,1],o),[h,p]=function(e,t,n,r,a){let s=W6(e,0,n,ER.computeStrides(t),a,"max"),i=V6(e,t,n,a,!0,r);return[s.values,i.values]}(c,a.shape,a.dtype,l,d),f=u.write(h,d.outShape,a.dtype),m=u.write(p,d.outShape,a.dtype);return[{dataId:f,shape:d.outShape,dtype:a.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};var $7={kernelName:W_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=ER.parseAxisParam(s,a.shape),l=rU.computeOutAndReduceShapes(a.shape,o)[1],u=ER.sizeFromShape(l),c=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(d);let h=V3({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});c.push(h);let p=G8({inputs:{a:h,b:d},backend:n});c.push(p);let f=_8({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:i}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};var R7={kernelName:V_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;T3(a,"min");let o=ER.parseAxisParam(s,a.shape),l=o,u=rU.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=a5({inputs:{x:a},backend:n,attrs:{perm:u}}),l=rU.getInnerMostAxes(l.length,a.shape.length)),rU.assertAxesAreInnerMostDims("min",l,c.shape.length);let[d,h]=rU.computeOutAndReduceShapes(c.shape,l),p=ER.sizeFromShape(h),f=ER.makeZerosTypedArray(ER.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*p,t=m[e];for(let n=0;n<p;++n){let r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let e=g6({inputs:{x:g},backend:n,attrs:{shape:rU.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var D7={kernelName:j_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;T3(a,"mirrorPad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),c="reflect"===i?0:1,d=n.data.get(a.dataId).values,h=a.shape.length,p=ER.computeStrides(a.shape),f=ER.sizeFromShape(o),m=o.length,g=ER.computeStrides(o),y=ER.getTypedArrayFromDType(a.dtype,f);for(let b=0;b<f;b++){let e=ER.indexToLoc(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));let t=ER.locToIndex(e,h,p);y[b]=d[t]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}},M7=D3(((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),F7=j3(G_,M7),O7={kernelName:G_,backendName:"cpu",kernelFunc:F7},P7=IT(OT());function L7(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=ER.parseAxisParam([o],a.shape),u=I7({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=rU.expandShapeToKeepDim(u.shape,l),d=g6({inputs:{x:u},backend:n,attrs:{shape:c}}),h=Y5({inputs:{a:a,b:d},backend:n}),p=h4({inputs:{x:h},backend:n}),f=_8({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=g6({inputs:{x:f},backend:n,attrs:{shape:c}}),g=G8({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var z7={kernelName:L$,backendName:"cpu",kernelFunc:L7};var B7={kernelName:H_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;T3(a,"multinomial");let l=o?a:L7({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,s],p=ER.makeZerosTypedArray(ER.sizeFromShape(h),"int32");for(let f=0;f<u;++f){let e=f*c,t=new Float32Array(c-1);t[0]=d[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+d[e+a];let n=P7.alea(i.toString()),r=f*s;for(let a=0;a<s;++a){let e=n();p[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+a]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}},W7=uj.nonMaxSuppressionV3Impl;var V7={kernelName:Y_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;T3(a,"NonMaxSuppression");let u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d}=W7(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},U7=uj.nonMaxSuppressionV4Impl;var j7={kernelName:Q_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;T3(a,"NonMaxSuppressionPadded");let c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=U7(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},G7=uj.nonMaxSuppressionV5Impl;var H7={kernelName:J_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;T3(a,"NonMaxSuppressionWithScore");let c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=G7(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};var q7={kernelName:e$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;T3(a,"oneHot");let u=ER.sizeFromShape(a.shape),c=new Float32Array(u*i);c.fill(l);let d=n.data.get(a.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...a.shape,i],s,c)}};function K7(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){let e=z3({inputs:{input:r},backend:n}),t=K7({inputs:{x:e},backend:n}),a=t8({inputs:{input:r},backend:n}),s=K7({inputs:{x:a},backend:n}),i=M3({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return Q8({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var X7={kernelName:lR,backendName:"cpu",kernelFunc:K7};var Y7={kernelName:Z_,backendName:"cpu",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){let t=z3({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=t8({inputs:{input:a},backend:r}),i=K7({inputs:{x:s},backend:r}),o=M3({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return Q8({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function Q7(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return V8({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{ER.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),ER.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=V8({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=r8({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}var J7={kernelName:t$,backendName:"cpu",kernelFunc:Q7};var Z7={kernelName:n$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;T3(a,"pad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,c=ER.sizeFromShape(a.shape),d=a.shape.length,h=ER.computeStrides(a.shape),p=ER.sizeFromShape(o),f=o.length,m=ER.computeStrides(o),g=ER.getTypedArrayFromDType(a.dtype,p);0!==i&&g.fill(i);for(let y=0;y<c;y++){let e=ER.indexToLoc(y,d,h).map(((e,t)=>e+l[t]));g[ER.locToIndex(e,f,m)]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},e9=D3(((e,t)=>Math.pow(e,t))),t9=j3(a$,e9),n9={kernelName:a$,backendName:"cpu",kernelFunc:t9};var r9={kernelName:o$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.data.get(e.dataId).values)),u=a.map((e=>e.shape)),c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=d5(l,u,c,s.shape,s.dtype,d,i.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};var a9={kernelName:l$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=p5(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var s9={kernelName:u$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,h=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=b5(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}};var i9={kernelName:c$,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=v5(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}},o9=n4(h$,(e=>1/e)),l9={kernelName:h$,backendName:"cpu",kernelFunc:o9};var u9={kernelName:y$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;T3(a,"resizeBilinear");let l=ER.computeStrides(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(ER.sizeFromShape([d,u,c,f])),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=0,x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<d;k++)for(let e=0;e<u;e++){let t;t=i?x*(e+.5)-.5:x*e;let n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(h-1,Math.ceil(t)),s=k*l[0]+n*l[1],o=k*l[0]+a*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;let n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(p-1,Math.ceil(t)),c=s+n*l[2],d=o+n*l[2],h=s+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){let t=m[c+e],n=m[d+e],s=t+(m[h+e]-t)*a,i=s+(n+(m[y+e]-n)*a-s)*r;g[v++]=i}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}};var c9={kernelName:b$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;T3([s,a],"resizeBilinearGrad");let o=ER.computeStrides(a.shape),[l,u,c,d]=a.shape,[,h,p]=s.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(s.dataId).values,x=0;for(let w=0;w<l;w++){let e=w*o[0];for(let t=0;t<h;t++){let n=t*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=e+r*o[1],i=e+a*o[1],l=n-r,h=1-l;for(let e=0;e<p;e++){let t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),a=t-n,u=1-a,p=s+n*o[2],m=s+r*o[2],g=i+n*o[2],y=i+r*o[2],w=h*u,k=h*a,S=l*u,I=l*a;for(let e=0;e<d;e++){let t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*I}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}};var d9={kernelName:m$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;T3(a,"resizeNearestNeighbor");let l=ER.computeStrides(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(d*u*c*f),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1],w=0;for(let k=0;k<d;k++){let e=k*l[0];for(let t=0;t<u;t++){let n=i?v*(t+.5):v*t,r=Math.min(h-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));let a=e+r*l[1];for(let e=0;e<c;e++){let t=i?x*(e+.5):x*e,n=Math.min(p-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));let r=a+n*l[2];for(let e=0;e<f;e++){let t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([d,u,c,f],a.dtype,g)}};var h9={kernelName:g$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;T3([s,a],"resizeNearestNeighborGrad");let o=ER.computeStrides(a.shape),l=ER.computeStrides(s.shape),[u,c,d,h]=a.shape,[,p,f]=s.shape,m=new Float32Array(u*c*d*h),g=n.data.get(s.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let C=0;C<u;C++){let e=C*o[0];for(let t=0;t<c;t++){let n=e+t*o[1],r=Math.floor(t*w),a=Math.floor(r-S/2);for(let s=0;s<d;s++){let r=n+s*o[2],u=Math.floor(s*k),y=Math.floor(u-I/2);for(let n=0;n<h;n++){let o=0;for(let r=0;r<S;r++){let u=r+a;if(u<0||u>=p)continue;let h=e+u*l[1],m=u*v;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){let t=e+y;if(t<0||t>=f)continue;let r=h+t*l[2],a=t*x;s===Math.min(d-1,i?Math.round(a):Math.floor(a))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}};var p9={kernelName:x$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;T3(a,"reverse");let i=a.shape.length,o=ER.parseAxisParam(s,a.shape);if(0===i)return P3({inputs:{x:a},backend:n});let l=new uD(a.shape,a.dtype),u=n.bufferSync(a);for(let c=0;c<l.size;c++){let e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},f9={kernelName:dR,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=ER.getTypedArrayFromDType(a.dtype,ER.sizeFromShape(a.shape)),[c,d,h,p]=a.shape,[f,m]=rU.getImageCenter(o,d,h),g=Math.sin(s),y=Math.cos(s),b=l.data.get(a.dataId).values;for(let v=0;v<c;v++){let e=v*h*d*p;for(let t=0;t<d;t++){let n=t*(h*p);for(let r=0;r<h;r++){let a=r*p;for(let s=0;s<p;s++){let o=[c,t,r,s],l=o[2],v=o[1],x=(l-f)*y-(v-m)*g,w=(l-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=i;if("number"!=typeof i&&(k=3===s?255:i[s]),x>=0&&x<h&&w>=0&&w<d){k=b[e+w*(h*p)+x*p+s]}u[e+n+a+s]=k}}}}return{dataId:l.write(u,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},m9=n4(w$,(e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),g9={kernelName:w$,backendName:"cpu",kernelFunc:m9};var y9={kernelName:S$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=rU.calculateShapes(s,a,i),h=S5(n.bufferSync(a),n.bufferSync(s),i,d,u,l,o,c,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function b9(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function v9(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}var x9={kernelName:C$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=function(e,t,n,r,a,s){let i=ER.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?b9(n,t[e+l]):v9(n,t[e+l])}return i}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",o)}};var w9={kernelName:N$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;T3([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=SD(a.dtype,s.dtype),d=ER.makeZerosTypedArray(ER.sizeFromShape(a.shape),c),h=0,p=0===i||i>1||1===a.shape.length?1:ER.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(a.shape,c,d)}},k9=rU.SELU_SCALEALPHA,S9=rU.SELU_SCALE,I9=n4(T$,(e=>e>=0?S9*e:k9*(Math.exp(e)-1))),C9={kernelName:T$,backendName:"cpu",kernelFunc:I9},N9=n4($$,(e=>e<0?-1:e>0?1:0)),T9={kernelName:$$,backendName:"cpu",kernelFunc:N9},E9=n4(A$,(e=>Math.sin(e))),A9={kernelName:A$,backendName:"cpu",kernelFunc:E9},_9=n4(_$,(e=>Math.sinh(e))),$9={kernelName:_$,backendName:"cpu",kernelFunc:_9},R9=Math.log(1.1920928955078125e-7)+2,D9=n4(D$,(e=>{let t,n=e>-R9,r=e<R9,a=Math.exp(e);return t=r?a:n?e:Math.log(1+a),t})),M9={kernelName:D$,backendName:"cpu",kernelFunc:D9};var F9={kernelName:O$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;T3([a],"spaceToBatchND");let o=ER.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=Z7.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=rU.getReshaped(u.shape,s,o,!1),d=rU.getPermuted(c.length,s.length,!1),h=rU.getReshapedPermuted(u.shape,s,o,!1),p=g6({inputs:{x:u},backend:n,attrs:{shape:c}}),f=a5({inputs:{x:p},backend:n,attrs:{perm:d}}),m=g6({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};var O9={kernelName:z$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=_5(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var P9={kernelName:B$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,d]=$5(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var L9={kernelName:W$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=R5(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};var z9={kernelName:V$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=R5(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};var B9={kernelName:U$,backendName:"cpu",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{sparseIndices:s,sparseValues:i,defaultValue:o}=n,{outputShape:l}=a,{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=rU.calculateShapes(i,s,l),f=!1,m=r.bufferSync(s);switch(i.dtype){case"bool":t=S5(m,r.bufferSync(i),l,p,d,c,u,h,!!r.data.get(o.dataId).values[0],f);break;case"float32":case"int32":t=S5(m,r.bufferSync(i),l,p,d,c,u,h,r.data.get(o.dataId).values[0],f);break;case"string":t=S5(m,r.bufferSync(i),l,p,d,c,u,h,ER.decodeString(r.data.get(o.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return r.makeTensorInfo(l,t.dtype,t.values)}};var W9={kernelName:P$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=ER.parseAxisParam(i,a.shape)[0],l=rU.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{let t=[...c];t[o]=e;let r=E5({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},V9={kernelName:G$,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e,{x:r}=t,a=n;T3(r,"square");let s=a.data.get(r.dataId).values,i=new Float32Array(s.length);for(let o=0;o<s.length;++o){let e=s[o];i[o]=e*e}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},U9=n4(uR,((e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),j9={kernelName:uR,backendName:"cpu",kernelFunc:U9};var G9={kernelName:q$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;T3(a,"stridedSlice");let p,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=$V.sliceInfo(a.shape,s,i,o,l,u,c,d,h);if(g)p=g6({inputs:{x:a},backend:n,attrs:{shape:m}});else if(y||b){ER.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));let e=$V.computeOutShape(v,x,w),t=E5({inputs:{x:a},backend:n,attrs:{begin:v,size:e}});p=g6({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{let e=V5(f,n.bufferSync(a),w,v);p=n.makeTensorInfo(m,e.dtype,e.values)}return p}};var H9={kernelName:K$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=j5(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var q9={kernelName:X$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=H5(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var K9={kernelName:Y$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=q5(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",i)}},X9=n4(J$,(e=>Math.tan(e))),Y9={kernelName:J$,backendName:"cpu",kernelFunc:X9},Q9=n4(Z$,(e=>Math.tanh(e)));var J9={kernelName:I$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=rU.calculateShapes(s,a,r.shape),d=n.bufferSync(a),h=n.bufferSync(s),p=n.bufferSync(r),f=S5(d,h,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};var Z9={kernelName:eR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;T3(a,"tile");let i=J5(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}};var eee={kernelName:tR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;T3(a,"topk");let o=n.data.get(a.dataId).values,[l,u]=t6(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};var tee={kernelName:nR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=[c,f,m,p],y=ER.computeStrides(a.shape),b=y[0],v=y[1],x=y[2],w=ER.computeStrides(g),k=w[0],S=w[1],I=w[2],C=ER.getTypedArrayFromDType(a.dtype,ER.sizeFromShape(g));C.fill(l);let N=r.data.get(a.dataId).values,T=r.data.get(s.dataId).values;for(let E=0;E<c;++E){let e=1===s.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let a,s=e[6]*n+e[7]*t+1;if(0===s)continue;let u=(e[0]*n+e[1]*t+e[2])/s,c=(e[3]*n+e[4]*t+e[5])/s,p=nee(u,h,o),f=nee(c,d,o);switch(i){case"nearest":a=aee(N,d,h,b,v,x,E,f,p,r,l);break;case"bilinear":a=see(N,d,h,b,v,x,E,f,p,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}C[E*k+t*S+n*I+r]=a}return r.makeTensorInfo(g,a.dtype,C)}return{dataId:r.write(C,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function nee(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{let e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return ER.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{let e=t-1;n-=t*Math.trunc(n/e)}return ER.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return ER.clamp(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function ree(e,t,n,r,a,s,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*a+l*s+u]:c}function aee(e,t,n,r,a,s,i,o,l,u,c){return ree(e,t,n,r,a,s,i,Math.round(o),Math.round(l),u,c)}function see(e,t,n,r,a,s,i,o,l,u,c){let d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1;return(p-o)*((f-l)*ree(e,t,n,r,a,s,i,d,h,u,c)+(l-h)*ree(e,t,n,r,a,s,i,d,f,u,c))+(o-d)*((f-l)*ree(e,t,n,r,a,s,i,p,h,u,c)+(l-h)*ree(e,t,n,r,a,s,i,p,f,u,c))}var iee={kernelName:aR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;T3(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=n6(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};var oee={kernelName:sR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),u=0;for(let p=0;p<i;p++)p!==s&&(l[u++]=a.shape[p]);let c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let h=new Array(o);for(let p=0;p<h.length;p++){c[s]=p;let e=E5({inputs:{x:a},backend:n,attrs:{begin:c,size:d}});h[p]=g6({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return h}};var lee={kernelName:iR,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;T3(a,"unsortedSegmentSum");let o=[],l=[],u=a.shape.length-s.shape.length,c=s;for(let h=0;h<u;++h){let e=V8({inputs:{input:c},backend:n,attrs:{dim:h+1}});c=e,l.push(e)}for(let h=0;h<i;++h){let e=ER.createScalarValue(h,"int32"),t=n.makeTensorInfo([],"int32",e),r=u4({inputs:{a:t,b:c},backend:n}),s=V3({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=Y4({inputs:{a:s,b:a},backend:n}),u=_8({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(s),l.push(i),l.push(u)}let d=Q7({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},uee=[x6,R3,k6,I6,X3,C6,N6,T6,E6,A6,$6,D6,F6,L6,B6,j6,G6,H6,q6,v6,K6,X6,Y6,e4,Q6,U3,i4,Z6,F3,e8,a8,i8,o8,l8,u8,c8,d8,p8,m8,g8,y8,b8,v8,x8,k8,S8,I8,C8,N8,T8,E8,A8,R8,s6,D8,c4,W8,p4,U8,g4,Y8,J8,Z8,v4,k4,e7,t7,n7,r7,T4,_4,L3,a7,n8,i7,l7,c7,o6,D4,O4,d7,B4,p7,g7,b7,w7,k7,S7,C7,j4,N7,T7,E7,A7,_7,$7,R7,q4,D7,O7,B7,Q4,Z4,V7,j7,H7,n5,q7,Y7,J7,Z7,n9,c6,o5,r9,a9,s9,i9,B3,H8,l9,h6,f6,y6,u9,c9,d9,h9,p9,f9,g9,k5,y9,x9,w9,C9,N5,T9,A9,$9,A5,z7,M9,F9,O9,P9,L9,z9,B9,W9,F5,V9,L5,W5,j9,G9,H9,q9,K9,Q5,$8,Y9,{kernelName:Z$,backendName:"cpu",kernelFunc:Q9},J9,Z9,eee,tee,s5,iee,oee,lee,X7];for(let n of uee)kR(n);var cee={};ST(cee,{assertNotComplex:()=>vte,bindCanvasToFramebuffer:()=>Xee,bindColorTextureToFramebuffer:()=>Yee,bindTextureToProgramUniformSampler:()=>Kee,bindTextureUnit:()=>jee,bindVertexBufferToProgramAttribute:()=>Uee,callAndCheck:()=>kee,canBeRepresented:()=>Cee,createFragmentShader:()=>Aee,createFramebuffer:()=>Vee,createProgram:()=>Mee,createStaticIndexBuffer:()=>Lee,createStaticVertexBuffer:()=>Pee,createTexture:()=>Bee,createVertexShader:()=>Eee,getBatchDim:()=>nte,getExtensionOrThrow:()=>Tee,getFramebufferErrorMessage:()=>Zee,getMaxTexturesInShader:()=>dte,getNumChannels:()=>zee,getProgramUniformLocation:()=>qee,getProgramUniformLocationOrThrow:()=>Hee,getRowsCols:()=>rte,getShapeAs3D:()=>ate,getTextureShapeFromLogicalShape:()=>ste,getWebGLDisjointQueryTimerVersion:()=>hte,getWebGLErrorMessage:()=>Nee,getWebGLMaxTextureSize:()=>lte,hasExtension:()=>pte,isCapableOfRenderingToFloatTexture:()=>mte,isDownloadFloatTextureEnabled:()=>gte,isReshapeFree:()=>ote,isWebGLFenceEnabled:()=>bte,isWebGLVersionEnabled:()=>fte,linkProgram:()=>Fee,logShaderSourceAndInfoLog:()=>Dee,resetMaxTextureSize:()=>ute,resetMaxTexturesInShader:()=>cte,unbindColorTextureFromFramebuffer:()=>Qee,unbindTextureUnit:()=>Gee,validateFramebuffer:()=>Jee,validateProgram:()=>Oee,validateTextureSize:()=>Wee});var dee,hee,pee,fee={},mee={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function gee(e,t){fee[e]=t}function yee(e,t){if(!(e in fee)||null!=t){let n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=null==t?function(e){if(!HE().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete fee[e]}),!1),HE().getBool("SOFTWARE_WEBGL_ENABLED")&&(mee.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",mee)||n.getContext("experimental-webgl",mee):n.getContext("webgl2",mee)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;fee[e]=n}let n=fee[e];return null==n||n.isContextLost()?(delete fee[e],yee(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),fee[e])}function bee(e,t){return[t,e]}function vee(e){let t=ER.sizeFromShape(e),n=Math.ceil(t/4);return ER.sizeToSquarishShape(n)}function xee(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function wee(e,t){let n,r,a,s,i,o,l,u,c,d,h=e;return 2===HE().getNumber("WEBGL_VERSION")?(n=h.R32F,r=h.R16F,a=h.RGBA16F,s=h.RGBA32F,i=h.RED,l=4,u=1,c=h.HALF_FLOAT,d=h.FLOAT,o=h.RGBA8):(n=e.RGBA,r=e.RGBA,a=e.RGBA,s=h.RGBA,i=e.RGBA,l=4,u=4,c=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,o=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:o,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:c,textureTypeFloat:d}}function kee(e,t){let n=t();return HE().getBool("DEBUG")&&function(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+Nee(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(dee||(dee={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(hee||(hee={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(pee||(pee={}));var See=5.96e-8,Iee=65504;function Cee(e){return!!(HE().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||See<Math.abs(e)&&Math.abs(e)<Iee)}function Nee(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Tee(e,t){return ete(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function Eee(e,t){let n=ete(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(kee(e,(()=>e.shaderSource(n,t))),kee(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function Aee(e,t){let n=ete(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(kee(e,(()=>e.shaderSource(n,t))),kee(e,(()=>e.compileShader(n))),HE().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw Dee(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var _ee,$ee,Ree=/ERROR: [0-9]+:([0-9]+):/g;function Dee(e,t){let n=Ree.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);let r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map(((e,t)=>ER.rightPad((t+1).toString(),s)+e)),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${ER.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function Mee(e){return ete(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function Fee(e,t){if(kee(e,(()=>e.linkProgram(t))),!HE().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Oee(e,t){if(kee(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Pee(e,t){let n=ete(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return kee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),kee(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function Lee(e,t){let n=ete(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return kee(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),kee(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function zee(){return 2===HE().getNumber("WEBGL_VERSION")?1:4}function Bee(e){return ete(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function Wee(e,t){let n=HE().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){throw new Error("Requested texture size "+`[${e}x${t}]`+" is invalid.")}if(e>n||t>n){throw new Error("Requested texture size "+`[${e}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}function Vee(e){return ete(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function Uee(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return-1!==o&&(kee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),kee(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i))),kee(e,(()=>e.enableVertexAttribArray(o))),!0)}function jee(e,t,n){tte(e,n),kee(e,(()=>e.activeTexture(e.TEXTURE0+n))),kee(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function Gee(e,t){tte(e,t),kee(e,(()=>e.activeTexture(e.TEXTURE0+t))),kee(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Hee(e,t,n){return ete(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function qee(e,t,n){return e.getUniformLocation(t,n)}function Kee(e,t,n,r){kee(e,(()=>jee(e,t,r))),kee(e,(()=>e.uniform1i(n,r)))}function Xee(e){kee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),kee(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),kee(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function Yee(e,t,n){kee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),kee(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function Qee(e,t){kee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),kee(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function Jee(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Zee(e,t))}function Zee(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function ete(e,t,n){let r=kee(e,(()=>t()));if(null==r)throw new Error(n);return r}function tte(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function nte(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return ER.sizeFromShape(e.slice(0,e.length-t))}function rte(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function ate(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[nte(e),...rte(e)]),t}function ste(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=HE().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=HE().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&HE().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?ER.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length&&(e=ER.squeezeShape(e).newShape);let a=ER.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){let t=nte(e),n=2,r=2;e.length&&([n,r]=rte(e)),a=t*(n/2)*(r/2),s=ER.sizeToSquarishShape(a).map((e=>2*e))}else s=ER.sizeToSquarishShape(a);return s}function ite(e){return e%2===0}function ote(e,t){if(e=e.slice(-2),t=t.slice(-2),ER.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||ite(n)&&ite(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&ite(e[0])&&ite(t[0])}function lte(e){if(null==_ee){let t=yee(e);_ee=t.getParameter(t.MAX_TEXTURE_SIZE)}return _ee}function ute(){_ee=null}function cte(){$ee=null}function dte(e){if(null==$ee){let t=yee(e);$ee=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,$ee)}function hte(e){if(0===e)return 0;let t,n=yee(e);return t=pte(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:pte(n,"EXT_disjoint_timer_query")?1:0,t}function pte(e,t){return null!=e.getExtension(t)}function fte(e){try{if(null!=yee(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function mte(e){if(0===e)return!1;let t=yee(e);if(1===e){if(!pte(t,"OES_texture_float"))return!1}else if(!pte(t,"EXT_color_buffer_float"))return!1;return yte(t)}function gte(e){if(0===e)return!1;let t=yee(e);if(1!==e){if(pte(t,"EXT_color_buffer_float"))return yte(t);let e="EXT_color_buffer_half_float";if(pte(t,e)){let n=t.getExtension(e);return function(e,t){let n=wee(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),s}(t,n)}return!1}return!(!pte(t,"OES_texture_float")||!pte(t,"WEBGL_color_buffer_float"))&&yte(t)}function yte(e){let t=wee(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function bte(e){return 2===e&&null!=yee(e).fenceSync}function vte(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&ER.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var xte=HE();function wte(){let e,t,n,r,a,s,i,o,l,u;return 2===HE().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=HE().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function kte(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=ER.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${t}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function Ste(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=ER.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / outShapeStrides[${a}]`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function Ite(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=function(e,t){let n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${r[a]}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}function Cte(e){let t=ER.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}xte.registerFlag("HAS_WEBGL",(()=>xte.getNumber("WEBGL_VERSION")>0)),xte.registerFlag("WEBGL_VERSION",(()=>fte(2)?2:fte(1)?1:0)),xte.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),xte.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===xte.get("WEBGL_VERSION"))),xte.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),xte.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),xte.registerFlag("WEBGL_PACK",(()=>xte.getBool("HAS_WEBGL"))),xte.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>xte.getBool("WEBGL_PACK"))),xte.registerFlag("WEBGL_PACK_CLIP",(()=>xte.getBool("WEBGL_PACK"))),xte.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>xte.getBool("WEBGL_PACK"))),xte.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>xte.getBool("WEBGL_PACK"))),xte.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>xte.getBool("WEBGL_PACK"))),xte.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>xte.getBool("WEBGL_PACK"))),xte.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>xte.getBool("WEBGL_PACK"))),xte.registerFlag("WEBGL_PACK_REDUCE",(()=>xte.getBool("WEBGL_PACK"))),xte.registerFlag("WEBGL_LAZILY_UNPACK",(()=>xte.getBool("WEBGL_PACK"))),xte.registerFlag("WEBGL_CONV_IM2COL",(()=>xte.getBool("WEBGL_PACK"))),xte.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>xte.getBool("WEBGL_PACK"))),xte.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>lte(xte.getNumber("WEBGL_VERSION")))),xte.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>dte(xte.getNumber("WEBGL_VERSION")))),xte.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{let e=xte.getNumber("WEBGL_VERSION");return 0===e?0:hte(e)})),xte.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>xte.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!zD.isMobile())),xte.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>mte(xte.getNumber("WEBGL_VERSION")))),xte.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!xte.getBool("WEBGL_FORCE_F16_TEXTURES")&&xte.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),xte.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>gte(xte.getNumber("WEBGL_VERSION")))),xte.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>bte(xte.getNumber("WEBGL_VERSION")))),xte.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>xte.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),xte.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),xte.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>zD.isMobile()?1:-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),xte.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),xte.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),xte.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),xte.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),xte.registerFlag("WEBGL_EXP_CONV",(()=>!1)),xte.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>xte.getBool("IS_TEST"))),xte.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),xte.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),xte.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),xte.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var Nte="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Tte}=rU;function Ete(e,t,n){let r=[];if(e.forEach((e=>{let t=ER.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){let{uniformShape:t}=zte(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));let a,s,i=r.join("\n"),o=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?_te(e,r):Ate(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(a+=n?function(e,t){let n,r=e.name,a=r.charAt(0).toUpperCase()+r.slice(1),s="get"+a+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=Tte(e.shapeInfo.logicalShape,t.logicalShape),u=Lte(o),c=o-i,d=["x","y","z","w","u","v"];n=0===i?"":o<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${d[e+c]} = 0;`)).join("\n");let h="";h=o<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+c]}`)).join(", ");let p="return outputValue;",f=1===ER.sizeFromShape(e.shapeInfo.logicalShape),m=1===ER.sizeFromShape(t.logicalShape);if(1!==i||f||m){if(f&&!m)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){let e=i-2,t=i-1;l.indexOf(e)>-1&&l.indexOf(t)>-1?p="return vec4(outputValue.x);":l.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${n}\n      vec4 outputValue = get${a}(${h});\n      ${p}\n    }\n  `}(e,t):function(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&ER.arraysEqual(i,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let u,c=Lte(l),d=Tte(e.shapeInfo.logicalShape,t.logicalShape),h=l-o,p=["x","y","z","w","u","v"];u=0===o?"":l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${p[e+h]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+h]}`)).join(", "),`\n    float ${a}() {\n      ${c} coords = getOutputCoords();\n      ${u}\n      return get${r}(${f});\n    }\n  `}(e,t)),a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),l=t.texShape,u=wte(),c=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u),d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${$te}\n    ${Rte}\n    ${Dte}\n  `}(u);return t.isPacked?(a=function(e,t,n){switch(e.length){case 0:return Fte();case 1:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(ER.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;let a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,l,n.enableShapeUniforms),s=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(a=function(e,t,n){switch(e.length){case 0:return Fte();case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return ER.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Ste(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;let r=kte(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Ste(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let r=kte(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){let n=kte(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){let n=kte(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,l,n.enableShapeUniforms),s=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),n.packedInputs&&(d+=Mte),[d,c,s,i,a,o,n.userCode].join("\n")}function Ate(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let i=Ote(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Pte(e)}\n      }\n    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=Ote(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&ER.arraysEqual(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;let e=s[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}let{newShape:i,keptDims:o}=ER.squeezeShape(n),l=i;if(l.length<n.length){let n=["row","col"];return`\n      ${Ate(Bte(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${Wte(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${Pte(e)}\n      }\n    `;let u=s[0],c=s[1],d=Ote(r);return 1===c?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=ER.squeezeShape(n),u=o;if(u.length<n.length){let n=["row","col","depth"];return`\n        ${Ate(Bte(e,u),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${Wte(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${Pte(e)}\n      }\n    `;let c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;let f=Ote(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=ER.squeezeShape(n);if(l.length<n.length){let n=["row","col","depth","depth2"];return`\n      ${Ate(Bte(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${Wte(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${Pte(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===s&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;let y=Ote(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=ER.squeezeShape(t);if(l.length<t.length){let t=["row","col","depth","depth2","depth3"];return`\n      ${Ate(Bte(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Wte(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${a})) +\n          depth3;\n        ${Pte(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let f=Ote(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=ER.squeezeShape(t);if(a.length<t.length){let t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Ate(Bte(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Wte(t,s)});\n      }\n    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Pte(e)}\n      }\n    `;let d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let m=Ote(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function _te(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=wte();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=wte();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=wte();if(null!=s&&ER.arraysEqual(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){let r=[1,2],s=["b","row","col"];return`\n        ${_te(Bte(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${Wte(s,r)});\n        }\n      `}let o=wte();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;let l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=wte();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(s[i-1]/2),h=d*Math.ceil(s[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=s[i-m-1],f=`b${m} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}var $te="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Rte="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Dte="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Mte="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Fte(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function Ote(e){return`offset${e}`}function Pte(e){let t=e.name,n=ER.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function Lte(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function zte(e,t,n){let{newShape:r,keptDims:a}=ER.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!ER.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function Bte(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Wte(e,t){return t.map((t=>e[t])).join(", ")}function Vte(e,t,n){let r,a,s,i=[],o=[],l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===HE().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let d of t.variableNames){let r={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,`${d}Shape`,c),r.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),i.push(r)}if(t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",c),s=e.getUniformLocation(n,"outShapeStrides",c),a=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(let d of t.customUniforms)o.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:i,customUniformLocations:o,infLoc:l,nanLoc:u,outShapeLocation:r,outShapeStridesLocation:s,outTexShapeLocation:a}}function Ute(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{let r=e.logicalShape,a=t[n],s=a.shape;if(!ER.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;let i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!ER.arraysEqual(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function jte(e){return HE().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var Gte=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=dee.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=wte();this.outputShape=e,this.enableShapeUniforms=jte(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ste(["r","c","d"],e):kte(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},Hte=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=dee.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=wte();this.outputShape=e,this.enableShapeUniforms=jte(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Ste(["r","c","d"],e):kte(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},qte=class{constructor(e){this.variableNames=["A"],this.outTexUsage=hee.DOWNLOAD;let t=wte();this.outputShape=e,this.userCode=`\n      ${Nte}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},Kte=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=hee.DOWNLOAD;let t=wte();this.outputShape=e,this.userCode=`\n      ${Nte}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},Xte={R:0,G:1,B:2,A:3},Yte=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=wte();this.outputShape=e,this.enableShapeUniforms=jte(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let e=n[i];s+=`\n          if(offset == ${i}) {\n            result = values[${Xte[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Cte(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${s}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}},Qte=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=wte();this.outputShape=e,this.enableShapeUniforms=jte(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){let a=2*s+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Cte(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}},Jte={};function Zte(e){let t=wte();return Eee(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function ene(e){return Pee(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function tne(e){return Lee(e,new Uint16Array([0,1,2,2,1,3]))}function nne(e,t,n,r,a,s){Wee(t,n);let i=Bee(e),o=e.TEXTURE_2D;return kee(e,(()=>e.bindTexture(o,i))),kee(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),kee(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),kee(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),kee(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===HE().getNumber("WEBGL_VERSION")?kee(e,(()=>e.texImage2D(o,0,r,t,n,0,a,s,null))):kee(e,(()=>e.texStorage2D(o,1,r,t,n))),kee(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function rne(e){return e.internalFormatFloat}function ane(e,t,n,r){let[a,s]=bee(t,n);return nne(e,a,s,rne(r),r.textureFormatFloat,e.FLOAT)}function sne(e){return e.internalFormatHalfFloat}function ine(e,t,n,r){let[a,s]=bee(t,n);return nne(e,a,s,sne(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function one(e){return e.downloadTextureFormat}function lne(e,t,n,r){let[a,s]=bee(t,n);return nne(e,a,s,one(r),e.RGBA,e.UNSIGNED_BYTE)}function une(e){return e.internalFormatPackedFloat}function cne(e,t,n,r){let[a,s]=xee(t,n);return nne(e,a,s,une(r),e.RGBA,e.FLOAT)}function dne(e){return e.internalFormatPackedHalfFloat}function hne(e,t,n,r){let[a,s]=xee(t,n);return nne(e,a,s,dne(r),e.RGBA,r.textureTypeHalfFloat)}function pne(e,t,n){return kee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),Uee(e,t,"clipSpacePos",n,3,20,0)&&Uee(e,t,"uv",n,2,20,12)}function fne(e,t,n,r,a,s){let i,o,l;kee(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===HE().getNumber("WEBGL_VERSION")?kee(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):kee(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),kee(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function mne(e,t,n){kee(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===HE().getNumber("WEBGL_VERSION")?kee(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):kee(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===HE().getNumber("WEBGL_VERSION")?kee(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):kee(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),kee(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function gne(e,t,n,r){let a=e.createBuffer();kee(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));let s=16*t*n;return kee(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),kee(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),kee(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}function yne(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function bne(e,t,n,r){let[a,s]=bee(t,n),i=new Uint8Array(function(e,t){return e*t}(t*n,4));return kee(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}function vne(e,t,n,r,a,s,i,o){let l=e,u=new Float32Array(function(e,t){let[n,r]=xee(e,t);return n*r*4}(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function xne(e,t,n){let r=new Float32Array(t*n*4);return kee(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}ST(Jte,{bindVertexProgramAttributeStreams:()=>pne,createBufferFromOutputTexture:()=>gne,createFloat16MatrixTexture:()=>ine,createFloat16PackedMatrixTexture:()=>hne,createFloat32MatrixTexture:()=>ane,createIndexBuffer:()=>tne,createPackedMatrixTexture:()=>cne,createUnsignedBytesMatrixTexture:()=>lne,createVertexBuffer:()=>ene,createVertexShader:()=>Zte,downloadByteEncodedFloatMatrixFromOutputTexture:()=>bne,downloadFloat32MatrixFromBuffer:()=>yne,downloadMatrixFromPackedOutputTexture:()=>xne,downloadPackedMatrixFromBuffer:()=>vne,getInternalFormatForFloat16MatrixTexture:()=>sne,getInternalFormatForFloat16PackedMatrixTexture:()=>dne,getInternalFormatForFloat32MatrixTexture:()=>rne,getInternalFormatForPackedMatrixTexture:()=>une,getInternalFormatForUnsignedBytesMatrixTexture:()=>one,uploadDenseMatrixToTexture:()=>fne,uploadPixelDataToTexture:()=>mne});var wne=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=HE().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,gee(t,e)):this.gl=yee(t),e=this.gl,2===HE().getNumber("WEBGL_VERSION")){let t=e;this.createVertexArray=()=>kee(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>kee(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>kee(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>kee(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){let t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>kee(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>kee(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>kee(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>kee(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===HE().getNumber("WEBGL_VERSION")){let e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=Tee(this.gl,e),pte(this.gl,t))this.textureHalfFloatExtension=Tee(this.gl,t);else if(HE().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),pte(this.gl,r))this.colorBufferHalfFloatExtension=Tee(this.gl,r);else if(HE().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",pte(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!pte(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=ene(this.gl),this.indexBuffer=tne(this.gl),this.framebuffer=Vee(this.gl),this.textureConfig=wee(this.gl,this.textureHalfFloatExtension)}get debug(){return HE().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;kee(e,(()=>e.finish())),kee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),kee(e,(()=>e.deleteFramebuffer(this.framebuffer))),kee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),kee(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),kee(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),ane(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),ine(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),lne(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),mne(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),fne(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),hne(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),cne(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Qee(this.gl,this.framebuffer),this.outputTexture=null),kee(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>bne(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return vne(this.gl,e,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return yne(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=gne(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(HE().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>xne(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=Zte(t));let n=Mee(t);kee(t,(()=>t.attachShader(n,this.vertexShader))),kee(t,(()=>t.attachShader(n,e))),Fee(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&Oee(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;kee(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),pne(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(kee(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&Oee(this.gl,this.program),kee(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?Hee(this.gl,e,t):qee(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),kee(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),Kee(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=xee(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Oee(this.gl,this.program),Jee(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}kee(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),kee(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Tee(this.gl,2===HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await ER.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){let e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in HE().platform&&(n=HE().platform.setTimeoutCustom.bind(HE().platform)),ER.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Yee(this.gl,e,this.framebuffer),this.debug&&Jee(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Yee(this.gl,this.outputTexture,this.framebuffer),this.debug&&Jee(this.gl)):Qee(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;Yee(r,e,this.framebuffer),this.debug&&Jee(r),this.outputTexture=e,kee(r,(()=>r.viewport(0,0,t,n))),kee(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),kee(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}};var{addImpl:kne,bincountImpl:Sne,bincountReduceImpl:Ine,bitwiseAndImpl:Cne,castImpl:Nne,ceilImpl:Tne,concatImpl:Ene,equalImpl:Ane,expImpl:_ne,expm1Impl:$ne,floorImpl:Rne,gatherNdImpl:Dne,gatherV2Impl:Mne,greaterImpl:Fne,greaterEqualImpl:One,lessImpl:Pne,lessEqualImpl:Lne,linSpaceImpl:zne,logImpl:Bne,maxImpl:Wne,maximumImpl:Vne,minimumImpl:Une,multiplyImpl:jne,negImpl:Gne,notEqualImpl:Hne,prodImpl:qne,raggedGatherImpl:Kne,raggedRangeImpl:Xne,raggedTensorToTensorImpl:Yne,rangeImpl:Qne,rsqrtImpl:Jne,scatterImpl:Zne,sigmoidImpl:ere,simpleAbsImpl:tre,sliceImpl:nre,sparseFillEmptyRowsImpl:rre,sparseReshapeImpl:are,sparseSegmentReductionImpl:sre,sqrtImpl:ire,staticRegexReplaceImpl:ore,stridedSliceImpl:lre,stringNGramsImpl:ure,stringSplitImpl:cre,stringToHashBucketFastImpl:dre,subImpl:hre,tileImpl:pre,topKImpl:fre,transposeImpl:mre,uniqueImpl:gre}=_3;function yre(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function bre(e,t){return 1===t?[e]:yre(e,t)}var vre=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=jte(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{let e=bre("rc",this.rank),t=Lte(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}},xre=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=jte(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2===1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${function(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?Ite(["r","c","d"],"inputShape"):kte(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Cte(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};var wre=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=Sre(t,n),a=Ire(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s,i=kre(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}return r===pee.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===pee.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===pee.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===pee.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===pee.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(s),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),s}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;let a=Sre(n,r),s=Ire(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=kre(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=HE().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(let e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function kre(e,t,n,r,a){let s,i=function(e,t){switch(e){case pee.PACKED_2X2_FLOAT32:return une(t);case pee.PACKED_2X2_FLOAT16:return dne(t);case pee.UNPACKED_FLOAT32:return rne(t);case pee.UNPACKED_FLOAT16:return sne(t);case pee.PACKED_4X1_UNSIGNED_BYTE:return one(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);if(a){let[t,n]=xee(e[0],e[1]);s=t*n}else{let[t,n]=bee(e[0],e[1]);s=t*n}let o=function(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,i);return s*o}function Sre(e,t){if(e===hee.UPLOAD)return pee.PACKED_2X2_FLOAT32;if(e===hee.RENDER||null==e)return function(e){return HE().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?pee.PACKED_2X2_FLOAT32:pee.UNPACKED_FLOAT32:e?pee.PACKED_2X2_FLOAT16:pee.UNPACKED_FLOAT16}(t);if(e===hee.DOWNLOAD||e===hee.PIXELS)return pee.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Ire(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var Cre=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=jte(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},Nre="if (isnan(x)) return x;",Tre="return x;",Ere="return abs(x);",Are="return (x >= 0.0) ? x : (exp(x) - 1.0);",_re=Nre+"\n  return (x < 0.0) ? 0.0 : x;\n",$re=Nre+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Rre="return x;",Dre="return 1.0 / (1.0 + exp(-1.0 * x));",Mre="return x;",Fre="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Ore="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Pre="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Lre="return 1.0 / (1.0 + exp(-1.0 * x));",zre=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=jte(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},Bre=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=jte(this.outputShape.length);let t=e.length,n=bre("rc",t),r=Lte(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}},Wre=uj.whereImpl,Vre={};var Ure=HE().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");var jre=class e extends qT{nextDataId(){return e.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!HE().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof wne)t=e;else{let n=yee(HE().getNumber("WEBGL_VERSION"),e);t=new wne(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=yee(HE().getNumber("WEBGL_VERSION"));t=new wne(e),this.binaryCache=function(e){return e in Vre||(Vre[e]={}),Vre[e]}(HE().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new wre(this.gpgpu),this.numMBBeforeWarning=null==HE().global.screen?1024:HE().global.screen.height*HE().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new HT(this,oM())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,s){let i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];let l=ate(t),u=new Yte(l,!1,s),c=this.runWebGLProgram(u,[i],n,[[r,a]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((HE().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||HE().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:hee.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if(HE().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:hee.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new zre(i,Rre):new Cre(i,Rre);let n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;let l,u,c=null!=this.activeTimers;if(c&&(l=ER.now()),"complex64"===r){let e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);u=rU.mergeRealAndImagArrays(e,t)}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=ER.now()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}let t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=a){let t;t=o?new zre(r,Rre):new Cre(r,Rre);let n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(HE().getBool("DEBUG")&&!HE().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===HE().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==s&&HE().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);let t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...vee(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){let e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),t=e[0],n=e[1];u=rU.mergeRealAndImagArrays(t,n)}else if(null==c)u=this.getValuesFromTexture(e);else{let e=ER.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){let e=this.gpgpu.gl;kee(e,(()=>e.deleteBuffer(c)))}let d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&oM().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new zre(a,Rre):new Cre(a,Rre);let r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(e,t.customTexShape),c=oM().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>ER.decodeString(e)));return wF(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return wF(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let n=e[t];if(!Cee(n))throw HE().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=ER.sizeFromShape(t);if(HE().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...vee(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}let s=HE().getBool("WEBGL_PACK")&&!0===r,i=s?ate(t):t,o=s?new Kte(i):new qte(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let a=ER.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=ER.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(a);i.kernelMs=ER.sum(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ER.now(),endMs:null}}endTimer(e){return HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=ER.now(),e)}async getQueryTime(e){if(HE().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ure;return HE().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&ER.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){rU.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return Wre(e.shape,t)}packedUnaryOp(e,t,n){let r=new zre(e.shape,t),a=this.compileAndRun(r,[e],n);return oM().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=tre(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(HE().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Ere,e.dtype);let t=new Cre(e.shape,Ere),n=this.compileAndRun(t,[e]);return oM().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&ER.isString(n[0])){let a=n.map((e=>ER.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return oM().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new Bre(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new vre(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let n=[nte(e.shape),...rte(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[nte(t),...rte(t)],s=new xre(a,n),i=[n],o=this.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){let e=ER.sizeFromShape(a),n=t[0]*t[1]*4;ER.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}let i,o=ate(a);i=r?new Hte(o):new Gte(o);let l=[null!=t?t:vee(o)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0,i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===dee.DENSE){let t=null!=s?s:vee(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===ER.sizeFromShape(i.shape))return o.values=ER.getTypedArrayFromDType(i.dtype,0),i;let l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&ER.sizeFromShape(t.shape)<=HE().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!ote(n.shape,t.shape)){let e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);let c,d={shape:i.shape,texData:o,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach((t=>{let a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=zte(e.packedInputs,t.shape,s),u="",c="",d="";if(1===o.length&&e.packedInputs){let e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){let e=ER.computeStrides(o);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;let h=t.shape.length,p=2===o.length&&ER.arraysEqual(t.shape,s),f=1===ER.sizeFromShape(t.shape),m=rU.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&ER.arraysEqual(s,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${h}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${d}_${y}_${a}`}else{let e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${HE().getNumber("WEBGL_VERSION")}`,s}(e,u,d),p=this.getAndSaveBinary(h,(()=>function(e,t,n,r){let a=n.map(((e,n)=>{let r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=Ete(a,i,t),l=Aee(e.gl,o),u=e.createProgram(l);return HE().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},Vte(e,t,u)))}(this.gpgpu,e,u,d))),f=null!=this.activeTimers;f&&(c=this.startTimer()),HE().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(Ute(t.inShapeInfos,n),Ute([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===HE().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let r=n[l],{uniform:a,offset:s,shape:i,texShape:o}=t.variablesLocations[l];if(i){let{uniformShape:n}=zte(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=a){if(r.isUniform){if(ER.sizeFromShape(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}continue}null!=r.texData.slice&&null!=s&&e.gl.uniform1i(s,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){let n=ER.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){let n=t.program.customUniforms[l],r=t.customUniformLocations[l],s=a[l];if("float"===n.type)e.gl.uniform1fv(r,s);else if("vec2"===n.type)e.gl.uniform2fv(r,s);else if("vec3"===n.type)e.gl.uniform3fv(r,s);else if("vec4"===n.type)e.gl.uniform4fv(r,s);else if("int"===n.type)e.gl.uniform1iv(r,s);else if("ivec2"===n.type)e.gl.uniform2iv(r,s);else if("ivec3"===n.type)e.gl.uniform3iv(r,s);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,s)}}e.executeProgram()}(this.gpgpu,p,u,d,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),f&&(c=this.endTimer(c),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(c)}));let m=HE().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){let e=ER.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!HE().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){let e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(HE().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=cM((()=>{if(!HE().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=HE().getBool("DEBUG");HE().set("DEBUG",!1);let t=this.abs(mP(1e-8)).dataSync()[0];if(HE().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;let l,u=null!=this.activeTimers;u&&(l=ER.now());let c=t.texShape;if(null==c&&(c=ste(n,o),t.texShape=c),null!=a){let e,s=ate(n),i=c[1],d=c[0],h=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(o||!h)&&([i,d]=xee(c[0],c[1])),e=o?new Qte(s,h):new Yte(s,h);let p=h?[d,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=h?hee.PIXELS:hee.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,a);let g=[[d,i]],y=this.runWebGLProgram(e,[f],r,g,!0),b=this.texData.get(y.dataId);t.texShape=b.texShape,t.isPacked=b.isPacked,t.usage=b.usage,HE().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=b.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=ER.now()-l)}else{let e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*ER.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await tU(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(Dee(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=Vte(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:r,height:a,width:s,channels:i}=e,o=oM().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=o.writeTexture(r,t,n,a,s,i);return oM().makeTensorFromDataId(l,t,n,o)}};jre.nextDataId=0;var Gre="4.16.0";function Hre(){HE().set("WEBGL_FORCE_F16_TEXTURES",!0)}zD.isBrowser()&&xM("webgl",(()=>new jre),2);var qre={forceHalfFloat:Hre},Kre="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",Xre=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=rU.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=jte(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},Yre="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",Qre=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=rU.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=jte(a);let s="";if(r)if(0===a||1===ER.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${Lte(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let e=bre("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}};function Jre(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Zre={kernelName:p_,backendName:"webgl",kernelFunc:Jre};function eae(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=Jre({inputs:{x:r},backend:n}),l=Jre({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var tae={kernelName:IA,backendName:"webgl",kernelFunc:eae},nae="return (a < 0.) ? b * a : a;",rae="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var aae={kernelName:v_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",ER.createScalarValue(s,"float32")),o=HE().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qre(rae,a.shape,i.shape):new Xre(nae,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},sae="return (a < 0.) ? b * a : a;",iae="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var oae={kernelName:s$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=HE().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qre(iae,r.shape,a.shape):new Xre(sae,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},lae="if (isnan(x)) return x;";function uae(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=e;return e=>{let s,{inputs:i,backend:o}=e,{x:l}=i,u=o,c=a||l.dtype;if(u.shouldExecuteOnCPU([l])&&null!=r){let e=u.texData.get(l.dataId),t=r(e.values,c);return u.makeTensorInfo(l.shape,c,t)}return s=HE().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new zre(l.shape,n):new Cre(l.shape,t),u.runWebGLProgram(s,[l],c)}}function cae(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:s,dtype:i}=e;return e=>{let{inputs:o,backend:l}=e,{a:u,b:c}=o,d=l;if(a&&"complex64"===u.dtype){let e=d.texData.get(u.dataId),n=d.texData.get(c.dataId),[r,a]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{let[n,r]=e,a={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:r.dataId,dtype:r.dtype,shape:c.shape},i=new Xre(t,u.shape,c.shape);return d.runWebGLProgram(i,[a,s],SD(n.dtype,r.dtype))})),s=eae({inputs:{real:r,imag:a},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(a),s}let h,p=i||SD(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=s){let e=d.texData.get(u.dataId).values,t=d.texData.get(c.dataId).values,n="string"===u.dtype?rU.fromUint8ToStringArray(e):e,r="string"===u.dtype?rU.fromUint8ToStringArray(t):t,[a,i]=s(u.shape,c.shape,n,r,p),o=d.makeTensorInfo(i,p);return d.texData.get(o.dataId).values=a,o}return h=HE().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Qre(n,u.shape,c.shape,r):new Xre(t,u.shape,c.shape),d.runWebGLProgram(h,[u,c],p)}}function dae(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?Mre:Tre;if("relu"===e)return t?Ore:_re;if("elu"===e)return t?Fre:Are;if("relu6"===e)return t?Pre:$re;if("prelu"===e)return t?iae:sae;if("leakyrelu"===e)return t?rae:nae;if("sigmoid"===e)return t?Lre:Dre;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var hae=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=jte(this.outputShape.length);let u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},pae={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},fae=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=rU.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},mae="return a * b;";function gae(e){let t,{inputs:n,backend:r}=e,{a:a,b:s}=n,i=rU.upcastType(a.dtype,s.dtype);if("complex64"===a.dtype){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),n=new fae(pae.REAL,a.shape,s.shape),i=new fae(pae.IMAG,a.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=r.runWebGLProgram(n,o,"float32"),u=r.runWebGLProgram(i,o,"float32"),c=eae({inputs:{real:l,imag:u},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(u),c}if(r.shouldExecuteOnCPU([a,s])){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),[n,o]=jne(a.shape,s.shape,e.values,t.values,i),l=r.makeTensorInfo(o,i);return r.texData.get(l.dataId).values=n,l}return t=HE().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qre(mae,a.shape,s.shape):new Xre(mae,a.shape,s.shape),r.runWebGLProgram(t,[a,s],i)}var yae={kernelName:q_,backendName:"webgl",kernelFunc:gae};function bae(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=ER.sizeFromShape(a.shape),l=ER.inferFromImplicitShape(s,o),u=ER.sizeFromShape(l);ER.assert(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));let c=i.texData.get(a.dataId);return!c.isPacked||ote(a.shape,l)||null!==c.texture&&ote(c.shape,l)?(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){let r=[nte(e.shape),...rte(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[nte(t),...rte(t)],i=new xre(s,r),o=[r],l=n.runWebGLProgram(i,[a],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(a,l,i)}var vae={kernelName:f$,backendName:"webgl",kernelFunc:bae},xae=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=4*Math.floor(n/4),o=n%4,l="sumValue += dot(values, ones);";if(null!=t){let e=1/t;l=`sumValue += dot(values * ${ER.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},wae=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");let u=4*Math.floor(n/4),c=n%4,d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function kae(e,t,n,r){let a=function(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],r=rU.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape),s=e;for(let i=0;i<a.length;i++){let o,l,{inSize:u,windowSize:c,outSize:d}=a[i];o="mean"===n?0===i?new xae({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:d},u):new xae({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:d}):new wae({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:d},n),l=s,s=r.runWebGLProgram(o,[s],t),l.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(l)}return s}var Sae=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let r=Lte(this.rank),a=function(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}};var Iae=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=Lte(this.rank),a=yre("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function Cae(e,t,n){let r=HE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Iae(e.shape,t):new Sae(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function Nae(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return function(e,t,n,r){let a=t,s=e.shape.length,i=ER.parseAxisParam(a,e.shape),o=i,l=rU.getAxesPermutation(o,s),u=null!=l,c=e;u&&(c=Cae(e,l,r),o=rU.getInnerMostAxes(o.length,s)),rU.assertAxesAreInnerMostDims("sum",o,s);let[d,h]=rU.computeOutAndReduceShapes(c.shape,o),p=d;n&&(p=rU.expandShapeToKeepDim(d,i));let f=ER.sizeFromShape(h),m=bae({inputs:{x:c},attrs:{shape:[ER.sizeFromShape(e.shape)/f,f]},backend:r}),g=kae(m,ID(e.dtype),"sum",r),y=bae({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),y}(a,s,i,n)}var Tae={kernelName:F$,backendName:"webgl",kernelFunc:Nae};function Eae(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{perm:i}=a,o=r,l=s.shape.length,u=new Array(l);for(let c=0;c<u.length;c++)u[c]=s.shape[i[c]];if(o.shouldExecuteOnCPU([s])){let e=o.texData.get(s.dataId).values,n=mre(e,s.shape,s.dtype,i,u);t=o.makeTensorInfo(u,s.dtype),o.texData.get(t.dataId).values=n}else t=Cae(s,i,o);return t}var Aae={kernelName:rR,backendName:"webgl",kernelFunc:Eae},_ae=1e3;function $ae(e){let{a:t,b:n,transposeA:r,transposeB:a,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e,c=t.shape.length,d=n.shape.length,h=r?t.shape[c-2]:t.shape[c-1],p=a?n.shape[d-1]:n.shape[d-2],f=r?t.shape[c-1]:t.shape[c-2],m=a?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=ER.sizeFromShape(g),v=ER.sizeFromShape(y),x=GO.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);ER.assert(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${a} must match.`));let w,k=r?[b,h,f]:[b,f,h],S=a?[v,m,p]:[v,p,m],I=bae({inputs:{x:t},backend:s,attrs:{shape:k}}),C=bae({inputs:{x:n},backend:s,attrs:{shape:S}}),N=[I,C],T=Math.max(b,v),E=r?I.shape[1]:I.shape[2],A=null!=i,_=null!=o,$="leakyrelu"===u,R=null!=u?dae(u,!0):null;if((1===f||1===m)&&E>_ae&&!1===(A||_||$||null!=R)){let e=I,t=C;r&&(e=Eae({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(e)),a&&(t=Eae({inputs:{x:C},backend:s,attrs:{perm:[0,2,1]}}),N.push(t));let n=1===m,i=e;1!==m&&(i=bae({inputs:{x:e},backend:s,attrs:{shape:[T,E,1]}}),N.push(i));let o=1===m?2:1,l=t;n&&(l=bae({inputs:{x:t},backend:s,attrs:{shape:[T,1,E]}}),N.push(l));let u=gae({inputs:{a:i,b:l},backend:s});w=Nae({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),N.push(u)}else{let e=SD(t.dtype,n.dtype),u=new hae(k,S,[T,f,m],r,a,A,R,_,$),c=[I,C];if(null!=i&&c.push(i),_&&c.push(o),$){let e=s.makeTensorInfo([],"float32",ER.createScalarValue(l,"float32"));c.push(e),N.push(e)}w=s.runWebGLProgram(u,c,e)}let D=bae({inputs:{x:w},backend:s,attrs:{shape:x}});N.push(w);for(let M of N)s.disposeIntermediateTensorInfo(M);return D}var Rae={kernelName:hR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return $ae({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},Dae="return abs(x);";var Mae={kernelName:QE,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=r.texData.get(a.dataId),t=tre(e.values);return r.makeTensorInfo(a.shape,a.dtype,t)}return t=HE().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new zre(a.shape,Dae):new Cre(a.shape,Dae),r.runWebGLProgram(t,[a],a.dtype)}},Fae=uae({opSnippet:Nre+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Oae={kernelName:JE,backendName:"webgl",kernelFunc:Fae},Pae=uae({opSnippet:Nre+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),Lae={kernelName:ZE,backendName:"webgl",kernelFunc:Pae},zae="return a + b;",Bae=cae({opSnippet:zae,packedOpSnippet:zae,supportsComplex:!0,cpuKernelImpl:kne}),Wae={kernelName:eA,backendName:"webgl",kernelFunc:Bae},Vae=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}},Uae=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}};var jae={kernelName:tA,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,a=n;if(1===a.length)return Jre({inputs:{x:a[0]},backend:r});if(a.length>HE().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),s=e({inputs:a.slice(t),backend:r});return e({inputs:[n,s],backend:r})}let s=a.map((e=>e.dtype)).reduce(((e,t)=>SD(e,t))),i=a.map((e=>e.shape)),o=HE().getBool("WEBGL_PACK")?new Uae(a[0].shape,i):new Vae(a[0].shape,i);return r.runWebGLProgram(o,a,s)}};var Gae={kernelName:nA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=ER.parseAxisParam(s,a.shape),u=l,c=rU.getAxesPermutation(u,o),d=a;null!=c&&(d=Eae({inputs:{x:a},backend:n,attrs:{perm:c}}),u=rU.getInnerMostAxes(u.length,o)),rU.assertAxesAreInnerMostDims("all",u,o);let h,[p,f]=rU.computeOutAndReduceShapes(d.shape,u),m=bae({inputs:{x:d},backend:n,attrs:{shape:[-1,ER.sizeFromShape(f)]}}),g=kae(m,m.dtype,"all",n);if(i){h=bae({inputs:{x:g},backend:n,attrs:{shape:rU.expandShapeToKeepDim(p,l)}})}else h=bae({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),h}};var Hae={kernelName:rA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=ER.parseAxisParam(s,a.shape),u=l,c=rU.getAxesPermutation(u,o),d=a;null!=c&&(d=Eae({inputs:{x:a},backend:n,attrs:{perm:c}}),u=rU.getInnerMostAxes(u.length,o)),rU.assertAxesAreInnerMostDims("any",u,o);let h,[p,f]=rU.computeOutAndReduceShapes(d.shape,u),m=bae({inputs:{x:d},backend:n,attrs:{shape:[-1,ER.sizeFromShape(f)]}}),g=kae(m,m.dtype,"any",n);if(i){h=bae({inputs:{x:g},backend:n,attrs:{shape:rU.expandShapeToKeepDim(p,l)}})}else h=bae({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),h}},qae=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},Kae=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,ER.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i,o,l=this.outputShape,u=l.length,c=Lte(u),d=bre("coords",u);if(1===s){o=u+1;let e=Lte(o);i=`\n        ${e} sourceLocR = ${e}(${d.join()}, 0);\n        ++${d[u-1]};\n        ${e} sourceLocG = ${e}(${d.join()}, 0);\n        ++${d[u-2]};\n        ${e} sourceLocA = ${e}(${d.join()}, 0);\n        --${d[u-1]};\n        ${e} sourceLocB = ${e}(${d.join()}, 0);\n        --${d[u-2]};`}else o=u,i=`\n        ${c} sourceLocR = coords;\n        ++${d[u-1]};\n        ${c} sourceLocG = coords;\n        ++${d[u-2]};\n        ${c} sourceLocA = coords;\n        --${d[u-1]};\n        ${c} sourceLocB = coords;\n        --${d[u-2]};`;let h=["x","y","z","w","u","v"].slice(0,o),p="."+h[o-1],f=h.map((e=>"int "+e)),m=bre("sourceLocR",o-1).concat("inIdx.r"),g=bre("sourceLocG",o-1).concat("inIdx.g"),y=bre("sourceLocB",o-1).concat("inIdx.b"),b=bre("sourceLocA",o-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${d[u-1]} < ${l[u-1]-1};\n        bool hasNextRow = ${d[u-2]} < ${l[u-2]-1};\n        ${i}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function Xae(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);let i=rU.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new qae(o,n,null==r),u=[t];null!=r&&u.push(r);let c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;let d=Xae(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function Yae(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=null!=r?r.shape:t.shape,s=a[a.length-1],i=rU.computeOptimalWindowSize(s),o=new Kae(a,i,n,null==r),l=null==r?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let r=Yae(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function Qae(e,t,n,r){let a=[n];if(rU.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!HE().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let n=[],s=e.texData.get(t.dataId),i=t;null!==s&&s.isPacked&&(i=e.unpackTensor(t),n.push(i));let[o,l]=rU.computeOutAndReduceShapes(i.shape,a),u=ER.sizeFromShape(l),c=bae({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);let d=Xae(e,c,r);n.push(d);let h=bae({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return Yae(e,t,r)}var Jae={kernelName:aA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=ER.parseAxisParam(s,a.shape),o=rU.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=Eae({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=rU.getInnerMostAxes(i.length,l.shape.length)),rU.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=Qae(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};var Zae={kernelName:sA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=ER.parseAxisParam(s,a.shape),o=rU.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=Eae({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=rU.getInnerMostAxes(i.length,l.shape.length)),rU.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=Qae(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},ese=uae({opSnippet:Nre+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),tse={kernelName:iA,backendName:"webgl",kernelFunc:ese},nse=uae({opSnippet:Nre+"return log(x + sqrt(x * x + 1.0));"}),rse={kernelName:oA,backendName:"webgl",kernelFunc:nse},ase=uae({opSnippet:Nre+"\n  return atan(x);\n"}),sse={kernelName:lA,backendName:"webgl",kernelFunc:ase},ise=cae({opSnippet:Kre+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Yre+"\n  return result;\n"}),ose={kernelName:cA,backendName:"webgl",kernelFunc:ise},lse=uae({opSnippet:Nre+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),use={kernelName:uA,backendName:"webgl",kernelFunc:lse},cse=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");let v=4*Math.floor(s/4),x=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}},dse=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b="avg"===t,v="0.0";if(b||(v="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");let w=4*Math.floor(s/4),k=s%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}};var hse={kernelName:dA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;vte(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;ER.assert(rU.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u=rU.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&ER.arraysEqual(u.inShape,u.outShape))return Jre({inputs:{x:a},backend:n});let c=new cse(u,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}};var pse={kernelName:pA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=rU.computePool3DInfo(a.shape,s,i,[1,1,1],o,l,u),d=new dse(c,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}},fse=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},mse=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var gse={kernelName:fA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=rU.computePool3DInfo(i.shape,o,l,[1,1,1],u,c),h=new mse(d);return n.runWebGLProgram(h,[a],i.dtype)}};var yse={kernelName:hA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;vte([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=rU.computePool2DInfo(i.shape,o,l,1,u),d=new fse(c);return n.runWebGLProgram(d,[a],i.dtype)}};var bse={kernelName:mA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;return $ae({a:a,b:s,transposeA:i,transposeB:o,backend:n})}},vse=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],rU.assertAndGetBroadcastShape(e,t),rU.assertAndGetBroadcastShape(e,n);let i="0.0";null!=r&&(rU.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(rU.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},xse=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],rU.assertAndGetBroadcastShape(e,t),rU.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";null!=r&&(rU.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(rU.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},wse={kernelName:l_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,mean:s,variance:i,offset:o,scale:l}=t;ER.assert(s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),ER.assert(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),ER.assert(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=r;null==u&&(u=.001);let c=[a,s,i],d=null;null!=o&&(d=o.shape,c.push(o));let h=null;null!=l&&(h=l.shape,c.push(l));let p=HE().getBool("WEBGL_PACK_NORMALIZATION")?new xse(a.shape,s.shape,i.shape,d,h,u):new vse(a.shape,s.shape,i.shape,d,h,u);return n.runWebGLProgram(p,c,c[0].dtype)}},kse=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Lte(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return Sse.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);n=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${Sse[t]} = start[${t}] + coords.${Sse[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${n}\n        setOutput(getSource(${r}));\n      }\n    `}},Sse=["x","y","z","w","u","v"];var Ise=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Lte(this.rank),n=bre("coords",this.rank),r=bre("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}};function Cse(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=$V.parseSliceParams(a,s,i);if($V.assertParamsValid(a,o,l),0===ER.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){let e=n.texData.get(a.dataId),t=nre(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}let{isPacked:u}=n.texData.get(a.dataId),c=$V.isSliceContinous(a.shape,o,l);if(u||!c){let e=HE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ise(l):new kse(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=$V.computeFlatOffset(t,ER.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}(a,o,l,n)}var Nse={kernelName:E$,backendName:"webgl",kernelFunc:Cse},Tse={kernelName:gA,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;ER.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=rU.getReshaped(a.shape,s,o),u=rU.getPermuted(l.length,s.length),c=rU.getReshapedPermuted(a.shape,s,o),d=rU.getSliceBeginCoords(i,s.length),h=rU.getSliceSize(c,i,s.length),p=[],f=bae({inputs:{x:a},backend:n,attrs:{shape:l}}),m=Eae({inputs:{x:f},backend:n,attrs:{perm:u}}),g=bae({inputs:{x:m},backend:n,attrs:{shape:c}}),y=Cse({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};var Ese={kernelName:yA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=Sne(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}};var Ase={kernelName:bA,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{a:a,b:s}=n,i=HE().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=HE().getNumber("WEBGL_VERSION");if(r.shouldExecuteOnCPU([a,s])||1===o){let e=r.texData.get(a.dataId).values,t=r.texData.get(s.dataId).values,[n,i]=Cne(a.shape,s.shape,e,t,a.dtype),o=r.makeTensorInfo(i,a.dtype);return r.texData.get(o.dataId).values=n,o}return t=i?new Qre("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,s.shape,!1):new Xre("\n  return float(int(a.r) & int(b.r));\n",a.shape,s.shape),r.runWebGLProgram(t,[a,s],a.dtype)}};var _se={kernelName:xA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=rU.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},$se=cae({opSnippet:"return float(a != b);",cpuKernelImpl:Hne,dtype:"bool"}),Rse={kernelName:X_,backendName:"webgl",kernelFunc:$se};function Dse(e){let{inputs:t,backend:n}=e,{input:r}=t;return Jre({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}var Mse={kernelName:d$,backendName:"webgl",kernelFunc:Dse},Fse="return float(int(x));";var Ose={kernelName:wA,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:i}=a;if("complex64"===i){if("complex64"===s.dtype)return Jre({inputs:{x:s},backend:r});let t=pL(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=eae({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){let t=Dse({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!ER.hasEncodingLoss(s.dtype,i)){let e=Jre({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([s])){let e=r.texData.get(s.dataId).values,[t,n,a]=Nne(e,s.shape,s.dtype,i);return r.makeTensorInfo(t,n,a)}if("int32"===i)return function(e,t){let n=new Cre(e.shape,Fse),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===i){let e=r.makeTensorInfo([],"bool",ER.getTypedArrayFromDType("bool",1)),t=$se({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},Pse="return ceil(x);",Lse=uae({opSnippet:Pse,packedOpSnippet:Pse,cpuKernelImpl:Tne}),zse={kernelName:kA,backendName:"webgl",kernelFunc:Lse},Bse=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}},Wse=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}};var Vse={kernelName:SA,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{clipValueMin:i,clipValueMax:o}=a;t=HE().getBool("WEBGL_PACK_CLIP")?new Wse(s.shape):new Bse(s.shape);let l=[[i],[o]];return r.runWebGLProgram(t,[s],s.dtype,l)}},Use=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}};function jse(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}var Gse={kernelName:CA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new Use(r.shape),i=[jse(r,a.complexTensorInfos.real),jse(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}},Hse=class{constructor(e){this.outputShape=[],this.outputShape=rU.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let e=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${e}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}},qse=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=rU.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=Lte(r),s=bre("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],u=i.slice(-2),c=i.join(),d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){let e=o[f-1];d+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${Kse(i,l,e)}),\n            vec2(${Kse(u,l,e)}));\n        }`}let h=o.length,p=o[o.length-1];d+=`\n        return getChannel(\n          getT${h}(${Kse(i,l,p)}),\n          vec2(${Kse(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}};function Kse(e,t,n){let r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function Xse(e){let{inputs:t,backend:n}=e,{input:r}=t;return Jre({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}var Yse={kernelName:m_,backendName:"webgl",kernelFunc:Xse};function Qse(e,t,n){let r=e[0].dtype;if("complex64"===r){let r=e.map((e=>Dse({inputs:{input:e},backend:n}))),a=e.map((e=>Xse({inputs:{input:e},backend:n}))),s=Qse(r,t,n),i=Qse(a,t,n),o=eae({inputs:{real:s,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){let a=e.map((e=>{let r=[-1,ER.sizeFromShape(e.shape.slice(t))];return bae({inputs:{x:e},backend:n,attrs:{shape:r}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=rU.computeOutShape(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=Ene(s,i,r,o),u=rU.computeOutShape(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}let s=e.filter((e=>ER.sizeFromShape(e.shape)>0)),i=HE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){let t=i?new Cre(e[0].shape,Rre):new zre(e[0].shape,Rre);return n.runWebGLProgram(t,e,r)}let o=HE().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let e=[];for(let a=0;a<s.length;a+=o){let r=s.slice(a,a+o);e.push(Qse(r,t,n))}let r=Qse(e,t,n);for(let t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){let e=new qse(s.map((e=>e.shape)),t);return n.runWebGLProgram(e,s,r)}let{tensors2D:l,outShape:u}=function(e,t,n){let r=rU.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>bae({inputs:{x:e},attrs:{shape:[-1,ER.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}(s,t,n),c=new Hse(l.map((e=>e.shape))),d=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));let h=bae({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function Jse(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=ER.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));rU.assertParamsConsistent(i,s);let o=rU.computeOutShape(t.map((e=>e.shape)),s);if(0===ER.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>ER.sizeFromShape(e.shape)>0));return 1===l.length?Jre({inputs:{x:l[0]},backend:n}):Qse(l,s,n)}var Zse={kernelName:NA,backendName:"webgl",kernelFunc:Jse},eie=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1,v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}},tie=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},nie=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jte(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u,d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)d+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){let t=2*m;if(d+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,d+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){let e=s%2===0?ER.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,d+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):d+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(d+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(d+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(d+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}},rie=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=jte(this.outputShape.length);let{dataFormat:n}=t,r=wte(),a="channelsLast"===n,s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}};function aie(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function sie(e){let t,{x:n,filter:r,convInfo:a,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e,c=n.shape,d=s.texData.get(n.dataId),h=a.inChannels,p=c[0]*c[1]*c[2],f=a.outChannels,m="channelsLast"===a.dataFormat,g=!1,y=[];if(null!=o){let e=aie(o.shape,m);null!=e&&(o=bae({inputs:{x:o},backend:s,attrs:{shape:e}}),y.push(o))}if(null!=i){let e=aie(i.shape,m);null!=e&&(i=bae({inputs:{x:i},backend:s,attrs:{shape:e}}),y.push(i))}if((1!==p&&1!==f||!(h>_ae))&&d.isPacked&&m&&null!=d.texture&&c[2]%2!==0&&ER.arraysEqual(d.shape.slice(-3),c.slice(-3))){let e=c[0]*c[1]*(c[2]+1),h={dataId:n.dataId,shape:[1,e,a.inChannels],dtype:n.dtype},p=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,ER.assert(ote(d.shape,h.shape),(()=>`packed reshape ${d.shape} to ${h.shape} isn't free`));let f=bae({inputs:{x:r},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}});y.push(f);let m=$ae({a:h,b:f,backend:s,transposeA:false,transposeB:g,bias:i,activation:u,preluActivationWeights:o,leakyreluAlpha:l}),b=s.texData.get(m.dataId);ER.assert(b.isPacked,(()=>"batchMatMul result is expected to be packed")),d.shape=p,b.shape=a.outShape,t=Jre({inputs:{x:m},backend:s}),t.shape=a.outShape,y.push(m)}else{let e=a.outHeight*a.outWidth,c=bae({inputs:{x:n},backend:s,attrs:{shape:m?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),d=bae({inputs:{x:r},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}}),h=$ae({a:m?c:d,b:m?d:c,transposeA:!m,transposeB:g,backend:s,bias:i,activation:u,preluActivationWeights:o,leakyreluAlpha:l});t=bae({inputs:{x:h},backend:s,attrs:{shape:a.outShape}}),y.push(c),y.push(d),y.push(h)}for(let b of y)s.disposeIntermediateTensorInfo(b);return t}function iie(e){let{x:t,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e,{filterWidth:u,filterHeight:c,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=u*c*d,y=p*h,b=[r.batchSize,g,y],v=[];if(null!=i){let e=aie(i.shape,m);null!=e&&(i=bae({inputs:{x:i},backend:a,attrs:{shape:e}}),v.push(i))}if(null!=s){let e=aie(s.shape,m);null!=e&&(s=bae({inputs:{x:s},backend:a,attrs:{shape:e}}),v.push(s))}let x=bae({inputs:{x:n},backend:a,attrs:{shape:[1,g,ER.sizeFromShape(n.shape)/g]}});v.push(x);let w=new rie(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(w,[t],"float32",k),I=bae({inputs:{x:S},backend:a,attrs:{shape:b}});v.push(S),v.push(I);let C=null!=s,N=null!=i,T="leakyrelu"===l,E=l?dae(l,!0):null,A=new hae(m?I.shape:x.shape,m?x.shape:I.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,C,E,N,T),_=m?[I,x]:[x,I];if(s&&_.push(s),N&&_.push(i),T){let e=a.makeTensorInfo([],"float32",ER.createScalarValue(o,"float32"));_.push(e),v.push(e)}let $=a.runWebGLProgram(A,_,"float32"),R=bae({inputs:{x:$},backend:a,attrs:{shape:r.outShape}});v.push($);for(let D of v)a.disposeIntermediateTensorInfo(D);return R}var oie={kernelName:TA,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:d}=a,h=rU.convertConv2DDataFormat(u),p=rU.computeConv2DInfo(s.shape,i.shape,o,c,l,d,!1,h);if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(p.strideWidth<=2&&"channelsLast"===h&&HE().getBool("WEBGL_EXP_CONV")){let e=new nie(p),n=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];t=r.runWebGLProgram(e,[s,i],"float32",n)}else if(HE().getBool("WEBGL_CONV_IM2COL"))t=iie({x:s,filter:i,convInfo:p,backend:r});else{let e=new eie(p);t=r.runWebGLProgram(e,[s,i],"float32")}else t=sie({x:s,filter:i,convInfo:p,backend:r});let f=bae({inputs:{x:t},backend:r,attrs:{shape:p.outShape}});return r.disposeIntermediateTensorInfo(t),f}},lie=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},uie=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},cie=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},die=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var hie={kernelName:EA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=rU.convertConv2DDataFormat(l),h=rU.computeConv2DInfo(a.shape,c,i,1,o,u,!1,d),p=new lie(h);return n.runWebGLProgram(p,[a,s],"float32")}},pie=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=jte(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}};var fie={kernelName:AA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=rU.convertConv2DDataFormat(u),h=rU.computeConv2DInfo(i,s.shape,o,1,l,c,!1,d);if(HE().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){let e=[[h.strideHeight,h.strideWidth]],t=new pie(h);return n.runWebGLProgram(t,[a,s],"float32",e)}{let e=new uie(h);return n.runWebGLProgram(e,[a,s],"float32")}}};var mie={kernelName:_A,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=rU.computeConv3DInfo(a.shape,s.shape,i,l,o),c=new tie(u);return n.runWebGLProgram(c,[a,s],"float32")}};var gie={kernelName:$A,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=rU.computeConv3DInfo(a.shape,l,i,1,o),c=new cie(u);return n.runWebGLProgram(c,[a,s],"float32")}};var yie,bie={kernelName:RA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=rU.computeConv3DInfo(l,s.shape,o,1,i),c=new die(u);return n.runWebGLProgram(c,[a,s],"float32")}},vie=uae({opSnippet:lae+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Yre}\n  return result;\n`}),xie={kernelName:DA,backendName:"webgl",kernelFunc:vie},wie=uae({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),kie={kernelName:MA,backendName:"webgl",kernelFunc:wie},Sie=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];let h="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,x]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},Iie={kernelName:PA,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new Sie(a.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[a,s,i],"float32")}};!function(e){e.Prod="*",e.Sum="+"}(yie||(yie={}));var Cie=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===yie.Prod?"1.0":"0.0",i=n?s:`getX(${Nie(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Lte(a)} coords = getOutputCoords();\n        int end = ${Tie(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${Tie(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Nie(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function Nie(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Tie(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Eie(e,t,n,r,a,s){let i=t.shape.length,o=rU.getAxesPermutation([r],i),l=t;null!=o&&(l=Eae({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=rU.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let c=l.shape[u],d=Jre({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){let t=new Cie(e,l.shape,!1,s),r=[[h]],a=d;d=n.runWebGLProgram(t,[d],d.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){let t=new Cie(e,l.shape,a,s),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){let e=Eae({inputs:{x:d},backend:n,attrs:{perm:rU.getUndoAxesPermutation(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}var Aie={kernelName:FA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return Eie(yie.Prod,a,n,s,i,o)}};var _ie={kernelName:OA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return Eie(yie.Sum,a,n,s,i,o)}};var $ie={kernelName:LA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=Sne(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(s),r=Ine(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},Rie=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};var Die={kernelName:zA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,c=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d=new Rie("NHWC"===i?[o,l,u,c]:[o,c,l,u],s,i);return n.runWebGLProgram(d,[a],a.dtype)}},Mie=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jte(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}},Fie=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jte(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c,h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)h+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){let e=2*g;if(h+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,h+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){let t=i%2===0?ER.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,h+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):h+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(h+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(h+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(h+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}};var Oie={kernelName:BA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r,c=l;null==c&&(c=[1,1]),ER.assert(rU.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));let d,h=rU.computeConv2DInfo(a.shape,s.shape,i,c,o,u,!0);d=HE().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new Fie(h):new Mie(h);let p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[a,s],"float32",p)}},Pie=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Lie=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var zie={kernelName:WA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=rU.computeConv2DInfo(a.shape,c,i,o,l,u,!0),h=new Pie(d);return n.runWebGLProgram(h,[a,s],"float32")}};var Bie={kernelName:VA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=rU.computeConv2DInfo(c,s.shape,i,o,l,u,!0),h=new Lie(d);return n.runWebGLProgram(h,[a,s],"float32")}},Wie=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}};var Vie={kernelName:UA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=ER.sizeFromShape(r.shape),i=bae({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new Wie(s),l=n.runWebGLProgram(o,[i],i.dtype),u=bae({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}},Uie=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}};var jie={kernelName:jA,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dilations:u}=a,c=rU.computeDilation2DInfo(s.shape,i.shape,o,l,"NHWC",u),d=new Uie(c);t=r.runWebGLProgram(d,[s,i],"float32");let h=bae({inputs:{x:t},backend:r,attrs:{shape:c.outShape}});return r.disposeIntermediateTensorInfo(t),h}};var Gie={kernelName:XA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=rU.decodeEinsumEquation(a,s.length);rU.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=rU.getEinsumComputePath(o,l),d=c.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let e of c[m]){let t,{permutationIndices:r,expandDims:a}=rU.getEinsumPermutation(p,l[e]);rU.isIdentityPermutation(r)?t=s[e]:(t=Eae({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);ER.arraysEqual(t.shape,i)||(t=bae({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===h?h=t:(h=gae({inputs:{a:t,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=Nae({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},Hie=uae({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),qie={kernelName:YA,backendName:"webgl",kernelFunc:Hie},Kie={kernelName:QA,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=HE().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Qre("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new Xre("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},Xie=cae({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Ane}),Yie={kernelName:ZA,backendName:"webgl",kernelFunc:Xie},Qie=uae({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${rU.ERF_P};\n  float a1 = ${rU.ERF_A1};\n  float a2 = ${rU.ERF_A2};\n  float a3 = ${rU.ERF_A3};\n  float a4 = ${rU.ERF_A4};\n  float a5 = ${rU.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),Jie={kernelName:JA,backendName:"webgl",kernelFunc:Qie},Zie=uae({opSnippet:lae+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:_ne,dtype:"float32"}),eoe={kernelName:e_,backendName:"webgl",kernelFunc:Zie};function toe(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(ER.assert(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),bae({inputs:{x:s},backend:r,attrs:{shape:o}})}var noe={kernelName:t_,backendName:"webgl",kernelFunc:toe},roe="return exp(x) - 1.0;",aoe=uae({opSnippet:roe,packedOpSnippet:roe,cpuKernelImpl:$ne}),soe={kernelName:n_,backendName:"webgl",kernelFunc:aoe},ioe=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a,s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${r}.0`:"1.0";if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function ooe(e,t,n){let r=n.texData.get(e.dataId),a=ER.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=bae({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),o=i.shape,l=new ioe("real",o,t),u=new ioe("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(l,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),p=eae({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);let f=bae({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}var loe={kernelName:r_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return ooe(r,!1,n)}},uoe=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};function coe(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||ER.inferDtype(a),"string"===s){let e=ER.getArrayFromDType(s,ER.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{let e=new uoe(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}var doe,hoe={kernelName:a_,backendName:"webgl",kernelFunc:coe},poe=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},foe={kernelName:s_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{image:r}=t,a=n,s=new poe(r.shape);return a.runWebGLProgram(s,[r],r.dtype)}},moe="return floor(x);",goe=uae({opSnippet:moe,packedOpSnippet:moe,cpuKernelImpl:Rne}),yoe={kernelName:i_,backendName:"webgl",kernelFunc:goe},boe=cae({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),voe={kernelName:o_,backendName:"webgl",kernelFunc:boe},xoe=class{constructor(e){this.variableNames=["A"];let t=wte(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},woe=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=wte(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},koe={kernelName:cR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],c=[u,l],d=[u,l,s];if(o||i){let e=HE().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==doe||e!==Soe)&&(Soe=e,doe=document.createElement("canvas").getContext("2d",{willReadFrequently:Soe})),doe.canvas.width=l,doe.canvas.height=u,doe.drawImage(a,0,0,l,u),a=doe.canvas}let h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=hee.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);let p=HE().getBool("WEBGL_PACK")?new woe(d):new xoe(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}},Soe=HE().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");var Ioe={kernelName:pR,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=n,{strides:u,pad:c,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=a,g=rU.convertConv2DDataFormat(d),y=rU.computeConv2DInfo(s.shape,i.shape,u,h,c,p,!1,g),b=[],v=null!=o,x=null!=l,w="leakyrelu"===f,k=()=>{let e=[s,i],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=bae({inputs:{x:e},backend:r,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(o,d)),x&&e.push(t(l,d)),w){let t=r.makeTensorInfo([],"float32",ER.createScalarValue(m,"float32"));e.push(t),b.push(t)}return e};if(1!==y.filterHeight||1!==y.filterWidth||1!==y.dilationHeight||1!==y.dilationWidth||1!==y.strideHeight||1!==y.strideWidth||"SAME"!==y.padInfo.type&&"VALID"!==y.padInfo.type)if(y.strideWidth<=2&&"channelsLast"===g&&HE().getBool("WEBGL_EXP_CONV")){let e=f?dae(f,!0):null,n=new nie(y,v,e,x,w),a=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],s=k();t=r.runWebGLProgram(n,s,"float32",a)}else if(HE().getBool("WEBGL_CONV_IM2COL"))t=iie({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{let e=f?dae(f,!1):null,n=new eie(y,v,e,x,w),a=k();t=r.runWebGLProgram(n,a,"float32")}else t=sie({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});let S=bae({inputs:{x:t},backend:r,attrs:{shape:y.outShape}});return b.push(t),b.forEach((e=>r.disposeIntermediateTensorInfo(e))),S}};var Coe={kernelName:fR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[],m=c;null==m&&(m=[1,1]),ER.assert(rU.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));let g,y=rU.computeConv2DInfo(a.shape,s.shape,l,m,u,d,!0),b=HE().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,v=h?dae(h,b):null,x=[a,s],w=null!=i,k=null!=o,S="leakyrelu"===h;if(w&&x.push(i),k&&x.push(o),S){let e=n.makeTensorInfo([],"float32",ER.createScalarValue(p,"float32"));x.push(e),f.push(e)}g=b?new Fie(y,w,v,k,S):new Mie(y,w,v,k,S);let I=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],C=n.runWebGLProgram(g,x,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),C}},Noe=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=Lte(n.length),s="\n    int index;";for(let i=0;i<this.sliceDim;i++)s+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}};var Toe={kernelName:c_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=ER.sizeFromShape(r.shape),[l,u,c,d]=rU.prepareAndValidate(r,a),h=bae({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),p=bae({inputs:{x:r},backend:n,attrs:{shape:[ER.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){let e=n.readSync(a.dataId),t=n.bufferSync(r),s=Dne(e,t,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}let f=new Noe(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=bae({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}},Eoe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Lte(this.rank),r=function(e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}};function Aoe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=ER.parseAxisParam(i,a.shape)[0];if(HE().get("DEBUG")){let e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){let r=e[n];ER.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}let u=rU.segment_util.collectGatherOpShapeInfo(a,s,l,o),c=ER.sizeFromShape(s.shape),d=[],h=bae({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=bae({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);let f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){let e=n.bufferSync(p),t=n.bufferSync(h),r=Mne(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}let m=new Eoe(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);let y=bae({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}var _oe={kernelName:u_,backendName:"webgl",kernelFunc:Aoe},$oe=cae({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Fne,dtype:"bool"}),Roe={kernelName:d_,backendName:"webgl",kernelFunc:$oe},Doe=cae({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:One}),Moe={kernelName:h_,backendName:"webgl",kernelFunc:Doe};var Foe={kernelName:f_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return ooe(r,!0,n)}},Ooe=uae({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Poe={kernelName:g_,backendName:"webgl",kernelFunc:Ooe},Loe=uae({opSnippet:"return float(isinf(x));",dtype:"bool"}),zoe={kernelName:y_,backendName:"webgl",kernelFunc:Loe},Boe=uae({opSnippet:"return float(isnan(x));",dtype:"bool"}),Woe={kernelName:b_,backendName:"webgl",kernelFunc:Boe},Voe=cae({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Pne,dtype:"bool"}),Uoe={kernelName:x_,backendName:"webgl",kernelFunc:Voe},joe=cae({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Lne,dtype:"bool"}),Goe={kernelName:w_,backendName:"webgl",kernelFunc:joe};var Hoe={kernelName:k_,backendName:"webgl",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=zne(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},qoe=uae({opSnippet:lae+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Bne}),Koe={kernelName:S_,backendName:"webgl",kernelFunc:qoe},Xoe=uae({opSnippet:lae+"\n  return log(1.0 + x);\n"}),Yoe={kernelName:I_,backendName:"webgl",kernelFunc:Xoe},Qoe=cae({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Joe={kernelName:C_,backendName:"webgl",kernelFunc:Qoe},Zoe=uae({opSnippet:"return float(!(x >= 1.0));"}),ele={kernelName:N_,backendName:"webgl",kernelFunc:Zoe},tle=cae({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),nle={kernelName:T_,backendName:"webgl",kernelFunc:tle},rle=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}},ale=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}},sle={kernelName:$_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=HE().getBool("WEBGL_PACK_NORMALIZATION")?new ale(a.shape,s,i,o,l):new rle(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)}},ile=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},ole={kernelName:R_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new ile(a.shape,o,l,u,c);return n.runWebGLProgram(d,[a,s,i],a.dtype)}};function lle(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=ER.parseAxisParam(s,a.shape),u=l,c=rU.getAxesPermutation(u,o),d=null!=c,h=n.shouldExecuteOnCPU([a]),p=a;if(d){if(h){let e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=a.shape[c[n]];let r=mre(e,a.shape,a.dtype,c,t);p=n.makeTensorInfo(t,a.dtype),n.texData.get(p.dataId).values=r}else p=Cae(a,c,n);u=rU.getInnerMostAxes(u.length,o)}rU.assertAxesAreInnerMostDims("max",u,o);let f,[m,g]=rU.computeOutAndReduceShapes(p.shape,u),y=m;if(i&&(y=rU.expandShapeToKeepDim(m,l)),h){let e=n.texData.get(p.dataId).values,t=Wne(e,ER.sizeFromShape(g),y,a.dtype);f=n.makeTensorInfo(y,a.dtype),n.texData.get(f.dataId).values=t}else f=function(e,t,n,r){let a=ER.sizeFromShape(t),s=bae({inputs:{x:e},attrs:{shape:[ER.sizeFromShape(e.shape)/a,a]},backend:r}),i=kae(s,e.dtype,"max",r),o=bae({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(p,g,y,n);return d&&n.disposeIntermediateTensorInfo(p),f}var ule={kernelName:M_,backendName:"webgl",kernelFunc:lle},cle=cae({opSnippet:Kre+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Yre+"\n  return result;\n",cpuKernelImpl:Vne}),dle={kernelName:F_,backendName:"webgl",kernelFunc:cle};var hle={kernelName:O_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;vte(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;ER.assert(rU.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u=rU.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&ER.arraysEqual(u.inShape,u.outShape))return Jre({inputs:{x:a},backend:n});let c=new cse(u,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}};var ple={kernelName:L_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=rU.computePool3DInfo(a.shape,s,i,[1,1,1],o,u,l),d=new dse(c,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}},fle=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},mle=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var gle={kernelName:z_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=rU.computePool3DInfo(i.shape,o,l,[1,1,1],u,c),h=new dse(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new mle(d),m=n.runWebGLProgram(f,[a,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};var yle={kernelName:P_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;vte([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=rU.computePool2DInfo(o.shape,l,u,1,c,d),p=new cse(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new fle(h),g=n.runWebGLProgram(m,[a,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};var ble={kernelName:B_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;ER.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));let c=[1,1];ER.assert(rU.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));let d=rU.computePool2DInfo(a.shape,s,i,c,o),[h,p]=function(e,t,n,r){let a=new cse(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");return a=new cse(n,"max",!0,!0,t),[s,r.runWebGLProgram(a,[e],"float32")]}(a,l,d,u);return[h,p]}};var vle={kernelName:W_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{keepDims:s,axis:i}=n,o=r,l=a.shape.length,u=ER.parseAxisParam(i,a.shape),c=u,d=rU.getAxesPermutation(c,l),h=null!=d,p=o.shouldExecuteOnCPU([a]),f=[],m=a;if(h){if(p){let e=o.texData.get(m.dataId).values,t=new Array(l);for(let r=0;r<t.length;r++)t[r]=a.shape[d[r]];let n=mre(e,a.shape,a.dtype,d,t);m=o.makeTensorInfo(t,a.dtype),o.texData.get(m.dataId).values=n}else m=Cae(a,d,o);f.push(m),c=rU.getInnerMostAxes(c.length,l)}rU.assertAxesAreInnerMostDims("sum",c,l);let[g,y]=rU.computeOutAndReduceShapes(m.shape,c),b=g;s&&(b=rU.expandShapeToKeepDim(g,u));let v=function(e,t,n,r){let a=ER.sizeFromShape(t),s=bae({inputs:{x:e},attrs:{shape:[ER.sizeFromShape(e.shape)/a,a]},backend:r}),i=kae(s,"float32","mean",r),o=bae({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(m,y,b,o);for(let x of f)o.disposeIntermediateTensorInfo(x);return v}};var xle={kernelName:V_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=ER.parseAxisParam(s,a.shape),u=l,c=rU.getAxesPermutation(u,o),d=a;null!=c&&(d=Eae({inputs:{x:a},backend:n,attrs:{perm:c}}),u=rU.getInnerMostAxes(u.length,a.shape.length)),rU.assertAxesAreInnerMostDims("min",u,o);let h,[p,f]=rU.computeOutAndReduceShapes(d.shape,u),m=bae({inputs:{x:d},backend:n,attrs:{shape:[-1,ER.sizeFromShape(f)]}}),g=kae(m,m.dtype,"min",n);if(i){h=bae({inputs:{x:g},backend:n,attrs:{shape:rU.expandShapeToKeepDim(p,l)}})}else h=bae({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),h}},wle=cae({opSnippet:Kre+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Yre+"\n  return result;\n",cpuKernelImpl:Une}),kle={kernelName:U_,backendName:"webgl",kernelFunc:wle},Sle=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=Lte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}},Ile=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=Lte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=bre("rc",r),l=bre("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1,h="";if(1===r){let e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{let e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}},Cle={kernelName:j_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r,o=HE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ile(a.shape,s,i):new Sle(a.shape,s,i);return n.runWebGLProgram(o,[a],a.dtype)}},Nle=cae({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Yre+"\n  return result;\n"}),Tle={kernelName:G_,backendName:"webgl",kernelFunc:Nle},Ele=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},Ale=cae({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),_le={kernelName:KA,backendName:"webgl",kernelFunc:Ale},$le="return a - b;",Rle=cae({opSnippet:$le,packedOpSnippet:$le,supportsComplex:!0,cpuKernelImpl:hre}),Dle={kernelName:Q$,backendName:"webgl",kernelFunc:Rle};function Mle(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=ER.parseAxisParam([s],a.shape),o=lle({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=rU.expandShapeToKeepDim(o.shape,i),u=bae({inputs:{x:o},backend:n,attrs:{shape:l}}),c=Rle({inputs:{a:a,b:u},backend:n}),d=Zie({inputs:{x:c},backend:n}),h=Nae({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=bae({inputs:{x:h},backend:n,attrs:{shape:l}}),f=Ale({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}var Fle={kernelName:L$,backendName:"webgl",kernelFunc:Mle};var Ole={kernelName:H_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:Mle({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new Ele(u,c,s),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}},Ple=Nre+"\n  return -x;\n";var Lle={kernelName:K_,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])){let e=r.texData.get(a.dataId),[t,n]=Gne(e.values,a.shape,a.dtype);return r.makeTensorInfo(n,a.dtype,t)}return t=HE().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new zre(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Cre(a.shape,Ple),r.runWebGLProgram(t,[a],a.dtype)}},zle=uj.nonMaxSuppressionV3Impl;var Ble={kernelName:Y_,backendName:"webgl",kernelFunc:function(e){rU.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=zle(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Wle=uj.nonMaxSuppressionV4Impl;var Vle={kernelName:Q_,backendName:"webgl",kernelFunc:function(e){rU.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:p}=Wle(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},Ule=uj.nonMaxSuppressionV5Impl;var jle={kernelName:J_,backendName:"webgl",kernelFunc:function(e){rU.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=Ule(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},Gle=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},Hle={kernelName:e$,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=ER.sizeFromShape(a.shape),c=new Gle(u,i,o,l),d=bae({inputs:{x:a},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],s);n.disposeIntermediateTensorInfo(d);let p=bae({inputs:{x:h},backend:n,attrs:{shape:[...a.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function qle(e){let{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){let e=Dse({inputs:{input:r},backend:n}),t=qle({inputs:{x:e},backend:n}),a=Xse({inputs:{input:r},backend:n}),s=qle({inputs:{x:a},backend:n}),i=eae({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return coe({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var Kle={kernelName:lR,backendName:"webgl",kernelFunc:qle};var Xle={kernelName:Z_,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){let t=Dse({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=Xse({inputs:{input:a},backend:r}),i=qle({inputs:{x:s},backend:r}),o=eae({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return coe({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};var Yle={kernelName:t$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return toe({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{ER.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),ER.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=toe({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=Jse({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},Qle=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=Lte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}},Jle=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=Lte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=bre("rc",r),l=bre("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${d[f]}\n        if (${h}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}},Zle=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===ER.sizeFromShape(a.shape)){let e=s.map(((e,t)=>e[0]+a.shape[t]+e[1]));return coe({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}let o=HE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Jle(a.shape,s,i):new Qle(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},eue={kernelName:n$,backendName:"webgl",kernelFunc:Zle},tue=cae({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Yre+"\n  return result;\n"}),nue={kernelName:a$,backendName:"webgl",kernelFunc:tue};var rue={kernelName:i$,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a,l=s.shape.length,u=[],c=ER.parseAxisParam(i,s.shape),d=c,h=rU.getAxesPermutation(d,l),p=s;if(null!=h&&(p=Eae({inputs:{x:s},backend:r,attrs:{perm:h}}),d=rU.getInnerMostAxes(d.length,l),u.push(p)),rU.assertAxesAreInnerMostDims("prod",d,l),r.shouldExecuteOnCPU([p])){let e=r.texData.get(p.dataId).values,{outVals:n,outShape:a,outDtype:s}=qne(p.shape,p.dtype,e,d);t=r.makeTensorInfo(a,s,n)}else{let[e,n]=rU.computeOutAndReduceShapes(p.shape,d),a=ER.sizeFromShape(n),i=bae({inputs:{x:p},backend:r,attrs:{shape:[-1,a]}}),o=kae(i,ID(s.dtype),"prod",r);t=bae({inputs:{x:o},backend:r,attrs:{shape:e}}),u.push(i),u.push(o)}if(o){u.push(t);let e=rU.expandShapeToKeepDim(t.shape,c);t=bae({inputs:{x:t},backend:r,attrs:{shape:e}})}return u.forEach((e=>r.disposeIntermediateTensorInfo(e))),t}};var aue={kernelName:o$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.readSync(e.dataId))),u=a.map((e=>e.shape)),c=n.readSync(s.dataId),d=n.readSync(i.dataId),[h,p,f]=Kne(l,u,c,s.shape,s.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};var sue={kernelName:l$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=Xne(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var iue={kernelName:u$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),d=n.readSync(i.dataId),h=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=Yne(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}},oue=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=Qne(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},lue={kernelName:c$,backendName:"webgl",kernelFunc:oue},uue=uae({opSnippet:"return 1.0 / x;"}),cue={kernelName:h$,backendName:"webgl",kernelFunc:uue},due=uae({opSnippet:Nre+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),hue={kernelName:p$,backendName:"webgl",kernelFunc:due},pue=uae({opSnippet:Nre+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),fue={kernelName:v$,backendName:"webgl",kernelFunc:pue},mue=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},gue=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}};var yue={kernelName:y$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=HE().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new gue(a.shape,l,u,s,i):new mue(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],"float32")}},bue=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};var vue={kernelName:b$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new bue(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}},xue=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";u=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},wue=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";u=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}};var kue={kernelName:m$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=HE().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new wue(a.shape,l,u,s,i):new xue(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],a.dtype)}},Sue=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};var Iue={kernelName:g$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new Sue(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}},Cue=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);let r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=Lte(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}},Nue=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=bre("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Lte(n);var o;function l(n){let r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o=r.slice(),l(o)};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",l(e)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}};var Tue={kernelName:x$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=ER.parseAxisParam(s,a.shape);if(0===i)return Jre({inputs:{x:a},backend:n});let l=HE().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Nue(a.shape,o):new Cue(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}},Eue=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},Aue={kernelName:dR,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=new Eue(a.shape,i),[c,d]=rU.getImageCenter(o,a.shape[1],a.shape[2]),h=[[c,d,Math.sin(s),Math.cos(s)]];return l.runWebGLProgram(u,[a],a.dtype,h)}},_ue=uae({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),$ue={kernelName:w$,backendName:"webgl",kernelFunc:_ue},Rue=uae({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Jne}),Due={kernelName:k$,backendName:"webgl",kernelFunc:Rue},Mue=class{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let o=Lte(a.length),l=Lte(s.length),u="";1===n?u="i":2===n&&(u="i, j");let c=`getIndices(${u})`,d="";1===r?d="i":2===r&&(d="i, coords[1]");let h=`getUpdates(${d})`,p="";i&&(p="coords[0], coords[1]");let f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}},Fue=class{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let o=Lte(a.length),l=Lte(s.length),u="";1===n?u="i":2===n&&(u="i, j");let c=`getIndices(${u})`,d="";1===r?d="i":2===r&&(d="i, coords[1]");let h=`getUpdates(${d})`,p="";i&&(p="coords[0], coords[1]");let f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${g};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}};var Oue={kernelName:S$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=rU.calculateShapes(s,a,i),h=[d/u,u];if(0===d)return n.makeTensorInfo(i,a.dtype);let p,f=bae({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),m=bae({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));p=HE().getBool("WEBGL_PACK")?new Fue(l,o,f.shape.length,m.shape.length,c,h):new Mue(l,o,f.shape.length,m.shape.length,c,h);let y=n.runWebGLProgram(p,[m,f,g],m.dtype),b=bae({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(g),b}},Pue=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===HE().getNumber("WEBGL_VERSION")?"while (left < right) {":a,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}};var Lue={kernelName:C$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new Pue(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}},zue=class{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{let n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}let s=Lte(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}};var Bue={kernelName:N$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new zue(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],SD(a.dtype,s.dtype))}},Wue=uae({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${rU.SELU_SCALEALPHA};\n  float scale = ${rU.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),Vue={kernelName:T$,backendName:"webgl",kernelFunc:Wue},Uue=uae({opSnippet:lae+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:ere}),jue={kernelName:R$,backendName:"webgl",kernelFunc:Uue},Gue=uae({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Hue={kernelName:$$,backendName:"webgl",kernelFunc:Gue},que=uae({opSnippet:lae+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Yre}\n  return result;\n`}),Kue={kernelName:A$,backendName:"webgl",kernelFunc:que},Xue=uae({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Yue={kernelName:_$,backendName:"webgl",kernelFunc:Xue},Que=uae({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Jue={kernelName:D$,backendName:"webgl",kernelFunc:Que},Zue={kernelName:O$,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;ER.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let u=[],c=Zle({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=rU.getReshaped(c.shape,s,o,!1),h=rU.getPermuted(d.length,s.length,!1),p=rU.getReshapedPermuted(c.shape,s,o,!1),f=bae({inputs:{x:c},backend:n,attrs:{shape:d}}),m=Eae({inputs:{x:f},backend:n,attrs:{perm:h}}),g=bae({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};var ece={kernelName:z$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=rre(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var tce={kernelName:B$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,d]=are(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var nce={kernelName:W$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=sre(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};var rce={kernelName:V$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=sre(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};var ace={kernelName:U$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=rU.calculateShapes(s,a,o),p=!1;if("string"===s.dtype){let e=n.bufferSync(a),t=n.bufferSync(s),r=ER.decodeString(n.readSync(i.dataId)[0]),f=Zne(e,t,o,h,c,u,l,d,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}let f=new Mue(u,l,a.shape.length,s.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=bae({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};var sce={kernelName:P$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=ER.parseAxisParam(i,a.shape)[0],l=rU.prepareSplitSize(a,s,o),u=a.shape.length,c=new Array(u).fill(0),d=a.shape.slice();return l.map((e=>{let t=[...d];t[o]=e;let r=Cse({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},ice="return sqrt(x);",oce=uae({opSnippet:ice,packedOpSnippet:ice,cpuKernelImpl:ire}),lce={kernelName:M$,backendName:"webgl",kernelFunc:oce},uce=uae({opSnippet:"return x * x;"}),cce={kernelName:G$,backendName:"webgl",kernelFunc:uce},dce="return (a - b) * (a - b);",hce=cae({opSnippet:dce,packedOpSnippet:dce}),pce={kernelName:j$,backendName:"webgl",kernelFunc:hce};var fce={kernelName:H$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");let s=n.readSync(a.dataId),i=rU.fromUint8ToStringArray(s),o=ore(i,"string",r);return n.makeTensorInfo(a.shape,"string",o)}};var mce={kernelName:uR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,s=Nre+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,i=new Cre(a.shape,s);return r.runWebGLProgram(i,[a],a.dtype)}},gce=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=Lte(n.length),s=Lte(n.length),i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}};var yce={kernelName:q$,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{begin:i,end:o,strides:l,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=$V.sliceInfo(s.shape,i,o,l,u,c,d,h,p);if(g)t=bae({inputs:{x:s},backend:r,attrs:{shape:m}});else if(y||b){ER.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=$V.computeOutShape(v,x,w),n=Cse({inputs:{x:s},backend:r,attrs:{begin:v,size:e}});t=bae({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeIntermediateTensorInfo(n)}else if(r.shouldExecuteOnCPU([s])){let e=r.readSync(s.dataId),n=wF(s.shape,s.dtype,e),a=lre(f,n,w,v);t=r.makeTensorInfo(m,s.dtype,a.values)}else{let e=new gce(v,w,f);t=r.runWebGLProgram(e,[s],s.dtype)}let k=bae({inputs:{x:t},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(t),k}};var bce={kernelName:K$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=ure(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var vce={kernelName:X$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=cre(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var xce={kernelName:Y$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=dre(i,a);return n.makeTensorInfo(s.shape,"int32",o)}},wce=uae({opSnippet:"return tan(x);"}),kce={kernelName:J$,backendName:"webgl",kernelFunc:wce},Sce=uae({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Ice={kernelName:Z$,backendName:"webgl",kernelFunc:Sce};var Cce={kernelName:I$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=rU.calculateShapes(i,s,a.shape),h=[d/u,u];if(0===d)return n.makeTensorInfo(a.shape,s.dtype);let p=bae({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=bae({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=bae({inputs:{x:a},backend:n,attrs:{shape:h}}),g=new Mue(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=bae({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}},Nce=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let r=Lte(this.rank),a=function(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}};function Tce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){let e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>ER.decodeString(e))):e,r=wF(a.shape,a.dtype,t),i=pre(r,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}let i=new Nce(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var Ece={kernelName:eR,backendName:"webgl",kernelFunc:Tce},Ace=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}},_ce=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function $ce(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function Rce(e){let t=1;for(;t<e;)t*=2;return t}var Dce={kernelName:tR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=HE().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=HE().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([a])||c<o||s>l){let e=n.readSync(a.dataId),[t,r]=fre(e,u,a.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[a,coe({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let d=n.texData.get(a.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(a):a,f=ER.sizeFromShape(u)/c,m=bae({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&$ce(n,p);let g=Rce(s),y=Rce(c),b=null,v=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{let a=v(),s=new Ace(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(s,a,"int32",i),$ce(n,o)};for(let C=1;C<g;C*=2){let e=2*C;for(let t=C;t>=1;t/=2)x(e,t,[f,y])}for(let C=y;C>g;C/=2){let e=v(),t=new _ce([f,C/2]),r=[[c],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(t,e,"int32",r),$ce(n,a);let s=g/2,i=2*s;for(let n=s;n>=1;n/=2)x(i,n,b.shape)}let w=b;b=Cse({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),$ce(n,w);let k=Aoe({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});$ce(n,m);let S=u.slice(0,-1);S.push(s),w=b,b=bae({inputs:{x:b},attrs:{shape:S},backend:n}),$ce(n,w);let I=k;return k=bae({inputs:{x:k},attrs:{shape:S},backend:n}),$ce(n,I),[k,b]}},Mce=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i,o="nearest"===n?1:2;switch(r){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}};var Fce={kernelName:nR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=new Mce(d,h,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[a,s],"float32")}};var Oce={kernelName:aR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;vte(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=gre(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};var Pce={kernelName:sR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1),c=0;for(let m=0;m<o;m++)m!==s&&(u[c++]=i.shape[m]);let d=[],h=new Array(o).fill(0),p=i.shape.slice();p[s]=1;let f=new Array(l);for(let m=0;m<f.length;m++){h[s]=m;let e=Cse({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),t=bae({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}},Lce=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ",c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}};var zce,Bce,Wce,Vce={kernelName:iR,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],u=0,c=rU.getAxesPermutation([u],o),d=a;null!=c&&(d=Eae({inputs:{x:a},backend:n,attrs:{perm:c}}),l.push(d),u=rU.getInnerMostAxes(1,o)[0]);let h=rU.segment_util.computeOutShape(d.shape,u,i),p=ER.sizeFromShape([d.shape[u]]),f=bae({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);let m=ID(a.dtype),g=(e,t,r,a,s)=>{let i=e.shape[0],o=e.shape[1],u=rU.segment_util.segOpComputeOptimalWindowSize(o,s),c=new Lce({windowSize:u,inSize:o,batchSize:i,numSegments:s},t),d=n.compileAndRun(c,[e,r],a);if(l.push(d),d.shape[1]===s)return d;let h=oue({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=Tce({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});return l.push(h),l.push(p),g(d,t,p,a,s)},y=bae({inputs:{x:g(f,"unsortedSegmentSum",s,m,i)},backend:n,attrs:{shape:h}}),b=y;if(null!=c){l.push(y);let e=rU.getUndoAxesPermutation(c);b=Eae({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},Uce=[Rae,Mae,Oae,Lae,Wae,jae,Gae,Hae,Jae,Zae,tse,rse,sse,ose,use,hse,pse,gse,yse,bse,wse,Tse,Ese,Ase,_se,Ose,zse,Vse,tae,Gse,Zse,oie,hie,fie,mie,gie,bie,xie,kie,Iie,Aie,_ie,$ie,Die,Oie,zie,Bie,Vie,jie,Gie,qie,Kie,Yie,Jie,eoe,noe,soe,loe,hoe,foe,yoe,voe,koe,Ioe,Coe,Toe,_oe,Roe,Moe,Zre,Foe,Yse,Poe,zoe,Woe,aae,Uoe,Goe,Hoe,Koe,Yoe,Joe,ele,nle,sle,ole,ule,dle,hle,ple,gle,yle,ble,vle,xle,kle,Cle,Tle,Ole,yae,Lle,Ble,Vle,jle,Rse,Hle,Xle,Yle,eue,nue,oae,rue,aue,sue,iue,lue,Mse,_le,cue,hue,fue,vae,yue,vue,kue,Iue,Tue,Aue,$ue,Due,Oue,Lue,Bue,Vue,jue,Hue,Kue,Yue,Nse,Fle,Jue,Zue,ece,tce,nce,rce,ace,sce,lce,cce,pce,fce,mce,yce,bce,vce,xce,Dle,Tae,kce,Ice,Cce,Ece,Dce,Fce,Aae,Oce,Pce,Vce,Kle];for(let n of Uce)kR(n);!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(zce||(zce={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(Bce||(Bce={}));var jce={kernelName:hR,backendName:"wasm",setupFunc:function(e){Wce=e.wasm.cwrap(hR,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,h=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=0;if(null!=i){let e=n.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}let m=null==o?0:n.dataIdMap.get(o.dataId).id,g=Bce[c];if(null==g)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=u?s.shape[1]:s.shape[2],v=GO.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),x=n.makeOutput([...v,y,b],a.dtype),w=n.dataIdMap.get(x.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer),S=new Uint8Array(new Int32Array(s.shape).buffer);return Wce(h,k,a.shape.length,p,S,s.shape.length,l,u,g,f,m,d||0,w),x}};function Gce(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){let{backend:r,inputs:{x:a}}=e,s=r.dataIdMap.get(a.dataId).id,i=r.makeOutput(a.shape,t||a.dtype),o=r.dataIdMap.get(i.dataId).id;return 0===ER.sizeFromShape(i.shape)||n(s,zce[a.dtype],o),i}}}var Hce=Gce(QE),qce=Gce(JE),Kce=Gce(ZE);function Xce(e,t,n){let r;return{kernelName:e,backendName:"wasm",setupFunc:function(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:a}=e,{a:s,b:i}=a,o=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(i.dataId).id,u=null!=n?n:s.dtype,c=rU.assertAndGetBroadcastShape(s.shape,i.shape),d=t.makeOutput(c,u);if(0===ER.sizeFromShape(c))return d;let h=new Uint8Array(new Int32Array(s.shape).buffer),p=new Uint8Array(new Int32Array(i.shape).buffer),f=t.dataIdMap.get(d.dataId).id;return r(o,h,s.shape.length,l,p,i.shape.length,zce[s.dtype],f),d}}}var Yce,Qce=Xce(eA);var Jce={kernelName:tA,backendName:"wasm",setupFunc:function(e){Yce=e.wasm.cwrap(tA,null,["array","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===ER.sizeFromShape(r.shape))return r;let a=t.map((e=>n.dataIdMap.get(e.dataId).id)),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return Yce(s,a.length,zce[r.dtype],i),r}};function Zce(e){let{inputs:{x:t},backend:n}=e;if("string"===t.dtype)return ZD(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var ede,tde={kernelName:p_,backendName:"wasm",kernelFunc:Zce};function nde(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=function(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let a=0;a<r.length;++a){let e=-1;for(let t=0;t<r.length;++t)r[t]>=a&&(-1===e||r[e]>r[t])&&(e=t);r[e]=a}return[n,r]}(t.x.shape,r.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=function(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let e=Zce({inputs:t,backend:n});return e.shape=o,e}let u=n.makeOutput(o,l.dtype),c=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,h=new Uint8Array(new Int32Array(s).buffer),p=new Uint8Array(new Int32Array(l.shape).buffer);return ede(c,p,l.shape.length,zce[l.dtype],d,h,s.length),u}var rde,ade={kernelName:rR,backendName:"wasm",kernelFunc:nde,setupFunc:function(e){ede=e.wasm.cwrap(rR,null,["number","array","number","number","number","array","number"])}};function sde(e,t,n){let r=e.shape,a=e.shape.length,s=ER.parseAxisParam(t,r),i=s,o=rU.getAxesPermutation(i,a),l=null,u=!1;if(null!=o){let t=new Array(a);for(let e=0;e<t.length;e++)t[e]=r[o[e]];i=rU.getInnerMostAxes(i.length,a),l=nde({inputs:{x:e},attrs:{perm:o},backend:n});let s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==s&&(u=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:u}}var ide,ode={kernelName:nA,backendName:"wasm",setupFunc:function(e){rde=e.wasm.cwrap(nA,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=sde(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let p=l.shape.length;rU.assertAxesAreInnerMostDims("all",c,p);let[f,m]=rU.computeOutAndReduceShapes(l.shape,c),g=ER.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==ER.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;rde(o,g,e)}if(h&&t.disposeData(u.dataId),s){let e=rU.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}};var lde={kernelName:rA,backendName:"wasm",setupFunc:function(e){ide=e.wasm.cwrap(rA,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=sde(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let p=l.shape.length;rU.assertAxesAreInnerMostDims("any",c,p);let[f,m]=rU.computeOutAndReduceShapes(l.shape,c),g=ER.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==ER.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;ide(o,g,e)}if(h&&t.disposeData(u.dataId),s){let e=rU.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}};function ude(e){let t;return{kernelName:e,backendName:"wasm",setupFunc:function(n){t=n.wasm.cwrap(e,null,["number","number","number","number","number"])},kernelFunc:function(e){let{backend:n,inputs:r,attrs:a}=e,{axis:s}=a,{x:i}=r,o=n.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,inputWasTransposed:h}=sde(i,s,n);if(h){let e=n.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e)}let p=u.shape.slice(0,-1),f=n.makeOutput(p,"int32"),m=n.dataIdMap.get(f.dataId).id,g=ER.sizeFromShape(f.shape),y=u.shape[d[0]];return t(l,zce[u.dtype],g,y,m),h&&n.disposeData(c.dataId),f}}}var cde,dde=ude(aA),hde=ude(sA),pde=Gce(iA),fde=Gce(oA),mde=Gce(lA),gde=Xce(cA),yde=Gce(uA);var bde,vde={kernelName:dA,backendName:"wasm",setupFunc:function(e){cde=e.wasm.cwrap(dA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=rU.computePool2DInfo(a.shape,i,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,b=c.strideWidth,v=c.inChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(1!==c.dilationWidth||1!==c.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let x=r.makeOutput(c.outShape,"float32"),w=r.dataIdMap.get(x.dataId).id;return cde(s,a.shape[0],a.shape[1],a.shape[2],d,h,p,f,m,g,y,b,v,w),x}};var xde,wde={kernelName:pA,backendName:"wasm",setupFunc:function(e){bde=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=rU.computePool3DInfo(a.shape,s,i,1,o,l,u),d=n.makeOutput(c.outShape,a.dtype);return bde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};var kde,Sde={kernelName:fA,backendName:"wasm",setupFunc:function(e){xde=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=rU.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return xde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),d}};var Ide={kernelName:hA,backendName:"wasm",setupFunc:function(e){kde=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l}=r,u=rU.computePool2DInfo(s.shape,i,o,1,l),c=n.makeOutput(s.shape,s.dtype);return kde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),c}};function Cde(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=ER.sizeFromShape(r.shape),i=ER.inferFromImplicitShape(a,s);return ER.assert(s===ER.sizeFromShape(i),(()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var Nde,Tde={kernelName:f$,backendName:"wasm",kernelFunc:Cde};var Ede={kernelName:mA,backendName:"wasm",setupFunc:function(e){Nde=e.wasm.cwrap(mA,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=ER.sizeFromShape(f),y=ER.sizeFromShape(m),b=GO.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);ER.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let v=o?[y,p,d]:[y,d,p],x=Cde({inputs:{x:a},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=Cde({inputs:{x:s},backend:n,attrs:{shape:v}}),k=n.dataIdMap.get(x.dataId).id,S=n.dataIdMap.get(w.dataId).id,I=i?x.shape[2]:x.shape[1],C=o?w.shape[1]:w.shape[2],N=Math.max(g,y),T=n.makeOutput([N,I,C],x.dtype),E=n.dataIdMap.get(T.dataId).id,A=new Uint8Array(new Int32Array(x.shape).buffer),_=new Uint8Array(new Int32Array(w.shape).buffer);return Nde(k,A,x.shape.length,S,_,w.shape.length,i,o,E),n.disposeData(x.dataId),n.disposeData(w.dataId),T.shape=b,T}};function Ade(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=$V.parseSliceParams(t,n,r),o=$V.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),u=a.makeOutput(i,t.dtype),c=ER.computeStrides(t.shape),d=a.dataIdMap.get(u.dataId);if(o){let e=$V.computeFlatOffset(s,c);return"string"===t.dtype?d.stringBytes=l.slice(e,e+ER.sizeFromShape(i)):a.typedArrayFromHeap(u).set(l.subarray(e,e+ER.sizeFromShape(i))),u}if("string"===t.dtype){let e=T5(l,s,i,t.shape,t.dtype);return d.stringBytes=e,u}let h=a.typedArrayFromHeap(u),p=t.shape.length;if(2===p)!function(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let u=i;u<l;u++){let r=u*t+o;n.set(e.subarray(r,r+a[1]),s),s+=a[1]}}(l,c[0],h,s,i);else if(3===p)!function(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],u=a[2],c=o+s[0],d=l+s[1];for(let h=o;h<c;h++)for(let a=l;a<d;a++){let o=h*t+a*n+u;r.set(e.subarray(o,o+s[2]),i),i+=s[2]}}(l,c[0],c[1],h,s,i);else if(4===p)!function(e,t,n,r,a,s,i){let o=0,l=s[0],u=s[1],c=s[2],d=l+i[0],h=u+i[1],p=c+i[2],f=s[3];for(let m=l;m<d;m++)for(let s=u;s<h;s++)for(let l=c;l<p;l++){let u=m*t+s*n+l*r+f;a.set(e.subarray(u,u+i[3]),o),o+=i[3]}}(l,c[0],c[1],c[2],h,s,i);else{let e=T5(l,s,i,t.shape,t.dtype);h.set(e)}return u}var _de={kernelName:E$,backendName:"wasm",kernelFunc:Ade};var $de,Rde={kernelName:gA,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce(((e,t)=>e*t)),l=rU.getReshaped(a.shape,s,o),u=rU.getPermuted(l.length,s.length),c=rU.getReshapedPermuted(a.shape,s,o),d=rU.getSliceBeginCoords(i,s.length),h=rU.getSliceSize(c,i,s.length),p=Cde({inputs:{x:a},backend:n,attrs:{shape:l}}),f=nde({inputs:{x:p},backend:n,attrs:{perm:u}}),m=Cde({inputs:{x:f},backend:n,attrs:{shape:c}}),g=Ade({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}};var Dde={kernelName:yA,backendName:"wasm",setupFunc:function(e){$de=e.wasm.cwrap(yA,null,["number","number","boolean","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i}=r,o=0!==s.shape.reduce(((e,t)=>e*t),1),l=1===a.shape.length?[i]:[a.shape[0],i],u=t.makeOutput(l,s.dtype);function c(e){return t.dataIdMap.get(e.dataId).id}return $de(c(a),i,o,c(s),zce[s.dtype],c(u)),u}},Mde=Xce(bA);var Fde={kernelName:xA,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(a),o=rU.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}};function Ode(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var Pde,Lde={kernelName:wA,backendName:"wasm",kernelFunc:Ode},zde=Gce(kA);var Bde={kernelName:SA,backendName:"wasm",setupFunc:function(e){Pde=e.wasm.cwrap(SA,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return Pde(o,s,i,u),l}};function Wde(e){let{inputs:t,backend:n}=e,r=ER.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map((e=>e.shape));rU.assertParamsConsistent(a,r);let s=rU.computeOutShape(t.map((e=>e.shape)),r),i=t.filter((e=>ER.sizeFromShape(e.shape)>0));if(1===i.length)return Zce({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(0===ER.sizeFromShape(s))return o;if("string"===i[0].dtype){let e=i.map((e=>{let t=[-1,ER.sizeFromShape(e.shape.slice(r))];return Cde({inputs:{x:e},backend:n,attrs:{shape:t}})})),a=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));s=rU.computeOutShape(e.map((e=>e.shape)),1);let l=1===e[0].shape[0],u=o4(a,s,t[0].dtype,l),c=rU.computeOutShape(i.map((e=>e.shape)),r);return o.shape=c,n.dataIdMap.get(o.dataId).stringBytes=rU.fromStringArrayToUint8(u),e.forEach((e=>n.disposeData(e.dataId))),o}let l=ER.sizeFromShape(i[0].shape.slice(0,r)),u=0,c=i.map((e=>{let t=ER.sizeFromShape(e.shape.slice(r));return u+=t,t})),d=i.map((e=>n.typedArrayFromHeap(e))),h=n.typedArrayFromHeap(o);for(let p=0;p<l;p++){let e=p*u;for(let t=0;t<d.length;t++){let n=c[t],r=p*n,a=d[t].subarray(r,r+n);h.set(a,e),e+=n}}return o}var Vde,Ude={kernelName:NA,backendName:"wasm",kernelFunc:Wde};var jde,Gde={kernelName:TA,backendName:"wasm",setupFunc:function(e){Vde=e.wasm.cwrap(TA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d,dataFormat:h}=n,p=rU.convertConv2DDataFormat(h),f=rU.computeConv2DInfo(a.shape,s.shape,l,u,c,d,!1,p),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,v=f.padInfo.bottom,x=f.padInfo.left,w=f.dilationHeight,k=f.dilationWidth,S=f.strideHeight,I=f.strideWidth,C=f.inChannels,N=f.outChannels,T="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let E=r.makeOutput(f.outShape,"float32"),A=r.dataIdMap.get(E.dataId).id;return Vde(i,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,b,v,x,T,w,k,S,I,C,N,A),E}};var Hde,qde={kernelName:AA,backendName:"wasm",setupFunc:function(e){jde=e.wasm.cwrap(AA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:c}=r,d=rU.convertConv2DDataFormat(l),h=rU.computeConv2DInfo(c,s.shape,i,1,o,u,!1,d),{batchSize:p,filterHeight:f,filterWidth:m,inChannels:g,inHeight:y,inWidth:b,outChannels:v,outHeight:x,outWidth:w,strideHeight:k,strideWidth:S}=h,I=f-1-h.padInfo.top,C=m-1-h.padInfo.left,N="channelsLast"===h.dataFormat,T=ER.computeStrides(h.inShape),E=ER.computeStrides(a.shape),[A,_,$]=ER.computeStrides(s.shape),R=T[0],D=N?T[1]:T[2],M=N?T[2]:1,F=N?1:T[1],O=E[0],P=N?E[1]:E[2],L=N?E[2]:1,z=N?1:E[1],B=t.makeOutput(h.inShape,"float32"),W=t.dataIdMap.get(B.dataId).id,V=t.dataIdMap.get(a.dataId).id,U=t.dataIdMap.get(s.dataId).id;return jde(V,U,p,f,m,y,b,g,x,w,v,k,S,I,C,A,_,$,R,D,M,F,O,P,L,z,W),B}};var Kde,Xde={kernelName:_A,backendName:"wasm",setupFunc:function(e){Hde=e.wasm.cwrap(_A,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=rU.computeConv3DInfo(a.shape,s.shape,i,l,o),c=n.makeOutput(u.outShape,a.dtype);return Hde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}};var Yde,Qde={kernelName:$A,backendName:"wasm",setupFunc:function(e){Kde=e.wasm.cwrap($A,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=rU.computeConv3DInfo(a.shape,l,i,1,o),c=n.makeOutput(u.filterShape,s.dtype);return Kde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}};var Jde,Zde,ehe={kernelName:RA,backendName:"wasm",setupFunc:function(e){Yde=e.wasm.cwrap(RA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=rU.computeConv3DInfo(l,s.shape,o,1,i),c=n.makeOutput(u.inShape,a.dtype);return Yde(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}},the=Gce(DA),nhe=Gce(MA);!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(Jde||(Jde={}));var rhe,ahe={kernelName:PA,backendName:"wasm",setupFunc:function(e){Zde=e.wasm.cwrap(PA,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{method:s,extrapolationValue:i,cropSize:o}=a,{image:l,boxes:u,boxInd:c}=r,d=u.shape[0],[h,p]=o,f=[d,h,p,l.shape[3]],m=n.dataIdMap.get(l.dataId);"float32"!==l.dtype&&(t=Ode({backend:n,inputs:{x:l},attrs:{dtype:"float32"}}),m=n.dataIdMap.get(t.dataId));let g=m.id,y=n.dataIdMap.get(u.dataId).id,b=n.dataIdMap.get(c.dataId).id,v=n.makeOutput(f,"float32"),x=n.dataIdMap.get(v.dataId).id,w=new Uint8Array(new Int32Array(l.shape).buffer);return Zde(g,y,b,d,w,h,p,Jde[s],i,x),null!=t&&n.disposeData(t.dataId),v}};var she,ihe={kernelName:FA,backendName:"wasm",setupFunc:function(e){rhe=e.wasm.cwrap(FA,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;ER.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));let u=rU.getAxesPermutation([s],l),c=a;null!==u&&(c=nde({inputs:{x:a},attrs:{perm:u},backend:n}));let d=rU.getInnerMostAxes(1,l)[0];rU.assertAxesAreInnerMostDims("cumprod",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;rhe(f,i?1:0,o?1:0,p,m,zce[a.dtype]);let g=h;if(null!==u){g=nde({inputs:{x:h},attrs:{perm:rU.getUndoAxesPermutation(u)},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return g}};var ohe,lhe={kernelName:OA,backendName:"wasm",setupFunc:function(e){she=e.wasm.cwrap(OA,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;ER.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));let u=rU.getAxesPermutation([s],l),c=a;null!==u&&(c=nde({inputs:{x:a},attrs:{perm:u},backend:n}));let d=rU.getInnerMostAxes(1,l)[0];rU.assertAxesAreInnerMostDims("cumsum",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;she(f,i?1:0,o?1:0,p,m,zce[a.dtype]);let g=h;if(null!==u){g=nde({inputs:{x:h},attrs:{perm:rU.getUndoAxesPermutation(u)},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return g}};var uhe,che={kernelName:LA,backendName:"wasm",setupFunc:function(e){ohe=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i,binaryOutput:o}=r,l=0!==s.shape.reduce(((e,t)=>e*t),1),u=1===a.shape.length?[i]:[a.shape[0],i],c=t.makeOutput(u,s.dtype);function d(e){return t.dataIdMap.get(e.dataId).id}return ohe(d(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,i,l,d(s),zce[s.dtype],o,d(c)),c}};var dhe,hhe={kernelName:zA,backendName:"wasm",setupFunc:function(e){uhe=e.wasm.cwrap(zA,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,c=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d="NHWC"===i?[o,l,u,c]:[o,c,l,u],h=t.makeOutput(d,"float32"),p=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(ER.computeStrides(a.shape)).buffer),m=new Uint8Array(new Int32Array(d).buffer),g=new Uint8Array(new Int32Array(ER.computeStrides(d)).buffer),y=t.dataIdMap.get(h.dataId).id;return uhe(p,s,"NHWC"===i?1:0,f,a.shape.length-1,m,g,d.length,y),h}};var phe,fhe={kernelName:BA,backendName:"wasm",setupFunc:function(e){dhe=e.wasm.cwrap(BA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d}=n,h=null==u?[1,1]:u,p=rU.computeConv2DInfo(a.shape,s.shape,l,h,c,d,!0),f=p.filterHeight,m=p.filterWidth,g=p.padInfo.top,y=p.padInfo.right,b=p.padInfo.bottom,v=p.padInfo.left,x=p.dilationHeight,w=p.dilationWidth,k=p.strideHeight,S=p.strideWidth,I=p.inChannels,C=p.outChannels,N="SAME"===p.padInfo.type?1:0;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let T=r.makeOutput(p.outShape,"float32"),E=r.dataIdMap.get(T.dataId).id;return dhe(i,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,b,v,N,x,w,k,S,I,C,E),T}};var mhe,ghe={kernelName:UA,backendName:"wasm",setupFunc:function(e){phe=e.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=ER.sizeFromShape(r.shape),s=n.makeOutput([...r.shape,...r.shape],r.dtype);return phe(n.dataIdMap.get(r.dataId).id,zce[r.dtype],a,n.dataIdMap.get(s.dataId).id),s}};var yhe,bhe={kernelName:jA,backendName:"wasm",setupFunc:function(e){mhe=e.wasm.cwrap(jA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${s.dtype}`);let u=rU.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),c=n.makeOutput(u.outShape,a.dtype);return mhe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,zce[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),c}};var vhe,xhe={kernelName:HA,backendName:"wasm",setupFunc:function(e){yhe=e.wasm.cwrap(HA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let c=rU.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),d=n.makeOutput(s.shape,s.dtype);return yhe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,zce[a.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}};var whe,khe={kernelName:GA,backendName:"wasm",setupFunc:function(e){vhe=e.wasm.cwrap(GA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let c=rU.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),d=n.makeOutput(a.shape,a.dtype);return vhe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,zce[a.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}},She=Gce(YA);var Ihe={kernelName:QA,backendName:"wasm",setupFunc:function(e){whe=e.wasm.cwrap(QA,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=n.makeOutput(a.shape,"float32"),i=e=>n.dataIdMap.get(e.dataId).id;return whe(i(a),i(r),i(s)),s}},Che=Xce(ZA,0,"bool"),Nhe=Gce(JA),The=Gce(e_,"float32");function Ehe(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(ER.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),Cde({inputs:{x:a},backend:r,attrs:{shape:o}})}var Ahe={kernelName:t_,backendName:"wasm",kernelFunc:Ehe},_he=Gce(n_,"float32");function $he(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:a}}=e;a=a||ER.inferDtype(n);let s=r.makeOutput(t,a);return r.typedArrayFromHeap(s).fill(n),s}var Rhe,Dhe={kernelName:a_,backendName:"wasm",kernelFunc:$he};var Mhe,Fhe={kernelName:s_,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,u,c]=r.shape;return Rhe(s,o,l,u,c,i),a},setupFunc:function(e){Rhe=e.wasm.cwrap(s_,null,["number","number","number","number","number","number"])}},Ohe=Gce(i_),Phe=Xce(o_);var Lhe,zhe={kernelName:l_,backendName:"wasm",setupFunc:function(e){Mhe=e.wasm.cwrap(l_,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:u}=n,c=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(o.dataId).id,p=null!=l?t.dataIdMap.get(l.dataId).id:0,f=null!=u?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(0===ER.sizeFromShape(s.shape))return m;let g=t.dataIdMap.get(m.dataId).id;return Mhe(c,d,h,p,f,a,g),m}};var Bhe,Whe={kernelName:pR,backendName:"wasm",setupFunc:function(e){Lhe=e.wasm.cwrap(pR,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=rU.computeConv2DInfo(a.shape,s.shape,l,c,u,h),g=Bce[p];if(null==g)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,v=m.outChannels,x=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==v)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${v})`);x=e.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,C=m.padInfo.bottom,N=m.padInfo.left,T=m.dilationHeight,E=m.dilationWidth,A=m.strideHeight,_=m.strideWidth,$=m.inChannels,R="SAME"===m.padInfo.type?1:0,D=m.batchSize,M=m.inHeight,F=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),P=r.dataIdMap.get(O.dataId).id,L=null==o?0:r.dataIdMap.get(o.dataId).id;return Lhe(y,D,M,F,b,w,k,x,S,I,C,N,R,T,E,A,_,$,v,g,L,f||0,P),O}};var Vhe,Uhe={kernelName:fR,backendName:"wasm",setupFunc:function(e){Bhe=e.wasm.cwrap(fR,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=rU.computeConv2DInfo(a.shape,s.shape,l,c,u,h,!0),g=Bce[p];if(null==g)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,v=m.outChannels,x=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==v)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${v})`);x=e.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,C=m.padInfo.bottom,N=m.padInfo.left,T=m.dilationHeight,E=m.dilationWidth,A=m.strideHeight,_=m.strideWidth,$=m.inChannels,R="SAME"===m.padInfo.type?1:0,D=m.batchSize,M=m.inHeight,F=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),P=r.dataIdMap.get(O.dataId).id,L=null==o?0:r.dataIdMap.get(o.dataId).id;return Bhe(y,D,M,F,b,w,k,x,S,I,C,N,R,T,E,A,_,$,v,g,L,f||0,P),O}};var jhe,Ghe={kernelName:c_,backendName:"wasm",setupFunc:function(e){Vhe=e.wasm.cwrap(c_,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=AV.prepareAndValidate(r,a),u=t.makeOutput(s,r.dtype);if(0===i)return u;let c=a.shape,d=c[c.length-1],h=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return Vhe(h,zce[r.dtype],p,i,d,o,f,m),u}};var Hhe,qhe={kernelName:u_,backendName:"wasm",setupFunc:function(e){jhe=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=ER.parseAxisParam(i,a.shape)[0],u=t.readSync(s.dataId),c=a.shape[l];for(let S=0;S<u.length;++S){let e=u[S];ER.assert(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let d=rU.segment_util.collectGatherOpShapeInfo(a,s,l,o),h=Cde({inputs:{x:a},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),p=ER.sizeFromShape(s.shape),f=Cde({inputs:{x:s},attrs:{shape:[d.batchSize,p/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize],g=t.makeOutput(m,a.dtype);if(0===ER.sizeFromShape(a.shape))return g;let y=h.shape.length-1,b=t.dataIdMap.get(h.dataId).id,v=t.dataIdMap.get(f.dataId).id,x=t.dataIdMap.get(g.dataId).id,w=new Uint8Array(new Int32Array(ER.computeStrides(h.shape)).buffer),k=new Uint8Array(new Int32Array(ER.computeStrides(m)).buffer);return jhe(b,zce[a.dtype],w,y,v,d.batchSize,k,x),t.disposeData(h.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}},Khe=Xce(d_,0,"bool"),Xhe=Xce(h_,0,"bool"),Yhe=Gce(g_,"bool"),Qhe=Gce(y_,"bool"),Jhe=Gce(b_,"bool");var Zhe,epe={kernelName:v_,backendName:"wasm",setupFunc:function(e){Hhe=e.wasm.cwrap(v_,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(0!==ER.sizeFromShape(t.shape)){let e=r.dataIdMap.get(s.dataId).id;Hhe(a,zce[t.dtype],n,e)}return s}},tpe=Xce(x_,0,"bool"),npe=Xce(w_,0,"bool");var rpe,ape={kernelName:k_,backendName:"wasm",setupFunc:function(e){Zhe=e.wasm.cwrap(k_,null,["number","number","number","number"])},kernelFunc:function(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return Zhe(n.dataIdMap.get(o.dataId).id,r,a,i),o}},spe=Gce(S_),ipe=Gce(I_),ope=Xce(C_,0,"bool"),lpe=Gce(N_),upe=Xce(T_,0,"bool"),cpe=Xce(E_,0,"bool");var dpe,hpe={kernelName:$_,backendName:"wasm",setupFunc:function(e){rpe=e.wasm.cwrap($_,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;if("float32"!==a.dtype)throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(a.shape,a.dtype);return rpe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,a.shape[3],s,i,o,l),u}};var ppe,fpe={kernelName:R_,backendName:"wasm",setupFunc:function(e){dpe=e.wasm.cwrap(R_,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;if("float32"!==a.dtype||"float32"!==s.dtype||"float32"!==i.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(a.shape,a.dtype);return dpe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,l,u,c),d}};var mpe,gpe={kernelName:M_,backendName:"wasm",setupFunc:function(e){ppe=e.wasm.cwrap(M_,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=sde(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let p=l.shape.length;rU.assertAxesAreInnerMostDims("max",c,p);let[f,m]=rU.computeOutAndReduceShapes(l.shape,c),g=ER.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==ER.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;ppe(o,zce[i.dtype],g,e)}if(h&&t.disposeData(u.dataId),s){let e=rU.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}},ype=Xce(F_);var bpe,vpe={kernelName:O_,backendName:"wasm",setupFunc:function(e){mpe=e.wasm.cwrap(O_,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;ER.assert("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=rU.computePool2DInfo(a.shape,i,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,b=c.dilationWidth,v=c.strideHeight,x=c.strideWidth,w=c.inChannels,k=c.outChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let S=r.makeOutput(c.outShape,"float32"),I=r.dataIdMap.get(S.dataId).id;return mpe(s,a.shape[0],a.shape[1],a.shape[2],d,h,p,f,m,g,y,b,v,x,w,k,I),S}};var xpe,wpe={kernelName:L_,backendName:"wasm",setupFunc:function(e){bpe=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=rU.computePool3DInfo(a.shape,s,i,1,o,l,u),d=n.makeOutput(c.outShape,a.dtype);return bpe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};var kpe,Spe={kernelName:z_,backendName:"wasm",setupFunc:function(e){xpe=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=rU.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return xpe(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};var Ipe,Cpe={kernelName:P_,backendName:"wasm",setupFunc:function(e){kpe=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=rU.computePool2DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return kpe(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),d}};var Npe,Tpe={kernelName:B_,backendName:"wasm",setupFunc:function(e){Ipe=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=r;ER.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));let u=[1,1];ER.assert(rU.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let c=rU.computePool2DInfo(a.shape,s,i,[1,1],o),d=n.makeOutput(c.outShape,a.dtype),h=n.makeOutput(c.outShape,"int32");return Ipe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(h.dataId).id,zce[a.dtype],l,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[d,h]}};var Epe,Ape={kernelName:W_,backendName:"wasm",setupFunc:function(e){Npe=e.wasm.cwrap(W_,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=sde(i,a,t),f=d;if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=rU.getInnerMostAxes(f.length,u.shape.length))}rU.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=rU.computeOutAndReduceShapes(u.shape,f),y=ER.sizeFromShape(g),b=u;"float32"!==u.dtype&&(b=Ode({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let v=t.makeOutput(m,"float32");if(0!==ER.sizeFromShape(u.shape)){let e=t.dataIdMap.get(v.dataId).id;Npe(l,y,e)}if(p&&t.disposeData(c.dataId),s){let e=rU.expandShapeToKeepDim(v.shape,h);v.shape=e}return"float32"!==u.dtype&&t.disposeData(b.dataId),v}};var _pe,$pe,Rpe={kernelName:V_,backendName:"wasm",setupFunc:function(e){Epe=e.wasm.cwrap(V_,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=sde(i,a,t);if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e)}let f=u.shape.length;rU.assertAxesAreInnerMostDims("min",d,f);let[m,g]=rU.computeOutAndReduceShapes(u.shape,d),y=ER.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==ER.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;Epe(l,zce[i.dtype],y,e)}if(p&&t.disposeData(c.dataId),s){let e=rU.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},Dpe=Xce(U_);!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(_pe||(_pe={}));var Mpe,Fpe={kernelName:j_,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1])),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),d=r.map((e=>e[1])),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return $pe(i,u,t.shape.length,zce[t.dtype],h,p,_pe[a],l),o},setupFunc:function(e){$pe=e.wasm.cwrap(j_,null,["number","array","number","number","array","array","number","number"])}};function Ope(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=ER.sizeFromShape(n.shape)/o;return 0===ER.sizeFromShape(s.shape)||Mpe(a,i,o,l),s}var Ppe,Lpe={kernelName:L$,backendName:"wasm",setupFunc:function(e){Mpe=e.wasm.cwrap(L$,null,["number","number","number","number"])},kernelFunc:Ope};var zpe,Bpe={kernelName:H_,backendName:"wasm",setupFunc:function(e){Ppe=e.wasm.cwrap(H_,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;if("float32"!==a.dtype)throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=o?a:Ope({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[u,c]=l.shape,d=n.makeOutput([u,s],"int32");return Ppe(n.dataIdMap.get(l.dataId).id,u,c,s,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(l.dataId),d}},Wpe=Xce(G_),Vpe=Xce(q_),Upe=Gce(K_);function jpe(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}var Gpe,Hpe={kernelName:Y_,backendName:"wasm",setupFunc:function(e){zpe=e.wasm.cwrap(Y_,"number",["number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(l.dataId).id,d=zpe(u,c,s,a,i),{pSelectedIndices:h,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=jpe(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",h)}};var qpe,Kpe={kernelName:Q_,backendName:"wasm",setupFunc:function(e){Gpe=e.wasm.cwrap(Q_,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=Gpe(c,d,s,a,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=jpe(t,h);return t.wasm._free(m),[t.makeOutput([f],"int32",p),t.makeOutput([],"int32",g)]}};var Xpe,Ype={kernelName:J_,backendName:"wasm",setupFunc:function(e){qpe=e.wasm.cwrap(J_,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=qpe(c,d,s,a,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=jpe(t,h);return t.wasm._free(g),[t.makeOutput([f],"int32",p),t.makeOutput([f],"float32",m)]}},Qpe=Xce(X_,0,"bool");var Jpe={kernelName:e$,backendName:"wasm",setupFunc:function(e){Xpe=e.wasm.cwrap(e$,null,["number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=n.makeOutput([...a.shape,i],s),c=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(a.dataId).id;return Xpe(d,i,o,l,c),u}};var Zpe={kernelName:Z_,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}};var efe,tfe={kernelName:t$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return Ehe({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{ER.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),ER.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=Ehe({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=Wde({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeData(e.dataId))),u}};var nfe,rfe={kernelName:n$,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===ER.sizeFromShape(t.shape))return $he({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),d=r.map((e=>e[1])),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return efe(i,u,t.shape.length,zce[t.dtype],h,p,a,l),o},setupFunc:function(e){efe=e.wasm.cwrap(n$,null,["number","array","number","number","array","array","number","number"])}},afe=Xce(a$);var sfe,ife={kernelName:s$,backendName:"wasm",setupFunc:function(e){nfe=e.wasm.cwrap(s$,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,u=l;"float32"!==l.dtype&&(u=Ode({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let c=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return nfe(o,i,d),"float32"!==l.dtype&&n.disposeData(u.dataId),c}};var ofe,lfe={kernelName:i$,backendName:"wasm",setupFunc:function(e){sfe=e.wasm.cwrap(i$,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=sde(i,a,t),f=d;if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=rU.getInnerMostAxes(f.length,u.shape.length))}rU.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=rU.computeOutAndReduceShapes(u.shape,f),y=ER.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==ER.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;sfe(l,y,zce[b.dtype],e)}if(p&&t.disposeData(c.dataId),s){let e=rU.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},ufe={kernelName:c$,backendName:"wasm",kernelFunc:e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=v5(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l}},cfe=Xce(KA),dfe=Gce(h$),hfe=Gce(p$),pfe=Gce(v$);var ffe,mfe={kernelName:y$,backendName:"wasm",setupFunc:function(e){ofe=e.wasm.cwrap(y$,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{images:s}=r,{alignCorners:i,halfPixelCenters:o,size:l}=a,[u,c]=l,[d,h,p,f]=s.shape,m=[d,u,c,f],g=n.dataIdMap.get(s.dataId);"float32"!==g.dtype&&(t=Ode({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),g=n.dataIdMap.get(t.dataId));let y=g.id,b=n.makeOutput(m,"float32");if(0===ER.sizeFromShape(s.shape))return b;let v=n.dataIdMap.get(b.dataId).id;return ofe(y,d,h,p,f,u,c,i?1:0,o?1:0,v),null!=t&&n.disposeData(t.dataId),b}};var gfe,yfe={kernelName:b$,backendName:"wasm",setupFunc:function(e){ffe=e.wasm.cwrap(b$,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:s,dy:i}=n,{alignCorners:o}=a,l=r.makeOutput(s.shape,"float32"),u=r.dataIdMap.get(s.dataId);return"float32"!==u.dtype&&(t=Ode({backend:r,inputs:{x:s},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),ffe(r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}};var bfe,vfe={kernelName:m$,backendName:"wasm",setupFunc:function(e){gfe=e.wasm.cwrap(m$,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,[c,d,h,p]=a.shape,f=[c,l,u,p],m=t.makeOutput(f,"float32");if(0===ER.sizeFromShape(a.shape))return m;let g,y=t.dataIdMap.get(a.dataId);"float32"!==y.dtype&&(g=Ode({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),y=t.dataIdMap.get(g.dataId));let b=y.id,v=t.dataIdMap.get(m.dataId).id;return gfe(b,c,d,h,p,l,u,s?1:0,i?1:0,v),null!=g&&t.disposeData(g.dataId),m}};var xfe,wfe={kernelName:g$,backendName:"wasm",setupFunc:function(e){bfe=e.wasm.cwrap(g$,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:s,dy:i}=n,{alignCorners:o}=a,l=r.makeOutput(s.shape,"float32"),u=r.dataIdMap.get(s.dataId);return"float32"!==u.dtype&&(t=Ode({backend:r,inputs:{x:s},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),bfe(r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}};var kfe,Sfe={kernelName:x$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=ER.parseAxisParam(s,a.shape);if(0===a.shape.length)return Zce({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(a.shape).buffer);xfe(l,c,i.length,d,a.shape.length,u);let h=Cde({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),h},setupFunc:function(e){xfe=e.wasm.cwrap(x$,null,["number","array","number","array","number","number"])}};var Ife,Cfe={kernelName:dR,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(l.dataId).id,[d,h,p,f]=a.shape,[m,g]=rU.getImageCenter(o,h,p),y="number"==typeof i?[i,i,i,0===i?0:255]:[...i,255],b=new Uint8Array(new Int32Array(y).buffer);return kfe(u,d,h,p,f,s,m,g,b,y.length,c),l},setupFunc:function(e){kfe=e.wasm.cwrap(dR,null,["number","number","number","number","number","number","number","number","array","number","number"])}},Nfe=Gce(w$),Tfe=Gce(k$);var Efe,Afe={kernelName:S$,backendName:"wasm",setupFunc:function(e){Ife=e.wasm.cwrap(S$,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(0===ER.sizeFromShape(i))return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Xz.calculateShapes(s,a,i),p=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return Ife(p,f,zce[s.dtype],l,u,c,m,h,g),o}};var _fe,$fe={kernelName:C$,backendName:"wasm",setupFunc:function(e){Efe=e.wasm.cwrap(C$,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r;if(a.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(e){return n.dataIdMap.get(e.dataId).id}return Efe(l(a),l(s),a.shape[0],a.shape[1],s.shape[1],zce[a.dtype],"left"===i,l(o)),o}};var Rfe,Dfe={kernelName:N$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(a.shape,a.dtype),c=n.dataIdMap.get(u.dataId).id,d=r.shape.length,h=a.shape.length,p=0===d||d>1||1===h?1:ER.sizeFromShape(a.shape.slice(1));return _fe(i,o,l,p,c),u},setupFunc:function(e){_fe=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},Mfe=Gce(T$);var Ffe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){Rfe=e.wasm.cwrap(R$,null,["number","number"])},kernelFunc:function(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return 0===ER.sizeFromShape(a.shape)||Rfe(r,s),a}},Ofe=Gce($$),Pfe=Gce(A$),Lfe=Gce(_$),zfe=Gce(D$);var Bfe,Wfe={kernelName:O$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=ER.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=rfe.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=rU.getReshaped(u.shape,s,o,!1),d=rU.getPermuted(c.length,s.length,!1),h=rU.getReshapedPermuted(u.shape,s,o,!1),p=Cde({inputs:{x:u},backend:n,attrs:{shape:c}}),f=nde({inputs:{x:p},backend:n,attrs:{perm:d}}),m=Cde({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeData(u.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}};var Vfe,Ufe={kernelName:z$,backendName:"wasm",setupFunc:function(e){Bfe=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r}=e,{indices:a,values:s,denseShape:i,defaultValue:o}=r,l=a.shape[0],u=a.shape[1],c=n.readSync(i.dataId)[0],d=[l+c,u],h=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=n.dataIdMap.get(o.dataId).id,m=n.makeOutput(d,a.dtype),g=n.dataIdMap.get(m.dataId).id,y=n.makeOutput(d.slice(0,1),s.dtype),b=n.dataIdMap.get(y.dataId).id,v=n.makeOutput([c],"bool"),x=n.dataIdMap.get(v.dataId).id,w=n.makeOutput([l],a.dtype),k=n.dataIdMap.get(w.dataId).id,S=n.makeOutput([4],"int32"),I=n.dataIdMap.get(S.dataId).id,C=Bfe(h,p,zce[s.dtype],l,c,u,f,g,b,x,k,I),N=n.readSync(S.dataId);switch(N[0]){case 1:t=rU.getSparseFillEmptyRowsIndicesDenseShapeMismatch(N[1]);break;case 2:t=rU.getSparseFillEmptyRowsNegativeIndexErrorMessage(N[1],N[2]);break;case 3:t=rU.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(N[1],N[2],N[3]);break;default:t=""}if(n.disposeData(S.dataId),t)throw n.disposeData(m.dataId),n.disposeData(y.dataId),n.disposeData(v.dataId),n.disposeData(w.dataId),new Error(t);let T=m,E=y;return C!==d[0]&&(T=Ade({inputs:{x:m},attrs:{begin:0,size:[C,u]},backend:n}),E=Ade({inputs:{x:y},attrs:{begin:0,size:C},backend:n}),n.disposeData(m.dataId),n.disposeData(y.dataId)),[T,E,v,w]}};var jfe,Gfe={kernelName:B$,backendName:"wasm",setupFunc:function(e){Vfe=e.wasm.cwrap(B$,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=r.shape[0],c=ER.sizeFromShape(s.shape),d=t.makeOutput([u,c],r.dtype),h=t.dataIdMap.get(d.dataId).id,p=t.makeOutput([c],s.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;Vfe(i,o,l,u,h,f,g);let y,b=t.readSync(m.dataId);switch(b[0]){case 0:y=rU.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break;case 1:y=rU.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break;case 2:y=rU.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(p.dataId));y=rU.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(p.dataId));y=rU.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(d.dataId),t.disposeData(p.dataId),new Error(y);return[d,p]}};function Hfe(e){jfe=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function qfe(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(rU.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=a.shape.slice();c[0]=u;let d=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(c,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;jfe(d,zce[a.dtype],a.shape[0],h,p,m,y,t,0);let b,v=n.readSync(g.dataId);switch(v[0]){case 0:b=rU.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:b=rU.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:b=rU.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v[1],v[2]);break;case 3:b=rU.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v[1],v[2],v[3]);break;default:b=""}if(n.disposeData(g.dataId),b)throw n.disposeData(f.dataId),new Error(b);return f}var Kfe={kernelName:W$,backendName:"wasm",setupFunc:Hfe,kernelFunc:function(e){return qfe(e,!0)}};var Xfe,Yfe={kernelName:V$,backendName:"wasm",setupFunc:Hfe,kernelFunc:function(e){return qfe(e,!1)}};var Qfe={kernelName:U$,backendName:"wasm",setupFunc:function(e){Xfe=e.wasm.cwrap(U$,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(0===ER.sizeFromShape(o))return l;let{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=rU.calculateShapes(s,a,o),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(h).buffer),b=t.dataIdMap.get(l.dataId).id;return Xfe(f,m,s.shape.length,g,zce[i.dtype],u,c,d,y,p,b),l}};var Jfe,Zfe={kernelName:P$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=ER.parseAxisParam(i,a.shape)[0],l=rU.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{let t=[...c];t[o]=e;let n=Ade({inputs:{x:a},attrs:{begin:u,size:t},backend:r});return u[o]+=e,n}))}},eme=Gce(M$),tme=Gce(G$),nme=Xce(j$);var rme,ame={kernelName:uR,backendName:"wasm",setupFunc:function(e){Jfe=e.wasm.cwrap(uR,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return Jfe(i,a,zce[s.dtype],l),o}};var sme={kernelName:q$,backendName:"wasm",setupFunc:function(e){rme=e.wasm.cwrap(q$,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{x:s}=r,{begin:i,end:o,strides:l,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=$V.sliceInfo(s.shape,i,o,l,u,c,d,h,p);if(g)t=Cde({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){ER.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=$V.computeOutShape(v,x,w),r=Ade({inputs:{x:s},backend:n,attrs:{begin:v,size:e}});t=Cde({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}else{let e=n.makeOutput(f,"float32"),r=n.dataIdMap.get(s.dataId).id,a=new Uint8Array(new Int32Array(ER.computeStrides(s.shape)).buffer),i=new Uint8Array(new Int32Array(v).buffer),o=new Uint8Array(new Int32Array(x).buffer),l=new Uint8Array(new Int32Array(w).buffer),u=new Uint8Array(new Int32Array(f).buffer),c=new Uint8Array(new Int32Array(ER.computeStrides(f)).buffer),d=n.dataIdMap.get(e.dataId).id;rme(r,a,s.shape.length,i,o,l,u,c,f.length,d),t=Cde({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeData(e.dataId)}return t}};var ime={kernelName:K$,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:d}=r,h=t.readSync(a.dataId),p=t.readSync(s.dataId),[f,m]=j5(h,p,i,o,l,u,c,d),g=t.makeOutput([f.length],"string");t.dataIdMap.get(g.dataId).stringBytes=f;let y=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(y).set(m),[g,y]}};var ome={kernelName:X$,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:i}=r,o=t.readSync(a.dataId),l=t.readSync(s.dataId),[u,c,d]=H5(o,l[0],i),h=c.length,p=t.makeOutput([h,2],"int32");t.typedArrayFromHeap(p).set(u);let f=t.makeOutput([h],"string");t.dataIdMap.get(f.dataId).stringBytes=c;let m=t.makeOutput([2],"int32");return t.typedArrayFromHeap(m).set(d),[p,f,m]}};var lme,ume={kernelName:Y$,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,i=q5(t.readSync(a.dataId),s),o=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(o).set(i),o}},cme=Xce(Q$);var dme,hme={kernelName:F$,backendName:"wasm",setupFunc:function(e){lme=e.wasm.cwrap(F$,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=sde(i,a,t),f=d;if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=rU.getInnerMostAxes(f.length,u.shape.length))}rU.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=rU.computeOutAndReduceShapes(u.shape,f),y=ER.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==ER.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;lme(l,y,zce[b.dtype],e)}if(p&&t.disposeData(c.dataId),s){let e=rU.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},pme=Gce(J$),fme=Gce(Z$);var mme,gme={kernelName:I$,backendName:"wasm",setupFunc:function(e){dme=e.wasm.cwrap(I$,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=n,{}=r,o=t.makeOutput(a.shape,a.dtype);if(0===ER.sizeFromShape(a.shape))return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Xz.calculateShapes(i,s,a.shape),p=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),y=t.dataIdMap.get(o.dataId).id;return dme(p,f,zce[i.dtype],l,u,c,g,h,y,m),o}};var yme,bme={kernelName:eR,backendName:"wasm",setupFunc:function(e){mme=e.wasm.cwrap(eR,null,["number","array","number","array","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let h=0;h<o.length;h++)o[h]=a.shape[h]*i[h];let l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,a.dtype),d=n.dataIdMap.get(c.dataId).id;return mme(s,l,a.shape.length,u,o.length,zce[c.dtype],d),c}};var vme,xme={kernelName:tR,backendName:"wasm",setupFunc:function(e){yme=e.wasm.cwrap(tR,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=n.dataIdMap.get(a.dataId).id,l=new Uint8Array(new Int32Array(a.shape).buffer),u=a.shape.slice();u[u.length-1]=s;let c=n.makeOutput(u,a.dtype),d=n.dataIdMap.get(c.dataId).id,h=n.makeOutput(u,"int32"),p=n.dataIdMap.get(h.dataId).id;return yme(o,l,a.shape.length,zce[a.dtype],s,i,d,p),[c,h]}};var wme={kernelName:nR,backendName:"wasm",setupFunc:function(e){vme=e.wasm.cwrap(nR,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{image:s,transforms:i}=r,{interpolation:o,fillMode:l,fillValue:u,outputShape:c}=a,[d,h,p,f]=s.shape,[m,g]=null!=c?c:[h,p],y=[d,m,g,f],b=new Uint8Array(new Int32Array(ER.computeStrides(s.shape)).buffer),v=new Uint8Array(new Int32Array(ER.computeStrides(y)).buffer),x=n.makeOutput(y,s.dtype),w=n.dataIdMap.get(x.dataId).id,k=n.dataIdMap.get(s.dataId).id,S=n.dataIdMap.get(i.dataId).id,I="nearest"===o?1:2;switch(l){case"constant":default:t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4}return vme(k,S,i.shape[0]>1,d,m,g,f,p,h,b,s.shape.length-1,v,y.length-1,I,t,u,w),x}};var kme={kernelName:aR,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=n6(r.readSync(s.dataId),a,s.shape,s.dtype);return[r.makeOutput(o,s.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}};var Sme={kernelName:sR,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),u=0;for(let p=0;p<o;p++)p!==s&&(l[u++]=a.shape[p]);let c=new Array(i),d=new Array(o).fill(0),h=a.shape.slice();h[s]=1;for(let p=0;p<c.length;p++)d[s]=p,c[p]=Ade({inputs:{x:a},attrs:{begin:d,size:h},backend:n});return c.map((e=>{let{dataId:t,dtype:n}=e;return{dataId:t,dtype:n,shape:l}}))}};var Ime={kernelName:lR,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}},Cme=[jce,Hce,qce,Kce,Qce,Jce,ode,lde,dde,hde,pde,fde,mde,gde,yde,vde,Ide,wde,Sde,Ede,Rde,Dde,Mde,Fde,Lde,zde,Bde,Ude,Gde,qde,Xde,Qde,ehe,the,nhe,ahe,ihe,lhe,che,hhe,fhe,ghe,bhe,xhe,khe,She,Ihe,Che,Nhe,The,Ahe,_he,Dhe,Fhe,Ohe,Phe,zhe,Whe,Uhe,Ghe,qhe,Khe,Xhe,tde,Yhe,Qhe,Jhe,epe,tpe,npe,ape,ipe,spe,ope,lpe,upe,cpe,hpe,fpe,gpe,ype,vpe,wpe,Spe,Cpe,Tpe,Ape,Rpe,Dpe,Fpe,Bpe,Wpe,Vpe,Upe,Hpe,Kpe,Ype,Qpe,Jpe,Zpe,tfe,rfe,afe,ife,lfe,ufe,cfe,dfe,hfe,pfe,Tde,mfe,yfe,vfe,wfe,Sfe,Cfe,Nfe,Tfe,Afe,$fe,Dfe,Mfe,Ffe,Ofe,Pfe,Lfe,_de,Lpe,zfe,Wfe,Ufe,Gfe,Kfe,Yfe,Qfe,Zfe,eme,tme,nme,ame,sme,ime,ome,ume,cme,hme,pme,fme,gme,bme,xme,wme,ade,kme,Sme,Ime];for(let n of Cme)kR(n);var Nme=HE();Nme.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(gD){return!1}})),Nme.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(Nme.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(gD){return!1}}));var Tme=IT(UT()),Eme=IT(jT()),Ame=IT(GT()),_me=Tme.default||Tme,$me=Ame.default||Ame,Rme=class extends qT{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(Ume),jme=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new HT(this,oM())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=ER.now();return e(),{kernelMs:ER.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if("string"===r){let i=t;return void this.dataIdMap.set(e,{id:s,stringBytes:i,shape:n,dtype:r,memoryOffset:null,refCount:a})}let i=ER.sizeFromShape(n),o=i*ER.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=i.length)?i.slice(t,n):i;t=t||0,n=n||ER.sizeFromShape(s);let o=ER.bytesPerElement(a);return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(r+t*o,r+n*o).buffer,a)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(null==n)a=this.write(null!=r?r:null,e,t);else{let r=this.dataIdNextNumber++;a={id:r},this.dataIdMap.set(a,{id:r,memoryOffset:n,shape:e,dtype:t,refCount:1});let s=ER.sizeFromShape(e);this.wasm.tfjs.registerTensor(r,s,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap(e){let{shape:t,dtype:n,dataId:r}=e,a=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(r),i=ER.sizeFromShape(t);switch(n){case"float32":return new Float32Array(a,s,i);case"int32":return new Int32Array(a,s,i);case"bool":return new Uint8Array(a,s,i);default:throw new Error(`Unknown dtype ${n}`)}}};function Dme(e,t,n){if(null!=Ome)return Ome;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=Lme&&null!=Lme[r]?Lme[r]:n+r}async function Mme(){let[e,t]=await Promise.all([HE().getAsync("WASM_HAS_SIMD_SUPPORT"),HE().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{let a={locateFile:(n,r)=>{if(n.endsWith(".worker.js")){let e=Eme.wasmWorkerContents.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?Dme(e,t,null!=Pme?Pme:r):r+n}};Bme&&(a.instantiateWasm=function(e){return(t,n)=>(ER.fetch(e,{credentials:"same-origin"}).then((r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then((e=>{WebAssembly.instantiate(e,t).then((e=>{n(e.instance,e.module)}))}))})),{})}(Dme(e,t,null!=Pme?Pme:"")));let s,i=!1;a.onAbort=()=>{i||zme||(zme=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==Ome?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+_me.toString()],{type:"text/javascript"}),s=_me(a)):s=$me(a),s.then((e=>{i=!0,zme=!1;e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},n({wasm:e})})).catch(r)}))}var Fme=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Ome=null,Pme=null,Lme={},zme=!1,Bme=!1;function Wme(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(sM("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),zme)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Ome=e,Bme=t}function Vme(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(zme)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)Pme=e;else{Lme=e;let t=Fme.filter((e=>null==Lme[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}Bme=t}var Ume=-1,jme=-1;function Gme(e){Ume=e}function Hme(){if(-1===jme)throw new Error("WASM backend not initialized.");return jme}var qme="4.16.0";xM("wasm",(async()=>{let{wasm:e}=await Mme();return new Rme(e)}),2);var Kme="4.16.0",Xme={tfjs:Kme,"tfjs-core":Kme,"tfjs-converter":"4.16.0","tfjs-backend-cpu":"4.16.0","tfjs-backend-webgl":"4.16.0","tfjs-backend-wasm":"4.16.0"},Yme={};function Qme(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(e.beginPath(),t.slice(1).forEach(((n,r)=>{let{x:a,y:s}=n,i=t[r];e.moveTo(i.x,i.y),e.lineTo(a,s)})),n){let n=t[t.length-1],r=t[0];if(!n||!r)return;e.moveTo(n.x,n.y),e.lineTo(r.x,r.y)}e.stroke()}mT(Yme,{AnchorPosition:()=>Bge,DrawBox:()=>jge,DrawBoxOptions:()=>Uge,DrawFaceLandmarks:()=>$ye,DrawFaceLandmarksOptions:()=>_ye,DrawTextField:()=>Vge,DrawTextFieldOptions:()=>Wge,drawContour:()=>Qme,drawDetections:()=>Gge,drawFaceExpressions:()=>Tye,drawFaceLandmarks:()=>Rye});mT({},{computeReshapedDimensions:()=>lge,getCenterPoint:()=>uge,isDimensions:()=>oge,isEven:()=>sge,isFloat:()=>age,isTensor:()=>Zme,isTensor1D:()=>ege,isTensor2D:()=>tge,isTensor3D:()=>nge,isTensor4D:()=>rge,isValidNumber:()=>dge,isValidProbablitiy:()=>hge,range:()=>cge,round:()=>ige});var Jme=class e{constructor(e,t){if(!dge(e)||!dge(t))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:t})}`);this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new e(1/this.width,1/this.height)}};function Zme(e,t){return e instanceof hD&&e.shape.length===t}function ege(e){return Zme(e,1)}function tge(e){return Zme(e,2)}function nge(e){return Zme(e,3)}function rge(e){return Zme(e,4)}function age(e){return e%1!==0}function sge(e){return e%2===0}function ige(e){let t=10**(arguments.length>1&&void 0!==arguments[1]?arguments[1]:2);return Math.floor(e*t)/t}function oge(e){return e&&e.width&&e.height}function lge(e,t){let{width:n,height:r}=e,a=t/Math.max(r,n);return new Jme(Math.round(n*a),Math.round(r*a))}function uge(e){return e.reduce(((e,t)=>e.add(t)),new pge(0,0)).div(new pge(e.length,e.length))}function cge(e,t,n){return Array(e).fill(0).map(((e,r)=>t+r*n))}function dge(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||0===e}function hge(e){return dge(e)&&e>=0&&e<=1}var pge=class e{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(t){return new e(this.x+t.x,this.y+t.y)}sub(t){return new e(this.x-t.x,this.y-t.y)}mul(t){return new e(this.x*t.x,this.y*t.y)}div(t){return new e(this.x/t.x,this.y/t.y)}abs(){return new e(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new e(Math.floor(this.x),Math.floor(this.y))}},fge=class e{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every(dge)}static assertIsValidBox(t,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!e.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t){let n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=t||{},a=[r.left,r.top,r.right,r.bottom].every(dge),s=[r.x,r.y,r.width,r.height].every(dge);if(!s&&!a)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[i,o,l,u]=s?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];e.assertIsValidBox({x:i,y:o,width:l,height:u},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new pge(this.left,this.top)}get topRight(){return new pge(this.right,this.top)}get bottomLeft(){return new pge(this.left,this.bottom)}get bottomRight(){return new pge(this.right,this.bottom)}round(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map((e=>Math.round(e)));return new e({x:t,y:n,width:r,height:a})}floor(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map((e=>Math.floor(e)));return new e({x:t,y:n,width:r,height:a})}toSquare(){let{x:t,y:n,width:r,height:a}=this,s=Math.abs(r-a);return r<a&&(t-=s/2,r+=s),a<r&&(n-=s/2,a+=s),new e({x:t,y:n,width:r,height:a})}rescale(t){let n=oge(t)?t.width:t,r=oge(t)?t.height:t;return new e({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,a,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new e({x:r,y:a,width:s,height:i})}clipAtImageBorders(t,n){let{x:r,y:a,right:s,bottom:i}=this,o=Math.max(r,0),l=Math.max(a,0),u=s-o,c=i-l,d=Math.min(u,t-o),h=Math.min(c,n-l);return new e({x:o,y:l,width:d,height:h}).floor()}shift(t,n){let{width:r,height:a}=this,s=this.x+t,i=this.y+n;return new e({x:s,y:i,width:r,height:a})}padAtBorders(e,t){let n=this.width+1,r=this.height+1,a=n,s=r,i=this.left,o=this.top,l=this.right,u=this.bottom;return l>t&&(a=-l+t+n,l=t),u>e&&(s=-u+e+r,u=e),i<1&&(s=2-i,i=1),o<1&&(s=2-o,o=1),{dy:1,edy:s,dx:1,edx:a,y:o,ey:u,x:i,ex:l,w:n,h:r}}calibrate(t){return new e({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},mge=class extends fge{constructor(e,t,n,r){super({left:e,top:t,right:n,bottom:r},arguments.length>4&&void 0!==arguments[4]&&arguments[4])}},gge=class e{constructor(e,t,n,r,a){this._imageDims=new Jme(a.width,a.height),this._score=e,this._classScore=t,this._className=n,this._box=new fge(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new fge(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new e(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},yge=class e extends gge{constructor(e,t,n){super(e,e,"",t,n)}forSize(t,n){let{score:r,relativeBox:a,imageDims:s}=super.forSize(t,n);return new e(r,a,s)}};function bge(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left))*Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top));return n?r/(e.area+t.area-r):r/Math.min(e.area,t.area)}function vge(e,t){return cM((()=>{let[n,r,a]=t,s=SO([...e.shape.slice(0,3),1],n,"float32"),i=SO([...e.shape.slice(0,3),1],r,"float32"),o=SO([...e.shape.slice(0,3),1],a,"float32"),l=iO([s,i,o],3);return JP(e,l)}))}function xge(e){return 1/(1+Math.exp(-e))}var wge,kge=class extends fge{constructor(e,t,n,r){super({x:e,y:t,width:n,height:r},arguments.length>4&&void 0!==arguments[4]&&arguments[4])}},Sge=class{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new pge(0,0),{width:r,height:a}=t;this._imgDims=new Jme(r,a),this._shift=n,this._positions=e.map((e=>e.mul(new pge(r,a)).add(n)))}get shift(){return new pge(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map((e=>e.sub(this._shift).div(new pge(this.imageWidth,this.imageHeight))))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new pge(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(e){let n=e instanceof yge?e.box.floor():new fge(e);return this.shiftBy(n.x,n.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=e=>r.sub(e).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/.45),o=uge(e),l=Math.floor(Math.max(0,o.x-.5*i)),u=Math.floor(Math.max(0,o.y-.43*i));return new kge(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=function(e){let t=e.map((e=>e.x)),n=e.map((e=>e.y)),r=t.reduce(((e,t)=>t<e?t:e),1/0),a=n.reduce(((e,t)=>t<e?t:e),1/0),s=t.reduce(((e,t)=>e<t?t:e),0),i=n.reduce(((e,t)=>e<t?t:e),0);return new mge(r,a,s,i)}(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},Ige=class extends Sge{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(uge)}},Cge=class{constructor(e,t){this._label=e,this._distance=t}get label(){return this._label}get distance(){return this._distance}toString(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return`${this.label}${e?` (${ige(this.distance)})`:""}`}},Nge=class e{constructor(e,t){if("string"!=typeof e)throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(t)||t.some((e=>!(e instanceof Float32Array))))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=e,this._descriptors=t}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map((e=>Array.from(e)))}}static fromJSON(t){let n=t.descriptors.map((e=>new Float32Array(e)));return new e(t.label,n)}};function Tge(e){return e.detection instanceof yge}function Ege(e,t){return{...e,detection:t}}function Age(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D:CanvasRenderingContext2D,Image:HTMLImageElement,ImageData:ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function _ge(){return"object"==typeof n.g&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node}function $ge(e){let t="";if(!e&&_ge())try{e=fT("fs")}catch(n){t=n.toString()}return{readFile:e?t=>new Promise(((n,r)=>{e.readFile(t,((e,t)=>e?r(e):n(t)))})):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function Rge(){let e=n.g.Canvas||n.g.HTMLCanvasElement,t=n.g.Image||n.g.HTMLImageElement,r=n.g.Video||n.g.HTMLVideoElement,a=n.g.fetch,s=$ge();return{Canvas:e||class{},CanvasRenderingContext2D:n.g.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:n.g.ImageData||class{},Video:n.g.HTMLVideoElement||class{},createCanvasElement:()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},createImageElement:()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},createVideoElement:()=>{if(r)return new r;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},fetch:a,...s}}function Dge(){return"object"==typeof window&&"undefined"!=typeof document&&"undefined"!=typeof HTMLImageElement&&"undefined"!=typeof HTMLCanvasElement&&"undefined"!=typeof HTMLVideoElement&&"undefined"!=typeof ImageData&&"undefined"!=typeof CanvasRenderingContext2D}function Mge(e){wge=e}function Fge(){return Dge()?Mge(Age()):_ge()?Mge(Rge()):null}var Oge={getEnv:function(){if(!wge)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return wge},setEnv:Mge,initialize:Fge,createBrowserEnv:Age,createFileSystem:$ge,createNodejsEnv:Rge,monkeyPatch:function(e){if(wge||Fge(),!wge)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=wge.Canvas,Image:n=wge.Image}=e;wge.Canvas=t,wge.Image=n,wge.createCanvasElement=e.createCanvasElement||(()=>new t),wge.createImageElement=e.createImageElement||(()=>new n),wge.ImageData=e.ImageData||wge.ImageData,wge.Video=e.Video||wge.Video,wge.fetch=e.fetch||wge.fetch,wge.readFile=e.readFile||wge.readFile},isBrowser:Dge,isNodejs:_ge};function Pge(e){return Oge.isNodejs()||"string"!=typeof e?e:document.getElementById(e)}function Lge(e){let{Canvas:t,CanvasRenderingContext2D:n}=Oge.getEnv();if(e instanceof n)return e;let r=Pge(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d",{willReadFrequently:!0});if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}Fge();var zge,Bge=((zge=Bge||{}).TOP_LEFT="TOP_LEFT",zge.TOP_RIGHT="TOP_RIGHT",zge.BOTTOM_LEFT="BOTTOM_LEFT",zge.BOTTOM_RIGHT="BOTTOM_RIGHT",zge),Wge=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},Vge=class e{constructor(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.text="string"==typeof t?[t]:t instanceof e?t.text:t,this.anchor=n,this.options=new Wge(r)}measureWidth(e){let{padding:t}=this.options;return this.text.map((t=>e.measureText(t).width)).reduce(((e,t)=>e<t?t:e),0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,r="BOTTOM_RIGHT"===n||"TOP_RIGHT"===n,a="BOTTOM_LEFT"===n||"BOTTOM_RIGHT"===n,s=this.measureWidth(e),i=this.measureHeight(),o=r?this.anchor.x-s:this.anchor.x,l=a?this.anchor.y-i:this.anchor.y;if(t){let{width:e,height:n}=t;return{x:Math.max(Math.min(o,e-s),0),y:Math.max(Math.min(l,n-i),0)}}return{x:o,y:l}}draw(e){let t=Pge(e),n=Lge(t),{backgroundColor:r,fontColor:a,fontSize:s,fontStyle:i,padding:o}=this.options;n.font=`${s}px ${i}`;let l=this.measureWidth(n),u=this.measureHeight();n.fillStyle=r;let c=this.getUpperLeft(n,t);n.fillRect(c.x,c.y,l,u),n.fillStyle=a,this.text.forEach(((e,t)=>{let r=o+c.x,a=o+c.y+(t+1)*s;n.fillText(e,r,a)}))}},Uge=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new Wge({...s,...a})}},jge=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.box=new fge(e),this.options=new Uge(t)}draw(e){let t=Lge(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new Vge([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function Gge(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof yge?t.score:Tge(t)?t.detection.score:void 0,r=t instanceof yge?t.box:Tge(t)?t.detection.box:new fge(t),a=n?`${ige(n)}`:void 0;new jge(r,{label:a}).draw(e)}))}function Hge(e){let{Image:t,Video:n}=Oge.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function qge(e){let{Image:t,Video:n}=Oge.getEnv();return e instanceof t?new Jme(e.naturalWidth,e.naturalHeight):e instanceof n?new Jme(e.videoWidth,e.videoHeight):new Jme(e.width,e.height)}function Kge(e){let{width:t,height:n}=e,{createCanvasElement:r}=Oge.getEnv(),a=r();return a.width=t,a.height=n,a}function Xge(e,t){let{ImageData:n}=Oge.getEnv();if(!(e instanceof n)&&!Hge(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||qge(e),s=Kge({width:r,height:a});return e instanceof n?Lge(s).putImageData(e,0,0):Lge(s).drawImage(e,0,0,r,a),s}function Yge(e){let{Image:t,Canvas:n,Video:r}=Oge.getEnv();return e instanceof t||e instanceof n||e instanceof r}var Qge=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach(((e,t)=>{if(nge(e))return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape);if(rge(e)){let n=e.shape[0];if(1!==n)throw new Error(`NetInput - tf.Tensor4D with batchSize ${n} passed, but not supported in input array`);return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape.slice(1))}let n=e instanceof Oge.getEnv().Canvas?e:Xge(e);this._canvases[t]=n,this._inputDimensions[t]=[n.height,n.width,3]}))}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return cge(this.batchSize,0,1).map(((e,t)=>this.getReshapedInputDimensions(t)))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if("number"!=typeof this.inputSize)throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");return lge({width:this.getInputWidth(e),height:this.getInputHeight(e)},this.inputSize)}toBatchTensor(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return this._inputSize=e,cM((()=>{let n=cge(this.batchSize,0,1).map((n=>{let r=this.getInput(n);if(r instanceof hD){let n=rge(r)?r:SP(r);return n=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return cM((()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=t=>{let n=e.shape.slice();return n[i]=t,SO(n,0,"float32")},l=o(s),u=a-l.shape[i],c=[t&&u?o(u):null,e,l].filter((e=>!!e)).map((e=>kF(e,"float32")));return iO(c,i)}))}(n,t),(n.shape[1]!==e||n.shape[2]!==e)&&(n=AW.resizeBilinear(n,[e,e],!1,!1)),n.as3D(e,e,3)}if(r instanceof Oge.getEnv().Canvas)return vV.fromPixels(function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{Image:r,Canvas:a}=Oge.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return Kge({width:1,height:1});let s=qge(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,u=Kge({width:t,height:t}),c=e instanceof a?e:Xge(e),d=Math.abs(o-l)/2,h=n&&o<l?d:0,p=n&&l<o?d:0;return c.width>0&&c.height>0&&Lge(u).drawImage(c,h,p,o,l),u}(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${n}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)}));return zz(n.map((e=>kF(e,"float32")))).as4D(this.batchSize,e,e,3)}))}};async function Jge(e){if(e instanceof Qge)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=t=>Array.isArray(e)?` at input index ${t}:`:"",r=t.map(Pge);return r.forEach(((e,r)=>{if(!Yge(e)&&!nge(e)&&!rge(e))throw"string"==typeof t[r]?new Error(`toNetInput -${n(r)} string passed, but could not resolve HTMLElement for element id ${t[r]}`):new Error(`toNetInput -${n(r)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(rge(e)){let t=e.shape[0];if(1!==t)throw new Error(`toNetInput -${n(r)} tf.Tensor4D with batchSize ${t} passed, but not supported in input array`)}})),await Promise.all(r.map((e=>Yge(e)&&function(e){return new Promise(((t,n)=>{function r(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),n(e))}function a(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),t(e))}(e instanceof Oge.getEnv().Canvas||Hge(e))&&t(null),e.addEventListener("load",a),e.addEventListener("error",r)}))}(e)))),new Qge(r,Array.isArray(e))}async function Zge(e,t){let{Canvas:n}=Oge.getEnv(),r=e;if(!(e instanceof n)){let t=await Jge(e);if(t.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let a=t.getInput(0);r=a instanceof n?a:await async function(e,t){let n=t||Oge.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(rge(e)?1:0),i=cM((()=>e.as3D(r,a,s).toInt()));return await vV.toPixels(i,n),i.dispose(),n}(a)}let a=Lge(r);return t.map((e=>e instanceof yge?e.forSize(r.width,r.height).box.floor():e)).map((e=>e.clipAtImageBorders(r.width,r.height))).map((e=>{let{x:t,y:n,width:r,height:s}=e,i=Kge({width:r,height:s});return r>0&&s>0&&Lge(i).putImageData(a.getImageData(t,n,r,s),0,0),i}))}async function eye(e,t){if(!nge(e)&&!rge(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(rge(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return cM((()=>{let[n,r,a]=e.shape.slice(rge(e)?1:0);return t.map((e=>e instanceof yge?e.forSize(r,n).box:e)).map((e=>e.clipAtImageBorders(r,n))).filter((e=>e.width>0&&e.height>0)).map((t=>{let{x:s,y:i,width:o,height:l}=t;return Az(e.as3D(n,r,a),[i,s,0],[l,o,a])}))}))}async function tye(e,t){let{fetch:n}=Oge.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}function nye(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if("/"===e)return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"",a=(e=e.replace(r,"")).split("/").filter((e=>e)),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:"/"===i?`/${s}`:`${i}/${s}`}}async function rye(e,t){let{manifestUri:n,modelBaseUri:r}=nye(e,t),a=await async function(e){return(await tye(e)).json()}(n);return YW.loadWeights(a,r)}var aye=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map((e=>{let{paramPath:t}=e;return{path:t,tensor:this.getParamFromPath(t)}}))}getTrainableParams(){return this.getParamList().filter((e=>e.tensor instanceof fD))}getFrozenParams(){return this.getParamList().filter((e=>!(e.tensor instanceof fD)))}variable(){this.getFrozenParams().forEach((e=>{let{path:t,tensor:n}=e;this.reassignParamFromPath(t,n.variable())}))}freeze(){this.getTrainableParams().forEach((e=>{let{path:t,tensor:n}=e,r=ZD(n.dataSync());n.dispose(),this.reassignParamFromPath(t,r)}))}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.getParamList().forEach((t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()})),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map((e=>{let{tensor:t}=e;return Array.from(t.dataSync())})).reduce(((e,t)=>e.concat(t))))}async load(e){e instanceof Float32Array?this.extractWeights(e):await this.loadFromUri(e)}async loadFromUri(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await rye(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=Oge.getEnv(),{manifestUri:n,modelBaseUri:r}=nye(e,this.getDefaultModelName()),a=YW.weightsLoaderFactory((e=>Promise.all(e.map((e=>t(e).then((e=>"string"==typeof e?Buffer.from(e):e.buffer))))))),s=JSON.parse((await t(n)).toString()),i=await a(s,r);this.loadFromWeightMap(i)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce(((t,n)=>{if(!t.nextObj.hasOwnProperty(n))throw new Error(`traversePropertyPath - object does not have property ${n}, for path ${e}`);return{obj:t.nextObj,objProp:n,nextObj:t.nextObj[n]}}),{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof hD))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function sye(e,t,n){return cM((()=>{let r=kz(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=CF(r,t.bias),r}))}function iye(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return cM((()=>{let r=hz(n?CF(AO(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):sye(e,t.conv0,[2,2])),a=sye(r,t.conv1,[1,1]),s=sye(hz(CF(r,a)),t.conv2,[1,1]);return hz(CF(r,CF(a,s)))}))}function oye(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];return cM((()=>{let a=hz(n?CF(AO(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):sye(e,t.conv0,r?[2,2]:[1,1])),s=sye(a,t.conv1,[1,1]),i=sye(hz(CF(a,s)),t.conv2,[1,1]),o=sye(hz(CF(a,CF(s,i))),t.conv3,[1,1]);return hz(CF(a,CF(s,CF(i,o))))}))}function lye(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"same",r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return cM((()=>{let a=CF(AO(e,t.filters,[1,1],n),t.bias);return r?hz(a):a}))}function uye(e,t){Object.keys(e).forEach((n=>{t.some((e=>e.originalPath===n))||e[n].dispose()}))}function cye(e,t){return(n,r,a,s)=>{let i=Hz(e(n*r*a*a),[a,a,n,r]),o=Uz(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function dye(e,t){return(n,r,a)=>{let s=jz(e(n*r),[n,r]),i=Uz(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var hye=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function pye(e,t){return(n,r,a)=>{let s=Hz(e(9*n),[3,3,n,1]),i=Hz(e(n*r),[1,1,n,r]),o=Uz(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new hye(s,i,o)}}function fye(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new hye(n,r,a)}}function mye(e,t){return(n,r,a)=>{let s=e[n];if(!Zme(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function gye(e){let t=e;return{extractWeights:function(e){let n=t.slice(0,e);return t=t.slice(e),n},getRemainingWeights:function(){return t}}}function yye(e,t){let n=cye(e,t),r=pye(e,t);function a(e,t,a){return{conv0:arguments.length>3&&void 0!==arguments[3]&&arguments[3]?n(e,t,3,`${a}/conv0`):r(e,t,`${a}/conv0`),conv1:r(t,t,`${a}/conv1`),conv2:r(t,t,`${a}/conv2`)}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:function(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],{conv0:i,conv1:o,conv2:l}=a(e,t,n,s);return{conv0:i,conv1:o,conv2:l,conv3:r(t,t,`${n}/conv3`)}}}}function bye(e){return t=>({filters:e(`${t}/filters`,4),bias:e(`${t}/bias`,1)})}function vye(e,t){let n=mye(e,t),r=bye(n),a=fye(n);return{extractDenseBlock3Params:function(e){return{conv0:arguments.length>1&&void 0!==arguments[1]&&arguments[1]?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`)}},extractDenseBlock4Params:function(e){return{conv0:arguments.length>1&&void 0!==arguments[1]&&arguments[1]?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`),conv3:a(`${e}/conv3`)}}}}var xye=class extends aye{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return cM((()=>{let n=oye(vge(kF(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=oye(n,t.dense1),n=oye(n,t.dense2),n=oye(n,t.dense3),n=aO(n,[7,7],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await Jge(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock4Params:n}=vye(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return uye(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=gye(e),{extractDenseBlock4Params:a}=yye(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}(e)}};function wye(e,t){return cM((()=>CF(oO(e,t.weights),t.bias)))}function kye(e){let t={},n={};return Object.keys(e).forEach((r=>{(r.startsWith("fc")?n:t)[r]=e[r]})),{featureExtractorMap:t,classifierMap:n}}var Sye=class extends aye{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return cM((()=>{let n=e instanceof Qge?this.faceFeatureExtractor.forwardInput(e):e;return wye(n.as2D(n.shape[0],-1),t.fc)}))}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=gye(e),i=dye(a,r)(t,n,"fc");if(0!==s().length)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=kye(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=mye(e,t),r={fc:(a="fc",{weights:n(`${a}/weights`,2),bias:n(`${a}/bias`,1)})};var a;return uye(e,t),{params:r,paramMappings:t}}(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},Iye=["neutral","happy","sad","angry","fearful","disgusted","surprised"],Cye=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,7!==e.length)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);Iye.forEach(((t,n)=>{this[t]=e[n]}))}asSortedArray(){return Iye.map((e=>({expression:e,probability:this[e]}))).sort(((e,t)=>t.probability-e.probability))}};function Nye(e,t){return{...e,expressions:t}}function Tye(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,r=arguments.length>3?arguments[3]:void 0;(Array.isArray(t)?t:[t]).forEach((t=>{let a=t instanceof Cye?t:function(e){return e.expressions instanceof Cye}(t)?t.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let s=a.asSortedArray().filter((e=>e.probability>n)),i=Tge(t)?t.detection.box.bottomLeft:r||new pge(0,0);new Vge(s.map((e=>`${e.expression} (${ige(e.probability)})`)),i).draw(e)}))}function Eye(e){return Tge(e)&&e.landmarks instanceof Sge&&e.unshiftedLandmarks instanceof Sge&&e.alignedRect instanceof yge}function Aye(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new yge(e.detection.score,a.rescale(s.reverse()),s),o=function(e){let t=e=>180*e/Math.PI,n=(e,t)=>Math.sqrt((e.x-t.x)**2+(e.y-t.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0};if(!e||!e.positions||68!==e.positions.length)return r;let a=e.positions;return r.roll=((e,n)=>{let r=Math.hypot(n.x-e.x,n.y-e.y),a=n.y-e.y,s=Math.asin(a/r),i=t(s);return Math.floor(90-i)*(n.x-e.x<0?-1:1)})(a[27],a[66]),r.pitch=((e,r,a)=>{let s=n(e,a),i=new pge((e.x+a.x)/2,(e.y+a.y)/2),o=n(r,i),l=Math.atan(o/s);return Math.floor(t(l))*(i.y-r.y<0?-1:1)})(a[14],a[30],a[2]),r.yaw=((e,t,n)=>Math.floor(e.x-t.x)-Math.floor(t.x-n.x))(a[14],a[33],a[2]),r}(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var _ye=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},$ye=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.faceLandmarks=e,this.options=new _ye(t)}draw(e){let t=Lge(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof Ige&&(t.strokeStyle=s,t.lineWidth=a,Qme(t,this.faceLandmarks.getJawOutline()),Qme(t,this.faceLandmarks.getLeftEyeBrow()),Qme(t,this.faceLandmarks.getRightEyeBrow()),Qme(t,this.faceLandmarks.getNose()),Qme(t,this.faceLandmarks.getLeftEye(),!0),Qme(t,this.faceLandmarks.getRightEye(),!0),Qme(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let e=e=>{t.beginPath(),t.arc(e.x,e.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(e)}}};function Rye(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof Sge?t:Eye(t)?t.landmarks:void 0;if(!n)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new $ye(n).draw(e)}))}function Dye(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=gye(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=function(e,t){let n=cye(e,t),r=pye(e,t);return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:function(e,t,a){return{separable_conv0:r(e,t,`${a}/separable_conv0`),separable_conv1:r(t,t,`${a}/separable_conv1`),expansion_conv:n(e,t,1,`${a}/expansion_conv`)}},extractMainBlockParams:function(e,t){return{separable_conv0:r(e,e,`${t}/separable_conv0`),separable_conv1:r(e,e,`${t}/separable_conv1`),separable_conv2:r(e,e,`${t}/separable_conv2`)}}}}(r,n),u={conv_in:s(3,32,3,"entry_flow/conv_in"),reduction_block_0:o(32,64,"entry_flow/reduction_block_0"),reduction_block_1:o(64,128,"entry_flow/reduction_block_1")},c={};cge(t,0,1).forEach((e=>{c[`main_block_${e}`]=l(128,`middle_flow/main_block_${e}`)}));let d={reduction_block:o(128,256,"exit_flow/reduction_block"),separable_conv:i(256,512,"exit_flow/separable_conv")};if(0!==a().length)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:u,middle_flow:c,exit_flow:d}}}function Mye(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=function(e,t){let n=mye(e,t),r=bye(n),a=fye(n);return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),expansion_conv:r(`${e}/expansion_conv`)}},extractMainBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),separable_conv2:a(`${e}/separable_conv2`)}}}}(e,n),o={conv_in:r("entry_flow/conv_in"),reduction_block_0:s("entry_flow/reduction_block_0"),reduction_block_1:s("entry_flow/reduction_block_1")},l={};cge(t,0,1).forEach((e=>{l[`main_block_${e}`]=i(`middle_flow/main_block_${e}`)}));let u={reduction_block:s("exit_flow/reduction_block"),separable_conv:a("exit_flow/separable_conv")};return uye(e,n),{params:{entry_flow:o,middle_flow:l,exit_flow:u},paramMappings:n}}function Fye(e,t,n){return CF(AO(e,t.filters,n,"same"),t.bias)}function Oye(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?hz(e):e;return n=sye(n,t.separable_conv0,[1,1]),n=sye(hz(n),t.separable_conv1,[1,1]),n=lL(n,[3,3],[2,2],"same"),n=CF(n,Fye(e,t.expansion_conv,[2,2])),n}var Pye=class extends aye{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return cM((()=>{let n=vge(kF(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),r=hz(Fye(n,t.entry_flow.conv_in,[2,2]));return r=Oye(r,t.entry_flow.reduction_block_0,!1),r=Oye(r,t.entry_flow.reduction_block_1),cge(this._numMainBlocks,0,1).forEach((e=>{r=function(e,t){let n=sye(hz(e),t.separable_conv0,[1,1]);return n=sye(hz(n),t.separable_conv1,[1,1]),n=sye(hz(n),t.separable_conv2,[1,1]),n=CF(n,e),n}(r,t.middle_flow[`main_block_${e}`])})),r=Oye(r,t.exit_flow.reduction_block),r=hz(sye(r,t.exit_flow.separable_conv,[1,1])),r}))}async forward(e){return this.forwardInput(await Jge(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return Mye(e,this._numMainBlocks)}extractParams(e){return Dye(e,this._numMainBlocks)}};var Lye,zye=((Lye=zye||{}).FEMALE="female",Lye.MALE="male",Lye),Bye=class extends Sye{postProcess(e,t,n){let r=n.map((e=>{let{width:n,height:r}=e,a=t/Math.max(r,n);return{width:n*a,height:r*a}})),a=r.length;return cM((()=>{let n=(e,t)=>zz([SO([68],e,"float32"),SO([68],t,"float32")],1).as2D(1,136).as1D(),s=(e,t)=>{let{width:n,height:a}=r[e];return t(n,a)?Math.abs(n-a)/2:0};return e.mul(SO([a,136],t,"float32")).sub(zz(Array.from(Array(a),((e,t)=>n((e=>s(e,((e,t)=>e<t)))(t),(e=>s(e,((e,t)=>t<e)))(t)))))).div(zz(Array.from(Array(a),((e,t)=>n(r[t].width,r[t].height)))))}))}forwardInput(e){return cM((()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map((e=>{let[t,n]=e;return{height:t,width:n}})))}))}async forward(e){return this.forwardInput(await Jge(e))}async detectLandmarks(e){let t=await Jge(e),n=cM((()=>aB(this.forwardInput(t)))),r=await Promise.all(n.map((async(e,n)=>{let r=Array.from(e.dataSync()),a=r.filter(((e,t)=>sge(t))),s=r.filter(((e,t)=>!sge(t)));return new Ige(Array(68).fill(0).map(((e,t)=>new pge(a[t],s[t]))),{height:t.getInputHeight(n),width:t.getInputWidth(n)})})));return n.forEach((e=>e.dispose())),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},Wye=class extends Bye{constructor(){super("FaceLandmark68Net",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new xye)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};var Vye=class extends aye{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return cM((()=>{let n=iye(vge(kF(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=iye(n,t.dense1),n=iye(n,t.dense2),n=aO(n,[14,14],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await Jge(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock3Params:n}=vye(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return uye(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=gye(e),{extractDenseBlock3Params:a}=yye(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}(e)}};function Uye(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"same",{filters:s,bias:i}=t.conv,o=AO(e,s,n,a);return o=CF(o,i),o=function(e,t){return CF(EF(e,t.weights),t.biases)}(o,t.scale),r?hz(o):o}function jye(e,t){return Uye(e,t,[1,1],!1)}function Gye(e,t){return Uye(e,t,[2,2],!0,"valid")}function Hye(e,t){function n(n,r,a,s){let i=function(t,n,r){let a=e(t),s=a.length/(n*r*r);if(age(s))throw new Error(`depth has to be an integer: ${s}, weights.length: ${a.length}, numFilters: ${n}, filterSize: ${r}`);return cM((()=>cB(Hz(a,[n,s,r,r]),[2,3,1,0])))}(n,r,a),o=Uz(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}function r(r,a,s,i){let o=n(r,a,s,`${i}/conv`),l=function(n,r){let a=Uz(e(n)),s=Uz(e(n));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/biases`}),{weights:a,biases:s}}(a,`${i}/scale`);return{conv:o,scale:l}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e,t,n,a){return{conv1:r((arguments.length>4&&void 0!==arguments[4]&&arguments[4]?.5:1)*e,t,n,`${a}/conv1`),conv2:r(e,t,n,`${a}/conv2`)}}}}function qye(e,t){let n=mye(e,t);function r(e){let t=n(`${e}/conv/filters`,4),r=n(`${e}/conv/bias`,1),a=function(e){return{weights:n(`${e}/scale/weights`,1),biases:n(`${e}/scale/biases`,1)}}(e);return{conv:{filters:t,bias:r},scale:a}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e){return{conv1:r(`${e}/conv1`),conv2:r(`${e}/conv2`)}}}}function Kye(e,t){let n=function(e,t){return Uye(e,t,[1,1],!0)}(e,t.conv1);return n=jye(n,t.conv2),n=CF(n,e),n=hz(n),n}function Xye(e,t){let n=Gye(e,t.conv1);n=jye(n,t.conv2);let r=aO(e,2,2,"valid"),a=pL(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let e=[...n.shape];e[1]=1;let t=pL(e);n=iO([n,t],1);let r=[...n.shape];r[2]=1;let a=pL(r);n=iO([n,a],2)}return r=s?iO([r,a],3):r,n=CF(r,n),n=hz(n),n}var Yye=class extends aye{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return cM((()=>{let n=Gye(vge(kF(e.toBatchTensor(150,!0),"float32"),[122.782,117.001,104.298]).div(255),t.conv32_down);n=lL(n,3,2,"valid"),n=Kye(n,t.conv32_1),n=Kye(n,t.conv32_2),n=Kye(n,t.conv32_3),n=Xye(n,t.conv64_down),n=Kye(n,t.conv64_1),n=Kye(n,t.conv64_2),n=Kye(n,t.conv64_3),n=Xye(n,t.conv128_down),n=Kye(n,t.conv128_1),n=Kye(n,t.conv128_2),n=Xye(n,t.conv256_down),n=Kye(n,t.conv256_1),n=Kye(n,t.conv256_2),n=Xye(n,t.conv256_down_out);let r=n.mean([1,2]);return oO(r,t.fc)}))}async forward(e){return this.forwardInput(await Jge(e))}async computeFaceDescriptor(e){var t;if(null!=(t=null==e?void 0:e.shape)&&t.some((e=>e<=0)))return new Float32Array(128);let n=await Jge(e),r=cM((()=>aB(this.forwardInput(n)))),a=await Promise.all(r.map((e=>e.data())));return r.forEach((e=>e.dispose())),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=qye(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),c=r("conv64_2"),d=r("conv64_3"),h=r("conv128_down"),p=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:v}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!tge(v))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${v}`);let x={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:c,conv64_3:d,conv128_down:h,conv128_1:p,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:v};return uye(e,t),{params:x,paramMappings:t}}(e)}extractParams(e){return function(e){let{extractWeights:t,getRemainingWeights:n}=gye(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=Hye(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),u=s(9216,32,3,"conv32_3"),c=s(36864,64,3,"conv64_down",!0),d=s(36864,64,3,"conv64_1"),h=s(36864,64,3,"conv64_2"),p=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),v=s(589824,256,3,"conv256_2"),x=s(589824,256,3,"conv256_down_out"),w=cM((()=>cB(jz(t(32768),[128,256]),[1,0])));if(r.push({paramPath:"fc"}),0!==n().length)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:c,conv64_1:d,conv64_2:h,conv64_3:p,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:v,conv256_down_out:x,fc:w},paramMappings:r}}(e)}};function Qye(e,t){return{...e,descriptor:t}}function Jye(e,t){return{...e,age:t}}function Zye(e,t,n){return{...e,gender:t,genderProbability:n}}function ebe(e,t){function n(n,r,a,s,i){let o=Hz(e(n*r*a*a),[a,a,n,r]),l=Uz(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/${i?"batch_norm_offset":"bias"}`}),{filters:o,bias:l}}function r(e,t,r,a){let{filters:s,bias:i}=n(e,t,r,a,!0);return{filters:s,batch_norm_offset:i}}function a(n,a,s){let i=function(n,r){let a=Hz(e(9*n),[3,3,n,1]),s=Uz(e(n)),i=Uz(e(n)),o=Uz(e(n)),l=Uz(e(n));return t.push({paramPath:`${r}/filters`},{paramPath:`${r}/batch_norm_scale`},{paramPath:`${r}/batch_norm_offset`},{paramPath:`${r}/batch_norm_mean`},{paramPath:`${r}/batch_norm_variance`}),{filters:a,batch_norm_scale:s,batch_norm_offset:i,batch_norm_mean:o,batch_norm_variance:l}}(n,`${s}/depthwise_conv`);return{depthwise_conv:i,pointwise_conv:r(n,a,1,`${s}/pointwise_conv`)}}return{extractMobilenetV1Params:function(){return{conv_0:r(3,32,3,"mobilenetv1/conv_0"),conv_1:a(32,64,"mobilenetv1/conv_1"),conv_2:a(64,128,"mobilenetv1/conv_2"),conv_3:a(128,128,"mobilenetv1/conv_3"),conv_4:a(128,256,"mobilenetv1/conv_4"),conv_5:a(256,256,"mobilenetv1/conv_5"),conv_6:a(256,512,"mobilenetv1/conv_6"),conv_7:a(512,512,"mobilenetv1/conv_7"),conv_8:a(512,512,"mobilenetv1/conv_8"),conv_9:a(512,512,"mobilenetv1/conv_9"),conv_10:a(512,512,"mobilenetv1/conv_10"),conv_11:a(512,512,"mobilenetv1/conv_11"),conv_12:a(512,1024,"mobilenetv1/conv_12"),conv_13:a(1024,1024,"mobilenetv1/conv_13")}},extractPredictionLayerParams:function(){return{conv_0:r(1024,256,1,"prediction_layer/conv_0"),conv_1:r(256,512,3,"prediction_layer/conv_1"),conv_2:r(512,128,1,"prediction_layer/conv_2"),conv_3:r(128,256,3,"prediction_layer/conv_3"),conv_4:r(256,128,1,"prediction_layer/conv_4"),conv_5:r(128,256,3,"prediction_layer/conv_5"),conv_6:r(256,64,1,"prediction_layer/conv_6"),conv_7:r(64,128,3,"prediction_layer/conv_7"),box_predictor_0:{box_encoding_predictor:n(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),class_predictor:n(512,9,1,"prediction_layer/box_predictor_0/class_predictor")},box_predictor_1:{box_encoding_predictor:n(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),class_predictor:n(1024,18,1,"prediction_layer/box_predictor_1/class_predictor")},box_predictor_2:{box_encoding_predictor:n(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),class_predictor:n(512,18,1,"prediction_layer/box_predictor_2/class_predictor")},box_predictor_3:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_3/class_predictor")},box_predictor_4:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_4/class_predictor")},box_predictor_5:{box_encoding_predictor:n(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),class_predictor:n(128,18,1,"prediction_layer/box_predictor_5/class_predictor")}}}}}function tbe(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=function(e,t){let n=mye(e,t);function r(e,t,r){return{filters:n(`${e}/Conv2d_${t}_pointwise/weights`,4,`${r}/filters`),batch_norm_offset:n(`${e}/Conv2d_${t}_pointwise/convolution_bn_offset`,1,`${r}/batch_norm_offset`)}}function a(e){let t=`mobilenetv1/conv_${e}`,a=`MobilenetV1/Conv2d_${e}_depthwise`,s=`${t}/depthwise_conv`,i=`${t}/pointwise_conv`;return{depthwise_conv:{filters:n(`${a}/depthwise_weights`,4,`${s}/filters`),batch_norm_scale:n(`${a}/BatchNorm/gamma`,1,`${s}/batch_norm_scale`),batch_norm_offset:n(`${a}/BatchNorm/beta`,1,`${s}/batch_norm_offset`),batch_norm_mean:n(`${a}/BatchNorm/moving_mean`,1,`${s}/batch_norm_mean`),batch_norm_variance:n(`${a}/BatchNorm/moving_variance`,1,`${s}/batch_norm_variance`)},pointwise_conv:r("MobilenetV1",e,i)}}function s(e,t){return{filters:n(`${e}/weights`,4,`${t}/filters`),bias:n(`${e}/biases`,1,`${t}/bias`)}}function i(e){return{box_encoding_predictor:s(`Prediction/BoxPredictor_${e}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${e}/box_encoding_predictor`),class_predictor:s(`Prediction/BoxPredictor_${e}/ClassPredictor`,`prediction_layer/box_predictor_${e}/class_predictor`)}}return{extractMobilenetV1Params:function(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}},extractPredictionLayerParams:function(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:i(0),box_predictor_1:i(1),box_predictor_2:i(2),box_predictor_3:i(3),box_predictor_4:i(4),box_predictor_5:i(5)}}}}(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!nge(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return uye(e,t),{params:s,paramMappings:t}}function nbe(e,t,n){return cM((()=>{let r=AO(e,t.filters,n,"same");return r=CF(r,t.batch_norm_offset),IO(r,0,6)}))}var rbe=.0010000000474974513;function abe(e,t){return cM((()=>{let n,r=nbe(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach(((e,t)=>{let a=t+1,s=function(e){return[2,4,6,12].some((t=>t===e))?[2,2]:[1,1]}(a);r=function(e,t,n){return cM((()=>{let r=VO(e,t.filters,n,"same");return r=fO(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,rbe),IO(r,0,6)}))}(r,e.depthwise_conv,s),r=nbe(r,e.pointwise_conv,[1,1]),11===a&&(n=r)})),null===n)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}}))}function sbe(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),c=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),h=(i-a)*(o-s),p=(c-l)*(d-u);if(h<=0||p<=0)return 0;let f=Math.max(a,l),m=Math.max(s,u),g=Math.min(i,c),y=Math.min(o,d),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(h+p-b)}function ibe(e,t){let{sizes:n,centers:r}=function(e){let t=aB(cB(e,[1,0])),n=[JP(t[2],t[0]),JP(t[3],t[1])];return{sizes:n,centers:[CF(t[0],TF(n[0],2)),CF(t[1],TF(n[1],2))]}}(e),a=aB(cB(t,[1,0])),s=TF(EF(kP(TF(a[2],5)),n[0]),2),i=CF(EF(TF(a[0],10),n[0]),r[0]),o=TF(EF(kP(TF(a[3],5)),n[1]),2),l=CF(EF(TF(a[1],10),n[1]),r[1]);return cB(zz([JP(i,s),JP(l,o),CF(i,s),CF(l,o)]),[1,0])}function obe(e,t){return cM((()=>{let n=e.shape[0];return{boxPredictionEncoding:rO(lye(e,t.box_encoding_predictor),[n,-1,1,4]),classPrediction:rO(lye(e,t.class_predictor),[n,-1,3])}}))}var lbe=class{constructor(){let{minConfidence:e,maxResults:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,"number"!=typeof this._minConfidence||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if("number"!=typeof this._maxResults)throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},ube=class extends aye{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return cM((()=>{let n=kF(e.toBatchTensor(512,!1),"float32"),r=abe(JP(TF(n,127.5),1),t.mobilenetv1),{boxPredictions:a,classPredictions:s}=function(e,t,n){return cM((()=>{let r=nbe(e,n.conv_0,[1,1]),a=nbe(r,n.conv_1,[2,2]),s=nbe(a,n.conv_2,[1,1]),i=nbe(s,n.conv_3,[2,2]),o=nbe(i,n.conv_4,[1,1]),l=nbe(o,n.conv_5,[2,2]),u=nbe(l,n.conv_6,[1,1]),c=nbe(u,n.conv_7,[2,2]),d=obe(t,n.box_predictor_0),h=obe(e,n.box_predictor_1),p=obe(a,n.box_predictor_2),f=obe(i,n.box_predictor_3),m=obe(l,n.box_predictor_4),g=obe(c,n.box_predictor_5);return{boxPredictions:iO([d.boxPredictionEncoding,h.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),classPredictions:iO([d.classPrediction,h.classPrediction,p.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1)}}))}(r.out,r.conv11,t.prediction_layer);return function(e,t,n){return cM((()=>{let r=e.shape[0],a=ibe(rO(CP(n.extra_dim,[r,1,1]),[-1,4]),rO(e,[-1,4]));a=rO(a,[r,a.shape[0]/r,4]);let s=lO(uO(t,[0,0,1],[-1,-1,-1])),i=uO(s,[0,0,0],[-1,-1,1]);return i=rO(i,[r,i.shape[1]]),{boxes:aB(a),scores:aB(i)}}))}(a,s,t.output_layer)}))}async forward(e){return this.forwardInput(await Jge(e))}async locateFaces(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{maxResults:n,minConfidence:r}=new lbe(t),a=await Jge(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let y=1;y<s.length;y++)s[y].dispose(),i[y].dispose();let u=Array.from(l.dataSync()),c=function(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map(((e,t)=>({score:e,boxIndex:t}))).filter((e=>e.score>a)).sort(((e,t)=>t.score-e.score)),l=e=>e<=r?1:0,u=[];return o.forEach((t=>{if(u.length>=i)return;let n=t.score;for(let r=u.length-1;r>=0;--r){let n=sbe(e,t.boxIndex,u[r]);if(0!==n&&(t.score*=l(n),t.score<=a))break}n===t.score&&u.push(t.boxIndex)})),u}(o,u,n,.5,r),d=a.getReshapedInputDimensions(0),h=a.inputSize,p=h/d.width,f=h/d.height,m=o.arraySync(),g=c.map((e=>{let[t,n]=[Math.max(0,m[e][0]),Math.min(1,m[e][2])].map((e=>e*f)),[r,s]=[Math.max(0,m[e][1]),Math.min(1,m[e][3])].map((e=>e*p));return new yge(u[e],new kge(r,t,s-r,n-t),{height:a.getInputHeight(0),width:a.getInputWidth(0)})}));return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return tbe(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=gye(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=ebe(n,t),i=a(),o=s(),l={extra_dim:Gz(n(20472),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}(e)}};var cbe=[new pge(.738768,.874946),new pge(2.42204,2.65704),new pge(4.30971,7.04493),new pge(10.246,4.59428),new pge(12.6868,11.8741)],dbe=[new pge(1.603231,2.094468),new pge(6.041143,7.080126),new pge(2.882459,3.518061),new pge(4.266906,5.178857),new pge(9.041765,10.66308)],hbe=[117.001,114.697,97.404],pbe=e=>"number"==typeof e;function fbe(e){return cM((()=>{let t=EF(e,mP(.10000000149011612));return CF(hz(JP(e,t)),t)}))}function mbe(e,t){return cM((()=>{let n=NL(e,[[0,0],[1,1],[1,1],[0,0]]);return n=AO(n,t.conv.filters,[1,1],"valid"),n=JP(n,t.bn.sub),n=EF(n,t.bn.truediv),n=CF(n,t.conv.bias),fbe(n)}))}function gbe(e,t){return cM((()=>{let n=NL(e,[[0,0],[1,1],[1,1],[0,0]]);return n=kz(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=CF(n,t.bias),fbe(n)}))}function ybe(e,t){let n=cye(e,t);let r=pye(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:function(r,a,s){let i=n(r,a,3,`${s}/conv`),o=function(n,r){let a=Uz(e(n)),s=Uz(e(n));return t.push({paramPath:`${r}/sub`},{paramPath:`${r}/truediv`}),{sub:a,truediv:s}}(a,`${s}/bn`);return{conv:i,bn:o}},extractSeparableConvParams:r}}function bbe(e,t){let n=mye(e,t);function r(e){return{filters:n(`${e}/filters`,4),bias:n(`${e}/bias`,1)}}return{extractConvParams:r,extractConvWithBatchNormParams:function(e){let t=r(`${e}/conv`),a=function(e){return{sub:n(`${e}/sub`,1),truediv:n(`${e}/truediv`,1)}}(`${e}/bn`);return{conv:t,bn:a}},extractSeparableConvParams:fye(n)}}var vbe=class{constructor(){let{inputSize:e,scoreThreshold:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,"number"!=typeof this._inputSize||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if("number"!=typeof this._scoreThreshold||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},xbe=class e extends aye{constructor(e){super("TinyYolov2"),function(e){if(!e)throw new Error(`invalid config: ${e}`);if("boolean"!=typeof e.withSeparableConvs)throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!pbe(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every((e=>"string"==typeof e)))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map((e=>e||{})).every((e=>pbe(e.x)&&pbe(e.y))))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||3!==e.meanRgb.length||!e.meanRgb.every(pbe)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=mbe(e,t.conv0);return n=lL(n,[2,2],[2,2],"same"),n=mbe(n,t.conv1),n=lL(n,[2,2],[2,2],"same"),n=mbe(n,t.conv2),n=lL(n,[2,2],[2,2],"same"),n=mbe(n,t.conv3),n=lL(n,[2,2],[2,2],"same"),n=mbe(n,t.conv4),n=lL(n,[2,2],[2,2],"same"),n=mbe(n,t.conv5),n=lL(n,[2,2],[1,1],"same"),n=mbe(n,t.conv6),n=mbe(n,t.conv7),lye(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?fbe(lye(e,t.conv0,"valid",!1)):gbe(e,t.conv0);return n=lL(n,[2,2],[2,2],"same"),n=gbe(n,t.conv1),n=lL(n,[2,2],[2,2],"same"),n=gbe(n,t.conv2),n=lL(n,[2,2],[2,2],"same"),n=gbe(n,t.conv3),n=lL(n,[2,2],[2,2],"same"),n=gbe(n,t.conv4),n=lL(n,[2,2],[2,2],"same"),n=gbe(n,t.conv5),n=lL(n,[2,2],[1,1],"same"),n=t.conv6?gbe(n,t.conv6):n,n=t.conv7?gbe(n,t.conv7):n,lye(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return cM((()=>{let r=kF(e.toBatchTensor(t,!1),"float32");return r=this.config.meanRgb?vge(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)}))}async forward(e,t){return this.forwardInput(await Jge(e),t)}async detect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{inputSize:n,scoreThreshold:r}=new vbe(t),a=await Jge(e),s=await this.forwardInput(a,n),i=cM((()=>aB(s)[0].expandDims())),o={width:a.getInputWidth(0),height:a.getInputHeight(0)},l=await this.extractBoxes(i,a.getReshapedInputDimensions(0),r);s.dispose(),i.dispose();let u=l.map((e=>e.box)),c=l.map((e=>e.score)),d=l.map((e=>e.classScore)),h=l.map((e=>this.config.classes[e.label]));return function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=t.map(((e,t)=>({score:e,boxIndex:t}))).sort(((e,t)=>e.score-t.score)).map((e=>e.boxIndex)),s=[];for(;a.length>0;){let t=a.pop();s.push(t);let i=a,o=[];for(let n=0;n<i.length;n++){let a=i[n],s=e[t],l=e[a];o.push(bge(s,l,r))}a=a.filter(((e,t)=>o[t]<=n))}return s}(u.map((e=>e.rescale(n))),c,this.config.iouThreshold,!0).map((e=>new gge(c[e],d[e],h[e],u[e],o)))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return function(e,t){let n,r=[],{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}=bbe(e,r);if(t.withSeparableConvs){let e=t.filterSizes&&t.filterSizes.length||9;n={conv0:t.isFirstLayerConv2d?a("conv0"):i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:e>7?i("conv6"):void 0,conv7:e>8?i("conv7"):void 0,conv8:a("conv8")}}else n={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:a("conv8")};return uye(e,r),{params:n,paramMappings:r}}(e,this.config)}extractParams(t){let n=this.config.filterSizes||e.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(7!==r&&8!==r&&9!==r)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return function(e,t,n,r){let a,{extractWeights:s,getRemainingWeights:i}=gye(e),o=[],{extractConvParams:l,extractConvWithBatchNormParams:u,extractSeparableConvParams:c}=ybe(s,o);if(t.withSeparableConvs){let[e,s,i,o,u,d,h,p,f]=r;a={conv0:t.isFirstLayerConv2d?l(e,s,3,"conv0"):c(e,s,"conv0"),conv1:c(s,i,"conv1"),conv2:c(i,o,"conv2"),conv3:c(o,u,"conv3"),conv4:c(u,d,"conv4"),conv5:c(d,h,"conv5"),conv6:p?c(h,p,"conv6"):void 0,conv7:f?c(p,f,"conv7"):void 0,conv8:l(f||p||h,5*n,1,"conv8")}}else{let[e,t,s,i,o,c,d,h,p]=r;a={conv0:u(e,t,"conv0"),conv1:u(t,s,"conv1"),conv2:u(s,i,"conv2"),conv3:u(i,o,"conv3"),conv4:u(o,c,"conv4"),conv5:u(c,d,"conv5"),conv6:u(d,h,"conv6"),conv7:u(h,p,"conv7"),conv8:l(p,5*n,1,"conv8")}}if(0!==i().length)throw new Error(`weights remaing after extract: ${i().length}`);return{params:a,paramMappings:o}}(t,this.config,this.boxEncodingSize,n)}async extractBoxes(e,t,n){let{width:r,height:a}=t,s=Math.max(r,a),i=s/r,o=s/a,l=e.shape[1],u=this.config.anchors.length,[c,d,h]=cM((()=>{let t=e.reshape([l,l,u,this.boxEncodingSize]);return[t.slice([0,0,0,0],[l,l,u,4]),t.slice([0,0,0,4],[l,l,u,1]),this.withClassScores?$z(t.slice([0,0,0,5],[l,l,u,this.config.classes.length]),3):mP(0)]})),p=[],f=await d.array(),m=await c.array();for(let g=0;g<l;g++)for(let e=0;e<l;e++)for(let t=0;t<u;t++){let r=xge(f[g][e][t][0]);if(!n||r>n){let n=(e+xge(m[g][e][t][0]))/l*i,a=(g+xge(m[g][e][t][1]))/l*o,s=Math.exp(m[g][e][t][2])*this.config.anchors[t].x/l*i,u=Math.exp(m[g][e][t][3])*this.config.anchors[t].y/l*o,c=n-s/2,d=a-u/2,f={row:g,col:e,anchor:t},{classScore:y,label:b}=this.withClassScores?await this.extractPredictedClass(h,f):{classScore:1,label:0};p.push({box:new mge(c,d,c+s,d+u),score:r,classScore:r*y,label:b,...f})}}return c.dispose(),d.dispose(),h.dispose(),p}async extractPredictedClass(e,t){let{row:n,col:r,anchor:a}=t,s=await e.array();return Array(this.config.classes.length).fill(0).map(((e,t)=>s[n][r][a][t])).map(((e,t)=>({classScore:e,label:t}))).reduce(((e,t)=>e.classScore>t.classScore?e:t))}};xbe.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var wbe=xbe,kbe=class extends wbe{constructor(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];super({withSeparableConvs:e,iouThreshold:.4,classes:["face"],...e?{anchors:dbe,meanRgb:hbe}:{anchors:cbe,withClassScores:!0}})}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new yge(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return this.withSeparableConvs?"tiny_yolov2_separable_conv_model":"tiny_yolov2_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}};var Sbe=class extends vbe{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Ibe=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Cbe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:e=>{let{alignedRect:t}=e;return t},s=e.map((e=>Eye(e)?a(e):e.detection)),i=r||(t instanceof hD?await eye(t,s):await Zge(t,s)),o=await n(i);return i.forEach((e=>e instanceof hD&&e.dispose())),o}async function Nbe(e,t,n,r,a){return Cbe([e],t,(async e=>n(e[0])),r,a)}var Tbe=[new pge(1.603231,2.094468),new pge(6.041143,7.080126),new pge(2.882459,3.518061),new pge(4.266906,5.178857),new pge(9.041765,10.66308)],Ebe=[117.001,114.697,97.404],Abe=class extends wbe{constructor(){super({withSeparableConvs:!0,iouThreshold:.4,classes:["face"],anchors:Tbe,meanRgb:Ebe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]})}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new yge(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},_be={ssdMobilenetv1:new ube,tinyFaceDetector:new Abe,tinyYolov2:new kbe,faceLandmark68Net:new Wye,faceLandmark68TinyNet:new class extends Bye{constructor(){super("FaceLandmark68TinyNet",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Vye)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}},faceRecognitionNet:new Yye,faceExpressionNet:new class extends Sye{constructor(){super("FaceExpressionNet",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new xye)}forwardInput(e){return cM((()=>$z(this.runNet(e))))}async forward(e){return this.forwardInput(await Jge(e))}async predictExpressions(e){let t=await Jge(e),n=await this.forwardInput(t),r=await Promise.all(aB(n).map((async e=>{let t=e.dataSync();return e.dispose(),t})));n.dispose();let a=r.map((e=>new Cye(e)));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}},ageGenderNet:new class extends aye{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Pye(2);super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return cM((()=>{let n=e instanceof Qge?this.faceFeatureExtractor.forwardInput(e):e,r=aO(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1);return{age:wye(r,t.fc.age).as1D(),gender:wye(r,t.fc.gender)}}))}forwardInput(e){return cM((()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:$z(n)}}))}async forward(e){return this.forwardInput(await Jge(e))}async predictAgeAndGender(e){let t=await Jge(e),n=await this.forwardInput(t),r=aB(n.age),a=aB(n.gender),s=r.map(((e,t)=>({ageTensor:e,genderTensor:a[t]}))),i=await Promise.all(s.map((async e=>{let{ageTensor:t,genderTensor:n}=e,r=t.dataSync()[0],a=n.dataSync()[0],s=a>.5,i=s?"male":"female",o=s?a:1-a;return t.dispose(),n.dispose(),{age:r,gender:i,genderProbability:o}})));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=gye(e),a=dye(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=kye(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=mye(e,t);function r(e){return{weights:n(`${e}/weights`,2),bias:n(`${e}/bias`,1)}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return uye(e,t),{params:a,paramMappings:t}}(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}}},$be=class extends Ibe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Rbe=class extends $be{async run(){let e=await this.parentTask,t=await Cbe(e,this.input,(async e=>Promise.all(e.map((e=>_be.faceExpressionNet.predictExpressions(e))))),this.extractedFaces);return e.map(((e,n)=>Nye(e,t[n])))}withAgeAndGender(){return new Pbe(this,this.input)}},Dbe=class extends $be{async run(){let e=await this.parentTask;if(e)return Nye(e,await Nbe(e,this.input,(e=>_be.faceExpressionNet.predictExpressions(e)),this.extractedFaces))}withAgeAndGender(){return new Lbe(this,this.input)}},Mbe=class extends Rbe{withAgeAndGender(){return new zbe(this,this.input)}withFaceDescriptors(){return new Vbe(this,this.input)}},Fbe=class extends Dbe{withAgeAndGender(){return new Bbe(this,this.input)}withFaceDescriptor(){return new Ube(this,this.input)}},Obe=class extends Ibe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Pbe=class extends Obe{async run(){let e=await this.parentTask,t=await Cbe(e,this.input,(async e=>Promise.all(e.map((e=>_be.ageGenderNet.predictAgeAndGender(e))))),this.extractedFaces);return e.map(((e,n)=>{let{age:r,gender:a,genderProbability:s}=t[n];return Jye(Zye(e,a,s),r)}))}withFaceExpressions(){return new Rbe(this,this.input)}},Lbe=class extends Obe{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await Nbe(e,this.input,(e=>_be.ageGenderNet.predictAgeAndGender(e)),this.extractedFaces);return Jye(Zye(e,n,r),t)}withFaceExpressions(){return new Dbe(this,this.input)}},zbe=class extends Pbe{withFaceExpressions(){return new Mbe(this,this.input)}withFaceDescriptors(){return new Vbe(this,this.input)}},Bbe=class extends Lbe{withFaceExpressions(){return new Fbe(this,this.input)}withFaceDescriptor(){return new Ube(this,this.input)}},Wbe=class extends Ibe{constructor(e,t){super(),this.parentTask=e,this.input=t}},Vbe=class extends Wbe{async run(){let e=await this.parentTask;return(await Cbe(e,this.input,(e=>Promise.all(e.map((e=>_be.faceRecognitionNet.computeFaceDescriptor(e))))),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0})))).map(((t,n)=>Qye(e[n],t)))}withFaceExpressions(){return new Mbe(this,this.input)}withAgeAndGender(){return new zbe(this,this.input)}},Ube=class extends Wbe{async run(){let e=await this.parentTask;if(e)return Qye(e,await Nbe(e,this.input,(e=>_be.faceRecognitionNet.computeFaceDescriptor(e)),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0}))))}withFaceExpressions(){return new Fbe(this,this.input)}withAgeAndGender(){return new Bbe(this,this.input)}},jbe=class extends Ibe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?_be.faceLandmark68TinyNet:_be.faceLandmark68Net}},Gbe=class extends jbe{async run(){let e=await this.parentTask,t=e.map((e=>e.detection)),n=this.input instanceof hD?await eye(this.input,t):await Zge(this.input,t),r=await Promise.all(n.map((e=>this.landmarkNet.detectLandmarks(e))));return n.forEach((e=>e instanceof hD&&e.dispose())),e.filter(((e,t)=>r[t])).map(((e,t)=>Aye(e,r[t])))}withFaceExpressions(){return new Mbe(this,this.input)}withAgeAndGender(){return new zbe(this,this.input)}withFaceDescriptors(){return new Vbe(this,this.input)}},Hbe=class extends jbe{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof hD?await eye(this.input,[t]):await Zge(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach((e=>e instanceof hD&&e.dispose())),Aye(e,r)}withFaceExpressions(){return new Fbe(this,this.input)}withAgeAndGender(){return new Bbe(this,this.input)}withFaceDescriptor(){return new Ube(this,this.input)}},qbe=class extends Ibe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new lbe;super(),this.input=e,this.options=t}},Kbe=class extends qbe{async run(){let e,{input:t,options:n}=this;if(n instanceof Sbe)e=_be.tinyFaceDetector.locateFaces(t,n);else if(n instanceof lbe)e=_be.ssdMobilenetv1.locateFaces(t,n);else{if(!(n instanceof vbe))throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");e=_be.tinyYolov2.locateFaces(t,n)}return e}runAndExtendWithFaceDetections(){return new Promise(((e,t)=>{this.run().then((t=>e(t.map((e=>Ege({},e)))))).catch((e=>t(e)))}))}withFaceLandmarks(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return new Gbe(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new Rbe(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new Pbe(this.runAndExtendWithFaceDetections(),this.input)}},Xbe=class extends qbe{async run(){let e=await new Kbe(this.input,this.options),t=e[0];return e.forEach((e=>{e.score>t.score&&(t=e)})),t}runAndExtendWithFaceDetection(){return new Promise((async e=>{let t=await this.run();e(t?Ege({},t):void 0)}))}withFaceLandmarks(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return new Hbe(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new Dbe(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new Lbe(this.runAndExtendWithFaceDetection(),this.input)}};function Ybe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new lbe;return new Kbe(e,t)}var Qbe=class e{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.6;this._distanceThreshold=t;let n=Array.isArray(e)?e:[e];if(!n.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let r=1,a=()=>"person "+r++;this._labeledDescriptors=n.map((e=>{if(e instanceof Nge)return e;if(e instanceof Float32Array)return new Nge(a(),[e]);if(e.descriptor&&e.descriptor instanceof Float32Array)return new Nge(a(),[e.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")}))}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(e,t){return t.map((t=>function(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),r=Array.from(t);return Math.sqrt(n.map(((e,t)=>e-r[t])).reduce(((e,t)=>e+t*t),0))}(t,e))).reduce(((e,t)=>e+t),0)/(t.length||1)}matchDescriptor(e){return this.labeledDescriptors.map((t=>{let{descriptors:n,label:r}=t;return new Cge(r,this.computeMeanDistance(e,n))})).reduce(((e,t)=>e.distance<t.distance?e:t))}findBestMatch(e){let t=this.matchDescriptor(e);return t.distance<this._distanceThreshold?t:new Cge("unknown",t.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map((e=>e.toJSON()))}}static fromJSON(t){let n=t.labeledDescriptors.map((e=>Nge.fromJSON(e)));return new e(n,t.distanceThreshold)}};function Jbe(e,t){let{width:n,height:r}=new Jme(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map((e=>Jbe(e,{width:n,height:r})));if(Eye(e)){let t=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(t.box.width,t.box.height);return Aye(Ege(e,t),a)}return Tge(e)?Ege(e,e.detection.forSize(n,r)):e instanceof Sge||e instanceof yge?e.forSize(n,r):e}var Zbe=n(5879);function eve(e){return(0,gr.Ay)("MuiCircularProgress",e)}(0,rr.A)("MuiCircularProgress",["root","determinate","indeterminate","colorPrimary","colorSecondary","svg","circle","circleDeterminate","circleIndeterminate","circleDisableShrink"]);const tve=44,nve=Nr`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`,rve=Nr`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`,ave="string"!==typeof nve?Cr`
        animation: ${nve} 1.4s linear infinite;
      `:null,sve="string"!==typeof rve?Cr`
        animation: ${rve} 1.4s ease-in-out infinite;
      `:null,ive=(0,cr.Ay)("span",{name:"MuiCircularProgress",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],t[`color${(0,_r.A)(n.color)}`]]}})((0,pr.A)((e=>{let{theme:t}=e;return{display:"inline-block",variants:[{props:{variant:"determinate"},style:{transition:t.transitions.create("transform")}},{props:{variant:"indeterminate"},style:ave||{animation:`${nve} 1.4s linear infinite`}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars||t).palette[n].main}}}))]}}))),ove=(0,cr.Ay)("svg",{name:"MuiCircularProgress",slot:"Svg",overridesResolver:(e,t)=>t.svg})({display:"block"}),lve=(0,cr.Ay)("circle",{name:"MuiCircularProgress",slot:"Circle",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.circle,t[`circle${(0,_r.A)(n.variant)}`],n.disableShrink&&t.circleDisableShrink]}})((0,pr.A)((e=>{let{theme:t}=e;return{stroke:"currentColor",variants:[{props:{variant:"determinate"},style:{transition:t.transitions.create("stroke-dashoffset")}},{props:{variant:"indeterminate"},style:{strokeDasharray:"80px, 200px",strokeDashoffset:0}},{props:e=>{let{ownerState:t}=e;return"indeterminate"===t.variant&&!t.disableShrink},style:sve||{animation:`${rve} 1.4s ease-in-out infinite`}}]}}))),uve=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiCircularProgress"}),{className:r,color:a="primary",disableShrink:s=!1,size:i=40,style:o,thickness:l=3.6,value:u=0,variant:c="indeterminate",...d}=n,h={...n,color:a,disableShrink:s,size:i,thickness:l,value:u,variant:c},p=(e=>{const{classes:t,variant:n,color:r,disableShrink:a}=e,s={root:["root",n,`color${(0,_r.A)(r)}`],svg:["svg"],circle:["circle",`circle${(0,_r.A)(n)}`,a&&"circleDisableShrink"]};return(0,lr.A)(s,eve,t)})(h),f={},m={},g={};if("determinate"===c){const e=2*Math.PI*((tve-l)/2);f.strokeDasharray=e.toFixed(3),g["aria-valuenow"]=Math.round(u),f.strokeDashoffset=`${((100-u)/100*e).toFixed(3)}px`,m.transform="rotate(-90deg)"}return(0,Zn.jsx)(ive,{className:(0,Wn.A)(p.root,r),style:{width:i,height:i,...m,...o},ownerState:h,ref:t,role:"progressbar",...g,...d,children:(0,Zn.jsx)(ove,{className:p.svg,ownerState:h,viewBox:"22 22 44 44",children:(0,Zn.jsx)(lve,{className:p.circle,style:f,ownerState:h,cx:tve,cy:tve,r:(tve-l)/2,fill:"none",strokeWidth:l})})})})),cve=uve;function dve(e){return(0,gr.Ay)("MuiLoadingButton",e)}const hve=(0,rr.A)("MuiLoadingButton",["root","label","loading","loadingIndicator","loadingIndicatorCenter","loadingIndicatorStart","loadingIndicatorEnd","endIconLoadingEnd","startIconLoadingStart"]),pve=(0,cr.Ay)(sl,{shouldForwardProp:e=>(e=>"ownerState"!==e&&"theme"!==e&&"sx"!==e&&"as"!==e&&"classes"!==e)(e)||"classes"===e,name:"MuiLoadingButton",slot:"Root",overridesResolver:(e,t)=>[t.root,t.startIconLoadingStart&&{[`& .${hve.startIconLoadingStart}`]:t.startIconLoadingStart},t.endIconLoadingEnd&&{[`& .${hve.endIconLoadingEnd}`]:t.endIconLoadingEnd}]})((0,pr.A)((e=>{let{theme:t}=e;return{display:"inline-flex",[`& .${hve.startIconLoadingStart}, & .${hve.endIconLoadingEnd}`]:{transition:t.transitions.create(["opacity"],{duration:t.transitions.duration.short}),opacity:0},variants:[{props:{loadingPosition:"center"},style:{transition:t.transitions.create(["background-color","box-shadow","border-color"],{duration:t.transitions.duration.short}),[`&.${hve.loading}`]:{color:"transparent"}}},{props:e=>{let{ownerState:t}=e;return"start"===t.loadingPosition&&t.fullWidth},style:{[`& .${hve.startIconLoadingStart}, & .${hve.endIconLoadingEnd}`]:{transition:t.transitions.create(["opacity"],{duration:t.transitions.duration.short}),opacity:0,marginRight:-8}}},{props:e=>{let{ownerState:t}=e;return"end"===t.loadingPosition&&t.fullWidth},style:{[`& .${hve.startIconLoadingStart}, & .${hve.endIconLoadingEnd}`]:{transition:t.transitions.create(["opacity"],{duration:t.transitions.duration.short}),opacity:0,marginLeft:-8}}}]}}))),fve=(0,cr.Ay)("span",{name:"MuiLoadingButton",slot:"LoadingIndicator",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.loadingIndicator,t[`loadingIndicator${(0,_r.A)(n.loadingPosition)}`]]}})((0,pr.A)((e=>{let{theme:t}=e;return{position:"absolute",visibility:"visible",display:"flex",variants:[{props:{loadingPosition:"start",size:"small"},style:{left:10}},{props:e=>{let{loadingPosition:t,ownerState:n}=e;return"start"===t&&"small"!==n.size},style:{left:14}},{props:{variant:"text",loadingPosition:"start"},style:{left:6}},{props:{loadingPosition:"center"},style:{left:"50%",transform:"translate(-50%)",color:(t.vars||t).palette.action.disabled}},{props:{loadingPosition:"end",size:"small"},style:{right:10}},{props:e=>{let{loadingPosition:t,ownerState:n}=e;return"end"===t&&"small"!==n.size},style:{right:14}},{props:{variant:"text",loadingPosition:"end"},style:{right:6}},{props:e=>{let{ownerState:t}=e;return"start"===t.loadingPosition&&t.fullWidth},style:{position:"relative",left:-10}},{props:e=>{let{ownerState:t}=e;return"end"===t.loadingPosition&&t.fullWidth},style:{position:"relative",right:-10}}]}}))),mve=(0,cr.Ay)("span",{name:"MuiLoadingButton",slot:"Label",overridesResolver:(e,t)=>[t.label]})({display:"inherit",alignItems:"inherit",justifyContent:"inherit"}),gve=T.forwardRef((function(e,t){const n=T.useContext(Jo),r=(0,ho.A)(n,e),a=(0,fr.b)({props:r,name:"MuiLoadingButton"}),{children:s,disabled:i=!1,id:o,loading:l=!1,loadingIndicator:u,loadingPosition:c="center",variant:d="text",...h}=a,p=(0,Zbe.A)(o),f=u??(0,Zn.jsx)(cve,{"aria-labelledby":p,color:"inherit",size:16}),m={...a,disabled:i,loading:l,loadingIndicator:f,loadingPosition:c,variant:d},g=(e=>{const{loading:t,loadingPosition:n,classes:r}=e,a=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;const r={};for(const a in e){const s=e[a];let i="";for(let e=0;e<s.length;e+=1){const r=s[e];r&&(i+=t(r)+" ",n&&n[r]&&(i+=n[r]+" "))}r[a]=i}return r}({root:["root",t&&"loading"],label:["label"],startIcon:[t&&`startIconLoading${(0,_r.A)(n)}`],endIcon:[t&&`endIconLoading${(0,_r.A)(n)}`],loadingIndicator:["loadingIndicator",t&&`loadingIndicator${(0,_r.A)(n)}`]},dve,r);return{...r,...a}})(m),y=l?(0,Zn.jsx)(fve,{className:g.loadingIndicator,ownerState:m,children:f}):null;return(0,Zn.jsxs)(pve,{disabled:i||l,id:p,ref:t,...h,variant:d,classes:g,ownerState:m,children:["end"===m.loadingPosition?(0,Zn.jsx)(mve,{className:g.label,children:s}):y,"end"===m.loadingPosition?y:(0,Zn.jsx)(mve,{className:g.label,children:s})]})})),yve=gve;const bve=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{autoHideDuration:t=null,disableWindowBlurListener:n=!1,onClose:r,open:a,resumeHideDuration:s}=e,i=_s();T.useEffect((()=>{if(a)return document.addEventListener("keydown",e),()=>{document.removeEventListener("keydown",e)};function e(e){e.defaultPrevented||"Escape"===e.key&&r?.(e,"escapeKeyDown")}}),[a,r]);const o=(0,hi.A)(((e,t)=>{r?.(e,t)})),l=(0,hi.A)((e=>{r&&null!=e&&i.start(e,(()=>{o(null,"timeout")}))}));T.useEffect((()=>(a&&l(t),i.clear)),[a,t,l,i]);const u=i.clear,c=T.useCallback((()=>{null!=t&&l(null!=s?s:.5*t)}),[t,s,l]),d=e=>t=>{const n=e.onFocus;n?.(t),u()},h=e=>t=>{const n=e.onMouseEnter;n?.(t),u()},p=e=>t=>{const n=e.onMouseLeave;n?.(t),c()};return T.useEffect((()=>{if(!n&&a)return window.addEventListener("focus",c),window.addEventListener("blur",u),()=>{window.removeEventListener("focus",c),window.removeEventListener("blur",u)}}),[n,a,c,u]),{getRootProps:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={...is(e),...is(t)};return{role:"presentation",...t,...n,onBlur:(r=n,e=>{const t=r.onBlur;t?.(e),c()}),onFocus:d(n),onMouseEnter:h(n),onMouseLeave:p(n)};var r},onClickAway:e=>{r?.(e,"clickaway")}}};function vve(e){return e.substring(2).toLowerCase()}function xve(e){const{children:t,disableReactTree:n=!1,mouseEvent:r="onClick",onClickAway:a,touchEvent:s="onTouchEnd"}=e,i=T.useRef(!1),o=T.useRef(null),l=T.useRef(!1),u=T.useRef(!1);T.useEffect((()=>(setTimeout((()=>{l.current=!0}),0),()=>{l.current=!1})),[]);const c=(0,Br.A)(es(t),o),d=(0,hi.A)((e=>{const t=u.current;u.current=!1;const r=(0,Js.A)(o.current);if(!l.current||!o.current||"clientX"in e&&function(e,t){return t.documentElement.clientWidth<e.clientX||t.documentElement.clientHeight<e.clientY}(e,r))return;if(i.current)return void(i.current=!1);let s;s=e.composedPath?e.composedPath().indexOf(o.current)>-1:!r.documentElement.contains(e.target)||o.current.contains(e.target),s||!n&&t||a(e)})),h=e=>n=>{u.current=!0;const r=t.props[e];r&&r(n)},p={ref:c};return!1!==s&&(p[s]=h(s)),T.useEffect((()=>{if(!1!==s){const e=vve(s),t=(0,Js.A)(o.current),n=()=>{i.current=!0};return t.addEventListener(e,d),t.addEventListener("touchmove",n),()=>{t.removeEventListener(e,d),t.removeEventListener("touchmove",n)}}}),[d,s]),!1!==r&&(p[r]=h(r)),T.useEffect((()=>{if(!1!==r){const e=vve(r),t=(0,Js.A)(o.current);return t.addEventListener(e,d),()=>{t.removeEventListener(e,d)}}}),[d,r]),(0,Zn.jsx)(T.Fragment,{children:T.cloneElement(t,p)})}function wve(e){return(0,gr.Ay)("MuiSnackbarContent",e)}(0,rr.A)("MuiSnackbarContent",["root","message","action"]);const kve=(0,cr.Ay)(xr,{name:"MuiSnackbarContent",slot:"Root",overridesResolver:(e,t)=>t.root})((0,pr.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?.8:.98,r=(0,ur.tL)(t.palette.background.default,n);return{...t.typography.body2,color:t.vars?t.vars.palette.SnackbarContent.color:t.palette.getContrastText(r),backgroundColor:t.vars?t.vars.palette.SnackbarContent.bg:r,display:"flex",alignItems:"center",flexWrap:"wrap",padding:"6px 16px",borderRadius:(t.vars||t).shape.borderRadius,flexGrow:1,[t.breakpoints.up("sm")]:{flexGrow:"initial",minWidth:288}}}))),Sve=(0,cr.Ay)("div",{name:"MuiSnackbarContent",slot:"Message",overridesResolver:(e,t)=>t.message})({padding:"8px 0"}),Ive=(0,cr.Ay)("div",{name:"MuiSnackbarContent",slot:"Action",overridesResolver:(e,t)=>t.action})({display:"flex",alignItems:"center",marginLeft:"auto",paddingLeft:16,marginRight:-8}),Cve=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiSnackbarContent"}),{action:r,className:a,message:s,role:i="alert",...o}=n,l=n,u=(e=>{const{classes:t}=e;return(0,lr.A)({root:["root"],action:["action"],message:["message"]},wve,t)})(l);return(0,Zn.jsxs)(kve,{role:i,square:!0,elevation:6,className:(0,Wn.A)(u.root,a),ownerState:l,ref:t,...o,children:[(0,Zn.jsx)(Sve,{className:u.message,ownerState:l,children:s}),r?(0,Zn.jsx)(Ive,{className:u.action,ownerState:l,children:r}):null]})}));function Nve(e){return(0,gr.Ay)("MuiSnackbar",e)}(0,rr.A)("MuiSnackbar",["root","anchorOriginTopCenter","anchorOriginBottomCenter","anchorOriginTopRight","anchorOriginBottomRight","anchorOriginTopLeft","anchorOriginBottomLeft"]);const Tve=(0,cr.Ay)("div",{name:"MuiSnackbar",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`anchorOrigin${(0,_r.A)(n.anchorOrigin.vertical)}${(0,_r.A)(n.anchorOrigin.horizontal)}`]]}})((0,pr.A)((e=>{let{theme:t}=e;return{zIndex:(t.vars||t).zIndex.snackbar,position:"fixed",display:"flex",left:8,right:8,justifyContent:"center",alignItems:"center",variants:[{props:e=>{let{ownerState:t}=e;return"top"===t.anchorOrigin.vertical},style:{top:8,[t.breakpoints.up("sm")]:{top:24}}},{props:e=>{let{ownerState:t}=e;return"top"!==t.anchorOrigin.vertical},style:{bottom:8,[t.breakpoints.up("sm")]:{bottom:24}}},{props:e=>{let{ownerState:t}=e;return"left"===t.anchorOrigin.horizontal},style:{justifyContent:"flex-start",[t.breakpoints.up("sm")]:{left:24,right:"auto"}}},{props:e=>{let{ownerState:t}=e;return"right"===t.anchorOrigin.horizontal},style:{justifyContent:"flex-end",[t.breakpoints.up("sm")]:{right:24,left:"auto"}}},{props:e=>{let{ownerState:t}=e;return"center"===t.anchorOrigin.horizontal},style:{[t.breakpoints.up("sm")]:{left:"50%",right:"auto",transform:"translateX(-50%)"}}}]}}))),Eve=T.forwardRef((function(e,t){const n=(0,fr.b)({props:e,name:"MuiSnackbar"}),r=hr(),a={enter:r.transitions.duration.enteringScreen,exit:r.transitions.duration.leavingScreen},{action:s,anchorOrigin:{vertical:i,horizontal:o}={vertical:"bottom",horizontal:"left"},autoHideDuration:l=null,children:u,className:c,ClickAwayListenerProps:d,ContentProps:h,disableWindowBlurListener:p=!1,message:f,onBlur:m,onClose:g,onFocus:y,onMouseEnter:b,onMouseLeave:v,open:x,resumeHideDuration:w,TransitionComponent:k=Qs,transitionDuration:S=a,TransitionProps:{onEnter:I,onExited:C,...N}={},...E}=n,A={...n,anchorOrigin:{vertical:i,horizontal:o},autoHideDuration:l,disableWindowBlurListener:p,TransitionComponent:k,transitionDuration:S},_=(e=>{const{classes:t,anchorOrigin:n}=e,r={root:["root",`anchorOrigin${(0,_r.A)(n.vertical)}${(0,_r.A)(n.horizontal)}`]};return(0,lr.A)(r,Nve,t)})(A),{getRootProps:$,onClickAway:R}=bve({...A}),[D,M]=T.useState(!0),F=cs({elementType:Tve,getSlotProps:$,externalForwardedProps:E,ownerState:A,additionalProps:{ref:t},className:[_.root,c]});return!x&&D?null:(0,Zn.jsx)(xve,{onClickAway:R,...d,children:(0,Zn.jsx)(Tve,{...F,children:(0,Zn.jsx)(k,{appear:!0,in:x,timeout:S,direction:"top"===i?"down":"up",onEnter:(e,t)=>{M(!1),I&&I(e,t)},onExited:e=>{M(!0),C&&C(e)},...N,children:u||(0,Zn.jsx)(Cve,{message:f,action:s,...h})})})})}));var Ave=n(6111),_ve=n.n(Ave);const $ve=[],Rve=e=>{let{firstName:t,lastName:n,email:r,dateOfBirth:a,onBack:s}=e;const i=(0,T.useRef)(null),[o,l]=(0,T.useState)(0),[u,c]=(0,T.useState)(!1),[d,h]=(0,T.useState)(!1),[p,f]=(0,T.useState)(!1),m=ee(),g=xn(),y=async()=>{c(!0);try{const e=((e,t,n,r)=>_ve().AES.encrypt(e||"",`${t||""} ${n||""}`+r).toString())(r,t,n,a),s=((e,t,n,r)=>e.map((e=>_ve().AES.encrypt(JSON.stringify(e),`${t||""} ${n||""}`+r).toString())))($ve,t,n,a),i={name:`${t||""} ${n||""}`,email:e,DOB:a||"",...s.reduce(((e,t,n)=>(e[`descriptors_${n}`]=t||[],e)),{})},o=await(async e=>await hv(_b(gv,"users"),e))(i);console.log("Document written with ID: ",o.id),m(wt(o.id)),g("/loggedUser")}catch(gD){console.error("Error adding document: ",gD)}finally{c(!1)}};return 5===o&&(y(),l((e=>e+1))),(0,Zn.jsxs)(or,{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",padding:2,height:"100vh",bgcolor:"#f5f5f5",children:[(0,Zn.jsxs)(xr,{elevation:3,sx:{padding:4,borderRadius:4,maxWidth:900,width:"100%"},children:[(0,Zn.jsx)(Pr,{variant:"h5",gutterBottom:!0,textAlign:"center",children:"Capture Your Photo"}),(0,Zn.jsx)(sl,{variant:"contained",color:"secondary",onClick:s,sx:{marginBottom:2,position:"absolute",left:20,top:20},children:"Back"}),(0,Zn.jsxs)(or,{display:"flex",flexDirection:{xs:"column",md:"row"},justifyContent:"center",gap:5,alignItems:"center",children:[(0,Zn.jsx)(dT(),{audio:!1,ref:i,screenshotFormat:"image/jpeg",style:{borderRadius:10,width:"100%",maxWidth:650,height:"auto"}}),o<5&&(0,Zn.jsxs)(or,{display:"flex",flexDirection:"column",alignItems:"center",children:[(0,Zn.jsx)(or,{children:(0,Zn.jsx)(or,{component:"img",alt:"Face Snapshot Guide",src:`/snapshotGuide/face_${o+1}.jpg`,sx:{width:{xs:"80%",md:250},height:"auto",borderRadius:2,objectFit:"contain",boxShadow:2}})}),(0,Zn.jsx)(yve,{variant:"contained",color:"primary",onClick:async()=>{try{h(!0);const e=i.current.getScreenshot(),t=new Image;t.src=e,await t.decode();const n=await function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new lbe;return new Xbe(e,t)}(t,new Sbe).withFaceLandmarks().withFaceDescriptor();n?($ve.push(Array.from(n.descriptor)),l((e=>e+1))):f(!0)}catch(e){f(!0)}finally{h(!1)}},disabled:o>4,sx:{marginTop:3,width:"100%"},loading:d,children:"Capture Photo"})]})]})]}),(0,Zn.jsx)(Eve,{open:p,autoHideDuration:3e3,onClose:()=>f(!1),anchorOrigin:{vertical:"top",horizontal:"center"},children:(0,Zn.jsx)(Sl,{variant:"filled",severity:"error",sx:{width:"30vw"},children:"Please re-take the image"})})]})},Dve=()=>{const[e,t]=(0,T.useState)({firstName:"",lastName:"",email:"",dateOfBirth:null}),[n,r]=(0,T.useState)({firstName:"",lastName:"",email:"",dateOfBirth:""}),[a,s]=(0,T.useState)(null),[i,o]=(0,T.useState)(!1),l=xn(),u=(n,r)=>{t({...e,[n]:r})},c=(0,T.useMemo)((()=>{switch(a){case"minDate":case"maxDate":return"Date of Birth cannot be in the future or an invalid range";case"invalidDate":return"Invalid date format";default:return""}}),[a]);var d;return i?(0,Zn.jsx)(Rve,{firstName:e.firstName,lastName:e.lastName,email:e.email,dateOfBirth:null===(d=e.dateOfBirth)||void 0===d?void 0:d.toISOString(),onBack:()=>o(!1)}):(0,Zn.jsx)(or,{display:"flex",justifyContent:"center",alignItems:"center",minHeight:"100vh",sx:{backgroundColor:"#f5f5f5"},children:(0,Zn.jsxs)(kv,{variant:"outlined",sx:{width:"400px",p:2},children:[(0,Zn.jsxs)(Cv,{children:[(0,Zn.jsx)(Pr,{variant:"h5",component:"h2",gutterBottom:!0,align:"center",children:"Registration Form"}),(0,Zn.jsxs)(or,{component:"form",onSubmit:t=>{t.preventDefault(),(()=>{let t={...n};t.firstName=e.firstName?"":"First Name is required",t.lastName=e.lastName?"":"Last Name is required",t.email=/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e.email)?"":"Email is not valid",t.dateOfBirth=e.dateOfBirth?c:"Date of Birth is required",e.dateOfBirth&&KN()().diff(KN()(e.dateOfBirth),"year")<13&&(t.dateOfBirth="You must be at least 13 years old");return r(t),console.log(n),Object.values(t).every((e=>""===e))})()&&o(!0)},noValidate:!0,sx:{mt:2},children:[(0,Zn.jsx)(No,{label:"First Name",variant:"outlined",fullWidth:!0,value:e.firstName,onChange:e=>u("firstName",e.target.value),error:!!n.firstName,helperText:n.firstName,margin:"normal"}),(0,Zn.jsx)(No,{label:"Last Name",variant:"outlined",fullWidth:!0,value:e.lastName,onChange:e=>u("lastName",e.target.value),error:!!n.lastName,helperText:n.lastName,margin:"normal"}),(0,Zn.jsx)(No,{label:"Email",variant:"outlined",fullWidth:!0,value:e.email,onChange:e=>u("email",e.target.value),error:!!n.email,helperText:n.email,margin:"normal"}),(0,Zn.jsx)(Ev,{dateAdapter:uT,children:(0,Zn.jsx)(HN,{label:"Date of Birth",value:e.dateOfBirth,onChange:e=>u("dateOfBirth",e),onError:e=>s(e),slotProps:{textField:{helperText:n.dateOfBirth||c,error:!!n.dateOfBirth||!!a}},sx:{mt:2,mb:1,width:1},minDate:KN()().subtract(100,"year"),maxDate:KN()()})}),(0,Zn.jsx)(sl,{type:"submit",variant:"contained",fullWidth:!0,sx:{mt:2},children:"Submit"})]})]}),(0,Zn.jsxs)(Pr,{variant:"body2",textAlign:"center",children:["Already have an account \xa0",(0,Zn.jsx)($l,{component:"button",variant:"body2",onClick:()=>{l("/login")},children:"Click here to Login"})]})]})})},Mve=()=>{const e=xn();return(0,Zn.jsx)(or,{display:"flex",justifyContent:"center",alignItems:"center",minHeight:"100vh",bgcolor:"#f5f5f5",padding:3,children:(0,Zn.jsxs)(xr,{elevation:3,sx:{padding:4,borderRadius:2,maxWidth:500,textAlign:"center"},children:[(0,Zn.jsx)(ou.A,{sx:{fontSize:80,color:"error.main",mb:2}}),(0,Zn.jsx)(Pr,{variant:"h4",gutterBottom:!0,children:"Oops! Something went wrong."}),(0,Zn.jsx)(Pr,{variant:"body1",paragraph:!0,children:"We couldn't find the information you were looking for. This might be due to an expired session or an invalid request."}),(0,Zn.jsx)(sl,{variant:"contained",color:"primary",onClick:()=>e("/"),sx:{mt:2},children:"Go to Home Page"})]})})};class Fve{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Ove{refCount(e){return Pve("refCount")}incRef(e){return Pve("incRef")}timerAvailable(){return!0}time(e){return Pve("time")}read(e){return Pve("read")}readSync(e){return Pve("readSync")}readToGPU(e,t){return Pve("readToGPU")}numDataIds(){return Pve("numDataIds")}disposeData(e,t){return Pve("disposeData")}write(e,t,n){return Pve("write")}move(e,t,n,r,a){return Pve("move")}createTensorFromGPUData(e,t,n){return Pve("createTensorFromGPUData")}memory(){return Pve("memory")}floatPrecision(){return Pve("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Pve("dispose")}}function Pve(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Lve(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Wve(e,t,n)}function zve(e,t,n){return Math.max(e,Math.min(t,n))}function Bve(e){return e%2===0?e:e+1}function Wve(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function Vve(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function Uve(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Vve(Hve(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function jve(e){Vve(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Gve(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Hve(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function qve(e){return e%1===0}function Kve(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Xve(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Yve(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,s)=>{let i=0;const o=()=>{if(e())return void a();i++;const l=t(i);null!=n&&i>=n?s():null!=r?r(o,l):setTimeout(o,l)};o()}))}function Qve(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const a=e.slice();return a[r]=t/n,a}function Jve(e,t){const n=t.length;return Vve((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),Vve(e.every((e=>qve(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function Zve(e,t){const n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:Jve(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function exe(e,t){return txe(e,t)}function txe(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function nxe(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function rxe(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function axe(e){return"string"===typeof e||e instanceof String}function sxe(e){return"number"===typeof e}function ixe(e){return Array.isArray(e)?ixe(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":sxe(e)?"float32":axe(e)?"string":"boolean"===typeof e?"bool":"float32"}function oxe(e){return!!(e&&e.constructor&&e.call&&e.apply)}function lxe(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function uxe(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function cxe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===t.length){const s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{const s=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=cxe(e+t*o,i,n,r)}return a}function dxe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return cxe(0,e,t,n)}function hxe(e,t){const n=pxe(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function pxe(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function fxe(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return dxe(e,new Float32Array(n));if("int32"===t)return dxe(e,new Int32Array(n));if("bool"===t)return dxe(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function mxe(e){e.forEach((t=>{Vve(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function gxe(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function yxe(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function bxe(e){return e&&e.then&&"function"===typeof e.then}const vxe="tfjsflags";class xxe{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=wxe,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(kxe().getBool("IS_TEST")||kxe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];kxe().getBool("IS_TEST")||kxe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(bxe(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(vxe in e){e[vxe].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}}function wxe(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function kxe(){return Ixe}let Sxe,Ixe=null;function Cxe(){if(null==Sxe){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}Sxe=e}return Sxe}function Nxe(e,t){const n=function(){const e=Cxe();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const Txe="Abs",Exe="Acos",Axe="Acosh",_xe="Add",$xe="AddN",Rxe="All",Dxe="Any",Mxe="ArgMax",Fxe="ArgMin",Oxe="Asin",Pxe="Asinh",Lxe="Atan",zxe="Atanh",Bxe="Atan2",Wxe="AvgPool",Vxe="AvgPoolGrad",Uxe="AvgPool3D",jxe="AvgPool3DGrad",Gxe="BatchMatMul",Hxe="BatchToSpaceND",qxe="Bincount",Kxe="BitwiseAnd",Xxe="BroadcastArgs",Yxe="Cast",Qxe="Ceil",Jxe="ClipByValue",Zxe="Complex",ewe="ComplexAbs",twe="Concat",nwe="Conv2D",rwe="Conv2DBackpropFilter",awe="Conv2DBackpropInput",swe="Conv3D",iwe="Conv3DBackpropFilterV2",owe="Conv3DBackpropInputV2",lwe="Cos",uwe="Cosh",cwe="Cumprod",dwe="Cumsum",hwe="CropAndResize",pwe="DenseBincount",fwe="DepthToSpace",mwe="DepthwiseConv2dNative",gwe="DepthwiseConv2dNativeBackpropFilter",ywe="DepthwiseConv2dNativeBackpropInput",bwe="Diag",vwe="Dilation2D",xwe="Dilation2DBackpropInput",wwe="Dilation2DBackpropFilter",kwe="Draw",Swe="RealDiv",Iwe="Einsum",Cwe="Elu",Nwe="EluGrad",Twe="Erf",Ewe="Equal",Awe="Exp",_we="ExpandDims",$we="Expm1",Rwe="FFT",Dwe="Fill",Mwe="FlipLeftRight",Fwe="Floor",Owe="FloorDiv",Pwe="FusedBatchNorm",Lwe="GatherV2",zwe="GatherNd",Bwe="Greater",Wwe="GreaterEqual",Vwe="Identity",Uwe="IFFT",jwe="Imag",Gwe="IsFinite",Hwe="IsInf",qwe="IsNan",Kwe="LeakyRelu",Xwe="Less",Ywe="LessEqual",Qwe="LinSpace",Jwe="Log",Zwe="Log1p",eke="LogicalAnd",tke="LogicalNot",nke="LogicalOr",rke="LRN",ake="LRNGrad",ske="Max",ike="Maximum",oke="MaxPool",lke="MaxPoolGrad",uke="MaxPool3D",cke="MaxPool3DGrad",dke="MaxPoolWithArgmax",hke="Mean",pke="Min",fke="Minimum",mke="MirrorPad",gke="Mod",yke="Multinomial",bke="Multiply",vke="Neg",xke="NotEqual",wke="NonMaxSuppressionV3",kke="NonMaxSuppressionV4",Ske="NonMaxSuppressionV5",Ike="OnesLike",Cke="OneHot",Nke="Pack",Tke="PadV2",Eke="Pow",Ake="Prelu",_ke="Prod",$ke="RaggedGather",Rke="RaggedRange",Dke="RaggedTensorToTensor",Mke="Range",Fke="Real",Oke="Reciprocal",Pke="Relu",Lke="Reshape",zke="ResizeNearestNeighbor",Bke="ResizeNearestNeighborGrad",Wke="ResizeBilinear",Vke="ResizeBilinearGrad",Uke="Relu6",jke="Reverse",Gke="Round",Hke="Rsqrt",qke="ScatterNd",Kke="TensorScatterUpdate",Xke="SearchSorted",Yke="Select",Qke="Selu",Jke="Slice",Zke="Sin",eSe="Sinh",tSe="Sign",nSe="Sigmoid",rSe="Softplus",aSe="Sqrt",sSe="Sum",iSe="SpaceToBatchND",oSe="SplitV",lSe="Softmax",uSe="SparseFillEmptyRows",cSe="SparseReshape",dSe="SparseSegmentMean",hSe="SparseSegmentSum",pSe="SparseToDense",fSe="SquaredDifference",mSe="Square",gSe="StaticRegexReplace",ySe="StridedSlice",bSe="StringNGrams",vSe="StringSplit",xSe="StringToHashBucketFast",wSe="Sub",kSe="Tan",SSe="Tanh",ISe="Tile",CSe="TopK",NSe="Transform",TSe="Transpose",ESe="Unique",ASe="Unpack",_Se="UnsortedSegmentSum",$Se="ZerosLike",RSe="Step",DSe="FromPixels",MSe="RotateWithOffset",FSe="_FusedMatMul",OSe="FusedConv2D",PSe="FusedDepthwiseConv2D";function LSe(){kxe().getBool("IS_TEST")||kxe().getBool("PROD")||console.warn(...arguments)}function zSe(){kxe().getBool("IS_TEST")||kxe().getBool("PROD")||console.log(...arguments)}const BSe=Nxe("kernelRegistry",(()=>new Map)),WSe=Nxe("gradRegistry",(()=>new Map));function VSe(e,t){const n=qSe(e,t);return BSe.get(n)}function USe(e){return WSe.get(e)}function jSe(e){const t=BSe.entries(),n=[];for(;;){const{done:r,value:a}=t.next();if(r)break;const[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function GSe(e){const{kernelName:t,backendName:n}=e,r=qSe(t,n);BSe.has(r)&&LSe(`The kernel '${t}' for backend '${n}' is already registered`),BSe.set(r,e)}function HSe(e){const{kernelName:t}=e;WSe.has(t)&&kxe().getBool("DEBUG")&&LSe(`Overriding the gradient for '${t}'`),WSe.set(t,e)}function qSe(e,t){return`${t}_${e}`}function KSe(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var XSe=n(8818);const YSe=n.n(XSe)()||XSe;function QSe(e){return YSe.fromString(e,!0,16)}const JSe=QSe("c3a5c85c97cb3127"),ZSe=QSe("b492b66fbe98f273"),eIe=QSe("9ae16a3b2f90404f");function tIe(e){return e.xor(e.shru(47))}function nIe(e,t,n){const r=e.slice(t,t+n);return YSe.fromBytes(Array.from(r),!0,!0)}function rIe(e,t){return nIe(e,t,8)}function aIe(e,t){return nIe(e,t,4)}function sIe(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function iIe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:QSe("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function oIe(e,t,n,r){return function(e,t,n,r,a,s){a=a.add(e),s=sIe(s.add(a).add(r),21);const i=a;return a=(a=a.add(t)).add(n),s=s.add(sIe(a,44)),[a.add(r),s.add(i)]}(rIe(e,t),rIe(e,t+8),rIe(e,t+16),rIe(e,t+24),n,r)}function lIe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=YSe.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=eIe.add(2*t),r=rIe(e,0).add(eIe),a=rIe(e,t-8);return iIe(sIe(a,37).mul(n).add(r),sIe(r,25).add(a).mul(n),n)}if(t>=4){const n=eIe.add(2*t);return iIe(aIe(e,0).shl(3).add(t),aIe(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return tIe(eIe.mul(n).xor(JSe.mul(r))).mul(eIe)}return eIe}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=eIe.add(2*t),r=rIe(e,0).mul(ZSe),a=rIe(e,8),s=rIe(e,t-8).mul(n),i=rIe(e,t-16).mul(eIe);return iIe(sIe(r.add(a),43).add(sIe(s,30)).add(i),r.add(sIe(a.add(eIe),18)).add(s),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=eIe.add(2*t),r=rIe(e,0).mul(eIe),a=rIe(e,8),s=rIe(e,t-8).mul(n),i=rIe(e,t-16).mul(eIe),o=sIe(r.add(a),43).add(sIe(s,30)).add(i),l=iIe(o,r.add(sIe(a.add(eIe),18)).add(s),n),u=rIe(e,16).mul(n),c=rIe(e,24),d=o.add(rIe(e,t-32)).mul(n),h=l.add(rIe(e,t-24)).mul(n);return iIe(sIe(u.add(c),43).add(sIe(d,30)).add(h),u.add(sIe(c.add(r),18)).add(d),n)}(e,t);let r=n,a=n.mul(ZSe).add(113),s=tIe(a.mul(eIe).add(113)).mul(eIe),i=[YSe.UZERO,YSe.UZERO],o=[YSe.UZERO,YSe.UZERO];r=r.mul(eIe).add(rIe(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=sIe(r.add(a).add(i[0]).add(rIe(e,l+8)),37).mul(ZSe),a=sIe(a.add(i[1]).add(rIe(e,l+48)),42).mul(ZSe),r=r.xor(o[1]),a=a.add(i[0]).add(rIe(e,l+40)),s=sIe(s.add(o[0]),33).mul(ZSe),i=oIe(e,l,i[1].mul(ZSe),r.add(o[0])),o=oIe(e,l+32,s.add(o[1]),a.add(rIe(e,l+16))),[s,r]=[r,s],l+=64}while(l!==u);const d=ZSe.add(s.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=sIe(r.add(a).add(i[0]).add(rIe(e,l+8)),37).mul(d),a=sIe(a.add(i[1]).add(rIe(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(rIe(e,l+40))),s=sIe(s.add(o[0]),33).mul(d),i=oIe(e,l,i[1].mul(d),r.add(o[0])),o=oIe(e,l+32,s.add(o[1]),a.add(rIe(e,l+16))),[s,r]=[r,s],iIe(iIe(i[0],o[0],d).add(tIe(a).mul(JSe)).add(s),iIe(i[1],o[1],d).add(r),d)}function uIe(e,t){return"string"===t?pIe(e):cIe([e],t)}function cIe(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=gIe(e)),kxe().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function dIe(){return kxe().platform.now()}function hIe(e,t){return kxe().platform.fetch(e,t)}function pIe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",kxe().platform.encode(e,t)}function fIe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",kxe().platform.decode(e,t)}function mIe(e){return null!=kxe().platform.isTypedArray?kxe().platform.isTypedArray(e):KSe(e)}function gIe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||bxe(e)||null==e||mIe(e)&&n)t.push(e);else if(Array.isArray(e)||mIe(e))for(let r=0;r<e.length;++r)gIe(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)gIe(e[a],t,n)}return t}class yIe{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new vIe)}profileKernel(e,t,n){let r;const a=()=>{r=n()};let s;const i=dIe();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(a);else{a();for(const e of r)e.dataSync();s=Promise.resolve({kernelMs:dIe()-i})}if(kxe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){const t=r[o];t.data().then((n=>{bIe(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}}function bIe(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class vIe{logKernelProfile(e,t,n,r,a,s){const i="number"===typeof r?Xve(`${r}ms`,9):r.error,o=Xve(e,25),l=t.rank,u=t.size,c=Xve(t.shape.toString(),14);let d="";for(const h in a){const e=a[h];if(null!=e){const n=e.shape||t.shape,r=n.length;d+=`${h}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const xIe=20,wIe=3,kIe=7;function SIe(e,t,n,r){const a=uxe(t),s=function(e,t,n,r){const a=Gve(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l="complex64"===n?TIe(e):e;if(o>1)for(let u=0;u<a/s;u++){const e=u*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],IIe(l[e+t],0,n).length)}return i}(e,t,n,a),i=t.length,o=NIe(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function IIe(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(kIe))} + ${parseFloat(e[1].toFixed(kIe))}j`:axe(e)?`'${e}'`:"bool"===n?CIe(e):parseFloat(e.toFixed(kIe)).toString(),Xve(r,t)}function CIe(e){return 0===e?"false":"true"}function NIe(e,t,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[IIe(TIe(e)[0],0,n)]}return"bool"===n?[CIe(e[0])]:[e[0].toString()]}if(1===l){if(o>xIe){const t=wIe*i;let r=Array.from(e.slice(0,t)),s=Array.from(e.slice((o-wIe)*i,o*i));return"complex64"===n&&(r=TIe(r),s=TIe(s)),["["+r.map(((e,t)=>IIe(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>IIe(e,a[o-wIe+t],n))).join(", ")+"]"]}return["["+("complex64"===n?TIe(e):Array.from(e)).map(((e,t)=>IIe(e,a[t],n))).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>xIe){for(let t=0;t<wIe;t++){const r=t*d,s=r+d;h.push(...NIe(e.slice(r,s),u,n,c,a,!1))}h.push("...");for(let t=o-wIe;t<o;t++){const r=t*d,s=r+d;h.push(...NIe(e.slice(r,s),u,n,c,a,t===o-1))}}else for(let m=0;m<o;m++){const t=m*d,r=t+d;h.push(...NIe(e.slice(t,r),u,n,c,a,m===o-1))}const p=2===l?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(s?"":f),h}function TIe(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class EIe{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Gve(e),null!=n){const e=n.length;Vve(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||txe(t,this.size),this.strides=uxe(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),Vve(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));const a=this.locToIndex(n);this.values[a]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(const s of t){if(s<0||s>=this.shape[r]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let a=t[t.length-1];for(let s=0;s<t.length-1;++s)a+=this.strides[s]*t[s];return this.values[a]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return AIe().makeTensor(this.values,this.shape,this.dtype)}}let AIe=null,_Ie=null,$Ie=null;class RIe{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Gve(e),this.strides=uxe(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return _Ie.buffer(this.shape,this.dtype,e)}bufferSync(){return _Ie.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return dxe(this.shape,e,"complex64"===this.dtype)}arraySync(){return dxe(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=AIe().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>fIe(e)))}catch(tL){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),AIe().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=AIe().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>fIe(e)))}catch(tL){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await AIe().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),AIe().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return _Ie.print(this,e)}clone(){return this.throwIfDisposed(),_Ie.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return SIe(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),_Ie.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),AIe().makeVariable(this,e,t,n)}}function DIe(){return Nxe("Tensor",(()=>RIe))}Object.defineProperty(RIe,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),DIe();class MIe extends RIe{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Hve(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);AIe().disposeTensor(this),this.dataId=e.dataId,AIe().incRef(this,null)}dispose(){AIe().disposeVariable(this),this.isDisposedInternal=!0}}var FIe,OIe,PIe,LIe,zIe;Object.defineProperty(MIe,Symbol.hasInstance,{value:e=>e instanceof RIe&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(FIe||(FIe={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(OIe||(OIe={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(PIe||(PIe={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(LIe||(LIe={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(zIe||(zIe={}));const BIe={float32:LIe,int32:OIe,bool:PIe,complex64:zIe};function WIe(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return BIe[e][t]}function VIe(e){return WIe(e,"int32")}function UIe(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function jIe(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function GIe(e,t){if(e.dtype===t.dtype)return[e,t];const n=WIe(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function HIe(e,t){return t.some((t=>t.id===e.id))}function qIe(e){const t=[];return KIe(e,t,new Set),t}function KIe(e,t,n){if(null==e)return;if(e instanceof RIe)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!==typeof r)return;var r;const a=e;for(const s in a){const e=a[s];n.has(e)||(n.add(e),KIe(e,t,n))}}function XIe(e){return null!=e.kernelName}class YIe{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class QIe{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new YIe}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(LSe(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new yIe(this.backendInstance),!0}setupRegisteredKernels(){jSe(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){jSe(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof Ove||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,LSe(`Initialization of backend ${e} failed`),LSe(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return LSe(`Initialization of backend ${e} failed`),LSe(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return QIe.nextTensorId++}nextVariableId(){return QIe.nextVariableId++}clone(e){const t=ZIe.runKernel(Vwe,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return ZIe.runKernel(Yxe,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=VSe(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=XIe(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(XIe(e)){const{kernelName:t,inputs:a,attrs:s}=e;null==this.backendName&&this.backend;const l=VSe(t,this.backendName);Vve(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();o=l.kernelFunc({inputs:a,attrs:s,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const u=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,a,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,a=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,a)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,d=XIe(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(l,u,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=i()})),r&&this.addTapeNode(l,u,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=USe(e);if(null!=r){const e=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(Vve(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const i=n.filter(((e,t)=>a[t]));return s.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&axe(e[0])&&(a=e.map((e=>pIe(e))));const s=r.write(a,t,n),i=new RIe(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(s),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:a}=e,s=new RIe(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const a=new MIe(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*rxe(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof MIe||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*rxe(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=USe(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=pxe(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=qIe(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const e=this.state.activeScope.track[a];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Vve(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Vve(a instanceof RIe,(()=>"The result y returned by f() must be a tensor."));const s=function(e,t,n){const r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const n=e[l],s=n.inputs;for(const e in s){const i=s[e];let o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[n.id]=!0;break}if(o)break}}const s={};s[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(const e in n)s[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const t=e[l];if(a[t.id]&&i[t.id]){const e={};for(const a in t.inputs){const n=t.inputs[a];r[n.id]&&(e[a]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[a.id]=null==n?function(e){const t=hxe(Gve(e),"float32");return ZIe.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){const s=t[a],i=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(i);for(const t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);const i=s.inputs[t];if(!Hve(a.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{const t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}(e,s,(e=>this.tidy(e)),eCe);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){var t=this;return Vve(oxe(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let s;Vve(r.every((e=>e instanceof RIe)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(s=e(...r,n),Vve(s.value instanceof RIe,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Vve(oxe(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(e,t)=>{const n=s.gradFunc(e,t),a=Array.isArray(n)?n:[n];Vve(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Vve(a.every((e=>e instanceof RIe)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=dIe(),n=await this.backend.time(e);return n.wallMs=dIe()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new YIe;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function JIe(){const e=Cxe();if(null==e._tfengine){const t=new xxe(e);e._tfengine=new QIe(t)}var t;return t=e._tfengine.ENV,Ixe=t,function(e){AIe=e}((()=>e._tfengine)),e._tfengine}QIe.nextTensorId=0,QIe.nextVariableId=0;const ZIe=JIe();function eCe(e,t){const n={a:e,b:t};return ZIe.runKernel(_xe,n)}let tCe;function nCe(e){if(void 0!==tCe)return tCe;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function rCe(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const aCe=kxe();function sCe(e,t){let n=e;if(mIe(e))return"string"===t?[]:[e.length];if(UIe(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(jIe(e))return[e.buffer.size/(null==t?4:rxe(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||mIe(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&kxe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&iCe(e,r,[]),r}function iCe(e,t,n){if(n=n||[],!Array.isArray(e)&&!mIe(e))return void Vve(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Vve(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Vve(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let a=0;a<e.length;++a)iCe(e[a],r,n.concat(a))}function oCe(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function lCe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof DIe())return oCe(r,e.dtype,t,n),e;let a=ixe(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),oCe(r,a,t,n),null==e||!mIe(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const s=sCe(e,a);mIe(e)||Array.isArray(e)||(e=[e]);const i="string"!==a?cIe(e,a):gIe(e,[],!0);return ZIe.makeTensor(i,s,a)}function uCe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>lCe(e,`${t}[${a}]`,n,r)))}aCe.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),aCe.registerFlag("IS_BROWSER",(()=>rCe())),aCe.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),aCe.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),aCe.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),aCe.registerFlag("PROD",(()=>!1)),aCe.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>aCe.getBool("DEBUG"))),aCe.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),aCe.registerFlag("IS_TEST",(()=>!1)),aCe.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>aCe.getBool("DEBUG"))),aCe.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),aCe.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),aCe.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const cCe="__op";function dCe(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=cCe;const a=function(){ZIe.startScope(n);try{const e=r(...arguments);return bxe(e)&&console.error("Cannot return a Promise inside of tidy."),ZIe.endScope(e),e}catch(e){throw ZIe.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const hCe=dCe({complex_:function(e,t){const n=lCe(e,"real","complex"),r=lCe(t,"imag","complex");Uve(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const a={real:n,imag:r};return ZIe.runKernel(Zxe,a)}});function pCe(e,t,n,r){if(null==r)r=ixe(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(jIe(e)||UIe(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ZIe.backend.createTensorFromGPUData(e,t||n,r)}if(!mIe(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){mxe(t);const e=Gve(t),r=Gve(n);Vve(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){const e=n[a],r=a!==n.length-1||e!==Gve(t.slice(a));Vve(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return mIe(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?cIe(e,r):gIe(e,[],!0),ZIe.makeTensor(e,t,r)}function fCe(e,t,n){return pCe(e,t,sCe(e,n),n)}const mCe={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class gCe{static join(e){return new gCe(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>mIe(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),a=new Uint8Array(r);let s=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],r=e+s-n.start,o=s,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(a.set(u,o),s+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const a=Math.floor((r-n)/2)+n,s=t(e[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function yCe(){return ZIe}function bCe(){return ZIe.memory()}function vCe(e,t){return ZIe.tidy(e,t)}function xCe(e){qIe(e).forEach((e=>e.dispose()))}function wCe(e){return ZIe.keep(e)}function kCe(){return ZIe.backendName}function SCe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return ZIe.registerBackend(e,t,n)}function ICe(){return ZIe.backend}!function(e){$Ie=e}((function(e){kxe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}));const CCe=4;async function NCe(e,t){const n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<a.length;++s){const i=a[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+CCe*t.length,r=new Uint8Array(n);let a=0;for(let s=0;s<t.length;s++){const e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=CCe,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:DCe(await Promise.all(r)),specs:n}}function TCe(e,t){const n=new gCe(e),r={};let a=0;for(const s of t){const e=ECe(s,((e,t)=>n.slice(a+e,a+t)));r[s.name]=_Ce(s,n.slice(a,a+e)),a+=e}return r}function ECe(e,t){const n=Gve(e.shape);let r;if("quantization"in e){const t=e.quantization;r=mCe[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=CCe+new Uint32Array(t(e,e+CCe))[0];return e}r=mCe[e.dtype]}return n*r}async function ACe(e,t){const n=Gve(e.shape);let r;if("quantization"in e){const t=e.quantization;r=mCe[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=CCe+new Uint32Array(await t(e,e+CCe))[0];return e}r=mCe[e.dtype]}return n*r}function _Ce(e,t){const n=e.name,r=e.dtype,a=e.shape,s=Gve(a);let i,o=0;if("quantization"in e){const a=e.quantization;if("uint8"===a.dtype||"uint16"===a.dtype){if(!("min"in a)||!("scale"in a))throw new Error(`Weight ${e.name} with quantization ${a.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==a.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${a.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${a.dtype} which only supports weights of type float32 not ${r}.`)}const l=mCe[a.dtype],u="uint8"===a.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===a.dtype||"uint16"===a.dtype){i=new Float32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=t*a.scale+a.min}}else{if("float16"!==a.dtype)throw new Error(`Unsupported quantization type ${a.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){const a=r[i],o=e[n[a>>10]+(1023&a)]+t[a>>10];s[i]=o}return new Float32Array(a)}}();i=e(u)}}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${n}': ${r}`);if("uint8"!==a.dtype&&"uint16"!==a.dtype)throw new Error(`Unsupported quantization type ${a.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=Math.round(t*a.scale+a.min)}}o+=s*l}else if("string"===r){const n=Gve(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+CCe))[0];o+=CCe;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=mCe[r];if("float32"===r)i=new Float32Array(t);else if("int32"===r)i=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const r=fCe(e,a,"float32"),s=fCe(n,a,"float32"),o=hCe(r,s);return r.dispose(),s.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${r}`)}i=new Uint8Array(t)}o+=s*e}return fCe(i,a,r)}async function $Ce(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:a}=await e.read();if(t&&null==a){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const s=new Uint8Array(r.length+a.byteLength);s.set(r,0),s.set(new Uint8Array(a),r.length),r=s}return r.buffer}async function RCe(e,t){const n={},r=e.getReader();let a=new ArrayBuffer(0);for(const s of t){const e=await ACe(s,(async(e,t)=>(a=await $Ce(r,a,t),a.slice(e,t))));a=await $Ce(r,a,e);const t=a.slice(0,e);a=a.slice(e);const i=_Ce(s,t);if(n[s.name]=i,"webgpu"===kCe()){const e=ICe();"uploadToGPU"in e&&Gve(i.shape)>=kxe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function DCe(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}const MCe="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function FCe(e){return MCe?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function OCe(e){return gCe.join(e)}function PCe(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function LCe(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function zCe(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function BCe(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),zCe(e,n,r)}function WCe(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:FCe(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:FCe(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new gCe(e.weightData).byteLength}}function VCe(e){const t=[];for(const n of e)t.push(...n.weights);return t}class UCe{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==UCe.instance&&(UCe.instance=new UCe),UCe.instance}static registerSaveRouter(e){UCe.getInstance().saveRouters.push(e)}static registerLoadRouter(e){UCe.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return UCe.getHandlers(e,"save")}static getLoadHandlers(e,t){return UCe.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?UCe.getInstance().loadRouters:UCe.getInstance().saveRouters).forEach((t=>{const a=t(e,n);null!==a&&r.push(a)})),r}}const jCe=e=>UCe.registerSaveRouter(e),GCe=e=>UCe.registerLoadRouter(e),HCe=e=>UCe.getSaveHandlers(e),qCe=(e,t)=>UCe.getLoadHandlers(e,t),KCe="tensorflowjs",XCe="models_store",YCe="model_info_store";function QCe(){if(!kxe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function JCe(e){const t=e.result;t.createObjectStore(XCe,{keyPath:"modelPath"}),t.createObjectStore(YCe,{keyPath:"modelPath"})}class ZCe{constructor(e){if(this.indexedDB=QCe(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(KCe,1);r.onupgradeneeded=()=>JCe(r),r.onsuccess=()=>{const a=r.result;if(null==t){const t=a.transaction(XCe,"readonly"),r=t.objectStore(XCe).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=gCe.join(t.weightData);const r=WCe(t),i=a.transaction(YCe,"readwrite");let o,l,u=i.objectStore(YCe);try{o=u.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(s){return n(s)}o.onsuccess=()=>{l=a.transaction(XCe,"readwrite");const o=l.objectStore(XCe);let c;try{c=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(s){return n(s)}c.onsuccess=()=>e({modelArtifactsInfo:r}),c.onerror=e=>{u=i.objectStore(YCe);const t=u.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(c.error)),t.onerror=e=>(a.close(),n(c.error))}},o.onerror=e=>(a.close(),n(o.error)),i.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}}ZCe.URL_SCHEME="indexeddb://";const eNe=e=>{return kxe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ZCe.URL_SCHEME)?(t=e.slice(ZCe.URL_SCHEME.length),new ZCe(t)):null;var t};UCe.registerSaveRouter(eNe),UCe.registerLoadRouter(eNe);class tNe{constructor(){this.indexedDB=QCe()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(KCe,1);n.onupgradeneeded=()=>JCe(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(YCe,"readonly"),s=a.objectStore(YCe).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(ZCe.URL_SCHEME)?t.slice(ZCe.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(KCe,1);r.onupgradeneeded=()=>JCe(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(YCe,"readwrite"),i=s.objectStore(YCe),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),s=()=>{l=a.transaction(XCe,"readwrite");const r=l.objectStore(XCe).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=s,r.onerror=e=>(s(),a.close(),n(o.error))}},o.onerror=e=>(a.close(),n(o.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}},r.onerror=e=>n(r.error)}))}}const nNe="/",rNe="tensorflowjs_models",aNe="info",sNe="model_topology",iNe="weight_specs",oNe="weight_data",lNe="model_metadata";function uNe(e){return{info:[rNe,e,aNe].join(nNe),topology:[rNe,e,sNe].join(nNe),weightSpecs:[rNe,e,iNe].join(nNe),weightData:[rNe,e,oNe].join(nNe),modelMetadata:[rNe,e,lNe].join(nNe)}}function cNe(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function dNe(e){const t=e.split(nNe);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(nNe)}class hNe{constructor(e){if(!kxe().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=uNe(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=WCe(e),s=gCe.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(MCe)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(s));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw cNe(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(MCe){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(s),t}}hNe.URL_SCHEME="localstorage://";const pNe=e=>{return kxe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(hNe.URL_SCHEME)?(t=e.slice(hNe.URL_SCHEME.length),new hNe(t)):null;var t};UCe.registerSaveRouter(pNe),UCe.registerLoadRouter(pNe);class fNe{constructor(){Vve(kxe().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Vve("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=rNe+nNe,n=nNe+aNe;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){e[dNe(a)]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){var t;const n=uNe(e=(t=e).startsWith(hNe.URL_SCHEME)?t.slice(hNe.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return cNe(n),r}}const mNe="://";class gNe{constructor(){this.managers={}}static getInstance(){return null==gNe.instance&&(gNe.instance=new gNe),gNe.instance}static registerManager(e,t){Vve(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(mNe)&&(e=e.slice(0,e.indexOf(mNe))),Vve(e.length>0,(()=>"scheme must not be an empty string."));const n=gNe.getInstance();Vve(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=gNe.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(gNe.getInstance().managers)}}function yNe(e){if(-1===e.indexOf(mNe))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${gNe.getSchemes().join(",")}`);return{scheme:e.split(mNe)[0],path:e.split(mNe)[1]}}async function bNe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Vve(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=UCe.getLoadHandlers(e);Vve(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),Vve(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const a=r[0],s=UCe.getSaveHandlers(t);Vve(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),Vve(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const i=s[0],o=yNe(e).scheme,l=yNe(e).path,u=o===yNe(e).scheme,c=await a.load();n&&u&&await gNe.getManager(o).removeModel(l);const d=await i.save(c);return n&&!u&&await gNe.getManager(o).removeModel(l),d.modelArtifactsInfo}async function vNe(){const e=gNe.getSchemes(),t={};for(const n of e){const e=await gNe.getManager(n).listModels();for(const r in e){t[n+mNe+r]=e[r]}}return t}async function xNe(e){const t=yNe(e);return gNe.getManager(t.scheme).removeModel(t.path)}async function wNe(e,t){return bNe(e,t,!1)}async function kNe(e,t){return bNe(e,t,!0)}class SNe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&kxe().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return KSe(e)}}if(kxe().get("IS_BROWSER")){kxe().setPlatform("browser",new SNe);try{gNe.registerManager(hNe.URL_SCHEME,new fNe)}catch(e7e){}try{gNe.registerManager(ZCe.URL_SCHEME,new tNe)}catch(e7e){}}const INe=()=>n(5817);let CNe;class NNe{constructor(){this.util=n(8590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=kxe().global.fetch?kxe().global.fetch(e,t):(null==CNe&&(CNe=INe()),CNe(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function TNe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",mxe(e),new EIe(e,t,n)}kxe().get("IS_NODE")&&!kxe().get("IS_BROWSER")&&kxe().setPlatform("node",new NNe);const ENe=dCe({cast_:function(e,t){const n=lCe(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},a={dtype:t};return ZIe.runKernel(Yxe,r,a)}});const ANe=dCe({clone_:function(e){const t={x:lCe(e,"x","clone","string_or_numeric")};return ZIe.runKernel(Vwe,t)}});function _Ne(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}JIe();_Ie={buffer:TNe,cast:ENe,clone:ANe,print:_Ne};const $Ne=dCe({add_:function(e,t){let n=lCe(e,"a","add"),r=lCe(t,"b","add");[n,r]=GIe(n,r);const a={a:n,b:r};return ZIe.runKernel(_xe,a)}});const RNe=dCe({floorDiv_:function(e,t){let n=lCe(e,"a","floorDiv"),r=lCe(t,"b","floorDiv");[n,r]=GIe(n,r);const a={a:n,b:r};return ZIe.runKernel(Owe,a)}});const DNe=dCe({div_:function(e,t){let n=lCe(e,"a","div"),r=lCe(t,"b","div");if([n,r]=GIe(n,r),"int32"===n.dtype&&"int32"===r.dtype)return RNe(n,r);const a={a:n,b:r};return ZIe.runKernel(Swe,a,{})}});const MNe=dCe({mul_:function(e,t){let n=lCe(e,"a","mul"),r=lCe(t,"b","mul");[n,r]=GIe(n,r);const a={a:n,b:r};return ZIe.runKernel(bke,a)}});const FNe=dCe({sqrt_:function(e){const t={x:lCe(e,"x","sqrt","float32")};return ZIe.runKernel(aSe,t)}});const ONe=dCe({square_:function(e){const t=lCe(e,"x","square");return ZIe.runKernel("Square",{x:t},{})}});const PNe=dCe({zerosLike_:function(e){const t={x:lCe(e,"x","zerosLike")};return ZIe.runKernel($Se,t)}});function LNe(e){return ZIe.customGrad(e)}function zNe(e,t){if((mIe(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&mIe(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return pCe(e,[],[],t)}const BNe=new Map,WNe=new Map;class VNe{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class UNe{constructor(){this.classNameMap={}}static getMap(){return null==UNe.instance&&(UNe.instance=new UNe),UNe.instance}static register(e){UNe.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function jNe(e,t,n){Vve(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Vve("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Vve(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const r=t+">"+n;return UNe.register(e),BNe.set(r,e),WNe.set(e,r),e}class GNe extends VNe{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return xCe(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Vve(oxe(e),(()=>"The f passed in variableGrads(f) must be a function")),Vve(null==t||Array.isArray(t)&&t.every((e=>e instanceof MIe)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in ZIe.registeredVariables)t.push(ZIe.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,a=t.length;t=t.filter((e=>e.trainable)),Vve(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));const{value:s,grads:i}=ZIe.gradients(e,t,null,!0);Vve(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Vve(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:s,grads:o}}(e,t)}dispose(){null!=this.iterations_&&xCe(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:zNe(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(GNe,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class HNe extends GNe{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=ZIe.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ZIe.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:vCe((()=>PNe(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:vCe((()=>PNe(r).variable(a)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;vCe((()=>{const e=$Ne(MNe(i,this.rho),MNe(ONe(s),1-this.rho)),t=MNe(DNe(FNe($Ne(o,this.epsilon)),FNe($Ne(i,this.epsilon))),s),n=$Ne(MNe(o,this.rho),MNe(ONe(t),1-this.rho));i.assign(e),o.assign(n);const a=$Ne(MNe(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(xCe(this.accumulatedGrads.map((e=>e.variable))),xCe(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function qNe(e,t,n){mxe(e);const r={shape:e,value:t,dtype:n=n||ixe(t)};return ZIe.runKernel(Dwe,{},r)}class KNe extends GNe{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ZIe.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:vCe((()=>qNe(r.shape,this.initialAccumulatorValue).variable(e)))}}const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const s=this.accumulatedGrads[n].variable;vCe((()=>{const e=$Ne(s,ONe(a));s.assign(e);const t=$Ne(MNe(DNe(a,FNe($Ne(e,ZIe.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&xCe(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const XNe=dCe({pow_:function(e,t){let n=lCe(e,"base","pow"),r=lCe(t,"exp","pow");[n,r]=GIe(n,r);const a={a:n,b:r};return ZIe.runKernel(Eke,a)}});const YNe=dCe({sub_:function(e,t){let n=lCe(e,"a","sub"),r=lCe(t,"b","sub");[n,r]=GIe(n,r);const a={a:n,b:r};return ZIe.runKernel(wSe,a)}});class QNe extends GNe{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],vCe((()=>{this.accBeta1=zNe(t).variable(),this.accBeta2=zNe(n).variable()})),null==r&&(this.epsilon=ZIe.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);vCe((()=>{const n=YNe(1,this.accBeta1),r=YNe(1,this.accBeta2);t.forEach(((t,a)=>{const s=ZIe.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:vCe((()=>PNe(s).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:vCe((()=>PNe(s).variable(i)))});const o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,c=$Ne(MNe(l,this.beta1),MNe(o,1-this.beta1)),d=$Ne(MNe(u,this.beta2),MNe(ONe(o),1-this.beta2)),h=DNe(c,n),p=DNe(d,r);l.assign(c),u.assign(d);const f=$Ne(MNe(DNe(h,$Ne(FNe(p),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(MNe(this.accBeta1,this.beta1)),this.accBeta2.assign(MNe(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&xCe(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&xCe(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),vCe((()=>{this.accBeta1.assign(XNe(this.beta1,this.iterations_+1)),this.accBeta2.assign(XNe(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const JNe=dCe({abs_:function(e){const t=lCe(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return ZIe.runKernel(ewe,e)}{const e={x:t};return ZIe.runKernel(Txe,e)}}});function ZNe(e,t){const n=e.length,r=[];for(let a=0;a<n;a++){const s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function eTe(e,t){const n=[];for(let r=0;r<t.length;r++){const a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function tTe(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];null==s&&(s=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===s)r[n-a-1]=i;else if(1===i)r[n-a-1]=s;else{if(s!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-a-1]=s}}return r}const nTe=dCe({maximum_:function(e,t){let n=lCe(e,"a","maximum"),r=lCe(t,"b","maximum");[n,r]=GIe(n,r),"bool"===n.dtype&&(n=ENe(n,"int32"),r=ENe(r,"int32")),tTe(n.shape,r.shape);const a={a:n,b:r};return ZIe.runKernel(ike,a)}});class rTe extends GNe{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],vCe((()=>{this.iteration=zNe(0).variable(),this.accBeta1=zNe(t).variable()})),null==r&&(this.epsilon=ZIe.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);vCe((()=>{const n=YNe(1,this.accBeta1),r=DNe(-this.learningRate,$Ne(MNe(this.iteration,this.decay),1));t.forEach(((t,a)=>{const s=ZIe.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:PNe(s).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:PNe(s).variable(i)});const o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,c=$Ne(MNe(l,this.beta1),MNe(o,1-this.beta1)),d=MNe(u,this.beta2),h=JNe(o),p=nTe(d,h);l.assign(c),u.assign(p);const f=$Ne(MNe(DNe(r,n),DNe(c,$Ne(p,this.epsilon))),s);s.assign(f)})),this.iteration.assign($Ne(this.iteration,1)),this.accBeta1.assign(MNe(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&xCe(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&xCe(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class aTe extends GNe{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);t.forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=ZIe.registeredVariables[t];vCe((()=>{const e=$Ne(MNe(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=wCe(zNe(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class sTe extends aTe{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=zNe(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ZIe.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:vCe((()=>PNe(r).variable(e)))}}const a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&vCe((()=>{let e;const t=$Ne(MNe(this.m,a),s);e=this.useNesterov?$Ne(MNe(this.c,$Ne(s,MNe(t,this.m))),r):$Ne(MNe(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&xCe(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class iTe extends GNe{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=ZIe.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ZIe.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:vCe((()=>PNe(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:vCe((()=>PNe(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:vCe((()=>PNe(r).variable(a)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;vCe((()=>{const e=$Ne(MNe(i,this.decay),MNe(ONe(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,a=$Ne(MNe(t,this.decay),MNe(s,1-this.decay)),l=DNe(MNe(s,this.learningRate),FNe(YNe(e,$Ne(ONe(a),this.epsilon)))),u=$Ne(MNe(o,this.momentum),l);i.assign(e),t.assign(a),o.assign(u);const c=YNe(r,u);r.assign(c)}else{const e=$Ne(MNe(i,this.decay),MNe(ONe(s),1-this.decay)),t=$Ne(MNe(o,this.momentum),DNe(MNe(s,this.learningRate),FNe($Ne(e,this.epsilon))));i.assign(e),o.assign(t);const n=YNe(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&xCe(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&xCe(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&xCe(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const oTe=[HNe,KNe,QNe,rTe,sTe,iTe,aTe];function lTe(e){return new Promise((e=>setTimeout(e))).then(e)}class uTe{constructor(e){if(!kxe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(uTe.URL_SCHEME)&&(e=e.slice(uTe.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=gCe.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=LCe(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await lTe((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await lTe((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:WCe(e)}}}}uTe.URL_SCHEME="downloads://";class cTe{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});const s=BCe(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const s of e)t.push(...s.weights),n.push(...s.paths);const r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const a=new FileReader;a.onload=e=>{const t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>PCe(e.name))),r={};for(const a of e)a.paths.forEach((e=>{const a=PCe(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function dTe(e){return new cTe(e)}function hTe(e,t,n,r){!function(e){Vve(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Vve(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),Vve(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),Vve(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(e.map((s=>(s.then((s=>{const i=n+ ++a/e.length*(r-n);return t(i),s})),s))))}async function pTe(e,t){null==t&&(t={});const n=null==t.fetchFunc?kxe().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await hTe(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await hTe(a,t.onProgress,.5,1)}async function fTe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return mTe((e=>pTe(e,{requestInit:r})))(e,t,n)}function mTe(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0;const a=t.map((()=>!1)),s={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,u=mCe[l]*Gve(e.shape),c=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){const e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));const c=await e(u),d={};let h=0;return l.forEach((e=>{const n=t[e].paths.length,r=new gCe(c.slice(h,h+n));s[e].forEach((e=>{const t=TCe(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)d[n]=t[n]})),h+=n})),d}}UCe.registerSaveRouter((e=>kxe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(uTe.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new uTe(e)}(e.slice(uTe.URL_SCHEME.length)):null));class gTe{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Vve("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=kxe().platform.fetch,Vve(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Vve(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=LCe(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=gCe.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:WCe(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(gD){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return BCe(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=VCe(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?kxe().platform.fetch:t.fetchFunc;let a,s=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;s<e.length;){if(!a){const n=(await r(e[s],t.requestInit,{isBinary:!0})).body;a=n.getReader()}const{done:o,value:l}=await a.read();if(!o)return void n.enqueue(l);s++,a=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,s/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,s=[],i=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):s.push(a+e+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){const t=await this.getWeightUrls(e);return[VCe(e),await pTe(t,this.loadOptions)]}}function yTe(e){return null!=e.match(gTe.URL_SCHEME_REGEX)}gTe.URL_SCHEME_REGEX=/^https?:\/\//;const bTe=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>yTe(e))):yTe(e),n)return vTe(e,t)}return null};function vTe(e,t){return new gTe(e,t)}function xTe(e,t){return vTe(e,t)}UCe.registerSaveRouter(bTe),UCe.registerLoadRouter(bTe);class wTe{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class kTe{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class STe{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function ITe(e,t,n,r){return new STe(CTe(...arguments))}function CTe(e,t,n,r){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new wTe(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wTe({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new wTe({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function NTe(e){return new kTe(e)}function TTe(e){return new kTe(e)}function ETe(e,t,n){if(jve(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=sCe(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return pCe(e,t,r,n)}let ATe;function _Te(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=VSe(DSe,ZIe.backendName)){const n={pixels:e},r={numChannels:t};return ZIe.runKernel(DSe,n,r)}const[l,u]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,d;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(s||a||o){if(null==ATe)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");ATe=new OffscreenCanvas(1,1).getContext("2d")}else ATe=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ATe.canvas.width=l,ATe.canvas.height=u,ATe.drawImage(e,0,0,l,u),c=ATe.getImageData(0,0,l,u).data}if(4===t)d=new Int32Array(c);else{const e=l*u;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=c[4*n+e]}return ETe(d,[u,l,t],"int32")}const $Te=dCe({fromPixels_:_Te}),RTe=-2,DTe=-1;function MTe(e,t,n){const r=e.shape.length;Vve(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),Vve(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)Vve(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function FTe(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function OTe(e,t,n){const r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function PTe(e,t,n,r){const a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[t]=1:(a.splice(t,0,1),a.pop());return a}function LTe(e,t,n){return n<=e?n:n-(t-1)}function zTe(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function BTe(e,t,n,r,a,s,i,o,l){const u=e.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=WTe(i,l,u,r,e),d=VTe(o,l,u,a,e),h=PTe(s,l,u,e)}else for(let p=0;p<u;p++)c[p]=jTe(i,r,s,e,p,l),d[p]=GTe(o,a,s,e,p,l),h[p]=UTe(s,p,l);return{begin:c,end:d,strides:h}}function WTe(e,t,n,r,a){const s=[...a],i=zTe(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{const a=LTe(t,n,o);let i=r[a];e&1<<a&&(i=0),s[o]=i}return s}function VTe(e,t,n,r,a){const s=[...a],i=zTe(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{const a=LTe(t,n,o);let i=r[a];e&1<<a&&(i=Number.MAX_SAFE_INTEGER),s[o]=i}for(let o=0;o<s.length;o++){const e=a[o];s[o]<0&&(s[o]+=e),s[o]=zve(0,s[o],a[o])}return s}function UTe(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function jTe(e,t,n,r,a,s){let i=t[a];const o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[a];return i<0&&(i+=l),i=zve(0,i,l-1),i}function GTe(e,t,n,r,a,s){let i=t[a];const o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[a];return i<0&&(i+=l),i=o>0?zve(0,i,l):zve(-1,i,l-1),i}function HTe(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function qTe(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function KTe(e,t,n){let r;const a=e.shape.length;let s;return r="number"===typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),r.forEach((e=>{Vve(-1!==e,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(a).fill(-1):"number"===typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,s=s.map(((t,n)=>t>=0?t:(Vve(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,s]}function XTe(e,t,n,r,a,s,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&0!==(1<<b&o)&&d.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(RTe),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(DTe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],y=[];for(let b=0;b<e.length;++b){if(0===h.strides[b])throw Error(`strides[${b}] must be non-zero`);const t=!!(h.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}const r=[h.beginMask&1<<b,h.endMask&1<<b],a=[h.strides[b]>0?0:-1,h.strides[b]>0?n:n-1];if(t&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[b];const s=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(t){const e=h.begin[b]<0?n+h.begin[b]:h.begin[b];if(h.begin[b]=e,h.end[b]=h.begin[b]+1,e<0||e>=n)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=YTe(h.begin[b],0,h.strides[b],n,r,a),h.end[b]=YTe(h.end[b],1,h.strides[b],n,r,a);const e=1===h.strides[b]&&0===h.begin[b]&&h.end[b]===n;p=p&&e,f=f&&(0===b&&1===h.strides[b]||e)}else p=p&&1===h.strides[b]&&s,f=f&&(0===b&&1===h.strides[b]||s);let i,o=!1;if(h.beginValid&&h.endValid?(i=h.end[b]-h.begin[b],o=!0):t?(i=1,o=!0):s&&n>=0&&(i=h.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!==h.strides[b]<0?0:Math.trunc(i/h.strides[b])+(i%h.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){const e=h.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===RTe&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>h.finalShapeGatherIndices[t]!==RTe)),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function YTe(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{const t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}const QTe=dCe({acos_:function(e){const t={x:lCe(e,"x","acos")};return ZIe.runKernel(Exe,t)}});const JTe=dCe({acosh_:function(e){const t={x:lCe(e,"x","acosh")};return ZIe.runKernel(Axe,t)}});const ZTe=dCe({addN_:function(e){Vve(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),Vve(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>lCe(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!Hve(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return ZIe.runKernel($xe,r)}});const eEe=dCe({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:lCe(e,"x","all","bool")},a={axis:t,keepDims:n};return ZIe.runKernel(Rxe,r,a)}});const tEe=dCe({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:lCe(e,"x","any","bool")},a={axis:t,keepDims:n};return ZIe.runKernel(Dxe,r,a)}});const nEe=dCe({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:lCe(e,"x","argMax")},r={axis:t};return ZIe.runKernel(Mxe,n,r)}});const rEe=dCe({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:lCe(e,"x","argMin")},r={axis:t};return ZIe.runKernel(Fxe,n,r)}});const aEe=dCe({asin_:function(e){const t={x:lCe(e,"x","asin")};return ZIe.runKernel(Oxe,t)}});const sEe=dCe({asinh_:function(e){const t={x:lCe(e,"x","asinh")};return ZIe.runKernel(Pxe,t)}});const iEe=dCe({atan_:function(e){const t={x:lCe(e,"x","atan")};return ZIe.runKernel(Lxe,t)}});const oEe=dCe({atan2_:function(e,t){let n=lCe(e,"a","atan2"),r=lCe(t,"b","atan2");[n,r]=GIe(n,r);const a={a:n,b:r};return ZIe.runKernel(Bxe,a)}});const lEe=dCe({atanh_:function(e){const t={x:lCe(e,"x","atanh")};return ZIe.runKernel(zxe,t)}});function uEe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return hEe(e,[...t,e[3]],n,s,r,null,null,kEe(a))}function cEe(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[o,l]=mEe(t);let u;if("channelsLast"===i)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[o,l,e[1],e[1]]}return hEe(e,u,n,r,a,s,!1,i)}function dEe(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,l,u]=gEe(t);let c,d;if("NDHWC"===i)d="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[o,l,u,e[1],e[1]]}return pEe(e,c,n,r,a,!1,d,s)}function hEe(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,c]=e}const[h,p,,f]=t,[m,g]=mEe(n),[y,b]=mEe(r),v=yEe(h,y),x=yEe(p,b),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,r,a,s,i,o,l){let u,c,d;if("number"===typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,r,a){null==r&&(r=fEe(e,t,n));const s=e[0],i=e[1],o=bEe((s-t+2*r)/n+1,a),l=bEe((i-t+2*r)/n+1,a);return[o,l]}([t,n],s,r,e,o);c=a[0],d=a[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/a);const e=Math.max(0,(c-1)*r+s-t),o=Math.max(0,(d-1)*a+i-n),l=Math.floor(e/2),h=e-l,p=Math.floor(o/2);u={top:l,bottom:h,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/r),d=Math.ceil((n-i+1)/a);else{if("object"!==typeof e)throw Error(`Unknown padding parameter: ${e}`);{const h="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=bEe((t-s+h+p)/r+1,o),d=bEe((n-i+f+m)/a+1,o)}}return{padInfo:u,outHeight:c,outWidth:d}}(a,u,c,m,g,v,x,s,o),I=i?f*d:f;let C;return"channelsFirst"===o?C=[l,I,k,S]:"channelsLast"===o&&(C=[l,k,S,I]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:e,outShape:C,filterShape:t}}function pEe(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=e}const[p,f,m,,g]=t,[y,b,v]=gEe(n),[x,w,k]=gEe(r),S=yEe(p,x),I=yEe(f,w),C=yEe(m,k),{padInfo:N,outDepth:T,outHeight:E,outWidth:A}=function(e,t,n,r,a,s,i,o,l,u,c){let d,h,p,f;"valid"===e&&(e=0);if("number"===typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,a,s){null==a&&(a=fEe(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=bEe((e[o]-t[o]+2*a)/r[o]+1,s));return i}([t,n,r,1],[o,l,u],1,[a,s,i],e,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(t/a),p=Math.ceil(n/s),f=Math.ceil(r/i);const e=(h-1)*a+o-t,c=(p-1)*s+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),v=c-b,x=Math.floor(m/2);d={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(a,u,c,d,y,b,v,S,I,C,o),_=s?g*h:g;let $;return"channelsFirst"===i?$=[l,_,T,E,A]:"channelsLast"===i&&($=[l,T,E,A,_]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:T,outHeight:E,outWidth:A,outChannels:_,padInfo:N,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:C,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:$,filterShape:t}}function fEe(e,t,n){const r=yEe(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function mEe(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function gEe(e){return"number"===typeof e?[e,e,e]:e}function yEe(e,t){return t<=1?e:e+(e-1)*(t-1)}function bEe(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function vEe(e){const[t,n,r]=mEe(e);return 1===t&&1===n&&1===r}function xEe(e,t){return vEe(e)||vEe(t)}function wEe(e){return mEe(e).every((e=>e>0))}function kEe(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function SEe(e,t,n){if(null!=n){if("string"===typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"===typeof t)Vve(qve(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!==typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{Vve(qve(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const IEe=dCe({reshape_:function(e,t){const n={x:lCe(e,"x","reshape","string_or_numeric")},r={shape:t};return ZIe.runKernel(Lke,n,r)}});const CEe=dCe({avgPool_:function(e,t,n,r,a){const s=lCe(e,"x","avgPool","float32");Vve(xEe(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=s,o=!1;3===s.rank&&(o=!0,i=IEe(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Vve(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),SEe("avgPool",r,a);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a};let c=ZIe.runKernel(Wxe,l,u);return c=ENe(c,s.dtype),o?IEe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const NEe=dCe({avgPool3d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=lCe(e,"x","avgPool3d","float32");let o=i,l=!1;4===i.rank&&(l=!0,o=IEe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Vve(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),Vve("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Vve("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),SEe("avgPool3d",r,a);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let d=ZIe.runKernel(Uxe,u,c);return d=ENe(d,o.dtype),l?IEe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const TEe=dCe({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Vve(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=uCe(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return ANe(n[0]);const r=n,a={axis:t};return ZIe.runKernel(twe,r,a)}});const EEe=dCe({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=lCe(e,"a","matMul"),s=lCe(t,"b","matMul");[a,s]=GIe(a,s);const i={a:a,b:s},o={transposeA:n,transposeB:r};return ZIe.runKernel(Gxe,i,o)}});const AEe=dCe({sigmoid_:function(e){const t={x:lCe(e,"x","sigmoid","float32")};return ZIe.runKernel(nSe,t)}});const _Ee=dCe({slice_:function(e,t,n){const r=lCe(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:t,size:n};return ZIe.runKernel(Jke,a,s)}});const $Ee=dCe({tanh_:function(e){const t={x:lCe(e,"x","tanh","float32")};return ZIe.runKernel(SSe,t)}});const REe=dCe({basicLSTMCell_:function(e,t,n,r,a,s){const i=lCe(e,"forgetBias","basicLSTMCell"),o=lCe(t,"lstmKernel","basicLSTMCell"),l=lCe(n,"lstmBias","basicLSTMCell"),u=lCe(r,"data","basicLSTMCell"),c=lCe(a,"c","basicLSTMCell"),d=lCe(s,"h","basicLSTMCell"),h=TEe([u,d],1),p=EEe(h,o),f=$Ne(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=_Ee(f,[0,0],y),v=_Ee(f,[0,g],y),x=_Ee(f,[0,2*g],y),w=_Ee(f,[0,3*g],y),k=$Ne(MNe(AEe(b),$Ee(v)),MNe(c,AEe($Ne(i,x))));return[k,MNe($Ee(k),AEe(w))]}});const DEe=dCe({batchToSpaceND_:function(e,t,n){const r=lCe(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));Vve(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),Vve(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),Vve(r.shape[0]%a===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));const s={x:r},i={blockShape:t,crops:n};return ZIe.runKernel(Hxe,s,i)}});const MEe=dCe({batchNorm_:function(e,t,n,r,a,s){null==s&&(s=.001);const i=lCe(e,"x","batchNorm"),o=lCe(t,"mean","batchNorm"),l=lCe(n,"variance","batchNorm");let u,c;null!=a&&(u=lCe(a,"scale","batchNorm")),null!=r&&(c=lCe(r,"offset","batchNorm")),Vve(o.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Vve(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Vve(null==u||o.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d=function(e){let t;return t=0===e.rank||1===e.rank?IEe(e,[1,1,1,e.size]):2===e.rank?IEe(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?IEe(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),h={x:d,scale:u,offset:c,mean:o,variance:l},p={varianceEpsilon:s},f=ZIe.runKernel(Pwe,h,p);return IEe(f,i.shape)}});const FEe=dCe({batchNorm2d_:function(e,t,n,r,a,s){const i=lCe(e,"x","batchNorm"),o=lCe(t,"mean","batchNorm"),l=lCe(n,"variance","batchNorm");let u,c;return null!=a&&(u=lCe(a,"scale","batchNorm")),null!=r&&(c=lCe(r,"offset","batchNorm")),Vve(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),Vve(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),Vve(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&Vve(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&Vve(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),MEe(i,o,l,c,u,s)}});const OEe=dCe({batchNorm3d_:function(e,t,n,r,a,s){const i=lCe(e,"x","batchNorm"),o=lCe(t,"mean","batchNorm"),l=lCe(n,"variance","batchNorm");let u,c;return null!=a&&(u=lCe(a,"scale","batchNorm")),null!=r&&(c=lCe(r,"offset","batchNorm")),Vve(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),Vve(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),Vve(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&Vve(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&Vve(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),MEe(i,o,l,c,u,s)}});const PEe=dCe({batchNorm4d_:function(e,t,n,r,a,s){const i=lCe(e,"x","batchNorm"),o=lCe(t,"mean","batchNorm"),l=lCe(n,"variance","batchNorm");let u,c;return null!=a&&(u=lCe(a,"scale","batchNorm")),null!=r&&(c=lCe(r,"offset","batchNorm")),Vve(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),Vve(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),Vve(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&Vve(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&Vve(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),MEe(i,o,l,c,u,s)}});const LEe=dCe({bincount_:function(e,t,n){const r=lCe(e,"x","bincount"),a=lCe(t,"weights","bincount");Vve("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Vve(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Vve(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));const s={x:r,weights:a},i={size:n};return ZIe.runKernel(qxe,s,i)}});const zEe=dCe({bitwiseAnd_:function(e,t){const n=lCe(e,"x","bitwiseAnd"),r=lCe(t,"y","bitwiseAnd");if(!Hve(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const a={a:n,b:r};return ZIe.runKernel(Kxe,a)}});const BEe=dCe({broadcastArgs_:function(e,t){const n=lCe(e,"s0","broadcastArgs","int32"),r=lCe(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const a={s0:n,s1:r};return ZIe.runKernel(Xxe,a)}});const WEe=dCe({broadcastTo_:function(e,t){let n=lCe(e,"broadcastTo","x");const r=n.shape;if(mxe(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=IEe(n,e)}const a=n.shape,s=Array.from(t);for(let u=t.length-1;u>=0;u--)if(a[u]===t[u])s[u]=1;else if(1!==n.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);const i=s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0));if(0===i.length)return ANe(n);const o={x:n},l={reps:s};return ZIe.runKernel(ISe,o,l)}});const VEe=dCe({ceil_:function(e){const t={x:lCe(e,"x","ceil","float32")};return ZIe.runKernel(Qxe,t)}});const UEe=dCe({clipByValue_:function(e,t,n){const r=lCe(e,"x","clipByValue");if(Vve(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return qNe(r.shape,t,r.dtype);const a={x:r},s={clipValueMin:t,clipValueMax:n};return ZIe.runKernel(Jxe,a,s)}});const jEe=dCe({concat1d_:function(e){return TEe(e,0)}});const GEe=dCe({concat2d_:function(e,t){return TEe(e,t)}});const HEe=dCe({concat3d_:function(e,t){return TEe(e,t)}});const qEe=dCe({concat4d_:function(e,t){return TEe(e,t)}});const KEe=dCe({conv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=lCe(e,"x","conv2d","float32"),l=lCe(t,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=IEe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Vve(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),Vve(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),SEe("conv2d",r,i);const d="NHWC"===a?u.shape[3]:u.shape[1];Vve(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),Vve(xEe(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Vve(wEe(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Vve(wEe(n),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=ZIe.runKernel(nwe,h,p);return c?IEe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const XEe=dCe({conv1d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0;const o=lCe(e,"x","conv1d"),l=lCe(t,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=IEe(o,[1,o.shape[0],o.shape[1]])),Vve(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),Vve(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),SEe("conv1d",r,i),Vve(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),Vve(xEe(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),Vve(wEe(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Vve(wEe(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Vve("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));const d=IEe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=IEe(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=KEe(h,d,[1,n],r,"NHWC",[1,s],i);return IEe(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const YEe=dCe({conv2DBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;Vve(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=IEe(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Vve(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),Vve(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),Vve(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===s?o[3]:o[1],d="NHWC"===s?l.shape[3]:l.shape[1];Vve(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),Vve(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),SEe("conv2dDerInput",a,i);const h={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=ZIe.runKernel(awe,h,p);return u?IEe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const QEe=dCe({conv2dTranspose_:function(e,t,n,r,a,s){const i=lCe(e,"x","conv2dTranspose"),o=lCe(t,"filter","conv2dTranspose");return YEe(n,i,o,r,a,"NHWC",s)}});const JEe=dCe({conv3d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=lCe(e,"x","conv3d"),o=lCe(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=IEe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Vve(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),Vve(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),Vve(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),Vve(xEe(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Vve("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),Vve(wEe(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Vve(wEe(n),(()=>"Error in conv3D: Strides should be larger than 0."));const c={x:l,filter:o},d={strides:n,pad:r,dataFormat:a,dilations:s},h=ZIe.runKernel(swe,c,d);return u?IEe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const ZEe=dCe({conv3DBackpropInput_:function(e,t,n,r,a){Vve(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=IEe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);const l=s[4],u=i.shape[4];Vve(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),Vve(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),Vve(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Vve(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),Vve(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:i,filter:n},d={pad:a,strides:r,inputShape:s},h=ZIe.runKernel(owe,c,d);return o?IEe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const eAe=dCe({conv3dTranspose_:function(e,t,n,r,a){const s=lCe(e,"x","conv3dTranspose"),i=lCe(t,"filter","conv3dTranspose");return ZEe(n,s,i,r,a)}});const tAe=dCe({cos_:function(e){const t={x:lCe(e,"x","cos","float32")};return ZIe.runKernel(lwe,t)}});const nAe=dCe({cosh_:function(e){const t={x:lCe(e,"x","cosh","float32")};return ZIe.runKernel(uwe,t)}});const rAe=dCe({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:lCe(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return ZIe.runKernel(cwe,a,s)}});const aAe=dCe({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={x:lCe(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return ZIe.runKernel(dwe,a,s)}});const sAe=dCe({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=lCe(e,"x","denseBincount"),s=lCe(t,"weights","denseBincount");Vve("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),Vve(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),Vve(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Vve(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));const i={x:a,weights:s},o={size:n,binaryOutput:r};return ZIe.runKernel(pwe,i,o)}});const iAe=dCe({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=lCe(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Vve(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),Vve(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),Vve(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),Vve(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const o={x:r},l={blockSize:t,dataFormat:n};return ZIe.runKernel(fwe,o,l)}});const oAe=dCe({depthwiseConv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=lCe(e,"x","depthwiseConv2d","float32"),l=lCe(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=IEe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Vve(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),Vve(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const d="NHWC"===a?u.shape[3]:u.shape[1];Vve(d===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`)),SEe("depthwiseConv2d",r,i);const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=ZIe.runKernel(mwe,h,p);return c?IEe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const lAe=dCe({diag_:function(e){const t={x:lCe(e,"x","diag")};return ZIe.runKernel(bwe,t)}});const uAe=dCe({dilation2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const i=lCe(e,"x","dilation2d"),o=lCe(t,"filter","dilation2d");Vve(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),Vve(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),Vve("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=i,u=!1;3===i.rank&&(l=IEe(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Vve(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));const c={x:l,filter:o},d={strides:n,pad:r,dilations:a},h=ZIe.runKernel(vwe,c,d);return u?IEe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const cAe=dCe({equal_:function(e,t){let n=lCe(e,"a","equal","string_or_numeric"),r=lCe(t,"b","equal","string_or_numeric");[n,r]=GIe(n,r),tTe(n.shape,r.shape);const a={a:n,b:r};return ZIe.runKernel(Ewe,a)}});const dAe=dCe({where_:function(e,t,n){const r=lCe(t,"a","where"),a=lCe(n,"b","where"),s=lCe(e,"condition","where","bool"),i=tTe(tTe(s.shape,r.shape),a.shape),o={condition:WEe(s,i),t:WEe(r,i),e:WEe(a,i)};return ZIe.runKernel(Yke,o)}});const hAe=dCe({divNoNan_:function(e,t){let n=lCe(e,"a","div"),r=lCe(t,"b","div");[n,r]=GIe(n,r);const a=DNe(n,r),s=PNe(a),i=cAe(r,s);return dAe(i,s,a)}});const pAe=dCe({dot_:function(e,t){const n=lCe(e,"t1","dot"),r=lCe(t,"t2","dot");Vve((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(Vve(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){const e=IEe(n,[1,-1]),t=IEe(r,[-1,1]),a=EEe(e,t);return IEe(a,[])}if(1===n.rank&&2===r.rank){const e=IEe(n,[1,-1]),t=IEe(r,[r.shape[0],r.shape[1]]),a=EEe(e,t);return IEe(a,[a.size])}if(2===n.rank&&1===r.rank){const e=IEe(r,[-1,1]),t=EEe(n,e);return IEe(t,[t.size])}{const e=IEe(r,[r.shape[0],r.shape[1]]);return EEe(n,e)}}});const fAe=dCe({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(((e,t)=>lCe(e,`tensors${t}`,"einsum"))),s={equation:e};return ZIe.runKernel(Iwe,a,s)}});const mAe=dCe({elu_:function(e){const t={x:lCe(e,"x","elu","float32")};return ZIe.runKernel(Cwe,t)}});const gAe=dCe({ensureShape_:function(e,t){const n=lCe(e,"x","ensureShape","string_or_numeric");if(!function(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});const yAe=dCe({erf_:function(e){let t=lCe(e,"x","erf");Vve("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=ENe(t,"float32"));const n={x:t};return ZIe.runKernel(Twe,n)}});function bAe(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function vAe(e,t,n){const r=e.length+t.length,a=[];let s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function xAe(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function wAe(e,t){return vAe(e,t.map((e=>1)),t)}function kAe(e,t,n){Vve(bAe(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function SAe(e,t){if(bAe(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function IAe(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function CAe(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const NAe=dCe({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:lCe(e,"x","max")},a={reductionIndices:t,keepDims:n};return ZIe.runKernel(ske,r,a)}});const TAe=dCe({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:lCe(e,"x","min")},a={axis:t,keepDims:n};return ZIe.runKernel(pke,r,a)}});const EAe=dCe({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=lCe(e,"x","sum");"bool"===r.dtype&&(r=ENe(r,"int32"));const a={x:r},s={axis:t,keepDims:n};return ZIe.runKernel(sSe,a,s)}});function AAe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return JNe(e);if(1!==e.rank&&null===n)return AAe(IEe(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return EAe(JNe(e),n);if(t===1/0)return NAe(JNe(e),n);if(t===-1/0)return TAe(JNe(e),n);if("euclidean"===t||2===t)return FNe(EAe(XNe(JNe(e),zNe(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return NAe(EAe(JNe(e),n[0]),n[1]-1);if(t===1/0)return NAe(EAe(JNe(e),n[1]),n[0]);if(t===-1/0)return TAe(EAe(JNe(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return FNe(EAe(ONe(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const _Ae=dCe({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=AAe(e=lCe(e,"x","norm"),t,n);let s=a.shape;if(r){const t=Jve(n,e.shape);s=wAe(a.shape,t)}return IEe(a,s)}});const $Ae=dCe({euclideanNorm_:function(e){return _Ae(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const RAe=dCe({exp_:function(e){const t={x:lCe(e,"x","exp")};return ZIe.runKernel(Awe,t)}});const DAe=dCe({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=lCe(e,"x","expandDims","string_or_numeric");Vve(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},a={dim:t};return ZIe.runKernel(_we,r,a)}});const MAe=dCe({expm1_:function(e){const t={x:lCe(e,"x","expm1")};return ZIe.runKernel($we,t)}});const FAe=dCe({tile_:function(e,t){const n=lCe(e,"x","tile","string_or_numeric");Vve(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},a={reps:t};return ZIe.runKernel(ISe,r,a)}});const OAe=dCe({eye_:function(e,t,n){null==t&&(t=e);const r=TNe([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=e<=t?e:t;for(let i=0;i<a;++i)r.set(1,i,i);const s=IEe(r.toTensor(),[e,t]);if(null==n)return s;if(1===n.length)return FAe(DAe(s,0),[n[0],1,1]);if(2===n.length)return FAe(DAe(DAe(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return FAe(DAe(DAe(DAe(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const PAe=dCe({floor_:function(e){const t={x:lCe(e,"x","floor","float32")};return ZIe.runKernel(Fwe,t)}});const LAe=dCe({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const a={x:lCe(e,"x","gather"),indices:lCe(t,"indices","gather","int32")},s={axis:n,batchDims:r};return ZIe.runKernel(Lwe,a,s)}});const zAe=dCe({greater_:function(e,t){let n=lCe(e,"a","greater","string_or_numeric"),r=lCe(t,"b","greater","string_or_numeric");[n,r]=GIe(n,r),tTe(n.shape,r.shape);const a={a:n,b:r};return ZIe.runKernel(Bwe,a)}});const BAe=dCe({greaterEqual_:function(e,t){let n=lCe(e,"a","greaterEqual","string_or_numeric"),r=lCe(t,"b","greaterEqual","string_or_numeric");[n,r]=GIe(n,r),tTe(n.shape,r.shape);const a={a:n,b:r};return ZIe.runKernel(Wwe,a)}});const WAe=dCe({imag_:function(e){const t={input:lCe(e,"input","imag")};return ZIe.runKernel(jwe,t)}});const VAe=dCe({isFinite_:function(e){const t={x:lCe(e,"x","isFinite")};return ZIe.runKernel(Gwe,t)}});const UAe=dCe({isInf_:function(e){const t={x:lCe(e,"x","isInf")};return ZIe.runKernel(Hwe,t)}});const jAe=dCe({isNaN_:function(e){const t={x:lCe(e,"x","isNaN")};return ZIe.runKernel(qwe,t)}});const GAe=dCe({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:lCe(e,"x","leakyRelu")},r={alpha:t};return ZIe.runKernel(Kwe,n,r)}});const HAe=dCe({less_:function(e,t){let n=lCe(e,"a","less","string_or_numeric"),r=lCe(t,"b","less","string_or_numeric");[n,r]=GIe(n,r),tTe(n.shape,r.shape);const a={a:n,b:r};return ZIe.runKernel(Xwe,a)}});const qAe=dCe({lessEqual_:function(e,t){let n=lCe(e,"a","lessEqual","string_or_numeric"),r=lCe(t,"b","lessEqual","string_or_numeric");[n,r]=GIe(n,r),tTe(n.shape,r.shape);const a={a:n,b:r};return ZIe.runKernel(Ywe,a)}});function KAe(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return ZIe.runKernel(Qwe,{},r)}const XAe=dCe({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const s=lCe(e,"x","localResponseNormalization");Vve(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),Vve(qve(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=s,o=!1;3===s.rank&&(o=!0,i=IEe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:a},c=ZIe.runKernel(rke,l,u);return o?IEe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const YAe=dCe({log_:function(e){const t={x:lCe(e,"x","log","float32")};return ZIe.runKernel(Jwe,t)}});const QAe=dCe({log1p_:function(e){const t={x:lCe(e,"x","log1p")};return ZIe.runKernel(Zwe,t)}});const JAe=dCe({neg_:function(e){const t={x:lCe(e,"x","neg")};return ZIe.runKernel(vke,t)}});const ZAe=dCe({softplus_:function(e){const t={x:lCe(e,"x","softplus")};return ZIe.runKernel(rSe,t)}});const e_e=dCe({logSigmoid_:function(e){const t=lCe(e,"x","logSigmoid"),n=LNe((e=>({value:JAe(ZAe(JAe(e))),gradFunc:t=>MNe(t,AEe(JAe(e)))})));return n(t)}});const t_e=dCe({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=lCe(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=LNe(((e,n)=>{const r=NAe(e,t,!0),a=YNe(e,r),s=YNe(ENe(a,"float32"),YAe(EAe(RAe(a),t,!0)));n([s]);return{value:s,gradFunc:(e,n)=>{const[r]=n,a=RAe(r);return YNe(e,MNe(EAe(e,t,!0),a))}}}));return r(n)}});const n_e=dCe({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=lCe(e,"x","logSumExp"),a=Jve(t,r.shape),s=NAe(r,a,!0),i=YNe(r,s),o=RAe(i),l=EAe(o,a),u=YAe(l),c=$Ne(IEe(s,u.shape),u);if(n){const e=wAe(c.shape,a);return IEe(c,e)}return c}});const r_e=dCe({logicalAnd_:function(e,t){const n=lCe(e,"a","logicalAnd","bool"),r=lCe(t,"b","logicalAnd","bool");tTe(n.shape,r.shape);const a={a:n,b:r};return ZIe.runKernel(eke,a)}});const a_e=dCe({logicalNot_:function(e){const t={x:lCe(e,"x","logicalNot","bool")};return ZIe.runKernel(tke,t)}});const s_e=dCe({logicalOr_:function(e,t){const n=lCe(e,"a","logicalOr","bool"),r=lCe(t,"b","logicalOr","bool");tTe(n.shape,r.shape);const a={a:n,b:r};return ZIe.runKernel(nke,a)}});const i_e=dCe({logicalXor_:function(e,t){const n=lCe(e,"a","logicalXor","bool"),r=lCe(t,"b","logicalXor","bool");return tTe(n.shape,r.shape),r_e(s_e(e,t),a_e(r_e(e,t)))}}),o_e=2147483648;const l_e=dCe({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const r=lCe(e,"sortedSequence","searchSorted"),a=lCe(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=IEe(r,[-1,s]),l=IEe(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Gve(l.shape)>=o_e)throw new Error("values tensor size must less than 2147483648");if(o.shape[1]>=o_e)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);const u={sortedSequence:o,values:l},c={side:n};return ZIe.runKernel(Xke,u,c)}});function u_e(e,t){return l_e(e,t,"left")}const c_e=dCe({maxPool_:function(e,t,n,r,a){const s=lCe(e,"x","maxPool");let i=s,o=!1;3===s.rank&&(o=!0,i=IEe(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Vve(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),Vve(xEe(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),SEe("maxPool",r,a);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=ZIe.runKernel(oke,l,u);return o?IEe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const d_e=dCe({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=lCe(e,"x","maxPool3d");let o=i,l=!1;4===i.rank&&(l=!0,o=IEe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Vve(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),Vve("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),SEe("maxPool3d",r,a);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=ZIe.runKernel(uke,u,c);return l?IEe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const h_e=dCe({maxPoolWithArgmax_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const s={x:lCe(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=ZIe.runKernel(dke,s,i);return{result:o[0],indexes:o[1]}}});const p_e=dCe({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:lCe(e,"x","mean")},a={axis:t,keepDims:n};return ZIe.runKernel(hke,r,a)}});function f_e(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(mxe(e),"complex64"===t){const t=f_e(e,"float32"),n=f_e(e,"float32");return hCe(t,n)}const n=pxe(Gve(e),t);return ZIe.makeTensor(n,e,t)}function m_e(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(mxe(e),"complex64"===t){const t=m_e(e,"float32"),n=f_e(e,"float32");return hCe(t,n)}const n=hxe(Gve(e),t);return ZIe.makeTensor(n,e,t)}function g_e(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=lCe(e,"x","meshgrid",e instanceof RIe?e.dtype:"float32");if(void 0===t)return[r];let a=lCe(t,"y","meshgrid",t instanceof RIe?t.dtype:"float32");const s=Gve(r.shape),i=Gve(a.shape);return"xy"===n?(r=IEe(r,[1,-1]),a=IEe(a,[-1,1]),[EEe(m_e([i,1],r.dtype),r),EEe(a,m_e([1,s],a.dtype))]):(r=IEe(r,[-1,1]),a=IEe(a,[1,-1]),[EEe(r,m_e([1,i],r.dtype)),EEe(m_e([s,1],a.dtype),a)])}const y_e=dCe({minimum_:function(e,t){let n=lCe(e,"a","minimum"),r=lCe(t,"b","minimum");[n,r]=GIe(n,r),"bool"===n.dtype&&(n=ENe(n,"int32"),r=ENe(r,"int32")),tTe(n.shape,r.shape);const a={a:n,b:r};return ZIe.runKernel(fke,a)}});const b_e=dCe({mirrorPad_:function(e,t,n){Vve("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=lCe(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Vve(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const a="reflect"===n?1:0;for(let o=0;o<r.rank;o++)Vve(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Vve(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`));const s={paddings:t,mode:n},i={x:r};return ZIe.runKernel(mke,i,s)}});const v_e=dCe({mod_:function(e,t){let n=lCe(e,"a","mod"),r=lCe(t,"b","mod");[n,r]=GIe(n,r);const a={a:n,b:r};return ZIe.runKernel(gke,a)}});const x_e=dCe({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Jve(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=lCe(e,"x","moments")).shape),r=p_e(e,n,t);let a=r.shape;t||(a=wAe(r.shape,n));const s=ONe(YNe(ENe(e,"float32"),IEe(r,a)));return{mean:r,variance:p_e(s,n,t)}}});const w_e=dCe({multiRNNCell_:function(e,t,n,r){const a=lCe(t,"data","multiRNNCell"),s=uCe(n,"c","multiRNNCell"),i=uCe(r,"h","multiRNNCell");let o=a;const l=[];for(let d=0;d<e.length;d++){const t=e[d](o,s[d],i[d]);l.push(t[0]),l.push(t[1]),o=t[1]}const u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}});const k_e=dCe({multinomial_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=lCe(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?IEe(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=ZIe.runKernel(yke,o,l);return 1===i?IEe(u,[u.size]):u}});const S_e=dCe({notEqual_:function(e,t){let n=lCe(e,"a","notEqual","string_or_numeric"),r=lCe(t,"b","notEqual","string_or_numeric");[n,r]=GIe(n,r),tTe(n.shape,r.shape);const a={a:n,b:r};return ZIe.runKernel(xke,a)}});const I_e=dCe({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const s={indices:lCe(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return ZIe.runKernel(Cke,s,i)}});const C_e=dCe({onesLike_:function(e){const t={x:lCe(e,"x","onesLike")};return ZIe.runKernel(Ike,t)}});const N_e=dCe({outerProduct_:function(e,t){const n=lCe(e,"v1","outerProduct"),r=lCe(t,"v2","outerProduct");Vve(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const a=IEe(n,[-1,1]),s=IEe(r,[1,-1]);return EEe(a,s)}});const T_e=dCe({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=lCe(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:t,constantValue:n},s={x:r};return ZIe.runKernel(Tke,s,a)}});const E_e=dCe({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Vve(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),T_e(e,[t],n)}});const A_e=dCe({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Vve(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),T_e(e,t,n)}});const __e=dCe({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Vve(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),T_e(e,t,n)}});const $_e=dCe({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Vve(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),T_e(e,t,n)}});const R_e=dCe({spaceToBatchND_:function(e,t,n){const r=lCe(e,"x","spaceToBatchND");Vve(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),Vve(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),Vve(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const a={x:r},s={blockShape:t,paddings:n};return ZIe.runKernel(iSe,a,s)}});const D_e=dCe({pool_:function(e,t,n,r,a,s,i){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");const o=lCe(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=IEe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Vve(xEe(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));const c=cEe(l.shape,t,s,a,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),a=r.map((e=>Math.floor(e/2))),s=r.map(((e,t)=>e-a[t]));return r.map(((e,t)=>[a[t],s[t]]))}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),i=t.map(((e,t)=>(e-s[t]%e)%e)),o=a.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([c.inHeight,c.inWidth],d,h),g=p?r:"valid",y=p?l:R_e(l,d,f),b=("avg"===n?()=>CEe(y,t,s,g,i):()=>c_e(y,t,s,g,i))(),v=p?b:DEe(b,d,m);return u?IEe(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});const M_e=dCe({prelu_:function(e,t){const n={x:lCe(e,"x","prelu"),alpha:lCe(t,"alpha","prelu")};return ZIe.runKernel(Ake,n)}});const F_e=dCe({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=lCe(e,"x","prod");"bool"===r.dtype&&(r=ENe(r,"int32"));const a={x:r},s={axis:t,keepDims:n};return ZIe.runKernel(_ke,a,s)}});const O_e=dCe({raggedGather_:function(e,t,n,r){const a={paramsNestedSplits:e.map(((e,t)=>lCe(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:lCe(t,"paramsDenseValues","raggedGather"),indices:lCe(n,"indices","raggedGather","int32")},s={outputRaggedRank:r},i=ZIe.runKernel($ke,a,s);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const P_e=dCe({raggedRange_:function(e,t,n){const r=lCe(e,"starts","raggedRange"),a={starts:r,limits:lCe(t,"limits","raggedRange",r.dtype),deltas:lCe(n,"deltas","raggedRange",r.dtype)},s=ZIe.runKernel(Rke,a);return{rtNestedSplits:s[0],rtDenseValues:s[1]}}});const L_e=dCe({raggedTensorToTensor_:function(e,t,n,r,a){const s=lCe(e,"shape","raggedTensorToTensor","int32"),i=lCe(t,"values","raggedTensorToTensor"),o={shape:s,values:i,defaultValue:lCe(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>lCe(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:a};return ZIe.runKernel(Dke,o,l)}});const z_e=dCe({rand_:function(e,t,n){mxe(e);const r=Gve(e);let a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let s=0;s<r;s++)a[s]=t();return ZIe.makeTensor(a,e,n)}});var B_e=n(4334);class W_e{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=B_e.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class V_e{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const a=r||Math.random();this.randu=B_e.alea(a.toString()),this.randn=new W_e(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class U_e{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=B_e.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const j_e=dCe({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;if(mxe(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const s=new V_e(t,n,r,a),i=TNe(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const G_e=dCe({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(mxe(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const s=new W_e(t,n,r,!1,a),i=TNe(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const H_e=dCe({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return G_e(e,0,1,t,n)}});const q_e=dCe({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;mxe(e);const s=TNe(e,r),i=new U_e(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});const K_e=dCe({randomUniformInt_:function(e,t,n,r){return q_e(e,t,n,"int32",r)}});function X_e(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:e,stop:t,step:n,dtype:r};return ZIe.runKernel(Mke,{},a)}const Y_e=dCe({real_:function(e){const t={input:lCe(e,"input","real")};return ZIe.runKernel(Fke,t)}});const Q_e=dCe({reciprocal_:function(e){const t={x:lCe(e,"x","reciprocal")};return ZIe.runKernel(Oke,t)}});const J_e=dCe({relu_:function(e){const t={x:lCe(e,"x","relu")};return ZIe.runKernel(Pke,t)}});const Z_e=dCe({relu6_:function(e){const t={x:lCe(e,"x","relu6")};return ZIe.runKernel(Uke,t)}});const e$e=dCe({reverse_:function(e,t){const n={x:lCe(e,"x","reverse")},r={dims:t};return ZIe.runKernel(jke,n,r)}});const t$e=dCe({reverse1d_:function(e){const t=lCe(e,"x","reverse");return Vve(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),e$e(t,0)}});const n$e=dCe({reverse2d_:function(e,t){const n=lCe(e,"x","reverse");return Vve(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),e$e(n,t)}});const r$e=dCe({reverse3d_:function(e,t){const n=lCe(e,"x","reverse");return Vve(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),e$e(n,t)}});const a$e=dCe({reverse4d_:function(e,t){const n=lCe(e,"x","reverse");return Vve(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),e$e(n,t)}});const s$e=dCe({round_:function(e){const t={x:lCe(e,"x","round")};return ZIe.runKernel(Gke,t)}});const i$e=dCe({rsqrt_:function(e){const t={x:lCe(e,"x","rsqrt","float32")};return ZIe.runKernel(Hke,t)}});const o$e=dCe({selu_:function(e){const t={x:lCe(e,"x","selu")};return ZIe.runKernel(Qke,t)}});const l$e=dCe({separableConv2d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const o=lCe(e,"x","separableConv2d"),l=lCe(t,"depthwiseFilter","separableConv2d"),u=lCe(n,"pointwiseFilter","separableConv2d");let c=o,d=!1;if(3===o.rank&&(d=!0,c=IEe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Vve(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),Vve(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),Vve(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),Vve(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),Vve(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const h=l.shape[2],p=l.shape[3];Vve(u.shape[2]===h*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`));const f=oAe(c,l,r,a,i,s),m=KEe(f,u,1,"valid",i);return d?IEe(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const u$e=async function(e,t){const n=lCe(e,"x","setdiff1d"),r=lCe(t,"y","setdiff1d");Vve(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),Vve(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),Vve(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const a=await n.data(),s=await r.data(),i=new Set(s);let o=0;for(let c=0;c<a.length;c++)i.has(a[c])||o++;const l=new EIe([o],n.dtype),u=new EIe([o],"int32");for(let c=0,d=0;c<a.length;c++)i.has(a[c])||(l.values[d]=a[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]};const c$e=dCe({sign_:function(e){const t={x:lCe(e,"x","sign")};return ZIe.runKernel(tSe,t)}});const d$e=dCe({sin_:function(e){const t={x:lCe(e,"x","sin","float32")};return ZIe.runKernel(Zke,t)}});const h$e=dCe({sinh_:function(e){const t={x:lCe(e,"x","sinh")};return ZIe.runKernel(eSe,t)}});const p$e=dCe({slice1d_:function(e,t,n){const r=lCe(e,"x","slice1d");return Vve(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),_Ee(r,[t],[n])}});const f$e=dCe({slice2d_:function(e,t,n){const r=lCe(e,"x","slice2d");return Vve(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),_Ee(r,t,n)}});const m$e=dCe({slice3d_:function(e,t,n){const r=lCe(e,"x","slice3d");return Vve(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),_Ee(r,t,n)}});const g$e=dCe({slice4d_:function(e,t,n){const r=lCe(e,"x","slice4d");return Vve(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),_Ee(r,t,n)}});const y$e=dCe({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=lCe(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},a={dim:t};return ZIe.runKernel(lSe,r,a)}});const b$e=dCe({fft_:function(e){Vve("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return ZIe.runKernel(Rwe,t)}});const v$e=dCe({ifft_:function(e){Vve("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return ZIe.runKernel(Uwe,t)}});const x$e=dCe({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const a=IEe(e,[n,t]);r=v$e(a)}else{const a=[n,2*(t-1)],s=IEe(Y_e(e),[n,t]),i=IEe(WAe(e),[n,t]),o=e$e(_Ee(s,[0,1],[n,t-2]),1),l=MNe(e$e(_Ee(i,[0,1],[n,t-2]),1),zNe(-1)),u=TEe([s,o],1),c=TEe([i,l],1),d=IEe(hCe(u,c),[a[0],a[1]]);r=v$e(d)}if(r=Y_e(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=IEe(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const w$e=dCe({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:lCe(e,"x","split")},a={numOrSizeSplits:t,axis:n};return ZIe.runKernel(oSe,r,a)}});const k$e=dCe({rfft_:function(e,t){Vve("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let a;if(null!=t&&t<n){const r=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,a=_Ee(e,r,s),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,a=TEe([e,f_e(r)],e.shape.length-1),n=t}else a=e;const s=PNe(a),i=IEe(hCe(a,s),[r,n]),o=b$e(i),l=Math.floor(n/2)+1,u=Y_e(o),c=WAe(o),d=w$e(u,[l,n-l],u.shape.length-1),h=w$e(c,[l,n-l],c.shape.length-1),p=a.shape.slice();return p[a.shape.length-1]=l,IEe(hCe(d[0],h[0]),p)}});const S$e=dCe({squaredDifference_:function(e,t){let n=lCe(e,"a","squaredDifference"),r=lCe(t,"b","squaredDifference");[n,r]=GIe(n,r),tTe(n.shape,r.shape);const a={a:n,b:r};return ZIe.runKernel(fSe,a,{})}});const I$e=dCe({squeeze_:function(e,t){const n=lCe(e,"x","squeeze","string_or_numeric");return IEe(n,Zve(n.shape,t).newShape)}});const C$e=dCe({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=uCe(e,"tensors","stack","string_or_numeric");Vve(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Vve(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,a={axis:t};return ZIe.runKernel(Nke,r,a)}});const N$e=dCe({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:lCe(e,"x","step")},r={alpha:t};return ZIe.runKernel(RSe,n,r)}});const T$e=dCe({stridedSlice_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const u={x:lCe(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return ZIe.runKernel(ySe,u,c)}});const E$e=dCe({tan_:function(e){const t={x:lCe(e,"x","tan","float32")};return ZIe.runKernel(kSe,t)}});function A$e(e,t){jve(e);const n=sCe(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return pCe(e,null,n,t)}function _$e(e,t,n){if(jve(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=sCe(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return pCe(e,t,r,n)}function $$e(e,t,n){if(jve(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=sCe(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return pCe(e,t,r,n)}function R$e(e,t,n){if(jve(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=sCe(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return pCe(e,t,r,n)}function D$e(e,t,n){if(jve(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=sCe(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return pCe(e,t=t||r,r,n)}function M$e(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function F$e(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}M$e(n,t,e)}function O$e(e,t,n){const r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length;let i=1;for(let l=a;l<s;++l)i*=n[l];const o=a<1?1:a;return{sliceRank:a,numUpdates:Gve(t.shape)/o,sliceSize:i,strides:[...uxe(n.slice(0,a)),1],outputSize:Gve(n)}}const P$e=dCe({tensorScatterUpdate_:function(e,t,n){const r=lCe(e,"tensor","tensorScatterupdate"),a=lCe(t,"indices","tensorScatterupdate","int32"),s=lCe(n,"updates","tensorScatterupdate");if(F$e(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);const i={tensor:r,indices:a,updates:s};return ZIe.runKernel(Kke,i,{})}});const L$e=dCe({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=lCe(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);const s={x:r},i={k:t,sorted:n},[o,l]=ZIe.runKernel(CSe,s,i);return{values:o,indices:l}}});const z$e=dCe({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(mxe(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new W_e(t,n,r,!0,a),i=TNe(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const B$e=dCe({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=lCe(e,"x","unique","string_or_numeric");Vve(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},a={axis:t},[s,i]=ZIe.runKernel(ESe,r,a);return{values:s,indices:i}}});const W$e=dCe({unsortedSegmentSum_:function(e,t,n){const r=lCe(e,"x","unsortedSegmentSum"),a=lCe(t,"segmentIds","unsortedSegmentSum","int32");Vve(qve(n),(()=>"numSegments must be of dtype int"));const s={x:r,segmentIds:a},i={numSegments:n};return ZIe.runKernel(_Se,s,i)}});const V$e=dCe({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=lCe(e,"x","unstack","string_or_numeric");Vve(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},a={axis:t};return ZIe.runKernel(ASe,r,a)}});function U$e(e,t){return l_e(e,t,"right")}function j$e(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return ZIe.makeVariable(e,t,n,r)}function G$e(e,t){const n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);const r=TNe(e,"int32"),a=TNe([n.length,e.length],"int32");for(let s=0;s<n.length;s++){const t=r.indexToLoc(n[s]),i=s*e.length;a.values.set(t,i)}return a.toTensor()}const H$e=async function(e){const t=lCe(e,"condition","whereAsync","bool"),n=await t.data(),r=G$e(t.shape,n);return e!==t&&t.dispose(),r};const q$e=async function(e,t,n){const r=lCe(e,"tensor","boolMask"),a=lCe(t,"mask","boolMask","bool"),s=null==n?0:n,i=a.rank,o=r.shape;Vve(i>0,(()=>"mask cannot be scalar")),Uve(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];const u=o.slice(0,s).concat([l],o.slice(s+i)),c=IEe(r,u),d=IEe(a,[-1]),h=await H$e(d),p=I$e(h,[1]),f=LAe(c,p,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f};const K$e=dCe({transpose_:function(e,t,n){const r=lCe(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Vve(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{Vve(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const a={x:r},s={perm:t};return"complex64"===r.dtype?vCe((()=>{let e=Y_e(r),t=WAe(r);return e=ZIe.runKernel(TSe,{x:e},s),t=ZIe.runKernel(TSe,{x:t},s),n&&(t=JAe(t)),hCe(e,t)})):ZIe.runKernel(TSe,a,s)}});const X$e=dCe({movingAverage_:function(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const s=lCe(e,"v","movingAverage"),i=lCe(t,"x","movingAverage"),o=lCe(n,"decay","movingAverage");!function(e,t){Vve(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}(s,i),Vve(Hve(s.shape,i.shape),(()=>"Shape mismatch in v and x"));const l=zNe(1),u=YNe(l,o);let c=MNe(YNe(i,s),u);if(a){Vve(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=lCe(r,"step","movingAverage");c=DNe(c,YNe(l,XNe(o,e)))}return $Ne(s,c)}});const Y$e=dCe({scatterND_:function(e,t,n){mxe(n);const r=lCe(e,"indices","scatterND","int32"),a=lCe(t,"updates","scatterND");F$e(a,r,n);const s={indices:r,updates:a},i={shape:n};return ZIe.runKernel(qke,s,i)}});const Q$e=dCe({sparseToDense_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;mxe(n);const a=lCe(e,"sparseIndices","sparseToDense","int32"),s=lCe(t,"sparseValues","sparseToDense","string_or_numeric"),i=lCe(r,"defaultValue","sparseToDense",s.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,s,n,i);const o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return ZIe.runKernel(pSe,o,l)}});const J$e=dCe({gatherND_:function(e,t){const n=lCe(t,"indices","gatherND","int32"),r={params:lCe(e,"x","gatherND","string_or_numeric"),indices:n};return ZIe.runKernel(zwe,r)}});const Z$e=dCe({dropout_:function(e,t,n,r){const a=lCe(e,"x","dropout");if(Vve("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),Vve(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof RIe?a.clone():a;const s=function(e,t){if(null==t)return e.shape.slice();if(Hve(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),i=1-t,o=DNe(PAe($Ne(q_e(s,0,1,"float32",r),i)),i);return MNe(a,o)}});function eRe(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function tRe(e,t,n){const r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){const i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return A$e(a,"float32")}const nRe=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const r=lCe(e,"predictions","inTopK"),a=lCe(t,"targets","inTopK");Vve(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),Vve(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),Uve(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];Vve(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));const i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],c=exe("bool",l);for(let d=0;d<l;d++){const e=d*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),c[d]=0;for(let a=0;a<n;a++)if(r[a].index===o[d]){c[d]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),fCe(c,a.shape,"bool")};const rRe=dCe({conv2DBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=IEe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=IEe(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Vve(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),Vve(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),Vve(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===s?o.shape[3]:o.shape[1],c="NHWC"===s?l.shape[3]:l.shape[1];Vve(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),Vve(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),SEe("conv2dDerFilter",a,i);const d={x:o,dy:l},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return ZIe.runKernel(rwe,d,h)}});function aRe(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return MNe(e,N$e(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function sRe(e,t){let n=t;const r=eTe(e.shape,t.shape);return r.length>0&&(n=EAe(n,r)),IEe(n,e.shape)}function iRe(e,t,n,r){if("linear"===t)return e;if("relu"===t)return J_e(e);if("elu"===t)return mAe(e);if("relu6"===t)return Z_e(e);if("prelu"===t)return M_e(e,n);if("leakyrelu"===t)return GAe(e,r);if("sigmoid"===t)return AEe(e);throw new Error(`Unknown fused activation ${t}.`)}const oRe=(e,t)=>!(e>0)||"linear"===t;const lRe=dCe({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(u=u||"linear",!1===oRe(ZIe.state.gradientDepth,u)){Vve("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=KEe(t,n,r,a,s,i,o);return null!=l&&(e=$Ne(e,l)),iRe(e,u,c,d)}const h=lCe(t,"x","conv2d","float32"),p=lCe(n,"filter","conv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=IEe(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Vve(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),Vve(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),SEe("fused conv2d",a,o);const g="NHWC"===s?f.shape[3]:f.shape[1];Vve(p.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`)),Vve(xEe(r,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`));const y=hEe(f.shape,p.shape,r,i,a,o);let b,v;if(null!=l&&(b=lCe(l,"bias","fused conv2d"),[b]=GIe(b,h),"NHWC"===s?tTe(y.outShape,b.shape):(Vve(b.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`)),Vve(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)))),null!=c){const e=c.shape;if(Vve(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)Vve(1===e[0]||e[0]===y.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${y.outChannels}).`));else if(3===e.length)try{tTe(e,y.outShape)}catch(gD){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(n)}v=lCe(c,"prelu weights","fused conv2d")}const x=(e,t)=>{Vve("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));const[n,o,l,c]=t,d=aRe(e,l,u);Vve(vEe(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));const h=[YEe(o.shape,d,n,r,a),rRe(o,d,n.shape,r,a)];if(null!=c){const e=sRe(c,d);h.push(e)}return h},w={x:f,filter:p,bias:b,preluActivationWeights:v},k={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};if(null==l){const e=LNe(((e,t,n)=>{let r=ZIe.runKernel(OSe,w,k);return n([t,e,r]),m&&(r=IEe(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p)}{const e=LNe(((e,t,n,r)=>{let a=ZIe.runKernel(OSe,w,k);return r([t,e,a,n]),m&&(a=IEe(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}));return e(f,p,b)}}});const uRe=dCe({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=IEe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=IEe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return ZIe.runKernel(gwe,u,c)}});const cRe=dCe({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,l=!1;3===t.rank&&(l=!0,o=IEe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},d=ZIe.runKernel(ywe,u,c);return l?IEe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const dRe=dCe({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(!1===oRe(ZIe.state.gradientDepth,u)){let e=oAe(t,n,r,a,s,i,o);return null!=l&&(e=$Ne(e,l)),iRe(e,u,c,d)}const h=lCe(t,"x","depthwiseConv2d","float32"),p=lCe(n,"filter","depthwiseConv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=IEe(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Vve(4===f.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`)),Vve(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),Vve(f.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==i&&(i=[1,1]),Vve(xEe(r,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`)),SEe("fused depthwiseConv2d",a,o);const g=hEe(f.shape,p.shape,r,i,a,o,!0);let y,b;null!=l&&(y=lCe(l,"bias","fused conv2d"),[y]=GIe(y,h),tTe(g.outShape,y.shape)),null!=c&&(b=lCe(c,"prelu weights","fused depthwiseConv2d"));const v=(e,t)=>{Vve(vEe(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[n,s,l,c]=t,d=aRe(e,l,u),h=cRe(s.shape,d,n,r,a,i,o),p=uRe(s,d,n.shape,r,a,i,o);if(null!=c){return[h,p,sRe(y,d)]}return[h,p]},x={x:f,filter:p,bias:y,preluActivationWeights:b},w={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};if(null==l){const e=LNe(((e,t,n)=>{let r=ZIe.runKernel(PSe,x,w);return n([t,e,r]),m&&(r=IEe(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p)}{const e=LNe(((e,t,n,r)=>{let a=ZIe.runKernel(PSe,x,w);return r([t,e,a,n]),m&&(a=IEe(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return e(f,p,y)}}});const hRe=dCe({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}=e;if(!1===oRe(ZIe.state.gradientDepth,i)){let e=EEe(t,n,r,a);return null!=s&&(e=$Ne(e,s)),iRe(e,i,o,l)}let u=lCe(t,"a","fused matMul"),c=lCe(n,"b","fused matMul");[u,c]=GIe(u,c);const d=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=a?c.shape[c.rank-1]:c.shape[c.rank-2],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=a?c.shape[c.rank-2]:c.shape[c.rank-1],m=u.shape.slice(0,-2),g=c.shape.slice(0,-2),y=Gve(m),b=Gve(g);Vve(d===h,(()=>`Error in fused matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${r} and transposeB=${a} must match.`));const v=tTe(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),x=IEe(u,r?[y,d,p]:[y,p,d]),w=IEe(c,a?[b,f,h]:[b,h,f]);let k,S;null!=s&&(k=lCe(s,"bias","fused matMul"),[k]=GIe(k,u),tTe(v,k.shape)),null!=o&&(S=lCe(o,"prelu weights","fused matMul"));const I=(e,t)=>{const[n,o,l,u]=t,c=aRe(IEe(e,l.shape),l,i);let d,h;if(r||a?!r&&a?(d=EEe(c,o,!1,!1),h=EEe(c,n,!0,!1)):r&&!a?(d=EEe(o,c,!1,!0),h=EEe(n,c,!1,!1)):(d=EEe(o,c,!0,!0),h=EEe(c,n,!0,!0)):(d=EEe(c,o,!1,!0),h=EEe(n,c,!0,!1)),null!=s){return[d,h,sRe(u,c)]}return[d,h]},C={a:x,b:w,bias:k,preluActivationWeights:S},N={transposeA:r,transposeB:a,activation:i,leakyreluAlpha:l};if(null==s){const e=LNe(((e,t,n)=>{const r=ZIe.runKernel(FSe,C,N);return n([e,t,r]),{value:IEe(r,v),gradFunc:I}}));return e(x,w)}{const e=LNe(((e,t,n,r)=>{const a=ZIe.runKernel(FSe,C,N);return r([e,t,a,n]),{value:IEe(a,v),gradFunc:I}}));return e(x,w,k)}}});const pRe=dCe({hammingWindow_:function(e){return tRe(e,.54,.46)}});const fRe=dCe({hannWindow_:function(e){return tRe(e,.5,.5)}});const mRe=dCe({frame_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0;const i=[];for(;s+t<=e.size;)i.push(_Ee(e,s,t)),s+=n;if(r)for(;s<e.size;){const r=s+t-e.size,o=TEe([_Ee(e,s,t-r),qNe([r],a)]);i.push(o),s+=n}return 0===i.length?_$e([],[0,t]):IEe(TEe(i),[i.length,t])}});const gRe=dCe({stft_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:fRe;null==r&&(r=eRe(t));const s=mRe(e,t,n),i=MNe(s,a(t));return k$e(i,r)}});const yRe=dCe({cropAndResize_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=lCe(e,"image","cropAndResize"),o=lCe(t,"boxes","cropAndResize","float32"),l=lCe(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Vve(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),Vve(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),Vve(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),Vve(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Vve(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Vve("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));const c={image:i,boxes:o,boxInd:l},d={method:a,extrapolationValue:s,cropSize:r};return ZIe.runKernel(hwe,c,d)}});const bRe=dCe({flipLeftRight_:function(e){const t=lCe(e,"image","flipLeftRight","float32");Vve(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return ZIe.runKernel(Mwe,n,{})}});const vRe=dCe({grayscaleToRGB_:function(e){const t=lCe(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Vve(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),Vve(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,FAe(t,a)}});const xRe=dCe({rgbToGrayscale_:function(e){const t=lCe(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Vve(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),Vve(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const a=t.dtype,s=ENe(t,"float32"),i=A$e([.2989,.587,.114]);let o;switch(t.rank){case 2:o=fAe("ij,j->i",s,i);break;case 3:o=fAe("ijk,k->ij",s,i);break;case 4:o=fAe("ijkl,l->ijk",s,i);break;case 5:o=fAe("ijklm,m->ijkl",s,i);break;case 6:o=fAe("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=DAe(o,-1),ENe(o,a)}});const wRe=dCe({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=lCe(e,"image","rotateWithOffset","float32");Vve(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));const s={image:a},i={radians:t,fillValue:n,center:r};return ZIe.runKernel(MSe,s,i)}});function kRe(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const i=e.shape[0];return n=Math.min(n,i),Vve(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Vve(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),Vve(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),Vve(1===t.rank,(()=>"scores must be a 1D tensor")),Vve(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),Vve(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}const SRe=dCe({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=lCe(e,"boxes","nonMaxSuppression","float32"),i=lCe(t,"scores","nonMaxSuppression","float32"),o=kRe(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return ZIe.runKernel(wke,{boxes:s,scores:i},l)}});function IRe(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);const o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}(e,t,n||CRe)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function CRe(e,t){return e>t?1:e<t?-1:0}function NRe(e,t,n,r,a){return ARe(e,t,n,r,a,0)}function TRe(e,t,n,r,a,s){return ARe(e,t,n,r,a,0,!1,s,!0)}function ERe(e,t,n,r,a,s){return ARe(e,t,n,r,a,s,!0)}function ARe(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(RRe);const c=s>0?-.5/s:0,d=[],h=[];for(;d.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<a)break;let o=!1;for(let l=d.length-1;l>=i;--l){const n=_Re(e,s,d[l]);if(n>=r){o=!0;break}if(t.score=t.score*$Re(r,c,n),t.score<=a)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(s),h.push(t.score)):t.score>a&&IRe(u,t,RRe))}const p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function _Re(e,t,n){const r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),h=Math.max(a[1],a[3]),p=(o-s)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(s,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function $Re(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function RRe(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const DRe=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=lCe(e,"boxes","nonMaxSuppressionAsync"),i=lCe(t,"scores","nonMaxSuppressionAsync"),o=kRe(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;const l=await Promise.all([s.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=NRe(u,c,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),A$e(d,"int32")};const MRe=dCe({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=lCe(e,"boxes","nonMaxSuppression"),o=lCe(t,"scores","nonMaxSuppression"),l=kRe(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},d=ZIe.runKernel(Ske,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}});const FRe=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=lCe(e,"boxes","nonMaxSuppressionAsync"),o=lCe(t,"scores","nonMaxSuppressionAsync"),l=kRe(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=ERe(c,d,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:A$e(h,"int32"),selectedScores:A$e(p)}};const ORe=dCe({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=lCe(e,"boxes","nonMaxSuppression"),o=lCe(t,"scores","nonMaxSuppression"),l=kRe(i,o,n,r,a,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},d=ZIe.runKernel(kke,u,c);return{selectedIndices:d[0],validOutputs:d[1]}}});const PRe=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=lCe(e,"boxes","nonMaxSuppressionAsync"),o=lCe(t,"scores","nonMaxSuppressionAsync"),l=kRe(i,o,n,r,a,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=TRe(h,p,u,c,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:A$e(f,"int32"),validOutputs:zNe(m,"int32")}};const LRe=dCe({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=lCe(e,"images","resizeBilinear");Vve(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),Vve(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),Vve(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=IEe(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=ZIe.runKernel(Wke,o,l);return i?IEe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const zRe=dCe({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=lCe(e,"images","resizeNearestNeighbor");Vve(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),Vve(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),Vve("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Vve(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=IEe(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=ZIe.runKernel(zke,o,l);return i?IEe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const BRe=dCe({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=lCe(e,"image","threshold"),s=a.shape[0]*a.shape[1];let i,o,l,u,c=MNe(A$e([r]),255);if(Vve(3===a.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`)),Vve(3===a.shape[2]||1===a.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`)),Vve("int32"===a.dtype||"float32"===a.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`)),Vve("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===a.shape[2]){[i,o,l]=w$e(a,[1,1,1],-1);const e=MNe(i,.2989),t=MNe(o,.587),n=MNe(l,.114);u=$Ne($Ne(e,t),n)}else u=e;if("otsu"===t){c=function(e,t){let n,r,a,s,i,o,l=A$e([-1]),u=A$e([0]),c=A$e([0]);for(let d=0;d<e.size-1;d++){n=_Ee(e,0,d+1),r=_Ee(e,d+1),i=DNe(EAe(n),t),o=DNe(EAe(r),t);const h=EAe(MNe(n,X_e(0,n.size)));a=DNe(h,EAe(n));const p=qNe(r.shape,n.size),f=$Ne(X_e(0,r.size),p),m=MNe(r,f);s=DNe(EAe(m),EAe(r));const g=YNe(a,s),y=YNe(a,s),b=MNe(i,o);c=MNe(MNe(b,g),y);const v=zAe(c,u);u=dAe(v,c,u),l=dAe(v,A$e([d]),l)}return l}(LEe(ENe(s$e(u),"int32"),fCe([]),256),s)}const d=n?qAe(u,c):zAe(u,c);return ENe(MNe(d,255),"int32")}});const WRe=dCe({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const i=lCe(e,"image","transform","float32"),o=lCe(t,"transforms","transform","float32");Vve(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),Vve(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Vve(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return ZIe.runKernel(NSe,l,u)}});const VRe=dCe({bandPart_:function(e,t,n){const r=lCe(e,"a","bandPart");Vve(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const a=r.shape,[s,i]=r.shape.slice(-2);let o,l;"number"===typeof t?(Vve(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Vve(t<=s,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`)),o=lCe(t<0?s:t,"numLower","bandPart")):(Vve("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=dAe(HAe(t,0),s,y_e(t,s))),"number"===typeof n?(Vve(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),Vve(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),l=lCe(n<0?i:n,"numUpper","bandPart")):(Vve("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=dAe(HAe(n,0),i,y_e(n,i)));const u=IEe(X_e(0,s,1,"int32"),[-1,1]),c=X_e(0,i,1,"int32"),d=YNe(u,c),h=r_e(qAe(d,o),BAe(d,JAe(l))),p=f_e([s,i],r.dtype);return IEe(C$e(V$e(IEe(r,[-1,s,i])).map((e=>dAe(h,e,p)))),a)}});const URe=dCe({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Vve(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Vve(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=w$e(e,e.shape[0],0).map((e=>I$e(e,[0])));Vve(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let a=0;a<e.length;++a)n.push(ZIe.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){const r=MNe(EAe(MNe(n[t],e)),n[t]);e=YNe(e,r)}return DNe(e,_Ae(e,"euclidean"))})));return t?C$e(n,0):n}});function jRe(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return ZIe.tidy((()=>{Vve(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let a=OAe(n),s=ANe(e);const i=_$e([[1]],[1,1]);let o=ANe(i);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=s,l=o,u=a;[o,s,a]=ZIe.tidy((()=>{const t=_Ee(s,[e,e],[n-e,1]),l=_Ae(t),u=_Ee(s,[e,e],[1,1]),c=dAe(zAe(u,0),_$e([[-1]]),_$e([[1]])),d=YNe(u,MNe(c,l)),h=DNe(t,d);o=1===h.shape[0]?ANe(i):TEe([i,_Ee(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=JAe(DNe(EEe(c,d),l)),f=_Ee(s,[e,0],[n-e,r]),m=MNe(p,o),g=K$e(o);if(0===e)s=YNe(f,EEe(m,EEe(g,f)));else{const t=YNe(f,EEe(m,EEe(g,f)));s=TEe([_Ee(s,[0,0],[e,r]),t],0)}const y=K$e(m),b=_Ee(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=YNe(b,EEe(EEe(b,o),y));else{const t=YNe(b,EEe(EEe(b,o),y));a=TEe([_Ee(a,[0,0],[n,e]),t],1)}return[o,s,a]})),xCe([t,l,u])}return!t&&n>r&&(a=_Ee(a,[0,0],[n,r]),s=_Ee(s,[0,0],[r,r])),[a,s]}))}const GRe=dCe({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Vve(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return jRe(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=V$e(IEe(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach((e=>{const[n,r]=jRe(e,t);a.push(n),s.push(r)}));return[IEe(C$e(a,0),e.shape),IEe(C$e(s,0),e.shape)]}}});var HRe;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(HRe||(HRe={}));const qRe=dCe({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:HRe.SUM_BY_NONZERO_WEIGHTS;const r=lCe(e,"losses","computeWeightedLoss");let a=null;null!=t&&(a=lCe(t,"weights","computeWeightedLoss"));const s=null==a?r:MNe(r,a);if(n===HRe.NONE)return s;if(n===HRe.SUM)return EAe(s);if(n===HRe.MEAN){if(null==a)return p_e(s);{const e=r.size/a.size,t=DNe(EAe(s),EAe(a));return e>1?DNe(t,zNe(e)):t}}if(n===HRe.SUM_BY_NONZERO_WEIGHTS){if(null==a)return DNe(EAe(s),zNe(r.size));{const e=MNe(a,m_e(r.shape)),t=ENe(EAe(S_e(e,zNe(0))),"float32");return DNe(EAe(s),t)}}throw Error(`Unknown reduction: ${n}`)}});const KRe=dCe({absoluteDifference_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:HRe.SUM_BY_NONZERO_WEIGHTS;const a=lCe(e,"labels","absoluteDifference"),s=lCe(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=lCe(n,"weights","absoluteDifference")),Uve(a.shape,s.shape,"Error in absoluteDifference: ");const o=JNe(YNe(a,s));return qRe(o,i,r)}});const XRe=dCe({cosineDistance_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:HRe.SUM_BY_NONZERO_WEIGHTS;const s=lCe(e,"labels","cosineDistance"),i=lCe(t,"predictions","cosineDistance");let o=null;null!=r&&(o=lCe(r,"weights","cosineDistance")),Uve(s.shape,i.shape,"Error in cosineDistance: ");const l=zNe(1),u=YNe(l,EAe(MNe(s,i),n,!0));return qRe(u,o,a)}});const YRe=dCe({hingeLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:HRe.SUM_BY_NONZERO_WEIGHTS,a=lCe(e,"labels","hingeLoss");const s=lCe(t,"predictions","hingeLoss");let i=null;null!=n&&(i=lCe(n,"weights","hingeLoss")),Uve(a.shape,s.shape,"Error in hingeLoss: ");const o=zNe(1);a=YNe(MNe(zNe(2),a),o);const l=J_e(YNe(o,MNe(a,s)));return qRe(l,i,r)}});const QRe=dCe({huberLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:HRe.SUM_BY_NONZERO_WEIGHTS;const s=lCe(e,"labels","huberLoss"),i=lCe(t,"predictions","huberLoss");let o=null;null!=n&&(o=lCe(n,"weights","huberLoss")),Uve(s.shape,i.shape,"Error in huberLoss: ");const l=zNe(r),u=JNe(YNe(i,s)),c=y_e(u,l),d=YNe(u,c),h=$Ne(MNe(zNe(.5),ONe(c)),MNe(l,d));return qRe(h,o,a)}});const JRe=dCe({logLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:HRe.SUM_BY_NONZERO_WEIGHTS;const s=lCe(e,"labels","logLoss"),i=lCe(t,"predictions","logLoss");let o=null;null!=n&&(o=lCe(n,"weights","logLoss")),Uve(s.shape,i.shape,"Error in logLoss: ");const l=zNe(1),u=zNe(r),c=JAe(MNe(s,YAe($Ne(i,u)))),d=MNe(YNe(l,s),YAe($Ne(YNe(l,i),u))),h=YNe(c,d);return qRe(h,o,a)}});const ZRe=dCe({meanSquaredError_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:HRe.SUM_BY_NONZERO_WEIGHTS;const a=lCe(e,"labels","meanSquaredError"),s=lCe(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=lCe(n,"weights","meanSquaredError")),Uve(a.shape,s.shape,"Error in meanSquaredError: ");const o=S$e(a,s);return qRe(o,i,r)}});const eDe=dCe({sigmoidCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:HRe.SUM_BY_NONZERO_WEIGHTS,s=lCe(e,"multiClassLabels","sigmoidCrossEntropy");const i=lCe(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=lCe(n,"weights","sigmoidCrossEntropy")),Uve(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=zNe(r),t=zNe(1),n=zNe(.5);s=$Ne(MNe(s,YNe(t,e)),MNe(n,e))}const l=function(e,t){const n=lCe(e,"labels","sigmoidCrossEntropyWithLogits"),r=lCe(t,"logits","sigmoidCrossEntropyWithLogits");Uve(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const a=J_e(r),s=MNe(r,n),i=QAe(RAe(JAe(JNe(r))));return $Ne(YNe(a,s),i)}(s,i);return qRe(l,o,a)}});const tDe=dCe({softmaxCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:HRe.SUM_BY_NONZERO_WEIGHTS,s=lCe(e,"onehotLabels","softmaxCrossEntropy");const i=lCe(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=lCe(n,"weights","softmaxCrossEntropy")),Uve(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=zNe(r),t=zNe(1),n=zNe(s.shape[1]);s=$Ne(MNe(s,YNe(t,e)),DNe(e,n))}const l=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=LNe(((e,t,r)=>{const a=n_e(t,[n],!0),s=YNe(ENe(t,"float32"),a);r([e,s]);const i=JAe(MNe(s,e));return{value:EAe(i,[n]),gradFunc:(e,t)=>{const[r,a]=t,s=wAe(e.shape,[n]);return[MNe(IEe(e,s),YNe(ENe(r,"float32"),RAe(a))),MNe(IEe(e,s),YNe(RAe(a),ENe(r,"float32")))]}}}));return r(e,t)}(s,i);return qRe(l,o,a)}});const nDe=dCe({sparseFillEmptyRows_:function(e,t,n,r){const a=lCe(e,"indices","sparseFillEmptyRows","int32"),s=lCe(t,"values","sparseFillEmptyRows"),i=lCe(n,"denseShape","sparseFillEmptyRows","int32"),o=lCe(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:a,values:s,denseShape:i,defaultValue:o},u=ZIe.runKernel(uSe,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});const rDe=dCe({sparseReshape_:function(e,t,n){const r=lCe(e,"inputIndices","sparseReshape","int32"),a=lCe(t,"inputShape","sparseReshape","int32"),s=lCe(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const i={inputIndices:r,inputShape:a,newShape:s},o=ZIe.runKernel(cSe,i);return{outputIndices:o[0],outputShape:o[1]}}});const aDe=dCe({sparseSegmentMean_:function(e,t,n){const r=lCe(e,"data","sparseSegmentMean"),a=lCe(t,"indices","sparseSegmentMean","int32"),s=lCe(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);const i={data:r,indices:a,segmentIds:s};return ZIe.runKernel(dSe,i)}});const sDe=dCe({sparseSegmentSum_:function(e,t,n){const r=lCe(e,"data","sparseSegmentSum"),a=lCe(t,"indices","sparseSegmentSum","int32"),s=lCe(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);const i={data:r,indices:a,segmentIds:s};return ZIe.runKernel(hSe,i)}});const iDe=dCe({stringNGrams_:function(e,t,n,r,a,s,i,o){const l=lCe(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=lCe(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=ZIe.runKernel(bSe,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}});const oDe=dCe({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=lCe(e,"input","stringSplit","string"),a=lCe(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);const s={skipEmpty:n},i={input:r,delimiter:a},o=ZIe.runKernel(vSe,i,s);return{indices:o[0],values:o[1],shape:o[2]}}});const lDe=dCe({stringToHashBucketFast_:function(e,t){const n=lCe(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return ZIe.runKernel(xSe,a,r)}});const uDe=dCe({staticRegexReplace_:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=lCe(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return ZIe.runKernel(gSe,{x:a},s)}}),cDe={fft:b$e,ifft:v$e,rfft:k$e,irfft:x$e},dDe={hammingWindow:pRe,hannWindow:fRe,frame:mRe,stft:gRe},hDe={flipLeftRight:bRe,grayscaleToRGB:vRe,resizeNearestNeighbor:zRe,resizeBilinear:LRe,rgbToGrayscale:xRe,rotateWithOffset:wRe,cropAndResize:yRe,nonMaxSuppression:SRe,nonMaxSuppressionAsync:DRe,nonMaxSuppressionWithScore:MRe,nonMaxSuppressionWithScoreAsync:FRe,nonMaxSuppressionPadded:ORe,nonMaxSuppressionPaddedAsync:PRe,threshold:BRe,transform:WRe},pDe={bandPart:VRe,gramSchmidt:URe,qr:GRe},fDe={absoluteDifference:KRe,computeWeightedLoss:qRe,cosineDistance:XRe,hingeLoss:YRe,huberLoss:QRe,logLoss:JRe,meanSquaredError:ZRe,sigmoidCrossEntropy:eDe,softmaxCrossEntropy:tDe},mDe={sparseFillEmptyRows:nDe,sparseReshape:rDe,sparseSegmentMean:aDe,sparseSegmentSum:sDe},gDe={stringNGrams:iDe,stringSplit:oDe,stringToHashBucketFast:lDe,staticRegexReplace:uDe};const yDe=class{static sgd(e){return new aTe(e)}static momentum(e,t){return new sTe(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new iTe(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new QNe(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new HNe(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new rTe(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new KNe(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},bDe="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function vDe(){return new Promise((e=>bDe((()=>e()))))}function xDe(e,t){const n=e[0].length;e.forEach(((e,t)=>{Vve(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),Vve(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)Vve(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function wDe(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var kDe;function SDe(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){const s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function IDe(e){const t={FIRST_DIM_SIZE:kDe.FIRST_DIM_SIZE,VALUE_ROWIDS:kDe.VALUE_ROWIDS,ROW_LENGTHS:kDe.ROW_LENGTHS,ROW_SPLITS:kDe.ROW_SPLITS,ROW_LIMITS:kDe.ROW_LIMITS,ROW_STARTS:kDe.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function CDe(e){return 0===e.length?0:e[0]===kDe.FIRST_DIM_SIZE?e.length-1:e.length}function NDe(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){const n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(kDe||(kDe={}));const TDe=30;function EDe(e){return e<=TDe?e:lxe(e,Math.floor(Math.sqrt(e)))}function ADe(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function _De(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function $De(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{const r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function RDe(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function DDe(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function MDe(e,t,n){const r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}function FDe(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Gve(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const a=t.shape,s=a[a.length-1];let i=1;for(let d=0;d<a.length-1;++d)i*=a[d];const o=e.shape,l=a.slice();l.pop();let u=1;for(let d=s;d<n;++d)u*=o[d],l.push(o[d]);const c=[...uxe(e.shape).map((e=>e/u)),1].slice(0,s);return[l,i,u,c]}const ODe=1.7580993408473768,PDe=1.0507009873554805,LDe=.3275911,zDe=.254829592,BDe=-.284496736,WDe=1.421413741,VDe=-1.453152027,UDe=1.061405429;function jDe(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function GDe(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function HDe(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function qDe(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function KDe(e,t){return{real:e[2*t],imag:e[2*t+1]}}function XDe(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function YDe(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){const s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function QDe(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const JDe="->",ZDe=/->/g,eMe=",",tMe="...";function nMe(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(ZDe,"").length)/JDe.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${JDe}").`);const[r,a]=e.split(JDe);Vve(-1===r.indexOf(tMe),(()=>`The ellipsis notation ("${tMe}") is not supported yet.`));const s=r.split(eMe),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let d=0;d<a.length;++d){const e=a[d];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<r.length;++d){const e=r[d];-1===o.indexOf(e)&&e!==eMe&&o.push(e)}const l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let e=0;e<s[d].length;++e)l[d].push(o.indexOf(s[d][e]))}const u=o.length,c=[];for(let d=a.length;d<u;++d)c.push(d);return{allDims:o,summedDims:c,idDims:l}}function rMe(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;const r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function aMe(e,t,n){const r=new Array(e);for(let a=0;a<n.length;++a){const e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:Vve(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function sMe(e,t){const n=e,r=[];let a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);const s=[];for(let i=0;i<n.length;++i){const e=oMe(t,n[i]);for(const t of e)-1===s.indexOf(t)&&(r[i].push(t),s.push(t))}return{path:n,steps:r}}function iMe(e){return e.every(((e,t)=>e===t))}function oMe(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function lMe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof t)Vve(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Vve(a<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}Vve(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function uMe(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function cMe(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function dMe(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function hMe(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function pMe(e,t){return`size ${e} must be non-negative, not ${t}`}function fMe(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function mMe(e,t){return`Input to reshape is a SparseTensor with ${Gve(e)}\n  dense values, but the requested shape requires a multiple of ${Gve(t)}. inputShape=${e} outputShape= ${t}`}function gMe(e,t){return`Input to reshape is a tensor with ${Gve(e)} dense values, but the requested shape has ${Gve(t)}. inputShape=${e} outputShape=${t}`}function yMe(){return"segment ids must be >= 0"}function bMe(){return"segment ids are not increasing"}function vMe(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function xMe(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function wMe(e,t){let n,r=!1;for(e<=TDe?(n=e,r=!0):n=lxe(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=lxe(e,n+1);return n}function kMe(e,t,n){const r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function SMe(e,t,n,r){const a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<a;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function IMe(e){try{return e.map((e=>fIe(e)))}catch(e7e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e7e}`)}}function CMe(e){return e.map((e=>pIe(e)))}!function(){for(const e of oTe)jNe(e)}();const NMe={kernelName:Txe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(e,N$e(ENe(n,"float32"),-1))}}},TMe={kernelName:Exe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=ONe(ENe(n,"float32")),r=FNe(YNe(zNe(1),t));return JAe(DNe(e,r))}}}},EMe={kernelName:Axe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=FNe(YNe(ONe(ENe(n,"float32")),1));return DNe(e,t)}}}},AMe={kernelName:_xe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=tTe(n.shape,r.shape);return{a:()=>{let t=e;const r=eTe(n.shape,a);return r.length>0&&(t=EAe(t,r)),IEe(t,n.shape)},b:()=>{let t=e;const n=eTe(r.shape,a);return n.length>0&&(t=EAe(t,n)),IEe(t,r.shape)}}}},_Me={kernelName:$xe,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},$Me={kernelName:Mxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>PNe(n)}}},RMe={kernelName:Fxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>PNe(n)}}},DMe={kernelName:Oxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>DNe(e,FNe(YNe(zNe(1),ONe(ENe(n,"float32")))))}}},MMe={kernelName:Pxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=FNe($Ne(zNe(1),ONe(ENe(n,"float32"))));return DNe(e,t)}}}},FMe={kernelName:Bxe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=tTe(n.shape,r.shape);return{a:()=>{const t=$Ne(ONe(n),ONe(r));let s=MNe(e,DNe(r,t));const i=eTe(n.shape,a);return i.length>0&&(s=EAe(s,i)),IEe(s,n.shape)},b:()=>{const t=$Ne(ONe(n),ONe(r));let s=JAe(MNe(e,DNe(n,t)));const i=eTe(r.shape,a);return i.length>0&&(s=EAe(s,i)),IEe(s,r.shape)}}}},OMe={kernelName:Lxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>DNe(e,$Ne(ONe(ENe(n,"float32")),1))}}},PMe={kernelName:zxe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>DNe(e,YNe(zNe(1),ONe(ENe(n,"float32"))))}}};const LMe=dCe({avgPool3dGrad_:function(e,t,n,r,a,s){const i=lCe(e,"dy","avgPool3dGrad"),o=lCe(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=IEe(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=IEe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Vve(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),Vve(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),SEe("avgPool3dGrad",a,s);const d={dy:l,input:u},h={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=ZIe.runKernel(jxe,d,h);return c?IEe(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),zMe={kernelName:Uxe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>LMe(e,r,a,s,i,o)}}};const BMe=dCe({avgPoolGrad_:function(e,t,n,r,a){const s=lCe(e,"dy","avgPoolGrad"),i=lCe(t,"input","avgPoolGrad");Vve(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=IEe(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=IEe(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Vve(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),Vve(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},d={filterSize:n,strides:r,pad:a},h=ZIe.runKernel(Vxe,c,d);return u?IEe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),WMe={kernelName:Wxe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>BMe(e,r,a,s,i)}}},VMe={kernelName:Gxe,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>EEe(e,a,!1,!1),b:()=>EEe(e,r,!0,!1)}:s&&!i?{a:()=>EEe(a,e,!1,!0),b:()=>EEe(r,e,!1,!1)}:{a:()=>EEe(a,e,!0,!0),b:()=>EEe(e,r,!0,!0)}:{a:()=>EEe(e,a,!1,!0),b:()=>EEe(r,e,!0,!1)}}},UMe={kernelName:Hxe,gradFunc:(e,t,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>R_e(e,r,a)}}},jMe={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>EAe(e,o,!0)}}},GMe={kernelName:Yxe,gradFunc:e=>({x:()=>e.clone()})},HMe={kernelName:Qxe,gradFunc:e=>({x:()=>PNe(e)})},qMe={kernelName:Jxe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>dAe(r_e(BAe(r,a),qAe(r,s)),e,PNe(e))}}},KMe={kernelName:ewe,inputsToSave:["x"],gradFunc:NMe.gradFunc},XMe={kernelName:twe,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:a}=n,s=Jve(a,t[0].shape)[0],i=r.map((e=>e[s]));return w$e(e,i,s).map((e=>()=>e))}},YMe={kernelName:nwe,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return Vve(vEe(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>YEe(r.shape,e,a,i,o,l),filter:()=>rRe(r,e,a.shape,i,o,l)}}},QMe={kernelName:awe,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>KEe(e,a,s,i,o,1,l),filter:()=>rRe(e,r,a.shape,s,i,o,l)}}};const JMe=dCe({conv3DBackpropFilter_:function(e,t,n,r,a){let s=e;4===e.rank&&(s=IEe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=IEe(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Vve(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),Vve(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),Vve(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Vve(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),Vve(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return ZIe.runKernel(iwe,o,l)}}),ZMe={kernelName:swe,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:s}=n;Vve(vEe(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>ZEe(i.shape,e,o,a,s),filter:()=>JMe(i,e,o.shape,a,s)}}},eFe={kernelName:lwe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(JAe(d$e(ENe(n,"float32"))),e)}}},tFe={kernelName:uwe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(h$e(ENe(n,"float32")),e)}}},nFe={kernelName:dwe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{const t=SAe([a],r.rank);let n=aAe(e,a,s,!i);return null!=t&&(n=K$e(n,t)),n}}}},rFe={kernelName:mwe,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Vve(vEe(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=t;return Vve(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),Vve(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),Vve(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Vve(xEe(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),SEe("depthwiseConv2d",s,i),{x:()=>cRe(l.shape,e,u,a,s,o,i),filter:()=>uRe(l,e,u.shape,a,s,o,i)}}},aFe={kernelName:vwe,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>ZIe.runKernel(xwe,s,n),filter:()=>ZIe.runKernel(wwe,i,n)}}},sFe={kernelName:Cwe,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>ZIe.runKernel(Nwe,r)}}},iFe={kernelName:Twe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=MNe(RAe(JAe(ONe(n))),2/Math.sqrt(Math.PI));return{x:()=>MNe(e,r)}}},oFe={kernelName:Awe,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(e,n)}}},lFe={kernelName:_we,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>IEe(e,n.shape)}}},uFe={kernelName:$we,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(e,RAe(n))}}},cFe={kernelName:Fwe,gradFunc:e=>({x:()=>PNe(e)})},dFe={kernelName:Owe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=tTe(n.shape,r.shape);return{a:()=>{const t=DNe(e,ENe(r,"float32")),s=eTe(n.shape,a);return s.length>0?IEe(EAe(t,s),n.shape):t},b:()=>{let t=MNe(e,ENe(n,"float32"));const s=eTe(r.shape,a);s.length>0&&(t=IEe(EAe(t,s),r.shape));const i=ONe(r);return JAe(DNe(t,ENe(i,"float32")))}}}},hFe={kernelName:Pwe,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?zNe(1):o,u=eTe(s.shape,a.shape),c=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)c.push(a.shape[e]);c.push(1)}const d=YNe(a,s),h=MNe(e,l),p=i$e($Ne(i,zNe(r))),f=MNe(MNe(MNe(p,p),p),zNe(-.5));return{x:()=>1===s.rank?IEe(MNe(MNe(e,FAe(IEe(p,[1,1,1,s.shape[0]]),c)),l),a.shape):IEe(MNe(MNe(e,p),l),a.shape),mean:()=>{let e=MNe(MNe(p,zNe(-1)),h);return 1===s.rank&&(e=EAe(e,u)),IEe(e,s.shape)},variance:()=>{let e=MNe(MNe(f,d),h);return 1===s.rank&&(e=EAe(e,u)),IEe(e,s.shape)},scale:()=>{const t=MNe(d,p);let n=MNe(e,t);return 1===s.rank&&(n=EAe(n,u)),IEe(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=EAe(t,u)),IEe(t,s.shape)}}}},pFe={kernelName:Lwe,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,a]=t,{axis:s,batchDims:i}=n,o=Jve(s,r.shape)[0],l=(e,t,n)=>()=>{const r=e.shape,a=t.size,i=r.slice(0,o),l=i.length,u=r.slice(s,r.length).slice(1),c=u.length,d=fFe(0,l),h=fFe(l+1,l+1+c),p=mFe([i,[a],u]),f=IEe(n,p),m=IEe(t,[a]),g=mFe([[l],d,h]),y=K$e(f,g);let b=W$e(y,m,e.shape[o]);const v=IAe(g);return b=K$e(b,v),b};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>{const t=C$e(n.map(((t,n)=>l(t,a.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)},indices:()=>a}}return{x:l(r,a,e),indices:()=>a}}};function fFe(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function mFe(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const gFe={kernelName:Wwe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>PNe(n),b:()=>PNe(r)}}},yFe={kernelName:Vwe,gradFunc:e=>({x:()=>ENe(e,"float32")})},bFe={kernelName:Gwe,gradFunc:e=>({x:()=>PNe(e)})},vFe={kernelName:Hwe,gradFunc:e=>({x:()=>PNe(e)})},xFe={kernelName:qwe,gradFunc:e=>({x:()=>PNe(e)})},wFe={kernelName:Kwe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:a}=n,s=zAe(r,0);return{x:()=>dAe(s,e,MNe(e,a))}}},kFe={kernelName:Zwe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>DNe(e,$Ne(n,1))}}},SFe={kernelName:Jwe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>DNe(e,ENe(n,"float32"))}}},IFe={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;return{logits:()=>{const t=RAe(r);return YNe(e,MNe(EAe(e,a,!0),t))}}}};const CFe=dCe({localResponseNormalizationBackprop_:function(e,t,n){const r={x:e,y:t,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return ZIe.runKernel(ake,r,a)}}),NFe={kernelName:rke,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>CFe(r,a,e,s,i,o,l)}}};function TFe(e,t,n,r){return t.rank<n.rank&&(t=IEe(t,wAe(t.shape,r))),e.rank<n.rank&&(e=IEe(e,wAe(e.shape,r))),{x:()=>MNe(e,ENe(cAe(n,t),e.dtype))}}const EFe={kernelName:ske,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:a}=r,s=t[0],i=TFe(e,t[1],s,Jve(a,s.shape));return{x:()=>i.x()}}},AFe={kernelName:ike,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>MNe(e,ENe(BAe(n,r),"float32")),b:()=>MNe(e,ENe(HAe(n,r),"float32"))}}};const _Fe=dCe({maxPool3dGrad_:function(e,t,n,r,a,s,i){const o=lCe(e,"dy","maxPool3dGrad"),l=lCe(t,"input","maxPool3dGrad"),u=lCe(n,"output","maxPool3dGrad");let c=o,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=IEe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=IEe(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=IEe(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Vve(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),Vve(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),Vve(5===h.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),SEe("maxPool3dGrad",s,i);const f={dy:c,input:d,output:h},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=ZIe.runKernel(cke,f,m);return p?IEe(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),$Fe={kernelName:uke,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>_Fe(e,r,a,s,i,o,l)}}};const RFe=dCe({maxPoolGrad_:function(e,t,n,r,a,s,i){const o=lCe(e,"dy","maxPoolGrad"),l=lCe(t,"input","maxPoolGrad"),u=lCe(n,"output","maxPoolGrad");Vve(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),Vve(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Vve(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),SEe("maxPoolGrad",s,i);const c={dy:o,input:l,output:u},d={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return ZIe.runKernel(lke,c,d)}}),DFe={kernelName:oke,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>RFe(e,r,a,s,i,o)}}},MFe={kernelName:hke,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n,s=Jve(a,r.shape),i=Gve(xAe(r.shape,s)[1]);return{x:()=>{const t=r.shape.slice();s.forEach((e=>{t[e]=1}));const n=IEe(e,t);return DNe(MNe(n,m_e(r.shape,"float32")),i)}}}},FFe={kernelName:pke,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:a}=r,[s,i]=t,o=TFe(e,i,s,Jve(a,s.shape));return{x:()=>o.x()}}},OFe={kernelName:fke,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>MNe(e,ENe(qAe(n,r),"float32")),b:()=>MNe(e,ENe(zAe(n,r),"float32"))}}},PFe={kernelName:mke,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>_Ee(e,s,r.shape)}}},LFe={kernelName:gke,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=tTe(n.shape,r.shape);return{a:()=>{const t=eTe(n.shape,a);return t.length>0?IEe(EAe(e,t),n.shape):e},b:()=>{const t=MNe(e,JAe(PAe(DNe(n,r)))),s=eTe(r.shape,a);return s.length>0?IEe(EAe(t,s),r.shape):t}}}},zFe={kernelName:bke,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=tTe(n.shape,r.shape);return{a:()=>{const t=MNe(e,ENe(r,"float32")),s=eTe(n.shape,a);return s.length>0?IEe(EAe(t,s),n.shape):t},b:()=>{const t=MNe(e,ENe(n,"float32")),s=eTe(r.shape,a);return s.length>0?IEe(EAe(t,s),r.shape):t}}}},BFe={kernelName:Tke,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>_Ee(e,s,r.shape)}}},WFe={kernelName:Eke,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,a]=t,s=n,i=r,o=tTe(s.shape,i.shape);return{a:()=>{const t=ENe(i,"float32");let n=MNe(e,MNe(t,XNe(s,YNe(t,zNe(1)))));const r=eTe(s.shape,o);return r.length>0&&(n=EAe(n,r)),IEe(n,s.shape)},b:()=>{const t=zAe(s,0),n=dAe(t,YAe(s),PNe(s));let r=MNe(e,MNe(a,n));const l=eTe(i.shape,o);return l.length>0&&(r=EAe(r,l)),IEe(r,i.shape)}}}},VFe={kernelName:Ake,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,a=zAe(n,0);return{x:()=>dAe(a,e,MNe(e,r)),alpha:()=>{let t=dAe(a,PNe(e),MNe(e,n));const s=eTe(r.shape,e.shape);return s.length>0&&(t=EAe(t,s)),IEe(t,r.shape)}}}};function UFe(e,t,n){const r=e.shape.length,a=r-n.length,s=SAe(n,r);let i=e;null!=s&&(i=K$e(e,s));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const a=IEe(t,r),s=rAe(e,n,!0,!1),i=rAe(e,n,!0,!0),o=MNe(s,i);return MNe(a,o)}(i.reshape(o),t,a);if(u=u.reshape(i.shape),null!=s){const e=IAe(s);u=K$e(u,e)}return u}const jFe={kernelName:_ke,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;let s=[];return s=void 0===a||null===a?r.shape.map(((e,t)=>t)):"number"===typeof a?[a]:a,{x:()=>UFe(r,e,s)}}},GFe={kernelName:Swe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=tTe(n.shape,r.shape);return{a:()=>{const t=DNe(e,ENe(r,"float32")),s=eTe(n.shape,a);return s.length>0?IEe(EAe(t,s),n.shape):t},b:()=>{let t=MNe(e,ENe(n,"float32"));const s=eTe(r.shape,a);s.length>0&&(t=IEe(EAe(t,s),r.shape));const i=ONe(r);return JAe(DNe(t,ENe(i,"float32")))}}}},HFe={kernelName:Oke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>DNe(e,JAe(ONe(n)))}}},qFe={kernelName:Uke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=MNe(qAe(n,6),N$e(n));return{x:()=>MNe(e,ENe(r,"float32"))}}},KFe={kernelName:Pke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(e,ENe(N$e(n),"float32"))}}},XFe={kernelName:Lke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>IEe(e,n.shape)}}},YFe={kernelName:Hke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>JAe(DNe(e,MNe(XNe(n,1.5),2)))}}},QFe={kernelName:Qke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=zAe(n,zNe(0)),r=zNe(ODe),a=zNe(PDe),s=MNe(e,a),i=MNe(MNe(e,r),RAe(ENe(n,"float32")));return dAe(t,s,i)}}}},JFe={kernelName:Zke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(tAe(ENe(n,"float32")),e)}}},ZFe={kernelName:eSe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(nAe(ENe(n,"float32")),e)}}},eOe={kernelName:Jke,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=KTe(r,a,s),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>T_e(e,u)}}},tOe={kernelName:rSe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(e,AEe(n))}}},nOe={kernelName:iSe,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>DEe(e,r,a)}}},rOe={kernelName:oSe,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>TEe(e,r)}}},aOe={kernelName:aSe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>DNe(e,MNe(FNe(ENe(n,"float32")),2))}}},sOe={kernelName:mSe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(e,MNe(ENe(n,"float32"),2))}}},iOe={kernelName:fSe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=zNe(2);return{a:()=>MNe(e,MNe(a,YNe(n,r))),b:()=>MNe(e,MNe(a,YNe(r,n)))}}},oOe={kernelName:wSe,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=tTe(n.shape,r.shape);return{a:()=>{let t=e;const r=eTe(n.shape,a);return r.length>0&&(t=EAe(t,r)),IEe(t,n.shape)},b:()=>{let t=e;const n=eTe(r.shape,a);return n.length>0&&(t=EAe(t,n)),IEe(JAe(t),r.shape)}}}},lOe={kernelName:sSe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,a=r.shape.slice(),{axis:s}=n;Jve(s,r.shape).forEach((e=>{a[e]=1}));const i=IEe(e,a),o=MNe(i,m_e(r.shape,"float32"));return{x:()=>o}}},uOe={kernelName:kSe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>DNe(e,ONe(tAe(n)))}}},cOe={kernelName:ISe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:a}=n;return{x:()=>{let t=PNe(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=$Ne(t,_Ee(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=$Ne(t,_Ee(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=$Ne(t,_Ee(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=$Ne(t,_Ee(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},dOe={kernelName:_Se,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=nTe(t,PNe(t)),r=LAe(e,n);let a=BAe(t,zNe(0,"int32"));const s=r.rank-a.rank;for(let o=0;o<s;++o)a=DAe(a,o+1);a=r_e(a,m_e(r.shape,"bool"));const i=PNe(r);return dAe(a,r,i)}(e,n)}}};const hOe=[NMe,TMe,EMe,AMe,_Me,$Me,RMe,DMe,MMe,FMe,OMe,PMe,zMe,WMe,VMe,UMe,jMe,GMe,HMe,qMe,KMe,XMe,QMe,YMe,ZMe,eFe,tFe,nFe,rFe,aFe,GFe,sFe,iFe,oFe,lFe,uFe,dFe,cFe,hFe,pFe,gFe,yFe,bFe,vFe,xFe,wFe,kFe,SFe,IFe,NFe,EFe,EFe,AFe,$Fe,DFe,MFe,FFe,OFe,PFe,LFe,zFe,{kernelName:vke,gradFunc:e=>({x:()=>JAe(e)})},{kernelName:Cke,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>f_e(n.shape,"float32")}}},{kernelName:Ike,gradFunc:e=>({x:()=>PNe(e)})},{kernelName:Nke,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return V$e(e,r).map((e=>()=>e))}},BFe,BFe,WFe,VFe,jFe,HFe,qFe,KFe,XFe,{kernelName:Wke,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>ZIe.runKernel(Vke,a,n)}}},{kernelName:zke,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>ZIe.runKernel(Bke,a,n)}}},{kernelName:jke,gradFunc:(e,t,n)=>{const{dims:r}=n,a=Jve(r,e.shape);return{x:()=>e$e(e,a)}}},{kernelName:Gke,gradFunc:e=>({x:()=>PNe(e)})},YFe,{kernelName:Yke,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>ENe(PNe(n),"float32"),t:()=>MNe(e,ENe(n,e.dtype)),e:()=>MNe(e,ENe(a_e(n),e.dtype))}}},QFe,{kernelName:nSe,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(e,MNe(n,YNe(zNe(1),n)))}}},{kernelName:tSe,gradFunc:e=>({x:()=>PNe(e)})},JFe,ZFe,eOe,{kernelName:lSe,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:a}=n,s=MNe(e,r);return{logits:()=>YNe(s,MNe(EAe(s,[a],true),r))}}},tOe,nOe,nOe,rOe,rOe,aOe,iOe,sOe,{kernelName:RSe,gradFunc:e=>({x:()=>PNe(e)})},oOe,lOe,uOe,{kernelName:SSe,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>MNe(YNe(zNe(1),ONe(n)),e)}}},cOe,{kernelName:TSe,gradFunc:(e,t,n)=>{const r=n,{perm:a}=r,s=IAe(a);return{x:()=>K$e(e,s)}}},{kernelName:ASe,gradFunc:(e,t,n)=>{const r=n,{axis:a}=r;return{value:()=>C$e(e,a)}}},dOe,{kernelName:$Se,gradFunc:e=>({x:()=>PNe(e)})}];for(const n of hOe)HSe(n);DIe().prototype.abs=function(){return this.throwIfDisposed(),JNe(this)},DIe().prototype.acos=function(){return this.throwIfDisposed(),QTe(this)},DIe().prototype.acosh=function(){return this.throwIfDisposed(),JTe(this)},DIe().prototype.add=function(e){return this.throwIfDisposed(),$Ne(this,e)},DIe().prototype.all=function(e,t){return this.throwIfDisposed(),eEe(this,e,t)},DIe().prototype.any=function(e,t){return this.throwIfDisposed(),tEe(this,e,t)},DIe().prototype.argMax=function(e){return this.throwIfDisposed(),nEe(this,e)},DIe().prototype.argMin=function(e){return this.throwIfDisposed(),rEe(this,e)},DIe().prototype.asScalar=function(){return this.throwIfDisposed(),Vve(1===this.size,(()=>"The array must have only 1 element.")),IEe(this,[])},DIe().prototype.asType=function(e){return this.throwIfDisposed(),ENe(this,e)},DIe().prototype.as1D=function(){return this.throwIfDisposed(),IEe(this,[this.size])},DIe().prototype.as2D=function(e,t){return this.throwIfDisposed(),IEe(this,[e,t])},DIe().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),IEe(this,[e,t,n])},DIe().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),IEe(this,[e,t,n,r])},DIe().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),IEe(this,[e,t,n,r,a])},DIe().prototype.asin=function(){return this.throwIfDisposed(),aEe(this)},DIe().prototype.asinh=function(){return this.throwIfDisposed(),sEe(this)},DIe().prototype.atan=function(){return this.throwIfDisposed(),iEe(this)},DIe().prototype.atan2=function(e){return this.throwIfDisposed(),oEe(this,e)},DIe().prototype.atanh=function(){return this.throwIfDisposed(),lEe(this)},DIe().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),CEe(this,e,t,n,r)},DIe().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),DEe(this,e,t)},DIe().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),MEe(this,e,t,n,r,a)},DIe().prototype.broadcastTo=function(e){return this.throwIfDisposed(),WEe(this,e)},DIe().prototype.cast=function(e){return this.throwIfDisposed(),ENe(this,e)},DIe().prototype.ceil=function(){return this.throwIfDisposed(),VEe(this)},DIe().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),UEe(this,e,t)},DIe().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof RIe&&(e=[e]),TEe([this,...e],t)},DIe().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),XEe(this,e,t,n,r,a,s)},DIe().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),QEe(this,e,t,n,r,a)},DIe().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),KEe(this,e,t,n,r,a,s)},DIe().prototype.cos=function(){return this.throwIfDisposed(),tAe(this)},DIe().prototype.cosh=function(){return this.throwIfDisposed(),nAe(this)},DIe().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),rAe(this,e,t,n)},DIe().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),aAe(this,e,t,n)},DIe().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),iAe(this,e,t)},DIe().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),oAe(this,e,t,n,r,a,s)},DIe().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),uAe(this,e,t,n,r,a)},DIe().prototype.divNoNan=function(e){return this.throwIfDisposed(),hAe(this,e)},DIe().prototype.div=function(e){return this.throwIfDisposed(),DNe(this,e)},DIe().prototype.dot=function(e){return this.throwIfDisposed(),pAe(this,e)},DIe().prototype.elu=function(){return this.throwIfDisposed(),mAe(this)},DIe().prototype.equal=function(e){return this.throwIfDisposed(),cAe(this,e)},DIe().prototype.erf=function(){return this.throwIfDisposed(),yAe(this)},DIe().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),$Ae(this,e,t)},DIe().prototype.exp=function(){return this.throwIfDisposed(),RAe(this)},DIe().prototype.expandDims=function(e){return this.throwIfDisposed(),DAe(this,e)},DIe().prototype.expm1=function(){return this.throwIfDisposed(),MAe(this)},DIe().prototype.fft=function(){return this.throwIfDisposed(),b$e(this)},DIe().prototype.flatten=function(){return this.throwIfDisposed(),IEe(this,[this.size])},DIe().prototype.floor=function(){return this.throwIfDisposed(),PAe(this)},DIe().prototype.floorDiv=function(e){return this.throwIfDisposed(),RNe(this,e)},DIe().prototype.gather=function(e,t,n){return this.throwIfDisposed(),LAe(this,e,t,n)},DIe().prototype.greaterEqual=function(e){return this.throwIfDisposed(),BAe(this,e)},DIe().prototype.greater=function(e){return this.throwIfDisposed(),zAe(this,e)},DIe().prototype.ifft=function(){return this.throwIfDisposed(),v$e(this)},DIe().prototype.irfft=function(){return this.throwIfDisposed(),x$e(this)},DIe().prototype.isFinite=function(){return this.throwIfDisposed(),VAe(this)},DIe().prototype.isInf=function(){return this.throwIfDisposed(),UAe(this)},DIe().prototype.isNaN=function(){return this.throwIfDisposed(),jAe(this)},DIe().prototype.leakyRelu=function(e){return this.throwIfDisposed(),GAe(this,e)},DIe().prototype.lessEqual=function(e){return this.throwIfDisposed(),qAe(this,e)},DIe().prototype.less=function(e){return this.throwIfDisposed(),HAe(this,e)},DIe().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),XAe(this,e,t,n,r)},DIe().prototype.logSigmoid=function(){return this.throwIfDisposed(),e_e(this)},DIe().prototype.logSoftmax=function(e){return this.throwIfDisposed(),t_e(this,e)},DIe().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),n_e(this,e,t)},DIe().prototype.log=function(){return this.throwIfDisposed(),YAe(this)},DIe().prototype.log1p=function(){return this.throwIfDisposed(),QAe(this)},DIe().prototype.logicalAnd=function(e){return this.throwIfDisposed(),r_e(this,e)},DIe().prototype.logicalNot=function(){return this.throwIfDisposed(),a_e(this)},DIe().prototype.logicalOr=function(e){return this.throwIfDisposed(),s_e(this,e)},DIe().prototype.logicalXor=function(e){return this.throwIfDisposed(),i_e(this,e)},DIe().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),EEe(this,e,t,n)},DIe().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),c_e(this,e,t,n,r)},DIe().prototype.max=function(e,t){return this.throwIfDisposed(),NAe(this,e,t)},DIe().prototype.maximum=function(e){return this.throwIfDisposed(),nTe(this,e)},DIe().prototype.mean=function(e,t){return this.throwIfDisposed(),p_e(this,e,t)},DIe().prototype.min=function(e,t){return this.throwIfDisposed(),TAe(this,e,t)},DIe().prototype.minimum=function(e){return this.throwIfDisposed(),y_e(this,e)},DIe().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),b_e(this,e,t)},DIe().prototype.mod=function(e){return this.throwIfDisposed(),v_e(this,e)},DIe().prototype.mul=function(e){return this.throwIfDisposed(),MNe(this,e)},DIe().prototype.neg=function(){return this.throwIfDisposed(),JAe(this)},DIe().prototype.norm=function(e,t,n){return this.throwIfDisposed(),_Ae(this,e,t,n)},DIe().prototype.notEqual=function(e){return this.throwIfDisposed(),S_e(this,e)},DIe().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),I_e(this,e,t,n)},DIe().prototype.onesLike=function(){return this.throwIfDisposed(),C_e(this)},DIe().prototype.pad=function(e,t){return this.throwIfDisposed(),T_e(this,e,t)},DIe().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),D_e(this,e,t,n,r,a,s)},DIe().prototype.pow=function(e){return this.throwIfDisposed(),XNe(this,e)},DIe().prototype.prelu=function(e){return this.throwIfDisposed(),M_e(this,e)},DIe().prototype.prod=function(e,t){return this.throwIfDisposed(),F_e(this,e,t)},DIe().prototype.reciprocal=function(){return this.throwIfDisposed(),Q_e(this)},DIe().prototype.relu=function(){return this.throwIfDisposed(),J_e(this)},DIe().prototype.relu6=function(){return this.throwIfDisposed(),Z_e(this)},DIe().prototype.reshapeAs=function(e){return this.throwIfDisposed(),IEe(this,e.shape)},DIe().prototype.reshape=function(e){return this.throwIfDisposed(),IEe(this,e)},DIe().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),LRe(this,e,t,n)},DIe().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),zRe(this,e,t,n)},DIe().prototype.reverse=function(e){return this.throwIfDisposed(),e$e(this,e)},DIe().prototype.rfft=function(){return this.throwIfDisposed(),k$e(this)},DIe().prototype.round=function(){return this.throwIfDisposed(),s$e(this)},DIe().prototype.rsqrt=function(){return this.throwIfDisposed(),i$e(this)},DIe().prototype.selu=function(){return this.throwIfDisposed(),o$e(this)},DIe().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),l$e(this,e,t,n,r,a,s)},DIe().prototype.sigmoid=function(){return this.throwIfDisposed(),AEe(this)},DIe().prototype.sign=function(){return this.throwIfDisposed(),c$e(this)},DIe().prototype.sin=function(){return this.throwIfDisposed(),d$e(this)},DIe().prototype.sinh=function(){return this.throwIfDisposed(),h$e(this)},DIe().prototype.slice=function(e,t){return this.throwIfDisposed(),_Ee(this,e,t)},DIe().prototype.softmax=function(e){return this.throwIfDisposed(),y$e(this,e)},DIe().prototype.softplus=function(){return this.throwIfDisposed(),ZAe(this)},DIe().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),R_e(this,e,t)},DIe().prototype.split=function(e,t){return this.throwIfDisposed(),w$e(this,e,t)},DIe().prototype.sqrt=function(){return this.throwIfDisposed(),FNe(this)},DIe().prototype.square=function(){return this.throwIfDisposed(),ONe(this)},DIe().prototype.squaredDifference=function(e){return this.throwIfDisposed(),S$e(this,e)},DIe().prototype.squeeze=function(e){return this.throwIfDisposed(),I$e(this,e)},DIe().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof RIe?[this,e]:[this,...e];return C$e(n,t)},DIe().prototype.step=function(e){return this.throwIfDisposed(),N$e(this,e)},DIe().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),T$e(this,e,t,n,r,a,s,i,o)},DIe().prototype.sub=function(e){return this.throwIfDisposed(),YNe(this,e)},DIe().prototype.sum=function(e,t){return this.throwIfDisposed(),EAe(this,e,t)},DIe().prototype.tan=function(){return this.throwIfDisposed(),E$e(this)},DIe().prototype.tanh=function(){return this.throwIfDisposed(),$Ee(this)},DIe().prototype.tile=function(e){return this.throwIfDisposed(),FAe(this,e)},DIe().prototype.toBool=function(){return this.throwIfDisposed(),ENe(this,"bool")},DIe().prototype.toFloat=function(){return this.throwIfDisposed(),ENe(this,"float32")},DIe().prototype.toInt=function(){return this.throwIfDisposed(),ENe(this,"int32")},DIe().prototype.topk=function(e,t){return this.throwIfDisposed(),L$e(this,e,t)},DIe().prototype.transpose=function(e){return this.throwIfDisposed(),K$e(this,e)},DIe().prototype.unique=function(e){return this.throwIfDisposed(),B$e(this,e)},DIe().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),W$e(this,e,t)},DIe().prototype.unstack=function(e){return this.throwIfDisposed(),V$e(this,e)},DIe().prototype.where=function(e,t){return this.throwIfDisposed(),dAe(e,this,t)},DIe().prototype.zerosLike=function(){return this.throwIfDisposed(),PNe(this)};class pOe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,pOe.prototype)}}class fOe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,fOe.prototype)}}class mOe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,mOe.prototype)}}class gOe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,gOe.prototype)}}class yOe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,yOe.prototype)}}Error;class bOe{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function vOe(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function xOe(e,t){if(!e)throw new yOe(t)}function wOe(e,t){let n=0;for(const r of e)r===t&&n++;return n}function kOe(e){return 1===e.length?e[0]:e}function SOe(e){return Array.isArray(e)?e:[e]}function IOe(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function COe(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let NOe={};function TOe(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function EOe(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>EOe(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?EOe(t):e[n]=t.value)}}}function AOe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const a=e;let s;if(a in n)s=n[a];else if(a in NOe)s=NOe[a];else if(s=t[a],null==s)throw new mOe(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const s=e;if(null==s.className||null==s.config)throw new mOe(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const i=s.className;let o,l;if(i in n?[o,l]=n[i]:i in NOe?[o,l]=NOe.className:i in t&&([o,l]=t[i]),null==o)throw new mOe(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const n of Object.keys(NOe))e[n]=NOe[n];for(const a of Object.keys(n))e[a]=n[a];s.config.customObjects=e;const t=Object.assign({},NOe);for(const a of Object.keys(n))NOe[a]=n[a];EOe(s.config);const r=l(o,s.config,n,a);return NOe=Object.assign({},t),r}{const e=Object.assign({},NOe);for(const r of Object.keys(n))NOe[r]=n[r];const t=new o(s.config);return NOe=Object.assign({},e),t}}}function _Oe(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function $Oe(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function ROe(e){if(null==e)throw new mOe(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function DOe(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new mOe(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function MOe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return xOe(n>=0),xOe(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function FOe(e,t){Array.isArray(e)?(Vve(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>FOe(e,`element ${n+1} of ${t}`)))):Vve(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${OOe(e)}.`))}function OOe(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>OOe(e))).join(",")+"]":"string"===typeof e?`"${e}"`:`${e}`}function POe(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let LOe=0;function zOe(){return LOe++}const BOe={};function WOe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in BOe||(BOe[e]=0),BOe[e]+=1,e+BOe[e].toString()}const VOe=["channelsFirst","channelsLast"],UOe=["nearest","bilinear"],jOe=["valid","same","causal"],GOe=["max","avg"],HOe=["sum","mul","concat","ave"],qOe=new Map;function KOe(e){DOe(VOe,"DataFormat",e)}function XOe(e){DOe(jOe,"PaddingMode",e)}function YOe(e){DOe(GOe,"PoolMode",e)}const QOe=[],JOe="/";function ZOe(e,t){QOe.push(e);try{const e=t();return QOe.pop(),e}catch(gD){throw QOe.pop(),gD}}function ePe(e){if(!rPe(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===QOe.length?"":QOe.join(JOe)+JOe)+e}function tPe(e){if(!rPe(e))throw new Error("Not a valid tensor name: '"+e+"'");qOe.has(e)||qOe.set(e,0);const t=qOe.get(e);if(qOe.set(e,qOe.get(e)+1),t>0){const n=`${e}_${t}`;return qOe.set(n,1),n}return e}const nPe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function rPe(e){return!!e.match(nPe)}function aPe(e){return e===parseInt(e.toString(),10)}function sPe(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function iPe(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function oPe(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function lPe(e,t){if(t<e)throw new mOe(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let uPe;function cPe(){return null==uPe&&(uPe=ICe().epsilon()),uPe}function dPe(e,t){return ENe(e,t)}function hPe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),IEe(e,n)}function pPe(e,t,n){return vCe((()=>{switch(e.rank){case 1:return p$e(e,t,n);case 2:return f$e(e,[t,0],[n,e.shape[1]]);case 3:return m$e(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return g$e(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return _Ee(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return _Ee(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new mOe(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function fPe(e,t,n){return vCe((()=>{switch(e.rank){case 1:return p$e(e,t,n);case 2:return f$e(e,[0,t],[e.shape[0],n]);case 3:return m$e(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return g$e(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new mOe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function mPe(e,t,n,r){return vCe((()=>{switch(e.rank){case 1:return p$e(e,t,n);case 2:switch(r){case 1:return pPe(e,t,n);case 2:return fPe(e,t,n);default:throw new mOe(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return pPe(e,t,n);case 2:return m$e(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return fPe(e,t,n);default:throw new mOe(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return pPe(e,t,n);case 2:return g$e(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return g$e(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return fPe(e,t,n);default:throw new mOe(`The axis is not within the rank of the tensor ${r}`)}default:throw new mOe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function gPe(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),TEe(e,n)}function yPe(e,t){switch(e.rank){case 1:return jEe([e,t]);case 2:return GEe([e,t],0);case 3:return HEe([e,t],0);case 4:return qEe([e,t],0);default:throw new mOe(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function bPe(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new mOe(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return FAe(e,t)}function vPe(e){return G_e(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function xPe(e,t,n,r){if(e.rank<2||t.rank<2)throw new gOe(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new gOe(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){return hRe({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?SPe(e.rank,r,"channelsLast"):null,activation:n})}{const a=e.shape.slice(),s=a.pop();e=IEe(e,[-1,s]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=IEe(K$e(t,c),[l,-1]);const d=[...a,...u];return IEe(hRe({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?SPe(e.rank,r,"channelsLast"):null,activation:n}),d)}}function wPe(e,t,n){return vCe((()=>(t=Array.isArray(t)?A$e(t,"int32"):ENe(t,"int32"),LAe(e,t,n))))}function kPe(e){return MNe(e,e)}function SPe(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new mOe(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?IEe(t,[1,r[0],1,1,1]):IEe(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?IEe(t,[1,1,1,1,r[0]]):IEe(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?IEe(t,[1,r[0],1,1]):IEe(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?IEe(t,[1,1,1,r[0]]):IEe(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?IEe(t,[1,r[0],1]):IEe(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?IEe(t,[1,1,r[0]]):IEe(t,[1].concat(r))}else if(e<3)return t;throw new mOe(`Unsupported input rank by biasAdd: ${t.rank}`)}function IPe(e,t,n){return vCe((()=>(null==n&&(n="channelsLast"),KOe(n),$Ne(e,SPe(e.rank,t,n)))))}function CPe(e,t,n,r){return vCe((()=>Z$e(e,t,n,r)))}function NPe(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const TPe=["fanIn","fanOut","fanAvg"],EPe=["normal","uniform","truncatedNormal"];class APe extends VNe{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class _Pe extends APe{apply(e,t){return f_e(e,t)}}_Pe.className="Zeros",jNe(_Pe);class $Pe extends APe{apply(e,t){return m_e(e,t)}}$Pe.className="Ones",jNe($Pe);class RPe extends APe{constructor(e){if(super(),"object"!==typeof e)throw new mOe(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new mOe(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return vCe((()=>MNe(zNe(this.value),m_e(e,t))))}getConfig(){return{value:this.value}}}RPe.className="Constant",jNe(RPe);class DPe extends APe{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return q_e(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}DPe.className="RandomUniform",jNe(DPe);class MPe extends APe{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new gOe(`randomNormal does not support dType ${t}.`);return vPe(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}MPe.className="RandomNormal",jNe(MPe);class FPe extends APe{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new gOe(`truncatedNormal does not support dType ${t}.`);return z$e(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}FPe.className="TruncatedNormal",jNe(FPe);class OPe extends APe{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return vCe((()=>{if(2!==e.length||e[0]!==e[1])throw new mOe("Identity matrix initializer can only be used for 2D square matrices.");return MNe(this.gain,OAe(e[0]))}))}getConfig(){return{gain:this.gain}}}OPe.className="Identity",jNe(OPe);class PPe extends APe{constructor(e){if(super(),e.scale<0)throw new mOe(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,DOe(TPe,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){DOe(EPe,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(KOe(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){const r=sPe(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){const r=sPe(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{const r=sPe(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],a=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new gOe(`${this.getClassName()} does not support dType ${t}.`);return z$e(e,0,n,t,this.seed)}{const n=Math.sqrt(3*s);return q_e(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}PPe.className="VarianceScaling",jNe(PPe);class LPe extends PPe{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return PPe.className}}LPe.className="GlorotUniform",jNe(LPe);class zPe extends PPe{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return PPe.className}}zPe.className="GlorotNormal",jNe(zPe);class BPe extends PPe{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return PPe.className}}BPe.className="HeNormal",jNe(BPe);class WPe extends PPe{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return PPe.className}}WPe.className="HeUniform",jNe(WPe);class VPe extends PPe{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return PPe.className}}VPe.className="LeCunNormal",jNe(VPe);class UPe extends PPe{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return PPe.className}}UPe.className="LeCunUniform",jNe(UPe);class jPe extends APe{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return vCe((()=>{if(e.length<2)throw new gOe("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=Gve(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const s=vPe([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=pDe.qr(s,!1);let o=i[0];const l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=MNe(o,l.sign()),n<r&&(o=o.transpose()),MNe(zNe(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}jPe.className="Orthogonal",jNe(jPe);const GPe={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function HPe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return AOe(e,UNe.getMap().classNameMap,t,"initializer")}function qPe(e){return TOe(e)}function KPe(e){if("string"===typeof e){const t=e in GPe?GPe[e]:e;if("GlorotNormal"===t)return new zPe;if("GlorotUniform"===t)return new LPe;if("HeNormal"===t)return new BPe;if("HeUniform"===t)return new WPe;if("LeCunNormal"===t)return new VPe;if("LeCunUniform"===t)return new UPe;{const e={};return e.className=t,e.config={},HPe(e)}}return e instanceof APe?e:HPe(e)}function XPe(e){return Array.isArray(e)&&Array.isArray(e[0])}function YPe(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function QPe(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new mOe(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function JPe(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new mOe(`Expected exactly 1 Shape; got ${e.length}`)}return e}function ZPe(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const eLe="Variable";class tLe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:eLe,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=zOe(),n=null==n?eLe:n,this.originalName=ePe(n),this.name=tPe(this.originalName),this.trainable_=r,this.constraint=a,this.val=j$e(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function nLe(e){return e.map((e=>e.read()))}function rLe(e){e.forEach((e=>{e[0].write(e[1])}))}class aLe{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class sLe{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=zOe(),null!=s&&(this.originalName=ePe(s),this.name=tPe(this.originalName)),this.rank=t.length}}let iLe=0;class oLe{constructor(e,t){this.callArgs=t,this.id=iLe++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let lLe=0;class uLe extends VNe{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=lLe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=IOe(e)+"_"+WOe(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new fOe(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new mOe(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return kOe(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return kOe(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new pOe(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new pOe(`Layer ${this.name} is not connected, no input to return.`);return kOe(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new pOe(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new pOe(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return kOe(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=SOe(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=SOe(this.inputSpec);if(t.length!==n.length)throw new mOe(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const e=t[r],a=n[r];if(null==a)continue;const s=e.rank;if(null!=a.ndim&&s!==a.ndim)throw new mOe(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new mOe(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new mOe(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&e.dtype!==a.dtype)throw new mOe(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${e.dtype}.`);if(a.axes){const t=e.shape;for(const e in a.axes){const n=Number(e),s=a.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=s&&-1===[s,null].indexOf(i))throw new mOe(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){const n=a.shape[t],s=e.shape[t];if(null!=n&&null!=s&&n!==s)throw new mOe(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=SOe(e),r=function(e){let t=!0;for(const n of SOe(e))if(!(n instanceof sLe)){t=!1;break}return t}(e),a=function(e){let t=!0;for(const n of SOe(e))if(n instanceof sLe){t=!1;break}return t}(e);if(r===a)throw new mOe("Arguments to apply() must be all SymbolicTensors or all Tensors");return ZOe(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of SOe(e))t.push(n.shape);this.build(kOe(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const a=SOe(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=kOe(s),null!=this.activityRegularizer)throw new gOe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=SOe(e);const t=[];for(const n of e)t.push(n.shape);return kOe(t)}(e),r=this.computeOutputShape(n);let a;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new sLe(s,n,this,SOe(e),t,this.name,r))):new sLe(s,r,this,SOe(e),t,this.name),this.addInboundNode(e,a,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new gOe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new pOe(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new pOe(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new fOe(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return ZPe(this.weights)}build(e){this.built=!0}getWeights(){return nLe(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){vCe((()=>{const t=this.weights;if(t.length!==e.length)throw new mOe(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=nLe(t);for(let a=0;a<r.length;++a){const s=r[a],i=t[a],o=e[a];if(!Hve(s.shape,o.shape))throw new mOe(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}rLe(n)}))}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new mOe(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():KPe("zeros"));const l=r.apply(t,n),u=new tLe(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=SOe(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),a=SOe(t),s=SOe(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=s[i]}addInboundNode(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const o=SOe(e);t=SOe(t),n=SOe(n),r=SOe(r),a=YPe(a),s=YPe(s);const l=[],u=[],c=[];for(const d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new oLe({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function cLe(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=cLe(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class dLe extends uLe{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:WOe("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new mOe("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new mOe("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new mOe("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new sLe(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new oLe({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new mOe(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}dLe.className="InputLayer",jNe(dLe);class hLe{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof hLe)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new mOe(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return ENe(t,e.dtype)}catch(e7e){throw new mOe(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof sLe){if(null==this.id2Value[e.id])throw new mOe(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new mOe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof sLe){if(null==this.id2Value[e.id])throw new mOe(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new mOe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&xCe(this.id2Mask)}}const pLe=new bOe,fLe=new bOe;function mLe(e,t,n,r){const a=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(const f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let d,h=pLe.get(c);if(null==h){const e=function(e,t){Vve(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const a=yLe(e[0],t);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of e){const{sorted:e,recipientMap:i}=yLe(s,t);for(const t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:gLe(r)}}(i,t);h=e.sorted,d=e.recipientCounts,pLe.put(c,h),fLe.put(c,d)}d={},a||Object.assign(d,fLe.get(c));const p=new hLe(t);for(let f=0;f<h.length;++f){if(null!=r){const e=bCe().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=h[f],s=e.sourceLayer;if(s instanceof dLe)continue;const i=[],u=[],c=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),a||(d[n.name]--,0!==d[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&((n=n||{}).mask=u[0]);const g=SOe(s.apply(i,n));let y=null;s.supportsMasking&&(y=s.computeMask(i,u));const b=bLe(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);const e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}a||xCe(c)}return p.disposeMasks(),s?l:l[0]}function gLe(e){const t={};for(const n in e)t[n]=e[n].size;return t}function yLe(e,t){const n=new Set,r=[],a={};for(const o of t.names())n.add(o);const s=[],i=[];for(s.push(e);s.length>0;){const e=s[s.length-1];if(n.has(e.name)){s.pop();continue}const t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(const t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),n.has(t.name)||s.push(t)}}return{sorted:r,recipientMap:a}}function bLe(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function vLe(e,t){return vCe((()=>FNe(EAe(MNe(e,e),t,!0))))}kxe().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=pLe&&pLe.setMaxEntries(e),null!=fLe&&fLe.setMaxEntries(e)}));class xLe extends VNe{getConfig(){return{}}}class wLe extends xLe{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return vCe((()=>{const t=vLe(e,this.axis),n=UEe(t,0,this.maxValue);return MNe(e,DNe(n,$Ne(cPe(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}wLe.className="MaxNorm",jNe(wLe);class kLe extends xLe{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return vCe((()=>DNe(e,$Ne(cPe(),vLe(e,this.axis)))))}getConfig(){return{axis:this.axis}}}kLe.className="UnitNorm",jNe(kLe);class SLe extends xLe{apply(e){return J_e(e)}}SLe.className="NonNeg",jNe(SLe);class ILe extends xLe{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return vCe((()=>{const t=vLe(e,this.axis),n=$Ne(MNe(this.rate,UEe(t,this.minValue,this.maxValue)),MNe(1-this.rate,t));return MNe(e,DNe(n,$Ne(cPe(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}ILe.className="MinMaxNorm",jNe(ILe);const CLe={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function NLe(e){return TOe(e)}function TLe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return AOe(e,UNe.getMap().classNameMap,t,"constraint")}function ELe(e){if(null==e)return null;if("string"===typeof e){return TLe({className:e in CLe?CLe[e]:e,config:{}})}return e instanceof xLe?e:TLe(e)}async function ALe(e){if(null==e)return;const t=[],n=[],r=[];for(const a in e){const s=e[a];if("number"!==typeof s){const e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){const a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];xCe(r)}}function _Le(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var $Le;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}($Le||($Le={}));class RLe{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class DLe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class MLe extends RLe{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const r in t){const e=t[r];if("number"===typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;const a=vCe((()=>$Ne(this.totals[r],MNe(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:vCe((()=>{const e=MNe(DNe(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),wCe(t[n])})))}}class FLe extends RLe{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const a in this.history){const r=this.history[a];for(let s=0;s<r.length;++s)if("number"!==typeof r[s]){const i=r[s];e.push(i.data()),t.push(a),n.push(s)}}const r=await Promise.all(e);for(let a=0;a<r.length;++a){this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}}}class OLe extends RLe{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||vDe,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");sxe(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():dIe();return function(){const s=null!=n?n():dIe();return s-a<t||(a=s,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await ALe(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await ALe(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await ALe(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await ALe(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await ALe(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):sxe(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await ALe(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await ALe(e),await this.trainEnd(e))}}function PLe(e,t){if(null==e&&(e={}),e instanceof RLe)return[e];if(Array.isArray(e)&&e[0]instanceof RLe)return e;return SOe(e).map((e=>new OLe(e,t)))}class LLe{constructor(){}static registerCallbackConstructor(e,t){Vve(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),LLe.checkForDuplicate(t),null==LLe.constructors[e]&&(LLe.constructors[e]=[]),LLe.constructors[e].push(t)}static checkForDuplicate(e){for(const t in LLe.constructors){LLe.constructors[+t].forEach((t=>{if(t===e)throw new mOe("Duplicate callback constructor.")}))}}static clear(){LLe.constructors={}}static createCallbacks(e){const t=[];for(const n in LLe.constructors){const r=+n;e>=r&&t.push(...LLe.constructors[r])}return t.map((e=>new e))}}function zLe(e,t,n,r,a,s,i,o,l){const u=new FLe,c=[new MLe,...LLe.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const d=new DLe(c);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function BLe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return AOe(e,UNe.getMap().classNameMap,t,"layer",n)}function WLe(e,t){return vCe((()=>{"float32"!==e.dtype&&(e=ENe(e,"float32"));const n=EAe(kPe(e),t,!0),r=qNe(n.shape,cPe()),a=FNe(nTe(n,r));return DNe(e,a)}))}function VLe(e,t){return vCe((()=>p_e(kPe(YNe(t,e)),-1)))}function ULe(e,t){return vCe((()=>p_e(JNe(YNe(t,e)),-1)))}function jLe(e,t){return vCe((()=>{const n=YNe(e,t),r=UEe(JNe(e),cPe(),Number.MAX_VALUE),a=JNe(DNe(n,r));return MNe(100,p_e(a,-1))}))}function GLe(e,t){return vCe((()=>{const n=UEe(t,cPe(),Number.MAX_VALUE),r=YAe($Ne(1,n)),a=UEe(e,cPe(),Number.MAX_VALUE),s=YAe($Ne(1,a));return p_e(kPe(YNe(r,s)),-1)}))}function HLe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return vCe((()=>{if(n)t=y$e(t);else{const e=EAe(t,t.shape.length-1,!0);t=DNe(t,e)}return t=UEe(t,cPe(),1-cPe()),JAe(EAe(MNe(ENe(e,"float32"),YAe(t)),t.shape.length-1))}))}function qLe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return vCe((()=>{const r=ENe(PAe(function(e){const t=[sPe(e.shape)];return IEe(e,t)}(e)),"int32"),a=(t=UEe(t,cPe(),1-cPe())).shape;return HLe(IEe(I_e(r,a[a.length-1]),a),t,n)}))}function KLe(e,t){return vCe((()=>{let n;return n=UEe(t,cPe(),1-cPe()),n=YAe(DNe(n,YNe(1,n))),p_e(function(e,t){if(!Hve(e.shape,t.shape))throw new mOe(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return vCe((()=>{const n=J_e(t),r=JAe(JNe(t));return $Ne(YNe(n,MNe(t,e)),QAe(RAe(r)))}))}(e,n),-1)}))}function XLe(e,t){return vCe((()=>{const n=UEe(e,cPe(),1),r=UEe(t,cPe(),1);return EAe(MNe(e,YAe(DNe(n,r))),-1)}))}function YLe(e,t){return vCe((()=>{const n=WLe(e,-1),r=WLe(t,-1),a=MNe(n,r);return JAe(EAe(a,-1))}))}LLe.constructors={};const QLe={meanSquaredError:VLe,meanAbsoluteError:ULe,meanAbsolutePercentageError:jLe,meanSquaredLogarithmicError:GLe,squaredHinge:function(e,t){return vCe((()=>{const n=nTe(0,YNe(1,MNe(e,t)));return p_e(kPe(n),-1)}))},hinge:function(e,t){return vCe((()=>{const n=nTe(0,YNe(1,MNe(e,t)));return p_e(n,-1)}))},categoricalHinge:function(e,t){return vCe((()=>{const n=EAe(MNe(e,t),-1),r=NAe(MNe(YNe(1,e),t),-1);return nTe(0,$Ne(1,YNe(r,n)))}))},logcosh:function(e,t){return vCe((()=>{const n=Math.log(2),r=YNe(t,e),a=YNe($Ne(r,ZAe(MNe(-2,r))),n);return p_e(a,-1)}))},categoricalCrossentropy:HLe,sparseCategoricalCrossentropy:qLe,binaryCrossentropy:KLe,kullbackLeiblerDivergence:XLe,poisson:function(e,t){return vCe((()=>{const n=YAe($Ne(cPe(),t));return p_e(YNe(t,MNe(e,n)),-1)}))},cosineProximity:YLe};function JLe(e){if("string"===typeof e){if(e in QLe)return QLe[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new mOe(t)}return e}function ZLe(e,t){return vCe((()=>{const n=MNe(.5,C_e(t)),r=dPe(zAe(t,n),e.dtype);return p_e(cAe(e,r),-1)}))}function eze(e,t){return vCe((()=>dPe(cAe(nEe(e,-1),nEe(t,-1)),"float32")))}function tze(e,t){return vCe((()=>ENe(EAe(r_e(cAe(e,1),cAe(t,1))),"float32")))}function nze(e,t){return KLe(e,t)}function rze(e,t){return e.rank===t.rank&&(e=I$e(e,[e.rank-1])),(t=nEe(t,-1)).dtype!==e.dtype&&(t=ENe(t,e.dtype)),ENe(cAe(e,t),"float32")}const aze=HLe,sze=qLe,ize={binaryAccuracy:ZLe,categoricalAccuracy:eze,precision:function(e,t){return vCe((()=>{const n=tze(e,t),r=function(e,t){return vCe((()=>ENe(EAe(r_e(cAe(e,0),cAe(t,1))),"float32")))}(e,t),a=$Ne(n,r);return ENe(dAe(zAe(a,0),DNe(n,a),0),"float32")}))},categoricalCrossentropy:aze,sparseCategoricalCrossentropy:sze,mse:VLe,MSE:VLe,mae:ULe,MAE:ULe,mape:jLe,MAPE:jLe,cosine:YLe};function oze(e){if("string"===typeof e&&e in ize)return ize[e];if("string"!==typeof e&&null!=e)return e;throw new mOe(`Unknown metric ${e}`)}function lze(e){if(xOe(null!==e,`Unknown LossOrMetricFn ${e}`),"string"===typeof e)return e;{let t;for(const n of Object.keys(QLe))if(QLe[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(ize))if(ize[n]===e){t=n;break}return void 0!==t?t:e.name}}const uze=1048576;function cze(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!dze(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>uze&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function dze(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!dze(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!dze(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function hze(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(e){let t=!0;const n=[],r=[];for(const a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(const a of e.layers){let e=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),s=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!a){s.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),pze(s,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)a?fze(o[c],n,r):mze(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;t=null!=e.collectedTrainableWeights?ZPe(e.collectedTrainableWeights):ZPe(e.trainableWeights);return t}(e),u=ZPe(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function pze(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function fze(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e7e){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(e7e){r="multiple"}pze([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function mze(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e7e){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(e7e){a="multiple"}const i=[];for(const c of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let e=0;e<c.inboundLayers.length;++e){const t=c.inboundLayers[e].name,n=c.nodeIndices[e],r=c.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}const o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];pze([`${o} (${l})`,s,a,e.countParams().toString(),u],t,r);for(let c=1;c<i.length;++c)pze(["","","","",i[c]],t,r)}function gze(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function yze(e,t){if(null===e)return null;if("string"===typeof e)return COe(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];gze(t,a,r)?n.push(r):n.push(yze(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"===typeof r)t[n]=r;else{const e=COe(n);t[e]=yze(r,e)}}return t}}function bze(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return IOe(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];gze(t,a,r)?n.push(r):n.push(bze(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],a=IOe(n);t[a]="name"!==n&&"className"!==n||"string"!==typeof r?bze(r,n):r}return t}}const vze="4.20.0";class xze extends uLe{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=WOe(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],$Oe(this.inputs).length!==this.inputs.length)throw new mOe(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);$Oe(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;xOe(0===t,"input layer has >1 nodes"),xOe(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof dLe))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},a={},s={},i=[],o=(e,t,n,r,a,l)=>{null!=r&&null!=a&&null!=l||(r=e.sourceLayer,a=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[a];if(-1!==n.indexOf(u))throw new fOe(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(xze.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let s=0;s<c;s++){const e=u.inputTensors[s],r=u.inboundLayers[s],a=u.nodeIndices[s],i=u.tensorIndices[s];o(e,t,n,r,a,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const y of this.outputs)o(y,l,u);const c=i.slice().reverse();for(const y of c){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const s=null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id];e=Math.max(e,s),r[y.outboundLayer.id]=e,a[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){const a=y.inboundLayers[r],s=y.nodeIndices[r],i=a.inboundNodes[s],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const d={};for(const y in t){const e=t[y];e in d||(d[e]=[]),d[e].push(n[y])}const h={};for(const y in r){const e=r[y];e in h||(h[e]=[]),h[e].push(a[y])}let p=Object.keys(h).map((e=>parseInt(e,10))).sort(_Oe);this.layers=[];for(const y of p){const e=h[y];e.sort(((e,t)=>{const n=s[e.id],r=s[t.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof xze&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=h,p=Object.keys(d).map((e=>parseInt(e,10))).sort(_Oe);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of d[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new fOe(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=d;const g=this.layers.map((e=>e.name));for(const y of g){const e=g.filter((e=>e===y)).length;if(1!==e)throw new fOe(`The name "${y}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new oLe({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new mOe("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const a=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);a&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const s=a?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[s])throw new mOe(`Duplicate weight name: ${s}`);n[s]=t,r++}const s=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])s.push([n[r],e[i]]);else if(t)throw new mOe(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new mOe(`${e.length} of ${r} weights are not set: ${e}`)}rLe(s)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${vze}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=bze(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return vCe((()=>{e=SOe(e);const n=new hLe;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return mLe(this.outputs,n,t)}))}computeMask(e,t){return vCe((()=>{let n;return e=SOe(e),n=null==t?vOe(null,e.length):SOe(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=YPe(e);if(t.length!==this.inputLayers.length)throw new mOe(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(_Oe);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const r=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],a=t.nodeIndices[i],s=t.tensorIndices[i],o=n[`${e.name}_${a}_${s}`];r.push(o)}const a=YPe(e.computeOutputShape(kOe(r))),s=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++){n[`${e.name}_${s}_${t}`]=a[t]}}}const a=[],s=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;s.push(r)}for(let i=0;i<s.length;i++){const e=s[i];xOe(e in n),a.push(n[e])}return kOe(a)}runInternalGraph(e,t){null==t&&(t=vOe(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const r=this.inputs[o],a=e[o],s=t[o];n[r.id]=[a,s]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(_Oe);for(const o of r){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,s=new Array;for(const t of r)t.id in n&&s.push(n[t.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){const[t,n]=s[0];null==u.mask&&(u.mask=n),o=SOe(e.call(t,u)),l=SOe(e.computeMask(t,n)),r=[t],i=[n]}else r=s.map((e=>e[0])),i=s.map((e=>e[1])),null==u.mask&&(u.mask=i),o=SOe(e.call(r,u)),l=SOe(e.computeMask(r,i));if(e.activityRegularizer)throw new gOe("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){const t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}const a=[],s=[],i=[];for(const o of this.outputs){xOe(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];i.push(e.shape),a.push(e),s.push(t)}return[a,s,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof xze?1:0;for(let e=0;e<r.inboundNodes.length;e++){const a=xze.nodeKey(r,e);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new mOe("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new mOe(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new mOe(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return vCe((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=xze.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const e=s.getClassName(),r=s.getConfig(),a=[];for(let n=0;n<s.inboundNodes.length;n++){const e=s.inboundNodes[n],r=xze.nodeKey(s,n);let i={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(e7e){console.warn(`Layer ${s.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const a=e.inboundLayers[r],s=e.nodeIndices[r],o=e.tensorIndices[r];let l=t[xze.nodeKey(a,s)];null==l&&(l=0),n.push([a.name,l,o,i])}a.push(n)}}}const i={};i.name=s.name,i.className=e,i.config=r,i.inboundNodes=a,n.push(i)}e.layers=n;const r=[];for(let s=0;s<this.inputLayers.length;s++){const e=this.inputLayers[s],n=this.inputLayersNodeIndices[s],a=xze.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let i=t[a];null!==i&&void 0!==i||(i=0);const o=this.inputLayersTensorIndices[s];r.push([e.name,i,o])}e.inputLayers=r;const a=[];for(let s=0;s<this.outputLayers.length;s++){const e=this.outputLayers[s],n=this.outputLayersNodeIndices[s],r=xze.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let i=t[r];null!==i&&void 0!==i||(i=0);const o=this.outputLayersTensorIndices[s];a.push([e.name,i,o])}return e.outputLayers=a,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function s(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function i(e,t){const n=[];let a;for(const i of t){const o=i[0],l=i[1],u=i[2];if(a=null==i[3]?{}:i[3],!(o in r))return void s(e,t);const c=r[o];if(c.inboundNodes.length<=l)return void s(e,t);const d=c.inboundNodes[l];n.push(d.outputTensors[u])}n.length>0&&e.apply(kOe(n),a)}function o(e){const a=e.name,i=BLe(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[a]=i;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new mOe(`Corrupted configuration, expected array for nodeData: ${e}`);s(i,e)}))}const l=t.name,u=t.layers;for(const f of u)o(f);for(;!ROe(a);)for(const e of u){const t=r[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)i(t,n)}}const c=[],d=[],h=t.inputLayers;for(const f of h){const e=f[0],t=f[1],n=f[2];xOe(e in r);const a=r[e].inboundNodes[t].outputTensors;c.push(a[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];xOe(e in r);const a=r[e].inboundNodes[t].outputTensors;d.push(a[n])}return new e({inputs:c,outputs:d,name:l})}get stateful(){if(this._stateful)throw new mOe("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){vCe((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function wze(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function kze(e,t){return wze(e,t,"classWeight")}async function Sze(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=vCe((()=>{if(1===e.shape.length)return ANe(e);if(2===e.shape.length){if(e.shape[1]>1){return nEe(e,1)}if(1===e.shape[1])return IEe(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());xCe(t);const a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),A$e(a,"float32")}return null}function Ize(e,t){return MNe(e,t)}function Cze(e,t){let n,r;const a=t;n=a.xs,r=a.ys,Vve(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const s=Nze("input",e.inputNames,n),i=Nze("output",e.outputNames,r),o=s[0].shape[0];Vve(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),Vve(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<s.length;l++)Vve(s[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)Vve(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:i}}function Nze(e,t,n){if(n instanceof RIe)return[n];if(Array.isArray(n))return Vve(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const a of t){if(null==n[a])throw new mOe(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function Tze(e,t,n){const r=null!=n.batchesPerEpoch;if(Vve(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Vve(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Vve(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Vve(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Vve(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const a=null!=n.validationData;let s,i;if(a)if(Eze(n.validationData))Vve(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new gOe("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);s=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=a?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=PLe(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=zLe(c,d,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,a,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const u={};await h.onEpochBegin(f);let c=0,d=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:a}=Cze(e,t.value),s={};s.batch=d,s.size=r[0].shape[0],await h.onBatchBegin(d,s);const i=[];if(null!=n.classWeight){const t=kze(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await Sze(a[e],null,t[e]))}const u=r.concat(a).concat(i),p=o(u);xCe(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];s[t]=n,wCe(n)}await h.onBatchEnd(d,s),_Le(s),d++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(a){let t;t=Eze(n.validationData)?SOe(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):SOe(e.evaluate(s,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,u),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Eze(e){return"function"===typeof e.iterator}function Aze(e){Vve(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function _ze(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>pPe(e,t,n-t))):pPe(e,t,n-t)}function $ze(e,t){return vCe((()=>null==e?null:Array.isArray(e)?e.map((e=>$ze(e,t))):wPe(e,"int32"===t.dtype?t:ENe(t,"int32"))))}function Rze(e,t){const n=[];let r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function Dze(e){const t=[];e instanceof RIe&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(hPe(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Mze(e,t){if(null==e)return;const n=[];if(t instanceof RIe)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const a in t){const e=t[a];n.push(e.id)}const r=[];if(e instanceof RIe)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const a in e){const t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function Fze(e){return Array.isArray(e)}function Oze(e){return!function(e){return e instanceof RIe}(e)&&!Fze(e)}function Pze(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(Fze(e)&&e.length>0)t=!0;else if(Oze(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new mOe(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(Oze(e)){r=[];for(const n of t){if(null==e[n])throw new mOe(`No data provided for "${n}". Need data for each key in: ${t}`);r.push(e[n])}}else if(Fze(e)){if(e.length!==t.length)throw new mOe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);r=e}else{if(t.length>1)throw new mOe(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);r=[e]}if(r=Dze(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new mOe(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!a)continue;const r=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&r!==o)throw new mOe(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return r}function Lze(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new mOe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);r=e}else{if(t.length>1)throw new mOe(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new mOe(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let r=0;r<n[i].length;++r){if(0===r&&!a)continue;const o=e.shape[r],l=n[i][r];if(null!=l&&l!==o)throw new mOe(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class zze extends xze{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new mOe("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");hze(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>yDe.adagrad(.01),Adadelta:()=>yDe.adadelta(1,.95,cPe()),Adam:()=>yDe.adam(.001,.9,.999,cPe()),Adamax:()=>yDe.adamax(.002,.9,.999,cPe(),0),RMSProp:()=>yDe.rmsprop(.001,.9,0,cPe()),SGD:()=>yDe.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new mOe(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof GNe))throw new mOe("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new mOe(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>JLe(e)))}else{const n=JLe(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new mOe(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(JLe(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ZOe("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};ZOe("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,s;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let a;1===t[t.length-1]||this.lossFunctions[e]===KLe?-1!==["accuracy","acc"].indexOf(i)?r=ZLe:-1!==["crossentropy","ce"].indexOf(i)&&(r=nze):this.lossFunctions[e]===qLe?-1!==["accuracy","acc"].indexOf(i)?r=rze:-1!==["crossentropy","ce"].indexOf(i)&&(r=sze):-1!==["accuracy","acc"].indexOf(i)?r=eze:-1!==["crossentropy","ce"].indexOf(i)&&(r=aze),-1!==["accuracy","acc"].indexOf(i)?a="acc":-1!==["crossentropy","ce"].indexOf(i)&&(a="ce"),s=r,n=""+a}else{const e=oze(i);s=e,n=""+lze(i)}let t;ZOe(n,(()=>{t=s})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;Aze(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const e=a[0].concat(a[1]);this.makeTestFunction();const t=this.testFunction;return kOe(this.testLoop(t,e,r,n.verbose,n.steps))}finally{Mze(a[0],e),Mze(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,a=e.testFunction;let s=[];if(n.verbose>0)throw new gOe("Verbose mode is not implemented yet.");Vve(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i="function"===typeof t.next?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await i.next();if(s=vCe((()=>{if(t.value){const{xs:n,ys:r}=Cze(e,t.value),i=n.concat(r),u=vCe((()=>a(i)));if(xCe(i),0===l)for(let e=0;e<u.length;++e)s.push(zNe(0));const c=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=s[e];s[e]=vCe((()=>$Ne(s[e],MNe(c,t)))),l>0&&xCe(n)}xCe(u),o+=c,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){const e=s[u];s[u]=DNe(s[u],o),xCe(e)}return kOe(s)}(this,e,t)}checkNumSamples(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new mOe(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new mOe(`Either the input data should have a defined shape, or ${a} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new mOe("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new hLe;if(e instanceof RIe&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new mOe(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new mOe(`No value is provided for the model's input ${o.name}`);s.add(o,t)}const i=mLe(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){const t=vOe(null,e.length);let n=e.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){const i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new mOe(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return vCe((()=>{const r=this.checkNumSamples(e);if(n)throw new gOe("Verbose predictLoop() is not implemented yet.");const a=Rze(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t){vCe((()=>{const n=a[t][0],r=a[t][1],s=_ze(e,n,r),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});const o=new hLe(i);return mLe(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)))}return kOe(s.map((e=>TEe(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Dze(e);Lze(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return Aze(e),this.predictLoop(n,e)}finally{Mze(n,e)}}predictOnBatch(e){Lze(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new fOe("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const e=this.feedOutputShapes[a];this.feedLossFns[a]===qLe?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){const n=$Oe(e.map((e=>e.shape[0])));n.sort();const r=$Oe(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new mOe(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new mOe(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!Hve(n,r))throw new mOe(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=Pze(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Pze(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){const r=[VLe,KLe,HLe];for(let a=0;a<e.length;++a){const s=e[a],i=t[a],o=n[a];if(null!=i){if(i===HLe&&1===s.shape[s.shape.length-1])throw new mOe(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],a=t[n];if(null!=a&&r!==a)throw new mOe(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new mOe(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=kze(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await Sze(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return vCe((()=>{const s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new gOe("Verbose mode is not implemented yet.");if(null!=a)throw new gOe("steps mode in testLoop() is not implemented yet");{const r=Rze(s,n),a=A$e(lPe(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],o=r[n][1],l=pPe(a,s,o-s),u=$ze(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(zNe(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=$Ne(i[e],MNe(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=DNe(i[e],s)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let a=r;if(wOe(e,r)>1){a+=`_${wOe(e.slice(0,n),r)}`}t.push(a)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new hLe(e),o=mLe(this.outputs,i,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],o[n]);null!=a[n]&&(e=Ize(e,a[n]));const s=p_e(e);t.push(s),l=0===n?e:$Ne(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=p_e(t(r[a],o[a]))}wCe(e),s.push(e)}return l=p_e(l),this.calculateLosses().forEach((e=>{l=$Ne(l,e)})),l}),!0,i)].concat(s)}}makeTestFunction(){this.testFunction=e=>vCe((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});const i=new hLe(s),o=mLe(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],s=p_e(r(a[e],o[e]));n=0===e?s:$Ne(n,s),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=p_e(n(a[r],o[r]));t.push(s)}return t}))}async fit(e,t){let n,r,a,s,i,o,l,u,c,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const h=null==d.batchSize?32:d.batchSize;Aze(h);const p=!1,f=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,p,h);n=f[0],r=f[1],c=f[2];let m,g=!1;if(null!=d.validationData&&d.validationData.length>0){if(g=!0,2!==d.validationData.length)throw 3===d.validationData.length?new gOe("validationData including sample weights is not supported yet."):new mOe(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${d.validationData} is invalid.`);i=d.validationData[0],o=d.validationData[1];const e=!0,t=await this.standardizeUserData(i,o,null,null,e,h);l=t[0],u=t[1],m=l.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];l=_ze(n,e,t),a=n,n=_ze(n,0,e),u=_ze(r,e,t),s=r,r=_ze(r,0,e),m=l.concat(u)}else null!=d.validationSteps&&(g=!0);const y=n.concat(r).concat(c);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let x,w;g?(this.makeTestFunction(),x=this.testFunction,w=v.slice().concat(v.map((e=>"val_"+e)))):(x=null,m=[],w=v.slice());const k=PLe(d.callbacks,d.yieldEvery);return await this.fitLoop(b,y,v,h,d.epochs,d.verbose,k,x,m,d.shuffle,w,d.initialEpoch,null,null)}finally{this.isTraining=!1,Mze(n,e),Mze(r,t),Mze(a,e),Mze(s,t),Mze(l,i),Mze(u,o),null!=c&&xCe(c)}}async fitLoop(e,t,n,r,a,s,i,o,l,u,c,d,h,p){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==h))throw new mOe("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,h,"steps_per_epoch");let g;null!=m&&(g=lPe(0,m)),null==s&&(s=1);const{callbackList:y,history:b}=zLe(i,s,a,d,m,h,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=d;v<a;++v){await y.onEpochBegin(v);const a={};if(null!=h)throw new gOe("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new gOe("batch shuffling is not implemneted yet");u&&Lve(g);const s=A$e(g),i=Rze(m,r);for(let u=0;u<i.length;++u){const c={};if(await y.onBatchBegin(u,c),vCe((()=>{const d=i[u][0],h=i[u][1],p=pPe(s,d,h-d);c.batch=u,c.size=h-d;const m=$ze(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];c[t]=r,wCe(r)}if(u===i.length-1&&f){const e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){const r=n[t],s=e[t];wCe(s),a["val_"+r]=s}}})),await y.onBatchEnd(u,c),_Le(c),this.stopTraining_)break}s.dispose()}if(await y.onEpochEnd(v,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return Tze(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(const o of s){const e=await o.data();i.push(e[0])}return xCe(s),Mze(n[0],e),Mze(n[1],t),kOe(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=bCe().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-bCe().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=IOe(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>IOe(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=IOe(n[r])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[IOe(lze(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>IOe(lze(e))));{const e={};for(const t in this.metrics)e[t]=IOe(lze(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=BLe(yze(e.optimizer_config));let n,r;if("string"===typeof e.loss)n=COe(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>COe(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=COe(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>COe(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=COe(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"===typeof e){const t=HCe(e);if(0===t.length)throw new mOe(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new mOe(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new mOe("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await NCe(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${vze}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:a}=await NCe(await this.optimizer.getWeights(),e);n.specs.push(...a),n.data=OCe([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;cze(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){cze(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}zze.className="Model",jNe(zze);class Bze extends zze{}Bze.className="Functional",jNe(Bze);class Wze extends zze{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:WOe("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new mOe(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Wze||e instanceof zze;let n;if(t){if(n=e,1!==n.outputs.length)throw new mOe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new mOe("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new mOe("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new mOe("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new dLe({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new mOe(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new mOe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=cLe(this.outputs[0])}this.inboundNodes=[],new oLe({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:vOe(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(JPe(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new zze({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new fOe("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new fOe("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new fOe("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new fOe("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new mOe("Legacy serialization format not supported yet.");n=t}else Vve(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,a=t;const s=new e(a);if(!(s instanceof Wze))throw new gOe(`Sequential.fromConfig called on non-Sequential input: ${s}`);for(const i of n){const e=BLe(i,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),s.add(e)}return s}set stopTraining(e){if(null==this.model)throw new mOe("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new mOe("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}Wze.className="Sequential",jNe(Wze);class Vze extends VNe{getConfig(){return{}}}class Uze extends Vze{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new gOe(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return mAe(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}Uze.className="elu",jNe(Uze);class jze extends Vze{apply(e){return o$e(e)}}jze.className="selu",jNe(jze);class Gze extends Vze{apply(e){return J_e(e)}}Gze.className="relu",jNe(Gze);class Hze extends Vze{apply(e){return vCe((()=>y_e(6,J_e(e))))}}Hze.className="relu6",jNe(Hze);class qze extends Vze{apply(e){return e}}qze.className="linear",jNe(qze);class Kze extends Vze{apply(e){return AEe(e)}}Kze.className="sigmoid",jNe(Kze);class Xze extends Vze{apply(e){return function(e){return vCe((()=>{const t=$Ne(.5,MNe(.2,e));return UEe(t,0,1)}))}(e)}}Xze.className="hardSigmoid",jNe(Xze);class Yze extends Vze{apply(e){return ZAe(e)}}Yze.className="softplus",jNe(Yze);class Qze extends Vze{apply(e){return function(e){return vCe((()=>DNe(e,$Ne(JNe(e),1))))}(e)}}Qze.className="softsign",jNe(Qze);class Jze extends Vze{apply(e){return $Ee(e)}}Jze.className="tanh",jNe(Jze);class Zze extends Vze{apply(e){return y$e(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}Zze.className="softmax",jNe(Zze);class eBe extends Vze{apply(e){return t_e(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}eBe.className="logSoftmax",jNe(eBe);class tBe extends Vze{apply(e){return vCe((()=>vCe((()=>{const t=Math.sqrt(2),n=MNe(.5,$Ne(1,yAe(DNe(e,t))));return MNe(e,n)}))))}}tBe.className="gelu",jNe(tBe);class nBe extends Vze{apply(e){return vCe((()=>MNe(.5,MNe(e,$Ne(1,$Ee(MNe(FNe(DNe(2,Math.PI)),$Ne(e,MNe(.044715,XNe(e,3))))))))))}}nBe.className="gelu_new",jNe(nBe);class rBe extends Vze{apply(e){return vCe((()=>MNe(e,$Ee(ZAe(e)))))}}rBe.className="mish",jNe(rBe);class aBe extends Vze{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return vCe((()=>MNe(AEe(MNe(e,t)),e)))}}function sBe(e){return e.getClassName()}function iBe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return AOe(e,UNe.getMap().classNameMap,t,"activation")}function oBe(e){if(null==e){const e={className:"linear",config:{}};return iBe(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},iBe(t)}return e instanceof Vze?e:iBe(e)}function lBe(e){if(null!=e&&"object"!==typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}aBe.className="swish",jNe(aBe);class uBe extends VNe{}class cBe extends uBe{constructor(e){super(),lBe(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return vCe((()=>{let t=f_e([1]);return this.hasL1&&(t=$Ne(t,EAe(MNe(this.l1,JNe(e))))),this.hasL2&&(t=$Ne(t,EAe(MNe(this.l2,kPe(e))))),IEe(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}cBe.className="L1L2",jNe(cBe);const dBe={l1l2:"L1L2"};function hBe(e){return TOe(e)}function pBe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return AOe(e,UNe.getMap().classNameMap,t,"regularizer")}function fBe(e){if(null==e)return null;if("string"===typeof e){return pBe({className:e in dBe?dBe[e]:e,config:{}})}return e instanceof uBe?e:pBe(e)}class mBe extends uLe{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=QPe(e);let n=J_e(e);return null!=this.maxValue&&(n=UEe(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}mBe.className="ReLU",jNe(mBe);class gBe extends uLe{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=QPe(e);return GAe(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}gBe.className="LeakyReLU",jNe(gBe);class yBe extends uLe{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=KPe(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=fBe(e.alphaRegularizer),this.alphaConstraint=ELe(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new mOe(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=JPe(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new aLe({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=QPe(e),M_e(e,this.alpha.read())}getConfig(){const e={alphaInitializer:qPe(this.alphaInitializer),alphaRegularizer:hBe(this.alphaRegularizer),alphaConstraint:NLe(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}yBe.className="PReLU",jNe(yBe);class bBe extends uLe{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new gOe(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=QPe(e);return mAe(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}bBe.className="ELU",jNe(bBe);class vBe extends uLe{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=QPe(e);return MNe(n,ENe(zAe(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}vBe.className="ThresholdedReLU",jNe(vBe);class xBe extends uLe{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Zze).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return vCe((()=>{let n=QPe(e);const r=t.mask;if(null!=r){const e=MNe(YNe(m_e(n.shape),ENe(r,n.dtype)),zNe(-1e9));n=$Ne(n,e)}return this.axis instanceof Array?this.axis.length>1?RAe(YNe(n,n_e(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function wBe(e,t,n){if("number"===typeof e)return vOe(e,t);if(e.length!==t)throw new mOe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const a=e[r];if(!aPe(a))throw new mOe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function kBe(e,t,n,r){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function SBe(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+oPe([n-t,0]);else{if("same"!==r)throw new mOe(`Unsupport padding mode: ${r}.`);e*=t}return e}function IBe(e,t){return vCe((()=>(KOe(t),"channelsFirst"===t?K$e(e,[0,2,3,1]):e)))}function CBe(e,t){return vCe((()=>(KOe(t),"channelsFirst"===t?K$e(e,[0,2,3,4,1]):e)))}function NBe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return vCe((()=>{if(null==s&&(s="channelsLast"),KOe(s),3!==e.shape.length)throw new mOe(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new mOe(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new mOe(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===s&&(e=K$e(e,[0,2,1])),"causal"===a)throw new gOe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=XEe(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=IPe(o,n)),o}))}function TBe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return vCe((()=>{if(null==s&&(s="channelsLast"),KOe(s),3!==e.rank&&4!==e.rank)throw new mOe(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new mOe(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=IBe(e,s);if("causal"===a)throw new gOe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=lRe({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=K$e(l,[0,3,1,2])),l}))}function EBe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return vCe((()=>{if(null==s&&(s="channelsLast"),KOe(s),4!==e.rank&&5!==e.rank)throw new mOe(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new mOe(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=CBe(e,s);if("causal"===a)throw new gOe("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=JEe(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=IPe(o,n)),"channelsFirst"===s&&(o=K$e(o,[0,4,1,2,3])),o}))}xBe.className="Softmax",jNe(xBe);class ABe extends uLe{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",ABe.verifyArgs(t),this.rank=e,FOe(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new gOe(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=wBe(t.kernelSize,e,"kernelSize"),this.strides=wBe(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,XOe(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,KOe(this.dataFormat),this.activation=oBe(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=KPe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ELe(t.biasConstraint),this.biasRegularizer=fBe(t.biasRegularizer),this.activityRegularizer=fBe(t.activityRegularizer),this.dilationRate=wBe(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new mOe(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new mOe(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new mOe(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(xOe("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!MOe(e.kernelSize,"number",1,3))throw new mOe(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:sBe(this.activation),useBias:this.useBias,biasInitializer:qPe(this.biasInitializer),biasRegularizer:hBe(this.biasRegularizer),activityRegularizer:hBe(this.activityRegularizer),biasConstraint:NLe(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class _Be extends ABe{constructor(e,t){super(e,t),this.kernel=null,_Be.verifyArgs(t),this.filters=t.filters,FOe(this.filters,"filters"),this.kernelInitializer=KPe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ELe(t.kernelConstraint),this.kernelRegularizer=fBe(t.kernelRegularizer)}build(e){e=JPe(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new mOe(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return vCe((()=>{let t;e=QPe(e);const n=null==this.bias?null:this.bias.read(),r=POe(this.activation.getClassName());if(null!=r&&2===this.rank)t=TBe(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=NBe(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=TBe(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new gOe("convolutions greater than 3D are not implemented yet.");t=EBe(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=JPe(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){const e=kBe(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:qPe(this.kernelInitializer),kernelRegularizer:hBe(this.kernelRegularizer),kernelConstraint:NLe(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new mOe(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class $Be extends _Be{constructor(e){super(2,e),$Be.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!MOe(e.kernelSize,"number",1,2))throw new mOe(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}$Be.className="Conv2D",jNe($Be);class RBe extends _Be{constructor(e){super(3,e),RBe.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new mOe(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}RBe.className="Conv3D",jNe(RBe);class DBe extends $Be{constructor(e){if(super(e),this.inputSpec=[new aLe({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new mOe(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=JPe(e)).length)throw new mOe("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new mOe("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new aLe({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return vCe((()=>{let t=QPe(e);if(4!==t.shape.length)throw new mOe(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let a,s;"channelsFirst"===this.dataFormat?(a=2,s=3):(a=1,s=2);const i=n[a],o=n[s],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],h=[r,SBe(i,c,l,this.padding),SBe(o,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=K$e(t,[0,2,3,1]));let p=QEe(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=K$e(p,[0,3,1,2])),null!=this.bias&&(p=IPe(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=JPe(e)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=SBe(t[r],o,s,this.padding),t[a]=SBe(t[a],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}DBe.className="Conv2DTranspose",jNe(DBe);class MBe extends RBe{constructor(e){if(super(e),this.inputSpec=[new aLe({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new mOe(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=JPe(e)).length)throw new mOe("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new mOe("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new aLe({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return vCe((()=>{let t=QPe(e);if(5!==t.shape.length)throw new mOe(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let a,s,i;"channelsFirst"===this.dataFormat?(i=2,a=3,s=4):(i=1,a=2,s=3);const o=n[i],l=n[a],u=n[s],c=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,SBe(o,p,c,this.padding),SBe(l,f,d,this.padding),SBe(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=K$e(t,[0,2,3,4,1]));let y=eAe(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=K$e(y,[0,4,1,2,3])),null!==this.bias&&(y=IPe(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){const t=(e=JPe(e)).slice();let n,r,a,s;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=SBe(t[r],u,i,this.padding),t[a]=SBe(t[a],c,o,this.padding),t[s]=SBe(t[s],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}MBe.className="Conv3DTranspose",jNe(MBe);class FBe extends _Be{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new mOe("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new mOe("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new mOe(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=KPe(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=fBe(t.depthwiseRegularizer),this.depthwiseConstraint=ELe(t.depthwiseConstraint),this.pointwiseInitializer=KPe(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=fBe(t.pointwiseRegularizer),this.pointwiseConstraint=ELe(t.pointwiseConstraint)}build(e){if((e=JPe(e)).length<this.rank+2)throw new mOe(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new mOe(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new aLe({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return vCe((()=>{let t;if(e=QPe(e),1===this.rank)throw new gOe("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=K$e(e,[0,2,3,1])),t=l$e(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=IPe(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=K$e(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=qPe(this.depthwiseInitializer),e.pointwiseInitializer=qPe(this.pointwiseInitializer),e.depthwiseRegularizer=hBe(this.depthwiseRegularizer),e.pointwiseRegularizer=hBe(this.pointwiseRegularizer),e.depthwiseConstraint=NLe(this.depthwiseConstraint),e.pointwiseConstraint=NLe(this.pointwiseConstraint),e}}FBe.className="SeparableConv";class OBe extends FBe{constructor(e){super(2,e)}}OBe.className="SeparableConv2D",jNe(OBe);class PBe extends _Be{constructor(e){super(1,e),PBe.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!MOe(e.kernelSize,"number",1,1))throw new mOe(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}PBe.className="Conv1D",jNe(PBe);class LBe extends uLe{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return vCe((()=>{if(e=QPe(e),"channelsLast"===this.dataFormat){const t=mPe(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return mPe(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=mPe(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return mPe(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}LBe.className="Cropping2D",jNe(LBe);class zBe extends uLe{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,KOe(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,DOe(UOe,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return vCe((()=>{let t=QPe(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=K$e(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?hDe.resizeNearestNeighbor(t,[e,r]):hDe.resizeBilinear(t,[e,r]);return K$e(a,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?hDe.resizeNearestNeighbor(t,[e,r]):hDe.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}zBe.className="UpSampling2D",jNe(zBe);class BBe extends ABe{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=KPe(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ELe(e.depthwiseConstraint),this.depthwiseRegularizer=fBe(e.depthwiseRegularizer)}build(e){if((e=JPe(e)).length<4)throw new mOe(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new mOe(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return vCe((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return vCe((()=>{null==a&&(a="channelsLast"),KOe(a);let i=IBe(e,a);if(4!==e.rank)throw new mOe(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new mOe(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=oAe(i,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(i=K$e(i,[0,3,1,2])),i}))}(e=QPe(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=IPe(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=JPe(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=kBe(t,this.kernelSize[0],this.padding,this.strides[0]),s=kBe(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=qPe(this.depthwiseInitializer),e.depthwiseRegularizer=hBe(this.depthwiseRegularizer),e.depthwiseConstraint=NLe(this.depthwiseRegularizer),e}}function WBe(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new mOe("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function VBe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return vCe((()=>{const l=t.shape.length;if(l<3)throw new mOe(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(lPe(2,l));if(t=K$e(t,u),null!=s)throw new gOe("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=ENe(ENe(a,"bool"),"float32"),a.rank===l-1&&(a=DAe(a,-1)),a=K$e(a,u)),r&&(t=e$e(t,0),null!=a&&(a=e$e(a,0)));const c=[];let d,h=n;const p=t.shape[0],f=V$e(t);let m,g;null!=a&&(m=V$e(a));for(let t=0;t<p;++t){const n=f[t],r=vCe((()=>e(n,h)));if(null==a)d=r[0],h=r[1];else{const e=vCe((()=>{const e=m[t],n=YNe(C_e(e),e);return{output:$Ne(MNe(r[0],e),MNe(h[0],n)),newStates:h.map(((t,a)=>$Ne(MNe(r[1][a],e),MNe(t,n))))}}));d=e.output,h=e.newStates}o&&c.push(d)}if(o){g=C$e(c,1)}return[d,g,h]}))}BBe.className="DepthwiseConv2D",jNe(BBe);class UBe extends uLe{constructor(e){let t;if(super(e),null==e.cell)throw new mOe("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new QBe({cells:e.cell}):e.cell,null==t.stateSize)throw new mOe("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new aLe({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return lPe(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){XPe(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return vCe((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new gOe("Constants support is not implemented in RNN yet.");XPe(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new aLe({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Hve(this.stateSpec.map((e=>e.shape[e.shape.length-1])),a))throw new mOe(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map((e=>new aLe({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];vCe((()=>{if(!this.stateful)throw new pOe("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new mOe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>f_e([n,e]))):this.states_=[f_e([n,this.cell.stateSize])];else if(null==e)xCe(this.states_),null!=this.keptStates&&(xCe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>f_e([n,e]))):this.states_[0]=f_e([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new mOe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):xCe(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!Hve(r.shape,s))throw new mOe(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>wCe(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=WBe(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new aLe({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length);if(s[0]instanceof sLe){const n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return vCe((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let a=null==t?null:t.initialState;e=QPe(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new mOe(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=VBe(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return vCe((()=>{let t=f_e(e.shape);return t=EAe(t,[1,2]),t=hPe(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?bPe(t,[1,e]):t)):this.cell.stateSize>1?[bPe(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===UBe.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=BLe(t.cell,n);return new e(Object.assign(t,{cell:r}))}}UBe.className="RNN",jNe(UBe);class jBe extends uLe{}class GBe extends jBe{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,FOe(this.units,"units"),this.activation=oBe(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=KPe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=KPe(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=KPe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fBe(e.kernelRegularizer),this.recurrentRegularizer=fBe(e.recurrentRegularizer),this.biasRegularizer=fBe(e.biasRegularizer),this.kernelConstraint=ELe(e.kernelConstraint),this.recurrentConstraint=ELe(e.recurrentConstraint),this.biasConstraint=ELe(e.biasConstraint),this.dropout=iPe([1,oPe([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=iPe([1,oPe([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=JPe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return vCe((()=>{if(2!==e.length)throw new mOe(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=JBe({ones:()=>C_e(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=JBe({ones:()=>C_e(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=this.recurrentDropoutMask;a=xPe(null!=s?MNe(e,s):e,this.kernel.read()),null!=this.bias&&(a=IPe(a,this.bias.read())),null!=i&&(n=MNe(n,i));let o=$Ne(a,xPe(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:sBe(this.activation),useBias:this.useBias,kernelInitializer:qPe(this.kernelInitializer),recurrentInitializer:qPe(this.recurrentInitializer),biasInitializer:qPe(this.biasInitializer),kernelRegularizer:hBe(this.kernelRegularizer),recurrentRegularizer:hBe(this.recurrentRegularizer),biasRegularizer:hBe(this.biasRegularizer),activityRegularizer:hBe(this.activityRegularizer),kernelConstraint:NLe(this.kernelConstraint),recurrentConstraint:NLe(this.recurrentConstraint),biasConstraint:NLe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}GBe.className="SimpleRNNCell",jNe(GBe);class HBe extends UBe{constructor(e){e.cell=new GBe(e),super(e)}call(e,t){return vCe((()=>{null!=this.cell.dropoutMask&&(xCe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(xCe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}}HBe.className="SimpleRNN",jNe(HBe);class qBe extends jBe{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new mOe("GRUCell does not support reset_after parameter set to true.");this.units=e.units,FOe(this.units,"units"),this.activation=oBe(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=oBe(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=KPe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=KPe(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=KPe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fBe(e.kernelRegularizer),this.recurrentRegularizer=fBe(e.recurrentRegularizer),this.biasRegularizer=fBe(e.biasRegularizer),this.kernelConstraint=ELe(e.kernelConstraint),this.recurrentConstraint=ELe(e.recurrentConstraint),this.biasConstraint=ELe(e.biasConstraint),this.dropout=iPe([1,oPe([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=iPe([1,oPe([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=JPe(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return vCe((()=>{if(2!==e.length)throw new mOe(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=JBe({ones:()=>C_e(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=JBe({ones:()=>C_e(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,s=this.recurrentDropoutMask;let i,o,l;0<this.dropout&&this.dropout<1&&(e=MNe(e,a[0]));let u=xPe(e,this.kernel.read());this.useBias&&(u=IPe(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=MNe(r,s[0]));const c=this.recurrentKernel.read(),[d,h]=w$e(c,[2*this.units,this.units],c.rank-1),p=xPe(r,d),[f,m,g]=w$e(u,3,u.rank-1),[y,b]=w$e(p,2,p.rank-1);i=this.recurrentActivation.apply($Ne(f,y)),o=this.recurrentActivation.apply($Ne(m,b));const v=xPe(MNe(o,r),h);l=this.activation.apply($Ne(g,v));const x=$Ne(MNe(i,r),MNe($Ne(1,JAe(i)),l));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:sBe(this.activation),recurrentActivation:sBe(this.recurrentActivation),useBias:this.useBias,kernelInitializer:qPe(this.kernelInitializer),recurrentInitializer:qPe(this.recurrentInitializer),biasInitializer:qPe(this.biasInitializer),kernelRegularizer:hBe(this.kernelRegularizer),recurrentRegularizer:hBe(this.recurrentRegularizer),biasRegularizer:hBe(this.biasRegularizer),activityRegularizer:hBe(this.activityRegularizer),kernelConstraint:NLe(this.kernelConstraint),recurrentConstraint:NLe(this.recurrentConstraint),biasConstraint:NLe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}qBe.className="GRUCell",jNe(qBe);class KBe extends UBe{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new qBe(e),super(e)}call(e,t){return vCe((()=>{null!=this.cell.dropoutMask&&(xCe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(xCe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}KBe.className="GRU",jNe(KBe);class XBe extends jBe{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,FOe(this.units,"units"),this.activation=oBe(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=oBe(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=KPe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=KPe(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=KPe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=fBe(e.kernelRegularizer),this.recurrentRegularizer=fBe(e.recurrentRegularizer),this.biasRegularizer=fBe(e.biasRegularizer),this.kernelConstraint=ELe(e.kernelConstraint),this.recurrentConstraint=ELe(e.recurrentConstraint),this.biasConstraint=ELe(e.biasConstraint),this.dropout=iPe([1,oPe([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=iPe([1,oPe([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=JPe(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new(t=class extends APe{apply(t,r){const a=e.apply([n]),s=(new $Pe).apply([n]),i=e.apply([2*n]);return yPe(yPe(a,s),i)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return vCe((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new mOe(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=JBe({ones:()=>C_e(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=JBe({ones:()=>C_e(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(e=MNe(e,s[0]));let d=xPe(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=MNe(r,i[0])),d=$Ne(d,xPe(r,this.recurrentKernel.read())),this.useBias&&(d=IPe(d,this.bias.read()));const[h,p,f,m]=w$e(d,4,d.rank-1);o=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=$Ne(MNe(l,a),MNe(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=MNe(c,this.activation.apply(u));return[g,g,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:sBe(this.activation),recurrentActivation:sBe(this.recurrentActivation),useBias:this.useBias,kernelInitializer:qPe(this.kernelInitializer),recurrentInitializer:qPe(this.recurrentInitializer),biasInitializer:qPe(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:hBe(this.kernelRegularizer),recurrentRegularizer:hBe(this.recurrentRegularizer),biasRegularizer:hBe(this.biasRegularizer),activityRegularizer:hBe(this.activityRegularizer),kernelConstraint:NLe(this.kernelConstraint),recurrentConstraint:NLe(this.recurrentConstraint),biasConstraint:NLe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}XBe.className="LSTMCell",jNe(XBe);class YBe extends UBe{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new XBe(e),super(e)}call(e,t){return vCe((()=>{null!=this.cell.dropoutMask&&(xCe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(xCe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}YBe.className="LSTM",jNe(YBe);class QBe extends jBe{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return vCe((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let s;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],s=0===i?[e[0]].concat(n):[s[0]].concat(n),s=o.call(s,t),a.push(s.slice(1))}n=[];for(const e of a.slice().reverse())n.push(...e);return[s[0]].concat(n)}))}build(e){let t;XPe(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{ZOe(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of t.cells)r.push(BLe(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return nLe(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}rLe(t)}}function JBe(e){const{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):CPe(t(),n),o=()=>NPe(i,t,r);if(!a||a<=1)return wCe(o().clone());return Array(a).fill(void 0).map(o).map((e=>wCe(e.clone())))}QBe.className="StackedRNNCells",jNe(QBe);var ZBe=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};class eWe extends UBe{constructor(e){if(e.unroll)throw new gOe("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new gOe("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new aLe({ndim:5})]}call(e,t){return vCe((()=>{if(null!=this.cell.dropoutMask&&(xCe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(xCe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new mOe("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return vCe((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=f_e([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];vCe((()=>{if(!this.stateful)throw new pOe("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new mOe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>f_e(a))):this.states_=[f_e(a)];else if(null==e)xCe(this.states_),null!=this.keptStates&&(xCe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>f_e(a))):this.states_[0]=f_e(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new mOe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):xCe(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=a;if(!Hve(n.shape,r))throw new mOe(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>wCe(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=kBe(l,r[0],a,s[0],i[0]),d=kBe(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}}eWe.className="ConvRNN2D";class tWe extends XBe{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,FOe(this.filters,"filters"),this.kernelSize=wBe(n,2,"kernelSize"),this.kernelSize.forEach((e=>FOe(e,"kernelSize"))),this.strides=wBe(r||1,2,"strides"),this.strides.forEach((e=>FOe(e,"strides"))),this.padding=a||"valid",XOe(this.padding),this.dataFormat=s||"channelsLast",KOe(this.dataFormat),this.dilationRate=wBe(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>FOe(e,"dilationRate")))}build(e){var t;e=JPe(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new mOe(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends APe{apply(e,t){return gPe([n.apply([r]),m_e([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return vCe((()=>{if(3!==e.length)throw new mOe(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],a=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=JBe({ones:()=>C_e(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?MNe(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),d=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=JBe({ones:()=>C_e(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let p=o(a,h,0),f=o(a,h,1),m=o(a,h,2),g=o(a,h,3);const[y,b,v,x]=w$e(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?w$e(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,v,S,this.padding),d=this.inputConv(d,x,I,this.padding);const[C,N,T,E]=w$e(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,C),f=this.recurrentConv(f,N),m=this.recurrentConv(m,T),g=this.recurrentConv(g,E);const A=this.recurrentActivation.apply($Ne(l,p)),_=this.recurrentActivation.apply($Ne(u,f)),$=$Ne(MNe(_,s),MNe(A,this.activation.apply($Ne(c,m)))),R=MNe(this.recurrentActivation.apply($Ne(d,g)),this.activation.apply($));return[R,R,$]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=ZBe(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const a=KEe(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?IPe(a,n,this.dataFormat):a}recurrentConv(e,t){return KEe(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}tWe.className="ConvLSTM2DCell",jNe(tWe);class nWe extends eWe{constructor(e){const t=new tWe(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}nWe.className="ConvLSTM2D",jNe(nWe);class rWe extends uLe{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return vCe((()=>{this.invokeCallHook(e,t);const n=QPe(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return NPe((()=>CPe(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}rWe.className="Dropout",jNe(rWe);class aWe extends rWe{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}aWe.className="SpatialDropout1D",jNe(aWe);class sWe extends uLe{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,FOe(this.units,"units"),this.activation=oBe(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=KPe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=KPe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ELe(e.kernelConstraint),this.biasConstraint=ELe(e.biasConstraint),this.kernelRegularizer=fBe(e.kernelRegularizer),this.biasRegularizer=fBe(e.biasRegularizer),this.activityRegularizer=fBe(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=JPe(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=JPe(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return vCe((()=>{this.invokeCallHook(e,t);const n=QPe(e),r=POe(this.activation.getClassName());let a;return null!=r?a=xPe(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=xPe(n,this.kernel.read()),null!=this.bias&&(a=IPe(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const e={units:this.units,activation:sBe(this.activation),useBias:this.useBias,kernelInitializer:qPe(this.kernelInitializer),biasInitializer:qPe(this.biasInitializer),kernelRegularizer:hBe(this.kernelRegularizer),biasRegularizer:hBe(this.biasRegularizer),activityRegularizer:hBe(this.activityRegularizer),kernelConstraint:NLe(this.kernelConstraint),biasConstraint:NLe(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}sWe.className="Dense",jNe(sWe);class iWe extends uLe{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=JPe(e);for(const t of e.slice(1))if(null==t)throw new mOe(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],sPe(e,1)]}call(e,t){return vCe((()=>{this.invokeCallHook(e,t);let n=QPe(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=K$e(n,e)}return function(e){if(e.rank<=1)throw new mOe(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],sPe(e.shape,1)];return IEe(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}iWe.className="Flatten",jNe(iWe);class oWe extends uLe{constructor(e){super(e),this.supportsMasking=!0,this.activation=oBe(e.activation)}call(e,t){return vCe((()=>{this.invokeCallHook(e,t);const n=QPe(e);return this.activation.apply(n)}))}getConfig(){const e={activation:sBe(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}oWe.className="Activation",jNe(oWe);class lWe extends uLe{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return vCe((()=>function(e,t){return vCe((()=>{if(2!==e.shape.length)throw new mOe(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return bPe(hPe(e,1),[1,t,1])}))}(e=QPe(e),this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}lWe.className="RepeatVector",jNe(lWe);class uWe extends uLe{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let a=1,s=null;for(let o=0;o<r.length;++o){const e=r[o];if(this.isUnknown(e)){if(null!==s)throw new mOe("Can only specifiy one unknown dimension.");s=o}else a*=e}const i=sPe(e);if(null!==s){if(0===a||i%a!==0)throw new mOe(n);r[s]=i/a}else if(i!==a)throw new mOe(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return vCe((()=>{this.invokeCallHook(e,t);const n=QPe(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return IEe(n,a)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}uWe.className="Reshape",jNe(uWe);class cWe extends uLe{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=lPe(1,e.dims.length+1);if(!Hve(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new aLe({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=JPe(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return K$e(QPe(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}cWe.className="Permute",jNe(cWe);class dWe extends uLe{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=QPe(e);return tEe(S_e(n,this.maskValue),-1)}call(e,t){return vCe((()=>{this.invokeCallHook(e,t);const n=QPe(e),r=tEe(S_e(n,this.maskValue),-1,!0);return MNe(n,ENe(r,n.dtype))}))}}dWe.className="Masking",jNe(dWe);class hWe extends uLe{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(SOe(e.inputLength))}this.inputDim=e.inputDim,FOe(this.inputDim,"inputDim"),this.outputDim=e.outputDim,FOe(this.outputDim,"outputDim"),this.embeddingsInitializer=KPe(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=fBe(e.embeddingsRegularizer),this.activityRegularizer=fBe(e.activityRegularizer),this.embeddingsConstraint=ELe(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return vCe((()=>this.maskZero?(e=QPe(e),S_e(e,PNe(e))):null))}computeOutputShape(e){if(e=JPe(e),null==this.inputLength)return[...e,this.outputDim];const t=SOe(this.inputLength);if(t.length!==e.length-1)throw new mOe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new mOe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return vCe((()=>{this.invokeCallHook(e,t);let n=QPe(e);"int32"!==n.dtype&&(n=dPe(n,"int32"));const r=wPe(this.embeddings.read(),IEe(n,[n.size]));return IEe(r,JPe(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:qPe(this.embeddingsInitializer),embeddingsRegularizer:hBe(this.embeddingsRegularizer),activityRegularizer:hBe(this.activityRegularizer),embeddingsConstraint:NLe(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}hWe.className="Embedding",jNe(hWe);class pWe extends uLe{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new gOe}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new mOe("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[JPe(e)]),e.length<2)throw new mOe(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=$Oe(t),t.length>1)throw new mOe(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===$Oe(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return vCe((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=oPe(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=hPe(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const s of e){const e=s.rank;if(null==e){const e=s.shape,r=e[0],a=e.slice(1).concat([r]);let i=IEe(s,[r].concat(sPe(e.slice(1))));i=K$e(i,[1,0]),i=IEe(i,a),t.push(i),n=!0}else if(e>1){const r=lPe(1,e).concat([0]);t.push(K$e(s,r)),n=!0}else t.push(s)}let r=this.mergeFunction(t);const a=r.rank;if(n)if(null==a){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=IEe(K$e(IEe(r,[-1,t]),[1,0]),n)}else if(a>1){const e=[a-1].concat(lPe(0,a-1));r=K$e(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=$Oe(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return vCe((()=>{if(null==t)return null;if(!Array.isArray(t))throw new mOe("`mask` should be an Array");if(!Array.isArray(e))throw new mOe("`inputs` should be an Array");if(t.length!==e.length)throw new mOe(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:DAe(e,0))))[0];for(let e=1;e<t.length-1;++e)n=r_e(n,t[e]);return n}))}}class fWe extends pWe{constructor(e){super(e)}mergeFunction(e){return vCe((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=$Ne(t,e[n]);return t}))}}fWe.className="Add",jNe(fWe);class mWe extends pWe{constructor(e){super(e)}mergeFunction(e){return vCe((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=MNe(t,e[n]);return t}))}}mWe.className="Multiply",jNe(mWe);class gWe extends pWe{constructor(e){super(e)}mergeFunction(e){return vCe((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=$Ne(t,e[n]);return MNe(1/e.length,t)}))}}gWe.className="Average",jNe(gWe);class yWe extends pWe{constructor(e){super(e)}mergeFunction(e){return vCe((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=nTe(t,e[n]);return t}))}}yWe.className="Maximum",jNe(yWe);class bWe extends pWe{constructor(e){super(e)}mergeFunction(e){return vCe((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=y_e(t,e[n]);return t}))}}bWe.className="Minimum",jNe(bWe);class vWe extends pWe{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new mOe("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let a=!1;for(const e of n)if(Hve(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new mOe("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return vCe((()=>gPe(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new mOe("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new mOe("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new mOe("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new mOe(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return vCe((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let s=0;s<e.length;++s)null==t[s]?r.push(ENe(C_e(e[s]),"bool")):t[s].rank<e[s].rank?r.push(DAe(t[s],-1)):r.push(t[s]);const a=TEe(r,this.axis);return eEe(a,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function xWe(e,t){for(;e<0;)e+=t;return e}vWe.className="Concatenate",jNe(vWe);class wWe extends pWe{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Vve(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new gOe("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new mOe(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new mOe(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>xWe(t,e[n].shape.length))):[xWe(this.axes,n.shape.length),xWe(this.axes,r.shape.length)],this.normalize&&(n=WLe(n,t[0]),r=WLe(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new gOe("batchDot is not implemented for tensors of 4D or higher rank yet");if(Vve(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),Vve(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new gOe("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);const s=n;return vCe((()=>{let n,i;if(r>a){n=r-a;const e=[];for(let t=0;t<n;++t)e.push(1);t=IEe(t,t.shape.concat(e))}else if(a>r){n=a-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=IEe(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?EAe(MNe(e,t),s[0]):EAe(MNe(K$e(e,[1,0]),t),s[1]);else{const n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;i=EEe(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=I$e(i,t)}return 1===i.shape.length&&(i=DAe(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[xWe(this.axes,e.length),xWe(this.axes,t.length)],n}computeOutputShape(e){Vve(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new gOe("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}wWe.className="Dot",jNe(wWe);class kWe extends uLe{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return vCe((()=>{this.invokeCallHook(e,t);const n=QPe(e);return NPe((()=>$Ne(vPe(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}kWe.className="GaussianNoise",jNe(kWe);class SWe extends uLe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return vCe((()=>{this.invokeCallHook(e,t);const n=QPe(e);if(this.rate>0&&this.rate<1){return NPe((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return MNe(n,vPe(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}SWe.className="GaussianDropout",jNe(SWe);class IWe extends uLe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||QPe(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return vCe((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=QPe(e),r=-1.7580993408473766;let a=BAe(q_e(n),this.rate);a=dPe(a,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-s*r*this.rate,o=$Ne(MNe(t,a),MNe($Ne(a,-1),r));return $Ne(MNe(o,s),i)};return NPe(r,(()=>QPe(e)),t.training||!1)}return e}))}}function CWe(e,t,n,r,a){let s,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)s=FEe(e,t,n,r,a,i);else if(3===e.rank)s=OEe(e,t,n,r,a,i);else{if(4!==e.rank)throw new gOe(`batchNormalization is not implemented for array of rank ${e.rank} yet`);s=PEe(e,t,n,r,a,i)}return s}function NWe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Hve(r.slice().sort(),lPe(0,e.rank-1))?function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return vCe((()=>{const s=x_e(e,r),i=s.mean,o=s.variance;return[CWe(e,i,o,n,t,a),i,o]}))}(e,t,n,r,a):function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return vCe((()=>{const s=x_e(e,r),i=s.mean,o=s.variance,l=[];for(const t of lPe(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=IEe(i,l),c=IEe(o,l),d=null==t?null:IEe(t,l),h=null==n?null:IEe(n,l);return[CWe(e,u,c,h,d,a),i,o]}))}(e,t,n,r,a)}IWe.className="AlphaDropout",jNe(IWe);class TWe extends uLe{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=KPe(e.betaInitializer||"zeros"),this.gammaInitializer=KPe(e.gammaInitializer||"ones"),this.movingMeanInitializer=KPe(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=KPe(e.movingVarianceInitializer||"ones"),this.betaConstraint=ELe(e.betaConstraint),this.gammaConstraint=ELe(e.gammaConstraint),this.betaRegularizer=fBe(e.betaRegularizer),this.gammaRegularizer=fBe(e.gammaRegularizer)}build(e){e=JPe(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new mOe(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new aLe({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return vCe((()=>{const n=null!=t.training&&t.training,r=QPe(e),a=r.shape,s=a.length,i=lPe(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);const l=vOe(1,s);l[o]=a[o];const u=i.slice();u.sort();const c=!Hve(u,lPe(0,s).slice(0,s-1));if(!n)return(()=>{if(c){const e=IEe(this.movingMean.read(),l),t=IEe(this.movingVariance.read(),l),n=this.center?IEe(this.beta.read(),l):null,a=this.scale?IEe(this.gamma.read(),l):null;return CWe(r,e,t,n,a,this.epsilon)}return CWe(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,h,p]=NWe(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{vCe((()=>{const r=1-n,a=e.read(),s=MNe(YNe(a,t),r);e.write(YNe(a,s))}))};return(()=>{f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:qPe(this.betaInitializer),gammaInitializer:qPe(this.gammaInitializer),movingMeanInitializer:qPe(this.movingMeanInitializer),movingVarianceInitializer:qPe(this.movingVarianceInitializer),betaRegularizer:hBe(this.betaRegularizer),gammaRegularizer:hBe(this.gammaRegularizer),betaConstraint:NLe(this.betaConstraint),gammaConstraint:NLe(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}TWe.className="BatchNormalization",jNe(TWe);class EWe extends uLe{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=KPe(e.betaInitializer||"zeros"),this.gammaInitializer=KPe(e.gammaInitializer||"ones"),this.betaRegularizer=fBe(e.betaRegularizer),this.gammaRegularizer=fBe(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=JPe(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==$Oe(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=QPe(e),r=n.shape,a=r.length;return vCe((()=>{let{mean:e,variance:t}=x_e(n,this.axis,!0);const s=vOe(1,a);for(const n of this.axis)s[n]=r[n];const i=e=>null!=e&&e.shape.length!==a?IEe(e,s):e;let o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null;const u=[],c=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=FAe(e,u),t=FAe(t,u),null!=o&&(o=FAe(o,c)),null!=l&&(l=FAe(l,c)),CWe(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:qPe(this.betaInitializer),gammaInitializer:qPe(this.gammaInitializer),betaRegularizer:hBe(this.betaRegularizer),gammaRegularizer:hBe(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}EWe.className="LayerNormalization",jNe(EWe);class AWe extends uLe{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new mOe(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new mOe(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new mOe(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new aLe({ndim:4})]}computeOutputShape(e){let t,n;return e=JPe(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return vCe((()=>function(e,t,n){return vCe((()=>{if(4!==e.rank)throw new mOe(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new mOe("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new mOe(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],T_e(e,r)}))}(QPe(e),this.padding,this.dataFormat)))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function _We(e,t,n,r,a,s){return vCe((()=>{let i;KOe(a),YOe(s),XOe(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=IBe(e,a);const o="same"===r?"same":"valid";return i="max"===s?c_e(e,t,n,o):CEe(e,t,n,o),"channelsFirst"===a&&(i=K$e(i,[0,3,1,2])),i}))}function $We(e,t,n,r,a,s){return vCe((()=>{let i;KOe(a),YOe(s),XOe(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=CBe(e,a);const o="same"===r?"same":"valid";return i="max"===s?d_e(e,t,n,o):NEe(e,t,n,o),"channelsFirst"===a&&(i=K$e(i,[0,4,1,2,3])),i}))}AWe.className="ZeroPadding2D",jNe(AWe);class RWe extends uLe{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new mOe(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(FOe(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new mOe(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}FOe(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,XOe(this.padding),this.inputSpec=[new aLe({ndim:3})]}computeOutputShape(e){const t=kBe((e=JPe(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return vCe((()=>{this.invokeCallHook(e,t),e=hPe(QPe(e),2);const n=this.poolingFunction(QPe(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return I$e(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class DWe extends RWe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KOe(a),XOe(r),_We(e,t,n,r,a,"max")}}DWe.className="MaxPooling1D",jNe(DWe);class MWe extends RWe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KOe(a),XOe(r),_We(e,t,n,r,a,"avg")}}MWe.className="AveragePooling1D",jNe(MWe);class FWe extends uLe{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new mOe(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];FOe(this.poolSize,"poolSize"),FOe(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,KOe(this.dataFormat),XOe(this.padding),this.inputSpec=[new aLe({ndim:4})]}computeOutputShape(e){e=JPe(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=kBe(t,this.poolSize[0],this.padding,this.strides[0]),n=kBe(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return vCe((()=>(this.invokeCallHook(e,t),this.poolingFunction(QPe(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class OWe extends FWe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KOe(a),XOe(r),_We(e,t,n,r,a,"max")}}OWe.className="MaxPooling2D",jNe(OWe);class PWe extends FWe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KOe(a),XOe(r),_We(e,t,n,r,a,"avg")}}PWe.className="AveragePooling2D",jNe(PWe);class LWe extends uLe{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new mOe(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];FOe(this.poolSize,"poolSize"),FOe(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,KOe(this.dataFormat),XOe(this.padding),this.inputSpec=[new aLe({ndim:5})]}computeOutputShape(e){e=JPe(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=kBe(t,this.poolSize[0],this.padding,this.strides[0]),n=kBe(n,this.poolSize[1],this.padding,this.strides[1]),r=kBe(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return vCe((()=>(this.invokeCallHook(e,t),this.poolingFunction(QPe(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class zWe extends LWe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KOe(a),XOe(r),$We(e,t,n,r,a,"max")}}zWe.className="MaxPooling3D",jNe(zWe);class BWe extends LWe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return KOe(a),XOe(r),$We(e,t,n,r,a,"avg")}}BWe.className="AveragePooling3D",jNe(BWe);class WWe extends uLe{constructor(e){super(e),this.inputSpec=[new aLe({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new gOe}}class VWe extends WWe{constructor(e){super(e||{})}call(e,t){return vCe((()=>{const t=QPe(e);return p_e(t,1)}))}}VWe.className="GlobalAveragePooling1D",jNe(VWe);class UWe extends WWe{constructor(e){super(e||{})}call(e,t){return vCe((()=>{const t=QPe(e);return NAe(t,1)}))}}UWe.className="GlobalMaxPooling1D",jNe(UWe);class jWe extends uLe{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,KOe(this.dataFormat),this.inputSpec=[new aLe({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new gOe}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class GWe extends jWe{call(e,t){return vCe((()=>{const t=QPe(e);return"channelsLast"===this.dataFormat?p_e(t,[1,2]):p_e(t,[2,3])}))}}GWe.className="GlobalAveragePooling2D",jNe(GWe);class HWe extends jWe{call(e,t){return vCe((()=>{const t=QPe(e);return"channelsLast"===this.dataFormat?NAe(t,[1,2]):NAe(t,[2,3])}))}}HWe.className="GlobalMaxPooling2D",jNe(HWe);class qWe extends uLe{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=BLe(t.layer,n);delete t.layer;const a={layer:r};return Object.assign(a,t),new e(a)}}class KWe extends qWe{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=JPe(e)).length<3)throw new mOe(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=JPe(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return vCe((()=>VBe(((e,n)=>[QPe(this.layer.call(e,t)),[]]),e=QPe(e),[],!1,null,null,!1,!0)[1]))}}KWe.className="TimeDistributed",jNe(KWe);class XWe extends qWe{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=BLe(n),t.goBackwards=!0!==t.goBackwards;const r={};var a;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=BLe(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,a=this.mergeMode,DOe(HOe,"BidirectionalMergeMode",a),e.weights)throw new gOe("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),t=a[0]):t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):kOe(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=WBe(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const s=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new mOe("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);const r=n.map((e=>new aLe({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new gOe("Support for constants in Bidirectional layers is not implemented yet.");const o=s[0]instanceof sLe;for(const l of s)if(l instanceof sLe!==o)throw new mOe("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return vCe((()=>{const n=t.initialState;let r,a,s,i;if(null==n)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{const s=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:s})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=e$e(a,1)),"concat"===this.mergeMode?i=gPe([r,a]):"sum"===this.mergeMode?i=$Ne(r,a):"ave"===this.mergeMode?i=MNe(.5,$Ne(r,a)):"mul"===this.mergeMode?i=MNe(r,a):null==this.mergeMode&&(i=[r,a]),this.returnState?null==this.mergeMode?i.concat(s):[i].concat(s):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ZOe(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),ZOe(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=BLe(t.layer);if(delete t.layer,null!=t.numConstants)throw new gOe("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}XWe.className="Bidirectional",jNe(XWe);class YWe extends uLe{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return vCe((()=>("float32"!==(e=QPe(e)).dtype&&(e=dPe(e,"float32")),$Ne(MNe(e,this.scale),this.offset))))}}YWe.className="Rescaling",jNe(YWe);const{resizeBilinear:QWe,cropAndResize:JWe}=hDe;class ZWe extends uLe{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return vCe((()=>{let l,u=!1;const c=[t/s,n/i,(r+t)/s,(a+n)/i],d=[];3===e.rank?(u=!0,l=C$e([e])):l=e;for(let e=0;e<l.shape[0];e++)d.push(c);const h=fCe(d,[d.length,4]),p=X_e(0,d.length,1,"int32"),f=JWe(l,h,p,[r,a],"nearest");return dPe(u?QPe(V$e(f)):f,o)}))}upsize(e,t,n,r){return vCe((()=>dPe(QWe(e,[t,n]),r)))}call(e,t){return vCe((()=>{const t=QPe(e),n=t.dtype,r=t.shape,a=r[r.length-3],s=r[r.length-2];let i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let o=0;return s!==this.width&&(o=Math.floor((s-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,a,s,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=JPe(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}ZWe.className="CenterCrop",jNe(ZWe);class eVe extends uLe{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=JPe(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return vCe((()=>{let n;if("int32"!==(e=QPe(e)).dtype&&(e=dPe(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new mOe(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=QPe(t.countWeights)}const r=NAe(e),a=TAe(e),s=zAe(this.numTokens,r).bufferSync().get(0),i=BAe(a,0).bufferSync().get(0);if(!s||!i)throw new mOe(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let a=QPe(e);if("int32"!==a.dtype&&(a=dPe(a,"int32")),"int"===t)return a;const s=a.shape;if(0===a.rank&&(a=DAe(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=DAe(a,-1)),a.rank>2)throw new mOe(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);const i=["multiHot","oneHot"].includes(t),o=a;let l;if(l=sAe(o,"undefined"!==typeof r&&"count"===t?r:[],n,i),"tfIdf"!==t)return l;if(r)return MNe(l,r);throw new mOe("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}eVe.className="CategoryEncoding",jNe(eVe);const tVe=new Set(["bilinear","nearest"]);class nVe extends uLe{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!tVe.has(e.interpolation))throw new mOe(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=JPe(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return vCe((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return hDe.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return hDe.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...tVe]} are supported`)}))}}nVe.className="Resizing",jNe(nVe);class rVe{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}rVe.className="RandomSeed";class aVe extends uLe{constructor(e){super(e),this.randomGenerator=new rVe(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}aVe.className="BaseRandomLayer";const sVe=new Set(["bilinear","nearest"]);class iVe extends aVe{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new mOe(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new mOe(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new mOe(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!sVe.has(n))throw new mOe(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=JPe(e))[2];return[this.imgHeight,-1,t]}call(e,t){return vCe((()=>{const t=QPe(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=q_e([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return hDe.resizeBilinear(e,a);case"nearest":return hDe.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...sVe]} are supported`)}}))}}iVe.className="RandomWidth",jNe(iVe);var oVe,lVe;kxe().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(oVe||(oVe={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(lVe||(lVe={}));const uVe={};function cVe(e){return uVe[e]}function dVe(e,t,n,r,a){const s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){const e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return hVe(t.inputNames[o],n,r,a);if("tensors"===s.type){const s=t.inputs.slice(e,i),o=t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=s[t])||void 0===n?void 0:n.op)}));return o.map((e=>hVe(e,n,r,a)))}const l=hVe(t.inputNames[o],n,r,a),u=l.dataSync();return"number"===s.type?u[0]:dxe(l.shape,u)}const i=t.attrParams[e];return i&&i.value}function hVe(e,t,n,r){const[a,s]=gVe(e,n);if(null!=r){const e=r.getHashTableHandleByName(a);if(null!=e)return e}const i=n.currentContextIds.find((e=>!!t[mVe(a,e)]));return void 0!==i?t[mVe(a,i)][s]:void 0}function pVe(e,t,n){return t[mVe(e,n.currentContextId)]}function fVe(e,t){const[n,r,a]=gVe(e,t);return[mVe(n,t&&t.currentContextId),r,a]}function mVe(e,t){return t?`${e}-${t}`:e}function gVe(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let a;if(1===r.length)a=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;a=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,a),a}function yVe(e,t,n){let r=dVe("pad",e,t,n);if("explicit"===r){r=dVe("explicitPaddings",e,t,n);const a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function bVe(e){return e.kept?e:ANe(e)}const vVe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],xVe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],wVe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],kVe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],SVe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],IVe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],CVe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],NVe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],TVe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],EVe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],AVe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],_Ve=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],$Ve=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],RVe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],DVe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],MVe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],FVe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],OVe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],PVe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class LVe{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[i,o,l,u,c,d,h,p,f,m,g,y,b,v,x,w,k,S,I].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,r=[],a=[],s=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e)),{});let o=[];const l=[];let u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(i);d.forEach((e=>{const t=i[e];t.inputNames.forEach(((e,n)=>{const[r,,a]=fVe(e),s=i[r];if(null!=s.outputs){const e=s.outputs.indexOf(a);if(-1!==e){const a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{const t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{const[t]=fVe(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{const[t]=fVe(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:h};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=cVe(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let a;switch(n.type){case"string":a=BVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=BVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":a=YVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=YVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":a=VVe(e.attr,n.tfName,n.defaultValue||0),void 0===a&&n.tfDeprecatedName&&(a=VVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":a=XVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=XVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":a=WVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=WVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":a=JVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=JVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":a=KVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=KVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":a=QVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=QVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":a=GVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=GVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":a=HVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=HVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":a=jVe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=jVe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:a,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const a=[],s=[];e.signature.inputArg.forEach((e=>{const[t]=fVe(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:UVe(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,a.push(n),r[t]=n}));Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[a,,s]=fVe(e),i=r[a];if(null!=i.outputs){const e=i.outputs.indexOf(s);if(-1!==e){const r=`${a}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));const i=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=fVe(i[e.name]),a=r[t];null!=a&&(a.defaultOutput=n,s.push(a))}));const o=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:s,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function zVe(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=kxe().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function BVe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e[t];return null!=a?zVe(a.s,r):n}function WVe(e,t,n){const r=e[t];return r?r.b:n}function VVe(e,t,n){const r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"===typeof a?a:parseInt(a,10)}function UVe(e){switch("string"===typeof e&&(e=oVe[e]),e){case oVe.DT_FLOAT:case oVe.DT_HALF:return"float32";case oVe.DT_INT32:case oVe.DT_INT64:case oVe.DT_INT8:case oVe.DT_UINT8:return"int32";case oVe.DT_BOOL:return"bool";case oVe.DT_DOUBLE:return"float32";case oVe.DT_STRING:return"string";case oVe.DT_COMPLEX64:case oVe.DT_COMPLEX128:return"complex64";default:return null}}function jVe(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function GVe(e,t,n){const r=e[t];return r&&r.type?UVe(r.type):n}function HVe(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>UVe(e))):n}function qVe(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function KVe(e,t,n){const r=e[t];return r&&r.shape?qVe(r.shape):n}function XVe(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function YVe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>zVe(e,r))):n}function QVe(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>qVe(e))):n}function JVe(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class ZVe{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return hVe(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return hVe(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return VVe(this.node.rawAttrs,e,t);if(null!=n.s)return BVe(this.node.rawAttrs,e,t);if(null!=n.b)return WVe(this.node.rawAttrs,e,t);if(null!=n.shape)return KVe(this.node.rawAttrs,e,t);if(null!=n.type)return GVe(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return XVe(this.node.rawAttrs,e,t);if(null!=n.list.s)return YVe(this.node.rawAttrs,e,t);if(null!=n.list.shape)return QVe(this.node.rawAttrs,e,t);if(null!=n.list.b)return JVe(this.node.rawAttrs,e,t);if(null!=n.list.type)return HVe(this.node.rawAttrs,e,t)}return t}}function eUe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){Vve(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const a=e[r],s=t[r];Vve(a<0||s<0||a===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function tUe(e){return"number"!==typeof e&&!e.some((e=>e<0))}function nUe(e,t,n){let r=rUe(e,n);const a=!tUe(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=rUe(e.shape,r)})),!tUe(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function rUe(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}class aUe{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=zNe(0),wCe(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),eUe(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,wCe(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return fCe([],[0].concat(this.elementShape));const n=this.readMany(e);return eUe(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),C$e(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return fCe([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return eUe(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),TEe(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,V$e(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=0===n?0:t.size/n,s=[];vCe((()=>{t=IEe(t,[1,n,a]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],a];s[n]=IEe(_Ee(t,i,o),this.elementShape)}return s}));const i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}}class sUe{get id(){return this.idTensor.id}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);eUe(t,e.shape,"TensorList shape mismatch: "),wCe(e)})),this.idTensor=zNe(0),this.maxNumElements=r,wCe(this.idTensor)}copy(){return new sUe([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);eUe(e,this.elementShape,"TensorList shape mismatch: ");const r=nUe(this.elementShape,this.tensors,e);return vCe((()=>{const e=this.tensors.map((e=>IEe(e,r)));return C$e(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=nUe(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,eUe(r.shape,e,"TensorList shape mismatch: "),IEe(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(eUe(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");wCe(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new sUe([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);eUe(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=nUe(this.elementShape,this.tensors,t);return IEe(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);eUe(this.elementShape,t.shape,"TensorList shape mismatch: "),wCe(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);eUe(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=nUe(this.elementShape,this.tensors,n);return 0===e.length?fCe([],[0].concat(r)):vCe((()=>{const t=e.map((e=>IEe(this.tensors[e],r)));return C$e(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);eUe(this.elementShape,t,"TensorList shape mismatch: ");const n=nUe(this.elementShape,this.tensors,t);return 0===this.size()?fCe([],[0].concat(n)):vCe((()=>{const e=this.tensors.map((e=>IEe(e,n)));return TEe(e,0)}))}}const iUe=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=dVe("thenBranch",e,t,n),a=dVe("elseBranch",e,t,n),s=dVe("cond",e,t,n),i=dVe("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=dVe("body",e,t,n),a=dVe("cond",e,t,n),s=dVe("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map((e=>e.id));let l=await i[0].data();i.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let u=s;for(;l[0];){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return u}case"LoopCond":return[bVe(dVe("pred",e,t,n))];case"Switch":{const r=dVe("pred",e,t,n);let a=dVe("data",e,t,n);return a.kept||(a=bVe(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==hVe(e,t,n)));if(r){return[bVe(hVe(r,t,n))]}return}case"Enter":{const r=dVe("frameName",e,t,n),a=dVe("tensor",e,t,n);return n.enterFrame(r),[bVe(a)]}case"Exit":{const r=dVe("tensor",e,t,n);return n.exitFrame(),[bVe(r)]}case"NextIteration":{const r=dVe("tensor",e,t,n);return n.nextIteration(),[bVe(r)]}case"TensorArrayV3":{const r=dVe("size",e,t,n),a=dVe("dtype",e,t,n),s=dVe("elementShape",e,t,n),i=dVe("dynamicSize",e,t,n),o=dVe("clearAfterRead",e,t,n),l=dVe("identicalElementShapes",e,t,n),u=dVe("name",e,t,n),c=new aUe(u,a,r,s,l,i,o);return n.addTensorArray(c),[c.idTensor,zNe(1)]}case"TensorArrayWriteV3":{const r=dVe("tensorArrayId",e,t,n),a=dVe("index",e,t,n),s=dVe("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{const r=dVe("tensorArrayId",e,t,n),a=dVe("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{const r=dVe("tensorArrayId",e,t,n),a=dVe("indices",e,t,n),s=dVe("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{const r=dVe("tensorArrayId",e,t,n),a=dVe("indices",e,t,n),s=dVe("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{const r=dVe("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=dVe("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{const r=dVe("tensorArrayId",e,t,n),a=dVe("tensor",e,t,n),s=dVe("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{const r=dVe("tensorArrayId",e,t,n);return[zNe(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=dVe("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{const r=dVe("tensorListId",e,t,n),a=dVe("index",e,t,n),s=dVe("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{const r=dVe("tensorListId",e,t,n),a=dVe("index",e,t,n),s=dVe("elementShape",e,t,n),i=dVe("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=dVe("indices",e,t,n),a=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);const s=new sUe([],n,e.dtype,r),i=V$e(e,0);return t.forEach(((e,t)=>{s.setItem(e,i[t])})),s}(dVe("tensor",e,t,n),r,dVe("elementShape",e,t,n),dVe("numElements",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=dVe("elementShape",e,t,n),a=dVe("elementDType",e,t,n);let s;s="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=dVe(s,e,t,n),o=function(e,t,n,r){return new sUe([],e,t,r)}(r,a,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=dVe("tensorListId",e,t,n),a=dVe("indices",e,t,n),s=dVe("elementShape",e,t,n),i=dVe("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{const r=dVe("tensorListId",e,t,n),a=dVe("elementShape",e,t,n),s=dVe("elementDType",e,t,n),i=dVe("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);eUe(e.shape.slice(1),t,"TensorList shape mismatch: ");const a=V$e(e);return new sUe(a,t,r)}(dVe("tensor",e,t,n),dVe("elementShape",e,t,n),dVe("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=dVe("tensorListId",e,t,n),a=n.getTensorList(r.id),s=dVe("dtype",e,t,n),i=dVe("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{const r=dVe("tensorListId",e,t,n),a=dVe("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{const r=dVe("tensorListId",e,t,n),a=dVe("elementShape",e,t,n),s=dVe("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{const r=dVe("tensor",e,t,n),a=dVe("elementShape",e,t,n),s=function(e,t,n){let r=0;const a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const s=rUe(e.shape.slice(1),n),i=0===r?0:e.size/r,o=vCe((()=>{const n=[];e=IEe(e,[1,r,i]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:a[r-1],0],l=[1,t[r],i];n[r]=IEe(_Ee(e,o,l),s)}return e.dispose(),n})),l=new sUe([],n,e.dtype,t.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(r,dVe("lengths",e,t,n),a);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{const r=dVe("tensorListId",e,t,n);return[zNe(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=dVe("tensorListId",e,t,n),a=dVe("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function oUe(e,t,n){const[r,a]=dVe("fusedOps",e,t,n),s="biasadd"===r,i=!s,o="prelu"===a,l="fusedbatchnorm"===r,u=dVe("numArgs",e,t,n);if(s){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=dVe("strides",e,t,n),d=yVe(e,t,n),h=dVe("dataFormat",e,t,n).toUpperCase(),p=dVe("dilations",e,t,n);let[f,m]=dVe("args",e,t,n);i&&(m=f,f=void 0);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:dVe("leakyreluAlpha",e,t,n)}}function lUe(e,t,n){return{boxes:dVe("boxes",e,t,n),scores:dVe("scores",e,t,n),maxOutputSize:dVe("maxOutputSize",e,t,n),iouThreshold:dVe("iouThreshold",e,t,n),scoreThreshold:dVe("scoreThreshold",e,t,n),softNmsSigma:dVe("softNmsSigma",e,t,n)}}class uUe{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=zNe(0),this.tensorMap=new Map,wCe(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return zNe(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),vCe((()=>{const e=V$e(t),r=n.length,a=e.length;Vve(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){const r=n[t],a=e[t];wCe(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return vCe((()=>{const e=[];for(let r=0;r<n.length;r++){const a=n[r],s=this.findWithDefault(a,t);e.push(s)}return C$e(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function cUe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:vCe;const s=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(dVe("a",e,t,n),dVe("b",e,t,n))];case"AddN":return[r.addN(dVe("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(dVe("a",e,t,n),dVe("b",e,t,n))];case"Mul":return[r.mul(dVe("a",e,t,n),dVe("b",e,t,n))];case"RealDiv":case"Div":return[r.div(dVe("a",e,t,n),dVe("b",e,t,n))];case"DivNoNan":return[r.divNoNan(dVe("a",e,t,n),dVe("b",e,t,n))];case"FloorDiv":return[r.floorDiv(dVe("a",e,t,n),dVe("b",e,t,n))];case"Sub":return[r.sub(dVe("a",e,t,n),dVe("b",e,t,n))];case"Minimum":return[r.minimum(dVe("a",e,t,n),dVe("b",e,t,n))];case"Maximum":return[r.maximum(dVe("a",e,t,n),dVe("b",e,t,n))];case"Pow":return[r.pow(dVe("a",e,t,n),dVe("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(dVe("a",e,t,n),dVe("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"basic_math":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(dVe("x",e,t,n))];case"Acos":return[r.acos(dVe("x",e,t,n))];case"Acosh":return[r.acosh(dVe("x",e,t,n))];case"Asin":return[r.asin(dVe("x",e,t,n))];case"Asinh":return[r.asinh(dVe("x",e,t,n))];case"Atan":return[r.atan(dVe("x",e,t,n))];case"Atan2":return[r.atan2(dVe("x",e,t,n),dVe("y",e,t,n))];case"Atanh":return[r.atanh(dVe("x",e,t,n))];case"Ceil":return[r.ceil(dVe("x",e,t,n))];case"Complex":return[r.complex(dVe("real",e,t,n),dVe("imag",e,t,n))];case"Cos":return[r.cos(dVe("x",e,t,n))];case"Cosh":return[r.cosh(dVe("x",e,t,n))];case"Elu":return[r.elu(dVe("x",e,t,n))];case"Erf":return[r.erf(dVe("x",e,t,n))];case"Exp":return[r.exp(dVe("x",e,t,n))];case"Expm1":return[r.expm1(dVe("x",e,t,n))];case"Floor":return[r.floor(dVe("x",e,t,n))];case"Log":return[r.log(dVe("x",e,t,n))];case"Log1p":return[r.log1p(dVe("x",e,t,n))];case"Imag":return[r.imag(dVe("x",e,t,n))];case"Neg":return[r.neg(dVe("x",e,t,n))];case"Reciprocal":return[r.reciprocal(dVe("x",e,t,n))];case"Real":return[r.real(dVe("x",e,t,n))];case"Relu":return[r.relu(dVe("x",e,t,n))];case"Round":return[r.round(dVe("x",e,t,n))];case"Selu":return[r.selu(dVe("x",e,t,n))];case"Sigmoid":return[r.sigmoid(dVe("x",e,t,n))];case"Sin":return[r.sin(dVe("x",e,t,n))];case"Sign":return[r.sign(dVe("x",e,t,n))];case"Sinh":return[r.sinh(dVe("x",e,t,n))];case"Softplus":return[r.softplus(dVe("x",e,t,n))];case"Sqrt":return[r.sqrt(dVe("x",e,t,n))];case"Square":return[r.square(dVe("x",e,t,n))];case"Tanh":return[r.tanh(dVe("x",e,t,n))];case"Tan":return[r.tan(dVe("x",e,t,n))];case"ClipByValue":return[r.clipByValue(dVe("x",e,t,n),dVe("clipValueMin",e,t,n),dVe("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(dVe("x",e,t,n))];case"Rsqrt":return[r.rsqrt(hVe(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(dVe("x",e,t,n),dVe("alpha",e,t,n))];case"Prelu":return[r.prelu(dVe("x",e,t,n),dVe("alpha",e,t,n))];case"IsNan":return[r.isNaN(hVe(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(hVe(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(hVe(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"control":return iUe(e,t,n);case"convolution":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Conv1D":{const a=dVe("stride",e,t,n),s=dVe("pad",e,t,n),i=dVe("dataFormat",e,t,n).toUpperCase(),o=dVe("dilation",e,t,n);return[r.conv1d(dVe("x",e,t,n),dVe("filter",e,t,n),a,s,i,o)]}case"Conv2D":{const a=dVe("strides",e,t,n),s=yVe(e,t,n),i=dVe("dataFormat",e,t,n).toUpperCase(),o=dVe("dilations",e,t,n);return[r.conv2d(dVe("x",e,t,n),dVe("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=oUe(e,t,n);return[r.fused.conv2d({x:dVe("x",e,t,n),filter:dVe("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=oUe(e,t,n);return[r.fused.depthwiseConv2d({x:dVe("x",e,t,n),filter:dVe("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=dVe("outputShape",e,t,n),s=dVe("strides",e,t,n),i=yVe(e,t,n);return[r.conv2dTranspose(dVe("x",e,t,n),dVe("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=dVe("strides",e,t,n),s=yVe(e,t,n),i=dVe("dilations",e,t,n),o=dVe("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(dVe("input",e,t,n),dVe("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{const a=dVe("strides",e,t,n),s=dVe("pad",e,t,n),i=dVe("dataFormat",e,t,n).toUpperCase(),o=dVe("dilations",e,t,n);return[r.conv3d(dVe("x",e,t,n),dVe("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{const a=dVe("strides",e,t,n),s=dVe("pad",e,t,n),i=dVe("kernelSize",e,t,n);return[r.avgPool(dVe("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{const a=dVe("strides",e,t,n),s=dVe("pad",e,t,n),i=dVe("kernelSize",e,t,n);return[r.maxPool(dVe("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{const a=dVe("strides",e,t,n),s=dVe("pad",e,t,n),i=dVe("kernelSize",e,t,n),o=dVe("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(dVe("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,u]}case"AvgPool3D":{const a=dVe("strides",e,t,n),s=dVe("pad",e,t,n),i=dVe("kernelSize",e,t,n);return[r.avgPool3d(dVe("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{const a=dVe("strides",e,t,n),s=dVe("pad",e,t,n),i=dVe("kernelSize",e,t,n);return[r.maxPool3d(dVe("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{const a=dVe("strides",e,t,n),s=dVe("pad",e,t,n),i=dVe("dilations",e,t,n),o=a[1],l=a[2],u=i[1],c=i[2];return[r.dilation2d(dVe("x",e,t,n),dVe("filter",e,t,n),[o,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"creation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Fill":{const a=dVe("shape",e,t,n),s=dVe("dtype",e,t,n),i=dVe("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{const a=dVe("start",e,t,n),s=dVe("stop",e,t,n),i=dVe("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{const a=dVe("logits",e,t,n),s=dVe("numSamples",e,t,n),i=dVe("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{const a=dVe("indices",e,t,n),s=dVe("depth",e,t,n),i=dVe("onValue",e,t,n),o=dVe("offValue",e,t,n),l=dVe("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(dVe("shape",e,t,n),dVe("dtype",e,t,n))];case"OnesLike":return[r.onesLike(dVe("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(dVe("shape",e,t,n),dVe("dtype",e,t,n),dVe("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(dVe("shape",e,t,n),dVe("minval",e,t,n),dVe("maxval",e,t,n),dVe("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(dVe("shape",e,t,n),dVe("minval",e,t,n),dVe("maxval",e,t,n),dVe("seed",e,t,n))];case"Range":{const a=dVe("start",e,t,n),s=dVe("stop",e,t,n),i=dVe("step",e,t,n);return[r.range(a,s,i,dVe("dtype",e,t,n))]}case"TruncatedNormal":{const a=dVe("shape",e,t,n),s=dVe("mean",e,t,n),i=dVe("stdDev",e,t,n),o=dVe("seed",e,t,n);return[r.truncatedNormal(a,s,i,dVe("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(dVe("shape",e,t,n),dVe("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(dVe("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"dynamic":return async function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:C;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=lUe(e,t,n),c=await a.image.nonMaxSuppressionWithScoreAsync(r,s,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=lUe(e,t,n),u=dVe("padToMaxOutputSize",e,t,n),c=await a.image.nonMaxSuppressionPaddedAsync(r,s,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=lUe(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,s,i,o,l)]}case"Where":{const r=a.cast(dVe("condition",e,t,n),"bool"),s=[await a.whereAsync(r)];return r.dispose(),s}case"ListDiff":return a.setdiff1dAsync(dVe("x",e,t,n),dVe("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n);case"evaluation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"LowerBound":{const a=dVe("sortedSequence",e,t,n),s=dVe("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{const a=dVe("x",e,t,n),s=dVe("k",e,t,n),i=dVe("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{const a=dVe("sortedSequence",e,t,n),s=dVe("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{const a=dVe("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{const a=dVe("x",e,t,n),s=dVe("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"image":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"ResizeBilinear":{const a=dVe("images",e,t,n),s=dVe("size",e,t,n),i=dVe("alignCorners",e,t,n),o=dVe("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{const a=dVe("images",e,t,n),s=dVe("size",e,t,n),i=dVe("alignCorners",e,t,n),o=dVe("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{const a=dVe("image",e,t,n),s=dVe("boxes",e,t,n),i=dVe("boxInd",e,t,n),o=dVe("cropSize",e,t,n),l=dVe("method",e,t,n),u=dVe("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{const a=dVe("images",e,t,n),s=dVe("transforms",e,t,n),i=dVe("outputShape",e,t,n),o=dVe("fillValue",e,t,n),l=dVe("interpolation",e,t,n),u=dVe("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"graph":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const a=dVe("default",e,t,n);return[hVe(e.name,t,n)||a];case"Placeholder":return[hVe(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[bVe(dVe("x",e,t,n))];case"IdentityN":return dVe("x",e,t,n).map((e=>bVe(e)));case"Shape":return[r.tensor1d(dVe("x",e,t,n).shape,"int32")];case"ShapeN":return dVe("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(dVe("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(dVe("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const s=dVe("x",e,t,n),i=dVe("data",e,t,n),o=dVe("message",e,t,n),l=dVe("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"logical":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Equal":return[r.equal(dVe("a",e,t,n),dVe("b",e,t,n))];case"NotEqual":return[r.notEqual(dVe("a",e,t,n),dVe("b",e,t,n))];case"Greater":return[r.greater(dVe("a",e,t,n),dVe("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(dVe("a",e,t,n),dVe("b",e,t,n))];case"Less":return[r.less(dVe("a",e,t,n),dVe("b",e,t,n))];case"LessEqual":return[r.lessEqual(dVe("a",e,t,n),dVe("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(dVe("a",e,t,n),dVe("b",e,t,n))];case"LogicalNot":return[r.logicalNot(dVe("a",e,t,n))];case"LogicalOr":return[r.logicalOr(dVe("a",e,t,n),dVe("b",e,t,n))];case"Select":case"SelectV2":return[r.where(dVe("condition",e,t,n),dVe("a",e,t,n),dVe("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(dVe("a",e,t,n),dVe("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"matrices":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(dVe("a",e,t,n),dVe("b",e,t,n),dVe("transposeA",e,t,n),dVe("transposeB",e,t,n))];case"Einsum":return[r.einsum(dVe("equation",e,t,n),...dVe("tensors",e,t,n))];case"Transpose":return[r.transpose(dVe("x",e,t,n),dVe("perm",e,t,n))];case"_FusedMatMul":const[a,s]=dVe("fusedOps",e,t,n),i="biasadd"===a,o="prelu"===s,l=dVe("numArgs",e,t,n),u=dVe("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=dVe("args",e,t,n);return[r.fused.matMul({a:dVe("a",e,t,n),b:dVe("b",e,t,n),transposeA:dVe("transposeA",e,t,n),transposeB:dVe("transposeB",e,t,n),bias:c,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(dVe("a",e,t,n),dVe("numLower",e,t,n),dVe("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"normalization":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(dVe("x",e,t,n),dVe("axis",e,t,n),dVe("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(dVe("x",e,t,n),dVe("mean",e,t,n),dVe("variance",e,t,n),dVe("offset",e,t,n),dVe("scale",e,t,n),dVe("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(dVe("x",e,t,n),dVe("radius",e,t,n),dVe("bias",e,t,n),dVe("alpha",e,t,n),dVe("beta",e,t,n))];case"Softmax":return[r.softmax(dVe("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(dVe("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"ragged":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"RaggedGather":{const{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(dVe("paramsNestedSplits",e,t,n),dVe("paramsDenseValues",e,t,n),dVe("indices",e,t,n),dVe("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{const{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(dVe("starts",e,t,n),dVe("limits",e,t,n),dVe("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(dVe("shape",e,t,n),dVe("values",e,t,n),dVe("defaultValue",e,t,n),dVe("rowPartitionTensors",e,t,n),dVe("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"reduction":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Max":{const a=dVe("axis",e,t,n),s=dVe("keepDims",e,t,n);return[r.max(dVe("x",e,t,n),a,s)]}case"Mean":{const a=dVe("axis",e,t,n),s=dVe("keepDims",e,t,n);return[r.mean(dVe("x",e,t,n),a,s)]}case"Min":{const a=dVe("axis",e,t,n),s=dVe("keepDims",e,t,n);return[r.min(dVe("x",e,t,n),a,s)]}case"Sum":{const a=dVe("axis",e,t,n),s=dVe("keepDims",e,t,n);return[r.sum(dVe("x",e,t,n),a,s)]}case"All":{const a=dVe("axis",e,t,n),s=dVe("keepDims",e,t,n);return[r.all(dVe("x",e,t,n),a,s)]}case"Any":{const a=dVe("axis",e,t,n),s=dVe("keepDims",e,t,n);return[r.any(dVe("x",e,t,n),a,s)]}case"ArgMax":{const a=dVe("axis",e,t,n);return[r.argMax(dVe("x",e,t,n),a)]}case"ArgMin":{const a=dVe("axis",e,t,n);return[r.argMin(dVe("x",e,t,n),a)]}case"Prod":{const a=dVe("axis",e,t,n),s=dVe("keepDims",e,t,n);return[r.prod(dVe("x",e,t,n),a,s)]}case"Cumprod":{const a=dVe("axis",e,t,n),s=dVe("exclusive",e,t,n),i=dVe("reverse",e,t,n);return[r.cumprod(dVe("x",e,t,n),a,s,i)]}case"Cumsum":{const a=dVe("axis",e,t,n),s=dVe("exclusive",e,t,n),i=dVe("reverse",e,t,n);return[r.cumsum(dVe("x",e,t,n),a,s,i)]}case"Bincount":const a=dVe("x",e,t,n),s=dVe("weights",e,t,n),i=dVe("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{const a=dVe("x",e,t,n),s=dVe("weights",e,t,n),i=dVe("size",e,t,n),o=dVe("binaryOutput",e,t,n);return[r.denseBincount(a,s,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"slice_join":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"ConcatV2":case"Concat":{const a=dVe("n",e,t,n),s=dVe("axis",e,t,n);let i=dVe("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{const a=dVe("x",e,t,n),s=dVe("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{const a=dVe("axis",e,t,n),s=dVe("batchDims",e,t,n),i=dVe("x",e,t,n),o=dVe("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{const a=dVe("dims",e,t,n),s=[];for(let e=0;e<a.length;e++)a[e]&&s.push(e);const i=dVe("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{const a=dVe("axis",e,t,n),s=dVe("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{const a=dVe("begin",e,t,n),s=dVe("size",e,t,n);return[r.slice(dVe("x",e,t,n),a,s)]}case"StridedSlice":{const a=dVe("begin",e,t,n),s=dVe("end",e,t,n),i=dVe("strides",e,t,n),o=dVe("beginMask",e,t,n),l=dVe("endMask",e,t,n),u=dVe("ellipsisMask",e,t,n),c=dVe("newAxisMask",e,t,n),d=dVe("shrinkAxisMask",e,t,n),h=dVe("x",e,t,n);return[r.stridedSlice(h,a,s,i,o,l,u,c,d)]}case"Pack":return vCe((()=>{const a=dVe("axis",e,t,n),s=dVe("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map((e=>{const t=Hve(e.shape,i);if(!t&&!Hve(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,a)]}));case"Unpack":{const a=dVe("axis",e,t,n),s=dVe("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{const a=dVe("reps",e,t,n);return[r.tile(dVe("x",e,t,n),a)]}case"Split":case"SplitV":{const a=dVe("axis",e,t,n),s=dVe("numOrSizeSplits",e,t,n),i=dVe("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{const a=dVe("indices",e,t,n),s=dVe("values",e,t,n),i=dVe("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{const a=dVe("x",e,t,n),s=dVe("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{const a=dVe("sparseIndices",e,t,n),s=dVe("outputShape",e,t,n),i=dVe("sparseValues",e,t,n),o=dVe("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const a=dVe("indices",e,t,n),s=dVe("values",e,t,n),i=dVe("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"sparse":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(dVe("indices",e,t,n),dVe("values",e,t,n),dVe("denseShape",e,t,n),dVe("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{const{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(dVe("inputIndices",e,t,n),dVe("inputShape",e,t,n),dVe("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(dVe("data",e,t,n),dVe("indices",e,t,n),dVe("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(dVe("data",e,t,n),dVe("indices",e,t,n),dVe("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"spectral":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"FFT":return[r.fft(dVe("x",e,t,n))];case"IFFT":return[r.ifft(dVe("x",e,t,n))];case"RFFT":return[r.rfft(dVe("x",e,t,n))];case"IRFFT":return[r.irfft(dVe("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"string":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(dVe("input",e,t,n),dVe("pattern",e,t,n),dVe("rewrite",e,t,n),dVe("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(dVe("data",e,t,n),dVe("dataSplits",e,t,n),dVe("separator",e,t,n),dVe("nGramWidths",e,t,n),dVe("leftPad",e,t,n),dVe("rightPad",e,t,n),dVe("padWidth",e,t,n),dVe("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{const{indices:a,values:s,shape:i}=r.string.stringSplit(dVe("input",e,t,n),dVe("delimiter",e,t,n),dVe("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(dVe("input",e,t,n),dVe("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"transformation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:C;switch(e.op){case"Cast":return[r.cast(dVe("x",e,t,n),dVe("dtype",e,t,n))];case"ExpandDims":{const a=dVe("axis",e,t,n);return[r.expandDims(dVe("x",e,t,n),a)]}case"Squeeze":{const a=dVe("axis",e,t,n);return[r.squeeze(dVe("x",e,t,n),a)]}case"Reshape":return[r.reshape(dVe("x",e,t,n),dVe("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(dVe("x",e,t,n),dVe("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(dVe("x",e,t,n),dVe("padding",e,t,n),dVe("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(dVe("x",e,t,n),dVe("padding",e,t,n),dVe("constantValue",e,t,n))];case"SpaceToBatchND":{const a=dVe("blockShape",e,t,n),s=dVe("paddings",e,t,n);return[r.spaceToBatchND(dVe("x",e,t,n),a,s)]}case"BatchToSpaceND":{const a=dVe("blockShape",e,t,n),s=dVe("crops",e,t,n);return[r.batchToSpaceND(dVe("x",e,t,n),a,s)]}case"DepthToSpace":{const a=dVe("blockSize",e,t,n),s=dVe("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(dVe("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(dVe("x",e,t,n),dVe("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(dVe("s0",e,t,n),dVe("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const a=r.getHashTableHandleByName(e.name);if(null!=a)return[a];{const a=dVe("keyDType",e,t,n),s=dVe("valueDType",e,t,n),i=new uUe(a,s);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const a=dVe("tableHandle",e,t,n,r),s=dVe("keys",e,t,n),i=dVe("values",e,t,n),o=r.getHashTableById(a.id);return[await o.import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{const a=dVe("tableHandle",e,t,n,r),s=dVe("keys",e,t,n),i=dVe("defaultValue",e,t,n),o=r.getHashTableById(a.id);return[await o.find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const a=dVe("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const s=cVe(e.op);if(s&&s.customExecutor)return s.customExecutor(new ZVe(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return bxe(s)?s.then((e=>[].concat(e))):[].concat(s)}class dUe{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function hUe(e,t,n,r){const a=new Set,s=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(e).map((e=>gVe(e)[0])));r=r||[];const c=new Set(r.map((e=>gVe(e.name)[0]))),d=[...t];for(;d.length>0;){const e=d.pop();(bUe(e)||vUe(e)||xUe(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&(u.has(e.name)||c.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))})):s.push(e.name)))}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function pUe(e,t){const{usedNodes:n,inputs:r}=t,a=Object.keys(r).map((e=>gVe(e)[0])).map((t=>e.nodes[t])),s=e.initNodes||[],i=e=>n.has("string"===typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const l=o([...a,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map((e=>[e.name,e]))),d={};for(const m of u){d[m.name]=d[m.name]||0;for(const e of m.children)i(e)||(d[e.name]=Number.POSITIVE_INFINITY),d[e.name]=(d[e.name]||0)+1}const h=Object.entries(d).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...h];for(;h.length>0;){const e=h.pop(),t=c.get(e);for(const n of t.children.filter(i))0===--d[n.name]&&(p.push(n.name),h.push(n.name))}const f=function(e,t){const n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),a=new Set(r);for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const s of t.children)n.has(s.name)&&!a.has(s.name)&&(a.add(s.name),r.push(s.name))}const s=e.filter((e=>a.has(e.name)));return s}(p.map((e=>c.get(e))),l);return function(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),a=e=>r.has("string"===typeof e?e:e.name),s=new Set(e.map((e=>e.name))),i=e=>s.has("string"===typeof e?e:e.name);for(const o of e){for(const e of o.children.filter(i)){if(!n.has(e.name))throw new fUe(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new fUe(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!a(o))for(const e of o.inputs){if(!n.has(e.name))throw new fUe(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new fUe(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}class fUe extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}const mUe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),gUe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),yUe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function bUe(e){return mUe.has(e.op)}function vUe(e){return gUe.has(e.op)}function xUe(e){return yUe.has(e.op)}class wUe{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new wUe(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=hUe(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){const n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}const i=pUe(this.graph,n),o=function(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>bUe(e)?n:t)),a=e=>{const n=r[t.get(e.name)];return null==n?-1:n},s=e.map(((e,t)=>e.children.map(a).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){const t=s[o];if(t===n)continue;const r=e[o],a=e[t];i.has(a.name)||i.set(a.name,[]),i.get(a.name).push(r)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return wCe(t),t}cloneTensorList(e){if(!e)return null;const t=e.map((e=>this.cloneAndKeepTensor(e)));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[gVe(e)[0]])),a=t.map((e=>gVe(e)[0])),s=new Set(a);let i=a.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=kxe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(gD){this.keepIntermediateTensors=!1,console.warn(gD.message)}const u={},c={};return vCe((()=>{const n=new dUe(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[a,s]=gVe(t,n),i=[];i[s]=e[t],r[a]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(i))}));const a=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(const e of i){if(r[e.name])continue;const t=cUe(e,r,n,this._resourceManager);if(bxe(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,a,s,o.get(e.name))}return null==this.parent&&n.dispose(a),t.map((e=>hVe(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,i){if(!bUe(t)&&!s.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if(bUe(e))continue;const t=pVe(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||a.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,a,s){function i(e){return bUe(e)||a.has(e.name)}if(!bUe(e)&&null!=s)for(const o of s){if(i(o))continue;const e=pVe(o.name,t,n);for(const t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=kxe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(gD){this.keepIntermediateTensors=!1,console.warn(gD.message)}const s=new dUe(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,s,t,n),o=t.map((e=>hVe(e,i,s))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()}))})),null==this.parent&&s.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const a=Object.keys(e),s=a.map((e=>this.graph.nodes[gVe(e)[0]])),i=n.map((e=>gVe(e)[0])),o=new Set(i);let l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:h}=hUe(e,l,this.weightMap,this._initNodes),p=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=gVe(t),a=[];a[r]=e[t],f[n]=a}));const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=this.processStack(s,p,t,f,y,g,o,m,u);await Promise.all(e)}null!=d||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter((e=>!bUe(e)&&!hVe(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,a,s,i,o,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&dVe("isConstant",e.node,r,n)&&([c]=fVe(e.node.name,n)),null==r[e.node.name]){const d=cUe(e.node,r,n,this._resourceManager);c||([c]=fVe(e.node.name,n));const h=n.currentContext;bxe(d)?u.push(d.then((u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=h,this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{const[i]=fVe(e.name,n);!a[i]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!hVe(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!hVe(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=gVe(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const e=a.attrParams.shape.value;Vve(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&Vve(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;const r={};for(const a in e){const s=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[a];null!=s?r[s.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=gVe(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=gVe(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class kUe{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const SUe="?tfjs-format=file",IUe="model.json";class CUe{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;this.modelUrl=t,this.loadOptions=n,this.version="n/a",this.io=r,null==n&&(this.loadOptions={}),this.resourceManager=new kUe}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return bxe(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await RCe(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new wUe(LVe.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=LVe.Instance.transformGraph(e.modelInitializer);this.initializer=new wUe(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof RIe?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof RIe)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var a,s,i;const o=null===(i=null===(s=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===s?void 0:s[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const a=t[n[r]];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&xCe(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function NUe(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==n&&(n={}),n.fromTFHub&&"string"===typeof t&&(t=function(e){e.endsWith("/")||(e+="/");return`${e}${IUe}${SUe}`}(t));const a=new CUe(t,n,r);return await a.load(),a}function TUe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if($Ue(e)){const a=Array.isArray(e)?[]:{};r.add(e);for(const s in e){const i=TUe(e[s],t,n,r);a[s]=i}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function EUe(e){return AUe(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:_Ue)}function AUe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if($Ue(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=e.map((e=>e[s])),i=AUe(r,t,n);a[s]=i}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function _Ue(e){return null===e?null:$Ue(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function $Ue(e){let t=!1;if(kxe().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(551);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof RIe)&&!(e instanceof Promise)&&!t)}function RUe(e){return function(e,t){return TUe(e,t)}(e,DUe)}function DUe(e){return e instanceof RIe?{value:e.clone(),recurse:!1}:$Ue(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class MUe{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class FUe extends MUe{constructor(){super(FUe.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function OUe(e){return new BUe(e)}function PUe(e,t){return new QUe(e,t)}FUe.INITIAL_CAPACITY=32;class LUe{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new qUe(this,e)}filter(e){return new GUe(this,e)}map(e){return new HUe(this,e)}mapAsync(e){return new KUe(this,e)}serialMapAsync(e){return new KUe(this,e).serial()}flatmap(e){return new YUe(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new jUe(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:_Ue;return this.rowMajorBatch(e,t).map((e=>EUe(e,n)))}concatenate(e,t){return new QUe(new zUe([this,e]),t)}take(e){return e<0||null==e?this:new UUe(this,e)}skip(e){return e<0||null==e?this:new VUe(this,e)}prefetch(e){return new ZUe(this,e)}shuffle(e,t){return new eje(this,e,t)}serial(){return new WUe(this)}}class zUe extends LUe{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:RUe(e),done:!1}}}class BUe extends LUe{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(gD){throw gD.message=`Error thrown while iterating through a dataset: ${gD.message}`,gD}}}class WUe extends LUe{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class VUe extends LUe{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;xCe(e.value)}return this.upstream.next()}}class UUe extends LUe{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class jUe extends LUe{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class GUe extends LUe{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;xCe(e.value)}}}class HUe extends LUe{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=qIe(e.value),n=this.transform(e.value),r=qIe(n);for(const a of t)HIe(a,r)||a.dispose();return{value:n,done:!1}}}class qUe extends LUe{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(gD){if(!this.handler(gD))return{value:null,done:!0}}}}class KUe extends LUe{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=qIe(e.value),n=await this.transform(e.value),r=qIe(n);for(const a of t)HIe(a,r)||a.dispose();return{value:n,done:!1}}}class XUe extends LUe{constructor(){super(),this.outputQueue=new FUe,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class YUe extends XUe{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=qIe(e.value),n=this.transform(e.value),r=qIe(n);this.outputQueue.pushAll(n);for(const a of t)HIe(a,r)||a.dispose();return!0}}class QUe extends LUe{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var JUe;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(JUe||(JUe={}));class ZUe extends LUe{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new MUe(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class eje extends ZUe{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=B_e.alea(n||dIe().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class tje{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return Vve(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),nje((async()=>(await n.iterator()).columnMajorBatch(e,t,rje)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,nje((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,nje((async()=>(await t.iterator()).filter((t=>vCe((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return nje((async()=>(await t.iterator()).map((t=>vCe((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return nje((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return nje((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,nje((async()=>PUe(OUe((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,nje((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,a=B_e.alea(t||dIe().toString());return nje((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,nje((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function nje(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends tje{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function rje(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof RIe||mIe(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof RIe?C$e(e):fCe(e)}(e),recurse:!1}}return{value:null,recurse:!0}}tje.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function aje(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Vve("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}const sje=G$e;class ije extends Ove{nextDataId(){return ije.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Fve(this,yCe())}write(e,t,n){this.firstUse&&(this.firstUse=!1,kxe().get("IS_NODE")&&LSe("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&axe(n[0])){const a=n.map((e=>pIe(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return jDe(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>fIe(e)));return TNe(e.shape,e.dtype,n)}catch(tL){throw new Error("Failed to decode encoded string bytes into utf-8")}return TNe(e.shape,e.dtype,t)}makeOutput(e,t,n){return yCe().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=dIe();e();return{kernelMs:dIe()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){aje([e],"where");const t=this.readSync(e.dataId);return sje(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}ije.nextDataId=0;function oje(e){return(t,n,r)=>{const a=txe(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function lje(e,t,n){return uje(e,oje(t),n)}function uje(e,t,n){return r=>{let{inputs:a,attrs:s,backend:i}=r;const{x:o}=a;aje(o,e);const l=i,u=l.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=IMe(u)}else c=u;const d=n||o.dtype,h=t(c,d,s);return l.makeTensorInfo(o.shape,d,h)}}SCe("cpu",(()=>new ije),1);const cje=lje(Cwe,(e=>e>=0?e:Math.exp(e)-1)),dje={kernelName:Cwe,backendName:"cpu",kernelFunc:cje};function hje(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const pje={kernelName:Vwe,backendName:"cpu",kernelFunc:hje};function fje(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;aje([a],"leakyRelu");const i=Gve(a.shape),o=n.data.get(a.dataId).values,l=exe("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}const mje={kernelName:Kwe,backendName:"cpu",kernelFunc:fje};function gje(e){return(t,n,r,a,s)=>{const i=tTe(t,n),o=i.length,l=uxe(i),u=exe(s,Gve(i)),c=t.length,d=n.length,h=uxe(t),p=uxe(n),f=ZNe(t,i),m=ZNe(n,i);if(f.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=e(r[g%r.length],a[g%a.length]);else for(let g=0;g<u.length;++g){const t=yxe(g,o,l),n=t.slice(-c);f.forEach((e=>n[e]=0));const s=gxe(n,c,h),i=t.slice(-d);m.forEach((e=>i[e]=0));const y=gxe(i,d,p);u[g]=e(r[s],a[y])}return[u,i]}}const yje=gje(((e,t)=>e<0?t*e:e));function bje(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t;aje([r,a],"prelu");const s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=yje(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}const vje={kernelName:Ake,backendName:"cpu",kernelFunc:bje},xje=lje(Pke,(e=>Math.max(0,e))),wje={kernelName:Pke,backendName:"cpu",kernelFunc:xje},kje=lje(Uke,(e=>Math.min(Math.max(0,e),6))),Sje={kernelName:Uke,backendName:"cpu",kernelFunc:kje},Ije=oje((e=>1/(1+Math.exp(-e)))),Cje=lje(nSe,(e=>1/(1+Math.exp(-e)))),Nje={kernelName:nSe,backendName:"cpu",kernelFunc:Cje};function Tje(e,t,n,r,a){if("linear"===n)return hje({inputs:{x:t},backend:e});if("relu"===n)return xje({inputs:{x:t},backend:e});if("elu"===n)return cje({inputs:{x:t},backend:e});if("relu6"===n)return kje({inputs:{x:t},backend:e});if("prelu"===n)return bje({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return fje({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return Cje({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Eje(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}const Aje={kernelName:Zxe,backendName:"cpu",kernelFunc:Eje};function _je(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return Eje({inputs:{real:_je(e,t,"float32"),imag:_je(e,t,"float32")},backend:e})}const r=pxe(Gve(t),n);return e.makeTensorInfo(t,n,r)}function $je(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const Rje={kernelName:Fke,backendName:"cpu",kernelFunc:$je};function Dje(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=cIe([0],n),[a,s]=gje(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Mje(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return hje({inputs:{x:a},backend:n});const e=_je(n,a.shape,a.dtype),t=Mje({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=Eje({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=$je({inputs:{input:a},backend:n}),t=Mje({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!nxe(a.dtype,s)){const e=hje({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}const i=n.data.get(a.dataId).values,[o,l,u]=Dje(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,u)}const Fje={kernelName:Yxe,backendName:"cpu",kernelFunc:Mje};function Oje(e,t,n,r){return null==n?n=>{let{inputs:a,backend:s}=n;const{a:i,b:o}=a,l=s;aje([i,o],e);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d="string"===i.dtype?IMe(u):u,h="string"===i.dtype?IMe(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:e=>{let{inputs:a,backend:s}=e;const{a:i,b:o}=a,l=s;if("complex64"===i.dtype||"complex64"===o.dtype){const e=Mje({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,s=l.data.get(r.dataId).values,u=l.data.get(a.dataId).values,c=Mje({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=l.data.get(h.dataId).values,m=l.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,s,u,f,m),v=l.makeTensorInfo(b,"float32",g),x=l.makeTensorInfo(b,"float32",y),w=Eje({inputs:{real:v,imag:x},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(x),w}{const e=l.data.get(i.dataId).values,n=l.data.get(o.dataId).values,a=r||i.dtype,[s,u]=t(i.shape,o.shape,e,n,a);return l.makeTensorInfo(u,a,s)}}}function Pje(e){return(t,n,r,a,s,i)=>{const o=tTe(t,n),l=Gve(o),u=o.length,c=uxe(o),d=exe("float32",l),h=exe("float32",l),p=ZNe(t,o),f=ZNe(n,o),m=jDe(r,a),g=jDe(s,i),y=t.length,b=uxe(t),v=n.length,x=uxe(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=r.real,h[w]=r.imag}else for(let w=0;w<d.length;w++){const t=yxe(w,u,c),n=t.slice(-y);p.forEach((e=>n[e]=0));const r=gxe(n,y,b),a=t.slice(-v);f.forEach((e=>a[e]=0));const s=gxe(a,v,x),i=e(m[2*r],m[2*r+1],g[2*s],g[2*s+1]);d[w]=i.real,h[w]=i.imag}return[d,h,o]}}const Lje=gje(((e,t)=>e+t)),zje=Pje(((e,t,n,r)=>({real:e+n,imag:t+r}))),Bje=Oje(_xe,Lje,zje),Wje={kernelName:_xe,backendName:"cpu",kernelFunc:Bje};function Vje(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=Gve(a.shape),o=Qve(s,i),l=Gve(o);Vve(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);const u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}const Uje={kernelName:Lke,backendName:"cpu",kernelFunc:Vje};function jje(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;aje([a,s],"matMul");const l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Gve(f),y=Gve(m),b=tTe(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);Vve(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));const v=o?[y,p,d]:[y,d,p],x=Vje({inputs:{x:a},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=Vje({inputs:{x:s},backend:n,attrs:{shape:v}}),k=i?x.shape[1]:x.shape[2],S=i?x.shape[2]:x.shape[1],I=o?w.shape[1]:w.shape[2],C=Math.max(g,y),N=n.data.get(x.dataId).values,T=n.data.get(w.dataId).values,E=uxe(x.shape),A=uxe(w.shape),[_,$,R]=i?[E[0],1,E[1]]:[E[0],E[1],1],[D,M,F]=o?[1,A[1],A[0]]:[A[1],1,A[0]],O=S*I,P=TNe([C,S,I],x.dtype),L=P.values,z=n.blockSize;for(let B=0;B<C;B++){const e=B%g,t=B%y;for(let n=0;n<S;n+=z){const r=Math.min(n+z,S);for(let a=0;a<I;a+=z){const s=Math.min(a+z,I);for(let i=0;i<k;i+=z){const o=Math.min(i+z,k);for(let l=n;l<r;l++)for(let n=a;n<s;n++){let r=0;for(let a=i;a<o;a++){r+=N[e*_+l*$+a*R]*T[a*D+n*M+t*F]}L[B*O+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,P.dtype,P.values)}const Gje={kernelName:Gxe,backendName:"cpu",kernelFunc:jje};const Hje={kernelName:FSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=jje({inputs:{a:a,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=Bje({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=Tje(n,h,c,o,d),m.push(h),h=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return h}};function qje(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const Kje={kernelName:Txe,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;aje(t,"abs");let r=new Float32Array(Gve(t.shape));return r=qje(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},Xje=lje(Exe,(e=>Math.acos(e))),Yje={kernelName:Exe,backendName:"cpu",kernelFunc:Xje},Qje=lje(Axe,(e=>Math.acosh(e))),Jje={kernelName:Axe,backendName:"cpu",kernelFunc:Qje};const Zje={kernelName:$xe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;aje(t,"addN");const a=r.map((e=>n.data.get(e.dataId).values)),s=TNe(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){const e=a[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function eGe(e,t,n,r,a){const s=t.length,i=Gve(t),o=uxe(t),l=uxe(a),u=exe(n,Gve(a));for(let c=0;c<i;++c){const t=yxe(c,s,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[gxe(n,s,l)]=e[c]}return u}function tGe(e){const{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;aje(a,"transpose");const i=a.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=a.shape[s[u]];const l=eGe(r.data.get(a.dataId).values,a.shape,a.dtype,s,o);return{dataId:r.write(l,o,a.dtype),shape:o,dtype:a.dtype}}const nGe={kernelName:TSe,backendName:"cpu",kernelFunc:tGe};const rGe={kernelName:Rxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;aje(a,"all");const o=Jve(s,a.shape);let l=o;const u=SAe(l,a.shape.length);let c=a;null!=u&&(c=tGe({inputs:{x:a},backend:n,attrs:{perm:u}}),l=CAe(l.length,a.shape.length)),kAe("all",l,c.shape.length);const[d,h]=xAe(c.shape,l),p=Gve(h),f=pxe(Gve(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=Vje({inputs:{x:g},backend:n,attrs:{shape:wAe(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const aGe={kernelName:Dxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;aje(a,"any");const o=Jve(s,a.shape);let l=o;const u=SAe(l,a.shape.length);let c=a;null!=u&&(c=tGe({inputs:{x:a},backend:n,attrs:{perm:u}}),l=CAe(l.length,a.shape.length)),kAe("any",l,c.shape.length);const[d,h]=xAe(c.shape,l),p=Gve(h),f=pxe(Gve(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=Vje({inputs:{x:g},backend:n,attrs:{shape:wAe(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const sGe={kernelName:Mxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;aje(a,"argMax");let i=Jve(s,a.shape);const o=SAe(i,a.shape.length);let l=a;const u=[];null!=o&&(l=tGe({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=CAe(i.length,l.shape.length)),i=[i[0]],kAe("argMax",i,l.shape.length);const[c,d]=xAe(l.shape,i),h=pxe(Gve(c),"int32"),p=Gve(d),f=n.data.get(l.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const a=f[e+r];a>t&&(t=a,n=r)}h[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}};const iGe={kernelName:Fxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;aje(a,"argMin");let i=Jve(s,a.shape);const o=SAe(i,a.shape.length);let l=a;const u=[];null!=o&&(l=tGe({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=CAe(i.length,l.shape.length)),i=[i[0]],kAe("argMin",i,l.shape.length);const[c,d]=xAe(l.shape,i),h=pxe(Gve(c),"int32"),p=Gve(d),f=n.data.get(l.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const a=f[e+r];a<t&&(t=a,n=r)}h[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}},oGe=lje(Oxe,(e=>Math.asin(e))),lGe={kernelName:Oxe,backendName:"cpu",kernelFunc:oGe},uGe=lje(Pxe,(e=>Math.asinh(e))),cGe={kernelName:Pxe,backendName:"cpu",kernelFunc:uGe},dGe=lje(Lxe,(e=>Math.atan(e))),hGe={kernelName:Lxe,backendName:"cpu",kernelFunc:dGe},pGe=gje(((e,t)=>Math.atan2(e,t))),fGe=Oje(Bxe,pGe),mGe={kernelName:Bxe,backendName:"cpu",kernelFunc:fGe},gGe=lje(zxe,(e=>Math.atanh(e))),yGe={kernelName:zxe,backendName:"cpu",kernelFunc:gGe};function bGe(e,t,n,r,a,s){const i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,c=a.effectiveFilterHeight,d=a.effectiveFilterWidth,h=a.padInfo.top,p=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=TNe(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let x=0;x<a.batchSize;++x){const t=x*y,n=x*r[0];for(let m=0;m<a.inChannels;++m)for(let y=0;y<a.outHeight;++y){const x=y*i-h,w=Math.max(0,x),k=Math.min(a.inHeight,c+x),S=t+y*b;for(let t=0;t<a.outWidth;++t){const i=t*o-p,c=Math.max(0,i),h=Math.min(a.inWidth,d+i);let y=f,b=0,x=0;for(let t=w;t<k;t+=l){const a=n+t*r[1];for(let t=c;t<h;t+=u){const n=e[a+t*r[2]+m];"max"===s&&n>y?y=n:"avg"===s&&(b+=n,x++)}if(isNaN(y))break}g[S+t*v+m]="avg"===s?b/x:y}}}return m}function vGe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=TNe(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=TNe(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*o-p;let y=n;for(;y<0;)y+=u;const b=Math.min(r.inHeight,d+n);for(let o=0;o<r.outWidth;++o){const d=o*l-f;let p=d;for(;p<0;)p+=c;const v=Math.min(r.inWidth,h+d);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=u){const i=t-n;for(let n=p;n<v;n+=c){const o=n-d,l=m.get(g,t,n,e);l>x&&(x=l,w=a?s?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*h+o)}}i.set(w,g,t,o,e)}}return i}function xGe(e,t,n,r,a,s){const i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,c=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=TNe(a.outShape,n),x=v.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let C=0;C<a.batchSize;++C){const t=C*w,n=C*r[0];for(let v=0;v<a.inChannels;++v)for(let w=0;w<a.outDepth;++w){const C=w*i-m;let N=C;for(;N<0;)N+=u;const T=Math.min(a.inDepth,h+C),E=t+w*k;for(let t=0;t<a.outHeight;++t){const i=t*o-g;let h=i;for(;h<0;)h+=c;const m=Math.min(a.inHeight,p+i),w=E+t*S;for(let t=0;t<a.outWidth;++t){const i=t*l-y;let o=i;for(;o<0;)o+=d;const p=Math.min(a.inWidth,f+i),g=w+t*I;let k=b,S=0,C=0;for(let t=N;t<T;t+=u){const a=n+t*r[1];for(let t=h;t<m;t+=c){const n=a+t*r[2];for(let t=o;t<p;t+=d){const a=e[n+t*r[3]+v];if("max"===s&&a>k?k=a:"avg"===s&&(S+=a,C++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===s?S/Math.max(C,1):k}}}}return v}const wGe={kernelName:Wxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;aje(a,"avgPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Vve(xEe(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=cEe(a.shape,s,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&Hve(u.inShape,u.outShape))c=hje({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=uxe(a.shape),r=bGe(e,a.shape,a.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,a.dtype,r.values)}return c}};const kGe={kernelName:Uxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;aje(a,"avgPool3d");const c=dEe(a.shape,s,i,1,o,l,u),d=xGe(n.data.get(a.dataId).values,a.shape,a.dtype,uxe(a.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};const SGe={kernelName:jxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;aje([a,s],"avgPool3DGrad");const c=dEe(s.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=x-1-c.padInfo.front,I=k-1-c.padInfo.left,C=w-1-c.padInfo.top,N=TNe(s.shape,"float32"),T=1/(f*m*g),E=n.bufferSync(a);for(let A=0;A<c.batchSize;++A)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const a=t-S,s=n-C,i=r-I;let o=0;for(let t=0;t<x;t+=y){const n=(a+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const r=(s+t)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){const a=(i+t)/p;if(a<0||a>=c.outWidth||Math.floor(a)!==a)continue;o+=E.get(A,n,r,a,e)}}}N.set(o*T,A,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const IGe={kernelName:Vxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;aje([a,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=cEe(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=TNe(i.shape,"float32"),k=1/(p*f),S=n.data.get(a.dataId).values,I=TNe(a.shape,"float32",S);for(let C=0;C<c.batchSize;++C)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const r=t-x,a=n-v;let s=0;for(let t=0;t<y;t+=m){const n=(r+t)/d;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const r=(a+t)/h;if(r<0||r>=c.outWidth||Math.floor(r)!==r)continue;s+=I.get(C,n,r,e)}}w.set(s*k,C,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const CGe={kernelName:Pwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;Vve(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Vve(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Vve(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),aje([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,v=d.length;let x=0,w=0,k=0,S=0;for(let I=0;I<c.length;++I)m[I]=f[x++]+(c[I]-d[w++])*p[k++]/Math.sqrt(h[S++]+u),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,m)}};function NGe(e,t,n,r,a){const s=HTe(r,t,n),i=Gve(n),o=uxe(r);if(s){const n=qTe(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}const l=TNe(r,a,"string"===a?IMe(e):e),u=TNe(n,a);for(let c=0;c<u.size;++c){const e=u.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===a?CMe(u.values):u.values}function TGe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;aje(a,"slice");const[o,l]=KTe(a,s,i);MTe(a,o,l);const u=NGe(n.data.get(a.dataId).values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}const EGe={kernelName:Jke,backendName:"cpu",kernelFunc:TGe};const AGe={kernelName:Hxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;aje([a],"batchToSpaceND");const o=s.reduce(((e,t)=>e*t)),l=_De(a.shape,s,o),u=$De(l.length,s.length),c=RDe(a.shape,s,o),d=DDe(i,s.length),h=MDe(c,i,s.length),p=Vje({inputs:{x:a},backend:n,attrs:{shape:l}}),f=tGe({inputs:{x:p},backend:n,attrs:{perm:u}}),m=Vje({inputs:{x:f},backend:n,attrs:{shape:c}}),g=TGe({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function _Ge(e,t,n,r,a){const s=Gve(r),i=pxe(a,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=s>0?t[o]:1)}return i}function $Ge(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e.shape[0],s=e.shape[1],i=TNe([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){const s=e.get(o,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}const RGe={kernelName:qxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=_Ge(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}},DGe=gje(((e,t)=>e&t)),MGe=Oje(Kxe,DGe),FGe={kernelName:Kxe,backendName:"cpu",kernelFunc:MGe};const OGe={kernelName:Xxe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=tTe(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},PGe=oje((e=>Math.ceil(e))),LGe=uje(Qxe,PGe),zGe={kernelName:Qxe,backendName:"cpu",kernelFunc:LGe},BGe=lje(Jxe,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),WGe={kernelName:Jxe,backendName:"cpu",kernelFunc:BGe},VGe={kernelName:ewe,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Gve(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function UGe(e,t,n,r){const a=txe(n,Gve(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=Gve(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const s="string"===n?IMe(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]}))}return a}function jGe(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const GGe={kernelName:jwe,backendName:"cpu",kernelFunc:jGe};function HGe(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Jve(a,t[0].shape)[0];xDe(t.map((e=>e.shape)),s);let i=wDe(t.map((e=>e.shape)),s);if(0===Gve(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Gve(e.shape)>0));if(1===o.length)return hje({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map((e=>$je({inputs:{input:e},backend:n}))),t=o.map((e=>jGe({inputs:{input:e},backend:n}))),r=HGe({inputs:e,backend:n,attrs:{axis:s}}),a=HGe({inputs:t,backend:n,attrs:{axis:s}}),i=Eje({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}const l=o.map((e=>{const t=Gve(e.shape.slice(s));return Vje({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=wDe(l.map((e=>e.shape)),1);const c=1===l[0].shape[0],d=UGe(u,i,t[0].dtype,c),h=wDe(o.map((e=>e.shape)),s),p=n.makeTensorInfo(h,t[0].dtype,d);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const qGe={kernelName:twe,backendName:"cpu",kernelFunc:HGe};function KGe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;aje([a,s],"conv2d");const d=kEe(l),h=hEe(a.shape,s.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new EIe(h.outShape,a.dtype),w=uxe(a.shape),k=uxe(s.shape),S=w[0],I=v?w[1]:w[2],C=v?w[2]:1,N=v?1:w[1],T=x.strides[0],E=v?x.strides[1]:x.strides[2],A=v?x.strides[2]:1,_=v?1:x.strides[1],$=n.data.get(a.dataId).values,R=n.data.get(s.dataId).values,D=x.values;for(let M=0;M<h.batchSize;++M){const e=M*S,t=M*T;for(let n=0;n<h.outHeight;++n){const r=t+n*E,a=n*h.strideHeight-b;for(let t=0;t<p;++t){const n=a+t*m;if(n<0||n>=h.inHeight)continue;const s=t*k[0],i=e+n*I;for(let e=0;e<h.outWidth;++e){const t=r+e*A,n=e*h.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=h.inWidth)continue;const a=i+r*C;let o=s+e*k[1];for(let e=0;e<h.inChannels;++e){const n=$[a+e*N];for(let e=0;e<h.outChannels;++e)D[t+e*_]+=n*R[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,D)}const XGe={kernelName:nwe,backendName:"cpu",kernelFunc:KGe};const YGe={kernelName:rwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;aje([a,s],"conv2dBackpropFilter");const d=kEe(l),h=hEe(a.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new EIe(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=new EIe(a.shape,a.dtype,w),I=new EIe(s.shape,s.dtype,k);for(let C=0;C<m;++C){const e=Math.max(0,Math.ceil((x-C)/p)),t=Math.min(h.outHeight,(h.inHeight+x-C)/p);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(h.outWidth,(h.inWidth+v-n)/f);for(let s=0;s<h.inChannels;++s)for(let i=0;i<h.outChannels;++i){let o=0;for(let l=0;l<h.batchSize;++l)for(let u=e;u<t;++u){const e=C+u*p-x;for(let t=r;t<a;++t){const r=n+t*f-v;o+=y?S.get(l,e,r,s)*I.get(l,u,t,i):S.get(l,s,e,r)*I.get(l,i,u,t)}}b.set(o,C,n,s,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const QGe={kernelName:awe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;aje([a,s],"conv2dBackpropInput");const d=uxe(s.shape),h=uxe(a.shape);let p=kEe(u);const f=hEe(i,s.shape,o,1,l,c,!1,p),m=new EIe(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[v,x,w]=d,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:C,inHeight:N,inWidth:T,outChannels:E,outHeight:A,outWidth:_,strideHeight:$,strideWidth:R}=f;p=f.dataFormat;const D=S-1-f.padInfo.top,M=I-1-f.padInfo.left,F="channelsLast"===p,O=m.strides[0],P=F?m.strides[1]:m.strides[2],L=F?m.strides[2]:1,z=F?1:m.strides[1],B=h[0],W=F?h[1]:h[2],V=F?h[2]:1,U=F?1:h[1];for(let j=0;j<k;++j)for(let e=0;e<C;++e)for(let t=0;t<N;++t){const n=t-D,r=Math.max(0,Math.ceil(n/$)),a=Math.min(A,(S+n)/$);for(let s=0;s<T;++s){const i=s-M,o=Math.max(0,Math.ceil(i/R)),l=Math.min(_,(I+i)/R);let u=0;for(let t=r;t<a;++t){const r=t*$-n;for(let n=o;n<l;++n){const a=B*j+W*t+V*n,s=v*(S-1-r)+x*(I-1-(n*R-i))+w*e;for(let e=0;e<E;++e){u+=y[a+U*e]*b[s+e]}}}g[O*j+P*t+L*s+z*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const JGe={kernelName:swe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;aje([a,s],"conv3d");const u=pEe(a.shape,s.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new EIe(u.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=x.values,I=uxe(a.shape),C=uxe(s.shape);for(let N=0;N<u.batchSize;++N){const e=N*I[0],t=N*x.strides[0];for(let n=0;n<u.outDepth;++n){const r=t+n*x.strides[1],a=n*u.strideDepth-y;for(let t=0;t<c;++t){const n=a+t*p;if(n<0||n>=u.inDepth)continue;const s=t*C[0],i=e+n*I[1];for(let e=0;e<u.outHeight;++e){const t=r+e*x.strides[2],n=e*u.strideHeight-v;for(let e=0;e<d;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const a=s+e*C[1],o=i+r*I[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<h;++e){const t=r+e*m;if(t<0||t>=u.inWidth)continue;const s=a+e*C[2],i=o+t*u.inChannels;let l=s;for(let e=0;e<u.inChannels;++e){const t=w[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const ZGe={kernelName:iwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;aje([a,s],"conv3dBackpropFilterV2");const u=uxe(a.shape),c=uxe(s.shape),d=pEe(a.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new EIe(d.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,I=n.data.get(s.dataId).values,[C,N,T,E]=c,A=n.data.get(a.dataId).values,[_,$,R,D]=u,M=d.padInfo.front,F=d.padInfo.left,O=d.padInfo.top;for(let P=0;P<m;++P){const e=Math.max(0,Math.ceil((M-P)/h)),t=Math.min(d.outDepth,(d.inDepth+M-P)/h),n=P*x;for(let r=0;r<g;++r){const a=Math.max(0,Math.ceil((O-r)/p)),s=Math.min(d.outHeight,(d.inHeight+O-r)/p),i=r*w+n;for(let n=0;n<y;++n){const o=Math.max(0,Math.ceil((F-n)/f)),l=Math.min(d.outWidth,(d.inWidth+F-n)/f),u=n*k+i;for(let i=0;i<d.inChannels;++i){const c=i*S+u;for(let u=0;u<d.outChannels;++u){let m=0;for(let c=0;c<d.batchSize;++c){const d=c*_,g=c*C;for(let c=e;c<t;++c){const e=(P+c*h-M)*$+d,t=c*N+g;for(let c=a;c<s;++c){const a=(r+c*p-O)*R+e,s=c*T+t;for(let e=o;e<l;++e){const t=e*E+s;m+=A[(n+e*f-F)*D+a+i]*I[t+u]}}}}v[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const eHe={kernelName:owe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;aje([a],"conv3dBackpropInputV2");const u=uxe(a.shape),c=uxe(s.shape),d=pEe(l,s.shape,o,1,i),h=new EIe(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(a.dataId).values,[v,x,w,k]=u,S=n.data.get(s.dataId).values,[I,C,N,T]=c,{batchSize:E,filterDepth:A,filterHeight:_,filterWidth:$,inChannels:R,inDepth:D,inHeight:M,inWidth:F,outChannels:O,outDepth:P,outHeight:L,outWidth:z,strideDepth:B,strideHeight:W,strideWidth:V}=d,U=A-1-d.padInfo.front,j=_-1-d.padInfo.top,G=$-1-d.padInfo.left;for(let H=0;H<E;++H)for(let e=0;e<R;++e)for(let t=0;t<D;++t){const n=t-U,r=Math.max(0,Math.ceil(n/B)),a=Math.min(P,(A+n)/B);for(let s=0;s<M;++s){const i=s-j,o=Math.max(0,Math.ceil(i/W)),l=Math.min(L,(_+i)/W);for(let u=0;u<F;++u){const c=u-G,d=Math.max(0,Math.ceil(c/V)),h=Math.min(z,($+c)/V);let E=0;for(let t=r;t<a;++t){const r=t*B-n;for(let n=o;n<l;++n){const a=n*W-i;for(let s=d;s<h;++s){const i=v*H+x*t+w*n+k*s,o=I*(A-1-r)+C*(_-1-a)+N*($-1-(s*V-c))+T*e;for(let e=0;e<O;++e){E+=b[i+e]*S[o+e]}}}}p[f*H+m*t+g*s+y*u+e]=E}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},tHe=lje(lwe,(e=>Math.cos(e))),nHe={kernelName:lwe,backendName:"cpu",kernelFunc:tHe},rHe=lje(uwe,(e=>Math.cosh(e))),aHe={kernelName:uwe,backendName:"cpu",kernelFunc:rHe};const sHe={kernelName:hwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=a.shape,f=s.shape[0],[m,g]=o,y=TNe([f,m,g,p],"float32"),b=n.data.get(s.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,w=uxe(a.shape),k=uxe(y.shape);for(let S=0;S<f;S++){const e=4*S,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],s=v[S];if(s>=c)continue;const i=m>1?(r-t)*(d-1)/(m-1):0,o=g>1?(a-n)*(h-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(d-1)+c*i:.5*(t+r)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}else if("bilinear"===l){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const l=g>1?n*(h-1)+e*o:.5*(n+a)*(h-1);if(l<0||l>h-1){for(let t=0;t<p;t++){const n=t+e*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const d=Math.floor(l),f=Math.ceil(l),m=l-d;for(let n=0;n<p;n++){let a=n+d*w[2]+t*w[1]+s*w[0];const o=x[a];a=n+f*w[2]+t*w[1]+s*w[0];const l=x[a];a=n+d*w[2]+r*w[1]+s*w[0];const u=x[a];a=n+f*w[2]+r*w[1]+s*w[0];const h=o+(l-o)*m,p=u+(x[a]-u)*m;a=n+e*k[2]+c*k[1]+S*k[0],y.values[a]=h+(p-h)*i}}}else for(let t=0;t<g;++t){const r=g>1?n*(h-1)+t*o:.5*(n+a)*(h-1);if(r<0||r>h-1){for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++){const n=e+i*w[2]+l*w[1]+s*w[0],r=e+t*k[2]+c*k[1]+S*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const iHe={kernelName:cwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;aje(a,"cumprod");const l=SAe([s],a.shape.length);let u=a;null!=l&&(u=tGe({inputs:{x:a},backend:n,attrs:{perm:l}}));const c=CAe(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=WIe(u.dtype,"int32"),h=hxe(Gve(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)h[t]=i?1:p[t];else{const n=m(y,e-1);h[t]=i?p[n]*h[n]:p[t]*h[n]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=tGe({inputs:{x:g},backend:n,attrs:{perm:IAe(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const oHe={kernelName:dwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;aje(a,"cumsum");const l=SAe([s],a.shape.length);let u=a;null!=l&&(u=tGe({inputs:{x:a},backend:n,attrs:{perm:l}}));const c=CAe(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=WIe(u.dtype,"int32"),h=pxe(Gve(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)h[t]=i?0:p[t];else{const n=m(y,e-1);h[t]=i?p[n]+h[n]:p[t]+h[n]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=tGe({inputs:{x:g},backend:n,attrs:{perm:IAe(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const lHe={kernelName:pwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){const e=_Ge(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){const e=$Ge(n.bufferSync(a),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};const uHe={kernelName:fwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;Vve("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const o=a.shape[0],l=a.shape[1],u=a.shape[2],c=a.shape[3],d=l*s,h=u*s,p=c/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*d*h*p);let g=0;for(let y=0;y<o;++y)for(let e=0;e<d;++e){const t=Math.floor(e/s),n=e%s;for(let e=0;e<h;++e){const r=Math.floor(e/s),a=(n*s+e%s)*p;for(let e=0;e<p;++e){const n=e+a+c*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,d,h,p],a.dtype,m)}};function cHe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;aje([a,s],"depthwiseConv2DNative");const c=uxe(a.shape),d=uxe(s.shape);let h=l;null==h&&(h=[1,1]),Vve(xEe(i,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`));const p=hEe(a.shape,s.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new EIe(p.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,C=k.values;for(let N=0;N<p.batchSize;++N){const e=N*c[0],t=N*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],a=n*p.strideHeight-x;for(let t=0;t<f;++t){const n=a+t*g;if(n<0||n>=p.inHeight)continue;const s=t*d[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=p.inWidth)continue;const a=s+e*d[1],o=i+r*p.inChannels;let l=t,u=a;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<w;++e)C[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const dHe={kernelName:mwe,backendName:"cpu",kernelFunc:cHe};const hHe={kernelName:gwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;aje([a,s],"depthwiseConv2dNativeBackpropFilter");const d=hEe(a.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new EIe(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,x=n.data.get(a.dataId).values,w=new EIe(a.shape,a.dtype,x),k=n.data.get(s.dataId).values,S=new EIe(s.shape,s.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((b-I)/h)),t=Math.min(d.outHeight,(d.inHeight+b-I)/h);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((y-n)/p)),a=Math.min(d.outWidth,(d.inWidth+y-n)/p);for(let s=0;s<d.outChannels;++s){const i=Math.trunc(s/v),o=s%v;let l=0;for(let u=0;u<d.batchSize;++u)for(let o=e;o<t;++o){const e=I+o*h-b;for(let t=r;t<a;++t){const r=n+t*p-y;l+=w.get(u,e,r,i)*S.get(u,o,t,s)}}g.set(l,I,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const pHe={kernelName:ywe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;aje([a,s],"depthwiseConv2DNativeBackpropInput");const d=uxe(a.shape),h=uxe(s.shape),p=hEe(c,s.shape,i,o,l,u,!0),f=new EIe(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(a.dataId).values,[x,w,k]=d,S=n.data.get(s.dataId).values,[I,C,N]=h,{batchSize:T,filterHeight:E,filterWidth:A,inChannels:_,inHeight:$,inWidth:R,outChannels:D,outHeight:M,outWidth:F,strideHeight:O,strideWidth:P}=p,L=E-1-p.padInfo.top,z=A-1-p.padInfo.left,B=D/_;for(let W=0;W<T;++W)for(let e=0;e<_;++e)for(let t=0;t<$;++t){const n=t-L,r=Math.max(0,Math.ceil(n/O)),a=Math.min(M,(E+n)/O);for(let s=0;s<R;++s){const i=s-z,o=Math.max(0,Math.ceil(i/P)),l=Math.min(F,(A+i)/P);let u=0;for(let t=r;t<a;++t){const r=t*O-n;for(let n=o;n<l;++n){const a=x*W+w*t+k*n,s=I*(E-1-r)+C*(A-1-(n*P-i))+N*e;for(let t=0;t<B;++t){u+=v[a+(e*B+t)]*S[s+t]}}}m[g*W+y*t+b*s+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const fHe={kernelName:bwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=Gve(r.shape),s=n.data.get(r.dataId).values,i=TNe([a,a],r.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*a+u]=s[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},mHe={kernelName:vwe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=n,c=u.data.get(a.dataId).values,d=a.shape.length,h=u.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:C,dilationWidth:N,outShape:T}=uEe(a.shape,s.shape,i,o,"NHWC",l),E=Gve(T),A=T.length,_=txe(a.dtype,E);for(let $=0;$<f;++$)for(let e=0;e<b;++e){const t=e*w-x.top;for(let n=0;n<v;++n){const r=n*k-x.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*C;if(n>=0&&n<m)for(let t=0;t<I;++t){const l=r+t*N;if(l>=0&&l<g){const r=gxe([$,n,l,i],d,uxe(a.shape)),u=gxe([e,t,i],p,uxe(s.shape)),f=c[r]+h[u];f>o&&(o=f)}}}_[gxe([$,e,n,i],A,uxe(T))]=o}}}return{dataId:u.write(cIe(_,a.dtype),T,a.dtype),shape:T,dtype:a.dtype}}},gHe={kernelName:wwe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=dxe(a.shape,c.data.get(a.dataId).values),h=dxe(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=uEe(a.shape,s.shape,o,l,"NHWC",u);Vve(i.rank===N.length,(()=>`Error in ${wwe}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));const T=dxe(N,c.data.get(i.dataId).values),E=fxe(s.shape,s.dtype);for(let A=0;A<p;++A)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*C;if(l>=0&&l<m){const r=d[A][n][l][a]+h[e][t][a];r>s&&(s=r,i=e,o=t)}}}E[i][o][a]+=T[A][e][n][a]}}}return{dataId:c.write(cIe(E,a.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},yHe={kernelName:xwe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=dxe(a.shape,c.data.get(a.dataId).values),h=dxe(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=uEe(a.shape,s.shape,o,l,"NHWC",u);Vve(i.rank===N.length,(()=>`Error in ${xwe}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));const T=dxe(N,c.data.get(i.dataId).values),E=fxe(a.shape,a.dtype);for(let A=0;A<p;++A)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*C;if(l>=0&&l<m){const r=d[A][n][l][a]+h[e][t][a];r>s&&(s=r,i=n,o=l)}}}E[A][i][o][a]+=T[A][e][n][a]}}}return{dataId:c.write(cIe(E,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};const bHe={kernelName:kwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null===l||void 0===l?void 0:l.alpha)||1,c=(null===o||void 0===o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=s.getContext(c,(null===o||void 0===o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);const[h,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(p*h*4);for(let v=0;v<h*p;++v){const e=[0,0,0,255*u];for(let n=0;n<f;n++){const t=m[v*f+n];if("float32"===a.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===a.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}s.width=p,s.height=h;const b=new ImageData(y,p,h);return d.putImageData(b,0,0),a}},vHe=gje(((e,t)=>e*t)),xHe=Pje(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),wHe=Oje(bke,vHe,xHe),kHe={kernelName:bke,backendName:"cpu",kernelFunc:wHe};function SHe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;let o;aje(a,"sum"),o="bool"===a.dtype?Mje({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):hje({inputs:{x:a},backend:n});const l=o.shape.length,u=Jve(s,o.shape),c=SAe(u,l);let d=u,h=o;null!=c&&(h=tGe({inputs:{x:o},backend:n,attrs:{perm:c}}),d=CAe(d.length,l)),kAe("sum",d,h.shape.length);const[p,f]=xAe(h.shape,d);let m=_je(n,p,WIe(h.dtype,"int32"));const g=Gve(f),y=n.data.get(m.dataId).values,b=n.data.get(h.dataId).values;for(let v=0;v<y.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(i){const e=m;m=Vje({inputs:{x:m},backend:n,attrs:{shape:wAe(m.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(h),m}const IHe={kernelName:sSe,backendName:"cpu",kernelFunc:SHe};const CHe={kernelName:Iwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=nMe(a,s.length);aMe(i.length,l,s);const{path:u,steps:c}=sMe(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=rMe(p,l[e]);let a;iMe(t)?a=s[e]:(a=tGe({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Hve(a.shape,i)||(a=Vje({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===h?h=a:(h=wHe({inputs:{a:a,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=SHe({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};const NHe={kernelName:Nwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:a}=t;aje([r,a],"eluGrad");const s=new Float32Array(Gve(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const e=i[l];s[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",s)}},THe=gje(((e,t)=>e===t?1:0)),EHe=Oje(Ewe,THe,null,"bool"),AHe={kernelName:Ewe,backendName:"cpu",kernelFunc:EHe},_He=LDe,$He=zDe,RHe=BDe,DHe=WDe,MHe=VDe,FHe=UDe,OHe=lje(Twe,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+_He*n);return t*(1-((((FHe*r+MHe)*r+DHe)*r+RHe)*r+$He)*r*Math.exp(-n*n))})),PHe={kernelName:Twe,backendName:"cpu",kernelFunc:OHe},LHe=oje((e=>Math.exp(e))),zHe=uje(Awe,LHe,"float32"),BHe={kernelName:Awe,backendName:"cpu",kernelFunc:zHe};function WHe(e){const{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(Vve(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),Vje({inputs:{x:a},backend:n,attrs:{shape:o}})}const VHe={kernelName:_we,backendName:"cpu",kernelFunc:WHe},UHe=oje((e=>Math.expm1(e))),jHe=uje($we,UHe),GHe={kernelName:$we,backendName:"cpu",kernelFunc:jHe},HHe=gje(((e,t)=>e/t)),qHe=Oje(Swe,HHe),KHe={kernelName:Swe,backendName:"cpu",kernelFunc:qHe},XHe=gje(((e,t)=>e-t)),YHe=Pje(((e,t,n,r)=>({real:e-n,imag:t-r}))),QHe=Oje(wSe,XHe,YHe),JHe={kernelName:wSe,backendName:"cpu",kernelFunc:QHe};function ZHe(e,t,n){const r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],c=Gve(u),d=exe("float32",c),h=exe("float32",c);for(let g=0;g<a;g++){const e=TGe({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=TGe({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=Eje({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=eqe(a,t,n),c=jDe(i,u);for(let t=0;t<s;t++){const e=KDe(c,t);d[g*s+t]=e.real,h[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=Eje({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function eqe(e,t,n){const r=Gve(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(0===((o=r)&o-1)){const a=tqe(s,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),s=n.makeTensorInfo([],"float32",uIe(r,"float32")),i=hje({inputs:{x:s},backend:n}),l=KHe.kernelFunc({inputs:{a:e,b:s},backend:n}),u=KHe.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return a}{const e=function(e,t,n){const r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){const o=QDe(a*r,t,n),l=KDe(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),XDe(r,s,i,a)}return r}(jDe(s,i),r,t);return GDe(e)}var o}function tqe(e,t,n,r,a){if(1===n)return{real:e,imag:t};const s=jDe(e,t),i=n/2,o=HDe(s),l=o.real,u=o.imag,c=[l.length],d=a.makeTensorInfo(c,"float32",l),h=a.makeTensorInfo(c,"float32",u),p=Eje({inputs:{real:d,imag:h},backend:a}),f=qDe(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),v=a.makeTensorInfo(y,"float32",g),x=Eje({inputs:{real:b,imag:v},backend:a}),w=tqe(l,u,i,r,a),k=w.real,S=w.imag,I=[k.length],C=a.makeTensorInfo(I,"float32",k),N=a.makeTensorInfo(I,"float32",S),T=Eje({inputs:{real:C,imag:N},backend:a}),E=tqe(m,g,i,r,a),A=E.real,_=E.imag,$=[A.length],R=a.makeTensorInfo($,"float32",A),D=a.makeTensorInfo($,"float32",_),M=Eje({inputs:{real:R,imag:D},backend:a}),F=YDe(n,r),O=[F.real.length],P=a.makeTensorInfo(O,"float32",F.real),L=a.makeTensorInfo(O,"float32",F.imag),z=Eje({inputs:{real:P,imag:L},backend:a}),B=wHe({inputs:{a:z,b:M},backend:a}),W=Bje({inputs:{a:T,b:B},backend:a}),V=QHe({inputs:{a:T,b:B},backend:a}),U=$je({inputs:{input:W},backend:a}),j=$je({inputs:{input:V},backend:a}),G=jGe({inputs:{input:W},backend:a}),H=jGe({inputs:{input:V},backend:a}),q=HGe({inputs:[U,j],backend:a,attrs:{axis:0}}),K=HGe({inputs:[G,H],backend:a,attrs:{axis:0}}),X=a.data.get(q.dataId).values,Y=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}const nqe={kernelName:Rwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=Gve(r.shape),s=r.shape[r.shape.length-1],i=Vje({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=ZHe(i,!1,n),l=Vje({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function rqe(e){const{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||ixe(a),o=txe(i,Gve(r));return function(e,t){e.fill(t)}(o,a),t.makeTensorInfo(r,i,o)}const aqe={kernelName:Dwe,backendName:"cpu",kernelFunc:rqe};const sqe={kernelName:Mwe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,s=r,i=exe(a.dtype,Gve(a.shape)),[o,l,u,c]=a.shape,d=s.data.get(a.dataId).values;for(let h=0;h<o;h++){const e=h*u*l*c;for(let t=0;t<l;t++){const n=t*(u*c);for(let t=0;t<u;t++){const r=t*c;for(let a=0;a<c;a++){const s=Math.round(u-t-1),o=e+n+r+a;let l=d[o];if(s>=0&&s<u){l=d[e+n+s*c+a]}i[o]=l}}}}return{dataId:s.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},iqe=oje((e=>Math.floor(e))),oqe=uje(Fwe,iqe),lqe={kernelName:Fwe,backendName:"cpu",kernelFunc:oqe},uqe=gje(((e,t)=>Math.floor(e/t))),cqe=Oje(Owe,uqe,null,"int32"),dqe={kernelName:Owe,backendName:"cpu",kernelFunc:cqe};const hqe={kernelName:OSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=KGe({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=Vje({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=Bje({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=Bje({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=Vje({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=Tje(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=Tje(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};const pqe={kernelName:PSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=cHe({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;m=Bje({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=Tje(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function fqe(e,t,n,r,a,s,i,o,l){const u=TNe([r,s],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<a;t++){const s=e[c*a+t];r+=s*i[t],n.push(s)}if(r<0||r>=l/s)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<s;e++)u.values[c*s+e]=t.get(...t.indexToLoc(r*s+e))}return u}const mqe={kernelName:zwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=Gve(r.shape),i=a.shape,o=i[i.length-1],[l,u,c,d]=FDe(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const h=fqe(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,o,c,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,h.values)}};function gqe(e,t,n){const r=TNe(n,e.dtype);for(let a=0;a<r.size;++a){const n=r.indexToLoc(a).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];const l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}const yqe={kernelName:Lwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;aje([a,s],"gatherV2");const l=Jve(i,a.shape)[0],u=n.data.get(s.dataId).values,c=a.shape[l];for(let v=0;v<u.length;++v){const e=u[v];Vve(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let d=o;null==o&&(d=0);const h=Gve(s.shape),p=SMe(a,s,l,d),f=Vje({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Vje({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=gqe(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},bqe=gje(((e,t)=>e>t?1:0)),vqe=Oje(Bwe,bqe,null,"bool"),xqe={kernelName:Bwe,backendName:"cpu",kernelFunc:vqe},wqe=gje(((e,t)=>e>=t?1:0)),kqe=Oje(Wwe,wqe,null,"bool"),Sqe={kernelName:Wwe,backendName:"cpu",kernelFunc:kqe};const Iqe={kernelName:Uwe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=Gve(r.shape),s=r.shape[r.shape.length-1],i=Vje({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=ZHe(i,!0,n),l=Vje({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},Cqe=lje(Gwe,(e=>Number.isFinite(e)?1:0),"bool"),Nqe={kernelName:Gwe,backendName:"cpu",kernelFunc:Cqe},Tqe=lje(Hwe,(e=>Math.abs(e)===1/0?1:0),"bool"),Eqe={kernelName:Hwe,backendName:"cpu",kernelFunc:Tqe},Aqe=lje(qwe,(e=>Number.isNaN(e)?1:0),"bool"),_qe={kernelName:qwe,backendName:"cpu",kernelFunc:Aqe},$qe=gje(((e,t)=>e<t?1:0)),Rqe=Oje(Xwe,$qe,null,"bool"),Dqe={kernelName:Xwe,backendName:"cpu",kernelFunc:Rqe},Mqe=gje(((e,t)=>e<=t?1:0)),Fqe=Oje(Ywe,Mqe,null,"bool"),Oqe={kernelName:Ywe,backendName:"cpu",kernelFunc:Fqe};function Pqe(e,t,n){const r=(t-e)/(n-1),a=pxe(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}const Lqe={kernelName:Qwe,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=Pqe(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},zqe=oje((e=>Math.log(e))),Bqe=uje(Jwe,zqe),Wqe={kernelName:Jwe,backendName:"cpu",kernelFunc:Bqe},Vqe=lje(Zwe,(e=>Math.log1p(e))),Uqe={kernelName:Zwe,backendName:"cpu",kernelFunc:Vqe},jqe=gje(((e,t)=>e&&t)),Gqe=Oje(eke,jqe,null,"bool"),Hqe={kernelName:eke,backendName:"cpu",kernelFunc:Gqe},qqe=lje(tke,(e=>e?0:1),"bool"),Kqe={kernelName:tke,backendName:"cpu",kernelFunc:qqe},Xqe=gje(((e,t)=>e||t)),Yqe=Oje(nke,Xqe,null,"bool"),Qqe={kernelName:nke,backendName:"cpu",kernelFunc:Yqe};const Jqe={kernelName:rke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;aje(a,"LRN");const u=a.shape[3],c=u-1,d=n.data.get(a.dataId).values,h=Gve(a.shape),p=new Float32Array(h);function f(e){const t=e%u;let n=e-t+Math.max(0,t-s);const r=e-t+Math.min(t+s,c);let a=0;for(;n<=r;n++){const e=d[n];a+=e*e}return a}for(let m=0;m<h;m++){const e=f(m),t=d[m]*Math.pow(i+o*e,-l);p[m]=t}return n.makeTensorInfo(a.shape,a.dtype,p)}};const Zqe={kernelName:ake,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;aje(i,"LRNGrad");const d=Gve(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const e=b%h,t=b-e+Math.max(0,e-o),n=b-e+Math.min(h,e+o+1);let r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*c*f[a]*m[b]/r;b===a&&(e+=Math.pow(r,-c)),e*=p[b],g[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,g)}};function eKe(e,t,n,r){const a=exe(r,Gve(n));for(let s=0;s<a.length;++s){const n=s*t;let r=e[n];for(let a=0;a<t;++a){const t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[s]=r}return a}function tKe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n;let l=a.shape;const u=l.length,c=Jve(s,l);let d=c;const h=SAe(d,u);let p=o.data.get(a.dataId).values;if(null!=h){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];p=eGe(p,l,a.dtype,h,e),d=CAe(d.length,u),l=e}aje(a,"max"),kAe("max",d,u);const[f,m]=xAe(l,d),g=eKe(p,Gve(m),f,a.dtype),y=o.write(g,f,a.dtype);let b=f;if(i){b=wAe(f,c)}return{dataId:y,shape:b,dtype:a.dtype}}const nKe={kernelName:ske,backendName:"cpu",kernelFunc:tKe},rKe=gje(((e,t)=>Math.max(e,t))),aKe=Oje(ike,rKe),sKe={kernelName:ike,backendName:"cpu",kernelFunc:aKe};const iKe={kernelName:oke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;aje(a,"maxPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Vve(xEe(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=cEe(a.shape,s,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&Hve(u.inShape,u.outShape))c=hje({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=uxe(a.shape),r=bGe(e,a.shape,a.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,a.dtype,r.values)}return c}};const oKe={kernelName:uke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;aje(a,"maxPool3d");const c=dEe(a.shape,s,i,1,o,l,u),d=xGe(n.data.get(a.dataId).values,a.shape,a.dtype,uxe(a.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};const lKe={kernelName:cke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;aje([a,s],"maxPool3DGrad");const c=dEe(s.shape,i,o,1,l,u),d=function(e,t){const n=TNe(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let v=b;for(;v<0;)v+=i;const x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){const u=r*a-p;let h=u;for(;h<0;)h+=o;const w=Math.min(t.inHeight,c+u);for(let a=0;a<t.outWidth;++a){const p=a*s-f;let k=p;for(;k<0;)k+=l;const S=Math.min(t.inWidth,d+p);let I=Number.NEGATIVE_INFINITY,C=-1;for(let t=v;t<x;t+=i){const n=t-b;for(let r=h;r<w;r+=o){const a=r-u;for(let s=k;s<S;s+=l){const i=s-p,o=e.get(m,t,r,s,g);o>=I&&(I=o,C=n*c*d+a*c+i)}}}n.set(C,m,y,r,a,g)}}}return n}(n.bufferSync(s),c),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=x-1-c.padInfo.left,S=v-1-c.padInfo.top,I=TNe(s.shape,"float32"),C=n.bufferSync(a);for(let N=0;N<c.batchSize;++N)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const a=t-w,s=n-S,i=r-k;let o=0;for(let t=0;t<b;t+=m){const n=(a+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){const a=(s+r)/p;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let s=0;s<x;s+=y){const l=(i+s)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=b*v*x-1-d.get(N,n,a,l,e)===t*v*x+r*x+s?1:0;if(0===u)continue;o+=C.get(N,n,a,l,e)*u}}}I.set(o,N,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const uKe={kernelName:lke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;aje([s,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=cEe(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=TNe(h.outShape,o.dtype,vGe(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,k=v-1-h.padInfo.top,S=TNe(o.shape,"float32"),I=n.data.get(a.dataId).values,C=TNe(a.shape,"float32",I);for(let N=0;N<h.batchSize;++N)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){const r=t-k,a=n-w;let s=0;for(let t=0;t<v;t+=y){const n=(r+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){const i=(a+r)/g;if(i<0||i>=h.outWidth||Math.floor(i)!==i)continue;const o=v*x-1-f.get(N,n,i,e)===t*x+r?1:0;if(0===o)continue;s+=C.get(N,n,i,e)*o}}S.set(s,N,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const cKe={kernelName:dke,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;aje(a,"MaxPoolWithArgmax");const c=u.data.get(a.dataId).values,d=cEe(a.shape,s,i,[1,1],o),[h,p]=function(e,t,n,r,a){const s=bGe(e,0,n,uxe(t),a,"max"),i=vGe(e,t,n,a,!0,r);return[s.values,i.values]}(c,a.shape,a.dtype,l,d),f=u.write(h,d.outShape,a.dtype),m=u.write(p,d.outShape,a.dtype);return[{dataId:f,shape:d.outShape,dtype:a.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};const dKe={kernelName:hke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=Jve(s,a.shape),l=Gve(xAe(a.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const d=Mje({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});u.push(d);const h=qHe({inputs:{a:d,b:c},backend:n});u.push(h);const p=SHe({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:i}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const hKe={kernelName:pke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;aje(a,"min");const o=Jve(s,a.shape);let l=o;const u=SAe(l,a.shape.length);let c=a;null!=u&&(c=tGe({inputs:{x:a},backend:n,attrs:{perm:u}}),l=CAe(l.length,a.shape.length)),kAe("min",l,c.shape.length);const[d,h]=xAe(c.shape,l),p=Gve(h),f=pxe(Gve(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=Vje({inputs:{x:g},backend:n,attrs:{shape:wAe(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},pKe=gje(((e,t)=>Math.min(e,t))),fKe=Oje(fke,pKe),mKe={kernelName:fke,backendName:"cpu",kernelFunc:fKe};const gKe={kernelName:mke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;aje(a,"mirrorPad");const o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),c="reflect"===i?0:1,d=n.data.get(a.dataId).values,h=a.shape.length,p=uxe(a.shape),f=Gve(o),m=o.length,g=uxe(o),y=exe(a.dtype,f);for(let b=0;b<f;b++){let e=yxe(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));const t=gxe(e,h,p);y[b]=d[t]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}},yKe=gje(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),bKe=Oje(gke,yKe),vKe={kernelName:gke,backendName:"cpu",kernelFunc:bKe};function xKe(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length;let o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Jve([o],a.shape),u=tKe({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=wAe(u.shape,l),d=Vje({inputs:{x:u},backend:n,attrs:{shape:c}}),h=QHe({inputs:{a:a,b:d},backend:n}),p=zHe({inputs:{x:h},backend:n}),f=SHe({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=Vje({inputs:{x:f},backend:n,attrs:{shape:c}}),g=qHe({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const wKe={kernelName:lSe,backendName:"cpu",kernelFunc:xKe};const kKe={kernelName:yke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;aje(a,"multinomial");const l=o?a:xKe({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,s],p=pxe(Gve(h),"int32");for(let f=0;f<u;++f){const e=f*c,t=new Float32Array(c-1);t[0]=d[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+d[e+a];const n=B_e.alea(i.toString()),r=f*s;for(let a=0;a<s;++a){const e=n();p[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+a]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}};function SKe(e,t,n){const r=uIe(-1,n);return vHe([],t,r,e,n)}const IKe={kernelName:vke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;aje(r,"neg");const a=n.data.get(r.dataId).values,[s,i]=SKe(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}},CKe=NRe;const NKe={kernelName:wke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;aje(a,"NonMaxSuppression");const u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d}=CKe(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},TKe=TRe;const EKe={kernelName:kke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;aje(a,"NonMaxSuppressionPadded");const c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=TKe(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},AKe=ERe;const _Ke={kernelName:Ske,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;aje(a,"NonMaxSuppressionWithScore");const c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=AKe(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},$Ke=gje(((e,t)=>e!==t?1:0)),RKe=Oje(xke,$Ke,null,"bool"),DKe={kernelName:xke,backendName:"cpu",kernelFunc:RKe};const MKe={kernelName:Cke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;aje(a,"oneHot");const u=Gve(a.shape),c=new Float32Array(u*i);c.fill(l);const d=n.data.get(a.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...a.shape,i],s,c)}};function FKe(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=$je({inputs:{input:r},backend:n}),t=FKe({inputs:{x:e},backend:n}),a=jGe({inputs:{input:r},backend:n}),s=FKe({inputs:{x:a},backend:n}),i=Eje({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return rqe({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const OKe={kernelName:$Se,backendName:"cpu",kernelFunc:FKe};const PKe={kernelName:Ike,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const t=$je({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=jGe({inputs:{input:a},backend:r}),i=FKe({inputs:{x:s},backend:r}),o=Eje({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return rqe({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function LKe(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return WHe({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Uve(s,e.shape,"All tensors passed to stack must have matching shapes"),Vve(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=HGe({inputs:t.map((e=>{const t=WHe({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const zKe={kernelName:Nke,backendName:"cpu",kernelFunc:LKe};const BKe={kernelName:Tke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;aje(a,"pad");const o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,c=Gve(a.shape),d=a.shape.length,h=uxe(a.shape),p=Gve(o),f=o.length,m=uxe(o),g=exe(a.dtype,p);0!==i&&g.fill(i);for(let y=0;y<c;y++){g[gxe(yxe(y,d,h).map(((e,t)=>e+l[t])),f,m)]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},WKe=gje(((e,t)=>Math.pow(e,t))),VKe=Oje(Eke,WKe),UKe={kernelName:Eke,backendName:"cpu",kernelFunc:VKe};function jKe(e,t,n,r){const[a,s]=xAe(e,r),i=WIe(t,"int32"),o=pxe(Gve(a),i),l=Gve(s);for(let u=0;u<o.length;++u){const e=u*l;let t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:a,outDtype:i}}const GKe={kernelName:_ke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;aje(a,"prod");const o=a.shape.length,l=Jve(s,a.shape),u=SAe(l,o);let c=l,d=a;const h=[];null!=u&&(d=tGe({inputs:{x:a},backend:n,attrs:{perm:u}}),h.push(d),c=CAe(c.length,o));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=jKe(d.shape,d.dtype,p,c);let y=m;return i&&(y=wAe(m,l)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function HKe(e,t,n,r){const a=[];let s=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){const a=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-a[r];for(let n=r;n<i;++n)o[s].push(a[n+1]+t)}r=a[r],i=a[i]}i!==r&&(a.push([r,i]),s+=i-r)}return{outSplits:o,valueSlices:a,numValues:s}}function qKe(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function KKe(e,t,n,r,a){const s=t.slice();s[0]=a;const i=txe(n,Gve(s)),o=e.length;return function(e,t,n,r,a,s){const i=qKe(t,2)[1],o=qKe(s,2)[1];let l=0;for(const u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)a[l*o+n]=e[t*i+n];++l}}(e,t,r,0===o?0:o/t[0],i,s),[i,s]}function XKe(e,t,n,r,a,s,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const a=yxe(r,t.length,uxe(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(s,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:c,numValues:d}=HKe(s,i,e,l),h=function(e){const t=[];for(let n=0;n<e.length;++n){const r=txe("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(u),p=KKe(n,r,a,c,d);return[h,p[0],p[1]]}const YKe={kernelName:$ke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.data.get(e.dataId).values)),u=a.map((e=>e.shape)),c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=XKe(l,u,c,s.shape,s.dtype,d,i.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}},QKe=2147483647;function JKe(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===a.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(a[0]),u||c.push(i[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=txe("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const t=o?e[0]:e[m],n=l?r[0]:r[m],a=u?s[0]:s[m];if(0===a)throw new Error("Requires delta != 0");let i;if(a>0&&n<t||a<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/a)),i>QKe)throw new Error(`Requires ((limit - start) / delta) <= ${QKe}`);h[m+1]=h[m]+i}const p=txe(n,h[d]);let f=0;for(let m=0;m<d;++m){const t=h[m+1]-h[m];let n=o?e[0]:e[m];const r=u?s[0]:s[m];for(let e=0;e<t;++e)p[f++]=n,n+=r}return[h,p]}const ZKe={kernelName:Rke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=JKe(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var eXe=kDe;class tXe{constructor(e,t,n,r,a,s,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=IDe(u),this.raggedRank=CDe(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===eXe.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===eXe.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case eXe.VALUE_ROWIDS:return tXe.getMaxWidthValueRowID(t);case eXe.ROW_SPLITS:return tXe.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${eXe[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){const t=e[s];t!==r&&(r=t,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return rXe(e,n)}calculateOutputSize(e){const t=this.valuesShape;NDe(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=SDe(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let a=1;a<=this.raggedRank;++a)r[a]<0&&(r[a]=this.getMaxWidth(a));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),a=[];let s=0;for(let i=0;i<r;++i,s+=t)a.push(s);for(let i=r;i<e;++i)a.push(-1);return Vve(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){const a=e.length,s=[];for(let i=0;i<a-1;++i){const a=e[i+1]-e[i];let o=Math.min(r,a),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)s.push(l),l+=n;for(let e=0;e<a-o;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){const a=e.length,s=[];if(0===a)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let u=1;u<a;++u){const a=e[u];if(a===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}s.push(l)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){const a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case eXe.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case eXe.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${eXe[s]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case eXe.FIRST_DIM_SIZE:return e[0];case eXe.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case eXe.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${eXe[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];const r=rXe(t,!1),a=txe(this.valuesDType,Gve(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){s=this.calculateOutputIndex(e-1,s,n[e],t[e])}this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;const a=this.values,s=n;let i=r.slice();i=i.slice(e+1);const o=Gve(i),l=t.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const e=this.defaultValueShape;vCe((()=>{const t=IEe(u,e),n=WEe(t,i);u=n.dataSync()}))}let c=0,d=0,h=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==h){if(d<h){const e=a.subarray(c*o);nXe(s.subarray(d*o),e,(h-d)*o)}if(p>=l){const t=n.length;e=Math.floor(t/o)}if(e>h)if(1===this.defaultValue.length)s.subarray(h*o,e*o).fill(this.defaultValue[0]),h=e;else for(;e>h;){nXe(s.slice(h*o),u,o),++h}e<0?(c=p+1,d=h):(c=p,d=h,h=d+1)}else++h}}}function nXe(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function rXe(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function aXe(e,t,n,r,a,s,i,o,l,u){return new tXe(e,t,n,r,a,s,i,o,l,u).compute()}const sXe={kernelName:Dke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,h=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=aXe(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}};function iXe(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return pxe(0,r);const a=pxe(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+n;return a}const oXe={kernelName:Mke,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=iXe(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}},lXe=lje(Oke,(e=>1/e)),uXe={kernelName:Oke,backendName:"cpu",kernelFunc:lXe};const cXe={kernelName:Wke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;aje(a,"resizeBilinear");const l=uxe(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(Gve([d,u,c,f])),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<d;k++)for(let e=0;e<u;e++){let t;t=i?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(h-1,Math.ceil(t)),s=k*l[0]+n*l[1],o=k*l[0]+a*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(p-1,Math.ceil(t)),c=s+n*l[2],d=o+n*l[2],h=s+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[d+e],s=t+(m[h+e]-t)*a,i=s+(n+(m[y+e]-n)*a-s)*r;g[v++]=i}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}};const dXe={kernelName:Vke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;aje([s,a],"resizeBilinearGrad");const o=uxe(a.shape),[l,u,c,d]=a.shape,[,h,p]=s.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(s.dataId).values;let x=0;for(let w=0;w<l;w++){const e=w*o[0];for(let t=0;t<h;t++){const n=t*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=e+r*o[1],i=e+a*o[1],l=n-r,h=1-l;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),a=t-n,u=1-a,p=s+n*o[2],m=s+r*o[2],g=i+n*o[2],y=i+r*o[2],w=h*u,k=h*a,S=l*u,I=l*a;for(let e=0;e<d;e++){const t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*I}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}};const hXe={kernelName:zke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;aje(a,"resizeNearestNeighbor");const l=uxe(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(d*u*c*f),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let k=0;k<d;k++){const e=k*l[0];for(let t=0;t<u;t++){const n=i?v*(t+.5):v*t;let r=Math.min(h-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const a=e+r*l[1];for(let e=0;e<c;e++){const t=i?x*(e+.5):x*e;let n=Math.min(p-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=a+n*l[2];for(let e=0;e<f;e++){const t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([d,u,c,f],a.dtype,g)}};const pXe={kernelName:Bke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;aje([s,a],"resizeNearestNeighborGrad");const o=uxe(a.shape),l=uxe(s.shape),[u,c,d,h]=a.shape,[,p,f]=s.shape,m=new Float32Array(u*c*d*h),g=n.data.get(s.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let C=0;C<u;C++){const e=C*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*w),a=Math.floor(r-S/2);for(let s=0;s<d;s++){const r=n+s*o[2],u=Math.floor(s*k),y=Math.floor(u-I/2);for(let n=0;n<h;n++){let o=0;for(let r=0;r<S;r++){const u=r+a;if(u<0||u>=p)continue;const h=e+u*l[1],m=u*v;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){const t=e+y;if(t<0||t>=f)continue;const r=h+t*l[2],a=t*x;s===Math.min(d-1,i?Math.round(a):Math.floor(a))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}};const fXe={kernelName:jke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;aje(a,"reverse");const i=a.shape.length,o=Jve(s,a.shape);if(0===i)return hje({inputs:{x:a},backend:n});const l=new EIe(a.shape,a.dtype),u=n.bufferSync(a);for(let c=0;c<l.size;c++){const e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},mXe={kernelName:MSe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=exe(a.dtype,Gve(a.shape)),[c,d,h,p]=a.shape,[f,m]=ADe(o,d,h),g=Math.sin(s),y=Math.cos(s),b=l.data.get(a.dataId).values;for(let v=0;v<c;v++){const e=v*h*d*p;for(let t=0;t<d;t++){const n=t*(h*p);for(let r=0;r<h;r++){const a=r*p;for(let s=0;s<p;s++){const o=[c,t,r,s],l=o[2],v=o[1];let x=(l-f)*y-(v-m)*g,w=(l-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=i;if("number"!==typeof i&&(k=3===s?255:i[s]),x>=0&&x<h&&w>=0&&w<d){k=b[e+w*(h*p)+x*p+s]}u[e+n+a+s]=k}}}}return{dataId:l.write(u,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},gXe=lje(Gke,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),yXe={kernelName:Gke,backendName:"cpu",kernelFunc:gXe},bXe=oje((e=>1/Math.sqrt(e))),vXe=uje(Hke,bXe),xXe={kernelName:Hke,backendName:"cpu",kernelFunc:vXe};function wXe(e,t,n,r,a,s,i,o,l,u){const c=[r/a,a],d=e.values,h=t.values;if(0===r)return TNe(n,t.dtype);const p=l instanceof EIe?l:TNe(c,t.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<s;f++){const e=[];let s=0;for(let t=0;t<i;t++){const n=d[f*i+t];e.push(n),s+=n*o[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?p.values[s*a+n]+=h[f*a+n]:p.values[s*a+n]=0===t.rank?h[0]:h[f*a+n]}return p}const kXe={kernelName:qke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=O$e(0,a,i),h=wXe(n.bufferSync(a),n.bufferSync(s),i,d,u,l,o,c,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function SXe(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function IXe(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}const CXe={kernelName:Xke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=function(e,t,n,r,a,s){const i=txe("int32",n*a);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?SXe(n,t[e+l]):IXe(n,t[e+l])}return i}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",o)}};const NXe={kernelName:Yke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;aje([r,a,s],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=WIe(a.dtype,s.dtype),d=pxe(Gve(a.shape),c);let h=0;const p=0===i||i>1||1===a.shape.length?1:Gve(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(a.shape,c,d)}},TXe=ODe,EXe=PDe,AXe=lje(Qke,(e=>e>=0?EXe*e:TXe*(Math.exp(e)-1))),_Xe={kernelName:Qke,backendName:"cpu",kernelFunc:AXe},$Xe=lje(tSe,(e=>e<0?-1:e>0?1:0)),RXe={kernelName:tSe,backendName:"cpu",kernelFunc:$Xe},DXe=lje(Zke,(e=>Math.sin(e))),MXe={kernelName:Zke,backendName:"cpu",kernelFunc:DXe},FXe=lje(eSe,(e=>Math.sinh(e))),OXe={kernelName:eSe,backendName:"cpu",kernelFunc:FXe},PXe=Math.log(1.1920928955078125e-7)+2,LXe=lje(rSe,(e=>{const t=e>-PXe,n=e<PXe,r=Math.exp(e);let a;return a=n?r:t?e:Math.log(1+r),a})),zXe={kernelName:rSe,backendName:"cpu",kernelFunc:LXe};const BXe={kernelName:iSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;aje([a],"spaceToBatchND");const o=Gve(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);const u=BKe.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=_De(u.shape,s,o,!1),d=$De(c.length,s.length,!1),h=RDe(u.shape,s,o,!1),p=Vje({inputs:{x:u},backend:n,attrs:{shape:c}}),f=tGe({inputs:{x:p},backend:n,attrs:{perm:d}}),m=Vje({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function WXe(e,t,n,r,a,s,i){const o=t[0],l=s[0],u=new Array(l),c=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(uMe(o));return[txe(n,0),[0,d],txe(a,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<o;++g){const t=e[g*d];if(t<0)throw new Error(cMe(g,t));if(t>=l)throw new Error(dMe(g,t,l));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<l;++g){const e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,d],n,u,c]}{const t=f[l-1],s=txe(n,t*d),h=txe(a,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){const t=e[n*d],a=p[t],i=(0===t?0:f[t-1])+a;p[t]++;for(let r=0;r<d;++r)s[i*d+r]=e[n*d+r];h[i]=r[n],c[n]=i}for(let e=0;e<l;++e){if(0===p[e]){const t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;h[t]=i}}return[s,[t,d],h,u,c]}}const VXe={kernelName:uSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=WXe(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function UXe(e,t,n,r,a){const s=Gve(r),i=t[0],o=a.length,l=[];let u=1,c=-1;for(let m=0;m<o;++m){const e=a[m];if(-1===e){if(-1!==c)throw new Error(hMe(c,m));c=m,l.push(1)}else{if(e<0)throw new Error(pMe(m,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(s/u);if(u*e!==s)throw new Error(mMe(r,l));l[c]=e}if(Gve(l)!==s)throw new Error(gMe(r,l));const d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=txe(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],l]}const jXe={kernelName:cSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,d]=UXe(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};function GXe(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?a[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=c;const h=txe(n,d.reduce(((e,t)=>e*t),1));if(0===o)return c>0&&h.fill(i),[h,d];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=a[p];for(;;){let t=0;if(f<o){if(t=a[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(vMe(g,c));g>m&&h.fill(i,m*u,g*u);for(let n=p;n<f;++n){const t=r[n];if(t<0||t>=l[0])throw new Error(xMe(n,r[n],l[0]));for(let n=0;n<u;n++)h[g*u+n]+=e[t*u+n]}if(s)for(let e=0;e<u;e++)h[g*u+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>o)break}return m<c&&h.fill(i,m*u,c*u),[h,d]}const HXe={kernelName:dSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=GXe(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const qXe={kernelName:hSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=GXe(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const KXe={kernelName:pSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=O$e(0,a,o),p=!1,f=n.bufferSync(a);let m;switch(s.dtype){case"bool":m=wXe(f,n.bufferSync(s),o,h,c,u,l,d,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":m=wXe(f,n.bufferSync(s),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"int32":m=wXe(f,n.bufferSync(s),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"string":m=wXe(f,n.bufferSync(s),o,h,c,u,l,d,fIe(n.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}};const XXe={kernelName:oSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Jve(i,a.shape)[0],l=lMe(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{const t=[...c];t[o]=e;const r=TGe({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},YXe=oje((e=>Math.sqrt(e))),QXe=lje(aSe,(e=>Math.sqrt(e))),JXe={kernelName:aSe,backendName:"cpu",kernelFunc:QXe},ZXe={kernelName:mSe,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:r}=t,a=n;aje(r,"square");const s=a.data.get(r.dataId).values,i=new Float32Array(s.length);for(let o=0;o<s.length;++o){const e=s[o];i[o]=e*e}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},eYe=gje(((e,t)=>{const n=e-t;return n*n})),tYe=Oje(fSe,eYe),nYe={kernelName:fSe,backendName:"cpu",kernelFunc:tYe},rYe=oje(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),aYe=uje(gSe,rYe),sYe={kernelName:gSe,backendName:"cpu",kernelFunc:aYe},iYe=lje(RSe,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),oYe={kernelName:RSe,backendName:"cpu",kernelFunc:iYe};function lYe(e,t,n,r){const a=TNe(e,t.dtype);for(let s=0;s<a.size;s++){const e=a.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}const uYe={kernelName:ySe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;aje(a,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=XTe(a.shape,s,i,o,l,u,c,d,h);let w;if(m)w=Vje({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){Vve(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=OTe(b,v,x),t=TGe({inputs:{x:a},backend:n,attrs:{begin:b,size:e}});w=Vje({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=lYe(p,n.bufferSync(a),x,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class cYe{constructor(e,t,n,r,a,s){this.separator=pIe(e),this.nGramWidths=t,this.leftPad=pIe(n),this.rightPad=pIe(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){const o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),c=s-(l+u),d=t+(l>0?0:i-o);let h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length;h+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(h);const p=n[r+i];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const a=r-1,s=txe("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[e,s]}s[0]=0;for(let o=1;o<=a;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[o]=s[o-1]+n}const i=new Array(s[a]);for(let o=0;o<a;++o){const n=t[o];let r=s[o];if(this.nGramWidths.forEach((a=>{const s=t[o+1]-t[o],l=this.getNumNGrams(s,a);this.createNGrams(e,n,i,r,l,a),r+=l})),this.preserveShort&&r===s[o]){const a=t[o+1]-t[o];if(0===a)continue;const s=a+2*this.padWidth,l=1;this.createNGrams(e,n,i,r,l,s)}}return[i,s]}}function dYe(e,t,n,r,a,s,i,o){return new cYe(n,r,a,s,i,o).compute(e,t)}const hYe={kernelName:bSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=dYe(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};function pYe(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const a=t[0];let s=e.indexOf(a);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||r.push(t),s=(e=e.subarray(s+1)).indexOf(a)}return void(n&&0===e.length||r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(a,s);n&&0===t.length||r.push(t),a=s+1}}function fYe(e,t,n){const r=e.length,a=[];let s=0,i=0;const o=new Array(r);for(let h=0;h<r;++h){const r=a.length;pYe(e[h],t,n,a);const l=a.length-r;o[h]=l,s+=l,i=Math.max(i,l)}const l=txe("int32",2*s),u=new Array(s),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let e=0;e<o[h];++e)l[2*d]=h,l[2*d+1]=e,u[d]=a[d],++d;return[l,u,c]}const mYe={kernelName:vSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=fYe(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function gYe(e,t){const n=txe("int32",e.length);for(let r=0;r<e.length;++r)n[r]=lIe(e[r]).modulo(t).getLowBitsUnsigned();return n}const yYe={kernelName:xSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=gYe(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",i)}},bYe=lje(kSe,(e=>Math.tan(e))),vYe={kernelName:kSe,backendName:"cpu",kernelFunc:bYe},xYe=lje(SSe,(e=>Math.tanh(e)));const wYe={kernelName:Kke,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=O$e(0,a,r.shape),d=n.bufferSync(a),h=n.bufferSync(s),p=n.bufferSync(r),f=wXe(d,h,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function kYe(e,t){const n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];const r=TNe(n,e.dtype);for(let a=0;a<r.values.length;++a){const t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const s=e.locToIndex(n);r.values[a]=e.values[s]}return r}const SYe={kernelName:ISe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;aje(a,"tile");const i=kYe(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},IYe=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function CYe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){const a=r-n+1,s=t-n+1,i=Math.log(a),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(a-o)/a)*Math.sign(s-a/2);CYe(e,t,Math.max(n,Math.floor(t-s*o/a+l)),Math.min(r,Math.floor(t+(a-s)*o/a+l)))}const a=e[t];let s=n,i=r;for(Wve(e,n,t),IYe(e[r],a)>0&&Wve(e,n,r);s<i;){for(Wve(e,s,i),s++,i--;IYe(e[s],a)<0;)s+=1;for(;IYe(e[i],a)>0;)i-=1}0===IYe(e[n],a)?Wve(e,n,i):(i+=1,Wve(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function NYe(e,t,n,r,a){const s=t[t.length-1],[i,o]=[e.length/s,s],l=exe(n,i*r),u=exe("int32",i*r);for(let d=0;d<i;d++){const t=d*o,n=e.subarray(t,t+o);let s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(CYe(s,r),s=s.slice(0,r)),a&&s.sort(IYe);const i=d*r,c=l.subarray(i,i+r),h=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=s[e].value,h[e]=s[e].index}const c=t.slice();return c[c.length-1]=r,[TNe(c,n,l),TNe(c,"int32",u)]}const TYe={kernelName:CSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;aje(a,"topk");const o=n.data.get(a.dataId).values,[l,u]=NYe(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};const EYe={kernelName:NSe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=[c,f,m,p],y=uxe(a.shape),b=y[0],v=y[1],x=y[2],w=uxe(g),k=w[0],S=w[1],I=w[2],C=exe(a.dtype,Gve(g));C.fill(l);const N=r.data.get(a.dataId).values,T=r.data.get(s.dataId).values;for(let E=0;E<c;++E){const e=1===s.shape[0]?T:T.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let a;const s=e[6]*n+e[7]*t+1;if(0===s)continue;const u=(e[0]*n+e[1]*t+e[2])/s,c=(e[3]*n+e[4]*t+e[5])/s,p=AYe(u,h,o),f=AYe(c,d,o);switch(i){case"nearest":a=$Ye(N,d,h,b,v,x,E,f,p,r,l);break;case"bilinear":a=RYe(N,d,h,b,v,x,E,f,p,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}C[E*k+t*S+n*I+r]=a}return r.makeTensorInfo(g,a.dtype,C)}return{dataId:r.write(C,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function AYe(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return zve(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return zve(0,n,t-1)}(e,t);case"nearest":return function(e,t){return zve(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function _Ye(e,t,n,r,a,s,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*a+l*s+u]:c}function $Ye(e,t,n,r,a,s,i,o,l,u,c){return _Ye(e,t,n,r,a,s,i,Math.round(o),Math.round(l),u,c)}function RYe(e,t,n,r,a,s,i,o,l,u,c){const d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1;return(p-o)*((f-l)*_Ye(e,t,n,r,a,s,i,d,h,u,c)+(l-h)*_Ye(e,t,n,r,a,s,i,d,f,u,c))+(o-d)*((f-l)*_Ye(e,t,n,r,a,s,i,p,h,u,c)+(l-h)*_Ye(e,t,n,r,a,s,i,p,f,u,c))}function DYe(e,t,n,r){const a=Jve(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];const i=new Map,o=new Int32Array(n[a]),l=new EIe(s,r,e),u=[],c=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(l.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,u.push(f)}}const d=s.slice();d[1]=i.size;const h=new EIe(d,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)h.set(l.get(n,e,r),n,t,r)}));const p=n.slice();return p[a]=d[1],{outputValues:h.values,outputShape:p,indices:o}}const MYe={kernelName:ESe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;aje(s,"unique");const i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=DYe(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const FYe={kernelName:ASe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const i=a.shape.length,o=a.shape[s],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==s&&(l[u++]=a.shape[p]);const c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;const h=new Array(o);for(let p=0;p<h.length;p++){c[s]=p;const e=TGe({inputs:{x:a},backend:n,attrs:{begin:c,size:d}});h[p]=Vje({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return h}};const OYe={kernelName:_Se,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;aje(a,"unsortedSegmentSum");const o=[],l=[],u=a.shape.length-s.shape.length;let c=s;for(let h=0;h<u;++h){const e=WHe({inputs:{input:c},backend:n,attrs:{dim:h+1}});c=e,l.push(e)}for(let h=0;h<i;++h){const e=uIe(h,"int32"),t=n.makeTensorInfo([],"int32",e),r=EHe({inputs:{a:t,b:c},backend:n}),s=Mje({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=wHe({inputs:{a:s,b:a},backend:n}),u=SHe({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(s),l.push(i),l.push(u)}const d=LKe({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},PYe=[Hje,Kje,Yje,Jje,Wje,Zje,rGe,aGe,sGe,iGe,lGe,cGe,hGe,mGe,yGe,wGe,kGe,SGe,IGe,Gje,CGe,AGe,RGe,FGe,OGe,Fje,zGe,WGe,Aje,VGe,qGe,XGe,YGe,QGe,JGe,ZGe,eHe,nHe,aHe,sHe,iHe,oHe,lHe,uHe,dHe,hHe,pHe,fHe,mHe,gHe,yHe,bHe,CHe,dje,NHe,AHe,PHe,BHe,VHe,GHe,nqe,aqe,sqe,lqe,dqe,hqe,pqe,mqe,yqe,xqe,Sqe,pje,Iqe,GGe,Nqe,Eqe,_qe,mje,Dqe,Oqe,Lqe,Wqe,Uqe,Hqe,Kqe,Qqe,Jqe,Zqe,nKe,sKe,iKe,oKe,lKe,uKe,cKe,dKe,hKe,mKe,gKe,vKe,kKe,kHe,IKe,NKe,EKe,_Ke,DKe,MKe,PKe,zKe,BKe,UKe,vje,GKe,YKe,ZKe,sXe,oXe,Rje,KHe,uXe,wje,Sje,Uje,cXe,dXe,hXe,pXe,fXe,mXe,yXe,xXe,kXe,CXe,NXe,_Xe,Nje,RXe,MXe,OXe,EGe,wKe,zXe,BXe,VXe,jXe,HXe,qXe,KXe,XXe,JXe,ZXe,nYe,sYe,oYe,uYe,hYe,mYe,yYe,JHe,IHe,vYe,{kernelName:SSe,backendName:"cpu",kernelFunc:xYe},wYe,SYe,TYe,EYe,nGe,MYe,FYe,OYe,OKe];for(const n of PYe)GSe(n);const LYe={},zYe={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function BYe(e,t){if(!(e in LYe)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(kxe().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete LYe[e]}),!1),kxe().getBool("SOFTWARE_WEBGL_ENABLED")&&(zYe.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",zYe)||n.getContext("experimental-webgl",zYe);return n.getContext("webgl2",zYe)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;LYe[e]=n}const n=LYe[e];return null==n||n.isContextLost()?(delete LYe[e],BYe(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),LYe[e])}var WYe,VYe,UYe;function jYe(e,t){return[t,e]}function GYe(e){const t=Gve(e);return Kve(Math.ceil(t/4))}function HYe(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function qYe(e,t){const n=e;let r,a,s,i,o,l,u,c,d,h;return 2===kxe().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function KYe(e,t){const n=t();return kxe().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(WYe||(WYe={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(VYe||(VYe={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(UYe||(UYe={}));function XYe(e){return!!(kxe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function YYe(e,t){return sQe(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const QYe=/ERROR: [0-9]+:([0-9]+):/g;function JYe(e,t){const n=QYe.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map(((e,t)=>Xve((t+1).toString(),s)+e));let o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Xve(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function ZYe(e,t){if(KYe(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function eQe(e,t,n,r,a,s,i){const o=e.getAttribLocation(t,n);return-1!==o&&(KYe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),KYe(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i))),KYe(e,(()=>e.enableVertexAttribArray(o))),!0)}function tQe(e,t,n,r){KYe(e,(()=>function(e,t,n){iQe(e,n),KYe(e,(()=>e.activeTexture(e.TEXTURE0+n))),KYe(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),KYe(e,(()=>e.uniform1i(n,r)))}function nQe(e,t,n){KYe(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),KYe(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function rQe(e,t){KYe(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),KYe(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function aQe(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function sQe(e,t,n){const r=KYe(e,(()=>t()));if(null==r)throw new Error(n);return r}function iQe(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function oQe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Gve(e.slice(0,e.length-t))}function lQe(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function uQe(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[oQe(e),...lQe(e)]),t}function cQe(e){return e%2===0}function dQe(e,t){if(Hve(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(cQe(n)&&cQe(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&cQe(e[0])&&cQe(t[0])}let hQe,pQe;function fQe(e,t){return null!=e.getExtension(t)}function mQe(e){try{if(null!=BYe(e))return!0}catch(gD){return console.log("Error when getting WebGL context: ",gD),!1}return!1}function gQe(e){if(0===e)return!1;const t=BYe(e);if(1!==e){if(fQe(t,"EXT_color_buffer_float"))return yQe(t);const e="EXT_color_buffer_half_float";if(fQe(t,e)){const n=t.getExtension(e);return function(e,t){const n=qYe(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const a=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}(t,n)}return!1}if(!fQe(t,"OES_texture_float"))return!1;if(!fQe(t,"WEBGL_color_buffer_float"))return!1;return yQe(t)}function yQe(e){const t=qYe(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function bQe(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Vve("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const vQe=kxe();function xQe(){let e,t,n,r,a,s,i,o,l,u;return 2===kxe().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=kxe().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function wQe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=uxe(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${t}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function kQe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=uxe(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / outShapeStrides[${a}]`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function SQe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${r[a]}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}function IQe(e){const t=uxe(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}vQe.registerFlag("HAS_WEBGL",(()=>vQe.getNumber("WEBGL_VERSION")>0)),vQe.registerFlag("WEBGL_VERSION",(()=>mQe(2)?2:mQe(1)?1:0)),vQe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),vQe.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===vQe.get("WEBGL_VERSION"))),vQe.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),vQe.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),vQe.registerFlag("WEBGL_PACK",(()=>vQe.getBool("HAS_WEBGL"))),vQe.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>vQe.getBool("WEBGL_PACK"))),vQe.registerFlag("WEBGL_PACK_CLIP",(()=>vQe.getBool("WEBGL_PACK"))),vQe.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>vQe.getBool("WEBGL_PACK"))),vQe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>vQe.getBool("WEBGL_PACK"))),vQe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>vQe.getBool("WEBGL_PACK"))),vQe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>vQe.getBool("WEBGL_PACK"))),vQe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>vQe.getBool("WEBGL_PACK"))),vQe.registerFlag("WEBGL_PACK_REDUCE",(()=>vQe.getBool("WEBGL_PACK"))),vQe.registerFlag("WEBGL_LAZILY_UNPACK",(()=>vQe.getBool("WEBGL_PACK"))),vQe.registerFlag("WEBGL_CONV_IM2COL",(()=>vQe.getBool("WEBGL_PACK"))),vQe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>vQe.getBool("WEBGL_PACK"))),vQe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==hQe){const t=BYe(e);hQe=t.getParameter(t.MAX_TEXTURE_SIZE)}return hQe}(vQe.getNumber("WEBGL_VERSION")))),vQe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==pQe){const t=BYe(e);pQe=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,pQe)}(vQe.getNumber("WEBGL_VERSION")))),vQe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=vQe.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=BYe(e);return t=fQe(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:fQe(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),vQe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>vQe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!nCe())),vQe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=BYe(e);if(1===e){if(!fQe(t,"OES_texture_float"))return!1}else if(!fQe(t,"EXT_color_buffer_float"))return!1;return yQe(t)}(vQe.getNumber("WEBGL_VERSION")))),vQe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!vQe.getBool("WEBGL_FORCE_F16_TEXTURES")&&vQe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),vQe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>gQe(vQe.getNumber("WEBGL_VERSION")))),vQe.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=vQe.getNumber("WEBGL_VERSION"))&&null!=BYe(e).fenceSync;var e})),vQe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>vQe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),vQe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),vQe.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>nCe()?1:-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),vQe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),vQe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),vQe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),vQe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),vQe.registerFlag("WEBGL_EXP_CONV",(()=>!1)),vQe.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>vQe.getBool("IS_TEST"))),vQe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),vQe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),vQe.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),vQe.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const CQe="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:NQe}=s;function TQe(e,t,n){const r=[];if(e.forEach((e=>{const t=Gve(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=LQe(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const a=r.join("\n"),s=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?AQe(e,r):EQe(e,r);const s=e.shapeInfo.logicalShape,i=t.logicalShape;s.length<=i.length&&(a+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=NQe(e.shapeInfo.logicalShape,t.logicalShape),l=PQe(i),u=i-s;let c;const d=["x","y","z","w","u","v"];c=0===s?"":i<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${d[e+u]} = 0;`)).join("\n");let h="";h=i<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+u]}`)).join(", ");let p="return outputValue;";const f=1===Gve(e.shapeInfo.logicalShape),m=Gve(t.logicalShape),g=1===m;if(1!==s||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=s-2,t=s-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${a}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&Hve(i,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=PQe(l),c=NQe(e.shapeInfo.logicalShape,t.logicalShape),d=l-o;let h;const p=["x","y","z","w","u","v"];h=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+d]} = 0;`)).join("\n");let f="";f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+d]}`)).join(", ");return`\n    float ${a}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${f});\n    }\n  `}(e,t));return a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,o=xQe(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,d=function(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${_Qe}\n    ${$Qe}\n    ${RQe}\n  `;return t}(o);t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return MQe();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Hve(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const a=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2);let i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function(e,t,n){switch(e.length){case 0:return MQe();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(Hve(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${kQe(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=wQe(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${kQe(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=wQe(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=wQe(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=wQe(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(d+=DQe);return[d,l,c,a,u,s,n.userCode].join("\n")}function EQe(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=FQe(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${OQe(e)}\n      }\n    `;const a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=FQe(n);if(1===i)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===s)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&Hve(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=s[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=Zve(n),l=i;if(l.length<n.length){const n=["row","col"];return`\n      ${EQe(zQe(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${BQe(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${OQe(e)}\n      }\n    `;const u=s[0],c=s[1],d=FQe(r);if(1===c)return t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===u)return t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Zve(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${EQe(zQe(e,u),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${BQe(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${OQe(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=FQe(r);if(t)return`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=Zve(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${EQe(zQe(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${BQe(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${OQe(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===s&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=FQe(r);if(t)return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=Zve(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${EQe(zQe(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${BQe(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${a})) +\n          depth3;\n        ${OQe(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=FQe(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=Zve(t);if(a.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${EQe(zQe(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${BQe(t,s)});\n      }\n    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${OQe(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=FQe(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function AQe(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=xQe();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=xQe();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=xQe();if(null!=s&&Hve(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=[1,2],s=["b","row","col"];return`\n        ${AQe(zQe(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${BQe(s,r)});\n        }\n      `}const o=xQe();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=xQe();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;const s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(s[i-1]/2);let h=d*Math.ceil(s[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=s[i-m-1],f=`b${m} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const _Qe="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$Qe="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",RQe="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",DQe="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function MQe(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function FQe(e){return`offset${e}`}function OQe(e){const t=e.name,n=Gve(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function PQe(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function LQe(e,t,n){const{newShape:r,keptDims:a}=Zve(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!Hve(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function zQe(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function BQe(e,t){return t.map((t=>e[t])).join(", ")}function WQe(e,t,n,r){const a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=TQe(a,i,t),l=function(e,t){const n=sQe(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(KYe(e,(()=>e.shaderSource(n,t))),KYe(e,(()=>e.compileShader(n))),kxe().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw JYe(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),u=e.createProgram(l);return kxe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},VQe(e,t,u)))}function VQe(e,t,n){const r=[],a=[];let s,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===kxe().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const d of t.variableNames){const a={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${d}Shape`,c),a.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),r.push(a)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const d of t.customUniforms)a.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function UQe(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,a=t[n],s=a.shape;if(!Hve(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;const i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!Hve(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function jQe(e){return kxe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class GQe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=WYe.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=xQe();this.outputShape=e,this.enableShapeUniforms=jQe(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?kQe(["r","c","d"],e):wQe(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class HQe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=WYe.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=xQe();this.outputShape=e,this.enableShapeUniforms=jQe(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?kQe(["r","c","d"],e):wQe(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class qQe{constructor(e){this.variableNames=["A"],this.outTexUsage=VYe.DOWNLOAD;const t=xQe();this.outputShape=e,this.userCode=`\n      ${CQe}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class KQe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=VYe.DOWNLOAD;const t=xQe();this.outputShape=e,this.userCode=`\n      ${CQe}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const XQe={R:0,G:1,B:2,A:3};class YQe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=xQe();this.outputShape=e,this.enableShapeUniforms=jQe(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){const e=n[i];s+=`\n          if(offset == ${i}) {\n            result = values[${XQe[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":IQe(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${s}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class QQe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=xQe();this.outputShape=e,this.enableShapeUniforms=jQe(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){const a=2*s+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":IQe(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}}function JQe(e){const t=xQe();return function(e,t){const n=sQe(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(KYe(e,(()=>e.shaderSource(n,t))),KYe(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function ZQe(e){return function(e,t){const n=sQe(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return KYe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),KYe(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function eJe(e){return function(e,t){const n=sQe(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return KYe(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),KYe(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function tJe(e,t,n,r,a,s){!function(e,t){const n=kxe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return sQe(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return KYe(e,(()=>e.bindTexture(o,i))),KYe(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),KYe(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),KYe(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),KYe(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===kxe().getNumber("WEBGL_VERSION")?KYe(e,(()=>e.texImage2D(o,0,r,t,n,0,a,s,null))):KYe(e,(()=>e.texStorage2D(o,1,r,t,n))),KYe(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function nJe(e){return e.internalFormatFloat}function rJe(e){return e.internalFormatHalfFloat}function aJe(e){return e.downloadTextureFormat}function sJe(e){return e.internalFormatPackedFloat}function iJe(e){return e.internalFormatPackedHalfFloat}function oJe(e,t,n,r,a,s,i,o){const l=e,u=new Float32Array(function(e,t){const[n,r]=HYe(e,t);return n*r*4}(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}class lJe{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=kxe().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){LYe[e]=t}(t,e)):this.gl=BYe(t),e=this.gl,2===kxe().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>KYe(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>KYe(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>KYe(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>KYe(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>KYe(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>KYe(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>KYe(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>KYe(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===kxe().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=YYe(this.gl,e),fQe(this.gl,t))this.textureHalfFloatExtension=YYe(this.gl,t);else if(kxe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),fQe(this.gl,r))this.colorBufferHalfFloatExtension=YYe(this.gl,r);else if(kxe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",fQe(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!fQe(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=ZQe(this.gl),this.indexBuffer=eJe(this.gl),this.framebuffer=function(e){return sQe(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=qYe(this.gl,this.textureHalfFloatExtension)}get debug(){return kxe().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;KYe(e,(()=>e.finish())),KYe(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),KYe(e,(()=>e.deleteFramebuffer(this.framebuffer))),KYe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),KYe(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),KYe(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=jYe(t,n);return tJe(e,a,s,nJe(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=jYe(t,n);return tJe(e,a,s,rJe(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=jYe(t,n);return tJe(e,a,s,aJe(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){KYe(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===kxe().getNumber("WEBGL_VERSION")?KYe(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):KYe(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===kxe().getNumber("WEBGL_VERSION")?KYe(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):KYe(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),KYe(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,a,s){let i,o,l;KYe(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===kxe().getNumber("WEBGL_VERSION")?KYe(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):KYe(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),KYe(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=HYe(t,n);return tJe(e,a,s,iJe(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=HYe(t,n);return tJe(e,a,s,sJe(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(rQe(this.gl,this.framebuffer),this.outputTexture=null),KYe(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[a,s]=jYe(t,n),i=new Uint8Array(t*n*4);return KYe(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return oJe(this.gl,e,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();KYe(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const a=16*t*n;return KYe(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ))),KYe(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),KYe(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(kxe().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return KYe(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=JQe(t));const n=function(e){return sQe(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);KYe(t,(()=>t.attachShader(n,this.vertexShader))),KYe(t,(()=>t.attachShader(n,e))),function(e,t){if(KYe(e,(()=>e.linkProgram(t))),!kxe().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&ZYe(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;KYe(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){KYe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),eQe(e,t,"clipSpacePos",n,3,20,0)&&eQe(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(KYe(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&ZYe(this.gl,this.program),KYe(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return sQe(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),KYe(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),tQe(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=HYe(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&ZYe(this.gl,this.program),aQe(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}KYe(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),KYe(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=YYe(this.gl,2===kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Yve((()=>this.disposed||this.isQueryAvailable(e,kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in kxe().platform&&(n=kxe().platform.setTimeoutCustom.bind(kxe().platform)),Yve((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),nQe(this.gl,e,this.framebuffer),this.debug&&aQe(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(nQe(this.gl,this.outputTexture,this.framebuffer),this.debug&&aQe(this.gl)):rQe(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;nQe(r,e,this.framebuffer),this.debug&&aQe(r),this.outputTexture=e,KYe(r,(()=>r.viewport(0,0,t,n))),KYe(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),KYe(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:uJe,XI:cJe,Nk:dJe,f6:hJe,ct:pJe,YG:fJe,hH:mJe,z3:gJe,sG:yJe,uM:bJe,vS:vJe,qB:xJe,GG:wJe,rq:kJe,lg:SJe,WR:IJe,cu:CJe,GE:NJe,px:TJe,jC:EJe,He:AJe,hE:_Je,BF:$Je,Dk:RJe,cl:DJe,_B:MJe,ub:FJe,_f:OJe,Ku:PJe,qy:LJe,Zy:zJe,bu:BJe,zv:WJe,dH:VJe,HS:UJe,yH:jJe,l3:GJe,z9:HJe,x6:qJe,_m:KJe,eW:XJe,GK:YJe,SP:QJe,yr:JJe,dl:ZJe,Dw:eZe,xT:tZe,_X:nZe,wz:rZe}=N;function aZe(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function sZe(e,t){return 1===t?[e]:aZe(e,t)}class iZe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=jQe(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=sZe("rc",this.rank),t=PQe(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class oZe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=jQe(this.outputShape.length);let n="";for(let s=0;s<4;s++){let e="thisRC = rc;";s%2===1&&(e+="thisRC.z += 1;"),s>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}var r,a;this.userCode=`\n      ${r=t,a=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${a?SQe(["r","c","d"],"inputShape"):wQe(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":IQe(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class lZe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=cZe(t,n),a=dZe(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const s=uZe(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}let i;return r===UYe.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===UYe.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===UYe.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===UYe.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===UYe.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const a=cZe(n,r),s=dZe(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);const i=uZe(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=kxe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[s],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function uZe(e,t,n,r,a){const s=function(e,t){switch(e){case UYe.PACKED_2X2_FLOAT32:return sJe(t);case UYe.PACKED_2X2_FLOAT16:return iJe(t);case UYe.UNPACKED_FLOAT32:return nJe(t);case UYe.UNPACKED_FLOAT16:return rJe(t);case UYe.PACKED_4X1_UNSIGNED_BYTE:return aJe(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(a){const[t,n]=HYe(e[0],e[1]);i=t*n}else{const[t,n]=jYe(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,s);return i*o}function cZe(e,t){if(e===VYe.UPLOAD)return UYe.PACKED_2X2_FLOAT32;if(e===VYe.RENDER||null==e)return function(e){return kxe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?UYe.PACKED_2X2_FLOAT32:UYe.UNPACKED_FLOAT32:e?UYe.PACKED_2X2_FLOAT16:UYe.UNPACKED_FLOAT16}(t);if(e===VYe.DOWNLOAD||e===VYe.PIXELS)return UYe.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function dZe(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class hZe{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=jQe(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const pZe="if (isnan(x)) return x;",fZe="return x;",mZe="return abs(x);";const gZe="return (x >= 0.0) ? x : (exp(x) - 1.0);",yZe=pZe+"\n  return (x < 0.0) ? 0.0 : x;\n",bZe=pZe+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",vZe="return x;",xZe="return 1.0 / (1.0 + exp(-1.0 * x));",wZe="return x;",kZe="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",SZe="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",IZe="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",CZe="return 1.0 / (1.0 + exp(-1.0 * x));";class NZe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=jQe(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class TZe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=jQe(this.outputShape.length);const t=e.length,n=sZe("rc",t),r=PQe(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const EZe=G$e,AZe={};const _Ze=kxe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class $Ze extends Ove{nextDataId(){return $Ze.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!kxe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof lJe)t=e;else{const n=BYe(kxe().getNumber("WEBGL_VERSION"),e);t=new lJe(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=BYe(kxe().getNumber("WEBGL_VERSION"));t=new lJe(e),this.binaryCache=((n=kxe().getNumber("WEBGL_VERSION"))in AZe||(AZe[n]={}),AZe[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new lZe(this.gpgpu),this.numMBBeforeWarning=null==kxe().global.screen?1024:kxe().global.screen.height*kxe().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Fve(this,yCe())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,s){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];const l=uQe(t),u=new YQe(l,!1,s),c=this.runWebGLProgram(u,[i],n,[[r,a]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((kxe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||kxe().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:VYe.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if(kxe().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:VYe.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new NZe(i,vZe):new hZe(i,vZe);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=dIe()),"complex64"===r){c=jDe(this.readSync(a.real.dataId),this.readSync(a.imag.dataId))}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=dIe()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=a){let t;t=o?new NZe(r,vZe):new hZe(r,vZe);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(kxe().getBool("DEBUG")&&!kxe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===kxe().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==s&&kxe().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...GYe(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);u=jDe(e[0],e[1])}else if(null==c)u=this.getValuesFromTexture(e);else{const e=Gve(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;KYe(e,(()=>e.deleteBuffer(c)))}const d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&yCe().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new NZe(a,vZe):new hZe(a,vZe);const r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=yCe().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>fIe(e)));return TNe(e.shape,e.dtype,n)}catch(tL){throw new Error("Failed to decode encoded string bytes into utf-8")}return TNe(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!XYe(n)){if(kxe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=Gve(t);if(kxe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...GYe(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}const s=kxe().getBool("WEBGL_PACK")&&!0===r,i=s?uQe(t):t,o=s?new KQe(i):new qQe(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=gIe(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=gIe(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(a);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:dIe(),endMs:null}}endTimer(e){return kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=dIe(),e)}async getQueryTime(e){if(kxe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:_Ze;return kxe().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Gve(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){LSe("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return EZe(e.shape,t)}packedUnaryOp(e,t,n){const r=new NZe(e.shape,t),a=this.compileAndRun(r,[e],n);return yCe().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=VJe(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(kxe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,mZe,e.dtype);const t=new hZe(e.shape,mZe),n=this.compileAndRun(t,[e]);return yCe().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&axe(n[0])){const a=n.map((e=>pIe(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return yCe().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new TZe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new iZe(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[oQe(e.shape),...lQe(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[oQe(t),...lQe(t)],s=new oZe(a,n),i=[n],o=this.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){Vve(Gve(a)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=uQe(a);let o;o=r?new HQe(i):new GQe(i);const l=[null!=t?t:GYe(i)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(o,[{shape:i,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0;const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===WYe.DENSE){const t=null!=s?s:GYe(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Gve(i.shape))return o.values=exe(i.dtype,0),i;const l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Gve(t.shape)<=kxe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!dQe(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},d=function(e,t,n){let r="";t.concat(n).forEach((t=>{const a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=LQe(e.packedInputs,t.shape,s);let u="",c="",d="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=uxe(o);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const h=t.shape.length,p=2===o.length&&Hve(t.shape,s),f=1===Gve(t.shape),m=ZNe(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&Hve(s,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${h}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${d}_${y}_${a}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));const a=e.userCode;let s=e.constructor.name;return s+="_"+r+"_"+a+`${kxe().getNumber("WEBGL_VERSION")}`,s}(e,u,c),h=this.getAndSaveBinary(d,(()=>WQe(this.gpgpu,e,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),kxe().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(UQe(t.inShapeInfos,n),UQe([t.outShapeInfo],[r]));const s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===kxe().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const r=n[l],{uniform:a,offset:s,shape:i,texShape:o}=t.variablesLocations[l];if(i){const{uniformShape:n}=LQe(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=a)if(r.isUniform)if(Gve(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=r.texData.slice&&null!=s&&e.gl.uniform1i(s,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,l)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=uxe(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){const n=t.program.customUniforms[l],r=t.customUniformLocations[l],s=a[l];if("float"===n.type)e.gl.uniform1fv(r,s);else if("vec2"===n.type)e.gl.uniform2fv(r,s);else if("vec3"===n.type)e.gl.uniform3fv(r,s);else if("vec4"===n.type)e.gl.uniform4fv(r,s);else if("int"===n.type)e.gl.uniform1iv(r,s);else if("ivec2"===n.type)e.gl.uniform2iv(r,s);else if("ivec3"===n.type)e.gl.uniform3iv(r,s);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,s)}}e.executeProgram()}(this.gpgpu,h,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=kxe().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=dIe();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!kxe().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!kxe().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=vCe((()=>{if(!kxe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=kxe().getBool("DEBUG");kxe().set("DEBUG",!1);const t=this.abs(zNe(1e-8)).dataSync()[0];if(kxe().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;const l=null!=this.activeTimers;let u;l&&(u=dIe());let c=t.texShape;if(null==c&&(c=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=kxe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=kxe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&kxe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?Bve(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=Zve(e);e=t.newShape}let a=Gve(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);const i=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){const t=oQe(e);let n=2,r=2;e.length&&([n,r]=lQe(e)),a=t*(n/2)*(r/2),s=Kve(a).map((e=>2*e))}else s=Kve(a);return s}(n,o),t.texShape=c),null!=a){const e=uQe(n);let s,i=c[1],d=c[0];const h=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!o&&h||([i,d]=HYe(c[0],c[1])),s=o?new QQe(e,h):new YQe(e,h);const p=h?[d,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=h?VYe.PIXELS:VYe.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,a);const g=[[d,i]],y=!0,b=this.runWebGLProgram(s,[f],r,g,y),v=this.texData.get(b.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,kxe().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=dIe()-u)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*rxe(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await vDe(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw JYe(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=VQe(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:a,width:s,channels:i}=e,o=yCe().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=o.writeTexture(r,t,n,a,s,i);return yCe().makeTensorFromDataId(l,t,n,o)}}$Ze.nextDataId=0;rCe()&&SCe("webgl",(()=>new $Ze),2);const RZe="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class DZe{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=tTe(t,n),this.enableShapeUniforms=jQe(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const MZe="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class FZe{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=tTe(t,n);const a=this.outputShape.length;this.enableShapeUniforms=jQe(a);let s="";if(r)if(0===a||1===Gve(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(s=`\n          ${PQe(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=sZe("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function OZe(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const PZe={kernelName:Vwe,backendName:"webgl",kernelFunc:OZe};function LZe(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=OZe({inputs:{x:r},backend:n}),l=OZe({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}const zZe={kernelName:Zxe,backendName:"webgl",kernelFunc:LZe},BZe="return (a < 0.) ? b * a : a;",WZe="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const VZe={kernelName:Kwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",uIe(s,"float32")),o=kxe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new FZe(WZe,a.shape,i.shape):new DZe(BZe,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},UZe="return (a < 0.) ? b * a : a;",jZe="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const GZe={kernelName:Ake,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=kxe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new FZe(jZe,r.shape,a.shape):new DZe(UZe,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},HZe="if (isnan(x)) return x;";function qZe(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=e;return e=>{let{inputs:s,backend:i}=e;const{x:o}=s,l=i,u=a||o.dtype;if(l.shouldExecuteOnCPU([o])&&null!=r){const e=l.texData.get(o.dataId),t=r(e.values,u);return l.makeTensorInfo(o.shape,u,t)}let c;return c=kxe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new NZe(o.shape,n):new hZe(o.shape,t),l.runWebGLProgram(c,[o],u)}}function KZe(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:s,dtype:i}=e;return e=>{let{inputs:o,backend:l}=e;const{a:u,b:c}=o,d=l;if(a&&"complex64"===u.dtype){const e=d.texData.get(u.dataId),n=d.texData.get(c.dataId),[r,a]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,a={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:r.dataId,dtype:r.dtype,shape:c.shape},i=new DZe(t,u.shape,c.shape);return d.runWebGLProgram(i,[a,s],WIe(n.dtype,r.dtype))})),s=LZe({inputs:{real:r,imag:a},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(a),s}const h=i||WIe(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=s){const e=d.texData.get(u.dataId).values,t=d.texData.get(c.dataId).values,n="string"===u.dtype?IMe(e):e,r="string"===u.dtype?IMe(t):t,[a,i]=s(u.shape,c.shape,n,r,h),o=d.makeTensorInfo(i,h);return d.texData.get(o.dataId).values=a,o}let p;return p=kxe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new FZe(n,u.shape,c.shape,r):new DZe(t,u.shape,c.shape),d.runWebGLProgram(p,[u,c],h)}}function XZe(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?wZe:fZe;if("relu"===e)return t?SZe:yZe;if("elu"===e)return t?kZe:gZe;if("relu6"===e)return t?IZe:bZe;if("prelu"===e)return t?jZe:UZe;if("leakyrelu"===e)return t?WZe:BZe;if("sigmoid"===e)return t?CZe:xZe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class YZe{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=jQe(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const QZe={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class JZe{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=tTe(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const ZZe="return a * b;";function e0e(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=WIe(r.dtype,a.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),s=new JZe(QZe.REAL,r.shape,a.shape),i=new JZe(QZe.IMAG,r.shape,a.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:a.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:a.shape}],l=n.runWebGLProgram(s,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=LZe({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,a])){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),[i,o]=$Je(r.shape,a.shape,e.values,t.values,s),l=n.makeTensorInfo(o,s);return n.texData.get(l.dataId).values=i,l}let i;return i=kxe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new FZe(ZZe,r.shape,a.shape):new DZe(ZZe,r.shape,a.shape),n.runWebGLProgram(i,[r,a],s)}const t0e={kernelName:bke,backendName:"webgl",kernelFunc:e0e};function n0e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=Gve(a.shape),l=Qve(s,o),u=Gve(l);Vve(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=i.texData.get(a.dataId);return!c.isPacked||dQe(a.shape,l)||null!==c.texture&&dQe(c.shape,l)?(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){const r=[oQe(e.shape),...lQe(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[oQe(t),...lQe(t)],i=new oZe(s,r),o=[r],l=n.runWebGLProgram(i,[a],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(a,l,i)}const r0e={kernelName:Lke,backendName:"webgl",kernelFunc:n0e};class a0e{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${qve(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class s0e{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}}function i0e(e,t,n,r){const a=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=EDe(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let s=e;for(let i=0;i<a.length;i++){const{inSize:o,windowSize:l,outSize:u}=a[i];let c,d;c="mean"===n?0===i?new a0e({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new a0e({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new s0e({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=s,s=r.runWebGLProgram(c,[s],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return s}class o0e{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;const r=PQe(this.rank),a=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}class l0e{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=PQe(this.rank),a=aZe("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];const i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function u0e(e,t,n){const r=kxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new l0e(e.shape,t):new o0e(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function c0e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return function(e,t,n,r){const a=t,s=e.shape.length,i=Jve(a,e.shape);let o=i;const l=SAe(o,s),u=null!=l;let c=e;u&&(c=u0e(e,l,r),o=CAe(o.length,s)),kAe("sum",o,s);const[d,h]=xAe(c.shape,o);let p=d;n&&(p=wAe(d,i));const f=Gve(h),m=n0e({inputs:{x:c},attrs:{shape:[Gve(e.shape)/f,f]},backend:r}),g=i0e(m,VIe(e.dtype),"sum",r),y=n0e({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),y}(a,s,i,n)}const d0e={kernelName:sSe,backendName:"webgl",kernelFunc:c0e};function h0e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,i=n,o=a.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=a.shape[s[c]];let u;if(i.shouldExecuteOnCPU([a])){const e=i.texData.get(a.dataId).values,t=nZe(e,a.shape,a.dtype,s,l);u=i.makeTensorInfo(l,a.dtype);i.texData.get(u.dataId).values=t}else u=u0e(a,s,i);return u}const p0e={kernelName:TSe,backendName:"webgl",kernelFunc:h0e},f0e=1e3;function m0e(e){let{a:t,b:n,transposeA:r,transposeB:a,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e;const c=t.shape.length,d=n.shape.length,h=r?t.shape[c-2]:t.shape[c-1],p=a?n.shape[d-1]:n.shape[d-2],f=r?t.shape[c-1]:t.shape[c-2],m=a?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=Gve(g),v=Gve(y),x=tTe(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);Vve(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${a} must match.`));const w=r?[b,h,f]:[b,f,h],k=a?[v,m,p]:[v,p,m],S=n0e({inputs:{x:t},backend:s,attrs:{shape:w}}),I=n0e({inputs:{x:n},backend:s,attrs:{shape:k}}),C=[S,I],N=Math.max(b,v),T=r?S.shape[1]:S.shape[2],E=null!=i,A=null!=o,_="leakyrelu"===u,$=null!=u?XZe(u,!0):null;let R;if((1===f||1===m)&&T>f0e&&!1===(E||A||_||null!=$)){let e=S,t=I;r&&(e=h0e({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),C.push(e)),a&&(t=h0e({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),C.push(t));const n=1===m;let i=e;1!==m&&(i=n0e({inputs:{x:e},backend:s,attrs:{shape:[N,T,1]}}),C.push(i));const o=1===m?2:1;let l=t;n&&(l=n0e({inputs:{x:t},backend:s,attrs:{shape:[N,1,T]}}),C.push(l));const u=e0e({inputs:{a:i,b:l},backend:s});R=c0e({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),C.push(u)}else{const e=WIe(t.dtype,n.dtype),u=new YZe(w,k,[N,f,m],r,a,E,$,A,_),c=[S,I];if(null!=i&&c.push(i),A&&c.push(o),_){const e=s.makeTensorInfo([],"float32",uIe(l,"float32"));c.push(e),C.push(e)}R=s.runWebGLProgram(u,c,e)}const D=n0e({inputs:{x:R},backend:s,attrs:{shape:x}});C.push(R);for(const M of C)s.disposeIntermediateTensorInfo(M);return D}const g0e={kernelName:FSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return m0e({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},y0e="return abs(x);";const b0e={kernelName:Txe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=VJe(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let a;return a=kxe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new NZe(r.shape,y0e):new hZe(r.shape,y0e),n.runWebGLProgram(a,[r],r.dtype)}},v0e=qZe({opSnippet:pZe+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),x0e={kernelName:Exe,backendName:"webgl",kernelFunc:v0e},w0e=qZe({opSnippet:pZe+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),k0e={kernelName:Axe,backendName:"webgl",kernelFunc:w0e},S0e="return a + b;",I0e=KZe({opSnippet:S0e,packedOpSnippet:S0e,supportsComplex:!0,cpuKernelImpl:uJe}),C0e={kernelName:_xe,backendName:"webgl",kernelFunc:I0e};class N0e{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class T0e{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const E0e={kernelName:$xe,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,a=n;if(1===a.length)return OZe({inputs:{x:a[0]},backend:r});if(a.length>kxe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),s=e({inputs:a.slice(t),backend:r});return e({inputs:[n,s],backend:r})}const s=a.map((e=>e.dtype)).reduce(((e,t)=>WIe(e,t))),i=a.map((e=>e.shape)),o=kxe().getBool("WEBGL_PACK")?new T0e(a[0].shape,i):new N0e(a[0].shape,i);return r.runWebGLProgram(o,a,s)}};const A0e={kernelName:Rxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Jve(s,a.shape);let u=l;const c=SAe(u,o);let d=a;null!=c&&(d=h0e({inputs:{x:a},backend:n,attrs:{perm:c}}),u=CAe(u.length,o)),kAe("all",u,o);const[h,p]=xAe(d.shape,u),f=n0e({inputs:{x:d},backend:n,attrs:{shape:[-1,Gve(p)]}}),m=i0e(f,f.dtype,"all",n);let g;if(i){g=n0e({inputs:{x:m},backend:n,attrs:{shape:wAe(h,l)}})}else g=n0e({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};const _0e={kernelName:Dxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Jve(s,a.shape);let u=l;const c=SAe(u,o);let d=a;null!=c&&(d=h0e({inputs:{x:a},backend:n,attrs:{perm:c}}),u=CAe(u.length,o)),kAe("any",u,o);const[h,p]=xAe(d.shape,u),f=n0e({inputs:{x:d},backend:n,attrs:{shape:[-1,Gve(p)]}}),m=i0e(f,f.dtype,"any",n);let g;if(i){g=n0e({inputs:{x:m},backend:n,attrs:{shape:wAe(h,l)}})}else g=n0e({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};class $0e{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class R0e{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Vve(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,l=PQe(o),u=sZe("coords",o);let c,d;if(1===s){d=o+1;const e=PQe(d);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else d=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),m=sZe("sourceLocR",d-1).concat("inIdx.r"),g=sZe("sourceLocG",d-1).concat("inIdx.g"),y=sZe("sourceLocB",d-1).concat("inIdx.b"),b=sZe("sourceLocA",d-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function D0e(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);const i=EDe(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new $0e(o,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=D0e(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function M0e(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const a=null!=r?r.shape:t.shape,s=EDe(a[a.length-1]),i=new R0e(a,s,n,null==r),o=null==r?[t]:[t,r],l=e.runWebGLProgram(i,o,"int32");if(l.shape.length===t.shape.length){const r=M0e(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function F0e(e,t,n,r){const a=[n];if(kAe("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!kxe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId);let i=t;null!==s&&s.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,l]=xAe(i.shape,a),u=Gve(l),c=n0e({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);const d=D0e(e,c,r);n.push(d);const h=n0e({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return M0e(e,t,r)}const O0e={kernelName:Mxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let i=Jve(s,a.shape);const o=SAe(i,a.shape.length);let l=a;const u=[];null!=o&&(l=h0e({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=CAe(i.length,l.shape.length)),kAe("argMax",[i[0]],l.shape.length);const c=F0e(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};const P0e={kernelName:Fxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let i=Jve(s,a.shape);const o=SAe(i,a.shape.length);let l=a;const u=[];null!=o&&(l=h0e({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=CAe(i.length,l.shape.length)),kAe("argMin",[i[0]],l.shape.length);const c=F0e(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},L0e=qZe({opSnippet:pZe+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),z0e={kernelName:Oxe,backendName:"webgl",kernelFunc:L0e},B0e=qZe({opSnippet:pZe+"return log(x + sqrt(x * x + 1.0));"}),W0e={kernelName:Pxe,backendName:"webgl",kernelFunc:B0e},V0e=qZe({opSnippet:pZe+"\n  return atan(x);\n"}),U0e={kernelName:Lxe,backendName:"webgl",kernelFunc:V0e},j0e=KZe({opSnippet:RZe+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+MZe+"\n  return result;\n"}),G0e={kernelName:Bxe,backendName:"webgl",kernelFunc:j0e},H0e=qZe({opSnippet:pZe+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),q0e={kernelName:zxe,backendName:"webgl",kernelFunc:H0e};class K0e{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");const v=4*Math.floor(s/4),x=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class X0e{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(s/4),k=s%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}}const Y0e={kernelName:Wxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;bQe(a,"avgPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Vve(xEe(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=cEe(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&Hve(u.inShape,u.outShape))return OZe({inputs:{x:a},backend:n});const c=new K0e(u,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}};const Q0e={kernelName:Uxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=dEe(a.shape,s,i,[1,1,1],o,l,u),d=new X0e(c,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}};class J0e{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Z0e{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const e1e={kernelName:jxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=dEe(i.shape,o,l,[1,1,1],u,c),h=new Z0e(d);return n.runWebGLProgram(h,[a],i.dtype)}};const t1e={kernelName:Vxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;bQe([a,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=cEe(i.shape,o,l,1,u),d=new J0e(c);return n.runWebGLProgram(d,[a],i.dtype)}};const n1e={kernelName:Gxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;return m0e({a:a,b:s,transposeA:i,transposeB:o,backend:n})}};class r1e{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],tTe(e,t),tTe(e,n);let i="0.0";null!=r&&(tTe(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(tTe(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class a1e{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],tTe(e,t),tTe(e,n);let i="vec4(0.0)";null!=r&&(tTe(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(tTe(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const s1e={kernelName:Pwe,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,mean:s,variance:i,offset:o,scale:l}=t;Vve(s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Vve(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Vve(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=[a,s,i];let d=null;null!=o&&(d=o.shape,c.push(o));let h=null;null!=l&&(h=l.shape,c.push(l));const p=kxe().getBool("WEBGL_PACK_NORMALIZATION")?new a1e(a.shape,s.shape,i.shape,d,h,u):new r1e(a.shape,s.shape,i.shape,d,h,u);return n.runWebGLProgram(p,c,c[0].dtype)}};class i1e{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=PQe(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return o1e.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${o1e[t]} = start[${t}] + coords.${o1e[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const o1e=["x","y","z","w","u","v"];class l1e{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=PQe(this.rank),n=sZe("coords",this.rank),r=sZe("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function u1e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=KTe(a,s,i);if(MTe(a,o,l),0===Gve(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.texData.get(a.dataId),t=UJe(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}const{isPacked:u}=n.texData.get(a.dataId),c=HTe(a.shape,o,l);if(u||!c){const e=kxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new l1e(l):new i1e(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){const a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=qTe(t,uxe(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}(a,o,l,n)}const c1e={kernelName:Jke,backendName:"webgl",kernelFunc:u1e},d1e={kernelName:Hxe,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;Vve(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((e,t)=>e*t)),l=_De(a.shape,s,o),u=$De(l.length,s.length),c=RDe(a.shape,s,o),d=DDe(i,s.length),h=MDe(c,i,s.length),p=[],f=n0e({inputs:{x:a},backend:n,attrs:{shape:l}}),m=h0e({inputs:{x:f},backend:n,attrs:{perm:u}}),g=n0e({inputs:{x:m},backend:n,attrs:{shape:c}}),y=u1e({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const h1e={kernelName:qxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=cJe(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}};const p1e={kernelName:Kxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=kxe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=kxe().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(a.dataId).values,[s,i]=hJe(r.shape,a.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=s,o}let o;return o=s?new FZe("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,a.shape,!1):new DZe("\n  return float(int(a.r) & int(b.r));\n",r.shape,a.shape),n.runWebGLProgram(o,[r,a],r.dtype)}};const f1e={kernelName:Xxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=tTe(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},m1e=KZe({opSnippet:"return float(a != b);",cpuKernelImpl:DJe,dtype:"bool"}),g1e={kernelName:xke,backendName:"webgl",kernelFunc:m1e};function y1e(e){const{inputs:t,backend:n}=e,{input:r}=t;return OZe({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const b1e={kernelName:Fke,backendName:"webgl",kernelFunc:y1e},v1e="return float(int(x));";const x1e={kernelName:Yxe,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:i}=a;if("complex64"===i){if("complex64"===s.dtype)return OZe({inputs:{x:s},backend:r});const t=f_e(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=LZe({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){const t=y1e({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!nxe(s.dtype,i)){const e=OZe({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([s])){const e=r.texData.get(s.dataId).values,[t,n,a]=pJe(e,s.shape,s.dtype,i);return r.makeTensorInfo(t,n,a)}if("int32"===i)return function(e,t){const n=new hZe(e.shape,v1e),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",exe("bool",1)),t=m1e({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},w1e="return ceil(x);",k1e=qZe({opSnippet:w1e,packedOpSnippet:w1e,cpuKernelImpl:fJe}),S1e={kernelName:Qxe,backendName:"webgl",kernelFunc:k1e};class I1e{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class C1e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const N1e={kernelName:Jxe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r;let o;o=kxe().getBool("WEBGL_PACK_CLIP")?new C1e(a.shape):new I1e(a.shape);const l=[[s],[i]];return n.runWebGLProgram(o,[a],a.dtype,l)}};class T1e{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function E1e(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const A1e={kernelName:ewe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new T1e(r.shape),i=[E1e(r,a.complexTensorInfos.real),E1e(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}};class _1e{constructor(e){this.outputShape=[],this.outputShape=wDe(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){const e=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${e}));`)}const r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class $1e{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=wDe(e,t);const n=this.outputShape,r=n.length,a=PQe(r),s=sZe("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const l=i[t],u=i.slice(-2),c=i.join();let d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){const e=o[f-1];d+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${R1e(i,l,e)}),\n            vec2(${R1e(u,l,e)}));\n        }`}const h=o.length,p=o[o.length-1];d+=`\n        return getChannel(\n          getT${h}(${R1e(i,l,p)}),\n          vec2(${R1e(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function R1e(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function D1e(e){const{inputs:t,backend:n}=e,{input:r}=t;return OZe({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const M1e={kernelName:jwe,backendName:"webgl",kernelFunc:D1e};function F1e(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>y1e({inputs:{input:e},backend:n}))),a=e.map((e=>D1e({inputs:{input:e},backend:n}))),s=F1e(r,t,n),i=F1e(a,t,n),o=LZe({inputs:{real:s,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const r=Gve(e.shape.slice(t));return n0e({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=wDe(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=mJe(s,i,r,o),u=wDe(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const s=e.filter((e=>Gve(e.shape)>0)),i=kxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const t=i?new hZe(e[0].shape,vZe):new NZe(e[0].shape,vZe);return n.runWebGLProgram(t,e,r)}const o=kxe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){const e=[];for(let a=0;a<s.length;a+=o){const r=s.slice(a,a+o);e.push(F1e(r,t,n))}const r=F1e(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new $1e(s.map((e=>e.shape)),t);return n.runWebGLProgram(e,s,r)}const{tensors2D:l,outShape:u}=function(e,t,n){const r=wDe(e.map((e=>e.shape)),t),a=e.map((e=>n0e({inputs:{x:e},attrs:{shape:[-1,Gve(e.shape.slice(t))]},backend:n})));return{tensors2D:a,outShape:r}}(s,t,n),c=new _1e(l.map((e=>e.shape))),d=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const h=n0e({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function O1e(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Jve(a,t[0].shape)[0];xDe(t.map((e=>e.shape)),s);const i=wDe(t.map((e=>e.shape)),s);if(0===Gve(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Gve(e.shape)>0));return 1===o.length?OZe({inputs:{x:o[0]},backend:n}):F1e(o,s,n)}const P1e={kernelName:twe,backendName:"webgl",kernelFunc:O1e};class L1e{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}}class z1e{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class B1e{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jQe(this.outputShape.length);const s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)d+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){const t=2*m;if(d+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,d+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){const e=s%2===0?Bve(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,d+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):d+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(d+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(d+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(d+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class W1e{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=jQe(this.outputShape.length);const{dataFormat:n}=t,r=xQe(),a="channelsLast"===n,s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function V1e(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function U1e(e){let{x:t,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const u=t.shape,c=a.texData.get(t.dataId),d=r.inChannels,h=u[0]*u[1]*u[2],p=r.outChannels,f="channelsLast"===r.dataFormat,m=!1;let g;const y=[];if(null!=i){const e=V1e(i.shape,f);null!=e&&(i=n0e({inputs:{x:i},backend:a,attrs:{shape:e}}),y.push(i))}if(null!=s){const e=V1e(s.shape,f);null!=e&&(s=n0e({inputs:{x:s},backend:a,attrs:{shape:e}}),y.push(s))}if(!((1===h||1===p)&&d>f0e)&&c.isPacked&&f&&null!=c.texture&&u[2]%2!==0&&Hve(c.shape.slice(-3),u.slice(-3))){const e=u[0]*u[1]*(u[2]+1),d={dataId:t.dataId,shape:[1,e,r.inChannels],dtype:t.dtype},h=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,Vve(dQe(c.shape,d.shape),(()=>`packed reshape ${c.shape} to ${d.shape} isn't free`));const p=n0e({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}});y.push(p);const f=m0e({a:d,b:p,backend:a,transposeA:false,transposeB:m,bias:s,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),b=a.texData.get(f.dataId);Vve(b.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=h,b.shape=r.outShape,g=OZe({inputs:{x:f},backend:a}),g.shape=r.outShape,y.push(f)}else{const e=r.outHeight*r.outWidth,u=n0e({inputs:{x:t},backend:a,attrs:{shape:f?[r.batchSize,e,r.inChannels]:[r.batchSize,r.inChannels,e]}}),c=n0e({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}}),d=m0e({a:f?u:c,b:f?c:u,transposeA:!f,transposeB:m,backend:a,bias:s,activation:l,preluActivationWeights:i,leakyreluAlpha:o});g=n0e({inputs:{x:d},backend:a,attrs:{shape:r.outShape}}),y.push(u),y.push(c),y.push(d)}for(const b of y)a.disposeIntermediateTensorInfo(b);return g}function j1e(e){let{x:t,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const{filterWidth:u,filterHeight:c,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=u*c*d,y=p*h,b=[r.batchSize,g,y],v=[];if(null!=i){const e=V1e(i.shape,m);null!=e&&(i=n0e({inputs:{x:i},backend:a,attrs:{shape:e}}),v.push(i))}if(null!=s){const e=V1e(s.shape,m);null!=e&&(s=n0e({inputs:{x:s},backend:a,attrs:{shape:e}}),v.push(s))}const x=n0e({inputs:{x:n},backend:a,attrs:{shape:[1,g,Gve(n.shape)/g]}});v.push(x);const w=new W1e(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(w,[t],"float32",k),I=n0e({inputs:{x:S},backend:a,attrs:{shape:b}});v.push(S),v.push(I);const C=null!=s,N=null!=i,T="leakyrelu"===l,E=l?XZe(l,!0):null,A=new YZe(m?I.shape:x.shape,m?x.shape:I.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,C,E,N,T),_=m?[I,x]:[x,I];if(s&&_.push(s),N&&_.push(i),T){const e=a.makeTensorInfo([],"float32",uIe(o,"float32"));_.push(e),v.push(e)}const $=a.runWebGLProgram(A,_,"float32"),R=n0e({inputs:{x:$},backend:a,attrs:{shape:r.outShape}});v.push($);for(const D of v)a.disposeIntermediateTensorInfo(D);return R}const G1e={kernelName:nwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=kEe(l),h=hEe(a.shape,s.shape,i,u,o,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&kxe().getBool("WEBGL_EXP_CONV")){const e=new B1e(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[a,s],"float32",t)}else if(kxe().getBool("WEBGL_CONV_IM2COL"))p=j1e({x:a,filter:s,convInfo:h,backend:n});else{const e=new L1e(h);p=n.runWebGLProgram(e,[a,s],"float32")}else p=U1e({x:a,filter:s,convInfo:h,backend:n});const f=n0e({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class H1e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class q1e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class K1e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class X1e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Y1e={kernelName:rwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=kEe(l),h=hEe(a.shape,c,i,1,o,u,!1,d),p=new H1e(h);return n.runWebGLProgram(p,[a,s],"float32")}};class Q1e{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=jQe(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const J1e={kernelName:awe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=kEe(u),h=hEe(i,s.shape,o,1,l,c,!1,d);if(kxe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new Q1e(h);return n.runWebGLProgram(t,[a,s],"float32",e)}{const e=new q1e(h);return n.runWebGLProgram(e,[a,s],"float32")}}};const Z1e={kernelName:swe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=pEe(a.shape,s.shape,i,l,o),c=new z1e(u);return n.runWebGLProgram(c,[a,s],"float32")}};const e2e={kernelName:iwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=pEe(a.shape,l,i,1,o),c=new K1e(u);return n.runWebGLProgram(c,[a,s],"float32")}};const t2e={kernelName:owe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=pEe(l,s.shape,o,1,i),c=new X1e(u);return n.runWebGLProgram(c,[a,s],"float32")}},n2e=qZe({opSnippet:HZe+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${MZe}\n  return result;\n`}),r2e={kernelName:lwe,backendName:"webgl",kernelFunc:n2e},a2e=qZe({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),s2e={kernelName:uwe,backendName:"webgl",kernelFunc:a2e};class i2e{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];const h="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,x]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const o2e={kernelName:hwe,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new i2e(a.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[a,s,i],"float32")}};var l2e;!function(e){e.Prod="*",e.Sum="+"}(l2e||(l2e={}));class u2e{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,s=this.op===l2e.Prod?"1.0":"0.0",i=n?s:`getX(${c2e(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${PQe(a)} coords = getOutputCoords();\n        int end = ${d2e(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${d2e(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${c2e(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function c2e(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function d2e(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function h2e(e,t,n,r,a,s){const i=t.shape.length,o=SAe([r],i);let l=t;null!=o&&(l=h0e({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=CAe(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=OZe({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const t=new u2e(e,l.shape,!1,s),r=[[h]],a=d;d=n.runWebGLProgram(t,[d],d.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){const t=new u2e(e,l.shape,a,s),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=h0e({inputs:{x:d},backend:n,attrs:{perm:IAe(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}const p2e={kernelName:cwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return h2e(l2e.Prod,a,n,s,i,o)}};const f2e={kernelName:dwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return h2e(l2e.Sum,a,n,s,i,o)}};const m2e={kernelName:pwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){const e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=cJe(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){const e=n.bufferSync(a),t=n.bufferSync(s),r=dJe(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};class g2e{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const y2e={kernelName:fwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,c=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d=new g2e("NHWC"===i?[o,l,u,c]:[o,c,l,u],s,i);return n.runWebGLProgram(d,[a],a.dtype)}};class b2e{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jQe(this.outputShape.length);const s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class v2e{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=jQe(this.outputShape.length);const s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)h+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){const e=2*g;if(h+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,h+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=i%2===0?Bve(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,h+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):h+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(h+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(h+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(h+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const x2e={kernelName:mwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),Vve(xEe(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=hEe(a.shape,s.shape,i,c,o,u,!0);let h;h=kxe().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new v2e(d):new b2e(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[a,s],"float32",p)}};class w2e{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class k2e{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const S2e={kernelName:gwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=hEe(a.shape,c,i,o,l,u,!0),h=new w2e(d);return n.runWebGLProgram(h,[a,s],"float32")}};const I2e={kernelName:ywe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=hEe(c,s.shape,i,o,l,u,!0),h=new k2e(d);return n.runWebGLProgram(h,[a,s],"float32")}};class C2e{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const N2e={kernelName:bwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=Gve(r.shape),i=n0e({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new C2e(s),l=n.runWebGLProgram(o,[i],i.dtype),u=n0e({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}};class T2e{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const E2e={kernelName:vwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=uEe(a.shape,s.shape,i,o,"NHWC",l);let c;const d=new T2e(u);c=n.runWebGLProgram(d,[a,s],"float32");const h=n0e({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}};const A2e={kernelName:Iwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=nMe(a,s.length);aMe(i.length,l,s);const{path:u,steps:c}=sMe(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=rMe(p,l[e]);let a;iMe(t)?a=s[e]:(a=h0e({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Hve(a.shape,i)||(a=n0e({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===h?h=a:(h=e0e({inputs:{a:a,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=c0e({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},_2e=qZe({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),$2e={kernelName:Cwe,backendName:"webgl",kernelFunc:_2e},R2e={kernelName:Nwe,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=kxe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new FZe("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new DZe("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},D2e=KZe({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:gJe}),M2e={kernelName:Ewe,backendName:"webgl",kernelFunc:D2e},F2e=qZe({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${LDe};\n  float a1 = ${zDe};\n  float a2 = ${BDe};\n  float a3 = ${WDe};\n  float a4 = ${VDe};\n  float a5 = ${UDe};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),O2e={kernelName:Twe,backendName:"webgl",kernelFunc:F2e},P2e=qZe({opSnippet:HZe+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:yJe,dtype:"float32"}),L2e={kernelName:Awe,backendName:"webgl",kernelFunc:P2e};function z2e(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(Vve(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),n0e({inputs:{x:s},backend:r,attrs:{shape:o}})}const B2e={kernelName:_we,backendName:"webgl",kernelFunc:z2e},W2e="return exp(x) - 1.0;",V2e=qZe({opSnippet:W2e,packedOpSnippet:W2e,cpuKernelImpl:bJe}),U2e={kernelName:$we,backendName:"webgl",kernelFunc:V2e};class j2e{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function G2e(e,t,n){const r=n.texData.get(e.dataId),a=Gve(e.shape),s=e.shape[e.shape.length-1],i=n0e({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),o=i.shape,l=new j2e("real",o,t),u=new j2e("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(l,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),p=LZe({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=n0e({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const H2e={kernelName:Rwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return G2e(r,!1,n)}};class q2e{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function K2e(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||ixe(a),"string"===s){const e=txe(s,Gve(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{const e=new q2e(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}const X2e={kernelName:Dwe,backendName:"webgl",kernelFunc:K2e};class Y2e{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Q2e={kernelName:Mwe,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:r}=t,a=n,s=new Y2e(r.shape);return a.runWebGLProgram(s,[r],r.dtype)}},J2e="return floor(x);",Z2e=qZe({opSnippet:J2e,packedOpSnippet:J2e,cpuKernelImpl:vJe}),e3e={kernelName:Fwe,backendName:"webgl",kernelFunc:Z2e},t3e=KZe({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),n3e={kernelName:Owe,backendName:"webgl",kernelFunc:t3e};class r3e{constructor(e){this.variableNames=["A"];const t=xQe(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class a3e{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=xQe(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const s3e={kernelName:DSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:s}=r,i="undefined"!==typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],c=[u,l],d=[u,l,s];if(o||i){const e=kxe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=i3e&&e===o3e||(o3e=e,i3e=document.createElement("canvas").getContext("2d",{willReadFrequently:o3e})),i3e.canvas.width=l,i3e.canvas.height=u,i3e.drawImage(a,0,0,l,u),a=i3e.canvas}const h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=VYe.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);const p=kxe().getBool("WEBGL_PACK")?new a3e(d):new r3e(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let i3e,o3e=kxe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const l3e={kernelName:OSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=kEe(c),g=hEe(a.shape,s.shape,l,d,u,h,!1,m);let y;const b=[],v=null!=i,x=null!=o,w="leakyrelu"===p,k=()=>{const e=[a,s],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=n0e({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(i,c)),x&&e.push(t(o,c)),w){const t=n.makeTensorInfo([],"float32",uIe(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&kxe().getBool("WEBGL_EXP_CONV")){const e=p?XZe(p,!0):null,t=new B1e(g,v,e,x,w),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],a=k();y=n.runWebGLProgram(t,a,"float32",r)}else if(kxe().getBool("WEBGL_CONV_IM2COL"))y=j1e({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?XZe(p,!1):null,t=new L1e(g,v,e,x,w),r=k();y=n.runWebGLProgram(t,r,"float32")}else y=U1e({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=n0e({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const u3e={kernelName:PSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),Vve(xEe(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=hEe(a.shape,s.shape,l,m,u,d,!0),y=kxe().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=h?XZe(h,y):null,v=[a,s],x=null!=i,w=null!=o,k="leakyrelu"===h;if(x&&v.push(i),w&&v.push(o),k){const e=n.makeTensorInfo([],"float32",uIe(p,"float32"));v.push(e),f.push(e)}let S;S=y?new v2e(g,x,b,w,k):new b2e(g,x,b,w,k);const I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],C=n.runWebGLProgram(S,v,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),C}};class c3e{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=PQe(n.length);let s="\n    int index;";for(let i=0;i<this.sliceDim;i++)s+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const d3e={kernelName:zwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=Gve(r.shape),[l,u,c,d]=FDe(r,a),h=n0e({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),p=n0e({inputs:{x:r},backend:n,attrs:{shape:[Gve(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),s=xJe(e,t,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}const f=new c3e(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=n0e({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class h3e{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=PQe(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function p3e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=Jve(i,a.shape)[0];if(kxe().get("DEBUG")){const e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){const r=e[n];Vve(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const u=SMe(a,s,l,o),c=Gve(s.shape),d=[],h=n0e({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=n0e({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),r=wJe(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new h3e(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const y=n0e({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const f3e={kernelName:Lwe,backendName:"webgl",kernelFunc:p3e},m3e=KZe({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:kJe,dtype:"bool"}),g3e={kernelName:Bwe,backendName:"webgl",kernelFunc:m3e},y3e=KZe({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:SJe}),b3e={kernelName:Wwe,backendName:"webgl",kernelFunc:y3e};const v3e={kernelName:Uwe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return G2e(r,!0,n)}},x3e=qZe({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),w3e={kernelName:Gwe,backendName:"webgl",kernelFunc:x3e},k3e=qZe({opSnippet:"return float(isinf(x));",dtype:"bool"}),S3e={kernelName:Hwe,backendName:"webgl",kernelFunc:k3e},I3e=qZe({opSnippet:"return float(isnan(x));",dtype:"bool"}),C3e={kernelName:qwe,backendName:"webgl",kernelFunc:I3e},N3e=KZe({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:IJe,dtype:"bool"}),T3e={kernelName:Xwe,backendName:"webgl",kernelFunc:N3e},E3e=KZe({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:CJe,dtype:"bool"}),A3e={kernelName:Ywe,backendName:"webgl",kernelFunc:E3e};const _3e={kernelName:Qwe,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=NJe(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},$3e=qZe({opSnippet:HZe+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:TJe}),R3e={kernelName:Jwe,backendName:"webgl",kernelFunc:$3e},D3e=qZe({opSnippet:HZe+"\n  return log(1.0 + x);\n"}),M3e={kernelName:Zwe,backendName:"webgl",kernelFunc:D3e},F3e=KZe({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),O3e={kernelName:eke,backendName:"webgl",kernelFunc:F3e},P3e=qZe({opSnippet:"return float(!(x >= 1.0));"}),L3e={kernelName:tke,backendName:"webgl",kernelFunc:P3e},z3e=KZe({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),B3e={kernelName:nke,backendName:"webgl",kernelFunc:z3e};class W3e{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];const s=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class V3e{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const U3e={kernelName:rke,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=kxe().getBool("WEBGL_PACK_NORMALIZATION")?new V3e(a.shape,s,i,o,l):new W3e(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)}};class j3e{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const G3e={kernelName:ake,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new j3e(a.shape,o,l,u,c);return n.runWebGLProgram(d,[a,s,i],a.dtype)}};function H3e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=Jve(s,a.shape);let u=l;const c=SAe(u,o),d=null!=c,h=n.shouldExecuteOnCPU([a]);let p=a;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=a.shape[c[n]];const r=nZe(e,a.shape,a.dtype,c,t);p=n.makeTensorInfo(t,a.dtype);n.texData.get(p.dataId).values=r}else p=u0e(a,c,n);u=CAe(u.length,o)}kAe("max",u,o);const[f,m]=xAe(p.shape,u);let g,y=f;if(i&&(y=wAe(f,l)),h){const e=n.texData.get(p.dataId).values,t=EJe(e,Gve(m),y,a.dtype);g=n.makeTensorInfo(y,a.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const a=Gve(t),s=n0e({inputs:{x:e},attrs:{shape:[Gve(e.shape)/a,a]},backend:r}),i=i0e(s,e.dtype,"max",r),o=n0e({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(p,m,y,n);return d&&n.disposeIntermediateTensorInfo(p),g}const q3e={kernelName:ske,backendName:"webgl",kernelFunc:H3e},K3e=KZe({opSnippet:RZe+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+MZe+"\n  return result;\n",cpuKernelImpl:AJe}),X3e={kernelName:ike,backendName:"webgl",kernelFunc:K3e};const Y3e={kernelName:oke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;bQe(a,"maxPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;Vve(xEe(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=cEe(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&Hve(u.inShape,u.outShape))return OZe({inputs:{x:a},backend:n});const c=new K0e(u,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}};const Q3e={kernelName:uke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=dEe(a.shape,s,i,[1,1,1],o,u,l),d=new X0e(c,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}};class J3e{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Z3e{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const e4e={kernelName:cke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=dEe(i.shape,o,l,[1,1,1],u,c),h=new X0e(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new Z3e(d),m=n.runWebGLProgram(f,[a,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};const t4e={kernelName:lke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;bQe([s,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=cEe(o.shape,l,u,1,c,d),p=new K0e(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new J3e(h),g=n.runWebGLProgram(m,[a,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const n4e={kernelName:dke,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;Vve(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));const c=[1,1];Vve(xEe(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=cEe(a.shape,s,i,c,o),[h,p]=function(e,t,n,r){let a=new K0e(n,"max",!1);const s=r.runWebGLProgram(a,[e],"float32");return a=new K0e(n,"max",!0,!0,t),[s,r.runWebGLProgram(a,[e],"float32")]}(a,l,d,u);return[h,p]}};const r4e={kernelName:hke,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{keepDims:s,axis:i}=n,o=r,l=a.shape.length,u=Jve(i,a.shape);let c=u;const d=SAe(c,l),h=null!=d,p=o.shouldExecuteOnCPU([a]),f=[];let m=a;if(h){if(p){const e=o.texData.get(m.dataId).values,t=new Array(l);for(let r=0;r<t.length;r++)t[r]=a.shape[d[r]];const n=nZe(e,a.shape,a.dtype,d,t);m=o.makeTensorInfo(t,a.dtype);o.texData.get(m.dataId).values=n}else m=u0e(a,d,o);f.push(m),c=CAe(c.length,l)}kAe("sum",c,l);const[g,y]=xAe(m.shape,c);let b=g;s&&(b=wAe(g,u));const v=function(e,t,n,r){const a=Gve(t),s=n0e({inputs:{x:e},attrs:{shape:[Gve(e.shape)/a,a]},backend:r}),i=i0e(s,"float32","mean",r),o=n0e({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(m,y,b,o);for(const x of f)o.disposeIntermediateTensorInfo(x);return v}};const a4e={kernelName:pke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Jve(s,a.shape);let u=l;const c=SAe(u,o);let d=a;null!=c&&(d=h0e({inputs:{x:a},backend:n,attrs:{perm:c}}),u=CAe(u.length,a.shape.length)),kAe("min",u,o);const[h,p]=xAe(d.shape,u),f=n0e({inputs:{x:d},backend:n,attrs:{shape:[-1,Gve(p)]}}),m=i0e(f,f.dtype,"min",n);let g;if(i){g=n0e({inputs:{x:m},backend:n,attrs:{shape:wAe(h,l)}})}else g=n0e({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},s4e=KZe({opSnippet:RZe+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+MZe+"\n  return result;\n",cpuKernelImpl:_Je}),i4e={kernelName:fke,backendName:"webgl",kernelFunc:s4e};class o4e{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=PQe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class l4e{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=PQe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=sZe("rc",r),l=sZe("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1;let h="";if(1===r){const e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const u4e={kernelName:mke,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a}=t,{paddings:s,mode:i}=r,o=kxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new l4e(a.shape,s,i):new o4e(a.shape,s,i);return n.runWebGLProgram(o,[a],a.dtype)}},c4e=KZe({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+MZe+"\n  return result;\n"}),d4e={kernelName:gke,backendName:"webgl",kernelFunc:c4e};class h4e{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const p4e=KZe({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),f4e={kernelName:Swe,backendName:"webgl",kernelFunc:p4e},m4e="return a - b;",g4e=KZe({opSnippet:m4e,packedOpSnippet:m4e,supportsComplex:!0,cpuKernelImpl:ZJe}),y4e={kernelName:wSe,backendName:"webgl",kernelFunc:g4e};function b4e(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=Jve([s],a.shape),o=H3e({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=wAe(o.shape,i),u=n0e({inputs:{x:o},backend:n,attrs:{shape:l}}),c=g4e({inputs:{a:a,b:u},backend:n}),d=P2e({inputs:{x:c},backend:n}),h=c0e({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=n0e({inputs:{x:h},backend:n,attrs:{shape:l}}),f=p4e({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const v4e={kernelName:lSe,backendName:"webgl",kernelFunc:b4e};const x4e={kernelName:yke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:b4e({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new h4e(u,c,s),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}},w4e=pZe+"\n  return -x;\n";const k4e={kernelName:vke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,a]=RJe(e.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,t)}let a;return a=kxe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new NZe(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new hZe(r.shape,w4e),n.runWebGLProgram(a,[r],r.dtype)}},S4e=NRe;const I4e={kernelName:wke,backendName:"webgl",kernelFunc:function(e){LSe("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=S4e(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},C4e=TRe;const N4e={kernelName:kke,backendName:"webgl",kernelFunc:function(e){LSe("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:p}=C4e(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},T4e=ERe;const E4e={kernelName:Ske,backendName:"webgl",kernelFunc:function(e){LSe("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=T4e(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class A4e{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const _4e={kernelName:Cke,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=Gve(a.shape),c=new A4e(u,i,o,l),d=n0e({inputs:{x:a},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],s);n.disposeIntermediateTensorInfo(d);const p=n0e({inputs:{x:h},backend:n,attrs:{shape:[...a.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function $4e(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=y1e({inputs:{input:r},backend:n}),t=$4e({inputs:{x:e},backend:n}),a=D1e({inputs:{input:r},backend:n}),s=$4e({inputs:{x:a},backend:n}),i=LZe({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return K2e({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const R4e={kernelName:$Se,backendName:"webgl",kernelFunc:$4e};const D4e={kernelName:Ike,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const t=y1e({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=D1e({inputs:{input:a},backend:r}),i=$4e({inputs:{x:s},backend:r}),o=LZe({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return K2e({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};const M4e={kernelName:Nke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return z2e({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Uve(s,e.shape,"All tensors passed to stack must have matching shapes"),Vve(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=O1e({inputs:t.map((e=>{const t=z2e({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class F4e{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=PQe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class O4e{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=PQe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=sZe("rc",r),l=sZe("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${d[f]}\n        if (${h}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const P4e=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===Gve(a.shape)){const e=s.map(((e,t)=>e[0]+a.shape[t]+e[1]));return K2e({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}const o=kxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new O4e(a.shape,s,i):new F4e(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},L4e={kernelName:Tke,backendName:"webgl",kernelFunc:P4e},z4e=KZe({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+MZe+"\n  return result;\n"}),B4e={kernelName:Eke,backendName:"webgl",kernelFunc:z4e};const W4e={kernelName:_ke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=[],u=Jve(s,a.shape);let c=u;const d=SAe(c,o);let h,p=a;if(null!=d&&(p=h0e({inputs:{x:a},backend:n,attrs:{perm:d}}),c=CAe(c.length,o),l.push(p)),kAe("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:a}=MJe(p.shape,p.dtype,e,c);h=n.makeTensorInfo(r,a,t)}else{const[e,t]=xAe(p.shape,c),r=Gve(t),s=n0e({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=i0e(s,VIe(a.dtype),"prod",n);h=n0e({inputs:{x:i},backend:n,attrs:{shape:e}}),l.push(s),l.push(i)}if(i){l.push(h);const e=wAe(h.shape,u);h=n0e({inputs:{x:h},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const V4e={kernelName:$ke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.readSync(e.dataId))),u=a.map((e=>e.shape)),c=n.readSync(s.dataId),d=n.readSync(i.dataId),[h,p,f]=FJe(l,u,c,s.shape,s.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};const U4e={kernelName:Rke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=OJe(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};const j4e={kernelName:Dke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),d=n.readSync(i.dataId),h=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=PJe(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}},G4e=e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=LJe(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},H4e={kernelName:Mke,backendName:"webgl",kernelFunc:G4e},q4e=qZe({opSnippet:"return 1.0 / x;"}),K4e={kernelName:Oke,backendName:"webgl",kernelFunc:q4e},X4e=qZe({opSnippet:pZe+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Y4e={kernelName:Pke,backendName:"webgl",kernelFunc:X4e},Q4e=qZe({opSnippet:pZe+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),J4e={kernelName:Uke,backendName:"webgl",kernelFunc:Q4e};class Z4e{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class e5e{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const t5e={kernelName:Wke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=kxe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new e5e(a.shape,l,u,s,i):new Z4e(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],"float32")}};class n5e{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const r5e={kernelName:Vke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new n5e(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};class a5e{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class s5e{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const i5e={kernelName:zke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=kxe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new s5e(a.shape,l,u,s,i):new a5e(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],a.dtype)}};class o5e{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const l5e={kernelName:Bke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new o5e(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};class u5e{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=PQe(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class c5e{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=sZe("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=PQe(n);function o(n){const r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const d5e={kernelName:jke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=Jve(s,a.shape);if(0===i)return OZe({inputs:{x:a},backend:n});const l=kxe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new c5e(a.shape,o):new u5e(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}};class h5e{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let a="";a="number"===typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const p5e={kernelName:MSe,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=new h5e(a.shape,i),[c,d]=ADe(o,a.shape[1],a.shape[2]),h=[[c,d,Math.sin(s),Math.cos(s)]];return l.runWebGLProgram(u,[a],a.dtype,h)}},f5e=qZe({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),m5e={kernelName:Gke,backendName:"webgl",kernelFunc:f5e},g5e=qZe({opSnippet:"return inversesqrt(x);",cpuKernelImpl:zJe}),y5e={kernelName:Hke,backendName:"webgl",kernelFunc:g5e};class b5e{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const o=PQe(a.length),l=PQe(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}}class v5e{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const o=PQe(a.length),l=PQe(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${g};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}}const x5e={kernelName:qke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=O$e(0,a,i),h=[d/u,u];if(0===d)return n.makeTensorInfo(i,a.dtype);const p=n0e({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=n0e({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=kxe().getBool("WEBGL_PACK")?new v5e(l,o,p.shape.length,f.shape.length,c,h):new b5e(l,o,p.shape.length,f.shape.length,c,h);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=n0e({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class w5e{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===kxe().getNumber("WEBGL_VERSION")?"while (left < right) {":a,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const k5e={kernelName:Xke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new w5e(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}};class S5e{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}const s=PQe(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}const I5e={kernelName:Yke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new S5e(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],WIe(a.dtype,s.dtype))}},C5e=qZe({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${ODe};\n  float scale = ${PDe};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),N5e={kernelName:Qke,backendName:"webgl",kernelFunc:C5e},T5e=qZe({opSnippet:HZe+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:WJe}),E5e={kernelName:nSe,backendName:"webgl",kernelFunc:T5e},A5e=qZe({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),_5e={kernelName:tSe,backendName:"webgl",kernelFunc:A5e},$5e=qZe({opSnippet:HZe+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${MZe}\n  return result;\n`}),R5e={kernelName:Zke,backendName:"webgl",kernelFunc:$5e},D5e=qZe({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),M5e={kernelName:eSe,backendName:"webgl",kernelFunc:D5e},F5e=qZe({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),O5e={kernelName:rSe,backendName:"webgl",kernelFunc:F5e},P5e={kernelName:iSe,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;Vve(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);const u=[],c=P4e({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=_De(c.shape,s,o,!1),h=$De(d.length,s.length,!1),p=RDe(c.shape,s,o,!1),f=n0e({inputs:{x:c},backend:n,attrs:{shape:d}}),m=h0e({inputs:{x:f},backend:n,attrs:{perm:h}}),g=n0e({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const L5e={kernelName:uSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=jJe(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};const z5e={kernelName:cSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,d]=GJe(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};const B5e={kernelName:dSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=HJe(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const W5e={kernelName:hSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=HJe(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const V5e={kernelName:pSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=O$e(0,a,o),p=!1;if("string"===s.dtype){const e=n.bufferSync(a),t=n.bufferSync(s),r=fIe(n.readSync(i.dataId)[0]),f=BJe(e,t,o,h,c,u,l,d,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new b5e(u,l,a.shape.length,s.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=n0e({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};const U5e={kernelName:oSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Jve(i,a.shape)[0],l=lMe(a,s,o),u=a.shape.length,c=new Array(u).fill(0),d=a.shape.slice();return l.map((e=>{const t=[...d];t[o]=e;const r=u1e({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},j5e="return sqrt(x);",G5e=qZe({opSnippet:j5e,packedOpSnippet:j5e,cpuKernelImpl:qJe}),H5e={kernelName:aSe,backendName:"webgl",kernelFunc:G5e},q5e={kernelName:mSe,backendName:"webgl",kernelFunc:qZe({opSnippet:"return x * x;"})},K5e="return (a - b) * (a - b);",X5e=KZe({opSnippet:K5e,packedOpSnippet:K5e}),Y5e={kernelName:fSe,backendName:"webgl",kernelFunc:X5e};const Q5e={kernelName:gSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");const s=IMe(n.readSync(a.dataId)),i=KJe(s,"string",r);return n.makeTensorInfo(a.shape,"string",i)}};const J5e={kernelName:RSe,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,s=pZe+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,i=new hZe(a.shape,s);return r.runWebGLProgram(i,[a],a.dtype)}};class Z5e{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=PQe(n.length),s=PQe(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const e6e={kernelName:ySe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=XTe(a.shape,s,i,o,l,u,c,d,h);let w;if(m)w=n0e({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){Vve(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=OTe(b,v,x),t=u1e({inputs:{x:a},backend:n,attrs:{begin:b,size:e}});w=n0e({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=TNe(a.shape,a.dtype,e),r=XJe(p,t,x,b);w=n.makeTensorInfo(f,a.dtype,r.values)}else{const e=new Z5e(b,x,p);w=n.runWebGLProgram(e,[a],a.dtype)}}const k=n0e({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const t6e={kernelName:bSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=YJe(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};const n6e={kernelName:vSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=QJe(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const r6e={kernelName:xSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(s.dataId),o=JJe(i,a);return n.makeTensorInfo(s.shape,"int32",o)}},a6e=qZe({opSnippet:"return tan(x);"}),s6e={kernelName:kSe,backendName:"webgl",kernelFunc:a6e},i6e=qZe({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),o6e={kernelName:SSe,backendName:"webgl",kernelFunc:i6e};const l6e={kernelName:Kke,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=O$e(0,s,a.shape),h=[d/u,u];if(0===d)return n.makeTensorInfo(a.shape,s.dtype);const p=n0e({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=n0e({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=n0e({inputs:{x:a},backend:n,attrs:{shape:h}}),g=new b5e(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=n0e({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class u6e{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;const r=PQe(this.rank),a=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}function c6e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>fIe(e))):e,r=TNe(a.shape,a.dtype,t),i=eZe(r,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new u6e(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}const d6e={kernelName:ISe,backendName:"webgl",kernelFunc:c6e};class h6e{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class p6e{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function f6e(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function m6e(e){let t=1;for(;t<e;)t*=2;return t}const g6e={kernelName:CSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=kxe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=kxe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([a])||c<o||s>l){const e=n.readSync(a.dataId),[t,r]=tZe(e,u,a.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[a,K2e({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(a.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(a):a,f=Gve(u)/c,m=n0e({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&f6e(n,p);const g=m6e(s),y=m6e(c);let b=null;const v=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{const a=v(),s=new h6e(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(s,a,"int32",i),f6e(n,o)};for(let C=1;C<g;C*=2){const e=2*C;for(let t=C;t>=1;t/=2)x(e,t,[f,y])}for(let C=y;C>g;C/=2){const e=v(),t=new p6e([f,C/2]),r=[[c],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(t,e,"int32",r),f6e(n,a);const s=g/2,i=2*s;for(let n=s;n>=1;n/=2)x(i,n,b.shape)}let w=b;b=u1e({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),f6e(n,w);let k=p3e({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});f6e(n,m);const S=u.slice(0,-1);S.push(s),w=b,b=n0e({inputs:{x:b},attrs:{shape:S},backend:n}),f6e(n,w);const I=k;return k=n0e({inputs:{x:k},attrs:{shape:S},backend:n}),f6e(n,I),[k,b]}};class y6e{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const b6e={kernelName:NSe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=new y6e(d,h,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[a,s],"float32")}};const v6e={kernelName:ESe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;bQe(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=rZe(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const x6e={kernelName:ASe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==s&&(u[c++]=i.shape[m]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[s]=1;const f=new Array(l);for(let m=0;m<f.length;m++){h[s]=m;const e=u1e({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),t=n0e({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class w6e{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const k6e={kernelName:_Se,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[];let u=0;const c=SAe([u],o);let d=a;null!=c&&(d=h0e({inputs:{x:a},backend:n,attrs:{perm:c}}),l.push(d),u=CAe(1,o)[0]);const h=kMe(d.shape,u,i),p=Gve([d.shape[u]]),f=n0e({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=VIe(a.dtype),g=(e,t,r,a,s)=>{const i=e.shape[0],o=e.shape[1],u=wMe(o,s),c=new w6e({windowSize:u,inSize:o,batchSize:i,numSegments:s},t),d=n.compileAndRun(c,[e,r],a);if(l.push(d),d.shape[1]===s)return d;const h=G4e({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=c6e({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});l.push(h),l.push(p);return g(d,t,p,a,s)},y=n0e({inputs:{x:g(f,"unsortedSegmentSum",s,m,i)},backend:n,attrs:{shape:h}});let b=y;if(null!=c){l.push(y);const e=IAe(c);b=h0e({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},S6e=[g0e,b0e,x0e,k0e,C0e,E0e,A0e,_0e,O0e,P0e,z0e,W0e,U0e,G0e,q0e,Y0e,Q0e,e1e,t1e,n1e,s1e,d1e,h1e,p1e,f1e,x1e,S1e,N1e,zZe,A1e,P1e,G1e,Y1e,J1e,Z1e,e2e,t2e,r2e,s2e,o2e,p2e,f2e,m2e,y2e,x2e,S2e,I2e,N2e,E2e,A2e,$2e,R2e,M2e,O2e,L2e,B2e,U2e,H2e,X2e,Q2e,e3e,n3e,s3e,l3e,u3e,d3e,f3e,g3e,b3e,PZe,v3e,M1e,w3e,S3e,C3e,VZe,T3e,A3e,_3e,R3e,M3e,O3e,L3e,B3e,U3e,G3e,q3e,X3e,Y3e,Q3e,e4e,t4e,n4e,r4e,a4e,i4e,u4e,d4e,x4e,t0e,k4e,I4e,N4e,E4e,g1e,_4e,D4e,M4e,L4e,B4e,GZe,W4e,V4e,U4e,j4e,H4e,b1e,f4e,K4e,Y4e,J4e,r0e,t5e,r5e,i5e,l5e,d5e,p5e,m5e,y5e,x5e,k5e,I5e,N5e,E5e,_5e,R5e,M5e,c1e,v4e,O5e,P5e,L5e,z5e,B5e,W5e,V5e,U5e,H5e,q5e,Y5e,Q5e,J5e,e6e,t6e,n6e,r6e,y4e,d0e,s6e,o6e,l6e,d6e,g6e,b6e,p0e,v6e,x6e,k6e,R4e];for(const n of S6e)GSe(n);function I6e(e,t,n,r){return new(n||(n=Promise))((function(a,s){function i(e){try{l(r.next(e))}catch(e){s(e)}}function o(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?a(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))}function C6e(e,t){var n,r,a,s,i={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function o(o){return function(l){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;s&&(s=0,o[0]&&(i=0)),i;)try{if(n=1,r&&(a=2&o[0]?r.return:o[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,o[1])).done)return a;switch(r=0,a&&(o=[2&o[0],a.value]),o[0]){case 0:case 1:a=o;break;case 4:return i.label++,{value:o[1],done:!1};case 5:i.label++,r=o[1],o=[0];continue;case 7:o=i.ops.pop(),i.trys.pop();continue;default:if(!((a=(a=i.trys).length>0&&a[a.length-1])||6!==o[0]&&2!==o[0])){i=0;continue}if(3===o[0]&&(!a||o[1]>a[0]&&o[1]<a[3])){i.label=o[1];break}if(6===o[0]&&i.label<a[1]){i.label=a[1],a=o;break}if(a&&i.label<a[2]){i.label=a[2],i.ops.push(o);break}a[2]&&i.ops.pop(),i.trys.pop();continue}o=t.call(e,i)}catch(e){o=[6,e],r=0}finally{n=a=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,l])}}}function N6e(e,t,n){if(n||2===arguments.length)for(var r,a=0,s=t.length;a<s;a++)!r&&a in t||(r||(r=Array.prototype.slice.call(t,0,a)),r[a]=t[a]);return e.concat(r||Array.prototype.slice.call(t))}function T6e(e){return[Math.abs(e.endPoint[0]-e.startPoint[0]),Math.abs(e.endPoint[1]-e.startPoint[1])]}function E6e(e){return[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])/2,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])/2]}function A6e(e,t){void 0===t&&(t=1.5);var n=E6e(e),r=T6e(e),a=[t*r[0]/2,t*r[1]/2];return{startPoint:[n[0]-a[0],n[1]-a[1]],endPoint:[n[0]+a[0],n[1]+a[1]],palmLandmarks:e.palmLandmarks}}function _6e(e){var t=E6e(e),n=T6e(e),r=Math.max.apply(Math,n)/2;return{startPoint:[t[0]-r,t[1]-r],endPoint:[t[0]+r,t[1]+r],palmLandmarks:e.palmLandmarks}}function $6e(e,t){var n=[e.endPoint[0]-e.startPoint[0],e.endPoint[1]-e.startPoint[1]],r=[n[0]*t[0],n[1]*t[1]];return{startPoint:[e.startPoint[0]+r[0],e.startPoint[1]+r[1]],endPoint:[e.endPoint[0]+r[0],e.endPoint[1]+r[1]],palmLandmarks:e.palmLandmarks}}"function"==typeof SuppressedError&&SuppressedError;var R6e=function(){function e(e,t,n,r,a,s){this.model=e,this.width=t,this.height=n,this.iouThreshold=a,this.scoreThreshold=s,this.anchors=r.map((function(e){return[e.x_center,e.y_center]})),this.anchorsTensor=_$e(this.anchors),this.inputSizeTensor=A$e([t,n]),this.doubleInputSizeTensor=A$e([2*t,2*n])}return e.prototype.normalizeBoxes=function(e){var t=this;return vCe((function(){var n=_Ee(e,[0,0],[-1,2]),r=_Ee(e,[0,2],[-1,2]),a=$Ne(DNe(n,t.inputSizeTensor),t.anchorsTensor),s=DNe(r,t.doubleInputSizeTensor),i=MNe(YNe(a,s),t.inputSizeTensor),o=MNe($Ne(a,s),t.inputSizeTensor);return GEe([i,o],1)}))},e.prototype.normalizeLandmarks=function(e,t){var n=this;return vCe((function(){var r=$Ne(DNe(IEe(e,[-1,7,2]),n.inputSizeTensor),n.anchors[t]);return MNe(r,n.inputSizeTensor)}))},e.prototype.getBoundingBoxes=function(e){return I6e(this,void 0,void 0,(function(){var t,n,r,a,s,i,o,l,u,c,d,h,p,f,m,g=this;return C6e(this,(function(y){switch(y.label){case 0:return t=vCe((function(){return MNe(YNe(e,.5),2)})),"webgl"===kCe()?(r=kxe().get("WEBGL_PACK_DEPTHWISECONV"),kxe().set("WEBGL_PACK_DEPTHWISECONV",!0),n=this.model.predict(t),kxe().set("WEBGL_PACK_DEPTHWISECONV",r)):n=this.model.predict(t),a=I$e(n),s=vCe((function(){return I$e(AEe(_Ee(a,[0,0],[-1,1])))})),i=_Ee(a,[0,1],[-1,4]),o=this.normalizeBoxes(i),l=console.warn,console.warn=function(){},u=hDe.nonMaxSuppression(o,s,1,this.iouThreshold,this.scoreThreshold),console.warn=l,[4,u.array()];case 1:return c=y.sent(),d=[t,n,u,a,o,i,s],0===c.length?(d.forEach((function(e){return e.dispose()})),[2,null]):(h=c[0],p=_Ee(o,[h,0],[1,-1]),f=_Ee(a,[h,5],[1,14]),m=vCe((function(){return IEe(g.normalizeLandmarks(f,h),[-1,2])})),d.push(f),d.forEach((function(e){return e.dispose()})),[2,{boxes:p,palmLandmarks:m}])}}))}))},e.prototype.estimateHandBounds=function(e){return I6e(this,void 0,void 0,(function(){var t,n,r,a,s,i,o,l,u=this;return C6e(this,(function(c){switch(c.label){case 0:return t=e.shape[1],n=e.shape[2],r=vCe((function(){return DNe(hDe.resizeBilinear(e,[u.width,u.height]),255)})),[4,this.getBoundingBoxes(r)];case 1:return null===(a=c.sent())?(r.dispose(),[2,null]):(s=a.boxes.arraySync(),i=s[0].slice(0,2),o=s[0].slice(2,4),l=a.palmLandmarks.arraySync(),r.dispose(),a.boxes.dispose(),a.palmLandmarks.dispose(),[2,(d={startPoint:i,endPoint:o,palmLandmarks:l},h=[n/this.width,t/this.height],{startPoint:[d.startPoint[0]*h[0],d.startPoint[1]*h[1]],endPoint:[d.endPoint[0]*h[0],d.endPoint[1]*h[1]],palmLandmarks:d.palmLandmarks.map((function(e){return[e[0]*h[0],e[1]*h[1]]}))})])}var d,h}))}))},e}(),D6e={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]};var M6e=function(e,t){return[[1,0,e],[0,1,t],[0,0,1]]};function F6e(e,t){for(var n=0,r=0;r<e.length;r++)n+=e[r]*t[r];return n}function O6e(e,t){for(var n=[],r=0;r<e.length;r++)n.push(e[r][t]);return n}function P6e(e,t){for(var n=[],r=e.length,a=0;a<r;a++){n.push([]);for(var s=0;s<r;s++)n[a].push(F6e(e[a],O6e(t,s)))}return n}function L6e(e,t){var n=Math.cos(e),r=Math.sin(e),a=[[n,-r,0],[r,n,0],[0,0,1]],s=P6e(M6e(t[0],t[1]),a);return P6e(s,M6e(-t[0],-t[1]))}function z6e(e,t){return[F6e(e,t[0]),F6e(e,t[1])]}var B6e=[0,-.4],W6e=[0,-.1],V6e=[0,5,9,13,17,1,2],U6e=function(){function e(e,t,n,r,a,s){this.boundingBoxDetector=e,this.meshDetector=t,this.meshWidth=n,this.meshHeight=r,this.maxContinuousChecks=a,this.detectionConfidence=s,this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.maxHandsNumber=1}return e.prototype.getBoxForPalmLandmarks=function(e,t){var n=e.map((function(e){return z6e(N6e(N6e([],e,!0),[1],!1),t)}));return A6e(_6e($6e(this.calculateLandmarksBoundingBox(n),B6e)),3)},e.prototype.getBoxForHandLandmarks=function(e){for(var t=A6e(_6e($6e(this.calculateLandmarksBoundingBox(e),W6e)),1.65),n=[],r=0;r<V6e.length;r++)n.push(e[V6e[r]].slice(0,2));return t.palmLandmarks=n,t},e.prototype.transformRawCoords=function(e,t,n,r){var a,s,i,o,l=this,u=T6e(t),c=[u[0]/this.meshWidth,u[1]/this.meshHeight],d=e.map((function(e){return[c[0]*(e[0]-l.meshWidth/2),c[1]*(e[1]-l.meshHeight/2),e[2]]})),h=L6e(n,[0,0]),p=d.map((function(e){return N6e(N6e([],z6e(e,h),!0),[e[2]],!1)})),f=(s=[[(a=r)[0][0],a[1][0]],[a[0][1],a[1][1]]],i=[a[0][2],a[1][2]],o=[-F6e(s[0],i),-F6e(s[1],i)],[s[0].concat(o[0]),s[1].concat(o[1]),[0,0,1]]),m=N6e(N6e([],E6e(t),!0),[1],!1),g=[F6e(m,f[0]),F6e(m,f[1])];return p.map((function(e){return[e[0]+g[0],e[1]+g[1],e[2]]}))},e.prototype.estimateHand=function(e){return I6e(this,void 0,void 0,(function(){var t,n,r,a,s,i,o,l,u,c,d,h,p,f,m,g,y,b,v,x;return C6e(this,(function(w){switch(w.label){case 0:return!0!==(t=this.shouldUpdateRegionsOfInterest())?[3,2]:[4,this.boundingBoxDetector.estimateHandBounds(e)];case 1:return null===(n=w.sent())?(e.dispose(),this.regionsOfInterest=[],[2,null]):(this.updateRegionsOfInterest(n,!0),this.runsWithoutHandDetector=0,[3,3]);case 2:this.runsWithoutHandDetector++,w.label=3;case 3:return r=this.regionsOfInterest[0],a=function(e,t){var n;return(n=Math.PI/2-Math.atan2(-(t[1]-e[1]),t[0]-e[0]))-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}(r.palmLandmarks[0],r.palmLandmarks[2]),s=E6e(r),i=[s[0]/e.shape[2],s[1]/e.shape[1]],o=hDe.rotateWithOffset(e,a,0,i),l=L6e(-a,s),u=!0===t?this.getBoxForPalmLandmarks(r.palmLandmarks,l):r,c=function(e,t,n){var r=t.shape[1],a=t.shape[2],s=[[e.startPoint[1]/r,e.startPoint[0]/a,e.endPoint[1]/r,e.endPoint[0]/a]];return hDe.cropAndResize(t,s,[0],n)}(u,o,[this.meshWidth,this.meshHeight]),d=DNe(c,255),c.dispose(),o.dispose(),"webgl"===kCe()?(p=kxe().get("WEBGL_PACK_DEPTHWISECONV"),kxe().set("WEBGL_PACK_DEPTHWISECONV",!0),h=this.meshDetector.predict(d),kxe().set("WEBGL_PACK_DEPTHWISECONV",p)):h=this.meshDetector.predict(d),f=h[0],m=h[1],d.dispose(),g=f.dataSync()[0],f.dispose(),g<this.detectionConfidence?(m.dispose(),this.regionsOfInterest=[],[2,null]):(y=IEe(m,[-1,3]),b=y.arraySync(),m.dispose(),y.dispose(),v=this.transformRawCoords(b,u,a,l),x=this.getBoxForHandLandmarks(v),this.updateRegionsOfInterest(x,!1),[2,{landmarks:v,handInViewConfidence:g,boundingBox:{topLeft:x.startPoint,bottomRight:x.endPoint}}])}}))}))},e.prototype.calculateLandmarksBoundingBox=function(e){var t=e.map((function(e){return e[0]})),n=e.map((function(e){return e[1]}));return{startPoint:[Math.min.apply(Math,t),Math.min.apply(Math,n)],endPoint:[Math.max.apply(Math,t),Math.max.apply(Math,n)]}},e.prototype.updateRegionsOfInterest=function(e,t){if(t)this.regionsOfInterest=[e];else{var n=this.regionsOfInterest[0],r=0;if(null!=n&&null!=n.startPoint){var a=e.startPoint,s=a[0],i=a[1],o=e.endPoint,l=o[0],u=o[1],c=n.startPoint,d=c[0],h=c[1],p=n.endPoint,f=p[0],m=p[1],g=Math.max(s,d),y=Math.max(i,h),b=(Math.min(l,f)-g)*(Math.min(u,m)-y);r=b/((l-s)*(u-i)+(f-d)*(m-i)-b)}this.regionsOfInterest[0]=r>.8?n:e}},e.prototype.shouldUpdateRegionsOfInterest=function(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks},e}();function j6e(){return I6e(this,void 0,void 0,(function(){return C6e(this,(function(e){return[2,NUe("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1",{fromTFHub:!0})]}))}))}function G6e(){return I6e(this,void 0,void 0,(function(){return C6e(this,(function(e){return[2,NUe("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1",{fromTFHub:!0})]}))}))}function H6e(){return I6e(this,void 0,void 0,(function(){return C6e(this,(function(e){return[2,hIe("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then((function(e){return e.json()}))]}))}))}var q6e=function(){function e(e){this.pipeline=e}return e.getAnnotations=function(){return D6e},e.prototype.estimateHands=function(e,t){return void 0===t&&(t=!1),I6e(this,void 0,void 0,(function(){var n,r,a,s,i,o,l,u,c;return C6e(this,(function(d){switch(d.label){case 0:return n=function(e){return e instanceof RIe?[e.shape[0],e.shape[1]]:[e.height,e.width]}(e),r=n[1],a=vCe((function(){return e instanceof RIe||(e=$Te(e)),DAe(ENe(e,"float32"))})),[4,this.pipeline.estimateHand(a)];case 1:if(s=d.sent(),a.dispose(),null===s)return[2,[]];for(i=s,!0===t&&(i=function(e,t){var n=e.handInViewConfidence,r=e.landmarks,a=e.boundingBox;return{handInViewConfidence:n,landmarks:r.map((function(e){return[t-1-e[0],e[1],e[2]]})),boundingBox:{topLeft:[t-1-a.topLeft[0],a.topLeft[1]],bottomRight:[t-1-a.bottomRight[0],a.bottomRight[1]]}}}(s,r)),o={},l=0,u=Object.keys(D6e);l<u.length;l++)c=u[l],o[c]=D6e[c].map((function(e){return i.landmarks[e]}));return[2,[{handInViewConfidence:i.handInViewConfidence,boundingBox:i.boundingBox,landmarks:i.landmarks,annotations:o}]]}}))}))},e}();const K6e={thumb:[0,1,2,3,4],indexFinger:[0,5,6,7,8],middleFinger:[0,9,10,11,12],ringFinger:[0,13,14,15,16],littleFinger:[0,17,18,19,20]};var X6e=n(757);const Y6e=X6e.Finger.Thumb,Q6e=X6e.Finger.Index,J6e=X6e.Finger.Middle,Z6e=X6e.Finger.Ring,e8e=X6e.Finger.Pinky,t8e=X6e.FingerCurl.NoCurl,n8e=X6e.FingerCurl.FullCurl,r8e=X6e.FingerCurl.HalfCurl,a8e=X6e.FingerDirection.VerticalUpRight,s8e=X6e.FingerDirection.VerticalUp,i8e=X6e.FingerDirection.VerticalDown,o8e=X6e.FingerDirection.DiagonalUpRight,l8e=X6e.FingerDirection.DiagonalDownRight,u8e=X6e.FingerDirection.DiagonalUpLeft,c8e=X6e.FingerDirection.HorizontalRight,d8e=X6e.FingerDirection.HorizontalLeft,h8e=new X6e.GestureDescription("A");h8e.addCurl(Y6e,t8e,1),h8e.addDirection(Q6e,a8e,.7),h8e.addCurl(Q6e,n8e,1),h8e.addDirection(Q6e,i8e,.7),h8e.addCurl(J6e,n8e,1),h8e.addDirection(J6e,s8e,.7),h8e.addCurl(Z6e,n8e,1),h8e.addDirection(Z6e,s8e,.7),h8e.addCurl(e8e,n8e,1),h8e.addDirection(e8e,s8e,.7);const p8e=new X6e.GestureDescription("B");p8e.addCurl(Y6e,r8e,1),p8e.addDirection(Q6e,u8e,.7),p8e.addDirection(Q6e,o8e,.7),p8e.addCurl(Q6e,t8e,1),p8e.addDirection(Q6e,s8e,.7),p8e.addCurl(J6e,t8e,1),p8e.addDirection(J6e,s8e,.7),p8e.addCurl(Z6e,t8e,1),p8e.addDirection(Z6e,s8e,.7),p8e.addCurl(e8e,t8e,1),p8e.addDirection(e8e,s8e,.7);const f8e=new X6e.GestureDescription("C");f8e.addCurl(Y6e,t8e,1),f8e.addDirection(Q6e,o8e,.7),f8e.addCurl(Q6e,t8e,1),f8e.addDirection(Q6e,o8e,.7),f8e.addCurl(J6e,r8e,1),f8e.addDirection(J6e,o8e,.7),f8e.addCurl(Z6e,r8e,1),f8e.addDirection(Z6e,o8e,.7),f8e.addCurl(e8e,r8e,1),f8e.addDirection(e8e,o8e,.7);const m8e=new X6e.GestureDescription("D");m8e.addCurl(Y6e,r8e,1),m8e.addDirection(Q6e,s8e,.7),m8e.addCurl(Q6e,t8e,1),m8e.addDirection(Q6e,s8e,.7),m8e.addCurl(J6e,n8e,1),m8e.addDirection(J6e,s8e,.7),m8e.addCurl(Z6e,n8e,1),m8e.addDirection(Z6e,s8e,.7),m8e.addCurl(e8e,n8e,1),m8e.addDirection(e8e,s8e,.7);const g8e=new X6e.GestureDescription("E");g8e.addCurl(Y6e,r8e,1),g8e.addDirection(Q6e,s8e,.7),g8e.addCurl(Q6e,n8e,1),g8e.addDirection(Q6e,s8e,.7),g8e.addCurl(J6e,n8e,1),g8e.addDirection(J6e,s8e,.7),g8e.addCurl(Z6e,n8e,1),g8e.addDirection(Z6e,s8e,.7),g8e.addCurl(e8e,n8e,1),g8e.addDirection(e8e,s8e,.7);const y8e=new X6e.GestureDescription("F");y8e.addCurl(Y6e,r8e,1),y8e.addDirection(Q6e,o8e,.7),y8e.addCurl(Q6e,n8e,1),y8e.addDirection(Q6e,o8e,.7),y8e.addCurl(J6e,t8e,1),y8e.addDirection(J6e,s8e,.7),y8e.addCurl(Z6e,t8e,1),y8e.addDirection(Z6e,s8e,.7),y8e.addCurl(e8e,t8e,1),y8e.addDirection(e8e,s8e,.7);const b8e=new X6e.GestureDescription("G");b8e.addCurl(Y6e,t8e,1),b8e.addDirection(Q6e,o8e,.7),b8e.addCurl(Q6e,t8e,1),b8e.addDirection(Q6e,c8e,.7),b8e.addCurl(J6e,n8e,1),b8e.addDirection(J6e,o8e,.7),b8e.addCurl(Z6e,n8e,1),b8e.addDirection(Z6e,c8e,.7),b8e.addCurl(e8e,n8e,1),b8e.addDirection(e8e,c8e,.7);const v8e=new X6e.GestureDescription("H");v8e.addCurl(Y6e,t8e,1),v8e.addDirection(Q6e,c8e,.7),v8e.addCurl(Q6e,t8e,1),v8e.addDirection(Q6e,c8e,.7),v8e.addCurl(J6e,t8e,1),v8e.addDirection(J6e,c8e,.7),v8e.addCurl(Z6e,n8e,1),v8e.addDirection(Z6e,c8e,.7),v8e.addCurl(e8e,n8e,1),v8e.addDirection(e8e,c8e,.7);const x8e=new X6e.GestureDescription("I");x8e.addCurl(Y6e,r8e,1),x8e.addDirection(Q6e,u8e,.7),x8e.addCurl(Q6e,n8e,1),x8e.addDirection(Q6e,s8e,.7),x8e.addCurl(J6e,n8e,1),x8e.addDirection(J6e,s8e,.7),x8e.addCurl(Z6e,n8e,1),x8e.addDirection(Z6e,s8e,.7),x8e.addCurl(e8e,t8e,1),x8e.addDirection(e8e,s8e,.7);const w8e=new X6e.GestureDescription("J");w8e.addCurl(Y6e,t8e,1),w8e.addDirection(Q6e,o8e,.7),w8e.addCurl(Q6e,n8e,1),w8e.addDirection(Q6e,o8e,.7),w8e.addCurl(J6e,n8e,1),w8e.addDirection(J6e,o8e,.7),w8e.addCurl(Z6e,n8e,1),w8e.addDirection(Z6e,c8e,.7),w8e.addCurl(e8e,t8e,1),w8e.addDirection(e8e,c8e,.7);const k8e=new X6e.GestureDescription("K");k8e.addCurl(Y6e,t8e,1),k8e.addDirection(Q6e,u8e,.7),k8e.addCurl(Q6e,t8e,1),k8e.addDirection(Q6e,o8e,.7),k8e.addCurl(J6e,t8e,1),k8e.addDirection(J6e,s8e,.7),k8e.addCurl(Z6e,n8e,1),k8e.addDirection(Z6e,s8e,.7),k8e.addCurl(e8e,n8e,1),k8e.addDirection(e8e,s8e,.7);const S8e=new X6e.GestureDescription("L");S8e.addCurl(Y6e,t8e,1),S8e.addDirection(Q6e,o8e,.7),S8e.addCurl(Q6e,t8e,1),S8e.addDirection(Q6e,s8e,.7),S8e.addCurl(J6e,n8e,1),S8e.addDirection(J6e,s8e,.7),S8e.addCurl(Z6e,n8e,1),S8e.addDirection(Z6e,s8e,.7),S8e.addCurl(e8e,n8e,1),S8e.addDirection(e8e,s8e,.7);const I8e=new X6e.GestureDescription("M");I8e.addCurl(Y6e,r8e,1),I8e.addDirection(Q6e,u8e,.7),I8e.addCurl(Q6e,n8e,1),I8e.addDirection(Q6e,o8e,.7),I8e.addCurl(J6e,n8e,1),I8e.addDirection(J6e,s8e,.7),I8e.addCurl(Z6e,n8e,1),I8e.addDirection(Z6e,s8e,.7),I8e.addCurl(e8e,n8e,1),I8e.addDirection(e8e,s8e,.7);const C8e=new X6e.GestureDescription("N");C8e.addCurl(Y6e,r8e,1),C8e.addDirection(Q6e,u8e,.7),C8e.addCurl(Q6e,n8e,1),C8e.addDirection(Q6e,o8e,.7),C8e.addCurl(J6e,n8e,1),C8e.addDirection(J6e,s8e,.7),C8e.addCurl(Z6e,n8e,1),C8e.addDirection(Z6e,s8e,.7),C8e.addCurl(e8e,n8e,1),C8e.addDirection(e8e,u8e,.7);const N8e=new X6e.GestureDescription("O");N8e.addCurl(Y6e,t8e,1),N8e.addDirection(Q6e,o8e,.7),N8e.addCurl(Q6e,r8e,1),N8e.addDirection(Q6e,o8e,.7),N8e.addCurl(J6e,r8e,1),N8e.addDirection(J6e,o8e,.7),N8e.addCurl(Z6e,n8e,1),N8e.addDirection(Z6e,o8e,.7),N8e.addCurl(e8e,n8e,1),N8e.addDirection(e8e,o8e,.7);const T8e=new X6e.GestureDescription("P");T8e.addCurl(Y6e,t8e,1),T8e.addDirection(Q6e,c8e,.7),T8e.addCurl(Q6e,t8e,1),T8e.addDirection(Q6e,c8e,.7),T8e.addCurl(J6e,r8e,1),T8e.addDirection(J6e,l8e,.7),T8e.addCurl(Z6e,n8e,1),T8e.addDirection(Z6e,l8e,.7),T8e.addCurl(e8e,n8e,1),T8e.addDirection(e8e,l8e,.7);const E8e=new X6e.GestureDescription("Q");E8e.addCurl(Y6e,t8e,1),E8e.addDirection(Q6e,l8e,.7),E8e.addCurl(Q6e,r8e,1),E8e.addDirection(Q6e,c8e,.7),E8e.addCurl(J6e,n8e,1),E8e.addDirection(J6e,c8e,.7),E8e.addCurl(Z6e,n8e,1),E8e.addDirection(Z6e,l8e,.7),E8e.addCurl(e8e,n8e,1),E8e.addDirection(e8e,l8e,.7);const A8e=new X6e.GestureDescription("R");A8e.addCurl(Y6e,r8e,1),A8e.addDirection(Q6e,u8e,.7),A8e.addCurl(Q6e,t8e,1),A8e.addDirection(Q6e,s8e,.7),A8e.addCurl(J6e,t8e,1),A8e.addDirection(J6e,s8e,.7),A8e.addCurl(Z6e,n8e,1),A8e.addDirection(Z6e,s8e,.7),A8e.addCurl(e8e,n8e,1),A8e.addDirection(e8e,s8e,.7);const _8e=new X6e.GestureDescription("S");_8e.addCurl(Y6e,r8e,1),_8e.addDirection(Q6e,s8e,.7),_8e.addCurl(Q6e,n8e,1),_8e.addDirection(Q6e,o8e,.7),_8e.addCurl(J6e,n8e,1),_8e.addDirection(J6e,s8e,.7),_8e.addCurl(Z6e,n8e,1),_8e.addDirection(Z6e,s8e,.7),_8e.addCurl(e8e,n8e,1),_8e.addDirection(e8e,u8e,.7);const $8e=new X6e.GestureDescription("T");$8e.addCurl(Y6e,t8e,1),$8e.addDirection(Q6e,s8e,.7),$8e.addCurl(Q6e,n8e,1),$8e.addDirection(Q6e,o8e,.7),$8e.addCurl(J6e,n8e,1),$8e.addDirection(J6e,s8e,.7),$8e.addCurl(Z6e,n8e,1),$8e.addDirection(Z6e,s8e,.7),$8e.addCurl(e8e,n8e,1),$8e.addDirection(e8e,u8e,.7);const R8e=new X6e.GestureDescription("U");R8e.addCurl(Y6e,r8e,1),R8e.addDirection(Q6e,u8e,.7),R8e.addCurl(Q6e,t8e,1),R8e.addDirection(Q6e,s8e,.7),R8e.addCurl(J6e,t8e,1),R8e.addDirection(J6e,s8e,.7),R8e.addCurl(Z6e,n8e,1),R8e.addDirection(Z6e,s8e,.7),R8e.addCurl(e8e,n8e,1),R8e.addDirection(e8e,u8e,.7);const D8e=new X6e.GestureDescription("V");D8e.addCurl(Y6e,r8e,1),D8e.addDirection(Q6e,u8e,.7),D8e.addCurl(Q6e,t8e,1),D8e.addDirection(Q6e,o8e,.7),D8e.addCurl(J6e,t8e,1),D8e.addDirection(J6e,s8e,.7),D8e.addCurl(Z6e,n8e,1),D8e.addDirection(Z6e,s8e,.7),D8e.addCurl(e8e,n8e,1),D8e.addDirection(e8e,u8e,.7);const M8e=new X6e.GestureDescription("W");M8e.addCurl(Y6e,r8e,1),M8e.addDirection(Q6e,u8e,.7),M8e.addCurl(Q6e,t8e,1),M8e.addDirection(Q6e,o8e,.7),M8e.addCurl(J6e,t8e,1),M8e.addDirection(J6e,s8e,.7),M8e.addCurl(Z6e,t8e,1),M8e.addDirection(Z6e,u8e,.7),M8e.addCurl(e8e,n8e,1),M8e.addDirection(e8e,u8e,.7);const F8e=new X6e.GestureDescription("X");F8e.addCurl(Y6e,r8e,1),F8e.addDirection(Q6e,s8e,.7),F8e.addCurl(Q6e,r8e,1),F8e.addDirection(Q6e,s8e,.7),F8e.addCurl(J6e,n8e,1),F8e.addDirection(J6e,s8e,.7),F8e.addCurl(Z6e,n8e,1),F8e.addDirection(Z6e,s8e,.7),F8e.addCurl(e8e,n8e,1),F8e.addDirection(e8e,s8e,.7);const O8e=new X6e.GestureDescription("Y");O8e.addCurl(Y6e,t8e,1),O8e.addDirection(Q6e,o8e,.7),O8e.addCurl(Q6e,n8e,1),O8e.addDirection(Q6e,s8e,.7),O8e.addCurl(J6e,n8e,1),O8e.addDirection(J6e,s8e,.7),O8e.addCurl(Z6e,t8e,1),O8e.addDirection(Z6e,s8e,.7),O8e.addCurl(e8e,t8e,1),O8e.addDirection(e8e,u8e,.7);const P8e=new X6e.GestureDescription("Z");P8e.addCurl(Y6e,t8e,.8),P8e.addDirection(Q6e,d8e,.7),P8e.addCurl(Q6e,t8e,1),P8e.addDirection(Q6e,u8e,.7),P8e.addCurl(J6e,n8e,1),P8e.addDirection(J6e,d8e,.7),P8e.addCurl(Z6e,n8e,1),P8e.addDirection(Z6e,d8e,.7),P8e.addCurl(e8e,n8e,1),P8e.addDirection(e8e,d8e,.7);const L8e={a_ASL:h8e,b_ASL:p8e,c_ASL:f8e,d_ASL:m8e,e_ASL:g8e,f_ASL:y8e,g_ASL:b8e,h_ASL:v8e,i_ASL:x8e,j_ASL:w8e,k_ASL:k8e,l_ASL:S8e,m_ASL:I8e,n_ASL:C8e,o_ASL:N8e,p_ASL:T8e,q_ASL:E8e,r_ASL:A8e,s_ASL:_8e,t_ASL:$8e,u_ASL:R8e,v_ASL:D8e,w_ASL:M8e,x_ASL:F8e,y_ASL:O8e,z_ASL:P8e};var z8e=n(1136);const B8e=T.createContext();function W8e(e){return(0,gr.Ay)("MuiGrid",e)}const V8e=["auto",!0,1,2,3,4,5,6,7,8,9,10,11,12],U8e=(0,rr.A)("MuiGrid",["root","container","item","zeroMinWidth",...[0,1,2,3,4,5,6,7,8,9,10].map((e=>`spacing-xs-${e}`)),...["column-reverse","column","row-reverse","row"].map((e=>`direction-xs-${e}`)),...["nowrap","wrap-reverse","wrap"].map((e=>`wrap-xs-${e}`)),...V8e.map((e=>`grid-xs-${e}`)),...V8e.map((e=>`grid-sm-${e}`)),...V8e.map((e=>`grid-md-${e}`)),...V8e.map((e=>`grid-lg-${e}`)),...V8e.map((e=>`grid-xl-${e}`))]);function j8e(e){let{breakpoints:t,values:n}=e,r="";Object.keys(n).forEach((e=>{""===r&&0!==n[e]&&(r=e)}));const a=Object.keys(t).sort(((e,n)=>t[e]-t[n]));return a.slice(0,a.indexOf(r))}const G8e=(0,cr.Ay)("div",{name:"MuiGrid",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e,{container:r,direction:a,item:s,spacing:i,wrap:o,zeroMinWidth:l,breakpoints:u}=n;let c=[];r&&(c=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!e||e<=0)return[];if("string"===typeof e&&!Number.isNaN(Number(e))||"number"===typeof e)return[n[`spacing-xs-${String(e)}`]];const r=[];return t.forEach((t=>{const a=e[t];Number(a)>0&&r.push(n[`spacing-${t}-${String(a)}`])})),r}(i,u,t));const d=[];return u.forEach((e=>{const r=n[e];r&&d.push(t[`grid-${e}-${String(r)}`])})),[t.root,r&&t.container,s&&t.item,l&&t.zeroMinWidth,...c,"row"!==a&&t[`direction-xs-${String(a)}`],"wrap"!==o&&t[`wrap-xs-${String(o)}`],...d]}})((e=>{let{ownerState:t}=e;return{boxSizing:"border-box",...t.container&&{display:"flex",flexWrap:"wrap",width:"100%"},...t.item&&{margin:0},...t.zeroMinWidth&&{minWidth:0},..."wrap"!==t.wrap&&{flexWrap:t.wrap}}}),(function(e){let{theme:t,ownerState:n}=e;const r=(0,z8e.kW)({values:n.direction,breakpoints:t.breakpoints.values});return(0,z8e.NI)({theme:t},r,(e=>{const t={flexDirection:e};return e.startsWith("column")&&(t[`& > .${U8e.item}`]={maxWidth:"none"}),t}))}),(function(e){let{theme:t,ownerState:n}=e;const{container:r,rowSpacing:a}=n;let s={};if(r&&0!==a){const e=(0,z8e.kW)({values:a,breakpoints:t.breakpoints.values});let n;"object"===typeof e&&(n=j8e({breakpoints:t.breakpoints.values,values:e})),s=(0,z8e.NI)({theme:t},e,((e,r)=>{const a=t.spacing(e);return"0px"!==a?{marginTop:t.spacing(-e),[`& > .${U8e.item}`]:{paddingTop:a}}:n?.includes(r)?{}:{marginTop:0,[`& > .${U8e.item}`]:{paddingTop:0}}}))}return s}),(function(e){let{theme:t,ownerState:n}=e;const{container:r,columnSpacing:a}=n;let s={};if(r&&0!==a){const e=(0,z8e.kW)({values:a,breakpoints:t.breakpoints.values});let n;"object"===typeof e&&(n=j8e({breakpoints:t.breakpoints.values,values:e})),s=(0,z8e.NI)({theme:t},e,((e,r)=>{const a=t.spacing(e);if("0px"!==a){return{width:`calc(100% + ${a})`,marginLeft:t.spacing(-e),[`& > .${U8e.item}`]:{paddingLeft:a}}}return n?.includes(r)?{}:{width:"100%",marginLeft:0,[`& > .${U8e.item}`]:{paddingLeft:0}}}))}return s}),(function(e){let t,{theme:n,ownerState:r}=e;return n.breakpoints.keys.reduce(((e,a)=>{let s={};if(r[a]&&(t=r[a]),!t)return e;if(!0===t)s={flexBasis:0,flexGrow:1,maxWidth:"100%"};else if("auto"===t)s={flexBasis:"auto",flexGrow:0,flexShrink:0,maxWidth:"none",width:"auto"};else{const i=(0,z8e.kW)({values:r.columns,breakpoints:n.breakpoints.values}),o="object"===typeof i?i[a]:i;if(void 0===o||null===o)return e;const l=Math.round(t/o*1e8)/1e6+"%";let u={};if(r.container&&r.item&&0!==r.columnSpacing){const e=n.spacing(r.columnSpacing);if("0px"!==e){const t=`calc(${l} + ${e})`;u={flexBasis:t,maxWidth:t}}}s={flexBasis:l,flexGrow:0,maxWidth:l,...u}}return 0===n.breakpoints.values[a]?Object.assign(e,s):e[n.breakpoints.up(a)]=s,e}),{})}));const H8e=e=>{const{classes:t,container:n,direction:r,item:a,spacing:s,wrap:i,zeroMinWidth:o,breakpoints:l}=e;let u=[];n&&(u=function(e,t){if(!e||e<=0)return[];if("string"===typeof e&&!Number.isNaN(Number(e))||"number"===typeof e)return[`spacing-xs-${String(e)}`];const n=[];return t.forEach((t=>{const r=e[t];if(Number(r)>0){const e=`spacing-${t}-${String(r)}`;n.push(e)}})),n}(s,l));const c=[];l.forEach((t=>{const n=e[t];n&&c.push(`grid-${t}-${String(n)}`)}));const d={root:["root",n&&"container",a&&"item",o&&"zeroMinWidth",...u,"row"!==r&&`direction-xs-${String(r)}`,"wrap"!==i&&`wrap-xs-${String(i)}`,...c]};return(0,lr.A)(d,W8e,t)},q8e=T.forwardRef((function(e,t){const n=mo({props:e,name:"MuiGrid"}),{breakpoints:r}=hr(),a=qn(n),{className:s,columns:i,columnSpacing:o,component:l="div",container:u=!1,direction:c="row",item:d=!1,rowSpacing:h,spacing:p=0,wrap:f="wrap",zeroMinWidth:m=!1,...g}=a,y=h||p,b=o||p,v=T.useContext(B8e),x=u?i||12:v,w={},k={...g};r.keys.forEach((e=>{null!=g[e]&&(w[e]=g[e],delete k[e])}));const S={...a,columns:x,container:u,direction:c,item:d,rowSpacing:y,columnSpacing:b,wrap:f,zeroMinWidth:m,spacing:p,...w,breakpoints:r.keys},I=H8e(S);return(0,Zn.jsx)(B8e.Provider,{value:x,children:(0,Zn.jsx)(G8e,{ownerState:S,className:(0,Wn.A)(I.root,s),as:l,ref:t,...k})})}));const K8e=q8e,X8e="ABCDEFGHIJKLMNOPQRSTUVWXYZ";var Y8e;Y8e="webgl",ZIe.setBackend(Y8e);const Q8e=e=>{let{userData:t,userId:n}=e;const r=ee(),a=(0,T.useRef)(null),s=(0,T.useRef)(null),[i,o]=(0,T.useState)("block"),[l,u]=(0,T.useState)(!1),[c,d]=(0,T.useState)(60),h=(0,T.useRef)(null),p=xn(),f=(()=>{const e=Math.floor(26*Math.random());return X8e[e]})(),m=`<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; color: #333333;">\n  <h1 style="color: #0066cc; text-align: center;">Authentication Instructions</h1>\n  <p style="font-size: 16px; line-height: 1.5;">Dear User,</p>\n  <p style="font-size: 16px; line-height: 1.5;">To authenticate yourself, please follow these steps:</p>\n  <ol style="font-size: 16px; line-height: 1.5;">\n    <li>Position yourself in front of your camera.</li>\n    <li>Ensure your background is clear and no other person is in the frame.</li>\n    <li>Make the hand sign for the letter ${f} in American Sign Language, as shown in the image below.</li>\n    <li>Make sure both your face and hand sign are clearly visible in the camera frame.</li>\n  </ol>\n  <h2 style="color: #0066cc; text-align: center;">Hand Sign for Letter ${f}</h2>\n  <img src=${`https://firebasestorage.googleapis.com/v0/b/auth-tfjs.appspot.com/o/HandSign%20Image%2F${f}.jpg?alt=media&token=d891e715-d5ab-49ee-8c4c-d14c25d7fb7a`} alt="Hand sign for letter ${f} in American Sign Language" style="display: block; max-width: 100%; height: auto; margin: 20px auto; border: 2px solid #0066cc;">\n  <p style="font-size: 16px; line-height: 1.5; font-weight: bold;">Important Notes:</p>\n  <ul style="font-size: 16px; line-height: 1.5;">\n    <li>Ensure good lighting for clear visibility.</li>\n    <li>Hold the hand sign steady for a few seconds.</li>\n  </ul>\n  <p style="font-size: 16px; line-height: 1.5;">Thank you for your cooperation in maintaining the security of your account.</p>\n  <p style="font-size: 16px; line-height: 1.5;">Best regards,<br>Your Authentication Team</p>\n  </div>`,g=()=>{d(6),h.current=setInterval((()=>{d((e=>e<=1?(clearInterval(h.current),r(kt()),p("/authenticated?username=invalid"),0):e-1))}),1e3)},y=async()=>{await(async(e,t,n,r)=>{try{await hv(_b(gv,"mail"),{to:[e],message:{subject:`Instructions: You have to draw ${n} in American Sign Language`,html:t}}),console.log("Image uploaded and email sent successfully"),r()}catch(a){console.error("Error uploading image or sending email: ",a)}})(t.email,m,f,g);const e=await function(e){var t=void 0===e?{}:e,n=t.maxContinuousChecks,r=void 0===n?1/0:n,a=t.detectionConfidence,s=void 0===a?.8:a,i=t.iouThreshold,o=void 0===i?.3:i,l=t.scoreThreshold,u=void 0===l?.5:l;return I6e(this,void 0,void 0,(function(){var e,t,n,a,i,l;return C6e(this,(function(c){switch(c.label){case 0:return[4,Promise.all([H6e(),j6e(),G6e()])];case 1:return e=c.sent(),t=e[0],n=e[1],a=e[2],i=new R6e(n,256,256,t,o,u),l=new U6e(i,a,256,256,r,s),[2,new q6e(l)]}}))}))}();h.current=setInterval((()=>{b(e,f)}),170)},b=async(e,i)=>{const{current:c}=a,{video:d}=c||{};if(c&&c.video&&s.current){if(!l&&d&&4===d.readyState)try{const a=d.videoWidth,l=d.videoHeight;c.video.width=a,c.video.height=l,s.current.width=a,s.current.height=l;const g=await e.estimateHands(d),y=await Ybe(d,new Sbe).withFaceLandmarks().withFaceDescriptors();if(g.length>0){var f;const e="ABCDEFGHIJKLMNOPQRSTUVWXYZ".toLowerCase().split("").map((e=>L8e[`${e}_ASL`])),s=new X6e.GestureEstimator([X6e.Gestures.ThumbsUpGesture,...e]),m=await s.estimate(g[0].landmarks,6.5);if((null===(f=m.gestures.reduce(((e,t)=>t.score>e.score?t:e),m.gestures[0]))||void 0===f?void 0:f.name)===i){clearInterval(h.current),h.current=null,u(!0),o("none");const e=await(async(e,t,n,r)=>{try{const a=document.createElement("canvas");a.width=e,a.height=t,a.getContext("2d").drawImage(n,0,0,e,t);const s=a.toDataURL("image/png"),i=new Image;return i.src=s,new Promise((e=>{i.onload=async()=>{const t=[...Array(5)].map(((e,t)=>new Nge(r.name,[new Float32Array(r.descriptors[t])])));let n=!1;const a=new Qbe(t);(await Ybe(i,new Sbe).withFaceLandmarks().withFaceDescriptors()).forEach((e=>{const{descriptor:t}=e,s=a.findBestMatch(t);n=!!s.label&&r.name})),e(n)}}))}catch(a){console.log("Error caught in faceRecognition",a)}})(a,l,d,t);if(c&&c.video&&c.video.srcObject){const e=c.video.srcObject;e.getTracks().forEach((e=>e.stop()))}return e?(r(xt({name:t.name,email:t.email,dateOfBirth:t.DOB,userId:n})),p(`/authenticated?username=${e}`)):p("/error")}}if(y.length>0){s.current.innerHTML=Xge(d);const e={width:a,height:l};!function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{width:r,height:a}=n?qge(t):t;e.width=r,e.height=a}(s.current,e);const t=Jbe(y,e);try{s&&s.current&&Yme.drawDetections(s.current,t);new Yme.DrawBox(y[0].detection.box,{label:"Face Detected"}).draw(s.current)}catch(m){console.log(m)}}const b=s.current.getContext("2d");((e,t)=>{e.length>0&&e.forEach((e=>{const n=e.landmarks;Object.keys(K6e).forEach((e=>{const r=K6e[e];r.slice(0,-1).forEach(((e,a)=>{const s=r[a],i=r[a+1];t.beginPath(),t.moveTo(n[s][0],n[s][1]),t.lineTo(n[i][0],n[i][1]),t.strokeStyle="#FF4500",t.lineWidth=2,t.stroke()}))})),n.forEach((e=>{let[n,r]=e;t.beginPath(),t.arc(n,r,5,0,3*Math.PI),t.fillStyle="#32CD32",t.fill()}))}))})(g,b),b.clearRect(0,0,s.width,s.height)}catch(m){console.log("Error during the recognition:",m)}}else console.error("Webcam or canvas not available for face detection.")};return(0,T.useEffect)((()=>((async()=>{try{y()}catch(e){console.error("Error during model loading or inference:",e)}})(),()=>clearInterval(h.current))),[]),(0,Zn.jsx)(or,{padding:1,sx:{display:"flex",alignItems:"center",justifyContent:"center",height:"100dvh"},children:(0,Zn.jsxs)(K8e,{container:!0,spacing:2,alignItems:"center",justifyContent:"center",children:[(0,Zn.jsxs)(K8e,{item:!0,xs:12,md:9,lg:8,children:[(0,Zn.jsx)(or,{display:"flex",justifyContent:"center",position:"relative",sx:{width:"100%"},children:(0,Zn.jsxs)(or,{sx:{position:"relative",width:"100%",maxWidth:"600px"},children:[(0,Zn.jsx)(dT(),{id:"webcam",ref:a,style:{width:"100%",height:"auto",borderRadius:"10px",objectFit:"cover"}}),(0,Zn.jsx)("canvas",{id:"gesture-canvas",ref:s,style:{display:i,position:"absolute",top:0,left:0,width:"100%",height:"100%",borderRadius:"10px"}})]})}),(0,Zn.jsxs)(Pr,{variant:"h5",align:"center",sx:{marginTop:2},children:["Time Remaining: ",c," seconds"]})]}),(0,Zn.jsx)(K8e,{item:!0,xs:12,md:3,lg:2,children:(0,Zn.jsx)(or,{display:"flex",flexDirection:"column",justifyContent:"flex-start",children:(0,Zn.jsxs)(xr,{elevation:3,sx:{padding:"20px",marginBottom:"20px"},children:[(0,Zn.jsx)(Pr,{variant:"h6",align:"center",children:"Kindly Check your email for Instructions on performing Hand Signs"}),(0,Zn.jsx)(Pr,{variant:"body1",align:"center",sx:{marginTop:"10px"},children:"Ensure your background is clear and no other person is present in the frame."})]})})})]})})},J8e=()=>{const[e,t]=(0,T.useState)(""),[n,r]=(0,T.useState)(null),[a,s]=(0,T.useState)(""),[i,o]=(0,T.useState)(!1),[l,u]=(0,T.useState)(!1),[c,d]=(0,T.useState)(!1),h=()=>{u(!1)};return c?(0,Zn.jsx)(Q8e,{userData:n,userId:e}):(0,Zn.jsxs)(Wl,{maxWidth:"sm",sx:{mt:10},children:[(0,Zn.jsxs)(or,{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",sx:{padding:4,boxShadow:"0px 0px 20px rgba(0, 0, 0, 0.1)",borderRadius:3,backgroundColor:"#ffffff",transition:"box-shadow 0.3s ease","&:hover":{boxShadow:"0px 0px 30px rgba(0, 0, 0, 0.15)"}},children:[(0,Zn.jsx)(Pr,{variant:"h4",gutterBottom:!0,sx:{color:"#1976d2",fontWeight:"bold"},children:"Enter Your User ID"}),(0,Zn.jsx)(No,{label:"User ID",variant:"outlined",fullWidth:!0,error:!!a,helperText:a,value:e,onChange:e=>t(e.target.value),sx:{marginBottom:3}}),(0,Zn.jsx)(sl,{variant:"contained",color:"primary",onClick:async()=>{if(!e)return void s("User ID is required.");if(/^[a-zA-Z0-9]+$/.test(e)){s(""),o(!0);try{const n=await yv(e);if(console.log("userDocSnap",n.data()),void 0!==n.data()){var t;const e=null!==(t=n.data())&&void 0!==t?t:{},a=((e,t)=>_ve().AES.decrypt(e,t.name+t.DOB).toString(_ve().enc.Utf8))(e.email,e),s=(e=>Object.keys(e).filter((e=>e.startsWith("descriptors_"))).map((t=>JSON.parse(_ve().AES.decrypt(e[t],e.name+e.DOB).toString(_ve().enc.Utf8)))))(e);r({...e,email:a,descriptors:s}),setTimeout((()=>{d(!0)}),1500)}else s("No such User ID exists.")}catch(a){s("Something went wrong! Please try again.")}finally{u(!0),o(!1)}}else s("User ID must be alphanumeric.")},sx:{backgroundColor:"#1976d2","&:hover":{backgroundColor:"#1565c0"},width:"100%",padding:"10px 0",fontSize:"16px",display:"flex",alignItems:"center",justifyContent:"center"},disabled:i,children:i?(0,Zn.jsx)(cve,{size:24}):"Submit"})]}),(0,Zn.jsx)(Eve,{open:l,autoHideDuration:3e3,onClose:h,anchorOrigin:{vertical:"top",horizontal:"right"},children:(0,Zn.jsx)(Sl,{onClose:h,severity:a.length?"error":"success",sx:{width:"100%"},children:a.length?a:"You are successfully Logged In!"})})]})};function Z8e(){return(0,T.useEffect)((()=>{(async()=>{await(async()=>{try{await Promise.all([_be.ssdMobilenetv1.loadFromUri("/models"),_be.tinyFaceDetector.loadFromUri("/models"),_be.faceLandmark68Net.loadFromUri("/models"),_be.faceRecognitionNet.loadFromUri("/models")]),console.log("Face Models are loaded!!!")}catch(e){console.error("Error loading models:",e)}})()})()}),[]),(0,Zn.jsx)(Ln,{children:(0,Zn.jsxs)(Fn,{children:[(0,Zn.jsx)(Dn,{path:"/",element:(0,Zn.jsx)(Dve,{})}),(0,Zn.jsx)(Dn,{path:"/login",element:(0,Zn.jsx)(J8e,{})}),(0,Zn.jsx)(Dn,{path:"/loggedUser",element:(0,Zn.jsx)(Dl,{})}),(0,Zn.jsx)(Dn,{path:"/authenticated",element:(0,Zn.jsx)(vv,{})}),(0,Zn.jsx)(Dn,{path:"/error",element:(0,Zn.jsx)(Mve,{})})]})})}A.render((0,Zn.jsx)(Y,{store:It,children:(0,Zn.jsx)(Z8e,{})}),document.getElementById("root"))})()})();
//# sourceMappingURL=main.14500cd2.js.map