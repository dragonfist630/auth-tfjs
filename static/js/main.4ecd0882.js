/*! For license information please see main.4ecd0882.js.LICENSE.txt */
(()=>{var e={7291:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=7291,e.exports=t},3803:(e,t,n)=>{"use strict";n.d(t,{A:()=>ae});var r=function(){function e(e){var t=this;this._insertTag=function(e){var n;n=0===t.tags.length?t.insertionPoint?t.insertionPoint.nextSibling:t.prepend?t.container.firstChild:t.before:t.tags[t.tags.length-1].nextSibling,t.container.insertBefore(e,n),t.tags.push(e)},this.isSpeedy=void 0===e.speedy||e.speedy,this.tags=[],this.ctr=0,this.nonce=e.nonce,this.key=e.key,this.container=e.container,this.prepend=e.prepend,this.insertionPoint=e.insertionPoint,this.before=null}var t=e.prototype;return t.hydrate=function(e){e.forEach(this._insertTag)},t.insert=function(e){this.ctr%(this.isSpeedy?65e3:1)===0&&this._insertTag(function(e){var t=document.createElement("style");return t.setAttribute("data-emotion",e.key),void 0!==e.nonce&&t.setAttribute("nonce",e.nonce),t.appendChild(document.createTextNode("")),t.setAttribute("data-s",""),t}(this));var t=this.tags[this.tags.length-1];if(this.isSpeedy){var n=function(e){if(e.sheet)return e.sheet;for(var t=0;t<document.styleSheets.length;t++)if(document.styleSheets[t].ownerNode===e)return document.styleSheets[t]}(t);try{n.insertRule(e,n.cssRules.length)}catch(r){}}else t.appendChild(document.createTextNode(e));this.ctr++},t.flush=function(){this.tags.forEach((function(e){var t;return null==(t=e.parentNode)?void 0:t.removeChild(e)})),this.tags=[],this.ctr=0},e}(),a=Math.abs,s=String.fromCharCode,i=Object.assign;function o(e){return e.trim()}function l(e,t,n){return e.replace(t,n)}function u(e,t){return e.indexOf(t)}function c(e,t){return 0|e.charCodeAt(t)}function d(e,t,n){return e.slice(t,n)}function h(e){return e.length}function p(e){return e.length}function f(e,t){return t.push(e),e}var m=1,g=1,y=0,b=0,v=0,x="";function w(e,t,n,r,a,s,i){return{value:e,root:t,parent:n,type:r,props:a,children:s,line:m,column:g,length:i,return:""}}function k(e,t){return i(w("",null,null,"",null,null,0),e,{length:-e.length},t)}function S(){return v=b>0?c(x,--b):0,g--,10===v&&(g=1,m--),v}function I(){return v=b<y?c(x,b++):0,g++,10===v&&(g=1,m++),v}function T(){return c(x,b)}function N(){return b}function C(e,t){return d(x,e,t)}function A(e){switch(e){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function E(e){return m=g=1,y=h(x=e),b=0,[]}function _(e){return x="",e}function $(e){return o(C(b-1,M(91===e?e+2:40===e?e+1:e)))}function R(e){for(;(v=T())&&v<33;)I();return A(e)>2||A(v)>3?"":" "}function D(e,t){for(;--t&&I()&&!(v<48||v>102||v>57&&v<65||v>70&&v<97););return C(e,N()+(t<6&&32==T()&&32==I()))}function M(e){for(;I();)switch(v){case e:return b;case 34:case 39:34!==e&&39!==e&&M(v);break;case 40:41===e&&M(e);break;case 92:I()}return b}function F(e,t){for(;I()&&e+v!==57&&(e+v!==84||47!==T()););return"/*"+C(t,b-1)+"*"+s(47===e?e:I())}function O(e){for(;!A(T());)I();return C(e,b)}var P="-ms-",L="-moz-",z="-webkit-",B="comm",V="rule",W="decl",U="@keyframes";function j(e,t){for(var n="",r=p(e),a=0;a<r;a++)n+=t(e[a],a,e,t)||"";return n}function G(e,t,n,r){switch(e.type){case"@layer":if(e.children.length)break;case"@import":case W:return e.return=e.return||e.value;case B:return"";case U:return e.return=e.value+"{"+j(e.children,r)+"}";case V:e.value=e.props.join(",")}return h(n=j(e.children,r))?e.return=e.value+"{"+n+"}":""}function H(e){return _(q("",null,null,null,[""],e=E(e),0,[0],e))}function q(e,t,n,r,a,i,o,d,p){for(var m=0,g=0,y=o,b=0,v=0,x=0,w=1,k=1,C=1,A=0,E="",_=a,M=i,P=r,L=E;k;)switch(x=A,A=I()){case 40:if(108!=x&&58==c(L,y-1)){-1!=u(L+=l($(A),"&","&\f"),"&\f")&&(C=-1);break}case 34:case 39:case 91:L+=$(A);break;case 9:case 10:case 13:case 32:L+=R(x);break;case 92:L+=D(N()-1,7);continue;case 47:switch(T()){case 42:case 47:f(Y(F(I(),N()),t,n),p);break;default:L+="/"}break;case 123*w:d[m++]=h(L)*C;case 125*w:case 59:case 0:switch(A){case 0:case 125:k=0;case 59+g:-1==C&&(L=l(L,/\f/g,"")),v>0&&h(L)-y&&f(v>32?X(L+";",r,n,y-1):X(l(L," ","")+";",r,n,y-2),p);break;case 59:L+=";";default:if(f(P=K(L,t,n,m,g,a,d,E,_=[],M=[],y),i),123===A)if(0===g)q(L,t,P,P,_,i,y,d,M);else switch(99===b&&110===c(L,3)?100:b){case 100:case 108:case 109:case 115:q(e,P,P,r&&f(K(e,P,P,0,0,a,d,E,a,_=[],y),M),a,M,y,d,r?_:M);break;default:q(L,P,P,P,[""],M,0,d,M)}}m=g=v=0,w=C=1,E=L="",y=o;break;case 58:y=1+h(L),v=x;default:if(w<1)if(123==A)--w;else if(125==A&&0==w++&&125==S())continue;switch(L+=s(A),A*w){case 38:C=g>0?1:(L+="\f",-1);break;case 44:d[m++]=(h(L)-1)*C,C=1;break;case 64:45===T()&&(L+=$(I())),b=T(),g=y=h(E=L+=O(N())),A++;break;case 45:45===x&&2==h(L)&&(w=0)}}return i}function K(e,t,n,r,s,i,u,c,h,f,m){for(var g=s-1,y=0===s?i:[""],b=p(y),v=0,x=0,k=0;v<r;++v)for(var S=0,I=d(e,g+1,g=a(x=u[v])),T=e;S<b;++S)(T=o(x>0?y[S]+" "+I:l(I,/&\f/g,y[S])))&&(h[k++]=T);return w(e,t,n,0===s?V:c,h,f,m)}function Y(e,t,n){return w(e,t,n,B,s(v),d(e,2,-2),0)}function X(e,t,n,r){return w(e,t,n,W,d(e,0,r),d(e,r+1,-1),r)}var Q=function(e,t,n){for(var r=0,a=0;r=a,a=T(),38===r&&12===a&&(t[n]=1),!A(a);)I();return C(e,b)},Z=function(e,t){return _(function(e,t){var n=-1,r=44;do{switch(A(r)){case 0:38===r&&12===T()&&(t[n]=1),e[n]+=Q(b-1,t,n);break;case 2:e[n]+=$(r);break;case 4:if(44===r){e[++n]=58===T()?"&\f":"",t[n]=e[n].length;break}default:e[n]+=s(r)}}while(r=I());return e}(E(e),t))},J=new WeakMap,ee=function(e){if("rule"===e.type&&e.parent&&!(e.length<1)){for(var t=e.value,n=e.parent,r=e.column===n.column&&e.line===n.line;"rule"!==n.type;)if(!(n=n.parent))return;if((1!==e.props.length||58===t.charCodeAt(0)||J.get(n))&&!r){J.set(e,!0);for(var a=[],s=Z(t,a),i=n.props,o=0,l=0;o<s.length;o++)for(var u=0;u<i.length;u++,l++)e.props[l]=a[o]?s[o].replace(/&\f/g,i[u]):i[u]+" "+s[o]}}},te=function(e){if("decl"===e.type){var t=e.value;108===t.charCodeAt(0)&&98===t.charCodeAt(2)&&(e.return="",e.value="")}};function ne(e,t){switch(function(e,t){return 45^c(e,0)?(((t<<2^c(e,0))<<2^c(e,1))<<2^c(e,2))<<2^c(e,3):0}(e,t)){case 5103:return z+"print-"+e+e;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return z+e+e;case 5349:case 4246:case 4810:case 6968:case 2756:return z+e+L+e+P+e+e;case 6828:case 4268:return z+e+P+e+e;case 6165:return z+e+P+"flex-"+e+e;case 5187:return z+e+l(e,/(\w+).+(:[^]+)/,z+"box-$1$2"+P+"flex-$1$2")+e;case 5443:return z+e+P+"flex-item-"+l(e,/flex-|-self/,"")+e;case 4675:return z+e+P+"flex-line-pack"+l(e,/align-content|flex-|-self/,"")+e;case 5548:return z+e+P+l(e,"shrink","negative")+e;case 5292:return z+e+P+l(e,"basis","preferred-size")+e;case 6060:return z+"box-"+l(e,"-grow","")+z+e+P+l(e,"grow","positive")+e;case 4554:return z+l(e,/([^-])(transform)/g,"$1"+z+"$2")+e;case 6187:return l(l(l(e,/(zoom-|grab)/,z+"$1"),/(image-set)/,z+"$1"),e,"")+e;case 5495:case 3959:return l(e,/(image-set\([^]*)/,z+"$1$`$1");case 4968:return l(l(e,/(.+:)(flex-)?(.*)/,z+"box-pack:$3"+P+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+z+e+e;case 4095:case 3583:case 4068:case 2532:return l(e,/(.+)-inline(.+)/,z+"$1$2")+e;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(h(e)-1-t>6)switch(c(e,t+1)){case 109:if(45!==c(e,t+4))break;case 102:return l(e,/(.+:)(.+)-([^]+)/,"$1"+z+"$2-$3$1"+L+(108==c(e,t+3)?"$3":"$2-$3"))+e;case 115:return~u(e,"stretch")?ne(l(e,"stretch","fill-available"),t)+e:e}break;case 4949:if(115!==c(e,t+1))break;case 6444:switch(c(e,h(e)-3-(~u(e,"!important")&&10))){case 107:return l(e,":",":"+z)+e;case 101:return l(e,/(.+:)([^;!]+)(;|!.+)?/,"$1"+z+(45===c(e,14)?"inline-":"")+"box$3$1"+z+"$2$3$1"+P+"$2box$3")+e}break;case 5936:switch(c(e,t+11)){case 114:return z+e+P+l(e,/[svh]\w+-[tblr]{2}/,"tb")+e;case 108:return z+e+P+l(e,/[svh]\w+-[tblr]{2}/,"tb-rl")+e;case 45:return z+e+P+l(e,/[svh]\w+-[tblr]{2}/,"lr")+e}return z+e+P+e+e}return e}var re=[function(e,t,n,r){if(e.length>-1&&!e.return)switch(e.type){case W:e.return=ne(e.value,e.length);break;case U:return j([k(e,{value:l(e.value,"@","@"+z)})],r);case V:if(e.length)return function(e,t){return e.map(t).join("")}(e.props,(function(t){switch(function(e,t){return(e=t.exec(e))?e[0]:e}(t,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return j([k(e,{props:[l(t,/:(read-\w+)/,":-moz-$1")]})],r);case"::placeholder":return j([k(e,{props:[l(t,/:(plac\w+)/,":"+z+"input-$1")]}),k(e,{props:[l(t,/:(plac\w+)/,":-moz-$1")]}),k(e,{props:[l(t,/:(plac\w+)/,P+"input-$1")]})],r)}return""}))}}],ae=function(e){var t=e.key;if("css"===t){var n=document.querySelectorAll("style[data-emotion]:not([data-s])");Array.prototype.forEach.call(n,(function(e){-1!==e.getAttribute("data-emotion").indexOf(" ")&&(document.head.appendChild(e),e.setAttribute("data-s",""))}))}var a,s,i=e.stylisPlugins||re,o={},l=[];a=e.container||document.head,Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="'+t+' "]'),(function(e){for(var t=e.getAttribute("data-emotion").split(" "),n=1;n<t.length;n++)o[t[n]]=!0;l.push(e)}));var u,c,d=[G,(c=function(e){u.insert(e)},function(e){e.root||(e=e.return)&&c(e)})],h=function(e){var t=p(e);return function(n,r,a,s){for(var i="",o=0;o<t;o++)i+=e[o](n,r,a,s)||"";return i}}([ee,te].concat(i,d));s=function(e,t,n,r){u=n,j(H(e?e+"{"+t.styles+"}":t.styles),h),r&&(f.inserted[t.name]=!0)};var f={key:t,sheet:new r({key:t,container:a,nonce:e.nonce,speedy:e.speedy,prepend:e.prepend,insertionPoint:e.insertionPoint}),nonce:e.nonce,inserted:o,registered:{},insert:s};return f.sheet.hydrate(l),f}},918:(e,t,n)=>{"use strict";function r(e){var t=Object.create(null);return function(n){return void 0===t[n]&&(t[n]=e(n)),t[n]}}n.d(t,{A:()=>r})},4575:(e,t,n)=>{"use strict";n.d(t,{T:()=>o,w:()=>i});var r=n(5043),a=n(3803),s=(n(6598),n(9436),r.createContext("undefined"!==typeof HTMLElement?(0,a.A)({key:"css"}):null)),i=(s.Provider,function(e){return(0,r.forwardRef)((function(t,n){var a=(0,r.useContext)(s);return e(t,a,n)}))}),o=r.createContext({})},6598:(e,t,n)=>{"use strict";n.d(t,{J:()=>g});var r={animationIterationCount:1,aspectRatio:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,scale:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},a=n(918),s=!1,i=/[A-Z]|^ms/g,o=/_EMO_([^_]+?)_([^]*?)_EMO_/g,l=function(e){return 45===e.charCodeAt(1)},u=function(e){return null!=e&&"boolean"!==typeof e},c=(0,a.A)((function(e){return l(e)?e:e.replace(i,"-$&").toLowerCase()})),d=function(e,t){switch(e){case"animation":case"animationName":if("string"===typeof t)return t.replace(o,(function(e,t,n){return f={name:t,styles:n,next:f},t}))}return 1===r[e]||l(e)||"number"!==typeof t||0===t?t:t+"px"},h="Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";function p(e,t,n){if(null==n)return"";var r=n;if(void 0!==r.__emotion_styles)return r;switch(typeof n){case"boolean":return"";case"object":var a=n;if(1===a.anim)return f={name:a.name,styles:a.styles,next:f},a.name;var i=n;if(void 0!==i.styles){var o=i.next;if(void 0!==o)for(;void 0!==o;)f={name:o.name,styles:o.styles,next:f},o=o.next;return i.styles+";"}return function(e,t,n){var r="";if(Array.isArray(n))for(var a=0;a<n.length;a++)r+=p(e,t,n[a])+";";else for(var i in n){var o=n[i];if("object"!==typeof o){var l=o;null!=t&&void 0!==t[l]?r+=i+"{"+t[l]+"}":u(l)&&(r+=c(i)+":"+d(i,l)+";")}else{if("NO_COMPONENT_SELECTOR"===i&&s)throw new Error(h);if(!Array.isArray(o)||"string"!==typeof o[0]||null!=t&&void 0!==t[o[0]]){var f=p(e,t,o);switch(i){case"animation":case"animationName":r+=c(i)+":"+f+";";break;default:r+=i+"{"+f+"}"}}else for(var m=0;m<o.length;m++)u(o[m])&&(r+=c(i)+":"+d(i,o[m])+";")}}return r}(e,t,n);case"function":if(void 0!==e){var l=f,m=n(e);return f=l,p(e,t,m)}}var g=n;if(null==t)return g;var y=t[g];return void 0!==y?y:g}var f,m=/label:\s*([^\s;\n{]+)\s*(;|$)/g;function g(e,t,n){if(1===e.length&&"object"===typeof e[0]&&null!==e[0]&&void 0!==e[0].styles)return e[0];var r=!0,a="";f=void 0;var s=e[0];null==s||void 0===s.raw?(r=!1,a+=p(n,t,s)):a+=s[0];for(var i=1;i<e.length;i++){if(a+=p(n,t,e[i]),r)a+=s[i]}m.lastIndex=0;for(var o,l="";null!==(o=m.exec(a));)l+="-"+o[1];var u=function(e){for(var t,n=0,r=0,a=e.length;a>=4;++r,a-=4)t=1540483477*(65535&(t=255&e.charCodeAt(r)|(255&e.charCodeAt(++r))<<8|(255&e.charCodeAt(++r))<<16|(255&e.charCodeAt(++r))<<24))+(59797*(t>>>16)<<16),n=1540483477*(65535&(t^=t>>>24))+(59797*(t>>>16)<<16)^1540483477*(65535&n)+(59797*(n>>>16)<<16);switch(a){case 3:n^=(255&e.charCodeAt(r+2))<<16;case 2:n^=(255&e.charCodeAt(r+1))<<8;case 1:n=1540483477*(65535&(n^=255&e.charCodeAt(r)))+(59797*(n>>>16)<<16)}return(((n=1540483477*(65535&(n^=n>>>13))+(59797*(n>>>16)<<16))^n>>>15)>>>0).toString(36)}(a)+l;return{name:u,styles:a,next:f}}},9436:(e,t,n)=>{"use strict";var r;n.d(t,{i:()=>o,s:()=>i});var a=n(5043),s=!!(r||(r=n.t(a,2))).useInsertionEffect&&(r||(r=n.t(a,2))).useInsertionEffect,i=s||function(e){return e()},o=s||a.useLayoutEffect},1722:(e,t,n)=>{"use strict";n.d(t,{Rk:()=>r,SF:()=>a,sk:()=>s});function r(e,t,n){var r="";return n.split(" ").forEach((function(n){void 0!==e[n]?t.push(e[n]+";"):r+=n+" "})),r}var a=function(e,t,n){var r=e.key+"-"+t.name;!1===n&&void 0===e.registered[r]&&(e.registered[r]=t.styles)},s=function(e,t,n){a(e,t,n);var r=e.key+"-"+t.name;if(void 0===e.inserted[t.name]){var s=t;do{e.insert(t===s?"."+r:"",s,e.sheet,!0),s=s.next}while(void 0!==s)}}},4914:(e,t,n)=>{"use strict";var r=n(4994);t.A=void 0;var a=r(n(39)),s=n(579);t.A=(0,a.default)((0,s.jsx)("path",{d:"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"}),"ContentCopy")},7948:(e,t,n)=>{"use strict";var r=n(4994);t.A=void 0;var a=r(n(39)),s=n(579);t.A=(0,a.default)((0,s.jsx)("path",{d:"M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2M12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"}),"ErrorOutline")},3531:(e,t,n)=>{"use strict";var r=n(4994);t.A=void 0;var a=r(n(39)),s=n(579);t.A=(0,a.default)((0,s.jsx)("path",{d:"M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2m0 12H6V10h12z"}),"LockOpen")},39:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return r.createSvgIcon}});var r=n(4421)},8249:(e,t,n)=>{"use strict";n.d(t,{b:()=>o});var r=n(5043),a=n(3030);n(579);const s=r.createContext(void 0);function i(e){let{props:t,name:n}=e;return function(e){const{theme:t,name:n,props:r}=e;if(!t||!t.components||!t.components[n])return r;const s=t.components[n];return s.defaultProps?(0,a.A)(s.defaultProps,r):s.styleOverrides||s.variants?r:(0,a.A)(s,r)}({props:t,name:n,theme:{components:r.useContext(s)}})}function o(e){return i(e)}},5913:(e,t,n)=>{"use strict";n.d(t,{A:()=>ae});var r=n(7868),a=n(9172),s=n(6596);const i={black:"#000",white:"#fff"},o={50:"#fafafa",100:"#f5f5f5",200:"#eeeeee",300:"#e0e0e0",400:"#bdbdbd",500:"#9e9e9e",600:"#757575",700:"#616161",800:"#424242",900:"#212121",A100:"#f5f5f5",A200:"#eeeeee",A400:"#bdbdbd",A700:"#616161"},l={50:"#f3e5f5",100:"#e1bee7",200:"#ce93d8",300:"#ba68c8",400:"#ab47bc",500:"#9c27b0",600:"#8e24aa",700:"#7b1fa2",800:"#6a1b9a",900:"#4a148c",A100:"#ea80fc",A200:"#e040fb",A400:"#d500f9",A700:"#aa00ff"},u={50:"#ffebee",100:"#ffcdd2",200:"#ef9a9a",300:"#e57373",400:"#ef5350",500:"#f44336",600:"#e53935",700:"#d32f2f",800:"#c62828",900:"#b71c1c",A100:"#ff8a80",A200:"#ff5252",A400:"#ff1744",A700:"#d50000"},c={50:"#fff3e0",100:"#ffe0b2",200:"#ffcc80",300:"#ffb74d",400:"#ffa726",500:"#ff9800",600:"#fb8c00",700:"#f57c00",800:"#ef6c00",900:"#e65100",A100:"#ffd180",A200:"#ffab40",A400:"#ff9100",A700:"#ff6d00"},d={50:"#e3f2fd",100:"#bbdefb",200:"#90caf9",300:"#64b5f6",400:"#42a5f5",500:"#2196f3",600:"#1e88e5",700:"#1976d2",800:"#1565c0",900:"#0d47a1",A100:"#82b1ff",A200:"#448aff",A400:"#2979ff",A700:"#2962ff"},h={50:"#e1f5fe",100:"#b3e5fc",200:"#81d4fa",300:"#4fc3f7",400:"#29b6f6",500:"#03a9f4",600:"#039be5",700:"#0288d1",800:"#0277bd",900:"#01579b",A100:"#80d8ff",A200:"#40c4ff",A400:"#00b0ff",A700:"#0091ea"},p={50:"#e8f5e9",100:"#c8e6c9",200:"#a5d6a7",300:"#81c784",400:"#66bb6a",500:"#4caf50",600:"#43a047",700:"#388e3c",800:"#2e7d32",900:"#1b5e20",A100:"#b9f6ca",A200:"#69f0ae",A400:"#00e676",A700:"#00c853"},f={text:{primary:"rgba(0, 0, 0, 0.87)",secondary:"rgba(0, 0, 0, 0.6)",disabled:"rgba(0, 0, 0, 0.38)"},divider:"rgba(0, 0, 0, 0.12)",background:{paper:i.white,default:i.white},action:{active:"rgba(0, 0, 0, 0.54)",hover:"rgba(0, 0, 0, 0.04)",hoverOpacity:.04,selected:"rgba(0, 0, 0, 0.08)",selectedOpacity:.08,disabled:"rgba(0, 0, 0, 0.26)",disabledBackground:"rgba(0, 0, 0, 0.12)",disabledOpacity:.38,focus:"rgba(0, 0, 0, 0.12)",focusOpacity:.12,activatedOpacity:.12}},m={text:{primary:i.white,secondary:"rgba(255, 255, 255, 0.7)",disabled:"rgba(255, 255, 255, 0.5)",icon:"rgba(255, 255, 255, 0.5)"},divider:"rgba(255, 255, 255, 0.12)",background:{paper:"#121212",default:"#121212"},action:{active:i.white,hover:"rgba(255, 255, 255, 0.08)",hoverOpacity:.08,selected:"rgba(255, 255, 255, 0.16)",selectedOpacity:.16,disabled:"rgba(255, 255, 255, 0.3)",disabledBackground:"rgba(255, 255, 255, 0.12)",disabledOpacity:.38,focus:"rgba(255, 255, 255, 0.12)",focusOpacity:.12,activatedOpacity:.24}};function g(e,t,n,r){const a=r.light||r,i=r.dark||1.5*r;e[t]||(e.hasOwnProperty(n)?e[t]=e[n]:"light"===t?e.light=(0,s.a)(e.main,a):"dark"===t&&(e.dark=(0,s.e$)(e.main,i)))}function y(e){const{mode:t="light",contrastThreshold:n=3,tonalOffset:y=.2,...b}=e,v=e.primary||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:d[200],light:d[50],dark:d[400]}:{main:d[700],light:d[400],dark:d[800]}}(t),x=e.secondary||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:l[200],light:l[50],dark:l[400]}:{main:l[500],light:l[300],dark:l[700]}}(t),w=e.error||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:u[500],light:u[300],dark:u[700]}:{main:u[700],light:u[400],dark:u[800]}}(t),k=e.info||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:h[400],light:h[300],dark:h[700]}:{main:h[700],light:h[500],dark:h[900]}}(t),S=e.success||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:p[400],light:p[300],dark:p[700]}:{main:p[800],light:p[500],dark:p[900]}}(t),I=e.warning||function(){return"dark"===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"light")?{main:c[400],light:c[300],dark:c[700]}:{main:"#ed6c02",light:c[500],dark:c[900]}}(t);function T(e){return(0,s.eM)(e,m.text.primary)>=n?m.text.primary:f.text.primary}const N=e=>{let{color:t,name:n,mainShade:a=500,lightShade:s=300,darkShade:i=700}=e;if(t={...t},!t.main&&t[a]&&(t.main=t[a]),!t.hasOwnProperty("main"))throw new Error((0,r.A)(11,n?` (${n})`:"",a));if("string"!==typeof t.main)throw new Error((0,r.A)(12,n?` (${n})`:"",JSON.stringify(t.main)));return g(t,"light",s,y),g(t,"dark",i,y),t.contrastText||(t.contrastText=T(t.main)),t},C={dark:m,light:f};return(0,a.A)({common:{...i},mode:t,primary:N({color:v,name:"primary"}),secondary:N({color:x,name:"secondary",mainShade:"A400",lightShade:"A200",darkShade:"A700"}),error:N({color:w,name:"error"}),warning:N({color:I,name:"warning"}),info:N({color:k,name:"info"}),success:N({color:S,name:"success"}),grey:o,contrastThreshold:n,getContrastText:T,augmentColor:N,tonalOffset:y,...C[t]},b)}function b(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";function t(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];if(!r.length)return"";const s=r[0];return"string"!==typeof s||s.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)?`, ${s}`:`, var(--${e?`${e}-`:""}${s}${t(...r.slice(1))})`}return function(n){for(var r=arguments.length,a=new Array(r>1?r-1:0),s=1;s<r;s++)a[s-1]=arguments[s];return`var(--${e?`${e}-`:""}${n}${t(...a)})`}}var v=n(6160),x=n(883);function w(e){const t={};return Object.entries(e).forEach((e=>{const[n,r]=e;"object"===typeof r&&(t[n]=`${r.fontStyle?`${r.fontStyle} `:""}${r.fontVariant?`${r.fontVariant} `:""}${r.fontWeight?`${r.fontWeight} `:""}${r.fontStretch?`${r.fontStretch} `:""}${r.fontSize||""}${r.lineHeight?`/${r.lineHeight} `:""}${r.fontFamily||""}`)})),t}const k=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=e;t.forEach(((e,s)=>{s===t.length-1?Array.isArray(a)?a[Number(e)]=n:a&&"object"===typeof a&&(a[e]=n):a&&"object"===typeof a&&(a[e]||(a[e]=r.includes(e)?[]:{}),a=a[e])}))},S=(e,t,n)=>{!function e(r){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];Object.entries(r).forEach((r=>{let[i,o]=r;(!n||n&&!n([...a,i]))&&void 0!==o&&null!==o&&("object"===typeof o&&Object.keys(o).length>0?e(o,[...a,i],Array.isArray(o)?[...s,i]:s):t([...a,i],o,s))}))}(e)},I=(e,t)=>{if("number"===typeof t){if(["lineHeight","fontWeight","opacity","zIndex"].some((t=>e.includes(t))))return t;return e[e.length-1].toLowerCase().indexOf("opacity")>=0?t:`${t}px`}return t};function T(e,t){const{prefix:n,shouldSkipGeneratingVar:r}=t||{},a={},s={},i={};return S(e,((e,t,o)=>{if(("string"===typeof t||"number"===typeof t)&&(!r||!r(e,t))){const r=`--${n?`${n}-`:""}${e.join("-")}`,l=I(e,t);Object.assign(a,{[r]:l}),k(s,e,`var(${r})`,o),k(i,e,`var(${r}, ${l})`,o)}}),(e=>"vars"===e[0])),{css:a,vars:s,varsWithDefaults:i}}const N=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{getSelector:n=y,disableCssColorScheme:r,colorSchemeSelector:s}=t,{colorSchemes:i={},components:o,defaultColorScheme:l="light",...u}=e,{vars:c,css:d,varsWithDefaults:h}=T(u,t);let p=h;const f={},{[l]:m,...g}=i;if(Object.entries(g||{}).forEach((e=>{let[n,r]=e;const{vars:s,css:i,varsWithDefaults:o}=T(r,t);p=(0,a.A)(p,o),f[n]={css:i,vars:s}})),m){const{css:e,vars:n,varsWithDefaults:r}=T(m,t);p=(0,a.A)(p,r),f[l]={css:e,vars:n}}function y(t,n){let r=s;if("class"===s&&(r=".%s"),"data"===s&&(r="[data-%s]"),s?.startsWith("data-")&&!s.includes("%s")&&(r=`[${s}="%s"]`),t){if("media"===r){if(e.defaultColorScheme===t)return":root";const r=i[t]?.palette?.mode||t;return{[`@media (prefers-color-scheme: ${r})`]:{":root":n}}}if(r)return e.defaultColorScheme===t?`:root, ${r.replace("%s",String(t))}`:r.replace("%s",String(t))}return":root"}return{vars:p,generateThemeVars:()=>{let e={...c};return Object.entries(f).forEach((t=>{let[,{vars:n}]=t;e=(0,a.A)(e,n)})),e},generateStyleSheets:()=>{const t=[],a=e.defaultColorScheme||"light";function s(e,n){Object.keys(n).length&&t.push("string"===typeof e?{[e]:{...n}}:e)}s(n(void 0,{...d}),d);const{[a]:o,...l}=f;if(o){const{css:e}=o,t=i[a]?.palette?.mode,l=!r&&t?{colorScheme:t,...e}:{...e};s(n(a,{...l}),l)}return Object.entries(l).forEach((e=>{let[t,{css:a}]=e;const o=i[t]?.palette?.mode,l=!r&&o?{colorScheme:o,...a}:{...a};s(n(t,{...l}),l)})),t}}};var C=n(138),A=n(2768),E=n(2390);const _={textTransform:"uppercase"},$='"Roboto", "Helvetica", "Arial", sans-serif';function R(e,t){const{fontFamily:n=$,fontSize:r=14,fontWeightLight:s=300,fontWeightRegular:i=400,fontWeightMedium:o=500,fontWeightBold:l=700,htmlFontSize:u=16,allVariants:c,pxToRem:d,...h}="function"===typeof t?t(e):t;const p=r/14,f=d||(e=>e/u*p+"rem"),m=(e,t,r,a,s)=>{return{fontFamily:n,fontWeight:e,fontSize:f(t),lineHeight:r,...n===$?{letterSpacing:(i=a/t,Math.round(1e5*i)/1e5)+"em"}:{},...s,...c};var i},g={h1:m(s,96,1.167,-1.5),h2:m(s,60,1.2,-.5),h3:m(i,48,1.167,0),h4:m(i,34,1.235,.25),h5:m(i,24,1.334,0),h6:m(o,20,1.6,.15),subtitle1:m(i,16,1.75,.15),subtitle2:m(o,14,1.57,.1),body1:m(i,16,1.5,.15),body2:m(i,14,1.43,.15),button:m(o,14,1.75,.4,_),caption:m(i,12,1.66,.4),overline:m(i,12,2.66,1,_),inherit:{fontFamily:"inherit",fontWeight:"inherit",fontSize:"inherit",lineHeight:"inherit",letterSpacing:"inherit"}};return(0,a.A)({htmlFontSize:u,pxToRem:f,fontFamily:n,fontSize:r,fontWeightLight:s,fontWeightRegular:i,fontWeightMedium:o,fontWeightBold:l,...g},h,{clone:!1})}function D(){return[`${arguments.length<=0?void 0:arguments[0]}px ${arguments.length<=1?void 0:arguments[1]}px ${arguments.length<=2?void 0:arguments[2]}px ${arguments.length<=3?void 0:arguments[3]}px rgba(0,0,0,0.2)`,`${arguments.length<=4?void 0:arguments[4]}px ${arguments.length<=5?void 0:arguments[5]}px ${arguments.length<=6?void 0:arguments[6]}px ${arguments.length<=7?void 0:arguments[7]}px rgba(0,0,0,0.14)`,`${arguments.length<=8?void 0:arguments[8]}px ${arguments.length<=9?void 0:arguments[9]}px ${arguments.length<=10?void 0:arguments[10]}px ${arguments.length<=11?void 0:arguments[11]}px rgba(0,0,0,0.12)`].join(",")}const M=["none",D(0,2,1,-1,0,1,1,0,0,1,3,0),D(0,3,1,-2,0,2,2,0,0,1,5,0),D(0,3,3,-2,0,3,4,0,0,1,8,0),D(0,2,4,-1,0,4,5,0,0,1,10,0),D(0,3,5,-1,0,5,8,0,0,1,14,0),D(0,3,5,-1,0,6,10,0,0,1,18,0),D(0,4,5,-2,0,7,10,1,0,2,16,1),D(0,5,5,-3,0,8,10,1,0,3,14,2),D(0,5,6,-3,0,9,12,1,0,3,16,2),D(0,6,6,-3,0,10,14,1,0,4,18,3),D(0,6,7,-4,0,11,15,1,0,4,20,3),D(0,7,8,-4,0,12,17,2,0,5,22,4),D(0,7,8,-4,0,13,19,2,0,5,24,4),D(0,7,9,-4,0,14,21,2,0,5,26,4),D(0,8,9,-5,0,15,22,2,0,6,28,5),D(0,8,10,-5,0,16,24,2,0,6,30,5),D(0,8,11,-5,0,17,26,2,0,6,32,5),D(0,9,11,-5,0,18,28,2,0,7,34,6),D(0,9,12,-6,0,19,29,2,0,7,36,6),D(0,10,13,-6,0,20,31,3,0,8,38,7),D(0,10,13,-6,0,21,33,3,0,8,40,7),D(0,10,14,-6,0,22,35,3,0,8,42,7),D(0,11,14,-7,0,23,36,3,0,9,44,8),D(0,11,15,-7,0,24,38,3,0,9,46,8)],F={easeInOut:"cubic-bezier(0.4, 0, 0.2, 1)",easeOut:"cubic-bezier(0.0, 0, 0.2, 1)",easeIn:"cubic-bezier(0.4, 0, 1, 1)",sharp:"cubic-bezier(0.4, 0, 0.6, 1)"},O={shortest:150,shorter:200,short:250,standard:300,complex:375,enteringScreen:225,leavingScreen:195};function P(e){return`${Math.round(e)}ms`}function L(e){if(!e)return 0;const t=e/36;return Math.min(Math.round(10*(4+15*t**.25+t/5)),3e3)}function z(e){const t={...F,...e.easing},n={...O,...e.duration};return{getAutoHeightDuration:L,create:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:["all"],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{duration:a=n.standard,easing:s=t.easeInOut,delay:i=0,...o}=r;return(Array.isArray(e)?e:[e]).map((e=>`${e} ${"string"===typeof a?a:P(a)} ${s} ${"string"===typeof i?i:P(i)}`)).join(",")},...e,easing:t,duration:n}}const B={mobileStepper:1e3,fab:1050,speedDial:1050,appBar:1100,drawer:1200,modal:1300,snackbar:1400,tooltip:1500};function V(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{breakpoints:t,mixins:n={},spacing:s,palette:i={},transitions:o={},typography:l={},shape:u,...c}=e;if(e.vars)throw new Error((0,r.A)(20));const d=y(i),h=(0,E.A)(e);let p=(0,a.A)(h,{mixins:(f=h.breakpoints,m=n,{toolbar:{minHeight:56,[f.up("xs")]:{"@media (orientation: landscape)":{minHeight:48}},[f.up("sm")]:{minHeight:64}},...m}),palette:d,shadows:M.slice(),typography:R(d,l),transitions:z(o),zIndex:{...B}});var f,m;p=(0,a.A)(p,c);for(var g=arguments.length,b=new Array(g>1?g-1:0),v=1;v<g;v++)b[v-1]=arguments[v];return p=b.reduce(((e,t)=>(0,a.A)(e,t)),p),p.unstable_sxConfig={...C.A,...c?.unstable_sxConfig},p.unstable_sx=function(e){return(0,A.A)({sx:e,theme:this})},p}const W=V;var U=n(3582);const j=[...Array(25)].map(((e,t)=>{if(0===t)return;const n=(0,U.A)(t);return`linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`}));function G(e){return{inputPlaceholder:"dark"===e?.5:.42,inputUnderline:"dark"===e?.7:.42,switchTrackDisabled:"dark"===e?.2:.12,switchTrack:"dark"===e?.3:.38}}function H(e){return"dark"===e?j:[]}function q(e){return!!e[0].match(/(cssVarPrefix|colorSchemeSelector|typography|mixins|breakpoints|direction|transitions)/)||!!e[0].match(/sxConfig$/)||"palette"===e[0]&&!!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/)}const K=e=>[...[...Array(24)].map(((t,n)=>`--${e?`${e}-`:""}overlays-${n+1}`)),`--${e?`${e}-`:""}palette-AppBar-darkBg`,`--${e?`${e}-`:""}palette-AppBar-darkColor`],Y=e=>(t,n)=>{const r=e.colorSchemeSelector;let a=r;if("class"===r&&(a=".%s"),"data"===r&&(a="[data-%s]"),r?.startsWith("data-")&&!r.includes("%s")&&(a=`[${r}="%s"]`),e.defaultColorScheme===t){if("dark"===t){const r={};return K(e.cssVarPrefix).forEach((e=>{r[e]=n[e],delete n[e]})),"media"===a?{":root":n,"@media (prefers-color-scheme: dark)":{":root":r}}:a?{[a.replace("%s",t)]:r,[`:root, ${a.replace("%s",t)}`]:n}:{":root":{...n,...r}}}if(a&&"media"!==a)return`:root, ${a.replace("%s",String(t))}`}else if(t){if("media"===a)return{[`@media (prefers-color-scheme: ${String(t)})`]:{":root":n}};if(a)return a.replace("%s",String(t))}return":root"};function X(){const e={...arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}};return function e(t){const n=Object.entries(t);for(let s=0;s<n.length;s++){const[i,o]=n[s];r=o,!(0,a.Q)(r)&&"undefined"!==typeof r&&"string"!==typeof r&&"boolean"!==typeof r&&"number"!==typeof r&&!Array.isArray(r)||i.startsWith("unstable_")?delete t[i]:(0,a.Q)(o)&&(t[i]={...o},e(t[i]))}var r}(e),`import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';\n\nconst theme = ${JSON.stringify(e,null,2)};\n\ntheme.breakpoints = createBreakpoints(theme.breakpoints || {});\ntheme.transitions = createTransitions(theme.transitions || {});\n\nexport default theme;`}function Q(e,t,n){!e[t]&&n&&(e[t]=n)}function Z(e){return e&&e.startsWith("hsl")?(0,s.YL)(e):e}function J(e,t){`${t}Channel`in e||(e[`${t}Channel`]=(0,s.Me)(Z(e[t]),`MUI: Can't create \`palette.${t}Channel\` because \`palette.${t}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().\nTo suppress this warning, you need to explicitly provide the \`palette.${t}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`))}const ee=e=>{try{return e()}catch(t){}},te=function(){return b(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"mui")};function ne(e,t,n,r){if(!t)return;t=!0===t?{}:t;const a="dark"===r?"dark":"light";if(!n)return void(e[r]=function(e){const{palette:t={mode:"light"},opacity:n,overlays:r,...a}=e,s=y(t);return{palette:s,opacity:{...G(s.mode),...n},overlays:r||H(s.mode),...a}}({...t,palette:{mode:a,...t?.palette}}));const{palette:s,...i}=W({...n,palette:{mode:a,...t?.palette}});return e[r]={...t,palette:s,opacity:{...G(a),...t?.opacity},overlays:t?.overlays||H(a)},i}function re(e,t,n){e.colorSchemes&&n&&(e.colorSchemes[t]={...!0!==n&&n,palette:y({...!0===n?{}:n.palette,mode:t})})}function ae(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{palette:t,cssVariables:n=!1,colorSchemes:i=(t?void 0:{light:!0}),defaultColorScheme:o=t?.mode,...l}=e,u=o||"light",c=i?.[u],d={...i,...t?{[u]:{..."boolean"!==typeof c&&c,palette:t}}:void 0};for(var h=arguments.length,p=new Array(h>1?h-1:0),f=1;f<h;f++)p[f-1]=arguments[f];if(!1===n){if(!("colorSchemes"in e))return W(e,...p);let n=t;"palette"in e||d[u]&&(!0!==d[u]?n=d[u].palette:"dark"===u&&(n={mode:"dark"}));const r=W({...e,palette:n},...p);return r.defaultColorScheme=u,r.colorSchemes=d,"light"===r.palette.mode&&(r.colorSchemes.light={...!0!==d.light&&d.light,palette:r.palette},re(r,"dark",d.dark)),"dark"===r.palette.mode&&(r.colorSchemes.dark={...!0!==d.dark&&d.dark,palette:r.palette},re(r,"light",d.light)),r}return t||"light"in d||"light"!==u||(d.light=!0),function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{colorSchemes:t={light:!0},defaultColorScheme:n,disableCssColorScheme:i=!1,cssVarPrefix:o="mui",shouldSkipGeneratingVar:l=q,colorSchemeSelector:u=(t.light&&t.dark?"media":void 0),...c}=e,d=Object.keys(t)[0],h=n||(t.light&&"light"!==d?"light":d),p=te(o),{[h]:f,light:m,dark:g,...y}=t,b={...y};let k=f;if(("dark"===h&&!("dark"in t)||"light"===h&&!("light"in t))&&(k=!0),!k)throw new Error((0,r.A)(21,h));const S=ne(b,k,c,h);m&&!b.light&&ne(b,m,void 0,"light"),g&&!b.dark&&ne(b,g,void 0,"dark");let I={defaultColorScheme:h,...S,cssVarPrefix:o,colorSchemeSelector:u,getCssVar:p,colorSchemes:b,font:{...w(S.typography),...S.font},spacing:(T=c.spacing,"number"===typeof T?`${T}px`:"string"===typeof T||"function"===typeof T||Array.isArray(T)?T:"8px")};var T;Object.keys(I.colorSchemes).forEach((e=>{const t=I.colorSchemes[e].palette,n=e=>{const n=e.split("-"),r=n[1],a=n[2];return p(e,t[r][a])};var r;if("light"===t.mode&&(Q(t.common,"background","#fff"),Q(t.common,"onBackground","#000")),"dark"===t.mode&&(Q(t.common,"background","#000"),Q(t.common,"onBackground","#fff")),r=t,["Alert","AppBar","Avatar","Button","Chip","FilledInput","LinearProgress","Skeleton","Slider","SnackbarContent","SpeedDialAction","StepConnector","StepContent","Switch","TableCell","Tooltip"].forEach((e=>{r[e]||(r[e]={})})),"light"===t.mode){Q(t.Alert,"errorColor",(0,s.Nd)(t.error.light,.6)),Q(t.Alert,"infoColor",(0,s.Nd)(t.info.light,.6)),Q(t.Alert,"successColor",(0,s.Nd)(t.success.light,.6)),Q(t.Alert,"warningColor",(0,s.Nd)(t.warning.light,.6)),Q(t.Alert,"errorFilledBg",n("palette-error-main")),Q(t.Alert,"infoFilledBg",n("palette-info-main")),Q(t.Alert,"successFilledBg",n("palette-success-main")),Q(t.Alert,"warningFilledBg",n("palette-warning-main")),Q(t.Alert,"errorFilledColor",ee((()=>t.getContrastText(t.error.main)))),Q(t.Alert,"infoFilledColor",ee((()=>t.getContrastText(t.info.main)))),Q(t.Alert,"successFilledColor",ee((()=>t.getContrastText(t.success.main)))),Q(t.Alert,"warningFilledColor",ee((()=>t.getContrastText(t.warning.main)))),Q(t.Alert,"errorStandardBg",(0,s.j4)(t.error.light,.9)),Q(t.Alert,"infoStandardBg",(0,s.j4)(t.info.light,.9)),Q(t.Alert,"successStandardBg",(0,s.j4)(t.success.light,.9)),Q(t.Alert,"warningStandardBg",(0,s.j4)(t.warning.light,.9)),Q(t.Alert,"errorIconColor",n("palette-error-main")),Q(t.Alert,"infoIconColor",n("palette-info-main")),Q(t.Alert,"successIconColor",n("palette-success-main")),Q(t.Alert,"warningIconColor",n("palette-warning-main")),Q(t.AppBar,"defaultBg",n("palette-grey-100")),Q(t.Avatar,"defaultBg",n("palette-grey-400")),Q(t.Button,"inheritContainedBg",n("palette-grey-300")),Q(t.Button,"inheritContainedHoverBg",n("palette-grey-A100")),Q(t.Chip,"defaultBorder",n("palette-grey-400")),Q(t.Chip,"defaultAvatarColor",n("palette-grey-700")),Q(t.Chip,"defaultIconColor",n("palette-grey-700")),Q(t.FilledInput,"bg","rgba(0, 0, 0, 0.06)"),Q(t.FilledInput,"hoverBg","rgba(0, 0, 0, 0.09)"),Q(t.FilledInput,"disabledBg","rgba(0, 0, 0, 0.12)"),Q(t.LinearProgress,"primaryBg",(0,s.j4)(t.primary.main,.62)),Q(t.LinearProgress,"secondaryBg",(0,s.j4)(t.secondary.main,.62)),Q(t.LinearProgress,"errorBg",(0,s.j4)(t.error.main,.62)),Q(t.LinearProgress,"infoBg",(0,s.j4)(t.info.main,.62)),Q(t.LinearProgress,"successBg",(0,s.j4)(t.success.main,.62)),Q(t.LinearProgress,"warningBg",(0,s.j4)(t.warning.main,.62)),Q(t.Skeleton,"bg",`rgba(${n("palette-text-primaryChannel")} / 0.11)`),Q(t.Slider,"primaryTrack",(0,s.j4)(t.primary.main,.62)),Q(t.Slider,"secondaryTrack",(0,s.j4)(t.secondary.main,.62)),Q(t.Slider,"errorTrack",(0,s.j4)(t.error.main,.62)),Q(t.Slider,"infoTrack",(0,s.j4)(t.info.main,.62)),Q(t.Slider,"successTrack",(0,s.j4)(t.success.main,.62)),Q(t.Slider,"warningTrack",(0,s.j4)(t.warning.main,.62));const e=(0,s.Y9)(t.background.default,.8);Q(t.SnackbarContent,"bg",e),Q(t.SnackbarContent,"color",ee((()=>t.getContrastText(e)))),Q(t.SpeedDialAction,"fabHoverBg",(0,s.Y9)(t.background.paper,.15)),Q(t.StepConnector,"border",n("palette-grey-400")),Q(t.StepContent,"border",n("palette-grey-400")),Q(t.Switch,"defaultColor",n("palette-common-white")),Q(t.Switch,"defaultDisabledColor",n("palette-grey-100")),Q(t.Switch,"primaryDisabledColor",(0,s.j4)(t.primary.main,.62)),Q(t.Switch,"secondaryDisabledColor",(0,s.j4)(t.secondary.main,.62)),Q(t.Switch,"errorDisabledColor",(0,s.j4)(t.error.main,.62)),Q(t.Switch,"infoDisabledColor",(0,s.j4)(t.info.main,.62)),Q(t.Switch,"successDisabledColor",(0,s.j4)(t.success.main,.62)),Q(t.Switch,"warningDisabledColor",(0,s.j4)(t.warning.main,.62)),Q(t.TableCell,"border",(0,s.j4)((0,s.Cg)(t.divider,1),.88)),Q(t.Tooltip,"bg",(0,s.Cg)(t.grey[700],.92))}if("dark"===t.mode){Q(t.Alert,"errorColor",(0,s.j4)(t.error.light,.6)),Q(t.Alert,"infoColor",(0,s.j4)(t.info.light,.6)),Q(t.Alert,"successColor",(0,s.j4)(t.success.light,.6)),Q(t.Alert,"warningColor",(0,s.j4)(t.warning.light,.6)),Q(t.Alert,"errorFilledBg",n("palette-error-dark")),Q(t.Alert,"infoFilledBg",n("palette-info-dark")),Q(t.Alert,"successFilledBg",n("palette-success-dark")),Q(t.Alert,"warningFilledBg",n("palette-warning-dark")),Q(t.Alert,"errorFilledColor",ee((()=>t.getContrastText(t.error.dark)))),Q(t.Alert,"infoFilledColor",ee((()=>t.getContrastText(t.info.dark)))),Q(t.Alert,"successFilledColor",ee((()=>t.getContrastText(t.success.dark)))),Q(t.Alert,"warningFilledColor",ee((()=>t.getContrastText(t.warning.dark)))),Q(t.Alert,"errorStandardBg",(0,s.Nd)(t.error.light,.9)),Q(t.Alert,"infoStandardBg",(0,s.Nd)(t.info.light,.9)),Q(t.Alert,"successStandardBg",(0,s.Nd)(t.success.light,.9)),Q(t.Alert,"warningStandardBg",(0,s.Nd)(t.warning.light,.9)),Q(t.Alert,"errorIconColor",n("palette-error-main")),Q(t.Alert,"infoIconColor",n("palette-info-main")),Q(t.Alert,"successIconColor",n("palette-success-main")),Q(t.Alert,"warningIconColor",n("palette-warning-main")),Q(t.AppBar,"defaultBg",n("palette-grey-900")),Q(t.AppBar,"darkBg",n("palette-background-paper")),Q(t.AppBar,"darkColor",n("palette-text-primary")),Q(t.Avatar,"defaultBg",n("palette-grey-600")),Q(t.Button,"inheritContainedBg",n("palette-grey-800")),Q(t.Button,"inheritContainedHoverBg",n("palette-grey-700")),Q(t.Chip,"defaultBorder",n("palette-grey-700")),Q(t.Chip,"defaultAvatarColor",n("palette-grey-300")),Q(t.Chip,"defaultIconColor",n("palette-grey-300")),Q(t.FilledInput,"bg","rgba(255, 255, 255, 0.09)"),Q(t.FilledInput,"hoverBg","rgba(255, 255, 255, 0.13)"),Q(t.FilledInput,"disabledBg","rgba(255, 255, 255, 0.12)"),Q(t.LinearProgress,"primaryBg",(0,s.Nd)(t.primary.main,.5)),Q(t.LinearProgress,"secondaryBg",(0,s.Nd)(t.secondary.main,.5)),Q(t.LinearProgress,"errorBg",(0,s.Nd)(t.error.main,.5)),Q(t.LinearProgress,"infoBg",(0,s.Nd)(t.info.main,.5)),Q(t.LinearProgress,"successBg",(0,s.Nd)(t.success.main,.5)),Q(t.LinearProgress,"warningBg",(0,s.Nd)(t.warning.main,.5)),Q(t.Skeleton,"bg",`rgba(${n("palette-text-primaryChannel")} / 0.13)`),Q(t.Slider,"primaryTrack",(0,s.Nd)(t.primary.main,.5)),Q(t.Slider,"secondaryTrack",(0,s.Nd)(t.secondary.main,.5)),Q(t.Slider,"errorTrack",(0,s.Nd)(t.error.main,.5)),Q(t.Slider,"infoTrack",(0,s.Nd)(t.info.main,.5)),Q(t.Slider,"successTrack",(0,s.Nd)(t.success.main,.5)),Q(t.Slider,"warningTrack",(0,s.Nd)(t.warning.main,.5));const e=(0,s.Y9)(t.background.default,.98);Q(t.SnackbarContent,"bg",e),Q(t.SnackbarContent,"color",ee((()=>t.getContrastText(e)))),Q(t.SpeedDialAction,"fabHoverBg",(0,s.Y9)(t.background.paper,.15)),Q(t.StepConnector,"border",n("palette-grey-600")),Q(t.StepContent,"border",n("palette-grey-600")),Q(t.Switch,"defaultColor",n("palette-grey-300")),Q(t.Switch,"defaultDisabledColor",n("palette-grey-600")),Q(t.Switch,"primaryDisabledColor",(0,s.Nd)(t.primary.main,.55)),Q(t.Switch,"secondaryDisabledColor",(0,s.Nd)(t.secondary.main,.55)),Q(t.Switch,"errorDisabledColor",(0,s.Nd)(t.error.main,.55)),Q(t.Switch,"infoDisabledColor",(0,s.Nd)(t.info.main,.55)),Q(t.Switch,"successDisabledColor",(0,s.Nd)(t.success.main,.55)),Q(t.Switch,"warningDisabledColor",(0,s.Nd)(t.warning.main,.55)),Q(t.TableCell,"border",(0,s.Nd)((0,s.Cg)(t.divider,1),.68)),Q(t.Tooltip,"bg",(0,s.Cg)(t.grey[700],.92))}J(t.background,"default"),J(t.background,"paper"),J(t.common,"background"),J(t.common,"onBackground"),J(t,"divider"),Object.keys(t).forEach((e=>{const n=t[e];n&&"object"===typeof n&&(n.main&&Q(t[e],"mainChannel",(0,s.Me)(Z(n.main))),n.light&&Q(t[e],"lightChannel",(0,s.Me)(Z(n.light))),n.dark&&Q(t[e],"darkChannel",(0,s.Me)(Z(n.dark))),n.contrastText&&Q(t[e],"contrastTextChannel",(0,s.Me)(Z(n.contrastText))),"text"===e&&(J(t[e],"primary"),J(t[e],"secondary")),"action"===e&&(n.active&&J(t[e],"active"),n.selected&&J(t[e],"selected")))}))}));for(var E=arguments.length,_=new Array(E>1?E-1:0),$=1;$<E;$++)_[$-1]=arguments[$];I=_.reduce(((e,t)=>(0,a.A)(e,t)),I);const R={prefix:o,disableCssColorScheme:i,shouldSkipGeneratingVar:l,getSelector:Y(I)},{vars:D,generateThemeVars:M,generateStyleSheets:F}=N(I,R);return I.vars=D,Object.entries(I.colorSchemes[I.defaultColorScheme]).forEach((e=>{let[t,n]=e;I[t]=n})),I.generateThemeVars=M,I.generateStyleSheets=F,I.generateSpacing=function(){return(0,v.A)(c.spacing,(0,x.LX)(this))},I.getColorSchemeSelector=function(e){return function(t){return"media"===e?`@media (prefers-color-scheme: ${t})`:e?e.startsWith("data-")&&!e.includes("%s")?`[${e}="${t}"] &`:"class"===e?`.${t} &`:"data"===e?`[data-${t}] &`:`${e.replace("%s",t)} &`:"&"}}(u),I.spacing=I.generateSpacing(),I.shouldSkipGeneratingVar=l,I.unstable_sxConfig={...C.A,...c?.unstable_sxConfig},I.unstable_sx=function(e){return(0,A.A)({sx:e,theme:this})},I.toRuntimeSource=X,I}({...l,colorSchemes:d,defaultColorScheme:u,..."boolean"!==typeof n&&n},...p)}},5170:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=(0,n(5913).A)()},3582:(e,t,n)=>{"use strict";function r(e){let t;return t=e<1?5.11916*e**2:4.5*Math.log(e+1)+2,Math.round(10*t)/1e3}n.d(t,{A:()=>r})},3375:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r="$$material"},1475:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(7123);const a=e=>(0,r.A)(e)&&"classes"!==e},7123:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=function(e){return"ownerState"!==e&&"theme"!==e&&"sx"!==e&&"as"!==e}},4535:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>o});var r=n(3860),a=n(5170),s=n(3375),i=n(1475);const o=(0,r.Ay)({themeId:s.A,defaultTheme:a.A,rootShouldForwardProp:i.A})},6803:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(7598).A},9662:(e,t,n)=>{"use strict";n.d(t,{A:()=>y});var r=n(5043),a=n(8387),s=n(8610),i=n(6803),o=n(4535),l=n(6870),u=n(8249),c=n(2532),d=n(2372);function h(e){return(0,d.Ay)("MuiSvgIcon",e)}(0,c.A)("MuiSvgIcon",["root","colorPrimary","colorSecondary","colorAction","colorError","colorDisabled","fontSizeInherit","fontSizeSmall","fontSizeMedium","fontSizeLarge"]);var p=n(579);const f=(0,o.Ay)("svg",{name:"MuiSvgIcon",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,"inherit"!==n.color&&t[`color${(0,i.A)(n.color)}`],t[`fontSize${(0,i.A)(n.fontSize)}`]]}})((0,l.A)((e=>{let{theme:t}=e;return{userSelect:"none",width:"1em",height:"1em",display:"inline-block",flexShrink:0,transition:t.transitions?.create?.("fill",{duration:(t.vars??t).transitions?.duration?.shorter}),variants:[{props:e=>!e.hasSvgAsChild,style:{fill:"currentColor"}},{props:{fontSize:"inherit"},style:{fontSize:"inherit"}},{props:{fontSize:"small"},style:{fontSize:t.typography?.pxToRem?.(20)||"1.25rem"}},{props:{fontSize:"medium"},style:{fontSize:t.typography?.pxToRem?.(24)||"1.5rem"}},{props:{fontSize:"large"},style:{fontSize:t.typography?.pxToRem?.(35)||"2.1875rem"}},...Object.entries((t.vars??t).palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars??t).palette?.[n]?.main}}})),{props:{color:"action"},style:{color:(t.vars??t).palette?.action?.active}},{props:{color:"disabled"},style:{color:(t.vars??t).palette?.action?.disabled}},{props:{color:"inherit"},style:{color:void 0}}]}}))),m=r.forwardRef((function(e,t){const n=(0,u.b)({props:e,name:"MuiSvgIcon"}),{children:o,className:l,color:c="inherit",component:d="svg",fontSize:m="medium",htmlColor:g,inheritViewBox:y=!1,titleAccess:b,viewBox:v="0 0 24 24",...x}=n,w=r.isValidElement(o)&&"svg"===o.type,k={...n,color:c,component:d,fontSize:m,instanceFontSize:e.fontSize,inheritViewBox:y,viewBox:v,hasSvgAsChild:w},S={};y||(S.viewBox=v);const I=(e=>{const{color:t,fontSize:n,classes:r}=e,a={root:["root","inherit"!==t&&`color${(0,i.A)(t)}`,`fontSize${(0,i.A)(n)}`]};return(0,s.A)(a,h,r)})(k);return(0,p.jsxs)(f,{as:d,className:(0,a.A)(I.root,l),focusable:"false",color:g,"aria-hidden":!b||void 0,role:b?"img":void 0,ref:t,...S,...x,...w&&o.props,ownerState:k,children:[w?o.props.children:o,b?(0,p.jsx)("title",{children:b}):null]})}));m&&(m.muiName="SvgIcon");const g=m;function y(e,t){function n(n,r){return(0,p.jsx)(g,{"data-testid":`${t}Icon`,ref:r,...n,children:e})}return n.muiName=g.muiName,r.memo(r.forwardRef(n))}},950:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(3468).A},4421:(e,t,n)=>{"use strict";n.r(t),n.d(t,{capitalize:()=>a.A,createChainedFunction:()=>s,createSvgIcon:()=>i.A,debounce:()=>o.A,deprecatedPropType:()=>l,isMuiElement:()=>u.A,ownerDocument:()=>d.A,ownerWindow:()=>h.A,requirePropFactory:()=>p,setRef:()=>f,unstable_ClassNameGenerator:()=>w,unstable_memoTheme:()=>c.A,unstable_useEnhancedEffect:()=>m.A,unstable_useId:()=>g.A,unsupportedProp:()=>y,useControlled:()=>b.A,useEventCallback:()=>v.A,useForkRef:()=>x.A});var r=n(9386),a=n(6803);const s=n(2456).A;var i=n(9662),o=n(950);const l=function(e,t){return()=>null};var u=n(7328),c=n(6870),d=n(2427),h=n(6078);const p=function(e,t){return()=>null};const f=n(6564).A;var m=n(5013),g=n(5879);const y=function(e,t,n,r,a){return null};var b=n(5420),v=n(3319),x=n(5849);const w={configure:e=>{r.A.configure(e)}}},7328:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(5043);const a=function(e,t){return r.isValidElement(e)&&-1!==t.indexOf(e.type.muiName??e.type?._payload?.value?.muiName)}},6870:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});const r={theme:void 0};function a(e){let t,n;return a=>{let s=t;return void 0!==s&&a.theme===n||(r.theme=a.theme,s=e(r),t=s,n=a.theme),s}}},2427:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(1668).A},6078:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(3940).A},5420:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(5043);const a=function(e){let{controlled:t,default:n,name:a,state:s="value"}=e;const{current:i}=r.useRef(void 0!==t),[o,l]=r.useState(n);return[i?t:o,r.useCallback((e=>{i||l(e)}),[])]}},5013:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(4440).A},3319:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(1782).A},5849:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(3462).A},5879:(e,t,n)=>{"use strict";n.d(t,{A:()=>r});const r=n(5844).A},4984:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>b,q_:()=>v});var r=n(8168),a=n(5043),s=n(918),i=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,o=(0,s.A)((function(e){return i.test(e)||111===e.charCodeAt(0)&&110===e.charCodeAt(1)&&e.charCodeAt(2)<91})),l=n(4575),u=n(1722),c=n(6598),d=n(9436),h=o,p=function(e){return"theme"!==e},f=function(e){return"string"===typeof e&&e.charCodeAt(0)>96?h:p},m=function(e,t,n){var r;if(t){var a=t.shouldForwardProp;r=e.__emotion_forwardProp&&a?function(t){return e.__emotion_forwardProp(t)&&a(t)}:a}return"function"!==typeof r&&n&&(r=e.__emotion_forwardProp),r},g=function(e){var t=e.cache,n=e.serialized,r=e.isStringTag;return(0,u.SF)(t,n,r),(0,d.s)((function(){return(0,u.sk)(t,n,r)})),null},y=function e(t,n){var s,i,o=t.__emotion_real===t,d=o&&t.__emotion_base||t;void 0!==n&&(s=n.label,i=n.target);var h=m(t,n,o),p=h||f(d),y=!p("as");return function(){var b=arguments,v=o&&void 0!==t.__emotion_styles?t.__emotion_styles.slice(0):[];if(void 0!==s&&v.push("label:"+s+";"),null==b[0]||void 0===b[0].raw)v.push.apply(v,b);else{v.push(b[0][0]);for(var x=b.length,w=1;w<x;w++)v.push(b[w],b[0][w])}var k=(0,l.w)((function(e,t,n){var r=y&&e.as||d,s="",o=[],m=e;if(null==e.theme){for(var b in m={},e)m[b]=e[b];m.theme=a.useContext(l.T)}"string"===typeof e.className?s=(0,u.Rk)(t.registered,o,e.className):null!=e.className&&(s=e.className+" ");var x=(0,c.J)(v.concat(o),t.registered,m);s+=t.key+"-"+x.name,void 0!==i&&(s+=" "+i);var w=y&&void 0===h?f(r):p,k={};for(var S in e)y&&"as"===S||w(S)&&(k[S]=e[S]);return k.className=s,n&&(k.ref=n),a.createElement(a.Fragment,null,a.createElement(g,{cache:t,serialized:x,isStringTag:"string"===typeof r}),a.createElement(r,k))}));return k.displayName=void 0!==s?s:"Styled("+("string"===typeof d?d:d.displayName||d.name||"Component")+")",k.defaultProps=t.defaultProps,k.__emotion_real=k,k.__emotion_base=d,k.__emotion_styles=v,k.__emotion_forwardProp=h,Object.defineProperty(k,"toString",{value:function(){return"."+i}}),k.withComponent=function(t,a){return e(t,(0,r.A)({},n,a,{shouldForwardProp:m(k,a,!0)})).apply(void 0,v)},k}}.bind();function b(e,t){return y(e,t)}["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"].forEach((function(e){y[e]=y(e)}));const v=(e,t)=>{Array.isArray(e.__emotion_styles)&&(e.__emotion_styles=t(e.__emotion_styles))}},1136:(e,t,n)=>{"use strict";n.d(t,{EU:()=>l,NI:()=>o,kW:()=>c,vf:()=>u,zu:()=>a});var r=n(3072);const a={xs:0,sm:600,md:900,lg:1200,xl:1536},s={keys:["xs","sm","md","lg","xl"],up:e=>`@media (min-width:${a[e]}px)`},i={containerQueries:e=>({up:t=>{let n="number"===typeof t?t:a[t]||t;return"number"===typeof n&&(n=`${n}px`),e?`@container ${e} (min-width:${n})`:`@container (min-width:${n})`}})};function o(e,t,n){const o=e.theme||{};if(Array.isArray(t)){const e=o.breakpoints||s;return t.reduce(((r,a,s)=>(r[e.up(e.keys[s])]=n(t[s]),r)),{})}if("object"===typeof t){const e=o.breakpoints||s;return Object.keys(t).reduce(((s,l)=>{if((0,r.ob)(e.keys,l)){const e=(0,r.CT)(o.containerQueries?o:i,l);e&&(s[e]=n(t[l],l))}else if(Object.keys(e.values||a).includes(l)){s[e.up(l)]=n(t[l],l)}else{const e=l;s[e]=t[e]}return s}),{})}return n(t)}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=e.keys?.reduce(((t,n)=>(t[e.up(n)]={},t)),{});return t||{}}function u(e,t){return e.reduce(((e,t)=>{const n=e[t];return(!n||0===Object.keys(n).length)&&delete e[t],e}),t)}function c(e){let{values:t,breakpoints:n,base:r}=e;const a=r||function(e,t){if("object"!==typeof e)return{};const n={},r=Object.keys(t);return Array.isArray(e)?r.forEach(((t,r)=>{r<e.length&&(n[t]=!0)})):r.forEach((t=>{null!=e[t]&&(n[t]=!0)})),n}(t,n),s=Object.keys(a);if(0===s.length)return t;let i;return s.reduce(((e,n,r)=>(Array.isArray(t)?(e[n]=null!=t[r]?t[r]:t[i],i=r):"object"===typeof t?(e[n]=null!=t[n]?t[n]:t[i],i=n):e[n]=t,e)),{})}},6596:(e,t,n)=>{"use strict";n.d(t,{X4:()=>h,e$:()=>f,tL:()=>b,eM:()=>d,YL:()=>u,a:()=>g,Cg:()=>p,Me:()=>o,Nd:()=>m,Y9:()=>v,j4:()=>y});var r=n(7868);const a=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MIN_SAFE_INTEGER,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Number.MAX_SAFE_INTEGER;return Math.max(t,Math.min(e,n))};function s(e){return a(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1)}function i(e){if(e.type)return e;if("#"===e.charAt(0))return i(function(e){e=e.slice(1);const t=new RegExp(`.{1,${e.length>=6?2:1}}`,"g");let n=e.match(t);return n&&1===n[0].length&&(n=n.map((e=>e+e))),n?`rgb${4===n.length?"a":""}(${n.map(((e,t)=>t<3?parseInt(e,16):Math.round(parseInt(e,16)/255*1e3)/1e3)).join(", ")})`:""}(e));const t=e.indexOf("("),n=e.substring(0,t);if(!["rgb","rgba","hsl","hsla","color"].includes(n))throw new Error((0,r.A)(9,e));let a,s=e.substring(t+1,e.length-1);if("color"===n){if(s=s.split(" "),a=s.shift(),4===s.length&&"/"===s[3].charAt(0)&&(s[3]=s[3].slice(1)),!["srgb","display-p3","a98-rgb","prophoto-rgb","rec-2020"].includes(a))throw new Error((0,r.A)(10,a))}else s=s.split(",");return s=s.map((e=>parseFloat(e))),{type:n,values:s,colorSpace:a}}const o=(e,t)=>{try{return(e=>{const t=i(e);return t.values.slice(0,3).map(((e,n)=>t.type.includes("hsl")&&0!==n?`${e}%`:e)).join(" ")})(e)}catch(n){return e}};function l(e){const{type:t,colorSpace:n}=e;let{values:r}=e;return t.includes("rgb")?r=r.map(((e,t)=>t<3?parseInt(e,10):e)):t.includes("hsl")&&(r[1]=`${r[1]}%`,r[2]=`${r[2]}%`),r=t.includes("color")?`${n} ${r.join(" ")}`:`${r.join(", ")}`,`${t}(${r})`}function u(e){e=i(e);const{values:t}=e,n=t[0],r=t[1]/100,a=t[2]/100,s=r*Math.min(a,1-a),o=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(e+n/30)%12;return a-s*Math.max(Math.min(t-3,9-t,1),-1)};let u="rgb";const c=[Math.round(255*o(0)),Math.round(255*o(8)),Math.round(255*o(4))];return"hsla"===e.type&&(u+="a",c.push(t[3])),l({type:u,values:c})}function c(e){let t="hsl"===(e=i(e)).type||"hsla"===e.type?i(u(e)).values:e.values;return t=t.map((t=>("color"!==e.type&&(t/=255),t<=.03928?t/12.92:((t+.055)/1.055)**2.4))),Number((.2126*t[0]+.7152*t[1]+.0722*t[2]).toFixed(3))}function d(e,t){const n=c(e),r=c(t);return(Math.max(n,r)+.05)/(Math.min(n,r)+.05)}function h(e,t){return e=i(e),t=s(t),"rgb"!==e.type&&"hsl"!==e.type||(e.type+="a"),"color"===e.type?e.values[3]=`/${t}`:e.values[3]=t,l(e)}function p(e,t,n){try{return h(e,t)}catch(r){return e}}function f(e,t){if(e=i(e),t=s(t),e.type.includes("hsl"))e.values[2]*=1-t;else if(e.type.includes("rgb")||e.type.includes("color"))for(let n=0;n<3;n+=1)e.values[n]*=1-t;return l(e)}function m(e,t,n){try{return f(e,t)}catch(r){return e}}function g(e,t){if(e=i(e),t=s(t),e.type.includes("hsl"))e.values[2]+=(100-e.values[2])*t;else if(e.type.includes("rgb"))for(let n=0;n<3;n+=1)e.values[n]+=(255-e.values[n])*t;else if(e.type.includes("color"))for(let n=0;n<3;n+=1)e.values[n]+=(1-e.values[n])*t;return l(e)}function y(e,t,n){try{return g(e,t)}catch(r){return e}}function b(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.15;return c(e)>.5?f(e,t):g(e,t)}function v(e,t,n){try{return b(e,t)}catch(r){return e}}},3860:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>f,MC:()=>l});var r=n(4984),a=n(9172),s=n(2390),i=n(2768);const o=(0,s.A)();function l(e){return"ownerState"!==e&&"theme"!==e&&"sx"!==e&&"as"!==e}function u(e,t,n){return function(e){for(const t in e)return!1;return!0}(t)?n:t[e]||t}const c=Symbol("mui.processed_props");function d(e,t,n){if(c in e)return e[c];const r={...e,theme:u(t,e.theme,n)};return e[c]=r,r[c]=r,r}function h(e){return e?(t,n)=>n[e]:null}function p(e,t){const n="function"===typeof e?e(t):e;if(Array.isArray(n))return n.flatMap((e=>p(e,t)));if(Array.isArray(n?.variants)){const{variants:e,...r}=n;let a,s=r;e:for(let n=0;n<e.length;n+=1){const r=e[n];if("function"===typeof r.props){if(a??={...t,...t.ownerState,ownerState:t.ownerState},!r.props(a))continue}else for(const e in r.props)if(t[e]!==r.props[e]&&t.ownerState?.[e]!==r.props[e])continue e;Array.isArray(s)||(s=[s]),"function"===typeof r.style?(a??={...t,...t.ownerState,ownerState:t.ownerState},s.push(r.style(a))):s.push(r.style)}return s}return n}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{themeId:t,defaultTheme:n=o,rootShouldForwardProp:s=l,slotShouldForwardProp:c=l}=e,f=e=>(0,i.A)(d(e,t,n));f.__mui_systemSx=!0;return function(e){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,r.q_)(e,(e=>e.filter((e=>!e?.__mui_systemSx))));const{name:o,slot:g,skipVariantsResolver:y,skipSx:b,overridesResolver:v=h(m(g)),...x}=i,w=void 0!==y?y:g&&"Root"!==g&&"root"!==g||!1,k=b||!1;let S=l;"Root"===g||"root"===g?S=s:g?S=c:function(e){return"string"===typeof e&&e.charCodeAt(0)>96}(e)&&(S=void 0);const I=(0,r.Ay)(e,{shouldForwardProp:S,label:undefined,...x}),T=e=>"function"===typeof e&&e.__emotion_real!==e||(0,a.Q)(e)?r=>p(e,d(r,t,n)):e,N=function(r){let a=T(r);for(var s=arguments.length,i=new Array(s>1?s-1:0),l=1;l<s;l++)i[l-1]=arguments[l];const c=i?i.map(T):[];o&&v&&c.push((e=>{const r=u(t,e.theme,n);if(!r.components||!r.components[o]||!r.components[o].styleOverrides)return null;const a=r.components[o].styleOverrides,s={},i=d(e,t,n);for(const t in a)s[t]=p(a[t],i);return v(e,s)})),o&&!w&&c.push((e=>{const r=u(t,e.theme,n),a=r?.components?.[o]?.variants;return a?p({variants:a},d(e,t,n)):null})),k||c.push(f);const h=c.length-i.length;if(Array.isArray(r)&&h>0){const e=new Array(h).fill("");a=[...r,...e],a.raw=[...r.raw,...e]}const m=I(a,...c);return e.muiName&&(m.muiName=e.muiName),m};return I.withConfig&&(N.withConfig=I.withConfig),N}}function m(e){return e?e.charAt(0).toLowerCase()+e.slice(1):e}},6160:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(883);function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:8,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(0,r.LX)({spacing:e});if(e.mui)return e;const n=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return(0===n.length?[1]:n).map((e=>{const n=t(e);return"number"===typeof n?`${n}px`:n})).join(" ")};return n.mui=!0,n}},2390:(e,t,n)=>{"use strict";n.d(t,{A:()=>d});var r=n(9172);const a=e=>{const t=Object.keys(e).map((t=>({key:t,val:e[t]})))||[];return t.sort(((e,t)=>e.val-t.val)),t.reduce(((e,t)=>({...e,[t.key]:t.val})),{})};var s=n(3072);const i={borderRadius:4};var o=n(6160),l=n(2768),u=n(138);function c(e,t){const n=this;if(n.vars){if(!n.colorSchemes?.[e]||"function"!==typeof n.getColorSchemeSelector)return{};let r=n.getColorSchemeSelector(e);return(r.includes("data-")||r.includes("."))&&(r=`*:where(${r.replace(/\s*&$/,"")}) &`),{[r]:t}}return n.palette.mode===e?t:{}}const d=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{breakpoints:t={},palette:n={},spacing:d,shape:h={},...p}=e,f=function(e){const{values:t={xs:0,sm:600,md:900,lg:1200,xl:1536},unit:n="px",step:r=5,...s}=e,i=a(t),o=Object.keys(i);function l(e){return`@media (min-width:${"number"===typeof t[e]?t[e]:e}${n})`}function u(e){return`@media (max-width:${("number"===typeof t[e]?t[e]:e)-r/100}${n})`}function c(e,a){const s=o.indexOf(a);return`@media (min-width:${"number"===typeof t[e]?t[e]:e}${n}) and (max-width:${(-1!==s&&"number"===typeof t[o[s]]?t[o[s]]:a)-r/100}${n})`}return{keys:o,values:i,up:l,down:u,between:c,only:function(e){return o.indexOf(e)+1<o.length?c(e,o[o.indexOf(e)+1]):l(e)},not:function(e){const t=o.indexOf(e);return 0===t?l(o[1]):t===o.length-1?u(o[t]):c(e,o[o.indexOf(e)+1]).replace("@media","@media not all and")},unit:n,...s}}(t),m=(0,o.A)(d);let g=(0,r.A)({breakpoints:f,direction:"ltr",components:{},palette:{mode:"light",...n},spacing:m,shape:{...i,...h}},p);g=(0,s.Ay)(g),g.applyStyles=c;for(var y=arguments.length,b=new Array(y>1?y-1:0),v=1;v<y;v++)b[v-1]=arguments[v];return g=b.reduce(((e,t)=>(0,r.A)(e,t)),g),g.unstable_sxConfig={...u.A,...p?.unstable_sxConfig},g.unstable_sx=function(e){return(0,l.A)({sx:e,theme:this})},g}},3072:(e,t,n)=>{"use strict";function r(e,t){if(!e.containerQueries)return t;const n=Object.keys(t).filter((e=>e.startsWith("@container"))).sort(((e,t)=>{const n=/min-width:\s*([0-9.]+)/;return+(e.match(n)?.[1]||0)-+(t.match(n)?.[1]||0)}));return n.length?n.reduce(((e,n)=>{const r=t[n];return delete e[n],e[n]=r,e}),{...t}):t}function a(e,t){return"@"===t||t.startsWith("@")&&(e.some((e=>t.startsWith(`@${e}`)))||!!t.match(/^@\d/))}function s(e,t){const n=t.match(/^@([^/]+)?\/?(.+)?$/);if(!n)return null;const[,r,a]=n,s=Number.isNaN(+r)?r||0:+r;return e.containerQueries(a).up(s)}function i(e){const t=(e,t)=>e.replace("@media",t?`@container ${t}`:"@container");function n(n,r){n.up=function(){return t(e.breakpoints.up(...arguments),r)},n.down=function(){return t(e.breakpoints.down(...arguments),r)},n.between=function(){return t(e.breakpoints.between(...arguments),r)},n.only=function(){return t(e.breakpoints.only(...arguments),r)},n.not=function(){const n=t(e.breakpoints.not(...arguments),r);return n.includes("not all and")?n.replace("not all and ","").replace("min-width:","width<").replace("max-width:","width>").replace("and","or"):n}}const r={},a=e=>(n(r,e),r);return n(a),{...e,containerQueries:a}}n.d(t,{Ay:()=>i,CT:()=>s,_S:()=>r,ob:()=>a})},5056:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(9172);const a=function(e,t){return t?(0,r.A)(e,t,{clone:!1}):e}},883:(e,t,n)=>{"use strict";n.d(t,{LX:()=>f,MA:()=>p,_W:()=>m,Lc:()=>b,Ms:()=>v});var r=n(1136),a=n(6224),s=n(5056);const i={m:"margin",p:"padding"},o={t:"Top",r:"Right",b:"Bottom",l:"Left",x:["Left","Right"],y:["Top","Bottom"]},l={marginX:"mx",marginY:"my",paddingX:"px",paddingY:"py"},u=function(e){const t={};return n=>(void 0===t[n]&&(t[n]=e(n)),t[n])}((e=>{if(e.length>2){if(!l[e])return[e];e=l[e]}const[t,n]=e.split(""),r=i[t],a=o[n]||"";return Array.isArray(a)?a.map((e=>r+e)):[r+a]})),c=["m","mt","mr","mb","ml","mx","my","margin","marginTop","marginRight","marginBottom","marginLeft","marginX","marginY","marginInline","marginInlineStart","marginInlineEnd","marginBlock","marginBlockStart","marginBlockEnd"],d=["p","pt","pr","pb","pl","px","py","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","paddingX","paddingY","paddingInline","paddingInlineStart","paddingInlineEnd","paddingBlock","paddingBlockStart","paddingBlockEnd"],h=[...c,...d];function p(e,t,n,r){const s=(0,a.Yn)(e,t,!0)??n;return"number"===typeof s||"string"===typeof s?e=>"string"===typeof e?e:"string"===typeof s?`calc(${e} * ${s})`:s*e:Array.isArray(s)?e=>{if("string"===typeof e)return e;const t=Math.abs(e);const n=s[t];return e>=0?n:"number"===typeof n?-n:`-${n}`}:"function"===typeof s?s:()=>{}}function f(e){return p(e,"spacing",8)}function m(e,t){return"string"===typeof t||null==t?t:e(t)}function g(e,t,n,a){if(!t.includes(n))return null;const s=function(e,t){return n=>e.reduce(((e,r)=>(e[r]=m(t,n),e)),{})}(u(n),a),i=e[n];return(0,r.NI)(e,i,s)}function y(e,t){const n=f(e.theme);return Object.keys(e).map((r=>g(e,t,r,n))).reduce(s.A,{})}function b(e){return y(e,c)}function v(e){return y(e,d)}function x(e){return y(e,h)}b.propTypes={},b.filterProps=c,v.propTypes={},v.filterProps=d,x.propTypes={},x.filterProps=h},6224:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>o,BO:()=>i,Yn:()=>s});var r=n(7598),a=n(1136);function s(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(!t||"string"!==typeof t)return null;if(e&&e.vars&&n){const n=`vars.${t}`.split(".").reduce(((e,t)=>e&&e[t]?e[t]:null),e);if(null!=n)return n}return t.split(".").reduce(((e,t)=>e&&null!=e[t]?e[t]:null),e)}function i(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n;return r="function"===typeof e?e(n):Array.isArray(e)?e[n]||a:s(e,n)||a,t&&(r=t(r,a,e)),r}const o=function(e){const{prop:t,cssProperty:n=e.prop,themeKey:o,transform:l}=e,u=e=>{if(null==e[t])return null;const u=e[t],c=s(e.theme,o)||{};return(0,a.NI)(e,u,(e=>{let a=i(c,l,e);return e===a&&"string"===typeof e&&(a=i(c,l,`${t}${"default"===e?"":(0,r.A)(e)}`,e)),!1===n?a:{[n]:a}}))};return u.propTypes={},u.filterProps=[t],u}},138:(e,t,n)=>{"use strict";n.d(t,{A:()=>M});var r=n(883),a=n(6224),s=n(5056);const i=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=t.reduce(((e,t)=>(t.filterProps.forEach((n=>{e[n]=t})),e)),{}),a=e=>Object.keys(e).reduce(((t,n)=>r[n]?(0,s.A)(t,r[n](e)):t),{});return a.propTypes={},a.filterProps=t.reduce(((e,t)=>e.concat(t.filterProps)),[]),a};var o=n(1136);function l(e){return"number"!==typeof e?e:`${e}px solid`}function u(e,t){return(0,a.Ay)({prop:e,themeKey:"borders",transform:t})}const c=u("border",l),d=u("borderTop",l),h=u("borderRight",l),p=u("borderBottom",l),f=u("borderLeft",l),m=u("borderColor"),g=u("borderTopColor"),y=u("borderRightColor"),b=u("borderBottomColor"),v=u("borderLeftColor"),x=u("outline",l),w=u("outlineColor"),k=e=>{if(void 0!==e.borderRadius&&null!==e.borderRadius){const t=(0,r.MA)(e.theme,"shape.borderRadius",4,"borderRadius"),n=e=>({borderRadius:(0,r._W)(t,e)});return(0,o.NI)(e,e.borderRadius,n)}return null};k.propTypes={},k.filterProps=["borderRadius"];i(c,d,h,p,f,m,g,y,b,v,k,x,w);const S=e=>{if(void 0!==e.gap&&null!==e.gap){const t=(0,r.MA)(e.theme,"spacing",8,"gap"),n=e=>({gap:(0,r._W)(t,e)});return(0,o.NI)(e,e.gap,n)}return null};S.propTypes={},S.filterProps=["gap"];const I=e=>{if(void 0!==e.columnGap&&null!==e.columnGap){const t=(0,r.MA)(e.theme,"spacing",8,"columnGap"),n=e=>({columnGap:(0,r._W)(t,e)});return(0,o.NI)(e,e.columnGap,n)}return null};I.propTypes={},I.filterProps=["columnGap"];const T=e=>{if(void 0!==e.rowGap&&null!==e.rowGap){const t=(0,r.MA)(e.theme,"spacing",8,"rowGap"),n=e=>({rowGap:(0,r._W)(t,e)});return(0,o.NI)(e,e.rowGap,n)}return null};T.propTypes={},T.filterProps=["rowGap"];i(S,I,T,(0,a.Ay)({prop:"gridColumn"}),(0,a.Ay)({prop:"gridRow"}),(0,a.Ay)({prop:"gridAutoFlow"}),(0,a.Ay)({prop:"gridAutoColumns"}),(0,a.Ay)({prop:"gridAutoRows"}),(0,a.Ay)({prop:"gridTemplateColumns"}),(0,a.Ay)({prop:"gridTemplateRows"}),(0,a.Ay)({prop:"gridTemplateAreas"}),(0,a.Ay)({prop:"gridArea"}));function N(e,t){return"grey"===t?t:e}i((0,a.Ay)({prop:"color",themeKey:"palette",transform:N}),(0,a.Ay)({prop:"bgcolor",cssProperty:"backgroundColor",themeKey:"palette",transform:N}),(0,a.Ay)({prop:"backgroundColor",themeKey:"palette",transform:N}));function C(e){return e<=1&&0!==e?100*e+"%":e}const A=(0,a.Ay)({prop:"width",transform:C}),E=e=>{if(void 0!==e.maxWidth&&null!==e.maxWidth){const t=t=>{const n=e.theme?.breakpoints?.values?.[t]||o.zu[t];return n?"px"!==e.theme?.breakpoints?.unit?{maxWidth:`${n}${e.theme.breakpoints.unit}`}:{maxWidth:n}:{maxWidth:C(t)}};return(0,o.NI)(e,e.maxWidth,t)}return null};E.filterProps=["maxWidth"];const _=(0,a.Ay)({prop:"minWidth",transform:C}),$=(0,a.Ay)({prop:"height",transform:C}),R=(0,a.Ay)({prop:"maxHeight",transform:C}),D=(0,a.Ay)({prop:"minHeight",transform:C}),M=((0,a.Ay)({prop:"size",cssProperty:"width",transform:C}),(0,a.Ay)({prop:"size",cssProperty:"height",transform:C}),i(A,E,_,$,R,D,(0,a.Ay)({prop:"boxSizing"})),{border:{themeKey:"borders",transform:l},borderTop:{themeKey:"borders",transform:l},borderRight:{themeKey:"borders",transform:l},borderBottom:{themeKey:"borders",transform:l},borderLeft:{themeKey:"borders",transform:l},borderColor:{themeKey:"palette"},borderTopColor:{themeKey:"palette"},borderRightColor:{themeKey:"palette"},borderBottomColor:{themeKey:"palette"},borderLeftColor:{themeKey:"palette"},outline:{themeKey:"borders",transform:l},outlineColor:{themeKey:"palette"},borderRadius:{themeKey:"shape.borderRadius",style:k},color:{themeKey:"palette",transform:N},bgcolor:{themeKey:"palette",cssProperty:"backgroundColor",transform:N},backgroundColor:{themeKey:"palette",transform:N},p:{style:r.Ms},pt:{style:r.Ms},pr:{style:r.Ms},pb:{style:r.Ms},pl:{style:r.Ms},px:{style:r.Ms},py:{style:r.Ms},padding:{style:r.Ms},paddingTop:{style:r.Ms},paddingRight:{style:r.Ms},paddingBottom:{style:r.Ms},paddingLeft:{style:r.Ms},paddingX:{style:r.Ms},paddingY:{style:r.Ms},paddingInline:{style:r.Ms},paddingInlineStart:{style:r.Ms},paddingInlineEnd:{style:r.Ms},paddingBlock:{style:r.Ms},paddingBlockStart:{style:r.Ms},paddingBlockEnd:{style:r.Ms},m:{style:r.Lc},mt:{style:r.Lc},mr:{style:r.Lc},mb:{style:r.Lc},ml:{style:r.Lc},mx:{style:r.Lc},my:{style:r.Lc},margin:{style:r.Lc},marginTop:{style:r.Lc},marginRight:{style:r.Lc},marginBottom:{style:r.Lc},marginLeft:{style:r.Lc},marginX:{style:r.Lc},marginY:{style:r.Lc},marginInline:{style:r.Lc},marginInlineStart:{style:r.Lc},marginInlineEnd:{style:r.Lc},marginBlock:{style:r.Lc},marginBlockStart:{style:r.Lc},marginBlockEnd:{style:r.Lc},displayPrint:{cssProperty:!1,transform:e=>({"@media print":{display:e}})},display:{},overflow:{},textOverflow:{},visibility:{},whiteSpace:{},flexBasis:{},flexDirection:{},flexWrap:{},justifyContent:{},alignItems:{},alignContent:{},order:{},flex:{},flexGrow:{},flexShrink:{},alignSelf:{},justifyItems:{},justifySelf:{},gap:{style:S},rowGap:{style:T},columnGap:{style:I},gridColumn:{},gridRow:{},gridAutoFlow:{},gridAutoColumns:{},gridAutoRows:{},gridTemplateColumns:{},gridTemplateRows:{},gridTemplateAreas:{},gridArea:{},position:{},zIndex:{themeKey:"zIndex"},top:{},right:{},bottom:{},left:{},boxShadow:{themeKey:"shadows"},width:{transform:C},maxWidth:{style:E},minWidth:{transform:C},height:{transform:C},maxHeight:{transform:C},minHeight:{transform:C},boxSizing:{},font:{themeKey:"font"},fontFamily:{themeKey:"typography"},fontSize:{themeKey:"typography"},fontStyle:{themeKey:"typography"},fontWeight:{themeKey:"typography"},letterSpacing:{},textTransform:{},lineHeight:{},textAlign:{},typography:{cssProperty:!1,themeKey:"typography"}})},2768:(e,t,n)=>{"use strict";n.d(t,{A:()=>c});var r=n(7598),a=n(5056),s=n(6224),i=n(1136),o=n(3072),l=n(138);const u=function(){function e(e,t,n,a){const o={[e]:t,theme:n},l=a[e];if(!l)return{[e]:t};const{cssProperty:u=e,themeKey:c,transform:d,style:h}=l;if(null==t)return null;if("typography"===c&&"inherit"===t)return{[e]:t};const p=(0,s.Yn)(n,c)||{};if(h)return h(o);return(0,i.NI)(o,t,(t=>{let n=(0,s.BO)(p,d,t);return t===n&&"string"===typeof t&&(n=(0,s.BO)(p,d,`${e}${"default"===t?"":(0,r.A)(t)}`,t)),!1===u?n:{[u]:n}}))}return function t(n){const{sx:r,theme:s={}}=n||{};if(!r)return null;const u=s.unstable_sxConfig??l.A;function c(n){let r=n;if("function"===typeof n)r=n(s);else if("object"!==typeof n)return n;if(!r)return null;const l=(0,i.EU)(s.breakpoints),c=Object.keys(l);let d=l;return Object.keys(r).forEach((n=>{const o=(l=r[n],c=s,"function"===typeof l?l(c):l);var l,c;if(null!==o&&void 0!==o)if("object"===typeof o)if(u[n])d=(0,a.A)(d,e(n,o,s,u));else{const e=(0,i.NI)({theme:s},o,(e=>({[n]:e})));!function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=t.reduce(((e,t)=>e.concat(Object.keys(t))),[]),a=new Set(r);return t.every((e=>a.size===Object.keys(e).length))}(e,o)?d=(0,a.A)(d,e):d[n]=t({sx:o,theme:s})}else d=(0,a.A)(d,e(n,o,s,u))})),(0,o._S)(s,(0,i.vf)(c,d))}return Array.isArray(r)?r.map(c):c(r)}}();u.filterProps=["sx"];const c=u},9386:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});const r=e=>e,a=(()=>{let e=r;return{configure(t){e=t},generate:t=>e(t),reset(){e=r}}})()},7598:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(7868);function a(e){if("string"!==typeof e)throw new Error((0,r.A)(7));return e.charAt(0).toUpperCase()+e.slice(1)}},8610:(e,t,n)=>{"use strict";function r(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;const r={};for(const a in e){const s=e[a];let i="",o=!0;for(let e=0;e<s.length;e+=1){const r=s[e];r&&(i+=(!0===o?"":" ")+t(r),o=!1,n&&n[r]&&(i+=" "+n[r]))}r[a]=i}return r}n.d(t,{A:()=>r})},2456:(e,t,n)=>{"use strict";function r(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.reduce(((e,t)=>null==t?e:function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];e.apply(this,r),t.apply(this,r)}),(()=>{}))}n.d(t,{A:()=>r})},3468:(e,t,n)=>{"use strict";function r(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:166;function r(){for(var r=arguments.length,a=new Array(r),s=0;s<r;s++)a[s]=arguments[s];clearTimeout(t),t=setTimeout((()=>{e.apply(this,a)}),n)}return r.clear=()=>{clearTimeout(t)},r}n.d(t,{A:()=>r})},9172:(e,t,n)=>{"use strict";function r(e){if("object"!==typeof e||null===e)return!1;const t=Object.getPrototypeOf(e);return(null===t||t===Object.prototype||null===Object.getPrototypeOf(t))&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)}function a(e){if(!r(e))return e;const t={};return Object.keys(e).forEach((n=>{t[n]=a(e[n])})),t}function s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{clone:!0};const i=n.clone?{...e}:e;return r(e)&&r(t)&&Object.keys(t).forEach((o=>{r(t[o])&&Object.prototype.hasOwnProperty.call(e,o)&&r(e[o])?i[o]=s(e[o],t[o],n):n.clone?i[o]=r(t[o])?a(t[o]):t[o]:i[o]=t[o]})),i}n.d(t,{A:()=>s,Q:()=>r})},7868:(e,t,n)=>{"use strict";function r(e){let t="https://mui.com/production-error/?code="+e;for(let n=1;n<arguments.length;n+=1)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified MUI error #"+e+"; visit "+t+" for the full message."}n.d(t,{A:()=>r})},2372:(e,t,n)=>{"use strict";n.d(t,{Ay:()=>s});var r=n(9386);const a={active:"active",checked:"checked",completed:"completed",disabled:"disabled",error:"error",expanded:"expanded",focused:"focused",focusVisible:"focusVisible",open:"open",readOnly:"readOnly",required:"required",selected:"selected"};function s(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const s=a[t];return s?`${n}-${s}`:`${r.A.generate(e)}-${t}`}},2532:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(2372);function a(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const a={};return t.forEach((t=>{a[t]=(0,r.Ay)(e,t,n)})),a}},1668:(e,t,n)=>{"use strict";function r(e){return e&&e.ownerDocument||document}n.d(t,{A:()=>r})},3940:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(1668);function a(e){return(0,r.A)(e).defaultView||window}},3030:(e,t,n)=>{"use strict";function r(e,t){const n={...t};for(const a in e)if(Object.prototype.hasOwnProperty.call(e,a)){const s=a;if("components"===s||"slots"===s)n[s]={...e[s],...n[s]};else if("componentsProps"===s||"slotProps"===s){const a=e[s],i=t[s];if(i)if(a){n[s]={...i};for(const e in a)if(Object.prototype.hasOwnProperty.call(a,e)){const t=e;n[s][t]=r(a[t],i[t])}}else n[s]=i;else n[s]=a||{}}else void 0===n[s]&&(n[s]=e[s])}return n}n.d(t,{A:()=>r})},6564:(e,t,n)=>{"use strict";function r(e,t){"function"===typeof e?e(t):e&&(e.current=t)}n.d(t,{A:()=>r})},4440:(e,t,n)=>{"use strict";n.d(t,{A:()=>a});var r=n(5043);const a="undefined"!==typeof window?r.useLayoutEffect:r.useEffect},1782:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var r=n(5043),a=n(4440);const s=function(e){const t=r.useRef(e);return(0,a.A)((()=>{t.current=e})),r.useRef((function(){return(0,t.current)(...arguments)})).current}},3462:(e,t,n)=>{"use strict";n.d(t,{A:()=>s});var r=n(5043),a=n(6564);function s(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return r.useMemo((()=>t.every((e=>null==e))?null:e=>{t.forEach((t=>{(0,a.A)(t,e)}))}),t)}},5844:(e,t,n)=>{"use strict";var r;n.d(t,{A:()=>o});var a=n(5043);let s=0;const i=(r||(r=n.t(a,2)))["useId".toString()];function o(e){if(void 0!==i){const t=i();return e??t}return function(e){const[t,n]=a.useState(e),r=e||t;return a.useEffect((()=>{null==t&&(s+=1,n(`mui-${s}`))}),[t]),r}(e)}},3915:function(e,t,n){!function(e,t,n){"use strict";const r={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class a{constructor(e,t){this.modelPath=t||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(e)}/model.json`}getPrefix(e){return"lite_mobilenet_v2"===e?`ssd${e}`:`ssd_${e}`}async load(){this.model=await t.loadGraphModel(this.modelPath);const e=n.zeros([1,300,300,3],"int32"),r=await this.model.executeAsync(e);await Promise.all(r.map((e=>e.data()))),r.map((e=>e.dispose())),e.dispose()}async infer(e,t,r){const a=n.tidy((()=>(e instanceof n.Tensor||(e=n.browser.fromPixels(e)),n.expandDims(e)))),s=a.shape[1],i=a.shape[2],o=await this.model.executeAsync(a),l=o[0].dataSync(),u=o[1].dataSync();a.dispose(),n.dispose(o);const[c,d]=this.calculateMaxScores(l,o[0].shape[1],o[0].shape[2]),h=n.getBackend();"webgl"===n.getBackend()&&n.setBackend("cpu");const p=n.tidy((()=>{const e=n.tensor2d(u,[o[1].shape[1],o[1].shape[3]]);return n.image.nonMaxSuppression(e,c,t,r,r)})),f=p.dataSync();return p.dispose(),h!==n.getBackend()&&n.setBackend(h),this.buildDetectedObjects(i,s,u,c,f,d)}buildDetectedObjects(e,t,n,a,s,i){const o=s.length,l=[];for(let u=0;u<o;u++){const o=[];for(let e=0;e<4;e++)o[e]=n[4*s[u]+e];const c=o[0]*t,d=o[1]*e,h=o[2]*t,p=o[3]*e;o[0]=d,o[1]=c,o[2]=p-d,o[3]=h-c,l.push({bbox:o,class:r[i[s[u]]+1].displayName,score:a[s[u]]})}return l}calculateMaxScores(e,t,n){const r=[],a=[];for(let s=0;s<t;s++){let t=Number.MIN_VALUE,i=-1;for(let r=0;r<n;r++)e[s*n+r]>t&&(t=e[s*n+r],i=r);r[s]=t,a[s]=i}return[r,a]}async detect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:20,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.5;return this.infer(e,t,n)}dispose(){null!=this.model&&this.model.dispose()}}e.ObjectDetection=a,e.load=async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(null==n)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const t=e.base||"lite_mobilenet_v2",r=e.modelUrl;if(-1===["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(t))throw new Error(`ObjectDetection constructed with invalid base model ${t}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const s=new a(t,r);return await s.load(),s},e.version="2.2.3",Object.defineProperty(e,"__esModule",{value:!0})}(t,n(5452),n(5743))},5452:(e,t,n)=>{"use strict";n.r(t),n.d(t,{GraphModel:()=>qe,deregisterOp:()=>E,loadGraphModel:()=>Ke,loadGraphModelSync:()=>Ye,registerOp:()=>C,version_converter:()=>Xe});var r={};n.r(r),n.d(r,{json:()=>L});var a={};n.r(a),n.d(a,{json:()=>z});var s={};n.r(s),n.d(s,{json:()=>B});var i={};n.r(i),n.d(i,{json:()=>V});var o={};n.r(o),n.d(o,{json:()=>W});var l={};n.r(l),n.d(l,{json:()=>U});var u={};n.r(u),n.d(u,{json:()=>j});var c={};n.r(c),n.d(c,{json:()=>G});var d={};n.r(d),n.d(d,{json:()=>H});var h={};n.r(h),n.d(h,{json:()=>q});var p={};n.r(p),n.d(p,{json:()=>K});var f={};n.r(f),n.d(f,{json:()=>Y});var m={};n.r(m),n.d(m,{json:()=>X});var g={};n.r(g),n.d(g,{json:()=>Q});var y={};n.r(y),n.d(y,{json:()=>Z});var b={};n.r(b),n.d(b,{json:()=>J});var v={};n.r(v),n.d(v,{json:()=>ee});var x={};n.r(x),n.d(x,{json:()=>te});var w={};n.r(w),n.d(w,{json:()=>ne});var k={};n.r(k),n.d(k,{OP_SCOPE_SUFFIX:()=>ve.BTT,abs:()=>ve.tnl,acos:()=>ve.HQu,acosh:()=>ve.FqL,add:()=>ve.WQq,addN:()=>ve.QiD,all:()=>ve.Q7R,any:()=>ve.bzn,argMax:()=>ve.FLi,argMin:()=>ve.XRg,asin:()=>ve.qRo,asinh:()=>ve.yHs,atan:()=>ve.rYl,atan2:()=>ve.FPz,atanh:()=>ve.rfv,avgPool:()=>ve.$jT,avgPool3d:()=>ve.sub,basicLSTMCell:()=>ve.lZX,batchNorm:()=>ve.$v7,batchNorm2d:()=>ve.BFc,batchNorm3d:()=>ve.kSi,batchNorm4d:()=>ve.T5N,batchToSpaceND:()=>ve.GTe,bincount:()=>ve.HbZ,bitwiseAnd:()=>ve.vjT,booleanMaskAsync:()=>ve.ftb,broadcastArgs:()=>ve.ROE,broadcastTo:()=>ve.hOW,buffer:()=>ve.ra8,cast:()=>ve.wgE,ceil:()=>ve.mkO,clipByValue:()=>ve.zQh,clone:()=>ve.o8B,complex:()=>ve.faB,concat:()=>ve.xWs,concat1d:()=>ve.I1m,concat2d:()=>ve.RPU,concat3d:()=>ve.O5O,concat4d:()=>ve.P1l,conv1d:()=>ve.kA9,conv2d:()=>ve.Xtf,conv2dTranspose:()=>ve.wX9,conv3d:()=>ve.IPL,conv3dTranspose:()=>ve.jIJ,cos:()=>ve.gnS,cosh:()=>ve.yIG,cosineWindow:()=>ve._jP,cumprod:()=>ve.Lp0,cumsum:()=>ve.rCv,denseBincount:()=>ve.aOp,depthToSpace:()=>ve.Rj8,depthwiseConv2d:()=>ve.Gl3,diag:()=>ve.smy,dilation2d:()=>ve.X7t,div:()=>ve.y4m,divNoNan:()=>ve.ek5,dot:()=>ve.Omf,dropout:()=>ve.EZY,einsum:()=>ve._3C,elu:()=>ve.Pqc,enclosingPowerOfTwo:()=>ve.FJY,ensureShape:()=>ve.QP2,equal:()=>ve.LCg,erf:()=>ve.Y12,euclideanNorm:()=>ve.p4S,exp:()=>ve.oNF,expandDims:()=>ve.UG6,expm1:()=>ve.IYd,eye:()=>ve.y5U,fft:()=>ve.hVP,fill:()=>ve.GSj,floor:()=>ve.RIf,floorDiv:()=>ve.wh_,fused:()=>ve.cZk,gather:()=>ve.kgh,gatherND:()=>ve.SY9,greater:()=>ve.rhj,greaterEqual:()=>ve.DQN,ifft:()=>ve.KGM,imag:()=>ve.ngS,image:()=>ve.Slp,inTopKAsync:()=>ve.U4u,irfft:()=>ve.ggX,isFinite:()=>ve.MIs,isInf:()=>ve.EN4,isNaN:()=>ve.yrW,leakyRelu:()=>ve.H8d,less:()=>ve.M7h,lessEqual:()=>ve.InN,linalg:()=>ve.mPL,linspace:()=>ve.mT8,localResponseNormalization:()=>ve.Kgs,log:()=>ve.Rm2,log1p:()=>ve.Kko,logSigmoid:()=>ve.nqI,logSoftmax:()=>ve.HPB,logSumExp:()=>ve.VZ,logicalAnd:()=>ve.n76,logicalNot:()=>ve.NSZ,logicalOr:()=>ve.ztW,logicalXor:()=>ve.rxB,losses:()=>ve.YYh,lowerBound:()=>ve.yzS,matMul:()=>ve.NoW,max:()=>ve.T9B,maxPool:()=>ve.jgi,maxPool3d:()=>ve.NYV,maxPoolWithArgmax:()=>ve.RO,maximum:()=>ve.PhQ,mean:()=>ve.i2o,meshgrid:()=>ve.OYQ,min:()=>ve.jkA,minimum:()=>ve.BpO,mirrorPad:()=>ve.FFZ,mod:()=>ve.ziu,moments:()=>ve.Clk,movingAverage:()=>ve.CRk,mul:()=>ve.lKK,multiRNNCell:()=>ve.YDF,multinomial:()=>ve.OjQ,neg:()=>ve.HZy,norm:()=>ve.xbf,notEqual:()=>ve.Ec,oneHot:()=>ve.Mw0,ones:()=>ve.SaS,onesLike:()=>ve.P61,op:()=>ve.op,outerProduct:()=>ve.X4o,pad:()=>ve.eVF,pad1d:()=>ve.BZs,pad2d:()=>ve.grY,pad3d:()=>ve.XHu,pad4d:()=>ve.WLX,pool:()=>ve.dzn,pow:()=>ve.n7C,prelu:()=>ve.NsG,print:()=>ve.yyV,prod:()=>ve._eU,raggedGather:()=>ve.whe,raggedRange:()=>ve.iyU,raggedTensorToTensor:()=>ve.Q0_,rand:()=>ve._9M,randomGamma:()=>ve.pR9,randomNormal:()=>ve.FE$,randomStandardNormal:()=>ve.m0H,randomUniform:()=>ve.YeY,randomUniformInt:()=>ve.HYA,range:()=>ve.y17,real:()=>ve.xav,reciprocal:()=>ve.VOZ,relu:()=>ve.VVh,relu6:()=>ve.j__,reshape:()=>ve.tQQ,reverse:()=>ve.BEg,reverse1d:()=>ve.QD2,reverse2d:()=>ve.LMr,reverse3d:()=>ve.I2l,reverse4d:()=>ve.JYU,rfft:()=>ve.z8$,round:()=>ve.LIG,rsqrt:()=>ve.Z$r,scalar:()=>ve.d_2,scatterND:()=>ve.NFr,searchSorted:()=>ve.sZg,selu:()=>ve.WfX,separableConv2d:()=>ve.wdz,setdiff1dAsync:()=>ve.F12,sigmoid:()=>ve.ry7,sign:()=>ve._SZ,signal:()=>ve.vPA,sin:()=>ve.F8e,sinh:()=>ve.L0l,slice:()=>ve.dik,slice1d:()=>ve.Q$M,slice2d:()=>ve.zAd,slice3d:()=>ve.wck,slice4d:()=>ve.R0O,softmax:()=>ve.Vs9,softplus:()=>ve.lw0,spaceToBatchND:()=>ve.eDJ,sparse:()=>ve.lMo,sparseToDense:()=>ve.Zhr,spectral:()=>ve.lOn,split:()=>ve.lDo,sqrt:()=>ve.RZD,square:()=>ve.EwI,squaredDifference:()=>ve.Pbu,squeeze:()=>ve.r2V,stack:()=>ve.t$z,step:()=>ve.PMw,stridedSlice:()=>ve.Ym9,string:()=>ve.YjP,sub:()=>ve.jbE,sum:()=>ve.czq,tan:()=>ve.Mlm,tanh:()=>ve.ymU,tensor:()=>ve.OEK,tensor1d:()=>ve.tGX,tensor2d:()=>ve.KtR,tensor3d:()=>ve.$_$,tensor4d:()=>ve.g9W,tensor5d:()=>ve.Lpo,tensor6d:()=>ve.yxw,tensorScatterUpdate:()=>ve.NNh,tile:()=>ve.Vsq,topk:()=>ve.rfw,transpose:()=>ve.mgz,truncatedNormal:()=>ve.efE,unique:()=>ve.AmM,unsortedSegmentSum:()=>ve.zAU,unstack:()=>ve.K$i,upperBound:()=>ve.rni,variable:()=>ve.bvq,where:()=>ve._M9,whereAsync:()=>ve.YJN,zeros:()=>ve.Ul9,zerosLike:()=>ve.POl});var S=n(5743);var I,T;(0,S.env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(I||(I={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(T||(T={}));const N={};function C(e,t){const n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};N[e]=n}function A(e){return N[e]}function E(e){delete N[e]}function _(e,t,n,r,a){const s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){const e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return $(t.inputNames[o],n,r,a);if("tensors"===s.type){const s=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=s[t])||void 0===n?void 0:n.op)})).map((e=>$(e,n,r,a)))}const l=$(t.inputNames[o],n,r,a),u=l.dataSync();return"number"===s.type?u[0]:S.util.toNestedArray(l.shape,u)}const i=t.attrParams[e];return i&&i.value}function $(e,t,n,r){const[a,s]=F(e,n);if(null!=r){const e=r.getHashTableHandleByName(a);if(null!=e)return e}const i=n.currentContextIds.find((e=>!!t[M(a,e)]));return void 0!==i?t[M(a,i)][s]:void 0}function R(e,t,n){return t[M(e,n.currentContextId)]}function D(e,t){const[n,r,a]=F(e,t);return[M(n,t&&t.currentContextId),r,a]}function M(e,t){return t?`${e}-${t}`:e}function F(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let a;if(1===r.length)a=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;a=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,a),a}function O(e,t,n){let r=_("pad",e,t,n);if("explicit"===r){r=_("explicitPaddings",e,t,n);const a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function P(e){return e.kept?e:(0,S.clone)(e)}const L=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],z=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],B=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],V=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],W=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],U=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],j=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],G=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],H=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],q=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],K=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Y=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],X=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Q=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Z=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],J=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],ee=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],te=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],ne=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class re{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[r,a,s,i,o,l,u,c,d,h,p,f,m,g,y,b,v,x,w].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,r=[],a=[],s=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e)),{});let o=[];const l=[];let u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(i);d.forEach((e=>{const t=i[e];t.inputNames.forEach(((e,n)=>{const[r,,a]=D(e),s=i[r];if(null!=s.outputs){const e=s.outputs.indexOf(a);if(-1!==e){const a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{const t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{const[t]=D(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{const[t]=D(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:h};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=A(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let a;switch(n.type){case"string":a=se(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=se(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":a=me(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=me(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":a=oe(e.attr,n.tfName,n.defaultValue||0),void 0===a&&n.tfDeprecatedName&&(a=oe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":a=fe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=fe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":a=ie(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=ie(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":a=ye(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=ye(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":a=pe(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=pe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":a=ge(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=ge(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":a=ce(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=ce(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":a=de(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=de(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":a=ue(e.attr,n.tfName,n.defaultValue),void 0===a&&n.tfDeprecatedName&&(a=ue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:a,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const a=[],s=[];e.signature.inputArg.forEach((e=>{const[t]=D(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:le(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,a.push(n),r[t]=n}));Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[a,,s]=D(e),i=r[a];if(null!=i.outputs){const e=i.outputs.indexOf(s);if(-1!==e){const r=`${a}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));const i=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=D(i[e.name]),a=r[t];null!=a&&(a.defaultOutput=n,s.push(a))}));const o=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:s,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function ae(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=(0,S.env)().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function se(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e[t];return null!=a?ae(a.s,r):n}function ie(e,t,n){const r=e[t];return r?r.b:n}function oe(e,t,n){const r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"===typeof a?a:parseInt(a,10)}function le(e){switch("string"===typeof e&&(e=I[e]),e){case I.DT_FLOAT:case I.DT_HALF:return"float32";case I.DT_INT32:case I.DT_INT64:case I.DT_INT8:case I.DT_UINT8:return"int32";case I.DT_BOOL:return"bool";case I.DT_DOUBLE:return"float32";case I.DT_STRING:return"string";case I.DT_COMPLEX64:case I.DT_COMPLEX128:return"complex64";default:return null}}function ue(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function ce(e,t,n){const r=e[t];return r&&r.type?le(r.type):n}function de(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>le(e))):n}function he(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function pe(e,t,n){const r=e[t];return r&&r.shape?he(r.shape):n}function fe(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function me(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>ae(e,r))):n}function ge(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>he(e))):n}function ye(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class be{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return $(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return $(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return oe(this.node.rawAttrs,e,t);if(null!=n.s)return se(this.node.rawAttrs,e,t);if(null!=n.b)return ie(this.node.rawAttrs,e,t);if(null!=n.shape)return pe(this.node.rawAttrs,e,t);if(null!=n.type)return ce(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return fe(this.node.rawAttrs,e,t);if(null!=n.list.s)return me(this.node.rawAttrs,e,t);if(null!=n.list.shape)return ge(this.node.rawAttrs,e,t);if(null!=n.list.b)return ye(this.node.rawAttrs,e,t);if(null!=n.list.type)return de(this.node.rawAttrs,e,t)}return t}}var ve=n(9249);function xe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){S.util.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const a=e[r],s=t[r];S.util.assert(a<0||s<0||a===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function we(e){return"number"!==typeof e&&!e.some((e=>e<0))}function ke(e,t,n){let r=Se(e,n);const a=!we(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=Se(e.shape,r)})),!we(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Se(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}class Ie{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=(0,S.scalar)(0),(0,S.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),xe(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,(0,S.keep)(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return(0,S.tensor)([],[0].concat(this.elementShape));const n=this.readMany(e);return xe(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),(0,S.stack)(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return(0,S.tensor)([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return xe(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),(0,S.concat)(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,(0,S.unstack)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=0===n?0:t.size/n,s=[];(0,S.tidy)((()=>{t=(0,S.reshape)(t,[1,n,a]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],a];s[n]=(0,S.reshape)((0,S.slice)(t,i,o),this.elementShape)}return s}));const i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}}class Te{get id(){return this.idTensor.id}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);xe(t,e.shape,"TensorList shape mismatch: "),(0,S.keep)(e)})),this.idTensor=(0,S.scalar)(0),this.maxNumElements=r,(0,S.keep)(this.idTensor)}copy(){return new Te([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);xe(e,this.elementShape,"TensorList shape mismatch: ");const r=ke(this.elementShape,this.tensors,e);return(0,S.tidy)((()=>{const e=this.tensors.map((e=>(0,S.reshape)(e,r)));return(0,S.stack)(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=ke(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,xe(r.shape,e,"TensorList shape mismatch: "),(0,S.reshape)(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(xe(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,S.keep)(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Te([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);xe(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=ke(this.elementShape,this.tensors,t);return(0,S.reshape)(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);xe(this.elementShape,t.shape,"TensorList shape mismatch: "),(0,S.keep)(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);xe(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=ke(this.elementShape,this.tensors,n);return 0===e.length?(0,S.tensor)([],[0].concat(r)):(0,S.tidy)((()=>{const t=e.map((e=>(0,S.reshape)(this.tensors[e],r)));return(0,S.stack)(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);xe(this.elementShape,t,"TensorList shape mismatch: ");const n=ke(this.elementShape,this.tensors,t);return 0===this.size()?(0,S.tensor)([],[0].concat(n)):(0,S.tidy)((()=>{const e=this.tensors.map((e=>(0,S.reshape)(e,n)));return(0,S.concat)(e,0)}))}}const Ne=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=_("thenBranch",e,t,n),a=_("elseBranch",e,t,n),s=_("cond",e,t,n),i=_("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=_("body",e,t,n),a=_("cond",e,t,n),s=_("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map((e=>e.id));let l=await i[0].data();i.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let u=s;for(;l[0];){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return u}case"LoopCond":return[P(_("pred",e,t,n))];case"Switch":{const r=_("pred",e,t,n);let a=_("data",e,t,n);return a.kept||(a=P(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==$(e,t,n)));if(r){return[P($(r,t,n))]}return}case"Enter":{const r=_("frameName",e,t,n),a=_("tensor",e,t,n);return n.enterFrame(r),[P(a)]}case"Exit":{const r=_("tensor",e,t,n);return n.exitFrame(),[P(r)]}case"NextIteration":{const r=_("tensor",e,t,n);return n.nextIteration(),[P(r)]}case"TensorArrayV3":{const r=_("size",e,t,n),a=_("dtype",e,t,n),s=_("elementShape",e,t,n),i=_("dynamicSize",e,t,n),o=_("clearAfterRead",e,t,n),l=_("identicalElementShapes",e,t,n),u=_("name",e,t,n),c=new Ie(u,a,r,s,l,i,o);return n.addTensorArray(c),[c.idTensor,(0,S.scalar)(1)]}case"TensorArrayWriteV3":{const r=_("tensorArrayId",e,t,n),a=_("index",e,t,n),s=_("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{const r=_("tensorArrayId",e,t,n),a=_("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{const r=_("tensorArrayId",e,t,n),a=_("indices",e,t,n),s=_("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{const r=_("tensorArrayId",e,t,n),a=_("indices",e,t,n),s=_("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{const r=_("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=_("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{const r=_("tensorArrayId",e,t,n),a=_("tensor",e,t,n),s=_("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{const r=_("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return[(0,S.scalar)(a.size(),"int32")]}case"TensorArrayCloseV3":{const r=_("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{const r=_("tensorListId",e,t,n),a=_("index",e,t,n),s=_("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{const r=_("tensorListId",e,t,n),a=_("index",e,t,n),s=_("elementShape",e,t,n),i=_("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=_("indices",e,t,n),a=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);const s=new Te([],n,e.dtype,r),i=(0,S.unstack)(e,0);return t.forEach(((e,t)=>{s.setItem(e,i[t])})),s}(_("tensor",e,t,n),r,_("elementShape",e,t,n),_("numElements",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=_("elementShape",e,t,n),a=_("elementDType",e,t,n);let s;s="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=_(s,e,t,n),o=function(e,t,n,r){return new Te([],e,t,r)}(r,a,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=_("tensorListId",e,t,n),a=_("indices",e,t,n),s=_("elementShape",e,t,n),i=_("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{const r=_("tensorListId",e,t,n),a=_("elementShape",e,t,n),s=_("elementDType",e,t,n),i=_("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);xe(e.shape.slice(1),t,"TensorList shape mismatch: ");const a=(0,S.unstack)(e);return new Te(a,t,r)}(_("tensor",e,t,n),_("elementShape",e,t,n),_("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=_("tensorListId",e,t,n),a=n.getTensorList(r.id),s=_("dtype",e,t,n),i=_("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{const r=_("tensorListId",e,t,n),a=_("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{const r=_("tensorListId",e,t,n),a=_("elementShape",e,t,n),s=_("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{const r=_("tensor",e,t,n),a=_("elementShape",e,t,n),s=function(e,t,n){let r=0;const a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const s=Se(e.shape.slice(1),n),i=0===r?0:e.size/r,o=(0,S.tidy)((()=>{const n=[];e=(0,S.reshape)(e,[1,r,i]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:a[r-1],0],l=[1,t[r],i];n[r]=(0,S.reshape)((0,S.slice)(e,o,l),s)}return e.dispose(),n})),l=new Te([],n,e.dtype,t.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(r,_("lengths",e,t,n),a);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{const r=_("tensorListId",e,t,n),a=n.getTensorList(r.id);return[(0,S.scalar)(a.size(),"int32")]}case"TensorListResize":{const r=_("tensorListId",e,t,n),a=_("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Ce(e,t,n){const[r,a]=_("fusedOps",e,t,n),s="biasadd"===r,i=!s,o="prelu"===a,l="fusedbatchnorm"===r,u=_("numArgs",e,t,n);if(s){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=_("strides",e,t,n),d=O(e,t,n),h=_("dataFormat",e,t,n).toUpperCase(),p=_("dilations",e,t,n);let[f,m]=_("args",e,t,n);i&&(m=f,f=void 0);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:_("leakyreluAlpha",e,t,n)}}function Ae(e,t,n){return{boxes:_("boxes",e,t,n),scores:_("scores",e,t,n),maxOutputSize:_("maxOutputSize",e,t,n),iouThreshold:_("iouThreshold",e,t,n),scoreThreshold:_("scoreThreshold",e,t,n),softNmsSigma:_("softNmsSigma",e,t,n)}}var Ee=n(1997);class _e{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=(0,S.scalar)(0),this.tensorMap=new Map,(0,S.keep)(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ee.d(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),(0,S.tidy)((()=>{const e=(0,S.unstack)(t),r=n.length,a=e.length;S.util.assert(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){const r=n[t],a=e[t];(0,S.keep)(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return(0,S.tidy)((()=>{const e=[];for(let r=0;r<n.length;r++){const a=n[r],s=this.findWithDefault(a,t);e.push(s)}return(0,S.stack)(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function $e(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:S.tidy;const s=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(_("a",e,t,n),_("b",e,t,n))];case"AddN":return[r.addN(_("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(_("a",e,t,n),_("b",e,t,n))];case"Mul":return[r.mul(_("a",e,t,n),_("b",e,t,n))];case"RealDiv":case"Div":return[r.div(_("a",e,t,n),_("b",e,t,n))];case"DivNoNan":return[r.divNoNan(_("a",e,t,n),_("b",e,t,n))];case"FloorDiv":return[r.floorDiv(_("a",e,t,n),_("b",e,t,n))];case"Sub":return[r.sub(_("a",e,t,n),_("b",e,t,n))];case"Minimum":return[r.minimum(_("a",e,t,n),_("b",e,t,n))];case"Maximum":return[r.maximum(_("a",e,t,n),_("b",e,t,n))];case"Pow":return[r.pow(_("a",e,t,n),_("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(_("a",e,t,n),_("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"basic_math":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(_("x",e,t,n))];case"Acos":return[r.acos(_("x",e,t,n))];case"Acosh":return[r.acosh(_("x",e,t,n))];case"Asin":return[r.asin(_("x",e,t,n))];case"Asinh":return[r.asinh(_("x",e,t,n))];case"Atan":return[r.atan(_("x",e,t,n))];case"Atan2":return[r.atan2(_("x",e,t,n),_("y",e,t,n))];case"Atanh":return[r.atanh(_("x",e,t,n))];case"Ceil":return[r.ceil(_("x",e,t,n))];case"Complex":return[r.complex(_("real",e,t,n),_("imag",e,t,n))];case"Cos":return[r.cos(_("x",e,t,n))];case"Cosh":return[r.cosh(_("x",e,t,n))];case"Elu":return[r.elu(_("x",e,t,n))];case"Erf":return[r.erf(_("x",e,t,n))];case"Exp":return[r.exp(_("x",e,t,n))];case"Expm1":return[r.expm1(_("x",e,t,n))];case"Floor":return[r.floor(_("x",e,t,n))];case"Log":return[r.log(_("x",e,t,n))];case"Log1p":return[r.log1p(_("x",e,t,n))];case"Imag":return[r.imag(_("x",e,t,n))];case"Neg":return[r.neg(_("x",e,t,n))];case"Reciprocal":return[r.reciprocal(_("x",e,t,n))];case"Real":return[r.real(_("x",e,t,n))];case"Relu":return[r.relu(_("x",e,t,n))];case"Round":return[r.round(_("x",e,t,n))];case"Selu":return[r.selu(_("x",e,t,n))];case"Sigmoid":return[r.sigmoid(_("x",e,t,n))];case"Sin":return[r.sin(_("x",e,t,n))];case"Sign":return[r.sign(_("x",e,t,n))];case"Sinh":return[r.sinh(_("x",e,t,n))];case"Softplus":return[r.softplus(_("x",e,t,n))];case"Sqrt":return[r.sqrt(_("x",e,t,n))];case"Square":return[r.square(_("x",e,t,n))];case"Tanh":return[r.tanh(_("x",e,t,n))];case"Tan":return[r.tan(_("x",e,t,n))];case"ClipByValue":return[r.clipByValue(_("x",e,t,n),_("clipValueMin",e,t,n),_("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(_("x",e,t,n))];case"Rsqrt":return[r.rsqrt($(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(_("x",e,t,n),_("alpha",e,t,n))];case"Prelu":return[r.prelu(_("x",e,t,n),_("alpha",e,t,n))];case"IsNan":return[r.isNaN($(e.inputNames[0],t,n))];case"IsInf":return[r.isInf($(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite($(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"control":return Ne(e,t,n);case"convolution":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"Conv1D":{const a=_("stride",e,t,n),s=_("pad",e,t,n),i=_("dataFormat",e,t,n).toUpperCase(),o=_("dilation",e,t,n);return[r.conv1d(_("x",e,t,n),_("filter",e,t,n),a,s,i,o)]}case"Conv2D":{const a=_("strides",e,t,n),s=O(e,t,n),i=_("dataFormat",e,t,n).toUpperCase(),o=_("dilations",e,t,n);return[r.conv2d(_("x",e,t,n),_("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=Ce(e,t,n);return[r.fused.conv2d({x:_("x",e,t,n),filter:_("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=Ce(e,t,n);return[r.fused.depthwiseConv2d({x:_("x",e,t,n),filter:_("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=_("outputShape",e,t,n),s=_("strides",e,t,n),i=O(e,t,n);return[r.conv2dTranspose(_("x",e,t,n),_("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=_("strides",e,t,n),s=O(e,t,n),i=_("dilations",e,t,n),o=_("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(_("input",e,t,n),_("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{const a=_("strides",e,t,n),s=_("pad",e,t,n),i=_("dataFormat",e,t,n).toUpperCase(),o=_("dilations",e,t,n);return[r.conv3d(_("x",e,t,n),_("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{const a=_("strides",e,t,n),s=_("pad",e,t,n),i=_("kernelSize",e,t,n);return[r.avgPool(_("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{const a=_("strides",e,t,n),s=_("pad",e,t,n),i=_("kernelSize",e,t,n);return[r.maxPool(_("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{const a=_("strides",e,t,n),s=_("pad",e,t,n),i=_("kernelSize",e,t,n),o=_("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(_("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,u]}case"AvgPool3D":{const a=_("strides",e,t,n),s=_("pad",e,t,n),i=_("kernelSize",e,t,n);return[r.avgPool3d(_("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{const a=_("strides",e,t,n),s=_("pad",e,t,n),i=_("kernelSize",e,t,n);return[r.maxPool3d(_("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{const a=_("strides",e,t,n),s=_("pad",e,t,n),i=_("dilations",e,t,n),o=a[1],l=a[2],u=i[1],c=i[2];return[r.dilation2d(_("x",e,t,n),_("filter",e,t,n),[o,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"creation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"Fill":{const a=_("shape",e,t,n),s=_("dtype",e,t,n),i=_("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{const a=_("start",e,t,n),s=_("stop",e,t,n),i=_("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{const a=_("logits",e,t,n),s=_("numSamples",e,t,n),i=_("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{const a=_("indices",e,t,n),s=_("depth",e,t,n),i=_("onValue",e,t,n),o=_("offValue",e,t,n),l=_("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(_("shape",e,t,n),_("dtype",e,t,n))];case"OnesLike":return[r.onesLike(_("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(_("shape",e,t,n),_("dtype",e,t,n),_("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(_("shape",e,t,n),_("minval",e,t,n),_("maxval",e,t,n),_("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(_("shape",e,t,n),_("minval",e,t,n),_("maxval",e,t,n),_("seed",e,t,n))];case"Range":{const a=_("start",e,t,n),s=_("stop",e,t,n),i=_("step",e,t,n);return[r.range(a,s,i,_("dtype",e,t,n))]}case"TruncatedNormal":{const a=_("shape",e,t,n),s=_("mean",e,t,n),i=_("stdDev",e,t,n),o=_("seed",e,t,n);return[r.truncatedNormal(a,s,i,_("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(_("shape",e,t,n),_("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(_("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"dynamic":return async function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:k;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=Ae(e,t,n),c=await a.image.nonMaxSuppressionWithScoreAsync(r,s,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=Ae(e,t,n),u=_("padToMaxOutputSize",e,t,n),c=await a.image.nonMaxSuppressionPaddedAsync(r,s,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=Ae(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,s,i,o,l)]}case"Where":{const r=a.cast(_("condition",e,t,n),"bool"),s=[await a.whereAsync(r)];return r.dispose(),s}case"ListDiff":return a.setdiff1dAsync(_("x",e,t,n),_("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n);case"evaluation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"LowerBound":{const a=_("sortedSequence",e,t,n),s=_("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{const a=_("x",e,t,n),s=_("k",e,t,n),i=_("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{const a=_("sortedSequence",e,t,n),s=_("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{const a=_("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{const a=_("x",e,t,n),s=_("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"image":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"ResizeBilinear":{const a=_("images",e,t,n),s=_("size",e,t,n),i=_("alignCorners",e,t,n),o=_("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{const a=_("images",e,t,n),s=_("size",e,t,n),i=_("alignCorners",e,t,n),o=_("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{const a=_("image",e,t,n),s=_("boxes",e,t,n),i=_("boxInd",e,t,n),o=_("cropSize",e,t,n),l=_("method",e,t,n),u=_("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{const a=_("images",e,t,n),s=_("transforms",e,t,n),i=_("outputShape",e,t,n),o=_("fillValue",e,t,n),l=_("interpolation",e,t,n),u=_("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"graph":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const a=_("default",e,t,n);return[$(e.name,t,n)||a];case"Placeholder":return[$(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[P(_("x",e,t,n))];case"IdentityN":return _("x",e,t,n).map((e=>P(e)));case"Shape":return[r.tensor1d(_("x",e,t,n).shape,"int32")];case"ShapeN":return _("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(_("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(_("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const s=_("x",e,t,n),i=_("data",e,t,n),o=_("message",e,t,n),l=_("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"logical":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"Equal":return[r.equal(_("a",e,t,n),_("b",e,t,n))];case"NotEqual":return[r.notEqual(_("a",e,t,n),_("b",e,t,n))];case"Greater":return[r.greater(_("a",e,t,n),_("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(_("a",e,t,n),_("b",e,t,n))];case"Less":return[r.less(_("a",e,t,n),_("b",e,t,n))];case"LessEqual":return[r.lessEqual(_("a",e,t,n),_("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(_("a",e,t,n),_("b",e,t,n))];case"LogicalNot":return[r.logicalNot(_("a",e,t,n))];case"LogicalOr":return[r.logicalOr(_("a",e,t,n),_("b",e,t,n))];case"Select":case"SelectV2":return[r.where(_("condition",e,t,n),_("a",e,t,n),_("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(_("a",e,t,n),_("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"matrices":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(_("a",e,t,n),_("b",e,t,n),_("transposeA",e,t,n),_("transposeB",e,t,n))];case"Einsum":return[r.einsum(_("equation",e,t,n),..._("tensors",e,t,n))];case"Transpose":return[r.transpose(_("x",e,t,n),_("perm",e,t,n))];case"_FusedMatMul":const[a,s]=_("fusedOps",e,t,n),i="biasadd"===a,o="prelu"===s,l=_("numArgs",e,t,n),u=_("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=_("args",e,t,n);return[r.fused.matMul({a:_("a",e,t,n),b:_("b",e,t,n),transposeA:_("transposeA",e,t,n),transposeB:_("transposeB",e,t,n),bias:c,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(_("a",e,t,n),_("numLower",e,t,n),_("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"normalization":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(_("x",e,t,n),_("axis",e,t,n),_("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(_("x",e,t,n),_("mean",e,t,n),_("variance",e,t,n),_("offset",e,t,n),_("scale",e,t,n),_("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(_("x",e,t,n),_("radius",e,t,n),_("bias",e,t,n),_("alpha",e,t,n),_("beta",e,t,n))];case"Softmax":return[r.softmax(_("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(_("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"ragged":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"RaggedGather":{const{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(_("paramsNestedSplits",e,t,n),_("paramsDenseValues",e,t,n),_("indices",e,t,n),_("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{const{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(_("starts",e,t,n),_("limits",e,t,n),_("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(_("shape",e,t,n),_("values",e,t,n),_("defaultValue",e,t,n),_("rowPartitionTensors",e,t,n),_("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"reduction":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"Max":{const a=_("axis",e,t,n),s=_("keepDims",e,t,n);return[r.max(_("x",e,t,n),a,s)]}case"Mean":{const a=_("axis",e,t,n),s=_("keepDims",e,t,n);return[r.mean(_("x",e,t,n),a,s)]}case"Min":{const a=_("axis",e,t,n),s=_("keepDims",e,t,n);return[r.min(_("x",e,t,n),a,s)]}case"Sum":{const a=_("axis",e,t,n),s=_("keepDims",e,t,n);return[r.sum(_("x",e,t,n),a,s)]}case"All":{const a=_("axis",e,t,n),s=_("keepDims",e,t,n);return[r.all(_("x",e,t,n),a,s)]}case"Any":{const a=_("axis",e,t,n),s=_("keepDims",e,t,n);return[r.any(_("x",e,t,n),a,s)]}case"ArgMax":{const a=_("axis",e,t,n);return[r.argMax(_("x",e,t,n),a)]}case"ArgMin":{const a=_("axis",e,t,n);return[r.argMin(_("x",e,t,n),a)]}case"Prod":{const a=_("axis",e,t,n),s=_("keepDims",e,t,n);return[r.prod(_("x",e,t,n),a,s)]}case"Cumprod":{const a=_("axis",e,t,n),s=_("exclusive",e,t,n),i=_("reverse",e,t,n);return[r.cumprod(_("x",e,t,n),a,s,i)]}case"Cumsum":{const a=_("axis",e,t,n),s=_("exclusive",e,t,n),i=_("reverse",e,t,n);return[r.cumsum(_("x",e,t,n),a,s,i)]}case"Bincount":const a=_("x",e,t,n),s=_("weights",e,t,n),i=_("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{const a=_("x",e,t,n),s=_("weights",e,t,n),i=_("size",e,t,n),o=_("binaryOutput",e,t,n);return[r.denseBincount(a,s,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"slice_join":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"ConcatV2":case"Concat":{const a=_("n",e,t,n),s=_("axis",e,t,n);let i=_("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{const a=_("x",e,t,n),s=_("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{const a=_("axis",e,t,n),s=_("batchDims",e,t,n),i=_("x",e,t,n),o=_("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{const a=_("dims",e,t,n),s=[];for(let e=0;e<a.length;e++)a[e]&&s.push(e);const i=_("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{const a=_("axis",e,t,n),s=_("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{const a=_("begin",e,t,n),s=_("size",e,t,n);return[r.slice(_("x",e,t,n),a,s)]}case"StridedSlice":{const a=_("begin",e,t,n),s=_("end",e,t,n),i=_("strides",e,t,n),o=_("beginMask",e,t,n),l=_("endMask",e,t,n),u=_("ellipsisMask",e,t,n),c=_("newAxisMask",e,t,n),d=_("shrinkAxisMask",e,t,n),h=_("x",e,t,n);return[r.stridedSlice(h,a,s,i,o,l,u,c,d)]}case"Pack":return(0,S.tidy)((()=>{const a=_("axis",e,t,n),s=_("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map((e=>{const t=S.util.arraysEqual(e.shape,i);if(!t&&!S.util.arraysEqual(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,a)]}));case"Unpack":{const a=_("axis",e,t,n),s=_("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{const a=_("reps",e,t,n);return[r.tile(_("x",e,t,n),a)]}case"Split":case"SplitV":{const a=_("axis",e,t,n),s=_("numOrSizeSplits",e,t,n),i=_("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{const a=_("indices",e,t,n),s=_("values",e,t,n),i=_("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{const a=_("x",e,t,n),s=_("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{const a=_("sparseIndices",e,t,n),s=_("outputShape",e,t,n),i=_("sparseValues",e,t,n),o=_("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const a=_("indices",e,t,n),s=_("values",e,t,n),i=_("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"sparse":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(_("indices",e,t,n),_("values",e,t,n),_("denseShape",e,t,n),_("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{const{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(_("inputIndices",e,t,n),_("inputShape",e,t,n),_("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(_("data",e,t,n),_("indices",e,t,n),_("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(_("data",e,t,n),_("indices",e,t,n),_("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"spectral":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"FFT":return[r.fft(_("x",e,t,n))];case"IFFT":return[r.ifft(_("x",e,t,n))];case"RFFT":return[r.rfft(_("x",e,t,n))];case"IRFFT":return[r.irfft(_("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"string":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(_("input",e,t,n),_("pattern",e,t,n),_("rewrite",e,t,n),_("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(_("data",e,t,n),_("dataSplits",e,t,n),_("separator",e,t,n),_("nGramWidths",e,t,n),_("leftPad",e,t,n),_("rightPad",e,t,n),_("padWidth",e,t,n),_("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{const{indices:a,values:s,shape:i}=r.string.stringSplit(_("input",e,t,n),_("delimiter",e,t,n),_("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(_("input",e,t,n),_("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"transformation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:k;switch(e.op){case"Cast":return[r.cast(_("x",e,t,n),_("dtype",e,t,n))];case"ExpandDims":{const a=_("axis",e,t,n);return[r.expandDims(_("x",e,t,n),a)]}case"Squeeze":{const a=_("axis",e,t,n);return[r.squeeze(_("x",e,t,n),a)]}case"Reshape":return[r.reshape(_("x",e,t,n),_("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(_("x",e,t,n),_("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(_("x",e,t,n),_("padding",e,t,n),_("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(_("x",e,t,n),_("padding",e,t,n),_("constantValue",e,t,n))];case"SpaceToBatchND":{const a=_("blockShape",e,t,n),s=_("paddings",e,t,n);return[r.spaceToBatchND(_("x",e,t,n),a,s)]}case"BatchToSpaceND":{const a=_("blockShape",e,t,n),s=_("crops",e,t,n);return[r.batchToSpaceND(_("x",e,t,n),a,s)]}case"DepthToSpace":{const a=_("blockSize",e,t,n),s=_("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(_("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(_("x",e,t,n),_("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(_("s0",e,t,n),_("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const a=r.getHashTableHandleByName(e.name);if(null!=a)return[a];{const a=_("keyDType",e,t,n),s=_("valueDType",e,t,n),i=new _e(a,s);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const a=_("tableHandle",e,t,n,r),s=_("keys",e,t,n),i=_("values",e,t,n),o=r.getHashTableById(a.id);return[await o.import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{const a=_("tableHandle",e,t,n,r),s=_("keys",e,t,n),i=_("defaultValue",e,t,n),o=r.getHashTableById(a.id);return[await o.find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const a=_("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const s=A(e.op);if(s&&s.customExecutor)return s.customExecutor(new be(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return S.util.isPromise(s)?s.then((e=>[].concat(e))):[].concat(s)}class Re{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function De(e,t,n,r){const a=new Set,s=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(e).map((e=>F(e)[0])));r=r||[];const c=new Set(r.map((e=>F(e.name)[0]))),d=[...t];for(;d.length>0;){const e=d.pop();(ze(e)||Be(e)||Ve(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&(u.has(e.name)||c.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))})):s.push(e.name)))}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function Me(e,t){const{usedNodes:n,inputs:r}=t,a=Object.keys(r).map((e=>F(e)[0])).map((t=>e.nodes[t])),s=e.initNodes||[],i=e=>n.has("string"===typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const l=o([...a,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map((e=>[e.name,e]))),d={};for(const m of u){d[m.name]=d[m.name]||0;for(const e of m.children)i(e)||(d[e.name]=Number.POSITIVE_INFINITY),d[e.name]=(d[e.name]||0)+1}const h=Object.entries(d).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...h];for(;h.length>0;){const e=h.pop(),t=c.get(e);for(const n of t.children.filter(i))0===--d[n.name]&&(p.push(n.name),h.push(n.name))}const f=function(e,t){const n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),a=new Set(r);for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const s of t.children)n.has(s.name)&&!a.has(s.name)&&(a.add(s.name),r.push(s.name))}const s=e.filter((e=>a.has(e.name)));return s}(p.map((e=>c.get(e))),l);return function(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),a=e=>r.has("string"===typeof e?e:e.name),s=new Set(e.map((e=>e.name))),i=e=>s.has("string"===typeof e?e:e.name);for(const o of e){for(const e of o.children.filter(i)){if(!n.has(e.name))throw new Fe(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new Fe(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!a(o))for(const e of o.inputs){if(!n.has(e.name))throw new Fe(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new Fe(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}class Fe extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}const Oe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Pe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Le=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function ze(e){return Oe.has(e.op)}function Be(e){return Pe.has(e.op)}function Ve(e){return Le.has(e.op)}class We{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new We(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=De(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){const n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}const i=Me(this.graph,n),o=function(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>ze(e)?n:t)),a=e=>{const n=r[t.get(e.name)];return null==n?-1:n},s=e.map(((e,t)=>e.children.map(a).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){const t=s[o];if(t===n)continue;const r=e[o],a=e[t];i.has(a.name)||i.set(a.name,[]),i.get(a.name).push(r)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return(0,S.keep)(t),t}cloneTensorList(e){if(!e)return null;return e.map((e=>this.cloneAndKeepTensor(e)))}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[F(e)[0]])),a=t.map((e=>F(e)[0])),s=new Set(a);let i=a.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=(0,S.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const u={},c={};return(0,S.tidy)((()=>{const n=new Re(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[a,s]=F(t,n),i=[];i[s]=e[t],r[a]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(i))}));const a=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(const e of i){if(r[e.name])continue;const t=$e(e,r,n,this._resourceManager);if(S.util.isPromise(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,a,s,o.get(e.name))}return null==this.parent&&n.dispose(a),t.map((e=>$(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,i){if(!ze(t)&&!s.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if(ze(e))continue;const t=R(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||a.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,a,s){function i(e){return ze(e)||a.has(e.name)}if(!ze(e)&&null!=s)for(const o of s){if(i(o))continue;const e=R(o.name,t,n);for(const t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=(0,S.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const s=new Re(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,s,t,n),o=t.map((e=>$(e,i,s))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()}))})),null==this.parent&&s.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const a=Object.keys(e),s=a.map((e=>this.graph.nodes[F(e)[0]])),i=n.map((e=>F(e)[0])),o=new Set(i);let l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:h}=De(e,l,this.weightMap,this._initNodes),p=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=F(t),a=[];a[r]=e[t],f[n]=a}));const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=this.processStack(s,p,t,f,y,g,o,m,u);await Promise.all(e)}null!=d||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter((e=>!ze(e)&&!$(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,a,s,i,o,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&_("isConstant",e.node,r,n)&&([c]=D(e.node.name,n)),null==r[e.node.name]){const d=$e(e.node,r,n,this._resourceManager);c||([c]=D(e.node.name,n));const h=n.currentContext;S.util.isPromise(d)?u.push(d.then((u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=h,this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{const[i]=D(e.name,n);!a[i]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!$(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!$(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=F(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const e=a.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));S.util.assert(t,(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&S.util.assert(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;const r={};for(const a in e){const s=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[a];null!=s?r[s.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=F(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=F(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class Ue{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}var je=n(285);const Ge="?tfjs-format=file",He="model.json";class qe{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:S.io;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new Ue}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return S.util.isPromise(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await(0,je.s5)(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new We(re.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=re.Instance.transformGraph(e.modelInitializer);this.initializer=new We(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof S.Tensor?[e]:e,n={};return t.forEach(((e,t)=>n[this.structuredOutputKeys[t]]=e)),n}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof S.Tensor)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var a,s,i;const o=null===(i=null===(s=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===s?void 0:s[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const a=t[n[r]];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,S.dispose)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Ke(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:S.io;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"===typeof e&&(e=function(e){e.endsWith("/")||(e+="/");return`${e}${He}${Ge}`}(e));const r=new qe(e,t,n);return await r.load(),r}function Ye(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){const[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");const a=S.io.getWeightSpecs(n.weightsManifest),s=S.io.getModelArtifactsForJSONSync(n,a,r);t=S.io.fromMemorySync(s)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=S.io.fromMemorySync(e)}const n=new qe(t);return n.load(),n}const Xe="4.20.0"},6790:(e,t,n)=>{"use strict";n.d(t,{GJ:()=>r,uI:()=>a});class r{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class a{refCount(e){return s("refCount")}incRef(e){return s("incRef")}timerAvailable(){return!0}time(e){return s("time")}read(e){return s("read")}readSync(e){return s("readSync")}readToGPU(e,t){return s("readToGPU")}numDataIds(){return s("numDataIds")}disposeData(e,t){return s("disposeData")}write(e,t,n){return s("write")}move(e,t,n,r,a){return s("move")}createTensorFromGPUData(e,t,n){return s("createTensorFromGPUData")}memory(){return s("memory")}floatPrecision(){return s("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return s("dispose")}}function s(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},6692:(e,t,n)=>{"use strict";function r(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);const o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}(e,t,n||a)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function a(e,t){return e>t?1:e<t?-1:0}function s(e,t,n,r,a){return l(e,t,n,r,a,0)}function i(e,t,n,r,a,s){return l(e,t,n,r,a,0,!1,s,!0)}function o(e,t,n,r,a,s){return l(e,t,n,r,a,s,!0)}function l(e,t,n,a,s,i){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],l=arguments.length>7&&void 0!==arguments[7]&&arguments[7],h=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const p=[];for(let r=0;r<t.length;r++)t[r]>s&&p.push({score:t[r],boxIndex:r,suppressBeginIndex:0});p.sort(d);const f=i>0?-.5/i:0,m=[],g=[];for(;m.length<n&&p.length>0;){const t=p.pop(),{score:n,boxIndex:i,suppressBeginIndex:o}=t;if(n<s)break;let l=!1;for(let r=m.length-1;r>=o;--r){const n=u(e,i,m[r]);if(n>=a){l=!0;break}if(t.score=t.score*c(a,f,n),t.score<=s)break}t.suppressBeginIndex=m.length,l||(t.score===n?(m.push(i),g.push(t.score)):t.score>s&&r(p,t,d))}const y=m.length,b=n-y;l&&b>0&&(m.push(...new Array(b).fill(0)),g.push(...new Array(b).fill(0)));const v={selectedIndices:m};return o&&(v.selectedScores=g),h&&(v.validOutputs=y),v}function u(e,t,n){const r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),h=Math.max(a[1],a[3]),p=(o-s)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(s,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function c(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function d(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}n.d(t,{c7:()=>s,ZS:()=>i,ut:()=>o})},9286:(e,t,n)=>{"use strict";n.d(t,{Y:()=>a});var r=n(259);function a(e,t){const n=[];for(let r=0;r<t.length;r++)t[r]&&n.push(r);const a=(0,r.r)(e,"int32"),s=(0,r.r)([n.length,e.length],"int32");for(let r=0;r<n.length;r++){const t=a.indexToLoc(n[r]),i=r*e.length;s.values.set(t,i)}return s.toTensor()}},2164:(e,t,n)=>{"use strict";n.d(t,{T2:()=>x,Ye:()=>v});var r=n(6790),a=n(5399),s=n(7926),i=n(9554),o=n(843),l=n(4124),u=n(8977),c=n(1426);class d{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new p)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let i;const o=u.now();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();i=Promise.resolve({kernelMs:u.now()-o})}if((0,a._K)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let a=0;a<r.length;a++){const t=r[a];t.data().then((n=>{h(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:i.then((e=>e.kernelMs)),extraInfo:i.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}}function h(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class p{logKernelProfile(e,t,n,r,a,s){const i="number"===typeof r?c.av(`${r}ms`,9):r.error,o=c.av(e,25),l=t.rank,u=t.size,d=c.av(t.shape.toString(),14);let h="";for(const c in a){const e=a[c];if(null!=e){const n=e.shape||t.shape,r=n.length;h+=`${c}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${d}\t%c${u}\t%c${h}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var f=n(9494),m=n(8804);function g(e){return null!=e.kernelName}class y{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class b{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new y}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(l.i(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new d(this.backendInstance),!0}setupRegisteredKernels(){(0,o.Op)(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){(0,o.Op)(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof r.uI||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,l.i(`Initialization of backend ${e} failed`),l.i(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return l.i(`Initialization of backend ${e} failed`),l.i(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return b.nextTensorId++}nextVariableId(){return b.nextVariableId++}clone(e){const t=x.runKernel(i.lzr,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return x.runKernel(i.KXH,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=(0,o._5)(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),a=this.state.numBytes,s=this.state.numTensors;let i,l;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=g(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(g(e)){const{kernelName:t,inputs:a,attrs:s}=e;null==this.backendName&&this.backend;const u=(0,o._5)(t,this.backendName);c.vA(null!=u,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();l=u.kernelFunc({inputs:a,attrs:s,backend:this.backend});const i=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const o=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,a,o);n=this.saveTensorsForBackwardMode(e)}return o}}else{const{forwardFunc:t}=e,a=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();l=this.tidy((()=>t(this.backend,a)));const n=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:d,attrs:h}=e,p=g(e)?null:e.backwardsFunc;let f;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(u,d,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs):t=i()})),r&&this.addTapeNode(u,d,t,p,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map((e=>null!=d[e]?d[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=(0,o.vQ)(e);if(null!=r){const e=r.inputsToSave||[],a=r.outputsToSave||[];let s;r.saveAllInputs?(c.vA(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const i=n.filter(((e,t)=>a[t]));return s.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&c.Kg(e[0])&&(a=e.map((e=>u.encodeString(e))));const s=r.write(a,t,n),i=new f.qY(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(s),t=(0,c.SL)(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:a}=e,s=new f.qY(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const a=new f.rT(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*c.jv(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof f.rT||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*c.jv(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},l=(0,o.vQ)(e);null!=l&&(r=l.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=c.Ty(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=(0,m.getTensorsInContainer)(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){const e=this.state.activeScope.track[a];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(c.vA(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));c.vA(a instanceof f.qY,(()=>"The result y returned by f() must be a tensor."));const s=function(e,t,n){const r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const n=e[l],s=n.inputs;for(const e in s){const i=s[e];let o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[n.id]=!0;break}if(o)break}}const s={};s[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(const e in n)s[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const t=e[l];if(a[t.id]&&i[t.id]){const e={};for(const a in t.inputs){const n=t.inputs[a];r[n.id]&&(e[a]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[a.id]=null==n?function(e){const t=(0,c.FZ)((0,c.Ze)(e),"float32");return x.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){const s=t[a],i=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(i);for(const t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);const i=s.inputs[t];if(!c.r1(a.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{const t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}(e,s,(e=>this.tidy(e)),w);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){var t=this;return c.vA(c.Tn(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];let s;c.vA(r.every((e=>e instanceof f.qY)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(s=e(...r,n),c.vA(s.value instanceof f.qY,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),c.vA(c.Tn(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(e,t)=>{const n=s.gradFunc(e,t),a=Array.isArray(n)?n:[n];c.vA(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),c.vA(a.every((e=>e instanceof f.qY)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=(0,u.now)(),n=await this.backend.time(e);return n.wallMs=(0,u.now)()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new y;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function v(){const e=(0,s.L)();if(null==e._tfengine){const t=new a.OH(e);e._tfengine=new b(t)}return(0,a.tj)(e._tfengine.ENV),(0,f.qP)((()=>e._tfengine)),e._tfengine}b.nextTensorId=0,b.nextVariableId=0;const x=v();function w(e,t){const n={a:e,b:t};return x.runKernel(i.OMN,n)}},5399:(e,t,n)=>{"use strict";n.d(t,{Km:()=>l,OH:()=>s,_K:()=>o,tj:()=>u});var r=n(1426);const a="tfjsflags";class s{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=i,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(o().getBool("IS_TEST")||o().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];o().getBool("IS_TEST")||o().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if((0,r.yL)(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(a in e){e[a].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}}function i(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function o(){return l}let l=null;function u(e){l=e}},7926:(e,t,n)=>{"use strict";let r;function a(){if(null==r){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}r=e}return r}function s(e,t){const n=function(){const e=a();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}n.d(t,{L:()=>a,m:()=>s})},8046:(e,t,n)=>{"use strict";n.d(t,{AS:()=>g,DZ:()=>m,Gc:()=>x,Hi:()=>h,Hs:()=>N,IS:()=>u,ME:()=>f,Ok:()=>C,Sm:()=>o,W4:()=>I,aC:()=>y,fL:()=>c,gJ:()=>T,gY:()=>l,go:()=>S,jh:()=>v,jz:()=>w,kB:()=>b,m1:()=>p,rE:()=>k,rm:()=>d});var r=n(2164),a=n(5399),s=n(9494),i=n(8804);function o(){(0,a._K)().set("PROD",!0)}function l(){(0,a._K)().set("DEBUG",!0)}function u(){(0,a._K)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function c(e){(0,a._K)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function d(){r.T2.disposeVariables()}function h(){return r.T2}function p(){return r.T2.memory()}function f(e){return r.T2.profile(e)}function m(e,t){return r.T2.tidy(e,t)}function g(e){(0,i.getTensorsInContainer)(e).forEach((e=>e.dispose()))}function y(e){return r.T2.keep(e)}function b(e){return r.T2.time(e)}function v(e){return r.T2.setBackend(e)}function x(){return r.T2.ready()}function w(){return r.T2.backendName}function k(e){r.T2.removeBackend(e)}function S(e){return r.T2.findBackend(e)}function I(e){return r.T2.findBackendFactory(e)}function T(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return r.T2.registerBackend(e,t,n)}function N(){return r.T2.backend}function C(e,t){(0,a._K)().setPlatform(e,t)}(0,s.B4)(c)},1839:(e,t,n)=>{"use strict";n.d(t,{Dv:()=>o,_X:()=>h,jY:()=>u,mu:()=>c,ok:()=>l,y7:()=>d});var r=n(2164),a=n(9494),s=n(4148),i=n(1426);function o(e){return i.vA(i.Tn(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{const a=(0,s.YT)(t,"x","tf.grad","string_or_numeric"),o=null!=n?(0,s.YT)(n,"dy","tf.grad"):null;return r.T2.tidy((()=>{const{value:t,grads:n}=r.T2.gradients((()=>e(a)),[a],o);return null!=o&&i.O3(t.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),p(n),n[0]}))}}function l(e){return i.vA(i.Tn(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{i.vA(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const a=(0,s.j1)(t,"args","tf.grads","string_or_numeric"),o=null!=n?(0,s.YT)(n,"dy","tf.grads"):null;return r.T2.tidy((()=>{const{value:t,grads:n}=r.T2.gradients((()=>e(...a)),a,o);return null!=o&&i.O3(t.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),p(n),n}))}}function u(e){return i.vA(i.Tn(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{i.vA(t instanceof a.qY,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),i.vA(null==n||n instanceof a.qY,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:s,value:o}=r.T2.gradients((()=>e(t)),[t],n);return p(s),{grad:s[0],value:o}}}function c(e){return i.vA(i.Tn(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{i.vA(Array.isArray(t)&&t.every((e=>e instanceof a.qY)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),i.vA(null==n||n instanceof a.qY,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const s=r.T2.gradients((()=>e(...t)),t,n);return null!=n&&i.O3(s.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),p(s.grads),s}}function d(e,t){i.vA(i.Tn(e),(()=>"The f passed in variableGrads(f) must be a function")),i.vA(null==t||Array.isArray(t)&&t.every((e=>e instanceof a.rT)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in r.T2.registeredVariables)t.push(r.T2.registeredVariables[e])}const s=n?t.filter((e=>!e.trainable)):null,o=t.length;t=t.filter((e=>e.trainable)),i.vA(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`));const{value:l,grads:u}=r.T2.gradients(e,t,null,!0);i.vA(u.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),i.vA(0===l.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${l.rank} tensor`));const c={};return t.forEach(((e,t)=>{null!=u[t]&&(c[e.name]=u[t])})),null!=s&&s.forEach((e=>c[e.name]=null)),{value:l,grads:c}}function h(e){return r.T2.customGrad(e)}function p(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},5743:(e,t,n)=>{"use strict";n.r(t),n.d(t,{Abs:()=>yt.ljI,Acos:()=>yt.Vvy,Acosh:()=>yt.PH8,AdadeltaOptimizer:()=>_e,AdagradOptimizer:()=>Re,AdamOptimizer:()=>Fe,AdamaxOptimizer:()=>Le,Add:()=>yt.OMN,AddN:()=>yt.EkD,All:()=>yt.u8Z,Any:()=>yt.FSt,ArgMax:()=>yt.Jp_,ArgMin:()=>yt.p_m,Asin:()=>yt.QKF,Asinh:()=>yt.epO,Atan:()=>yt.TyE,Atan2:()=>yt.lxb,Atanh:()=>yt.zP9,AvgPool:()=>yt.ho8,AvgPool3D:()=>yt.cS,AvgPool3DGrad:()=>yt.wwC,AvgPoolGrad:()=>yt.VCH,BatchMatMul:()=>yt.jAQ,BatchToSpaceND:()=>yt.Ik2,Bincount:()=>yt.N4F,BitwiseAnd:()=>yt.HNs,BroadcastArgs:()=>yt.vj7,BroadcastTo:()=>yt.LB5,Cast:()=>yt.KXH,Ceil:()=>yt.QDP,ClipByValue:()=>yt.vaV,Complex:()=>yt.pr3,ComplexAbs:()=>yt.$zE,Concat:()=>yt.$dB,Conv2D:()=>yt.p2J,Conv2DBackpropFilter:()=>yt.rFm,Conv2DBackpropInput:()=>yt.jfg,Conv3D:()=>yt.A1h,Conv3DBackpropFilterV2:()=>yt.iGz,Conv3DBackpropInputV2:()=>yt.gC7,Cos:()=>yt.Mn0,Cosh:()=>yt.MnK,CropAndResize:()=>yt.MRQ,Cumprod:()=>yt.jj_,Cumsum:()=>yt.nY8,DataStorage:()=>pr.GJ,DenseBincount:()=>yt.wNW,DepthToSpace:()=>yt.TMz,DepthwiseConv2dNative:()=>yt.tGH,DepthwiseConv2dNativeBackpropFilter:()=>yt.X$8,DepthwiseConv2dNativeBackpropInput:()=>yt.nVu,Diag:()=>yt.ORI,Dilation2D:()=>yt.jxD,Dilation2DBackpropFilter:()=>yt.pk0,Dilation2DBackpropInput:()=>yt.bP9,Draw:()=>yt.XmO,ENV:()=>b.Km,Einsum:()=>yt.Qgm,Elu:()=>yt.Pah,EluGrad:()=>yt.rsH,Environment:()=>b.OH,Equal:()=>yt.BRl,Erf:()=>yt._s9,Exp:()=>yt.ox3,ExpandDims:()=>yt.ybN,Expm1:()=>yt.ybj,FFT:()=>yt.rGP,Fill:()=>yt.SQl,FlipLeftRight:()=>yt.BxF,Floor:()=>yt.ZgB,FloorDiv:()=>yt.ElG,FromPixels:()=>yt.awo,FusedBatchNorm:()=>yt.i5R,FusedConv2D:()=>yt.aAr,FusedDepthwiseConv2D:()=>yt.T7M,GatherNd:()=>yt.O4G,GatherV2:()=>yt.mxL,Greater:()=>yt.XhZ,GreaterEqual:()=>yt.lLS,IFFT:()=>yt.OAQ,Identity:()=>yt.lzr,Imag:()=>yt.dv8,IsFinite:()=>yt.gIW,IsInf:()=>yt.E3$,IsNan:()=>yt.iPs,KernelBackend:()=>pr.uI,LRN:()=>yt.jM4,LRNGrad:()=>yt.ToN,LeakyRelu:()=>yt.X0$,Less:()=>yt.mIA,LessEqual:()=>yt.CwD,LinSpace:()=>yt.mnI,Log:()=>yt.tG8,Log1p:()=>yt.Cg$,LogSoftmax:()=>yt.zfU,LogicalAnd:()=>yt.RUm,LogicalNot:()=>yt.nZd,LogicalOr:()=>yt.LXA,LogicalXor:()=>yt.RW8,LowerBound:()=>yt.yPW,MatrixBandPart:()=>yt.WRv,Max:()=>yt.VAI,MaxPool:()=>yt.t3d,MaxPool3D:()=>yt.ySp,MaxPool3DGrad:()=>yt.cHb,MaxPoolGrad:()=>yt.RXX,MaxPoolWithArgmax:()=>yt.TL8,Maximum:()=>yt.LDN,Mean:()=>yt.g5A,Min:()=>yt.lNG,Minimum:()=>yt.LG0,MirrorPad:()=>yt.x7F,Mod:()=>yt.BLA,MomentumOptimizer:()=>Be,Multinomial:()=>yt.WT3,Multiply:()=>yt.xu7,Neg:()=>yt.l0G,NonMaxSuppressionV3:()=>yt.SDM,NonMaxSuppressionV4:()=>yt.Zl4,NonMaxSuppressionV5:()=>yt.e0f,NotEqual:()=>yt.ylV,OP_SCOPE_SUFFIX:()=>Qt.BTT,OneHot:()=>yt.urI,OnesLike:()=>yt.LWX,Optimizer:()=>Ee,OptimizerConstructors:()=>Yt,Pack:()=>yt.mM$,PadV2:()=>yt.ODT,Pool:()=>yt.bCz,Pow:()=>yt.pyJ,Prelu:()=>yt.Ncv,Prod:()=>yt.kdj,RMSPropOptimizer:()=>Ve,RaggedGather:()=>yt.oJ2,RaggedRange:()=>yt.CQC,RaggedTensorToTensor:()=>yt.mH5,Range:()=>yt.Q6t,Rank:()=>Xt.rg,Real:()=>yt.LRy,RealDiv:()=>yt.sDr,Reciprocal:()=>yt.huO,Reduction:()=>Zt.i,Relu:()=>yt.fUj,Relu6:()=>yt.P_L,Reshape:()=>yt.R23,ResizeBilinear:()=>yt.hgw,ResizeBilinearGrad:()=>yt.FCQ,ResizeNearestNeighbor:()=>yt.jOE,ResizeNearestNeighborGrad:()=>yt.XQy,Reverse:()=>yt.D7i,RotateWithOffset:()=>yt.BK4,Round:()=>yt.hVg,Rsqrt:()=>yt.TOR,SGDOptimizer:()=>ze,ScatterNd:()=>yt.pJc,SearchSorted:()=>yt.uWl,Select:()=>yt.l6P,Selu:()=>yt.u$b,Sigmoid:()=>yt.vI1,Sign:()=>yt.YVe,Sin:()=>yt.hql,Sinh:()=>yt.J3C,Slice:()=>yt.JiE,Softmax:()=>yt.rFG,Softplus:()=>yt.Fin,SpaceToBatchND:()=>yt.A8B,SparseFillEmptyRows:()=>yt.C8s,SparseReshape:()=>yt.BoJ,SparseSegmentMean:()=>yt.L6G,SparseSegmentSum:()=>yt.DvZ,SparseToDense:()=>yt.jgd,SplitV:()=>yt.Blb,Sqrt:()=>yt.dFH,Square:()=>yt.M6A,SquaredDifference:()=>yt.Ddj,StaticRegexReplace:()=>yt.GZp,Step:()=>yt.pnw,StridedSlice:()=>yt.UcO,StringNGrams:()=>yt.YAb,StringSplit:()=>yt.iW0,StringToHashBucketFast:()=>yt.$jE,Sub:()=>yt.PbM,Sum:()=>yt.WuN,Tan:()=>yt.oFs,Tanh:()=>yt.iuW,Tensor:()=>he.qY,TensorBuffer:()=>he.yl,TensorScatterUpdate:()=>yt.X4r,Tile:()=>yt.FAs,TopK:()=>yt.TBb,Transform:()=>yt.dLy,Transpose:()=>yt.wx0,Unique:()=>yt.EwU,Unpack:()=>yt.dXR,UnsortedSegmentSum:()=>yt.pPe,UpperBound:()=>yt.RMm,Variable:()=>he.rT,ZerosLike:()=>yt.xJ3,_FusedMatMul:()=>yt.Dr,abs:()=>Qt.tnl,acos:()=>Qt.HQu,acosh:()=>Qt.FqL,add:()=>Qt.WQq,addN:()=>Qt.QiD,all:()=>Qt.Q7R,any:()=>Qt.bzn,argMax:()=>Qt.FLi,argMin:()=>Qt.XRg,asin:()=>Qt.qRo,asinh:()=>Qt.yHs,atan:()=>Qt.rYl,atan2:()=>Qt.FPz,atanh:()=>Qt.rfv,avgPool:()=>Qt.$jT,avgPool3d:()=>Qt.sub,backend:()=>fe.Hs,backend_util:()=>d,basicLSTMCell:()=>Qt.lZX,batchNorm:()=>Qt.$v7,batchNorm2d:()=>Qt.BFc,batchNorm3d:()=>Qt.kSi,batchNorm4d:()=>Qt.T5N,batchToSpaceND:()=>Qt.GTe,bincount:()=>Qt.HbZ,bitwiseAnd:()=>Qt.vjT,booleanMaskAsync:()=>Qt.ftb,broadcastArgs:()=>Qt.ROE,broadcastTo:()=>Qt.hOW,broadcast_util:()=>gt,browser:()=>o,buffer:()=>Qt.ra8,cast:()=>Qt.wgE,ceil:()=>Qt.mkO,clipByValue:()=>Qt.zQh,clone:()=>Qt.o8B,complex:()=>Qt.faB,concat:()=>Qt.xWs,concat1d:()=>Qt.I1m,concat2d:()=>Qt.RPU,concat3d:()=>Qt.O5O,concat4d:()=>Qt.P1l,conv1d:()=>Qt.kA9,conv2d:()=>Qt.Xtf,conv2dTranspose:()=>Qt.wX9,conv3d:()=>Qt.IPL,conv3dTranspose:()=>Qt.jIJ,copyRegisteredKernels:()=>bt.Cf,cos:()=>Qt.gnS,cosh:()=>Qt.yIG,cosineWindow:()=>Qt._jP,cumprod:()=>Qt.Lp0,cumsum:()=>Qt.rCv,customGrad:()=>we._X,denseBincount:()=>Qt.aOp,deprecationWarn:()=>fe.fL,depthToSpace:()=>Qt.Rj8,depthwiseConv2d:()=>Qt.Gl3,device_util:()=>r,diag:()=>Qt.smy,dilation2d:()=>Qt.X7t,disableDeprecationWarnings:()=>fe.IS,dispose:()=>fe.AS,disposeVariables:()=>fe.rm,div:()=>Qt.y4m,divNoNan:()=>Qt.ek5,dot:()=>Qt.Omf,dropout:()=>Qt.EZY,einsum:()=>Qt._3C,elu:()=>Qt.Pqc,enableDebugMode:()=>fe.gY,enableProdMode:()=>fe.Sm,enclosingPowerOfTwo:()=>Qt.FJY,engine:()=>fe.Hi,ensureShape:()=>Qt.QP2,env:()=>b._K,equal:()=>Qt.LCg,erf:()=>Qt.Y12,euclideanNorm:()=>Qt.p4S,exp:()=>Qt.oNF,expandDims:()=>Qt.UG6,expm1:()=>Qt.IYd,eye:()=>Qt.y5U,fft:()=>Qt.hVP,fill:()=>Qt.GSj,findBackend:()=>fe.go,findBackendFactory:()=>fe.W4,floor:()=>Qt.RIf,floorDiv:()=>Qt.wh_,fused:()=>Qt.cZk,gather:()=>Qt.kgh,gatherND:()=>Qt.SY9,gather_util:()=>l,getBackend:()=>fe.jz,getGradient:()=>bt.vQ,getKernel:()=>bt._5,getKernelsForBackend:()=>bt.Op,grad:()=>we.Dv,grads:()=>we.ok,greater:()=>Qt.rhj,greaterEqual:()=>Qt.DQN,ifft:()=>Qt.KGM,imag:()=>Qt.ngS,image:()=>Qt.Slp,inTopKAsync:()=>Qt.U4u,io:()=>s,irfft:()=>Qt.ggX,isFinite:()=>Qt.MIs,isInf:()=>Qt.EN4,isNaN:()=>Qt.yrW,keep:()=>fe.aC,kernel_impls:()=>h,leakyRelu:()=>Qt.H8d,less:()=>Qt.M7h,lessEqual:()=>Qt.InN,linalg:()=>Qt.mPL,linspace:()=>Qt.mT8,localResponseNormalization:()=>Qt.Kgs,log:()=>Qt.Rm2,log1p:()=>Qt.Kko,logSigmoid:()=>Qt.nqI,logSoftmax:()=>Qt.HPB,logSumExp:()=>Qt.VZ,logicalAnd:()=>Qt.n76,logicalNot:()=>Qt.NSZ,logicalOr:()=>Qt.ztW,logicalXor:()=>Qt.rxB,losses:()=>Qt.YYh,lowerBound:()=>Qt.yzS,matMul:()=>Qt.NoW,math:()=>i,max:()=>Qt.T9B,maxPool:()=>Qt.jgi,maxPool3d:()=>Qt.NYV,maxPoolWithArgmax:()=>Qt.RO,maximum:()=>Qt.PhQ,mean:()=>Qt.i2o,memory:()=>fe.m1,meshgrid:()=>Qt.OYQ,min:()=>Qt.jkA,minimum:()=>Qt.BpO,mirrorPad:()=>Qt.FFZ,mod:()=>Qt.ziu,moments:()=>Qt.Clk,movingAverage:()=>Qt.CRk,mul:()=>Qt.lKK,multiRNNCell:()=>Qt.YDF,multinomial:()=>Qt.OjQ,neg:()=>Qt.HZy,nextFrame:()=>tn,norm:()=>Qt.xbf,notEqual:()=>Qt.Ec,oneHot:()=>Qt.Mw0,ones:()=>Qt.SaS,onesLike:()=>Qt.P61,op:()=>Qt.op,outerProduct:()=>Qt.X4o,pad:()=>Qt.eVF,pad1d:()=>Qt.BZs,pad2d:()=>Qt.grY,pad3d:()=>Qt.XHu,pad4d:()=>Qt.WLX,pool:()=>Qt.dzn,pow:()=>Qt.n7C,prelu:()=>Qt.NsG,print:()=>Qt.yyV,prod:()=>Qt._eU,profile:()=>fe.ME,raggedGather:()=>Qt.whe,raggedRange:()=>Qt.iyU,raggedTensorToTensor:()=>Qt.Q0_,rand:()=>Qt._9M,randomGamma:()=>Qt.pR9,randomNormal:()=>Qt.FE$,randomStandardNormal:()=>Qt.m0H,randomUniform:()=>Qt.YeY,randomUniformInt:()=>Qt.HYA,range:()=>Qt.y17,ready:()=>fe.Gc,real:()=>Qt.xav,reciprocal:()=>Qt.VOZ,registerBackend:()=>fe.gJ,registerGradient:()=>bt.kr,registerKernel:()=>bt.tA,relu:()=>Qt.VVh,relu6:()=>Qt.j__,removeBackend:()=>fe.rE,reshape:()=>Qt.tQQ,reverse:()=>Qt.BEg,reverse1d:()=>Qt.QD2,reverse2d:()=>Qt.LMr,reverse3d:()=>Qt.I2l,reverse4d:()=>Qt.JYU,rfft:()=>Qt.z8$,round:()=>Qt.LIG,rsqrt:()=>Qt.Z$r,scalar:()=>Qt.d_2,scatterND:()=>Qt.NFr,scatter_util:()=>_t,searchSorted:()=>Qt.sZg,selu:()=>Qt.WfX,separableConv2d:()=>Qt.wdz,serialization:()=>a,setBackend:()=>fe.jh,setPlatform:()=>fe.Ok,setdiff1dAsync:()=>Qt.F12,sigmoid:()=>Qt.ry7,sign:()=>Qt._SZ,signal:()=>Qt.vPA,sin:()=>Qt.F8e,sinh:()=>Qt.L0l,slice:()=>Qt.dik,slice1d:()=>Qt.Q$M,slice2d:()=>Qt.zAd,slice3d:()=>Qt.wck,slice4d:()=>Qt.R0O,slice_util:()=>$t,softmax:()=>Qt.Vs9,softplus:()=>Qt.lw0,spaceToBatchND:()=>Qt.eDJ,sparse:()=>Qt.lMo,sparseToDense:()=>Qt.Zhr,spectral:()=>Qt.lOn,split:()=>Qt.lDo,sqrt:()=>Qt.RZD,square:()=>Qt.EwI,squaredDifference:()=>Qt.Pbu,squeeze:()=>Qt.r2V,stack:()=>Qt.t$z,step:()=>Qt.PMw,stridedSlice:()=>Qt.Ym9,string:()=>Qt.YjP,sub:()=>Qt.jbE,sum:()=>Qt.czq,sumOutType:()=>Xt.ch,tan:()=>Qt.Mlm,tanh:()=>Qt.ymU,tensor:()=>Qt.OEK,tensor1d:()=>Qt.tGX,tensor2d:()=>Qt.KtR,tensor3d:()=>Qt.$_$,tensor4d:()=>Qt.g9W,tensor5d:()=>Qt.Lpo,tensor6d:()=>Qt.yxw,tensorScatterUpdate:()=>Qt.NNh,tensor_util:()=>Rt,test_util:()=>u,tidy:()=>fe.DZ,tile:()=>Qt.Vsq,time:()=>fe.kB,topk:()=>Qt.rfw,train:()=>Jt,transpose:()=>Qt.mgz,truncatedNormal:()=>Qt.efE,unique:()=>Qt.AmM,unregisterGradient:()=>bt.rY,unregisterKernel:()=>bt.iP,unsortedSegmentSum:()=>Qt.zAU,unstack:()=>Qt.K$i,upcastType:()=>Xt.Tu,upperBound:()=>Qt.rni,util:()=>Dt,valueAndGrad:()=>we.jY,valueAndGrads:()=>we.mu,variable:()=>Qt.bvq,variableGrads:()=>we.y7,version_core:()=>Kt,where:()=>Qt._M9,whereAsync:()=>Qt.YJN,zeros:()=>Qt.Ul9,zerosLike:()=>Qt.POl});var r={};n.r(r),n.d(r,{isBrowser:()=>y,isMobile:()=>g,mockIsMobile:()=>m});var a={};n.r(a),n.d(a,{Serializable:()=>Te,SerializationMap:()=>Ne,getRegisteredName:()=>Ae,registerClass:()=>Ce});var s={};n.r(s),n.d(s,{CompositeArrayBuffer:()=>N.D,browserFiles:()=>He,browserHTTPRequest:()=>nt,concatenateArrayBuffers:()=>x.AQ,copyModel:()=>te,decodeWeights:()=>x.CY,decodeWeightsStream:()=>x.s5,encodeWeights:()=>x.aG,fromMemory:()=>it,fromMemorySync:()=>ot,getLoadHandlers:()=>T,getModelArtifactsForJSON:()=>x.Ej,getModelArtifactsForJSONSync:()=>x.Rl,getModelArtifactsInfoForJSON:()=>x.oR,getSaveHandlers:()=>I,getWeightSpecs:()=>x.Xf,http:()=>tt,isHTTPScheme:()=>Je,listModels:()=>J,loadWeights:()=>Xe,moveModel:()=>ne,registerLoadRouter:()=>S,registerSaveRouter:()=>k,removeModel:()=>ee,weightsLoaderFactory:()=>Qe,withSaveHandler:()=>lt,withSaveHandlerSync:()=>ut});var i={};n.r(i),n.d(i,{confusionMatrix:()=>mt});var o={};n.r(o),n.d(o,{draw:()=>Ct,fromPixels:()=>At,fromPixelsAsync:()=>It,toPixels:()=>Nt});var l={};n.r(l),n.d(l,{prepareAndValidate:()=>Et});var u={};n.r(u),n.d(u,{TEST_EPSILON_FLOAT16:()=>Ft,createVideoElement:()=>Ht,encodeStrings:()=>Gt,expectArrayBuffersEqual:()=>jt,expectArraysClose:()=>Ot,expectArraysEqual:()=>Bt,expectNumbersClose:()=>Vt,expectPromiseToFail:()=>zt,expectValuesInRange:()=>Ut,play:()=>qt,testEpsilon:()=>Pt});var c={};n.r(c),n.d(c,{collectGatherOpShapeInfo:()=>lr,computeOutShape:()=>or,segOpComputeOptimalWindowSize:()=>ir});var d={};n.r(d),n.d(d,{ERF_A1:()=>Sn,ERF_A2:()=>In,ERF_A3:()=>Tn,ERF_A4:()=>Nn,ERF_A5:()=>Cn,ERF_P:()=>kn,PARALLELIZE_THRESHOLD:()=>pn,RowPartitionType:()=>sn,SELU_SCALE:()=>wn.X,SELU_SCALEALPHA:()=>wn.j,applyActivation:()=>ln.f2,assertAndGetBroadcastShape:()=>gt.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>nn.WC,assertParamsConsistent:()=>rn,assignToTypedArray:()=>Mn,axesAreInnerMostDims:()=>nn.WH,calculateShapes:()=>_t.calculateShapes,checkEinsumDimSizes:()=>Un,checkPadOnDimRoundingMode:()=>on.s_,combineLocations:()=>nn.aF,combineRaggedTensorToTensorShapes:()=>un,complexWithEvenIndex:()=>$n,complexWithOddIndex:()=>Rn,computeConv2DInfo:()=>on.uf,computeConv3DInfo:()=>on.p$,computeDefaultPad:()=>on.G8,computeDilation2DInfo:()=>on.YQ,computeOptimalWindowSize:()=>fn,computeOutAndReduceShapes:()=>nn.lb,computeOutShape:()=>an,computePool2DInfo:()=>on.E6,computePool3DInfo:()=>on.l5,convertConv2DDataFormat:()=>on.$Q,decodeEinsumEquation:()=>Vn,eitherStridesOrDilationsAreOne:()=>on.G0,expandShapeToKeepDim:()=>nn.SM,exponent:()=>On,exponents:()=>Fn,fromStringArrayToUint8:()=>cr,fromUint8ToStringArray:()=>ur,getAxesPermutation:()=>nn.Em,getBroadcastDims:()=>gt.getBroadcastDims,getComplexWithIndex:()=>Dn,getEinsumComputePath:()=>jn,getEinsumPermutation:()=>Wn,getFusedBiasGradient:()=>ln.Do,getFusedDyActivation:()=>ln.XB,getImageCenter:()=>mn,getInnerMostAxes:()=>nn.fK,getPermuted:()=>yn,getRaggedRank:()=>dn,getReductionAxes:()=>gt.getReductionAxes,getReshaped:()=>gn,getReshapedPermuted:()=>bn,getRowPartitionTypesHelper:()=>cn,getSliceBeginCoords:()=>vn,getSliceSize:()=>xn,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Kn,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Yn,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Xn,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Jn,getSparseReshapeInputOutputMismatchErrorMessage:()=>tr,getSparseReshapeInputOutputMultipleErrorMessage:()=>er,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Qn,getSparseReshapeNegativeOutputDimErrorMessage:()=>Zn,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>sr,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>nr,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>rr,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>ar,getUndoAxesPermutation:()=>nn.gx,isIdentityPermutation:()=>Gn,log:()=>An.R,mergeRealAndImagArrays:()=>En,prepareAndValidate:()=>Et,prepareSplitSize:()=>qn,segment_util:()=>c,shouldFuse:()=>ln.zE,slice_util:()=>$t,splitRealAndImagArrays:()=>_n,stridesOrDilationsArePositive:()=>on.qk,tupleValuesAreOne:()=>on.Dh,upcastType:()=>Xt.Tu,validateDefaultValueShape:()=>hn,validateInput:()=>_t.validateInput,validateUpdateShape:()=>_t.validateUpdateShape,warn:()=>An.i});var h={};n.r(h),n.d(h,{nonMaxSuppressionV3Impl:()=>dr.c7,nonMaxSuppressionV4Impl:()=>dr.ZS,nonMaxSuppressionV5Impl:()=>dr.ut,whereImpl:()=>hr.Y});var p=n(2164);let f;function m(e){f=e}function g(e){if(void 0!==f)return f;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function y(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}var b=n(5399);const v=(0,b._K)();v.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),v.registerFlag("IS_BROWSER",(()=>y())),v.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),v.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),v.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),v.registerFlag("PROD",(()=>!1)),v.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>v.getBool("DEBUG"))),v.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),v.registerFlag("IS_TEST",(()=>!1)),v.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>v.getBool("DEBUG"))),v.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),v.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),v.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));var x=n(285);class w{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==w.instance&&(w.instance=new w),w.instance}static registerSaveRouter(e){w.getInstance().saveRouters.push(e)}static registerLoadRouter(e){w.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return w.getHandlers(e,"save")}static getLoadHandlers(e,t){return w.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?w.getInstance().loadRouters:w.getInstance().saveRouters).forEach((t=>{const a=t(e,n);null!==a&&r.push(a)})),r}}const k=e=>w.registerSaveRouter(e),S=e=>w.registerLoadRouter(e),I=e=>w.getSaveHandlers(e),T=(e,t)=>w.getLoadHandlers(e,t);var N=n(7131);const C="tensorflowjs",A="models_store",E="model_info_store";function _(){if(!(0,b._K)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function $(e){const t=e.result;t.createObjectStore(A,{keyPath:"modelPath"}),t.createObjectStore(E,{keyPath:"modelPath"})}class R{constructor(e){if(this.indexedDB=_(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(C,1);r.onupgradeneeded=()=>$(r),r.onsuccess=()=>{const a=r.result;if(null==t){const t=a.transaction(A,"readonly"),r=t.objectStore(A).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=N.D.join(t.weightData);const r=(0,x.oR)(t),i=a.transaction(E,"readwrite");let o,l,u=i.objectStore(E);try{o=u.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(s){return n(s)}o.onsuccess=()=>{l=a.transaction(A,"readwrite");const o=l.objectStore(A);let c;try{c=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(s){return n(s)}c.onsuccess=()=>e({modelArtifactsInfo:r}),c.onerror=e=>{u=i.objectStore(E);const t=u.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(c.error)),t.onerror=e=>(a.close(),n(c.error))}},o.onerror=e=>(a.close(),n(o.error)),i.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}}R.URL_SCHEME="indexeddb://";const D=e=>{return(0,b._K)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(R.URL_SCHEME)?(t=e.slice(R.URL_SCHEME.length),new R(t)):null;var t};w.registerSaveRouter(D),w.registerLoadRouter(D);class M{constructor(){this.indexedDB=_()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(C,1);n.onupgradeneeded=()=>$(n),n.onsuccess=()=>{const r=n.result,a=r.transaction(E,"readonly"),s=a.objectStore(E).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(R.URL_SCHEME)?t.slice(R.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(C,1);r.onupgradeneeded=()=>$(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(E,"readwrite"),i=s.objectStore(E),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return a.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),s=()=>{l=a.transaction(A,"readwrite");const r=l.objectStore(A).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=s,r.onerror=e=>(s(),a.close(),n(o.error))}},o.onerror=e=>(a.close(),n(o.error)),s.oncomplete=()=>{null==l?a.close():l.oncomplete=()=>a.close()}},r.onerror=e=>n(r.error)}))}}var F=n(1426);const O="/",P="tensorflowjs_models",L="info",z="model_topology",B="weight_specs",V="weight_data",W="model_metadata";function U(e){return{info:[P,e,L].join(O),topology:[P,e,z].join(O),weightSpecs:[P,e,B].join(O),weightData:[P,e,V].join(O),modelMetadata:[P,e,W].join(O)}}function j(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function G(e){const t=e.split(O);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(O)}class H{constructor(e){if(!(0,b._K)().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=U(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=(0,x.oR)(e),s=N.D.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,(0,x.l3)(s));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw j(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){const e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=(0,x.jf)(s),t}}H.URL_SCHEME="localstorage://";const q=e=>{return(0,b._K)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(H.URL_SCHEME)?(t=e.slice(H.URL_SCHEME.length),new H(t)):null;var t};w.registerSaveRouter(q),w.registerLoadRouter(q);class K{constructor(){(0,F.vA)((0,b._K)().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),(0,F.vA)("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=P+O,n=O+L;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){e[G(a)]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){var t;const n=U(e=(t=e).startsWith(H.URL_SCHEME)?t.slice(H.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return j(n),r}}const Y="://";class X{constructor(){this.managers={}}static getInstance(){return null==X.instance&&(X.instance=new X),X.instance}static registerManager(e,t){(0,F.vA)(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Y)&&(e=e.slice(0,e.indexOf(Y))),(0,F.vA)(e.length>0,(()=>"scheme must not be an empty string."));const n=X.getInstance();(0,F.vA)(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=X.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(X.getInstance().managers)}}function Q(e){if(-1===e.indexOf(Y))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${X.getSchemes().join(",")}`);return{scheme:e.split(Y)[0],path:e.split(Y)[1]}}async function Z(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];(0,F.vA)(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=w.getLoadHandlers(e);(0,F.vA)(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),(0,F.vA)(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const a=r[0],s=w.getSaveHandlers(t);(0,F.vA)(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),(0,F.vA)(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const i=s[0],o=Q(e).scheme,l=Q(e).path,u=o===Q(e).scheme,c=await a.load();n&&u&&await X.getManager(o).removeModel(l);const d=await i.save(c);return n&&!u&&await X.getManager(o).removeModel(l),d.modelArtifactsInfo}async function J(){const e=X.getSchemes(),t={};for(const n of e){const e=await X.getManager(n).listModels();for(const r in e){t[n+Y+r]=e[r]}}return t}async function ee(e){const t=Q(e);return X.getManager(t.scheme).removeModel(t.path)}async function te(e,t){return Z(e,t,!1)}async function ne(e,t){return Z(e,t,!0)}var re=n(5767);class ae{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&(0,b._K)().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return(0,re.Y)(e)}}if((0,b._K)().get("IS_BROWSER")){(0,b._K)().setPlatform("browser",new ae);try{X.registerManager(H.URL_SCHEME,new K)}catch(fr){}try{X.registerManager(R.URL_SCHEME,new M)}catch(fr){}}const se=()=>n(5817);let ie;class oe{constructor(){this.util=n(8590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=(0,b._K)().global.fetch?(0,b._K)().global.fetch(e,t):(null==ie&&(ie=se()),ie(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}(0,b._K)().get("IS_NODE")&&!(0,b._K)().get("IS_BROWSER")&&(0,b._K)().setPlatform("node",new oe);var le=n(259),ue=n(7794),ce=n(9820),de=n(6574),he=n(9494);(0,p.Ye)();const pe={buffer:le.r,cast:ue.w,clone:ce.o,print:de.y};(0,he.Q5)(pe);var fe=n(8046),me=n(7242),ge=n(4974),ye=n(803),be=n(191),ve=n(7738),xe=n(3290),we=n(1839),ke=n(1997);const Se=new Map,Ie=new Map;class Te{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Ne{constructor(){this.classNameMap={}}static getMap(){return null==Ne.instance&&(Ne.instance=new Ne),Ne.instance}static register(e){Ne.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Ce(e,t,n){(0,F.vA)(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),(0,F.vA)("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),(0,F.vA)(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const r=t+">"+n;return Ne.register(e),Se.set(r,e),Ie.set(e,r),e}function Ae(e){return Ie.has(e)?Ie.get(e):e.className}class Ee extends Te{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return(0,fe.AS)(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return(0,we.y7)(e,t)}dispose(){null!=this.iterations_&&(0,fe.AS)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,ke.d)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Ee,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class _e extends Ee{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=p.T2.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.T2.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:(0,fe.DZ)((()=>(0,xe.P)(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:(0,fe.DZ)((()=>(0,xe.P)(r).variable(a)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;(0,fe.DZ)((()=>{const e=(0,me.W)((0,ye.l)(i,this.rho),(0,ye.l)((0,ve.E)(s),1-this.rho)),t=(0,ye.l)((0,ge.y)((0,be.R)((0,me.W)(o,this.epsilon)),(0,be.R)((0,me.W)(i,this.epsilon))),s),n=(0,me.W)((0,ye.l)(o,this.rho),(0,ye.l)((0,ve.E)(t),1-this.rho));i.assign(e),o.assign(n);const a=(0,me.W)((0,ye.l)(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,fe.AS)(this.accumulatedGrads.map((e=>e.variable))),(0,fe.AS)(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}var $e=n(4660);class Re extends Ee{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.T2.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:(0,fe.DZ)((()=>(0,$e.G)(r.shape,this.initialAccumulatorValue).variable(e)))}}const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const s=this.accumulatedGrads[n].variable;(0,fe.DZ)((()=>{const e=(0,me.W)(s,(0,ve.E)(a));s.assign(e);const t=(0,me.W)((0,ye.l)((0,ge.y)(a,(0,be.R)((0,me.W)(e,p.T2.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,fe.AS)(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}var De=n(7587),Me=n(7951);class Fe extends Ee{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,fe.DZ)((()=>{this.accBeta1=(0,ke.d)(t).variable(),this.accBeta2=(0,ke.d)(n).variable()})),null==r&&(this.epsilon=p.T2.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,fe.DZ)((()=>{const n=(0,Me.j)(1,this.accBeta1),r=(0,Me.j)(1,this.accBeta2);t.forEach(((t,a)=>{const s=p.T2.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:(0,fe.DZ)((()=>(0,xe.P)(s).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:(0,fe.DZ)((()=>(0,xe.P)(s).variable(i)))});const o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,c=(0,me.W)((0,ye.l)(l,this.beta1),(0,ye.l)(o,1-this.beta1)),d=(0,me.W)((0,ye.l)(u,this.beta2),(0,ye.l)((0,ve.E)(o),1-this.beta2)),h=(0,ge.y)(c,n),f=(0,ge.y)(d,r);l.assign(c),u.assign(d);const m=(0,me.W)((0,ye.l)((0,ge.y)(h,(0,me.W)((0,be.R)(f),this.epsilon)),-this.learningRate),s);s.assign(m)})),this.accBeta1.assign((0,ye.l)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,ye.l)(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,fe.AS)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&(0,fe.AS)(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),(0,fe.DZ)((()=>{this.accBeta1.assign((0,De.n)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,De.n)(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}var Oe=n(3753),Pe=n(2131);class Le extends Ee{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,fe.DZ)((()=>{this.iteration=(0,ke.d)(0).variable(),this.accBeta1=(0,ke.d)(t).variable()})),null==r&&(this.epsilon=p.T2.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);(0,fe.DZ)((()=>{const n=(0,Me.j)(1,this.accBeta1),r=(0,ge.y)(-this.learningRate,(0,me.W)((0,ye.l)(this.iteration,this.decay),1));t.forEach(((t,a)=>{const s=p.T2.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:(0,xe.P)(s).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:(0,xe.P)(s).variable(i)});const o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,c=(0,me.W)((0,ye.l)(l,this.beta1),(0,ye.l)(o,1-this.beta1)),d=(0,ye.l)(u,this.beta2),h=(0,Oe.t)(o),f=(0,Pe.P)(d,h);l.assign(c),u.assign(f);const m=(0,me.W)((0,ye.l)((0,ge.y)(r,n),(0,ge.y)(c,(0,me.W)(f,this.epsilon))),s);s.assign(m)})),this.iteration.assign((0,me.W)(this.iteration,1)),this.accBeta1.assign((0,ye.l)(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,fe.AS)(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&(0,fe.AS)(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class ze extends Ee{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const a=p.T2.registeredVariables[t];(0,fe.DZ)((()=>{const e=(0,me.W)((0,ye.l)(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=(0,fe.aC)((0,ke.d)(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Be extends ze{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=(0,ke.d)(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.T2.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:(0,fe.DZ)((()=>(0,xe.P)(r).variable(e)))}}const a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&(0,fe.DZ)((()=>{let e;const t=(0,me.W)((0,ye.l)(this.m,a),s);e=this.useNesterov?(0,me.W)((0,ye.l)(this.c,(0,me.W)(s,(0,ye.l)(t,this.m))),r):(0,me.W)((0,ye.l)(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,fe.AS)(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Ve extends Ee{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=p.T2.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=p.T2.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:(0,fe.DZ)((()=>(0,xe.P)(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:(0,fe.DZ)((()=>(0,xe.P)(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:(0,fe.DZ)((()=>(0,xe.P)(r).variable(a)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;(0,fe.DZ)((()=>{const e=(0,me.W)((0,ye.l)(i,this.decay),(0,ye.l)((0,ve.E)(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,a=(0,me.W)((0,ye.l)(t,this.decay),(0,ye.l)(s,1-this.decay)),l=(0,ge.y)((0,ye.l)(s,this.learningRate),(0,be.R)((0,Me.j)(e,(0,me.W)((0,ve.E)(a),this.epsilon)))),u=(0,me.W)((0,ye.l)(o,this.momentum),l);i.assign(e),t.assign(a),o.assign(u);const c=(0,Me.j)(r,u);r.assign(c)}else{const e=(0,me.W)((0,ye.l)(i,this.decay),(0,ye.l)((0,ve.E)(s),1-this.decay)),t=(0,me.W)((0,ye.l)(o,this.momentum),(0,ge.y)((0,ye.l)(s,this.learningRate),(0,be.R)((0,me.W)(e,this.epsilon))));i.assign(e),o.assign(t);const n=(0,Me.j)(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,fe.AS)(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&(0,fe.AS)(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&(0,fe.AS)(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const We=[_e,Re,Fe,Le,Be,Ve,ze];function Ue(e){return new Promise((e=>setTimeout(e))).then(e)}class je{constructor(e){if(!(0,b._K)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(je.URL_SCHEME)&&(e=e.slice(je.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=N.D.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=(0,x.zV)(e,t),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=a,await Ue((()=>s.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Ue((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:(0,x.oR)(e)}}}}je.URL_SCHEME="downloads://";class Ge{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});const s=(0,x.Ej)(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const s of e)t.push(...s.weights),n.push(...s.paths);const r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const a=new FileReader;a.onload=e=>{const t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>(0,x.P8)(e.name))),r={};for(const a of e)a.paths.forEach((e=>{const a=(0,x.P8)(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function He(e){return new Ge(e)}function qe(e,t,n,r){!function(e){(0,F.vA)(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){(0,F.vA)(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),(0,F.vA)(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),(0,F.vA)(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(e.map((s=>(s.then((s=>{const i=n+ ++a/e.length*(r-n);return t(i),s})),s))))}w.registerSaveRouter((e=>(0,b._K)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(je.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new je(e)}(e.slice(je.URL_SCHEME.length)):null));var Ke=n(1042);async function Ye(e,t){null==t&&(t={});const n=null==t.fetchFunc?(0,b._K)().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await qe(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await qe(a,t.onProgress,.5,1)}async function Xe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Qe((e=>Ye(e,{requestInit:r})))(e,t,n)}function Qe(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0;const a=t.map((()=>!1)),s={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,u=Ke.i[l]*F.Ze(e.shape),c=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){const e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));const c=await e(u),d={};let h=0;return l.forEach((e=>{const n=t[e].paths.length,r=new N.D(c.slice(h,h+n));s[e].forEach((e=>{const t=r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),n=(0,x.CY)(t,[e.manifestEntry]);for(const r in n)d[r]=n[r]})),h+=n})),d}}class Ze{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?((0,F.vA)("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=(0,b._K)().platform.fetch,(0,F.vA)(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&(0,F.vA)(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=(0,x.zV)(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=N.D.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:(0,x.oR)(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(a){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return(0,x.Ej)(e,(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=(0,x.Xf)(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?(0,b._K)().platform.fetch:t.fetchFunc;let a,s=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;s<e.length;){if(!a){const n=(await r(e[s],t.requestInit,{isBinary:!0})).body;a=n.getReader()}const{done:o,value:l}=await a.read();if(!o)return void n.enqueue(l);s++,a=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,s/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,s=[],i=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):s.push(a+e+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){const t=await this.getWeightUrls(e);return[(0,x.Xf)(e),await Ye(t,this.loadOptions)]}}function Je(e){return null!=e.match(Ze.URL_SCHEME_REGEX)}Ze.URL_SCHEME_REGEX=/^https?:\/\//;const et=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Je(e))):Je(e),n)return tt(e,t)}return null};function tt(e,t){return new Ze(e,t)}function nt(e,t){return tt(e,t)}w.registerSaveRouter(et),w.registerLoadRouter(et);class rt{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class at{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class st{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function it(e,t,n,r){return new st(ot(...arguments))}function ot(e,t,n,r){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new rt(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new rt({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new rt({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function lt(e){return new at(e)}function ut(e){return new at(e)}var ct=n(4148),dt=n(5162),ht=n(9246),pt=n(7892),ft=n(2154);const mt=(0,pt.op)({confusionMatrix_:function(e,t,n){const r=(0,ct.YT)(e,"labels","confusionMatrix"),a=(0,ct.YT)(t,"predictions","confusionMatrix");F.vA(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),F.vA(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),F.vA(1===a.rank,(()=>`Expected the rank of predictions to be 1, but got ${a.rank}`)),F.vA(r.shape[0]===a.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`)),F.vA(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));const s=(0,ht.M)((0,ue.w)(r,"int32"),n),i=(0,ht.M)((0,ue.w)(a,"int32"),n),o=(0,ft.m)(s),l=(0,dt.N)(o,i);return(0,ue.w)(l,"int32")}});var gt=n(8805),yt=n(9554),bt=n(843),vt=n(5395);let xt,wt=!1;function kt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=(0,bt._5)(yt.awo,p.T2.backendName)){const n={pixels:e},r={numChannels:t};return p.T2.runKernel(yt.awo,n,r)}const[l,u]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,d;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(s||a||o){if(null==xt)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");xt=new OffscreenCanvas(1,1).getContext("2d")}else xt=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});xt.canvas.width=l,xt.canvas.height=u,xt.drawImage(e,0,0,l,u),c=xt.getImageData(0,0,l,u).data}if(4===t)d=new Int32Array(c);else{const e=l*u;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=c[4*n+e]}const h=[u,l,t];return(0,vt.$)(d,h,"int32")}function St(e){return"undefined"!==typeof window&&"undefined"!==typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function It(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,n=null;if((0,b._K)().getBool("WRAP_TO_IMAGEBITMAP")&&St(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(r){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return kt(n,t)}function Tt(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function Nt(e,t){let n=(0,ct.YT)(e,"img","toPixels");if(!(e instanceof he.qY)){const e=n;n=(0,ue.w)(e,"int32"),e.dispose()}Tt(n);const[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){const e=[0,0,0,255];for(let r=0;r<s;r++){const t=i[u*s+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===s?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[r]=t*o}const t=4*u;l[t+0]=Math.round(e[0]),l[t+1]=Math.round(e[1]),l[t+2]=Math.round(e[2]),l[t+3]=Math.round(e[3])}if(null!=t){if(!wt){null!=(0,bt._5)(yt.XmO,p.T2.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),wt=!0)}t.width=a,t.height=r;const e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function Ct(e,t,n){let r=(0,ct.YT)(e,"img","draw");if(!(e instanceof he.qY)){const e=r;r=(0,ue.w)(e,"int32"),e.dispose()}Tt(r),function(e){const t=(null===e||void 0===e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null===n||void 0===n?void 0:n.imageOptions);const a={image:r},s={canvas:t,options:n};p.T2.runKernel(yt.XmO,a,s)}const At=(0,pt.op)({fromPixels_:kt});function Et(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===(0,F.Ze)(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const a=t.shape,s=a[a.length-1];let i=1;for(let d=0;d<a.length-1;++d)i*=a[d];const o=e.shape,l=a.slice();l.pop();let u=1;for(let d=s;d<n;++d)u*=o[d],l.push(o[d]);const c=[...(0,F.Ur)(e.shape).map((e=>e/u)),1].slice(0,s);return[l,i,u,c]}var _t=n(4083),$t=n(4642),Rt=n(8804),Dt=n(8977);const Mt=.001,Ft=.1;function Ot(e,t,n){return null==n&&(n=Pt()),Lt(e,t,((e,t)=>Wt(e,t,n)))}function Pt(){return 32===p.T2.backend.floatPrecision()?Mt:Ft}function Lt(e,t,n){let r=!0;if(((0,Dt.isTypedArray)(e)||(0,Dt.isTypedArray)(t))&&(r=!1),(0,Dt.isTypedArray)(e)&&(0,Dt.isTypedArray)(t)&&(r=!0),r){const n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){const n=(0,ct.MZ)(e),r=(0,ct.MZ)(t);if(!(0,F.r1)(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const a=(0,Dt.isTypedArray)(e)?e:(0,Dt.flatten)(e),s=(0,Dt.isTypedArray)(t)?t:(0,Dt.flatten)(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.\nActual:   ${a}.\nExpected: ${s}.`);for(let i=0;i<s.length;++i){const e=a[i],t=s[i];if(!n(e,t))throw new Error(`Arrays differ: actual[${i}] = ${e}, expected[${i}] = ${t}.\nActual:   ${a}.\nExpected: ${s}.`)}"undefined"!==typeof expect&&expect().nothing()}function zt(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!==typeof expect&&expect().nothing()}function Bt(e,t){const n="string"===typeof t||"number"===typeof t||"boolean"===typeof t?[t]:t;return(0,F.Kg)(e)||(0,F.Kg)(e[0])||(0,F.Kg)(t)||(0,F.Kg)(t[0])?Lt(e,n,((e,t)=>e==t)):Lt(e,t,((e,t)=>Wt(e,t,0)))}function Vt(e,t,n){if(null==n&&(n=Pt()),!Wt(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!==typeof expect&&expect().nothing()}function Wt(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Ut(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function jt(e,t){const n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function Gt(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?Gt(n):e[t]=(0,Dt.encodeString)(n)}return e}function Ht(e){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function qt(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}const Kt="4.20.0";class Yt{static sgd(e){return new ze(e)}static momentum(e,t){return new Be(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new Ve(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Fe(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new _e(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new Le(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new Re(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}}var Xt=n(8075),Qt=n(9249),Zt=n(1667);const Jt=Yt,en="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function tn(){return new Promise((e=>en((()=>e()))))}var nn=n(9235);function rn(e,t){const n=e[0].length;e.forEach(((e,t)=>{F.vA(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),F.vA(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)F.vA(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function an(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var sn,on=n(7538),ln=n(7905);function un(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){const s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function cn(e){const t={FIRST_DIM_SIZE:sn.FIRST_DIM_SIZE,VALUE_ROWIDS:sn.VALUE_ROWIDS,ROW_LENGTHS:sn.ROW_LENGTHS,ROW_SPLITS:sn.ROW_SPLITS,ROW_LIMITS:sn.ROW_LIMITS,ROW_STARTS:sn.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function dn(e){return 0===e.length?0:e[0]===sn.FIRST_DIM_SIZE?e.length-1:e.length}function hn(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){const n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(sn||(sn={}));const pn=30;function fn(e){return e<=pn?e:(0,F.lK)(e,Math.floor(Math.sqrt(e)))}function mn(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function gn(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function yn(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{const r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function bn(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function vn(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function xn(e,t,n){const r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var wn=n(3765);const kn=.3275911,Sn=.254829592,In=-.284496736,Tn=1.421413741,Nn=-1.453152027,Cn=1.061405429;var An=n(4124);function En(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function _n(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function $n(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Rn(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Dn(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Mn(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Fn(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){const s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function On(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const Pn="->",Ln=/->/g,zn=",",Bn="...";function Vn(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Ln,"").length)/Pn.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Pn}").`);const[r,a]=e.split(Pn);(0,F.vA)(-1===r.indexOf(Bn),(()=>`The ellipsis notation ("${Bn}") is not supported yet.`));const s=r.split(zn),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let d=0;d<a.length;++d){const e=a[d];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<r.length;++d){const e=r[d];-1===o.indexOf(e)&&e!==zn&&o.push(e)}const l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let e=0;e<s[d].length;++e)l[d].push(o.indexOf(s[d][e]))}const u=o.length,c=[];for(let d=a.length;d<u;++d)c.push(d);return{allDims:o,summedDims:c,idDims:l}}function Wn(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;const r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function Un(e,t,n){const r=new Array(e);for(let a=0;a<n.length;++a){const e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:(0,F.vA)(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function jn(e,t){const n=e,r=[];let a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);const s=[];for(let i=0;i<n.length;++i){const e=Hn(t,n[i]);for(const t of e)-1===s.indexOf(t)&&(r[i].push(t),s.push(t))}return{path:n,steps:r}}function Gn(e){return e.every(((e,t)=>e===t))}function Hn(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function qn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof t)(0,F.vA)(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);(0,F.vA)(a<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}(0,F.vA)(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Kn(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Yn(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function Xn(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Qn(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Zn(e,t){return`size ${e} must be non-negative, not ${t}`}function Jn(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function er(e,t){return`Input to reshape is a SparseTensor with ${(0,F.Ze)(e)}\n  dense values, but the requested shape requires a multiple of ${(0,F.Ze)(t)}. inputShape=${e} outputShape= ${t}`}function tr(e,t){return`Input to reshape is a tensor with ${(0,F.Ze)(e)} dense values, but the requested shape has ${(0,F.Ze)(t)}. inputShape=${e} outputShape=${t}`}function nr(){return"segment ids must be >= 0"}function rr(){return"segment ids are not increasing"}function ar(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function sr(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function ir(e,t){let n,r=!1;for(e<=pn?(n=e,r=!0):n=(0,F.lK)(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=(0,F.lK)(e,n+1);return n}function or(e,t,n){const r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function lr(e,t,n,r){const a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<a;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function ur(e){try{return e.map((e=>(0,Dt.decodeString)(e)))}catch(fr){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${fr}`)}}function cr(e){return e.map((e=>(0,Dt.encodeString)(e)))}var dr=n(6692),hr=n(9286),pr=n(6790);!function(){for(const e of We)Ce(e)}()},7131:(e,t,n)=>{"use strict";n.d(t,{D:()=>a});var r=n(8977);class a{static join(e){return new a(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>r.isTypedArray(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),a=new Uint8Array(r);let s=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],r=e+s-n.start,o=s,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(a.set(u,o),s+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const a=Math.floor((r-n)/2)+n,s=t(e[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}},285:(e,t,n)=>{"use strict";n.d(t,{AQ:()=>S,CY:()=>h,Ej:()=>C,P8:()=>I,Rl:()=>N,Xf:()=>E,aG:()=>d,jf:()=>k,l3:()=>w,oR:()=>A,s5:()=>y,zV:()=>T});var r=n(6149),a=n(8032),s=n(1426),i=n(1042),o=n(7131),l=n(8046),u=n(5399);const c=4;async function d(e,t){const n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<a.length;++s){const i=a[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+c*t.length,r=new Uint8Array(n);let a=0;for(let s=0;s<t.length;s++){const e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=c,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:b(await Promise.all(r)),specs:n}}function h(e,t){const n=new o.D(e),r={};let a=0;for(const s of t){const e=p(s,((e,t)=>n.slice(a+e,a+t)));r[s.name]=m(s,n.slice(a,a+e)),a+=e}return r}function p(e,t){const n=(0,s.Ze)(e.shape);let r;if("quantization"in e){const t=e.quantization;r=i.i[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=c+new Uint32Array(t(e,e+c))[0];return e}r=i.i[e.dtype]}return n*r}async function f(e,t){const n=(0,s.Ze)(e.shape);let r;if("quantization"in e){const t=e.quantization;r=i.i[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=c+new Uint32Array(await t(e,e+c))[0];return e}r=i.i[e.dtype]}return n*r}function m(e,t){const n=e.name,o=e.dtype,l=e.shape,u=(0,s.Ze)(l);let d,h=0;if("quantization"in e){const r=e.quantization;if("uint8"===r.dtype||"uint16"===r.dtype){if(!("min"in r)||!("scale"in r))throw new Error(`Weight ${e.name} with quantization ${r.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==r.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${r.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${e.name} is quantized with ${r.dtype} which only supports weights of type float32 not ${o}.`)}const a=i.i[r.dtype],s="uint8"===r.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===o)if("uint8"===r.dtype||"uint16"===r.dtype){d=new Float32Array(s.length);for(let e=0;e<s.length;e++){const t=s[e];d[e]=t*r.scale+r.min}}else{if("float16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){const a=r[i],o=e[n[a>>10]+(1023&a)]+t[a>>10];s[i]=o}return new Float32Array(a)}}();d=e(s)}}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${n}': ${o}`);if("uint8"!==r.dtype&&"uint16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type int32.`);d=new Int32Array(s.length);for(let e=0;e<s.length;e++){const t=s[e];d[e]=Math.round(t*r.scale+r.min)}}h+=u*a}else if("string"===o){const n=(0,s.Ze)(e.shape);d=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(h,h+c))[0];h+=c;const n=new Uint8Array(t.slice(h,h+e));d.push(n),h+=e}}else{const e=i.i[o];if("float32"===o)d=new Float32Array(t);else if("int32"===o)d=new Int32Array(t);else{if("bool"!==o){if("complex64"===o){d=new Float32Array(t);const e=new Float32Array(d.length/2),n=new Float32Array(d.length/2);for(let t=0;t<e.length;t++)e[t]=d[2*t],n[t]=d[2*t+1];const s=(0,a.O)(e,l,"float32"),i=(0,a.O)(n,l,"float32"),o=(0,r.f)(s,i);return s.dispose(),i.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${o}`)}d=new Uint8Array(t)}h+=u*e}return(0,a.O)(d,l,o)}async function g(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:a}=await e.read();if(t&&null==a){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const s=new Uint8Array(r.length+a.byteLength);s.set(r,0),s.set(new Uint8Array(a),r.length),r=s}return r.buffer}async function y(e,t){const n={},r=e.getReader();let a=new ArrayBuffer(0);for(const i of t){const e=await f(i,(async(e,t)=>(a=await g(r,a,t),a.slice(e,t))));a=await g(r,a,e);const t=a.slice(0,e);a=a.slice(e);const o=m(i,t);if(n[i.name]=o,"webgpu"===(0,l.jz)()){const e=(0,l.Hs)();"uploadToGPU"in e&&(0,s.Ze)(o.shape)>=(0,u._K)().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(o.dataId)}}return n}function b(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}const v="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function x(e){return v?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function w(e){if(v)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function k(e){if(v){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function S(e){return o.D.join(e)}function I(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function T(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function N(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function C(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),N(e,n,r)}function A(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:x(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:x(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new o.D(e.weightData).byteLength}}function E(e){const t=[];for(const n of e)t.push(...n.weights);return t}},1042:(e,t,n)=>{"use strict";n.d(t,{i:()=>r});const r={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},9554:(e,t,n)=>{"use strict";n.d(t,{$dB:()=>R,$jE:()=>nn,$zE:()=>$,A1h:()=>O,A8B:()=>Wt,BK4:()=>bn,BLA:()=>Qe,BRl:()=>se,Blb:()=>Ut,BoJ:()=>Ht,BxF:()=>de,C8s:()=>Gt,CQC:()=>ft,Cg$:()=>_e,CwD:()=>Ce,D7i:()=>Nt,Ddj:()=>Xt,Dr:()=>vn,DvZ:()=>Kt,E3$:()=>Se,EkD:()=>o,ElG:()=>pe,EwU:()=>dn,FAs:()=>on,FCQ:()=>It,FSt:()=>u,Fin:()=>zt,GZp:()=>Zt,HNs:()=>I,Ik2:()=>k,J3C:()=>Ot,JiE:()=>Mt,Jp_:()=>c,KXH:()=>C,L6G:()=>qt,LB5:()=>T,LDN:()=>Ve,LG0:()=>Ye,LRy:()=>yt,LWX:()=>st,LXA:()=>De,M6A:()=>Qt,MRQ:()=>U,Mn0:()=>z,MnK:()=>B,N4F:()=>S,Ncv:()=>dt,O4G:()=>ge,OAQ:()=>xe,ODT:()=>lt,OMN:()=>i,ORI:()=>Y,PH8:()=>s,P_L:()=>Tt,Pah:()=>ne,PbM:()=>rn,Q6t:()=>gt,QDP:()=>A,QKF:()=>h,Qgm:()=>te,R23:()=>xt,RMm:()=>fn,RUm:()=>$e,RW8:()=>Me,RXX:()=>Ue,SDM:()=>nt,SQl:()=>ce,T7M:()=>wn,TBb:()=>ln,TL8:()=>He,TMz:()=>G,TOR:()=>At,ToN:()=>Le,TyE:()=>f,UcO:()=>Jt,VAI:()=>Be,VCH:()=>b,Vvy:()=>a,WRv:()=>ze,WT3:()=>Ze,WuN:()=>Vt,X$8:()=>q,X0$:()=>Te,X4r:()=>_t,XQy:()=>kt,XhZ:()=>ye,XmO:()=>J,YAb:()=>en,YVe:()=>Pt,ZgB:()=>he,Zl4:()=>rt,_s9:()=>ae,aAr:()=>xn,awo:()=>yn,bCz:()=>ut,bP9:()=>Q,cHb:()=>Ge,cS:()=>v,dFH:()=>Bt,dLy:()=>un,dXR:()=>hn,dv8:()=>we,e0f:()=>at,epO:()=>p,fUj:()=>vt,g5A:()=>qe,gC7:()=>L,gIW:()=>ke,hVg:()=>Ct,hgw:()=>St,ho8:()=>y,hql:()=>Ft,huO:()=>bt,i5R:()=>fe,iGz:()=>P,iPs:()=>Ie,iW0:()=>tn,iuW:()=>sn,jAQ:()=>w,jM4:()=>Pe,jOE:()=>wt,jfg:()=>F,jgd:()=>Yt,jj_:()=>V,jxD:()=>X,kdj:()=>ht,l0G:()=>et,l6P:()=>Rt,lLS:()=>be,lNG:()=>Ke,ljI:()=>r,lxb:()=>g,lzr:()=>ve,mH5:()=>mt,mIA:()=>Ne,mM$:()=>ot,mnI:()=>Ae,mxL:()=>me,nVu:()=>K,nY8:()=>W,nZd:()=>Re,oFs:()=>an,oJ2:()=>pt,ox3:()=>ie,p2J:()=>D,pJc:()=>Et,pPe:()=>pn,p_m:()=>d,pk0:()=>Z,pnw:()=>gn,pr3:()=>_,pyJ:()=>ct,rFG:()=>jt,rFm:()=>M,rGP:()=>ue,rsH:()=>re,sDr:()=>ee,t3d:()=>We,tG8:()=>Ee,tGH:()=>H,u$b:()=>Dt,u8Z:()=>l,uWl:()=>$t,urI:()=>it,vI1:()=>Lt,vaV:()=>E,vj7:()=>N,wNW:()=>j,wwC:()=>x,wx0:()=>cn,x7F:()=>Xe,xJ3:()=>mn,xu7:()=>Je,yPW:()=>Oe,ySp:()=>je,ybN:()=>oe,ybj:()=>le,ylV:()=>tt,zP9:()=>m,zfU:()=>Fe});const r="Abs",a="Acos",s="Acosh",i="Add",o="AddN",l="All",u="Any",c="ArgMax",d="ArgMin",h="Asin",p="Asinh",f="Atan",m="Atanh",g="Atan2",y="AvgPool",b="AvgPoolGrad",v="AvgPool3D",x="AvgPool3DGrad",w="BatchMatMul",k="BatchToSpaceND",S="Bincount",I="BitwiseAnd",T="BroadcastTo",N="BroadcastArgs",C="Cast",A="Ceil",E="ClipByValue",_="Complex",$="ComplexAbs",R="Concat",D="Conv2D",M="Conv2DBackpropFilter",F="Conv2DBackpropInput",O="Conv3D",P="Conv3DBackpropFilterV2",L="Conv3DBackpropInputV2",z="Cos",B="Cosh",V="Cumprod",W="Cumsum",U="CropAndResize",j="DenseBincount",G="DepthToSpace",H="DepthwiseConv2dNative",q="DepthwiseConv2dNativeBackpropFilter",K="DepthwiseConv2dNativeBackpropInput",Y="Diag",X="Dilation2D",Q="Dilation2DBackpropInput",Z="Dilation2DBackpropFilter",J="Draw",ee="RealDiv",te="Einsum",ne="Elu",re="EluGrad",ae="Erf",se="Equal",ie="Exp",oe="ExpandDims",le="Expm1",ue="FFT",ce="Fill",de="FlipLeftRight",he="Floor",pe="FloorDiv",fe="FusedBatchNorm",me="GatherV2",ge="GatherNd",ye="Greater",be="GreaterEqual",ve="Identity",xe="IFFT",we="Imag",ke="IsFinite",Se="IsInf",Ie="IsNan",Te="LeakyRelu",Ne="Less",Ce="LessEqual",Ae="LinSpace",Ee="Log",_e="Log1p",$e="LogicalAnd",Re="LogicalNot",De="LogicalOr",Me="LogicalXor",Fe="LogSoftmax",Oe="LowerBound",Pe="LRN",Le="LRNGrad",ze="MatrixBandPart",Be="Max",Ve="Maximum",We="MaxPool",Ue="MaxPoolGrad",je="MaxPool3D",Ge="MaxPool3DGrad",He="MaxPoolWithArgmax",qe="Mean",Ke="Min",Ye="Minimum",Xe="MirrorPad",Qe="Mod",Ze="Multinomial",Je="Multiply",et="Neg",tt="NotEqual",nt="NonMaxSuppressionV3",rt="NonMaxSuppressionV4",at="NonMaxSuppressionV5",st="OnesLike",it="OneHot",ot="Pack",lt="PadV2",ut="Pool",ct="Pow",dt="Prelu",ht="Prod",pt="RaggedGather",ft="RaggedRange",mt="RaggedTensorToTensor",gt="Range",yt="Real",bt="Reciprocal",vt="Relu",xt="Reshape",wt="ResizeNearestNeighbor",kt="ResizeNearestNeighborGrad",St="ResizeBilinear",It="ResizeBilinearGrad",Tt="Relu6",Nt="Reverse",Ct="Round",At="Rsqrt",Et="ScatterNd",_t="TensorScatterUpdate",$t="SearchSorted",Rt="Select",Dt="Selu",Mt="Slice",Ft="Sin",Ot="Sinh",Pt="Sign",Lt="Sigmoid",zt="Softplus",Bt="Sqrt",Vt="Sum",Wt="SpaceToBatchND",Ut="SplitV",jt="Softmax",Gt="SparseFillEmptyRows",Ht="SparseReshape",qt="SparseSegmentMean",Kt="SparseSegmentSum",Yt="SparseToDense",Xt="SquaredDifference",Qt="Square",Zt="StaticRegexReplace",Jt="StridedSlice",en="StringNGrams",tn="StringSplit",nn="StringToHashBucketFast",rn="Sub",an="Tan",sn="Tanh",on="Tile",ln="TopK",un="Transform",cn="Transpose",dn="Unique",hn="Unpack",pn="UnsortedSegmentSum",fn="UpperBound",mn="ZerosLike",gn="Step",yn="FromPixels",bn="RotateWithOffset",vn="_FusedMatMul",xn="FusedConv2D",wn="FusedDepthwiseConv2D"},843:(e,t,n)=>{"use strict";n.d(t,{Cf:()=>m,Op:()=>c,_5:()=>l,iP:()=>p,kr:()=>h,rY:()=>f,tA:()=>d,vQ:()=>u});var r=n(5399),a=n(7926),s=n(4124);const i=(0,a.m)("kernelRegistry",(()=>new Map)),o=(0,a.m)("gradRegistry",(()=>new Map));function l(e,t){const n=g(e,t);return i.get(n)}function u(e){return o.get(e)}function c(e){const t=i.entries(),n=[];for(;;){const{done:r,value:a}=t.next();if(r)break;const[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function d(e){const{kernelName:t,backendName:n}=e,r=g(t,n);i.has(r)&&s.i(`The kernel '${t}' for backend '${n}' is already registered`),i.set(r,e)}function h(e){const{kernelName:t}=e;o.has(t)&&(0,r._K)().getBool("DEBUG")&&s.i(`Overriding the gradient for '${t}'`),o.set(t,e)}function p(e,t){const n=g(e,t);if(!i.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);i.delete(n)}function f(e){if(!o.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);o.delete(e)}function m(e,t){c(e).forEach((e=>{d(Object.assign({},e,{backendName:t}))}))}function g(e,t){return`${t}_${e}`}},4124:(e,t,n)=>{"use strict";n.d(t,{R:()=>s,i:()=>a});var r=n(5399);function a(){(0,r._K)().getBool("IS_TEST")||(0,r._K)().getBool("PROD")||console.warn(...arguments)}function s(){(0,r._K)().getBool("IS_TEST")||(0,r._K)().getBool("PROD")||console.log(...arguments)}},3753:(e,t,n)=>{"use strict";n.d(t,{t:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({abs_:function(e){const t=(0,s.YT)(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return r.T2.runKernel(a.$zE,e)}{const e={x:t};return r.T2.runKernel(a.ljI,e)}}})},4759:(e,t,n)=>{"use strict";n.d(t,{H:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({acos_:function(e){const t={x:(0,s.YT)(e,"x","acos")};return r.T2.runKernel(a.Vvy,t)}})},983:(e,t,n)=>{"use strict";n.d(t,{F:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({acosh_:function(e){const t={x:(0,s.YT)(e,"x","acosh")};return r.T2.runKernel(a.PH8,t)}})},7242:(e,t,n)=>{"use strict";n.d(t,{W:()=>o});var r=n(2164),a=n(9554),s=n(8804),i=n(4148);const o=(0,n(7892).op)({add_:function(e,t){let n=(0,i.YT)(e,"a","add"),o=(0,i.YT)(t,"b","add");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(a.OMN,l)}})},1802:(e,t,n)=>{"use strict";n.d(t,{Q:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i={x:(0,s.YT)(e,"x","all","bool")},o={axis:t,keepDims:n};return r.T2.runKernel(a.u8Z,i,o)}})},1819:(e,t,n)=>{"use strict";n.d(t,{b:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i={x:(0,s.YT)(e,"x","any","bool")},o={axis:t,keepDims:n};return r.T2.runKernel(a.FSt,i,o)}})},3068:(e,t,n)=>{"use strict";n.d(t,{F:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:(0,s.YT)(e,"x","argMax")},i={axis:t};return r.T2.runKernel(a.Jp_,n,i)}})},8482:(e,t,n)=>{"use strict";n.d(t,{X:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:(0,s.YT)(e,"x","argMin")},i={axis:t};return r.T2.runKernel(a.p_m,n,i)}})},3010:(e,t,n)=>{"use strict";n.d(t,{q:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({asin_:function(e){const t={x:(0,s.YT)(e,"x","asin")};return r.T2.runKernel(a.QKF,t)}})},6464:(e,t,n)=>{"use strict";n.d(t,{y:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({asinh_:function(e){const t={x:(0,s.YT)(e,"x","asinh")};return r.T2.runKernel(a.epO,t)}})},7803:(e,t,n)=>{"use strict";n.d(t,{r:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({atan_:function(e){const t={x:(0,s.YT)(e,"x","atan")};return r.T2.runKernel(a.TyE,t)}})},6349:(e,t,n)=>{"use strict";n.d(t,{F:()=>o});var r=n(2164),a=n(9554),s=n(8804),i=n(4148);const o=(0,n(7892).op)({atan2_:function(e,t){let n=(0,i.YT)(e,"a","atan2"),o=(0,i.YT)(t,"b","atan2");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(a.lxb,l)}})},8147:(e,t,n)=>{"use strict";n.d(t,{r:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({atanh_:function(e){const t={x:(0,s.YT)(e,"x","atanh")};return r.T2.runKernel(a.zP9,t)}})},8650:(e,t,n)=>{"use strict";n.d(t,{$:()=>d});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(7794),l=n(7538),u=n(7892),c=n(5583);const d=(0,u.op)({avgPool_:function(e,t,n,u,d){const h=(0,s.YT)(e,"x","avgPool","float32");i.vA(l.G0(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let p=h,f=!1;3===h.rank&&(f=!0,p=(0,c.t)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),i.vA(4===p.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${p.rank}.`)),l.s_("avgPool",u,d);const m={x:p},g={filterSize:t,strides:n,pad:u,dimRoundingMode:d};let y=r.T2.runKernel(a.ho8,m,g);return y=(0,o.w)(y,h.dtype),f?(0,c.t)(y,[y.shape[1],y.shape[2],y.shape[3]]):y}})},9235:(e,t,n)=>{"use strict";n.d(t,{Em:()=>u,SM:()=>o,WC:()=>l,WH:()=>a,aF:()=>s,fK:()=>d,gx:()=>c,lb:()=>i});var r=n(1426);function a(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function s(e,t,n){const r=e.length+t.length,a=[];let s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function i(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function o(e,t){return s(e,t.map((e=>1)),t)}function l(e,t,n){r.vA(a(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function u(e,t){if(a(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function c(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function d(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}},2557:(e,t,n)=>{"use strict";n.d(t,{G:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({batchToSpaceND_:function(e,t,n){const o=(0,s.YT)(e,"x","batchToSpaceND"),l=t.reduce(((e,t)=>e*t));i.vA(o.rank>=1+t.length,(()=>`input rank is ${o.rank} but should be > than blockShape.length ${t.length}`)),i.vA(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),i.vA(o.shape[0]%l===0,(()=>`input tensor batch is ${o.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${l}`));const u={x:o},c={blockShape:t,crops:n};return r.T2.runKernel(a.Ik2,u,c)}})},9618:(e,t,n)=>{"use strict";n.d(t,{$:()=>l});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(5583);const l=(0,n(7892).op)({batchNorm_:function(e,t,n,l,u,c){null==c&&(c=.001);const d=(0,s.YT)(e,"x","batchNorm"),h=(0,s.YT)(t,"mean","batchNorm"),p=(0,s.YT)(n,"variance","batchNorm");let f,m;null!=u&&(f=(0,s.YT)(u,"scale","batchNorm")),null!=l&&(m=(0,s.YT)(l,"offset","batchNorm")),i.vA(h.rank===p.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),i.vA(null==m||h.rank===m.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),i.vA(null==f||h.rank===f.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const g={x:function(e){let t;return t=0===e.rank||1===e.rank?(0,o.t)(e,[1,1,1,e.size]):2===e.rank?(0,o.t)(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?(0,o.t)(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(d),scale:f,offset:m,mean:h,variance:p},y={varianceEpsilon:c},b=r.T2.runKernel(a.i5R,g,y);return(0,o.t)(b,d.shape)}})},4920:(e,t,n)=>{"use strict";n.d(t,{h:()=>c});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(9820),l=n(7892),u=n(5583);const c=(0,l.op)({broadcastTo_:function(e,t){let n=(0,s.YT)(e,"broadcastTo","x");const l=n.shape;if((0,i.SA)(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=(0,u.t)(n,e)}const c=n.shape,d=Array.from(t);for(let r=t.length-1;r>=0;r--)if(c[r]===t[r])d[r]=1;else if(1!==n.shape[r])throw new Error(`broadcastTo(): [${l}] cannot be broadcast to [${t}].`);if(0===d.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return(0,o.o)(n);const h={x:n},p={reps:d};return r.T2.runKernel(a.FAs,h,p)}})},8805:(e,t,n)=>{"use strict";function r(e,t){const n=e.length,r=[];for(let a=0;a<n;a++){const s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function a(e,t){const n=[];for(let r=0;r<t.length;r++){const a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function s(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];null==s&&(s=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===s)r[n-a-1]=i;else if(1===i)r[n-a-1]=s;else{if(s!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-a-1]=s}}return r}n.r(t),n.d(t,{assertAndGetBroadcastShape:()=>s,getBroadcastDims:()=>r,getReductionAxes:()=>a})},259:(e,t,n)=>{"use strict";n.d(t,{r:()=>s});var r=n(9494),a=n(1426);function s(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",a.SA(e),new r.yl(e,t,n)}},7794:(e,t,n)=>{"use strict";n.d(t,{w:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({cast_:function(e,t){const n=(0,s.YT)(e,"x","cast");if(!i.xn(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const o={x:n},l={dtype:t};return r.T2.runKernel(a.KXH,o,l)}})},5396:(e,t,n)=>{"use strict";n.d(t,{m:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({ceil_:function(e){const t={x:(0,s.YT)(e,"x","ceil","float32")};return r.T2.runKernel(a.QDP,t)}})},3829:(e,t,n)=>{"use strict";n.d(t,{z:()=>l});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(4660);const l=(0,n(7892).op)({clipByValue_:function(e,t,n){const l=(0,s.YT)(e,"x","clipByValue");if(i.vA(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return(0,o.G)(l.shape,t,l.dtype);const u={x:l},c={clipValueMin:t,clipValueMax:n};return r.T2.runKernel(a.vaV,u,c)}})},9820:(e,t,n)=>{"use strict";n.d(t,{o:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({clone_:function(e){const t={x:(0,s.YT)(e,"x","clone","string_or_numeric")};return r.T2.runKernel(a.lzr,t)}})},6149:(e,t,n)=>{"use strict";n.d(t,{f:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({complex_:function(e,t){const n=(0,s.YT)(e,"real","complex"),o=(0,s.YT)(t,"imag","complex");i.O3(n.shape,o.shape,`real and imag shapes, ${n.shape} and ${o.shape}, must match in call to tf.complex().`);const l={real:n,imag:o};return r.T2.runKernel(a.pr3,l)}})},4429:(e,t,n)=>{"use strict";n.d(t,{x:()=>l});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(9820);const l=(0,n(7892).op)({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;(0,i.vA)(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=(0,s.j1)(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return(0,o.o)(n[0]);const l=n,u={axis:t};return r.T2.runKernel(a.$dB,l,u)}})},9870:(e,t,n)=>{"use strict";n.d(t,{k:()=>u});var r=n(4148),a=n(1426),s=n(4969),i=n(7538),o=n(7892),l=n(5583);const u=(0,o.op)({conv1d_:function(e,t,n,o){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,d=arguments.length>6?arguments[6]:void 0;const h=(0,r.YT)(e,"x","conv1d"),p=(0,r.YT)(t,"filter","conv1d");let f=h,m=!1;2===h.rank&&(m=!0,f=(0,l.t)(h,[1,h.shape[0],h.shape[1]])),a.vA(3===f.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${f.rank}.`)),a.vA(3===p.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${p.rank}.`)),i.s_("conv1d",o,d),a.vA(f.shape[2]===p.shape[1],(()=>`Error in conv1d: depth of input (${f.shape[2]}) must match input depth for filter ${p.shape[1]}.`)),a.vA(i.G0(n,c),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${c}'`)),a.vA(i.qk(c),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),a.vA(i.qk(n),(()=>"Error in conv1D: Stride should be larger than 0.")),a.vA("NWC"===u,(()=>`Error in conv1d: got dataFormat of ${u} but only NWC is currently supported.`));const g=(0,l.t)(p,[1,p.shape[0],p.shape[1],p.shape[2]]),y=(0,l.t)(f,[f.shape[0],1,f.shape[1],f.shape[2]]),b=[1,n],v=[1,c],x=(0,s.X)(y,g,b,o,"NHWC",v,d);return m?(0,l.t)(x,[x.shape[2],x.shape[3]]):(0,l.t)(x,[x.shape[0],x.shape[2],x.shape[3]])}})},4969:(e,t,n)=>{"use strict";n.d(t,{X:()=>c});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(7538),l=n(7892),u=n(5583);const c=(0,l.op)({conv2d_:function(e,t,n,l){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],h=arguments.length>6?arguments[6]:void 0;const p=(0,s.YT)(e,"x","conv2d","float32"),f=(0,s.YT)(t,"filter","conv2d","float32");let m=p,g=!1;3===p.rank&&(g=!0,m=(0,u.t)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),i.vA(4===m.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${m.rank}.`)),i.vA(4===f.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${f.rank}.`)),o.s_("conv2d",l,h);const y="NHWC"===c?m.shape[3]:m.shape[1];i.vA(y===f.shape[2],(()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${f.shape[2]}.`)),i.vA(o.G0(n,d),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${d}'`)),i.vA(o.qk(d),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),i.vA(o.qk(n),(()=>"Error in conv2D: Strides should be larger than 0."));const b={x:m,filter:f},v={strides:n,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h},x=r.T2.runKernel(a.p2J,b,v);return g?(0,u.t)(x,[x.shape[1],x.shape[2],x.shape[3]]):x}})},6927:(e,t,n)=>{"use strict";n.d(t,{H:()=>u});var r=n(2164),a=n(9554),s=n(1426),i=n(7538),o=n(7892),l=n(5583);const u=(0,o.op)({conv2DBackpropFilter_:function(e,t,n,o,u){let c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",d=arguments.length>6?arguments[6]:void 0,h=e;3===e.rank&&(h=(0,l.t)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let p=t;3===p.rank&&(p=(0,l.t)(t,[1,t.shape[0],t.shape[1],t.shape[2]])),s.vA(4===h.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${h.shape}.`)),s.vA(4===p.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${p.shape}.`)),s.vA(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const f="NHWC"===c?h.shape[3]:h.shape[1],m="NHWC"===c?p.shape[3]:p.shape[1];s.vA(f===n[2],(()=>`Error in conv2dDerFilter: depth of input ${f}) must match input depth in filter (${n[2]}.`)),s.vA(m===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${m}) must match output depth for filter (${n[3]}).`)),i.s_("conv2dDerFilter",u,d);const g={x:h,dy:p},y={strides:o,pad:u,dataFormat:c,dimRoundingMode:d,filterShape:n};return r.T2.runKernel(a.rFm,g,y)}})},1565:(e,t,n)=>{"use strict";n.d(t,{v:()=>u});var r=n(2164),a=n(9554),s=n(1426),i=n(7538),o=n(7892),l=n(5583);const u=(0,o.op)({conv2DBackpropInput_:function(e,t,n,o,u){let c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",d=arguments.length>6?arguments[6]:void 0;s.vA(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let h=e,p=t,f=!1;3===t.rank&&(f=!0,p=(0,l.t)(t,[1,t.shape[0],t.shape[1],t.shape[2]]),h=[1,e[0],e[1],e[2]]),s.vA(4===h.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${h.length}.`)),s.vA(4===p.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${p.rank}`)),s.vA(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const m="NHWC"===c?h[3]:h[1],g="NHWC"===c?p.shape[3]:p.shape[1];s.vA(m===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${m}) must match input depth for filter ${n.shape[2]}.`)),s.vA(g===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${g}) must match output depth for filter ${n.shape[3]}.`)),i.s_("conv2dDerInput",u,d);const y={dy:p,filter:n},b={strides:o,pad:u,dataFormat:c,dimRoundingMode:d,inputShape:h},v=r.T2.runKernel(a.jfg,y,b);return f?(0,l.t)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}})},1137:(e,t,n)=>{"use strict";n.d(t,{w:()=>s});var r=n(4148),a=n(1565);const s=(0,n(7892).op)({conv2dTranspose_:function(e,t,n,s,i,o){const l=(0,r.YT)(e,"x","conv2dTranspose"),u=(0,r.YT)(t,"filter","conv2dTranspose");return(0,a.v)(n,l,u,s,i,"NHWC",o)}})},6410:(e,t,n)=>{"use strict";n.d(t,{c:()=>l});var r=n(2164),a=n(9554),s=n(1426),i=n(7892),o=n(5583);const l=(0,i.op)({conv3DBackpropInput_:function(e,t,n,i,l){s.vA(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let u=e,c=t,d=!1;4===t.rank&&(d=!0,c=(0,o.t)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),u=[1,e[0],e[1],e[2],e[3]]);const h=u[4],p=c.shape[4];s.vA(5===u.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${u.length}.`)),s.vA(5===c.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${c.rank}`)),s.vA(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),s.vA(h===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[3]}.`)),s.vA(p===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[4]}.`));const f={dy:c,filter:n},m={pad:l,strides:i,inputShape:u},g=r.T2.runKernel(a.gC7,f,m);return d?(0,o.t)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}})},7538:(e,t,n)=>{"use strict";n.d(t,{$Q:()=>y,Dh:()=>f,E6:()=>s,G0:()=>m,G8:()=>u,YQ:()=>a,l5:()=>i,p$:()=>l,qk:()=>g,s_:()=>b,uf:()=>o});var r=n(1426);function a(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return o(e,[...t,e[3]],n,s,r,null,null,y(a))}function s(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[l,u]=c(t);let d;if("channelsLast"===i)d=[l,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);d=[l,u,e[1],e[1]]}return o(e,d,n,r,a,s,!1,i)}function i(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,u,c]=d(t);let h,p;if("NDHWC"===i)p="channelsLast",h=[o,u,c,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);p="channelsFirst",h=[o,u,c,e[1],e[1]]}return l(e,h,n,r,a,!1,p,s)}function o(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,d,f,m]=[-1,-1,-1,-1];if("channelsLast"===o)[l,d,f,m]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,m,d,f]=e}const[g,y,,b]=t,[v,x]=c(n),[w,k]=c(r),S=h(g,w),I=h(y,k),{padInfo:T,outHeight:N,outWidth:C}=function(e,t,n,r,a,s,i,o,l){let c,d,h;if("number"===typeof e){c={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const a=function(e,t,n,r,a){null==r&&(r=u(e,t,n));const s=e[0],i=e[1],o=p((s-t+2*r)/n+1,a),l=p((i-t+2*r)/n+1,a);return[o,l]}([t,n],s,r,e,o);d=a[0],h=a[1]}else if("same"===e){d=Math.ceil(t/r),h=Math.ceil(n/a);const e=Math.max(0,(d-1)*r+s-t),o=Math.max(0,(h-1)*a+i-n),l=Math.floor(e/2),u=e-l,p=Math.floor(o/2);c={top:l,bottom:u,left:p,right:o-p,type:"SAME"}}else if("valid"===e)c={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-s+1)/r),h=Math.ceil((n-i+1)/a);else{if("object"!==typeof e)throw Error(`Unknown padding parameter: ${e}`);{const u="channelsLast"===l?e[1][0]:e[2][0],f="channelsLast"===l?e[1][1]:e[2][1],m="channelsLast"===l?e[2][0]:e[3][0],g="channelsLast"===l?e[2][1]:e[3][1];c={top:u,bottom:f,left:m,right:g,type:0===u&&0===f&&0===m&&0===g?"VALID":"EXPLICIT"},d=p((t-s+u+f)/r+1,o),h=p((n-i+m+g)/a+1,o)}}return{padInfo:c,outHeight:d,outWidth:h}}(a,d,f,v,x,S,I,s,o),A=i?b*m:b;let E;return"channelsFirst"===o?E=[l,A,N,C]:"channelsLast"===o&&(E=[l,N,C,A]),{batchSize:l,dataFormat:o,inHeight:d,inWidth:f,inChannels:m,outHeight:N,outWidth:C,outChannels:A,padInfo:T,strideHeight:v,strideWidth:x,filterHeight:g,filterWidth:y,effectiveFilterHeight:S,effectiveFilterWidth:I,dilationHeight:w,dilationWidth:k,inShape:e,outShape:E,filterShape:t}}function l(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,c,f,m,g]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,c,f,m,g]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,g,c,f,m]=e}const[y,b,v,,x]=t,[w,k,S]=d(n),[I,T,N]=d(r),C=h(y,I),A=h(b,T),E=h(v,N),{padInfo:_,outDepth:$,outHeight:R,outWidth:D}=function(e,t,n,r,a,s,i,o,l,c,d){let h,f,m,g;"valid"===e&&(e=0);if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const y=function(e,t,n,r,a,s){null==a&&(a=u(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=p((e[o]-t[o]+2*a)/r[o]+1,s));return i}([t,n,r,1],[o,l,c],1,[a,s,i],e,d);f=y[0],m=y[1],g=y[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{f=Math.ceil(t/a),m=Math.ceil(n/s),g=Math.ceil(r/i);const e=(f-1)*a+o-t,u=(m-1)*s+l-n,d=(g-1)*i+c-r,p=Math.floor(e/2),y=e-p,b=Math.floor(u/2),v=u-b,x=Math.floor(d/2);h={top:b,bottom:v,left:x,right:d-x,front:p,back:y,type:"SAME"}}}return{padInfo:h,outDepth:f,outHeight:m,outWidth:g}}(a,c,f,m,w,k,S,C,A,E,o),M=s?x*g:x;let F;return"channelsFirst"===i?F=[l,M,$,R,D]:"channelsLast"===i&&(F=[l,$,R,D,M]),{batchSize:l,dataFormat:i,inDepth:c,inHeight:f,inWidth:m,inChannels:g,outDepth:$,outHeight:R,outWidth:D,outChannels:M,padInfo:_,strideDepth:w,strideHeight:k,strideWidth:S,filterDepth:y,filterHeight:b,filterWidth:v,effectiveFilterDepth:C,effectiveFilterHeight:A,effectiveFilterWidth:E,dilationDepth:I,dilationHeight:T,dilationWidth:N,inShape:e,outShape:F,filterShape:t}}function u(e,t,n){const r=h(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function c(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function d(e){return"number"===typeof e?[e,e,e]:e}function h(e,t){return t<=1?e:e+(e-1)*(t-1)}function p(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function f(e){const[t,n,r]=c(e);return 1===t&&1===n&&1===r}function m(e,t){return f(e)||f(t)}function g(e){return c(e).every((e=>e>0))}function y(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function b(e,t,n){if(null!=n){if("string"===typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"===typeof t)r.vA(r.E6(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!==typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{r.vA(r.E6(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}},5894:(e,t,n)=>{"use strict";n.d(t,{g:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({cos_:function(e){const t={x:(0,s.YT)(e,"x","cos","float32")};return r.T2.runKernel(a.Mn0,t)}})},1164:(e,t,n)=>{"use strict";n.d(t,{y:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({cosh_:function(e){const t={x:(0,s.YT)(e,"x","cosh","float32")};return r.T2.runKernel(a.MnK,t)}})},3739:(e,t,n)=>{"use strict";n.d(t,{L:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const o={x:(0,s.YT)(e,"x","cumprod")},l={axis:t,exclusive:n,reverse:i};return r.T2.runKernel(a.jj_,o,l)}})},7167:(e,t,n)=>{"use strict";n.d(t,{r:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const o={x:(0,s.YT)(e,"x","cumsum")},l={axis:t,exclusive:n,reverse:i};return r.T2.runKernel(a.nY8,o,l)}})},1719:(e,t,n)=>{"use strict";n.d(t,{R:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const o=(0,s.YT)(e,"x","depthToSpace","float32"),l="NHWC"===n?o.shape[1]:o.shape[2],u="NHWC"===n?o.shape[2]:o.shape[3],c="NHWC"===n?o.shape[3]:o.shape[1];i.vA(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),i.vA(l*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${l} and ${t}  for depthToSpace with input shape\n    ${o.shape}`)),i.vA(u*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${u} and ${t} for depthToSpace with input shape\n        ${o.shape}`)),i.vA(c%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${c} for depthToSpace with input shape ${o.shape}`));const d={x:o},h={blockSize:t,dataFormat:n};return r.T2.runKernel(a.TMz,d,h)}})},9899:(e,t,n)=>{"use strict";n.d(t,{G:()=>c});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(7538),l=n(7892),u=n(5583);const c=(0,l.op)({depthwiseConv2d_:function(e,t,n,l){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],h=arguments.length>6?arguments[6]:void 0;const p=(0,s.YT)(e,"x","depthwiseConv2d","float32"),f=(0,s.YT)(t,"filter","depthwiseConv2d","float32");let m=p,g=!1;3===p.rank&&(g=!0,m=(0,u.t)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),i.vA(4===m.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`)),i.vA(4===f.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`));const y="NHWC"===c?m.shape[3]:m.shape[1];i.vA(y===f.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${y}) must match the inChannels dimension in filter ${f.shape[2]}.`)),o.s_("depthwiseConv2d",l,h);const b={x:m,filter:f},v={strides:n,pad:l,dataFormat:c,dilations:d,dimRoundingMode:h},x=r.T2.runKernel(a.tGH,b,v);return g?(0,u.t)(x,[x.shape[1],x.shape[2],x.shape[3]]):x}})},7399:(e,t,n)=>{"use strict";n.d(t,{x:()=>o});var r=n(2164),a=n(9554),s=n(7892),i=n(5583);const o=(0,s.op)({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,s,o){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],u=arguments.length>6?arguments[6]:void 0,c=e;3===e.rank&&(c=(0,i.t)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let d=t;3===d.rank&&(d=(0,i.t)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={x:c,dy:d},p={strides:s,pad:o,dimRoundingMode:u,dilations:l,filterShape:n};return r.T2.runKernel(a.X$8,h,p)}})},261:(e,t,n)=>{"use strict";n.d(t,{l:()=>o});var r=n(2164),a=n(9554),s=n(7892),i=n(5583);const o=(0,s.op)({depthwiseConv2dNativeBackpropInput_:function(e,t,n,s,o){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],u=arguments.length>6?arguments[6]:void 0,c=t,d=!1;3===t.rank&&(d=!0,c=(0,i.t)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const h={dy:c,filter:n},p={strides:s,pad:o,dimRoundingMode:u,dilations:l,inputShape:e},f=r.T2.runKernel(a.nVu,h,p);return d?(0,i.t)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},3789:(e,t,n)=>{"use strict";n.d(t,{X:()=>u});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(7892),l=n(5583);const u=(0,o.op)({dilation2d_:function(e,t,n,o){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const d=(0,s.YT)(e,"x","dilation2d"),h=(0,s.YT)(t,"filter","dilation2d");i.vA(3===d.rank||4===d.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${d.rank}.`)),i.vA(3===h.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${h.rank}.`)),i.vA("NHWC"===c,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${c}`));let p=d,f=!1;3===d.rank&&(p=(0,l.t)(d,[1,d.shape[0],d.shape[1],d.shape[2]]),f=!0),i.vA(p.shape[3]===h.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${p.shape[3]} vs ${h.shape[2]}`));const m={x:p,filter:h},g={strides:n,pad:o,dilations:u},y=r.T2.runKernel(a.jxD,m,g);return f?(0,l.t)(y,[y.shape[1],y.shape[2],y.shape[3]]):y}})},4974:(e,t,n)=>{"use strict";n.d(t,{y:()=>l});var r=n(2164),a=n(9554),s=n(8804),i=n(4148),o=n(3612);const l=(0,n(7892).op)({div_:function(e,t){let n=(0,i.YT)(e,"a","div"),l=(0,i.YT)(t,"b","div");if([n,l]=(0,s.makeTypesMatch)(n,l),"int32"===n.dtype&&"int32"===l.dtype)return(0,o.w)(n,l);const u={a:n,b:l};return r.T2.runKernel(a.sDr,u,{})}})},44:(e,t,n)=>{"use strict";n.d(t,{e:()=>c});var r=n(8804),a=n(4148),s=n(4974),i=n(7457),o=n(7892),l=n(3986),u=n(3290);const c=(0,o.op)({divNoNan_:function(e,t){let n=(0,a.YT)(e,"a","div"),o=(0,a.YT)(t,"b","div");[n,o]=(0,r.makeTypesMatch)(n,o);const c=(0,s.y)(n,o),d=(0,u.P)(c),h=(0,i.L)(o,d);return(0,l._)(h,d,c)}})},6434:(e,t,n)=>{"use strict";n.d(t,{O:()=>l});var r=n(4148),a=n(1426),s=n(5162),i=n(7892),o=n(5583);const l=(0,i.op)({dot_:function(e,t){const n=(0,r.YT)(e,"t1","dot"),i=(0,r.YT)(t,"t2","dot");a.vA((1===n.rank||2===n.rank)&&(1===i.rank||2===i.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${i.rank}.`));const l=1===n.rank?n.size:n.shape[1],u=1===i.rank?i.size:i.shape[0];if(a.vA(l===u,(()=>`Error in dot: inner dimensions of inputs must match, but got ${l} and ${u}.`)),1===n.rank&&1===i.rank){const e=(0,o.t)(n,[1,-1]),t=(0,o.t)(i,[-1,1]),r=(0,s.N)(e,t);return(0,o.t)(r,[])}if(1===n.rank&&2===i.rank){const e=(0,o.t)(n,[1,-1]),t=(0,o.t)(i,[i.shape[0],i.shape[1]]),r=(0,s.N)(e,t);return(0,o.t)(r,[r.size])}if(2===n.rank&&1===i.rank){const e=(0,o.t)(i,[-1,1]),t=(0,s.N)(n,e);return(0,o.t)(t,[t.size])}{const e=(0,o.t)(i,[i.shape[0],i.shape[1]]);return(0,s.N)(n,e)}}})},3645:(e,t,n)=>{"use strict";n.d(t,{P:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({elu_:function(e){const t={x:(0,s.YT)(e,"x","elu","float32")};return r.T2.runKernel(a.Pah,t)}})},7457:(e,t,n)=>{"use strict";n.d(t,{L:()=>l});var r=n(2164),a=n(9554),s=n(8804),i=n(4148),o=n(8805);const l=(0,n(7892).op)({equal_:function(e,t){let n=(0,i.YT)(e,"a","equal","string_or_numeric"),l=(0,i.YT)(t,"b","equal","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(a.BRl,u)}})},8810:(e,t,n)=>{"use strict";n.d(t,{Y:()=>l});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(7794);const l=(0,n(7892).op)({erf_:function(e){let t=(0,s.YT)(e,"x","erf");i.vA("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=(0,o.w)(t,"float32"));const n={x:t};return r.T2.runKernel(a._s9,n)}})},8826:(e,t,n)=>{"use strict";n.d(t,{p:()=>a});var r=n(2155);const a=(0,n(7892).op)({euclideanNorm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return(0,r.x)(e,"euclidean",t,n)}})},5462:(e,t,n)=>{"use strict";n.d(t,{o:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({exp_:function(e){const t={x:(0,s.YT)(e,"x","exp")};return r.T2.runKernel(a.ox3,t)}})},4023:(e,t,n)=>{"use strict";n.d(t,{U:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=(0,s.YT)(e,"x","expandDims","string_or_numeric");i.vA(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const o={input:n},l={dim:t};return r.T2.runKernel(a.ybN,o,l)}})},2520:(e,t,n)=>{"use strict";n.d(t,{I:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({expm1_:function(e){const t={x:(0,s.YT)(e,"x","expm1")};return r.T2.runKernel(a.ybj,t)}})},4660:(e,t,n)=>{"use strict";n.d(t,{G:()=>i});var r=n(2164),a=n(9554),s=n(1426);function i(e,t,n){(0,s.SA)(e);const i={shape:e,value:t,dtype:n=n||(0,s.X$)(t)};return r.T2.runKernel(a.SQl,{},i)}},8587:(e,t,n)=>{"use strict";n.d(t,{R:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({floor_:function(e){const t={x:(0,s.YT)(e,"x","floor","float32")};return r.T2.runKernel(a.ZgB,t)}})},3612:(e,t,n)=>{"use strict";n.d(t,{w:()=>o});var r=n(2164),a=n(9554),s=n(8804),i=n(4148);const o=(0,n(7892).op)({floorDiv_:function(e,t){let n=(0,i.YT)(e,"a","floorDiv"),o=(0,i.YT)(t,"b","floorDiv");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(a.ElG,l)}})},7905:(e,t,n)=>{"use strict";n.d(t,{Do:()=>m,XB:()=>f,f2:()=>g,zE:()=>y});var r=n(8805),a=n(3645),s=n(8076),i=n(803),o=n(9855),l=n(5251),u=n(9721),c=n(5583),d=n(4213),h=n(319),p=n(7382);function f(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return(0,i.l)(e,(0,h.P)(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function m(e,t){let n=t;const a=r.getReductionAxes(e.shape,t.shape);return a.length>0&&(n=(0,p.c)(n,a)),(0,c.t)(n,e.shape)}function g(e,t,n,r){if("linear"===t)return e;if("relu"===t)return(0,l.V)(e);if("elu"===t)return(0,a.P)(e);if("relu6"===t)return(0,u.j)(e);if("prelu"===t)return(0,o.N)(e,n);if("leakyrelu"===t)return(0,s.H)(e,r);if("sigmoid"===t)return(0,d.r)(e);throw new Error(`Unknown fused activation ${t}.`)}const y=(e,t)=>!(e>0)||"linear"===t},6178:(e,t,n)=>{"use strict";n.d(t,{k:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const o={x:(0,s.YT)(e,"x","gather"),indices:(0,s.YT)(t,"indices","gather","int32")},l={axis:n,batchDims:i};return r.T2.runKernel(a.mxL,o,l)}})},2759:(e,t,n)=>{"use strict";n.d(t,{r:()=>l});var r=n(2164),a=n(9554),s=n(8804),i=n(4148),o=n(8805);const l=(0,n(7892).op)({greater_:function(e,t){let n=(0,i.YT)(e,"a","greater","string_or_numeric"),l=(0,i.YT)(t,"b","greater","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(a.XhZ,u)}})},9996:(e,t,n)=>{"use strict";n.d(t,{D:()=>l});var r=n(2164),a=n(9554),s=n(8804),i=n(4148),o=n(8805);const l=(0,n(7892).op)({greaterEqual_:function(e,t){let n=(0,i.YT)(e,"a","greaterEqual","string_or_numeric"),l=(0,i.YT)(t,"b","greaterEqual","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(a.lLS,u)}})},1047:(e,t,n)=>{"use strict";n.d(t,{n:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({imag_:function(e){const t={input:(0,s.YT)(e,"input","imag")};return r.T2.runKernel(a.dv8,t)}})},2214:(e,t,n)=>{"use strict";n.d(t,{v:()=>u});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(7892),l=n(5583);const u=(0,o.op)({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const u=(0,s.YT)(e,"images","resizeBilinear");i.vA(3===u.rank||4===u.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${u.rank}.`)),i.vA(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),i.vA(!1===o||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let c=u,d=!1;3===u.rank&&(d=!0,c=(0,l.t)(u,[1,u.shape[0],u.shape[1],u.shape[2]]));const[]=t,h={images:c},p={alignCorners:n,halfPixelCenters:o,size:t},f=r.T2.runKernel(a.hgw,h,p);return d?(0,l.t)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},2823:(e,t,n)=>{"use strict";n.d(t,{b:()=>u});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(7892),l=n(5583);const u=(0,o.op)({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const u=(0,s.YT)(e,"images","resizeNearestNeighbor");i.vA(3===u.rank||4===u.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${u.rank}.`)),i.vA(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),i.vA("float32"===u.dtype||"int32"===u.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),i.vA(!1===o||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let c=u,d=!1;3===u.rank&&(d=!0,c=(0,l.t)(u,[1,u.shape[0],u.shape[1],u.shape[2]]));const[]=t,h={images:c},p={alignCorners:n,halfPixelCenters:o,size:t},f=r.T2.runKernel(a.jOE,h,p);return d?(0,l.t)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},9027:(e,t,n)=>{"use strict";n.d(t,{M:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({isFinite_:function(e){const t={x:(0,s.YT)(e,"x","isFinite")};return r.T2.runKernel(a.gIW,t)}})},6005:(e,t,n)=>{"use strict";n.d(t,{E:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({isInf_:function(e){const t={x:(0,s.YT)(e,"x","isInf")};return r.T2.runKernel(a.E3$,t)}})},3467:(e,t,n)=>{"use strict";n.d(t,{y:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({isNaN_:function(e){const t={x:(0,s.YT)(e,"x","isNaN")};return r.T2.runKernel(a.iPs,t)}})},8076:(e,t,n)=>{"use strict";n.d(t,{H:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:(0,s.YT)(e,"x","leakyRelu")},i={alpha:t};return r.T2.runKernel(a.X0$,n,i)}})},8320:(e,t,n)=>{"use strict";n.d(t,{M:()=>l});var r=n(2164),a=n(9554),s=n(8804),i=n(4148),o=n(8805);const l=(0,n(7892).op)({less_:function(e,t){let n=(0,i.YT)(e,"a","less","string_or_numeric"),l=(0,i.YT)(t,"b","less","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(a.mIA,u)}})},827:(e,t,n)=>{"use strict";n.d(t,{I:()=>l});var r=n(2164),a=n(9554),s=n(8804),i=n(4148),o=n(8805);const l=(0,n(7892).op)({lessEqual_:function(e,t){let n=(0,i.YT)(e,"a","lessEqual","string_or_numeric"),l=(0,i.YT)(t,"b","lessEqual","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(a.CwD,u)}})},6584:(e,t,n)=>{"use strict";n.d(t,{K:()=>u});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(7892),l=n(5583);const u=(0,o.op)({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const c=(0,s.YT)(e,"x","localResponseNormalization");i.vA(4===c.rank||3===c.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${c.rank}.`)),i.vA(i.E6(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let d=c,h=!1;3===c.rank&&(h=!0,d=(0,l.t)(c,[1,c.shape[0],c.shape[1],c.shape[2]]));const p={x:d},f={depthRadius:t,bias:n,alpha:o,beta:u},m=r.T2.runKernel(a.jM4,p,f);return h?(0,l.t)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},5911:(e,t,n)=>{"use strict";n.d(t,{R:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({log_:function(e){const t={x:(0,s.YT)(e,"x","log","float32")};return r.T2.runKernel(a.tG8,t)}})},1386:(e,t,n)=>{"use strict";n.d(t,{K:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({log1p_:function(e){const t={x:(0,s.YT)(e,"x","log1p")};return r.T2.runKernel(a.Cg$,t)}})},4824:(e,t,n)=>{"use strict";n.d(t,{n:()=>c});var r=n(1839),a=n(4148),s=n(803),i=n(1011),o=n(7892),l=n(4213),u=n(9973);const c=(0,o.op)({logSigmoid_:function(e){const t=(0,a.YT)(e,"x","logSigmoid");return(0,r._X)((e=>({value:(0,i.H)((0,u.l)((0,i.H)(e))),gradFunc:t=>(0,s.l)(t,(0,l.r)((0,i.H)(e)))})))(t)}})},1194:(e,t,n)=>{"use strict";n.d(t,{H:()=>p});var r=n(1839),a=n(4148),s=n(7794),i=n(5462),o=n(5911),l=n(891),u=n(803),c=n(7892),d=n(7951),h=n(7382);const p=(0,c.op)({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=(0,a.YT)(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return(0,r._X)(((e,n)=>{const r=(0,l.T)(e,t,!0),a=(0,d.j)(e,r),c=(0,d.j)((0,s.w)(a,"float32"),(0,o.R)((0,h.c)((0,i.o)(a),t,!0)));n([c]);return{value:c,gradFunc:(e,n)=>{const[r]=n,a=(0,i.o)(r);return(0,d.j)(e,(0,u.l)((0,h.c)(e,t,!0),a))}}}))(n)}})},2175:(e,t,n)=>{"use strict";n.d(t,{V:()=>f});var r=n(4148),a=n(1426),s=n(7242),i=n(9235),o=n(5462),l=n(5911),u=n(891),c=n(7892),d=n(5583),h=n(7951),p=n(7382);const f=(0,c.op)({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const c=(0,r.YT)(e,"x","logSumExp"),f=(0,a.Y6)(t,c.shape),m=(0,u.T)(c,f,!0),g=(0,h.j)(c,m),y=(0,o.o)(g),b=(0,p.c)(y,f),v=(0,l.R)(b),x=(0,s.W)((0,d.t)(m,v.shape),v);if(n){const e=(0,i.SM)(x.shape,f);return(0,d.t)(x,e)}return x}})},5692:(e,t,n)=>{"use strict";n.d(t,{n:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(8805);const o=(0,n(7892).op)({logicalAnd_:function(e,t){const n=(0,s.YT)(e,"a","logicalAnd","bool"),o=(0,s.YT)(t,"b","logicalAnd","bool");(0,i.assertAndGetBroadcastShape)(n.shape,o.shape);const l={a:n,b:o};return r.T2.runKernel(a.RUm,l)}})},5344:(e,t,n)=>{"use strict";n.d(t,{N:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({logicalNot_:function(e){const t={x:(0,s.YT)(e,"x","logicalNot","bool")};return r.T2.runKernel(a.nZd,t)}})},7920:(e,t,n)=>{"use strict";n.d(t,{z:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(8805);const o=(0,n(7892).op)({logicalOr_:function(e,t){const n=(0,s.YT)(e,"a","logicalOr","bool"),o=(0,s.YT)(t,"b","logicalOr","bool");(0,i.assertAndGetBroadcastShape)(n.shape,o.shape);const l={a:n,b:o};return r.T2.runKernel(a.LXA,l)}})},3708:(e,t,n)=>{"use strict";n.d(t,{r:()=>l});var r=n(4148),a=n(8805),s=n(5692),i=n(5344),o=n(7920);const l=(0,n(7892).op)({logicalXor_:function(e,t){const n=(0,r.YT)(e,"a","logicalXor","bool"),l=(0,r.YT)(t,"b","logicalXor","bool");return(0,a.assertAndGetBroadcastShape)(n.shape,l.shape),(0,s.n)((0,o.z)(e,t),(0,i.N)((0,s.n)(e,t)))}})},1667:(e,t,n)=>{"use strict";var r;n.d(t,{i:()=>r}),function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(r||(r={}))},5162:(e,t,n)=>{"use strict";n.d(t,{N:()=>o});var r=n(2164),a=n(9554),s=n(8804),i=n(4148);const o=(0,n(7892).op)({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]&&arguments[3],l=(0,i.YT)(e,"a","matMul"),u=(0,i.YT)(t,"b","matMul");[l,u]=(0,s.makeTypesMatch)(l,u);const c={a:l,b:u},d={transposeA:n,transposeB:o};return r.T2.runKernel(a.jAQ,c,d)}})},891:(e,t,n)=>{"use strict";n.d(t,{T:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i={x:(0,s.YT)(e,"x","max")},o={reductionIndices:t,keepDims:n};return r.T2.runKernel(a.VAI,i,o)}})},6044:(e,t,n)=>{"use strict";n.d(t,{j:()=>c});var r=n(2164),a=n(9554),s=n(4148),i=n(1426),o=n(7538),l=n(7892),u=n(5583);const c=(0,l.op)({maxPool_:function(e,t,n,l,c){const d=(0,s.YT)(e,"x","maxPool");let h=d,p=!1;3===d.rank&&(p=!0,h=(0,u.t)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),i.vA(4===h.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${h.rank}.`)),i.vA(o.G0(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),o.s_("maxPool",l,c);const f={x:h},m={filterSize:t,strides:n,pad:l,dimRoundingMode:c},g=r.T2.runKernel(a.t3d,f,m);return p?(0,u.t)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}})},2131:(e,t,n)=>{"use strict";n.d(t,{P:()=>u});var r=n(2164),a=n(9554),s=n(8804),i=n(4148),o=n(8805),l=n(7794);const u=(0,n(7892).op)({maximum_:function(e,t){let n=(0,i.YT)(e,"a","maximum"),u=(0,i.YT)(t,"b","maximum");[n,u]=(0,s.makeTypesMatch)(n,u),"bool"===n.dtype&&(n=(0,l.w)(n,"int32"),u=(0,l.w)(u,"int32")),(0,o.assertAndGetBroadcastShape)(n.shape,u.shape);const c={a:n,b:u};return r.T2.runKernel(a.LDN,c)}})},3015:(e,t,n)=>{"use strict";n.d(t,{i:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i={x:(0,s.YT)(e,"x","mean")},o={axis:t,keepDims:n};return r.T2.runKernel(a.g5A,i,o)}})},1465:(e,t,n)=>{"use strict";n.d(t,{j:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i={x:(0,s.YT)(e,"x","min")},o={axis:t,keepDims:n};return r.T2.runKernel(a.lNG,i,o)}})},6561:(e,t,n)=>{"use strict";n.d(t,{B:()=>u});var r=n(2164),a=n(9554),s=n(8804),i=n(4148),o=n(8805),l=n(7794);const u=(0,n(7892).op)({minimum_:function(e,t){let n=(0,i.YT)(e,"a","minimum"),u=(0,i.YT)(t,"b","minimum");[n,u]=(0,s.makeTypesMatch)(n,u),"bool"===n.dtype&&(n=(0,l.w)(n,"int32"),u=(0,l.w)(u,"int32")),(0,o.assertAndGetBroadcastShape)(n.shape,u.shape);const c={a:n,b:u};return r.T2.runKernel(a.LG0,c)}})},4252:(e,t,n)=>{"use strict";n.d(t,{F:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({mirrorPad_:function(e,t,n){i.vA("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const o=(0,s.YT)(e,"x","mirrorPad");if(0===o.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");i.vA(t.length===o.rank,(()=>`Padding doesn't match input. Must be ${o.rank}. Got ${t.length}.`));const l="reflect"===n?1:0;for(let r=0;r<o.rank;r++)i.vA(2===t[r].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),i.vA(t[r][0]>=0&&t[r][0]<=o.shape[r]-l&&t[r][1]>=0&&t[r][1]<=o.shape[r]-l,(()=>`Padding in dimension ${r} cannot be greater than or equal to ${o.shape[r]-l} or less than 0 for input of shape ${o.shape}`));const u={paddings:t,mode:n},c={x:o};return r.T2.runKernel(a.x7F,c,u)}})},3617:(e,t,n)=>{"use strict";n.d(t,{z:()=>o});var r=n(2164),a=n(9554),s=n(8804),i=n(4148);const o=(0,n(7892).op)({mod_:function(e,t){let n=(0,i.YT)(e,"a","mod"),o=(0,i.YT)(t,"b","mod");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(a.BLA,l)}})},803:(e,t,n)=>{"use strict";n.d(t,{l:()=>o});var r=n(2164),a=n(9554),s=n(8804),i=n(4148);const o=(0,n(7892).op)({mul_:function(e,t){let n=(0,i.YT)(e,"a","mul"),o=(0,i.YT)(t,"b","mul");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(a.xu7,l)}})},1011:(e,t,n)=>{"use strict";n.d(t,{H:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({neg_:function(e){const t={x:(0,s.YT)(e,"x","neg")};return r.T2.runKernel(a.l0G,t)}})},2155:(e,t,n)=>{"use strict";n.d(t,{x:()=>y});var r=n(4148),a=n(1426),s=n(3753),i=n(9235),o=n(891),l=n(1465),u=n(7892),c=n(7587),d=n(5583),h=n(1997),p=n(191),f=n(7738),m=n(7382);function g(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return(0,s.t)(e);if(1!==e.rank&&null===n)return g((0,d.t)(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return(0,m.c)((0,s.t)(e),n);if(t===1/0)return(0,o.T)((0,s.t)(e),n);if(t===-1/0)return(0,l.j)((0,s.t)(e),n);if("euclidean"===t||2===t)return(0,p.R)((0,m.c)((0,c.n)((0,s.t)(e),(0,h.d)(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return(0,o.T)((0,m.c)((0,s.t)(e),n[0]),n[1]-1);if(t===1/0)return(0,o.T)((0,m.c)((0,s.t)(e),n[1]),n[0]);if(t===-1/0)return(0,l.j)((0,m.c)((0,s.t)(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return(0,p.R)((0,m.c)((0,f.E)(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const y=(0,u.op)({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const o=g(e=(0,r.YT)(e,"x","norm"),t,n);let l=o.shape;if(s){const t=(0,a.Y6)(n,e.shape);l=i.SM(o.shape,t)}return(0,d.t)(o,l)}})},135:(e,t,n)=>{"use strict";n.d(t,{E:()=>l});var r=n(2164),a=n(9554),s=n(8804),i=n(4148),o=n(8805);const l=(0,n(7892).op)({notEqual_:function(e,t){let n=(0,i.YT)(e,"a","notEqual","string_or_numeric"),l=(0,i.YT)(t,"b","notEqual","string_or_numeric");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(a.ylV,u)}})},9246:(e,t,n)=>{"use strict";n.d(t,{M:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const l={indices:(0,s.YT)(e,"indices","oneHot","int32")},u={dtype:o,depth:t,onValue:n,offValue:i};return r.T2.runKernel(a.urI,l,u)}})},4616:(e,t,n)=>{"use strict";n.d(t,{S:()=>o});var r=n(2164),a=n(1426),s=n(6149),i=n(4218);function o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if((0,a.SA)(e),"complex64"===t){const t=o(e,"float32"),n=(0,i.U)(e,"float32");return(0,s.f)(t,n)}const n=(0,a.FZ)((0,a.Ze)(e),t);return r.T2.makeTensor(n,e,t)}},4100:(e,t,n)=>{"use strict";n.d(t,{P:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({onesLike_:function(e){const t={x:(0,s.YT)(e,"x","onesLike")};return r.T2.runKernel(a.LWX,t)}})},7892:(e,t,n)=>{"use strict";n.d(t,{B:()=>s,op:()=>i});var r=n(2164),a=n(1426);const s="__op";function i(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const i=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=s;const o=function(){r.T2.startScope(n);try{const e=i(...arguments);return(0,a.yL)(e)&&console.error("Cannot return a Promise inside of tidy."),r.T2.endScope(e),e}catch(e){throw r.T2.endScope(null),e}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}},9249:(e,t,n)=>{"use strict";n.d(t,{BTT:()=>h.B,tnl:()=>a.t,HQu:()=>s.H,FqL:()=>i.F,WQq:()=>o.W,QiD:()=>p,Q7R:()=>f.Q,bzn:()=>m.b,FLi:()=>g.F,XRg:()=>y.X,qRo:()=>b.q,yHs:()=>v.y,rYl:()=>x.r,FPz:()=>w.F,rfv:()=>k.r,$jT:()=>S.$,sub:()=>C,lZX:()=>M,$v7:()=>O.$,BFc:()=>P,kSi:()=>L,T5N:()=>z,GTe:()=>F.G,HbZ:()=>B,vjT:()=>V,ftb:()=>nr,ROE:()=>W,hOW:()=>U.h,ra8:()=>j.r,wgE:()=>I.w,mkO:()=>G.m,zQh:()=>H.z,o8B:()=>q.o,faB:()=>K.f,xWs:()=>A.x,I1m:()=>Y,RPU:()=>X,O5O:()=>Q,P1l:()=>Z,kA9:()=>J.k,Xtf:()=>ee.X,wX9:()=>te.w,IPL:()=>ne,jIJ:()=>ae,gnS:()=>se.g,yIG:()=>ie.y,_jP:()=>hr,Lp0:()=>oe.L,rCv:()=>le.r,aOp:()=>ue,Rj8:()=>ce.R,Gl3:()=>de.G,smy:()=>he,X7t:()=>pe.X,y4m:()=>fe.y,ek5:()=>me.e,Omf:()=>ge.O,EZY:()=>cr,_3C:()=>ye,Pqc:()=>be.P,FJY:()=>dr,QP2:()=>ve,LCg:()=>xe.L,Y12:()=>we.Y,p4S:()=>ke.p,oNF:()=>Se.o,UG6:()=>Ie.U,IYd:()=>Te.I,y5U:()=>Ce,hVP:()=>wn.h,GSj:()=>Ae.G,RIf:()=>Ee.R,wh_:()=>_e.w,cZk:()=>r,kgh:()=>$e.k,SY9:()=>ur,rhj:()=>Re.r,DQN:()=>De.D,KGM:()=>kn.K,ngS:()=>Me.n,Slp:()=>ga,U4u:()=>pr,ggX:()=>Sn.g,MIs:()=>Fe.M,EN4:()=>Oe.E,yrW:()=>Pe.y,H8d:()=>Le.H,M7h:()=>ze.M,InN:()=>Be.I,mPL:()=>ya,mT8:()=>Ve,Kgs:()=>We.K,Rm2:()=>Ue.R,Kko:()=>je.K,nqI:()=>Ge.n,HPB:()=>He.H,VZ:()=>qe.V,n76:()=>Ke.n,NSZ:()=>Ye.N,ztW:()=>Xe.z,rxB:()=>Qe.r,YYh:()=>ba,yzS:()=>et,NoW:()=>E.N,T9B:()=>tt.T,jgi:()=>nt.j,NYV:()=>rt,RO:()=>at,PhQ:()=>st.P,i2o:()=>it.i,OYQ:()=>ut,jkA:()=>ct.j,BpO:()=>dt.B,FFZ:()=>ht.F,ziu:()=>pt.z,Clk:()=>yt,CRk:()=>ir,lKK:()=>_.l,YDF:()=>bt,OjQ:()=>vt,HZy:()=>xt.H,xbf:()=>ar.x,Ec:()=>wt.E,Mw0:()=>kt.M,SaS:()=>ot.S,P61:()=>St.P,op:()=>h.op,X4o:()=>It,eVF:()=>Tt.e,BZs:()=>Nt,grY:()=>Ct,XHu:()=>At,WLX:()=>Et,dzn:()=>_t.d,n7C:()=>$t.n,NsG:()=>Rt.N,yyV:()=>Dt.y,_eU:()=>Mt._,whe:()=>Ft,iyU:()=>Ot,Q0_:()=>Pt,_9M:()=>Lt,pR9:()=>Ut,FE$:()=>jt,m0H:()=>Gt,YeY:()=>Ht,HYA:()=>qt,y17:()=>Kt,xav:()=>Yt.x,VOZ:()=>Xt.V,VVh:()=>Qt.V,j__:()=>Zt.j,tQQ:()=>N.t,BEg:()=>Jt.B,QD2:()=>en,LMr:()=>tn,I2l:()=>nn,JYU:()=>rn,z8$:()=>In.z,LIG:()=>an.L,Z$r:()=>sn.Z,d_2:()=>on.d,NFr:()=>or,sZg:()=>Je,WfX:()=>ln.W,wdz:()=>un.w,F12:()=>cn,ry7:()=>$.r,_SZ:()=>dn._,vPA:()=>ma,F8e:()=>hn.F,L0l:()=>pn.L,dik:()=>R.d,Q$M:()=>fn,zAd:()=>mn,wck:()=>gn,R0O:()=>yn,Vs9:()=>bn.V,lw0:()=>vn.l,eDJ:()=>xn.e,lMo:()=>va,Zhr:()=>lr,lOn:()=>fa,lDo:()=>Tn.l,RZD:()=>Nn.R,EwI:()=>mt.E,Pbu:()=>Cn.P,r2V:()=>An.r,t$z:()=>En.t,PMw:()=>_n.P,Ym9:()=>$n.Y,YjP:()=>xa,jbE:()=>gt.j,czq:()=>Rn.c,Mlm:()=>Dn.M,ymU:()=>D.y,OEK:()=>Mn.O,tGX:()=>On,KtR:()=>Pn,$_$:()=>Ln.$,g9W:()=>zn,Lpo:()=>Bn,yxw:()=>Vn,NNh:()=>Un,Vsq:()=>Ne.V,rfw:()=>jn.r,mgz:()=>rr.m,efE:()=>Gn,AmM:()=>Hn.A,zAU:()=>qn.z,K$i:()=>Kn.K,rni:()=>Yn,bvq:()=>Xn,_M9:()=>Qn._,YJN:()=>Jn,Ul9:()=>er.U,POl:()=>tr.P});var r={};n.r(r),n.d(r,{conv2d:()=>vr,depthwiseConv2d:()=>kr,matMul:()=>Sr});var a=n(3753),s=n(4759),i=n(983),o=n(7242),l=n(2164),u=n(9554),c=n(4148),d=n(1426),h=n(7892);const p=(0,h.op)({addN_:function(e){d.vA(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),d.vA(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>(0,c.YT)(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!d.r1(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return l.T2.runKernel(u.EkD,r)}});var f=n(1802),m=n(1819),g=n(3068),y=n(8482),b=n(3010),v=n(6464),x=n(7803),w=n(6349),k=n(8147),S=n(8650),I=n(7794),T=n(7538),N=n(5583);const C=(0,h.op)({avgPool3d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=(0,c.YT)(e,"x","avgPool3d","float32");let o=i,h=!1;4===i.rank&&(h=!0,o=(0,N.t)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),d.vA(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),d.vA("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),d.vA("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),(0,T.s_)("avgPool3d",r,a);const p={x:o},f={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s};let m=l.T2.runKernel(u.cS,p,f);return m=(0,I.w)(m,o.dtype),h?(0,N.t)(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}});var A=n(4429),E=n(5162),_=n(803),$=n(4213),R=n(463),D=n(6532);const M=(0,h.op)({basicLSTMCell_:function(e,t,n,r,a,s){const i=(0,c.YT)(e,"forgetBias","basicLSTMCell"),l=(0,c.YT)(t,"lstmKernel","basicLSTMCell"),u=(0,c.YT)(n,"lstmBias","basicLSTMCell"),d=(0,c.YT)(r,"data","basicLSTMCell"),h=(0,c.YT)(a,"c","basicLSTMCell"),p=(0,c.YT)(s,"h","basicLSTMCell"),f=(0,A.x)([d,p],1),m=(0,E.N)(f,l),g=(0,o.W)(m,u),y=g.shape[0],b=g.shape[1]/4,v=[y,b],x=(0,R.d)(g,[0,0],v),w=(0,R.d)(g,[0,b],v),k=(0,R.d)(g,[0,2*b],v),S=(0,R.d)(g,[0,3*b],v),I=(0,o.W)((0,_.l)((0,$.r)(x),(0,D.y)(w)),(0,_.l)(h,(0,$.r)((0,o.W)(i,k))));return[I,(0,_.l)((0,D.y)(I),(0,$.r)(S))]}});var F=n(2557),O=n(9618);const P=(0,h.op)({batchNorm2d_:function(e,t,n,r,a,s){const i=(0,c.YT)(e,"x","batchNorm"),o=(0,c.YT)(t,"mean","batchNorm"),l=(0,c.YT)(n,"variance","batchNorm");let u,h;return null!=a&&(u=(0,c.YT)(a,"scale","batchNorm")),null!=r&&(h=(0,c.YT)(r,"offset","batchNorm")),d.vA(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),d.vA(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),d.vA(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&d.vA(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=h&&d.vA(2===h.rank||1===h.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`)),(0,O.$)(i,o,l,h,u,s)}});const L=(0,h.op)({batchNorm3d_:function(e,t,n,r,a,s){const i=(0,c.YT)(e,"x","batchNorm"),o=(0,c.YT)(t,"mean","batchNorm"),l=(0,c.YT)(n,"variance","batchNorm");let u,h;return null!=a&&(u=(0,c.YT)(a,"scale","batchNorm")),null!=r&&(h=(0,c.YT)(r,"offset","batchNorm")),d.vA(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),d.vA(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),d.vA(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&d.vA(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=h&&d.vA(3===h.rank||1===h.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`)),(0,O.$)(i,o,l,h,u,s)}});const z=(0,h.op)({batchNorm4d_:function(e,t,n,r,a,s){const i=(0,c.YT)(e,"x","batchNorm"),o=(0,c.YT)(t,"mean","batchNorm"),l=(0,c.YT)(n,"variance","batchNorm");let u,h;return null!=a&&(u=(0,c.YT)(a,"scale","batchNorm")),null!=r&&(h=(0,c.YT)(r,"offset","batchNorm")),d.vA(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),d.vA(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),d.vA(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&d.vA(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=h&&d.vA(4===h.rank||1===h.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`)),(0,O.$)(i,o,l,h,u,s)}});const B=(0,h.op)({bincount_:function(e,t,n){const r=(0,c.YT)(e,"x","bincount"),a=(0,c.YT)(t,"weights","bincount");d.vA("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),d.vA(n>=0,(()=>`size must be non-negative, but got ${n}.`)),d.vA(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));const s={x:r,weights:a},i={size:n};return l.T2.runKernel(u.N4F,s,i)}});const V=(0,h.op)({bitwiseAnd_:function(e,t){const n=(0,c.YT)(e,"x","bitwiseAnd"),r=(0,c.YT)(t,"y","bitwiseAnd");if(!(0,d.r1)(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const a={a:n,b:r};return l.T2.runKernel(u.HNs,a)}});const W=(0,h.op)({broadcastArgs_:function(e,t){const n=(0,c.YT)(e,"s0","broadcastArgs","int32"),r=(0,c.YT)(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const a={s0:n,s1:r};return l.T2.runKernel(u.vj7,a)}});var U=n(4920),j=n(259),G=n(5396),H=n(3829),q=n(9820),K=n(6149);const Y=(0,h.op)({concat1d_:function(e){return(0,A.x)(e,0)}});const X=(0,h.op)({concat2d_:function(e,t){return(0,A.x)(e,t)}});const Q=(0,h.op)({concat3d_:function(e,t){return(0,A.x)(e,t)}});const Z=(0,h.op)({concat4d_:function(e,t){return(0,A.x)(e,t)}});var J=n(9870),ee=n(4969),te=n(1137);const ne=(0,h.op)({conv3d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=(0,c.YT)(e,"x","conv3d"),o=(0,c.YT)(t,"filter","conv3d");let h=i,p=!1;4===i.rank&&(p=!0,h=(0,N.t)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),d.vA(5===h.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${h.rank}.`)),d.vA(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),d.vA(h.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${h.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),d.vA((0,T.G0)(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),d.vA("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),d.vA((0,T.qk)(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),d.vA((0,T.qk)(n),(()=>"Error in conv3D: Strides should be larger than 0."));const f={x:h,filter:o},m={strides:n,pad:r,dataFormat:a,dilations:s},g=l.T2.runKernel(u.A1h,f,m);return p?(0,N.t)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}});var re=n(6410);const ae=(0,h.op)({conv3dTranspose_:function(e,t,n,r,a){const s=(0,c.YT)(e,"x","conv3dTranspose"),i=(0,c.YT)(t,"filter","conv3dTranspose");return(0,re.c)(n,s,i,r,a)}});var se=n(5894),ie=n(1164),oe=n(3739),le=n(7167);const ue=(0,h.op)({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=(0,c.YT)(e,"x","denseBincount"),s=(0,c.YT)(t,"weights","denseBincount");d.vA("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),d.vA(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),d.vA(n>=0,(()=>`size must be non-negative, but got ${n}.`)),d.vA(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));const i={x:a,weights:s},o={size:n,binaryOutput:r};return l.T2.runKernel(u.wNW,i,o)}});var ce=n(1719),de=n(9899);const he=(0,h.op)({diag_:function(e){const t={x:(0,c.YT)(e,"x","diag")};return l.T2.runKernel(u.ORI,t)}});var pe=n(3789),fe=n(4974),me=n(44),ge=n(6434);const ye=(0,h.op)({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(((e,t)=>(0,c.YT)(e,`tensors${t}`,"einsum"))),s={equation:e};return l.T2.runKernel(u.Qgm,a,s)}});var be=n(3645);const ve=(0,h.op)({ensureShape_:function(e,t){const n=(0,c.YT)(e,"x","ensureShape","string_or_numeric");if(!(0,d.e_)(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});var xe=n(7457),we=n(8810),ke=n(8826),Se=n(5462),Ie=n(4023),Te=n(2520),Ne=n(3017);const Ce=(0,h.op)({eye_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";null==t&&(t=e);const a=(0,j.r)([e,t],r),s=e<=t?e:t;for(let o=0;o<s;++o)a.set(1,o,o);const i=(0,N.t)(a.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return(0,Ne.V)((0,Ie.U)(i,0),[n[0],1,1]);if(2===n.length)return(0,Ne.V)((0,Ie.U)((0,Ie.U)(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return(0,Ne.V)((0,Ie.U)((0,Ie.U)((0,Ie.U)(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var Ae=n(4660),Ee=n(8587),_e=n(3612),$e=n(6178),Re=n(2759),De=n(9996),Me=n(1047),Fe=n(9027),Oe=n(6005),Pe=n(3467),Le=n(8076),ze=n(8320),Be=n(827);function Ve(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return l.T2.runKernel(u.mnI,{},r)}var We=n(6584),Ue=n(5911),je=n(1386),Ge=n(4824),He=n(1194),qe=n(2175),Ke=n(5692),Ye=n(5344),Xe=n(7920),Qe=n(3708);const Ze=2147483648;const Je=(0,h.op)({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const r=(0,c.YT)(e,"sortedSequence","searchSorted"),a=(0,c.YT)(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=(0,N.t)(r,[-1,s]),h=(0,N.t)(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==h.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,d.Ze)(h.shape)>=Ze)throw new Error("values tensor size must less than 2147483648");if(o.shape[1]>=Ze)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);const p={sortedSequence:o,values:h},f={side:n};return l.T2.runKernel(u.uWl,p,f)}});function et(e,t){return Je(e,t,"left")}var tt=n(891),nt=n(6044);const rt=(0,h.op)({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=(0,c.YT)(e,"x","maxPool3d");let o=i,h=!1;4===i.rank&&(h=!0,o=(0,N.t)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),d.vA(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),d.vA("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),(0,T.s_)("maxPool3d",r,a);const p={x:o},f={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},m=l.T2.runKernel(u.ySp,p,f);return h?(0,N.t)(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}});const at=(0,h.op)({maxPoolWithArgmax_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const s={x:(0,c.YT)(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=l.T2.runKernel(u.TL8,s,i);return{result:o[0],indexes:o[1]}}});var st=n(2131),it=n(3015),ot=n(4616),lt=n(9494);function ut(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=(0,c.YT)(e,"x","meshgrid",e instanceof lt.qY?e.dtype:"float32");if(void 0===t)return[r];let a=(0,c.YT)(t,"y","meshgrid",t instanceof lt.qY?t.dtype:"float32");const s=(0,d.Ze)(r.shape),i=(0,d.Ze)(a.shape);return"xy"===n?(r=(0,N.t)(r,[1,-1]),a=(0,N.t)(a,[-1,1]),[(0,E.N)((0,ot.S)([i,1],r.dtype),r),(0,E.N)(a,(0,ot.S)([1,s],a.dtype))]):(r=(0,N.t)(r,[-1,1]),a=(0,N.t)(a,[1,-1]),[(0,E.N)(r,(0,ot.S)([1,i],r.dtype)),(0,E.N)((0,ot.S)([s,1],a.dtype),a)])}var ct=n(1465),dt=n(6561),ht=n(4252),pt=n(3617),ft=n(9235),mt=n(7738),gt=n(7951);const yt=(0,h.op)({moments_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];e=(0,c.YT)(e,"x","moments");const r=(0,d.Y6)(t,e.shape),a=(0,it.i)(e,r,n);let s=a.shape;n||(s=(0,ft.SM)(a.shape,r));const i=(0,mt.E)((0,gt.j)((0,I.w)(e,"float32"),(0,N.t)(a,s)));return{mean:a,variance:(0,it.i)(i,r,n)}}});const bt=(0,h.op)({multiRNNCell_:function(e,t,n,r){const a=(0,c.YT)(t,"data","multiRNNCell"),s=(0,c.j1)(n,"c","multiRNNCell"),i=(0,c.j1)(r,"h","multiRNNCell");let o=a;const l=[];for(let c=0;c<e.length;c++){const t=e[c](o,s[c],i[c]);l.push(t[0]),l.push(t[1]),o=t[1]}const u=[],d=[];for(let c=0;c<l.length;c+=2)u.push(l[c]),d.push(l[c+1]);return[u,d]}});const vt=(0,h.op)({multinomial_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=(0,c.YT)(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?(0,N.t)(a,[1,-1]):a},d={numSamples:t,seed:n,normalized:r},h=l.T2.runKernel(u.WT3,o,d);return 1===i?(0,N.t)(h,[h.size]):h}});var xt=n(1011),wt=n(135),kt=n(9246),St=n(4100);const It=(0,h.op)({outerProduct_:function(e,t){const n=(0,c.YT)(e,"v1","outerProduct"),r=(0,c.YT)(t,"v2","outerProduct");d.vA(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const a=(0,N.t)(n,[-1,1]),s=(0,N.t)(r,[1,-1]);return(0,E.N)(a,s)}});var Tt=n(5048);const Nt=(0,h.op)({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return(0,d.vA)(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),(0,Tt.e)(e,[t],n)}});const Ct=(0,h.op)({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return(0,d.vA)(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,Tt.e)(e,t,n)}});const At=(0,h.op)({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return(0,d.vA)(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,Tt.e)(e,t,n)}});const Et=(0,h.op)({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return(0,d.vA)(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),(0,Tt.e)(e,t,n)}});var _t=n(7751),$t=n(7587),Rt=n(9855),Dt=n(6574),Mt=n(9556);const Ft=(0,h.op)({raggedGather_:function(e,t,n,r){const a={paramsNestedSplits:e.map(((e,t)=>(0,c.YT)(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:(0,c.YT)(t,"paramsDenseValues","raggedGather"),indices:(0,c.YT)(n,"indices","raggedGather","int32")},s={outputRaggedRank:r},i=l.T2.runKernel(u.oJ2,a,s);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const Ot=(0,h.op)({raggedRange_:function(e,t,n){const r=(0,c.YT)(e,"starts","raggedRange"),a={starts:r,limits:(0,c.YT)(t,"limits","raggedRange",r.dtype),deltas:(0,c.YT)(n,"deltas","raggedRange",r.dtype)},s=l.T2.runKernel(u.CQC,a);return{rtNestedSplits:s[0],rtDenseValues:s[1]}}});const Pt=(0,h.op)({raggedTensorToTensor_:function(e,t,n,r,a){const s=(0,c.YT)(e,"shape","raggedTensorToTensor","int32"),i=(0,c.YT)(t,"values","raggedTensorToTensor"),o={shape:s,values:i,defaultValue:(0,c.YT)(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>(0,c.YT)(e,`tensors${t}`,"raggedTensorToTensor","int32")))},d={rowPartitionTypes:a};return l.T2.runKernel(u.mH5,o,d)}});const Lt=(0,h.op)({rand_:function(e,t,n){(0,d.SA)(e);const r=(0,d.Ze)(e);let a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let s=0;s<r;s++)a[s]=t();return l.T2.makeTensor(a,e,n)}});var zt=n(4334);class Bt{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=a||Math.random();this.random=zt.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);const i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Vt{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const a=r||Math.random();this.randu=zt.alea(a.toString()),this.randn=new Bt(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class Wt{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=zt.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Ut=(0,h.op)({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;if((0,d.SA)(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const s=new Vt(t,n,r,a),i=(0,j.r)(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const jt=(0,h.op)({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if((0,d.SA)(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const s=new Bt(t,n,r,!1,a),i=(0,j.r)(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});const Gt=(0,h.op)({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return jt(e,0,1,t,n)}});const Ht=(0,h.op)({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;(0,d.SA)(e);const s=(0,j.r)(e,r),i=new Wt(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});const qt=(0,h.op)({randomUniformInt_:function(e,t,n,r){return Ht(e,t,n,"int32",r)}});function Kt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const a={start:e,stop:t,step:n,dtype:r};return l.T2.runKernel(u.Q6t,{},a)}var Yt=n(9477),Xt=n(6309),Qt=n(5251),Zt=n(9721),Jt=n(7419);const en=(0,h.op)({reverse1d_:function(e){const t=(0,c.YT)(e,"x","reverse");return d.vA(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),(0,Jt.B)(t,0)}});const tn=(0,h.op)({reverse2d_:function(e,t){const n=(0,c.YT)(e,"x","reverse");return d.vA(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),(0,Jt.B)(n,t)}});const nn=(0,h.op)({reverse3d_:function(e,t){const n=(0,c.YT)(e,"x","reverse");return d.vA(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),(0,Jt.B)(n,t)}});const rn=(0,h.op)({reverse4d_:function(e,t){const n=(0,c.YT)(e,"x","reverse");return d.vA(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),(0,Jt.B)(n,t)}});var an=n(6509),sn=n(6777),on=n(1997),ln=n(2022),un=n(3117);const cn=async function(e,t){const n=(0,c.YT)(e,"x","setdiff1d"),r=(0,c.YT)(t,"y","setdiff1d");d.vA(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),d.vA(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),d.vA(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const a=await n.data(),s=await r.data(),i=new Set(s);let o=0;for(let c=0;c<a.length;c++)i.has(a[c])||o++;const l=new lt.yl([o],n.dtype),u=new lt.yl([o],"int32");for(let c=0,d=0;c<a.length;c++)i.has(a[c])||(l.values[d]=a[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]};var dn=n(5740),hn=n(9519),pn=n(8143);const fn=(0,h.op)({slice1d_:function(e,t,n){const r=(0,c.YT)(e,"x","slice1d");return d.vA(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),(0,R.d)(r,[t],[n])}});const mn=(0,h.op)({slice2d_:function(e,t,n){const r=(0,c.YT)(e,"x","slice2d");return d.vA(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),(0,R.d)(r,t,n)}});const gn=(0,h.op)({slice3d_:function(e,t,n){const r=(0,c.YT)(e,"x","slice3d");return d.vA(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),(0,R.d)(r,t,n)}});const yn=(0,h.op)({slice4d_:function(e,t,n){const r=(0,c.YT)(e,"x","slice4d");return d.vA(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),(0,R.d)(r,t,n)}});var bn=n(6719),vn=n(9973),xn=n(3585),wn=n(3062),kn=n(1405),Sn=n(7307),In=n(9486),Tn=n(5181),Nn=n(191),Cn=n(208),An=n(613),En=n(901),_n=n(319),$n=n(1231),Rn=n(7382),Dn=n(4894),Mn=n(8032),Fn=n(9914);function On(e,t){(0,d.HO)(e);const n=(0,c.MZ)(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,Fn.Q)(e,null,n,t)}function Pn(e,t,n){if((0,d.HO)(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=(0,c.MZ)(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,Fn.Q)(e,t,r,n)}var Ln=n(5395);function zn(e,t,n){if((0,d.HO)(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=(0,c.MZ)(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,Fn.Q)(e,t,r,n)}function Bn(e,t,n){if((0,d.HO)(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=(0,c.MZ)(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,Fn.Q)(e,t,r,n)}function Vn(e,t,n){if((0,d.HO)(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=(0,c.MZ)(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,(0,Fn.Q)(e,t,r,n)}var Wn=n(4083);const Un=(0,h.op)({tensorScatterUpdate_:function(e,t,n){const r=(0,c.YT)(e,"tensor","tensorScatterupdate"),a=(0,c.YT)(t,"indices","tensorScatterupdate","int32"),s=(0,c.YT)(n,"updates","tensorScatterupdate");if(Wn.validateInput(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);const i={tensor:r,indices:a,updates:s};return l.T2.runKernel(u.X4r,i,{})}});var jn=n(2765);const Gn=(0,h.op)({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if((0,d.SA)(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const s=new Bt(t,n,r,!0,a),i=(0,j.r)(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var Hn=n(9694),qn=n(5149),Kn=n(3984);function Yn(e,t){return Je(e,t,"right")}function Xn(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return l.T2.makeVariable(e,t,n,r)}var Qn=n(3986),Zn=n(9286);const Jn=async function(e){const t=(0,c.YT)(e,"condition","whereAsync","bool"),n=await t.data(),r=(0,Zn.Y)(t.shape,n);return e!==t&&t.dispose(),r};var er=n(4218),tr=n(3290);const nr=async function(e,t,n){const r=(0,c.YT)(e,"tensor","boolMask"),a=(0,c.YT)(t,"mask","boolMask","bool"),s=null==n?0:n,i=a.rank,o=r.shape;d.vA(i>0,(()=>"mask cannot be scalar")),d.O3(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let c=s;c<s+i;c++)l*=o[c];const u=o.slice(0,s).concat([l],o.slice(s+i)),h=(0,N.t)(r,u),p=(0,N.t)(a,[-1]),f=await Jn(p),m=(0,An.r)(f,[1]),g=(0,$e.k)(h,m,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),m.dispose(),h.dispose(),p.dispose(),f.dispose(),g};var rr=n(2154),ar=n(2155),sr=n(8804);const ir=(0,h.op)({movingAverage_:function(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const s=(0,c.YT)(e,"v","movingAverage"),i=(0,c.YT)(t,"x","movingAverage"),l=(0,c.YT)(n,"decay","movingAverage");(0,sr.assertTypesMatch)(s,i),d.vA(d.r1(s.shape,i.shape),(()=>"Shape mismatch in v and x"));const u=(0,on.d)(1),h=(0,gt.j)(u,l);let p=(0,_.l)((0,gt.j)(i,s),h);if(a){d.vA(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=(0,c.YT)(r,"step","movingAverage");p=(0,fe.y)(p,(0,gt.j)(u,(0,$t.n)(l,e)))}return(0,o.W)(s,p)}});const or=(0,h.op)({scatterND_:function(e,t,n){(0,d.SA)(n);const r=(0,c.YT)(e,"indices","scatterND","int32"),a=(0,c.YT)(t,"updates","scatterND");Wn.validateInput(a,r,n);const s={indices:r,updates:a},i={shape:n};return l.T2.runKernel(u.pJc,s,i)}});const lr=(0,h.op)({sparseToDense_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;(0,d.SA)(n);const a=(0,c.YT)(e,"sparseIndices","sparseToDense","int32"),s=(0,c.YT)(t,"sparseValues","sparseToDense","string_or_numeric"),i=(0,c.YT)(r,"defaultValue","sparseToDense",s.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,s,n,i);const o={sparseIndices:a,sparseValues:s,defaultValue:i},h={outputShape:n};return l.T2.runKernel(u.jgd,o,h)}});const ur=(0,h.op)({gatherND_:function(e,t){const n=(0,c.YT)(t,"indices","gatherND","int32"),r={params:(0,c.YT)(e,"x","gatherND","string_or_numeric"),indices:n};return l.T2.runKernel(u.O4G,r)}});const cr=(0,h.op)({dropout_:function(e,t,n,r){const a=(0,c.YT)(e,"x","dropout");if(d.vA("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),d.vA(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof lt.qY?a.clone():a;const s=function(e,t){if(null==t)return e.shape.slice();if(d.r1(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),i=1-t,l=(0,fe.y)((0,Ee.R)((0,o.W)(Ht(s,0,1,"float32",r),i)),i);return(0,_.l)(a,l)}});function dr(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function hr(e,t,n){const r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){const i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return On(a,"float32")}const pr=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const r=(0,c.YT)(e,"predictions","inTopK"),a=(0,c.YT)(t,"targets","inTopK");(0,d.vA)(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),(0,d.vA)(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),(0,d.O3)(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];(0,d.vA)(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));const i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],h=(0,d.ce)("bool",l);for(let c=0;c<l;c++){const e=c*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),h[c]=0;for(let a=0;a<n;a++)if(r[a].index===o[c]){h[c]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),(0,Mn.O)(h,a.shape,"bool")};var fr=n(1839),mr=n(8805),gr=n(6927),yr=n(1565),br=n(7905);const vr=(0,h.op)({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:h,bias:p,activation:f="linear",preluActivationWeights:m,leakyreluAlpha:g}=e;if(f=f||"linear",!1===(0,br.zE)(l.T2.state.gradientDepth,f)){d.vA("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=(0,ee.X)(t,n,r,a,s,i,h);return null!=p&&(e=(0,o.W)(e,p)),(0,br.f2)(e,f,m,g)}const y=(0,c.YT)(t,"x","conv2d","float32"),b=(0,c.YT)(n,"filter","conv2d","float32");let v=y,x=!1;3===y.rank&&(x=!0,v=(0,N.t)(y,[1,y.shape[0],y.shape[1],y.shape[2]])),d.vA(4===v.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${v.rank}.`)),d.vA(4===b.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${b.rank}.`)),T.s_("fused conv2d",a,h);const w="NHWC"===s?v.shape[3]:v.shape[1];d.vA(b.shape[2]===w,(()=>`Error in conv2d: depth of input (${w}) must match input depth for filter ${b.shape[2]}.`)),d.vA(T.G0(r,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`));const k=T.uf(v.shape,b.shape,r,i,a,h);let S,I;if(null!=p&&(S=(0,c.YT)(p,"bias","fused conv2d"),[S]=(0,sr.makeTypesMatch)(S,y),"NHWC"===s?mr.assertAndGetBroadcastShape(k.outShape,S.shape):(d.vA(S.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${S.shape.length}.`)),d.vA(0===S.shape.length||S.shape[0]===k.outChannels||1===S.shape[0],(()=>`Error in fused conv2d: bias shape (${S.shape}) is not compatible with the number of output channels (${k.outChannels})`)))),null!=m){const e=m.shape;if(d.vA(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)d.vA(1===e[0]||e[0]===k.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${k.outChannels}).`));else if(3===e.length)try{mr.assertAndGetBroadcastShape(e,k.outShape)}catch(_){const t=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${k.outShape}).`;throw Error(t)}I=(0,c.YT)(m,"prelu weights","fused conv2d")}const C=(e,t)=>{d.vA("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));const[n,o,l,u]=t,c=(0,br.XB)(e,l,f);d.vA(T.Dh(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));const h=[(0,yr.v)(o.shape,c,n,r,a),(0,gr.H)(o,c,n.shape,r,a)];if(null!=u){const e=(0,br.Do)(u,c);h.push(e)}return h},A={x:v,filter:b,bias:S,preluActivationWeights:I},E={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:h,activation:f,leakyreluAlpha:g};if(null==p){const e=(0,fr._X)(((e,t,n)=>{let r=l.T2.runKernel(u.aAr,A,E);return n([t,e,r]),x&&(r=(0,N.t)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:C}}));return e(v,b)}{const e=(0,fr._X)(((e,t,n,r)=>{let a=l.T2.runKernel(u.aAr,A,E);return r([t,e,a,n]),x&&(a=(0,N.t)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:C}}));return e(v,b,S)}}});var xr=n(7399),wr=n(261);const kr=(0,h.op)({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:h,bias:p,activation:f="linear",preluActivationWeights:m,leakyreluAlpha:g}=e;if(!1===(0,br.zE)(l.T2.state.gradientDepth,f)){let e=(0,de.G)(t,n,r,a,s,i,h);return null!=p&&(e=(0,o.W)(e,p)),(0,br.f2)(e,f,m,g)}const y=(0,c.YT)(t,"x","depthwiseConv2d","float32"),b=(0,c.YT)(n,"filter","depthwiseConv2d","float32");let v=y,x=!1;3===y.rank&&(x=!0,v=(0,N.t)(y,[1,y.shape[0],y.shape[1],y.shape[2]])),d.vA(4===v.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${v.rank}.`)),d.vA(4===b.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${b.rank}.`)),d.vA(v.shape[3]===b.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${v.shape[3]}) must match the inChannels dimension in filter ${b.shape[2]}.`)),null==i&&(i=[1,1]),d.vA(T.G0(r,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`)),T.s_("fused depthwiseConv2d",a,h);const w=T.uf(v.shape,b.shape,r,i,a,h,!0);let k,S;null!=p&&(k=(0,c.YT)(p,"bias","fused conv2d"),[k]=(0,sr.makeTypesMatch)(k,y),mr.assertAndGetBroadcastShape(w.outShape,k.shape)),null!=m&&(S=(0,c.YT)(m,"prelu weights","fused depthwiseConv2d"));const I=(e,t)=>{d.vA(T.Dh(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[n,s,o,l]=t,u=(0,br.XB)(e,o,f),c=(0,wr.l)(s.shape,u,n,r,a,i,h),p=(0,xr.x)(s,u,n.shape,r,a,i,h);if(null!=l){return[c,p,(0,br.Do)(k,u)]}return[c,p]},C={x:v,filter:b,bias:k,preluActivationWeights:S},A={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:h,activation:f,leakyreluAlpha:g};if(null==p){const e=(0,fr._X)(((e,t,n)=>{let r=l.T2.runKernel(u.T7M,C,A);return n([t,e,r]),x&&(r=(0,N.t)(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:I}}));return e(v,b)}{const e=(0,fr._X)(((e,t,n,r)=>{let a=l.T2.runKernel(u.T7M,C,A);return r([t,e,a,n]),x&&(a=(0,N.t)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:I}}));return e(v,b,k)}}});const Sr=(0,h.op)({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:i="linear",preluActivationWeights:h,leakyreluAlpha:p=.2}=e;if(!1===(0,br.zE)(l.T2.state.gradientDepth,i)){let e=(0,E.N)(t,n,r,a);return null!=s&&(e=(0,o.W)(e,s)),(0,br.f2)(e,i,h,p)}let f=(0,c.YT)(t,"a","fused matMul"),m=(0,c.YT)(n,"b","fused matMul");[f,m]=(0,sr.makeTypesMatch)(f,m);const g=r?f.shape[f.rank-2]:f.shape[f.rank-1],y=a?m.shape[m.rank-1]:m.shape[m.rank-2],b=r?f.shape[f.rank-1]:f.shape[f.rank-2],v=a?m.shape[m.rank-2]:m.shape[m.rank-1],x=f.shape.slice(0,-2),w=m.shape.slice(0,-2),k=d.Ze(x),S=d.Ze(w);d.vA(g===y,(()=>`Error in fused matMul: inner shapes (${g}) and (${y}) of Tensors with shapes ${f.shape} and ${m.shape} and transposeA=${r} and transposeB=${a} must match.`));const I=mr.assertAndGetBroadcastShape(f.shape.slice(0,-2),m.shape.slice(0,-2)).concat([b,v]),T=r?(0,N.t)(f,[k,g,b]):(0,N.t)(f,[k,b,g]),C=a?(0,N.t)(m,[S,v,y]):(0,N.t)(m,[S,y,v]);let A,_;null!=s&&(A=(0,c.YT)(s,"bias","fused matMul"),[A]=(0,sr.makeTypesMatch)(A,f),mr.assertAndGetBroadcastShape(I,A.shape)),null!=h&&(_=(0,c.YT)(h,"prelu weights","fused matMul"));const $=(e,t)=>{const[n,o,l,u]=t,c=(0,br.XB)((0,N.t)(e,l.shape),l,i);let d,h;if(r||a?!r&&a?(d=(0,E.N)(c,o,!1,!1),h=(0,E.N)(c,n,!0,!1)):r&&!a?(d=(0,E.N)(o,c,!1,!0),h=(0,E.N)(n,c,!1,!1)):(d=(0,E.N)(o,c,!0,!0),h=(0,E.N)(c,n,!0,!0)):(d=(0,E.N)(c,o,!1,!0),h=(0,E.N)(n,c,!0,!1)),null!=s){return[d,h,(0,br.Do)(u,c)]}return[d,h]},R={a:T,b:C,bias:A,preluActivationWeights:_},D={transposeA:r,transposeB:a,activation:i,leakyreluAlpha:p};if(null==s){const e=(0,fr._X)(((e,t,n)=>{const r=l.T2.runKernel(u.Dr,R,D);return n([e,t,r]),{value:(0,N.t)(r,I),gradFunc:$}}));return e(T,C)}{const e=(0,fr._X)(((e,t,n,r)=>{const a=l.T2.runKernel(u.Dr,R,D);return r([e,t,a,n]),{value:(0,N.t)(a,I),gradFunc:$}}));return e(T,C,A)}}});const Ir=(0,h.op)({hammingWindow_:function(e){return hr(e,.54,.46)}});const Tr=(0,h.op)({hannWindow_:function(e){return hr(e,.5,.5)}});const Nr=(0,h.op)({frame_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0;const i=[];for(;s+t<=e.size;)i.push((0,R.d)(e,s,t)),s+=n;if(r)for(;s<e.size;){const r=s+t-e.size,o=(0,A.x)([(0,R.d)(e,s,t-r),(0,Ae.G)([r],a)]);i.push(o),s+=n}return 0===i.length?Pn([],[0,t]):(0,N.t)((0,A.x)(i),[i.length,t])}});const Cr=(0,h.op)({stft_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Tr;null==r&&(r=dr(t));const s=Nr(e,t,n),i=(0,_.l)(s,a(t));return(0,In.z)(i,r)}});const Ar=(0,h.op)({cropAndResize_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=(0,c.YT)(e,"image","cropAndResize"),o=(0,c.YT)(t,"boxes","cropAndResize","float32"),h=(0,c.YT)(n,"boxInd","cropAndResize","int32"),p=o.shape[0];d.vA(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),d.vA(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${p},4] but had shape ${o.shape}.`)),d.vA(1===h.rank&&h.shape[0]===p,(()=>`Error in cropAndResize: boxInd must be have size [${p}] but had shape ${o.shape}.`)),d.vA(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),d.vA(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),d.vA("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));const f={image:i,boxes:o,boxInd:h},m={method:a,extrapolationValue:s,cropSize:r};return l.T2.runKernel(u.MRQ,f,m)}});const Er=(0,h.op)({flipLeftRight_:function(e){const t=(0,c.YT)(e,"image","flipLeftRight","float32");d.vA(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return l.T2.runKernel(u.BxF,n,{})}});const _r=(0,h.op)({grayscaleToRGB_:function(e){const t=(0,c.YT)(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];d.vA(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),d.vA(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,(0,Ne.V)(t,a)}});const $r=(0,h.op)({rgbToGrayscale_:function(e){const t=(0,c.YT)(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];d.vA(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),d.vA(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const a=t.dtype,s=(0,I.w)(t,"float32"),i=On([.2989,.587,.114]);let o;switch(t.rank){case 2:o=ye("ij,j->i",s,i);break;case 3:o=ye("ijk,k->ij",s,i);break;case 4:o=ye("ijkl,l->ijk",s,i);break;case 5:o=ye("ijklm,m->ijkl",s,i);break;case 6:o=ye("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=(0,Ie.U)(o,-1),(0,I.w)(o,a)}});const Rr=(0,h.op)({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=(0,c.YT)(e,"image","rotateWithOffset","float32");d.vA(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));const s={image:a},i={radians:t,fillValue:n,center:r};return l.T2.runKernel(u.BK4,s,i)}});function Dr(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);const i=e.shape[0];return n=Math.min(n,i),d.vA(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),d.vA(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),d.vA(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),d.vA(1===t.rank,(()=>"scores must be a 1D tensor")),d.vA(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),d.vA(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}const Mr=(0,h.op)({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=(0,c.YT)(e,"boxes","nonMaxSuppression","float32"),i=(0,c.YT)(t,"scores","nonMaxSuppression","float32"),o=Dr(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;const d={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return l.T2.runKernel(u.SDM,{boxes:s,scores:i},d)}});var Fr=n(6692);const Or=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=(0,c.YT)(e,"boxes","nonMaxSuppressionAsync"),i=(0,c.YT)(t,"scores","nonMaxSuppressionAsync"),o=Dr(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;const l=await Promise.all([s.data(),i.data()]),u=l[0],d=l[1],{selectedIndices:h}=(0,Fr.c7)(u,d,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),On(h,"int32")};const Pr=(0,h.op)({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=(0,c.YT)(e,"boxes","nonMaxSuppression"),o=(0,c.YT)(t,"scores","nonMaxSuppression"),d=Dr(i,o,n,r,a,s);n=d.maxOutputSize,r=d.iouThreshold,a=d.scoreThreshold,s=d.softNmsSigma;const h={boxes:i,scores:o},p={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},f=l.T2.runKernel(u.e0f,h,p);return{selectedIndices:f[0],selectedScores:f[1]}}});const Lr=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=(0,c.YT)(e,"boxes","nonMaxSuppressionAsync"),o=(0,c.YT)(t,"scores","nonMaxSuppressionAsync"),l=Dr(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),d=u[0],h=u[1],{selectedIndices:p,selectedScores:f}=(0,Fr.ut)(d,h,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:On(p,"int32"),selectedScores:On(f)}};const zr=(0,h.op)({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=(0,c.YT)(e,"boxes","nonMaxSuppression"),o=(0,c.YT)(t,"scores","nonMaxSuppression"),d=Dr(i,o,n,r,a,null),h={boxes:i,scores:o},p={maxOutputSize:d.maxOutputSize,iouThreshold:d.iouThreshold,scoreThreshold:d.scoreThreshold,padToMaxOutputSize:s},f=l.T2.runKernel(u.Zl4,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}});const Br=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=(0,c.YT)(e,"boxes","nonMaxSuppressionAsync"),o=(0,c.YT)(t,"scores","nonMaxSuppressionAsync"),l=Dr(i,o,n,r,a,null),u=l.maxOutputSize,d=l.iouThreshold,h=l.scoreThreshold,[p,f]=await Promise.all([i.data(),o.data()]),{selectedIndices:m,validOutputs:g}=(0,Fr.ZS)(p,f,u,d,h,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:On(m,"int32"),validOutputs:(0,on.d)(g,"int32")}};var Vr=n(2214),Wr=n(2823);const Ur=(0,h.op)({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const a=(0,c.YT)(e,"image","threshold"),s=a.shape[0]*a.shape[1];let i,l,u,h,p=(0,_.l)(On([r]),255);if(d.vA(3===a.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`)),d.vA(3===a.shape[2]||1===a.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`)),d.vA("int32"===a.dtype||"float32"===a.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`)),d.vA("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===a.shape[2]){[i,l,u]=(0,Tn.l)(a,[1,1,1],-1);const e=(0,_.l)(i,.2989),t=(0,_.l)(l,.587),n=(0,_.l)(u,.114);h=(0,o.W)((0,o.W)(e,t),n)}else h=e;if("otsu"===t){p=function(e,t){let n,r,a,s,i,l,u=On([-1]),c=On([0]),d=On([0]);for(let h=0;h<e.size-1;h++){n=(0,R.d)(e,0,h+1),r=(0,R.d)(e,h+1),i=(0,fe.y)((0,Rn.c)(n),t),l=(0,fe.y)((0,Rn.c)(r),t);const p=(0,Rn.c)((0,_.l)(n,Kt(0,n.size)));a=(0,fe.y)(p,(0,Rn.c)(n));const f=(0,Ae.G)(r.shape,n.size),m=(0,o.W)(Kt(0,r.size),f),g=(0,_.l)(r,m);s=(0,fe.y)((0,Rn.c)(g),(0,Rn.c)(r));const y=(0,gt.j)(a,s),b=(0,gt.j)(a,s),v=(0,_.l)(i,l);d=(0,_.l)((0,_.l)(v,y),b);const x=(0,Re.r)(d,c);c=(0,Qn._)(x,d,c),u=(0,Qn._)(x,On([h]),u)}return u}(B((0,I.w)((0,an.L)(h),"int32"),(0,Mn.O)([]),256),s)}const f=n?(0,Be.I)(h,p):(0,Re.r)(h,p);return(0,I.w)((0,_.l)(f,255),"int32")}});const jr=(0,h.op)({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const i=(0,c.YT)(e,"image","transform","float32"),o=(0,c.YT)(t,"transforms","transform","float32");d.vA(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),d.vA(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),d.vA(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));const h={image:i,transforms:o},p={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return l.T2.runKernel(u.dLy,h,p)}});const Gr=(0,h.op)({bandPart_:function(e,t,n){const r=(0,c.YT)(e,"a","bandPart");(0,d.vA)(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const a=r.shape,[s,i]=r.shape.slice(-2);let o,l;"number"===typeof t?((0,d.vA)(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),(0,d.vA)(t<=s,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`)),o=(0,c.YT)(t<0?s:t,"numLower","bandPart")):((0,d.vA)("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=(0,Qn._)((0,ze.M)(t,0),s,(0,dt.B)(t,s))),"number"===typeof n?((0,d.vA)(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),(0,d.vA)(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),l=(0,c.YT)(n<0?i:n,"numUpper","bandPart")):((0,d.vA)("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=(0,Qn._)((0,ze.M)(n,0),i,(0,dt.B)(n,i)));const u=(0,N.t)(Kt(0,s,1,"int32"),[-1,1]),h=Kt(0,i,1,"int32"),p=(0,gt.j)(u,h),f=(0,Ke.n)((0,Be.I)(p,o),(0,De.D)(p,(0,xt.H)(l))),m=(0,er.U)([s,i],r.dtype);return(0,N.t)((0,En.t)((0,Kn.K)((0,N.t)(r,[-1,s,i])).map((e=>(0,Qn._)(f,e,m)))),a)}});const Hr=(0,h.op)({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,(0,d.vA)(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)(0,d.vA)(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=(0,Tn.l)(e,e.shape[0],0).map((e=>(0,An.r)(e,[0])));(0,d.vA)(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let a=0;a<e.length;++a)n.push(l.T2.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){const r=(0,_.l)((0,Rn.c)((0,_.l)(n[t],e)),n[t]);e=(0,gt.j)(e,r)}return(0,fe.y)(e,(0,ar.x)(e,"euclidean"))})));return t?(0,En.t)(n,0):n}});var qr=n(8046);function Kr(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return l.T2.tidy((()=>{(0,d.vA)(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let a=Ce(n),s=(0,q.o)(e);const i=Pn([[1]],[1,1]);let o=(0,q.o)(i);const u=n>=r?r:n;for(let e=0;e<u;++e){const t=s,u=o,c=a;[o,s,a]=l.T2.tidy((()=>{const t=(0,R.d)(s,[e,e],[n-e,1]),l=(0,ar.x)(t),u=(0,R.d)(s,[e,e],[1,1]),c=(0,Qn._)((0,Re.r)(u,0),Pn([[-1]]),Pn([[1]])),d=(0,gt.j)(u,(0,_.l)(c,l)),h=(0,fe.y)(t,d);o=1===h.shape[0]?(0,q.o)(i):(0,A.x)([i,(0,R.d)(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=(0,xt.H)((0,fe.y)((0,E.N)(c,d),l)),f=(0,R.d)(s,[e,0],[n-e,r]),m=(0,_.l)(p,o),g=(0,rr.m)(o);if(0===e)s=(0,gt.j)(f,(0,E.N)(m,(0,E.N)(g,f)));else{const t=(0,gt.j)(f,(0,E.N)(m,(0,E.N)(g,f)));s=(0,A.x)([(0,R.d)(s,[0,0],[e,r]),t],0)}const y=(0,rr.m)(m),b=(0,R.d)(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=(0,gt.j)(b,(0,E.N)((0,E.N)(b,o),y));else{const t=(0,gt.j)(b,(0,E.N)((0,E.N)(b,o),y));a=(0,A.x)([(0,R.d)(a,[0,0],[n,e]),t],1)}return[o,s,a]})),(0,qr.AS)([t,u,c])}return!t&&n>r&&(a=(0,R.d)(a,[0,0],[n,r]),s=(0,R.d)(s,[0,0],[r,r])),[a,s]}))}const Yr=(0,h.op)({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if((0,d.vA)(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Kr(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=(0,Kn.K)((0,N.t)(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach((e=>{const[n,r]=Kr(e,t);a.push(n),s.push(r)}));return[(0,N.t)((0,En.t)(a,0),e.shape),(0,N.t)((0,En.t)(s,0),e.shape)]}}});var Xr=n(1667);const Qr=(0,h.op)({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Xr.i.SUM_BY_NONZERO_WEIGHTS;const r=(0,c.YT)(e,"losses","computeWeightedLoss");let a=null;null!=t&&(a=(0,c.YT)(t,"weights","computeWeightedLoss"));const s=null==a?r:(0,_.l)(r,a);if(n===Xr.i.NONE)return s;if(n===Xr.i.SUM)return(0,Rn.c)(s);if(n===Xr.i.MEAN){if(null==a)return(0,it.i)(s);{const e=r.size/a.size,t=(0,fe.y)((0,Rn.c)(s),(0,Rn.c)(a));return e>1?(0,fe.y)(t,(0,on.d)(e)):t}}if(n===Xr.i.SUM_BY_NONZERO_WEIGHTS){if(null==a)return(0,fe.y)((0,Rn.c)(s),(0,on.d)(r.size));{const e=(0,_.l)(a,(0,ot.S)(r.shape)),t=(0,I.w)((0,Rn.c)((0,wt.E)(e,(0,on.d)(0))),"float32");return(0,fe.y)((0,Rn.c)(s),t)}}throw Error(`Unknown reduction: ${n}`)}});const Zr=(0,h.op)({absoluteDifference_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Xr.i.SUM_BY_NONZERO_WEIGHTS;const s=(0,c.YT)(e,"labels","absoluteDifference"),i=(0,c.YT)(t,"predictions","absoluteDifference");let o=null;null!=n&&(o=(0,c.YT)(n,"weights","absoluteDifference")),(0,d.O3)(s.shape,i.shape,"Error in absoluteDifference: ");const l=(0,a.t)((0,gt.j)(s,i));return Qr(l,o,r)}});const Jr=(0,h.op)({cosineDistance_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Xr.i.SUM_BY_NONZERO_WEIGHTS;const s=(0,c.YT)(e,"labels","cosineDistance"),i=(0,c.YT)(t,"predictions","cosineDistance");let o=null;null!=r&&(o=(0,c.YT)(r,"weights","cosineDistance")),(0,d.O3)(s.shape,i.shape,"Error in cosineDistance: ");const l=(0,on.d)(1),u=(0,gt.j)(l,(0,Rn.c)((0,_.l)(s,i),n,!0));return Qr(u,o,a)}});const ea=(0,h.op)({hingeLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Xr.i.SUM_BY_NONZERO_WEIGHTS,a=(0,c.YT)(e,"labels","hingeLoss");const s=(0,c.YT)(t,"predictions","hingeLoss");let i=null;null!=n&&(i=(0,c.YT)(n,"weights","hingeLoss")),(0,d.O3)(a.shape,s.shape,"Error in hingeLoss: ");const o=(0,on.d)(1);a=(0,gt.j)((0,_.l)((0,on.d)(2),a),o);const l=(0,Qt.V)((0,gt.j)(o,(0,_.l)(a,s)));return Qr(l,i,r)}});const ta=(0,h.op)({huberLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Xr.i.SUM_BY_NONZERO_WEIGHTS;const i=(0,c.YT)(e,"labels","huberLoss"),l=(0,c.YT)(t,"predictions","huberLoss");let u=null;null!=n&&(u=(0,c.YT)(n,"weights","huberLoss")),(0,d.O3)(i.shape,l.shape,"Error in huberLoss: ");const h=(0,on.d)(r),p=(0,a.t)((0,gt.j)(l,i)),f=(0,dt.B)(p,h),m=(0,gt.j)(p,f),g=(0,o.W)((0,_.l)((0,on.d)(.5),(0,mt.E)(f)),(0,_.l)(h,m));return Qr(g,u,s)}});const na=(0,h.op)({logLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Xr.i.SUM_BY_NONZERO_WEIGHTS;const s=(0,c.YT)(e,"labels","logLoss"),i=(0,c.YT)(t,"predictions","logLoss");let l=null;null!=n&&(l=(0,c.YT)(n,"weights","logLoss")),(0,d.O3)(s.shape,i.shape,"Error in logLoss: ");const u=(0,on.d)(1),h=(0,on.d)(r),p=(0,xt.H)((0,_.l)(s,(0,Ue.R)((0,o.W)(i,h)))),f=(0,_.l)((0,gt.j)(u,s),(0,Ue.R)((0,o.W)((0,gt.j)(u,i),h))),m=(0,gt.j)(p,f);return Qr(m,l,a)}});const ra=(0,h.op)({meanSquaredError_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Xr.i.SUM_BY_NONZERO_WEIGHTS;const a=(0,c.YT)(e,"labels","meanSquaredError"),s=(0,c.YT)(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=(0,c.YT)(n,"weights","meanSquaredError")),(0,d.O3)(a.shape,s.shape,"Error in meanSquaredError: ");const o=(0,Cn.P)(a,s);return Qr(o,i,r)}});const aa=(0,h.op)({sigmoidCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Xr.i.SUM_BY_NONZERO_WEIGHTS,i=(0,c.YT)(e,"multiClassLabels","sigmoidCrossEntropy");const l=(0,c.YT)(t,"logits","sigmoidCrossEntropy");let u=null;if(null!=n&&(u=(0,c.YT)(n,"weights","sigmoidCrossEntropy")),(0,d.O3)(i.shape,l.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=(0,on.d)(r),t=(0,on.d)(1),n=(0,on.d)(.5);i=(0,o.W)((0,_.l)(i,(0,gt.j)(t,e)),(0,_.l)(n,e))}const h=function(e,t){const n=(0,c.YT)(e,"labels","sigmoidCrossEntropyWithLogits"),r=(0,c.YT)(t,"logits","sigmoidCrossEntropyWithLogits");(0,d.O3)(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=(0,Qt.V)(r),i=(0,_.l)(r,n),l=(0,je.K)((0,Se.o)((0,xt.H)((0,a.t)(r))));return(0,o.W)((0,gt.j)(s,i),l)}(i,l);return Qr(h,u,s)}});const sa=(0,h.op)({softmaxCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Xr.i.SUM_BY_NONZERO_WEIGHTS,s=(0,c.YT)(e,"onehotLabels","softmaxCrossEntropy");const i=(0,c.YT)(t,"logits","softmaxCrossEntropy");let l=null;if(null!=n&&(l=(0,c.YT)(n,"weights","softmaxCrossEntropy")),(0,d.O3)(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=(0,on.d)(r),t=(0,on.d)(1),n=(0,on.d)(s.shape[1]);s=(0,o.W)((0,_.l)(s,(0,gt.j)(t,e)),(0,fe.y)(e,n))}const u=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=(0,fr._X)(((e,t,r)=>{const a=(0,qe.V)(t,[n],!0),s=(0,gt.j)((0,I.w)(t,"float32"),a);r([e,s]);const i=(0,xt.H)((0,_.l)(s,e));return{value:(0,Rn.c)(i,[n]),gradFunc:(e,t)=>{const[r,a]=t,s=(0,ft.SM)(e.shape,[n]);return[(0,_.l)((0,N.t)(e,s),(0,gt.j)((0,I.w)(r,"float32"),(0,Se.o)(a))),(0,_.l)((0,N.t)(e,s),(0,gt.j)((0,Se.o)(a),(0,I.w)(r,"float32")))]}}}));return r(e,t)}(s,i);return Qr(u,l,a)}});const ia=(0,h.op)({sparseFillEmptyRows_:function(e,t,n,r){const a=(0,c.YT)(e,"indices","sparseFillEmptyRows","int32"),s=(0,c.YT)(t,"values","sparseFillEmptyRows"),i=(0,c.YT)(n,"denseShape","sparseFillEmptyRows","int32"),o=(0,c.YT)(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const d={indices:a,values:s,denseShape:i,defaultValue:o},h=l.T2.runKernel(u.C8s,d);return{outputIndices:h[0],outputValues:h[1],emptyRowIndicator:h[2],reverseIndexMap:h[3]}}});const oa=(0,h.op)({sparseReshape_:function(e,t,n){const r=(0,c.YT)(e,"inputIndices","sparseReshape","int32"),a=(0,c.YT)(t,"inputShape","sparseReshape","int32"),s=(0,c.YT)(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const i={inputIndices:r,inputShape:a,newShape:s},o=l.T2.runKernel(u.BoJ,i);return{outputIndices:o[0],outputShape:o[1]}}});const la=(0,h.op)({sparseSegmentMean_:function(e,t,n){const r=(0,c.YT)(e,"data","sparseSegmentMean"),a=(0,c.YT)(t,"indices","sparseSegmentMean","int32"),s=(0,c.YT)(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);const i={data:r,indices:a,segmentIds:s};return l.T2.runKernel(u.L6G,i)}});const ua=(0,h.op)({sparseSegmentSum_:function(e,t,n){const r=(0,c.YT)(e,"data","sparseSegmentSum"),a=(0,c.YT)(t,"indices","sparseSegmentSum","int32"),s=(0,c.YT)(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);const i={data:r,indices:a,segmentIds:s};return l.T2.runKernel(u.DvZ,i)}});const ca=(0,h.op)({stringNGrams_:function(e,t,n,r,a,s,i,o){const d=(0,c.YT)(e,"data","stringNGrams","string");if("string"!==d.dtype)throw new Error("Data must be of datatype string");if(1!==d.shape.length)throw new Error(`Data must be a vector, saw: ${d.shape}`);const h=(0,c.YT)(t,"dataSplits","stringNGrams");if("int32"!==h.dtype)throw new Error("Data splits must be of datatype int32");const p={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},f={data:d,dataSplits:h},m=l.T2.runKernel(u.YAb,f,p);return{nGrams:m[0],nGramsSplits:m[1]}}});const da=(0,h.op)({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=(0,c.YT)(e,"input","stringSplit","string"),a=(0,c.YT)(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);const s={skipEmpty:n},i={input:r,delimiter:a},o=l.T2.runKernel(u.iW0,i,s);return{indices:o[0],values:o[1],shape:o[2]}}});const ha=(0,h.op)({stringToHashBucketFast_:function(e,t){const n=(0,c.YT)(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const a={input:n};return l.T2.runKernel(u.$jE,a,r)}});const pa=(0,h.op)({staticRegexReplace_:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=(0,c.YT)(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return l.T2.runKernel(u.GZp,{x:a},s)}}),fa={fft:wn.h,ifft:kn.K,rfft:In.z,irfft:Sn.g},ma={hammingWindow:Ir,hannWindow:Tr,frame:Nr,stft:Cr},ga={flipLeftRight:Er,grayscaleToRGB:_r,resizeNearestNeighbor:Wr.b,resizeBilinear:Vr.v,rgbToGrayscale:$r,rotateWithOffset:Rr,cropAndResize:Ar,nonMaxSuppression:Mr,nonMaxSuppressionAsync:Or,nonMaxSuppressionWithScore:Pr,nonMaxSuppressionWithScoreAsync:Lr,nonMaxSuppressionPadded:zr,nonMaxSuppressionPaddedAsync:Br,threshold:Ur,transform:jr},ya={bandPart:Gr,gramSchmidt:Hr,qr:Yr},ba={absoluteDifference:Zr,computeWeightedLoss:Qr,cosineDistance:Jr,hingeLoss:ea,huberLoss:ta,logLoss:na,meanSquaredError:ra,sigmoidCrossEntropy:aa,softmaxCrossEntropy:sa},va={sparseFillEmptyRows:ia,sparseReshape:oa,sparseSegmentMean:la,sparseSegmentSum:ua},xa={stringNGrams:ca,stringSplit:da,stringToHashBucketFast:ha,staticRegexReplace:pa}},5048:(e,t,n)=>{"use strict";n.d(t,{e:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const i=(0,s.YT)(e,"x","pad");if(0===i.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:t,constantValue:n},l={x:i};return r.T2.runKernel(a.ODT,l,o)}})},7751:(e,t,n)=>{"use strict";n.d(t,{d:()=>h});var r=n(4148),a=n(1426),s=n(8650),i=n(2557),o=n(7538),l=n(6044),u=n(7892),c=n(5583),d=n(3585);const h=(0,u.op)({pool_:function(e,t,n,u,h,p,f){null==h&&(h=[1,1]),null==p&&(p=1),0===u&&(u="valid");const m=(0,r.YT)(e,"x","maxPool");let g=m,y=!1;3===m.rank&&(y=!0,g=(0,c.t)(m,[1,m.shape[0],m.shape[1],m.shape[2]])),a.vA(o.G0(p,h),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${p} and dilations '${h}'`));const b=o.E6(g.shape,t,p,h,u),v=[b.dilationHeight,b.dilationWidth];let x;x="same"===u?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),a=r.map((e=>Math.floor(e/2))),s=r.map(((e,t)=>e-a[t]));return r.map(((e,t)=>[a[t],s[t]]))}([b.filterHeight,b.filterWidth],v):[[0,0],[0,0]];const w=1===v[0]&&1===v[1],[k,S]=function(e,t,n){const r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),i=t.map(((e,t)=>(e-s[t]%e)%e)),o=a.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([b.inHeight,b.inWidth],v,x),I=w?u:"valid",T=w?g:(0,d.e)(g,v,k),N=("avg"===n?()=>(0,s.$)(T,t,p,I,f):()=>(0,l.j)(T,t,p,I,f))(),C=w?N:(0,i.G)(N,v,S);return y?(0,c.t)(C,[C.shape[1],C.shape[2],C.shape[3]]):C}})},7587:(e,t,n)=>{"use strict";n.d(t,{n:()=>o});var r=n(2164),a=n(9554),s=n(8804),i=n(4148);const o=(0,n(7892).op)({pow_:function(e,t){let n=(0,i.YT)(e,"base","pow"),o=(0,i.YT)(t,"exp","pow");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(a.pyJ,l)}})},9855:(e,t,n)=>{"use strict";n.d(t,{N:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({prelu_:function(e,t){const n={x:(0,s.YT)(e,"x","prelu"),alpha:(0,s.YT)(t,"alpha","prelu")};return r.T2.runKernel(a.Ncv,n)}})},6574:(e,t,n)=>{"use strict";function r(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}n.d(t,{y:()=>r})},9556:(e,t,n)=>{"use strict";n.d(t,{_:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(7794);const o=(0,n(7892).op)({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=(0,s.YT)(e,"x","prod");"bool"===o.dtype&&(o=(0,i.w)(o,"int32"));const l={x:o},u={axis:t,keepDims:n};return r.T2.runKernel(a.kdj,l,u)}})},9477:(e,t,n)=>{"use strict";n.d(t,{x:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({real_:function(e){const t={input:(0,s.YT)(e,"input","real")};return r.T2.runKernel(a.LRy,t)}})},6309:(e,t,n)=>{"use strict";n.d(t,{V:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({reciprocal_:function(e){const t={x:(0,s.YT)(e,"x","reciprocal")};return r.T2.runKernel(a.huO,t)}})},5251:(e,t,n)=>{"use strict";n.d(t,{V:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({relu_:function(e){const t={x:(0,s.YT)(e,"x","relu")};return r.T2.runKernel(a.fUj,t)}})},9721:(e,t,n)=>{"use strict";n.d(t,{j:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({relu6_:function(e){const t={x:(0,s.YT)(e,"x","relu6")};return r.T2.runKernel(a.P_L,t)}})},5583:(e,t,n)=>{"use strict";n.d(t,{t:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({reshape_:function(e,t){const n={x:(0,s.YT)(e,"x","reshape","string_or_numeric")},i={shape:t};return r.T2.runKernel(a.R23,n,i)}})},7419:(e,t,n)=>{"use strict";n.d(t,{B:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({reverse_:function(e,t){const n={x:(0,s.YT)(e,"x","reverse")},i={dims:t};return r.T2.runKernel(a.D7i,n,i)}})},6509:(e,t,n)=>{"use strict";n.d(t,{L:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({round_:function(e){const t={x:(0,s.YT)(e,"x","round")};return r.T2.runKernel(a.hVg,t)}})},6777:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({rsqrt_:function(e){const t={x:(0,s.YT)(e,"x","rsqrt","float32")};return r.T2.runKernel(a.TOR,t)}})},1997:(e,t,n)=>{"use strict";n.d(t,{d:()=>s});var r=n(8977),a=n(9914);function s(e,t){if(((0,r.isTypedArray)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&(0,r.isTypedArray)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,a.Q)(e,[],[],t)}},4083:(e,t,n)=>{"use strict";n.r(t),n.d(t,{calculateShapes:()=>i,validateInput:()=>s,validateUpdateShape:()=>a});var r=n(1426);function a(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function s(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}a(n,t,e)}function i(e,t,n){const a=t.shape.length,s=a>1?t.shape[a-1]:1,i=n.length;let o=1;for(let r=s;r<i;++r)o*=n[r];const l=s<1?1:s;return{sliceRank:s,numUpdates:(0,r.Ze)(t.shape)/l,sliceSize:o,strides:[...(0,r.Ur)(n.slice(0,s)),1],outputSize:(0,r.Ze)(n)}}},2022:(e,t,n)=>{"use strict";n.d(t,{W:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({selu_:function(e){const t={x:(0,s.YT)(e,"x","selu")};return r.T2.runKernel(a.u$b,t)}})},3765:(e,t,n)=>{"use strict";n.d(t,{X:()=>a,j:()=>r});const r=1.7580993408473768,a=1.0507009873554805},3117:(e,t,n)=>{"use strict";n.d(t,{w:()=>u});var r=n(4148),a=n(1426),s=n(4969),i=n(9899),o=n(7892),l=n(5583);const u=(0,o.op)({separableConv2d_:function(e,t,n,o,u){let c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],d=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const h=(0,r.YT)(e,"x","separableConv2d"),p=(0,r.YT)(t,"depthwiseFilter","separableConv2d"),f=(0,r.YT)(n,"pointwiseFilter","separableConv2d");let m=h,g=!1;if(3===h.rank&&(g=!0,m=(0,l.t)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),"NCHW"===d)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");a.vA(4===m.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${m.rank}.`)),a.vA(4===p.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${p.rank}.`)),a.vA(4===f.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${p.rank}.`)),a.vA(1===f.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${f.shape[0]}.`)),a.vA(1===f.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${f.shape[1]}.`));const y=p.shape[2],b=p.shape[3];a.vA(f.shape[2]===y*b,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${y*b}, but got ${f.shape[2]}.`));const v=(0,i.G)(m,p,o,u,d,c),x=(0,s.X)(v,f,1,"valid",d);return g?(0,l.t)(x,[x.shape[1],x.shape[2],x.shape[3]]):x}})},4213:(e,t,n)=>{"use strict";n.d(t,{r:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({sigmoid_:function(e){const t={x:(0,s.YT)(e,"x","sigmoid","float32")};return r.T2.runKernel(a.vI1,t)}})},5740:(e,t,n)=>{"use strict";n.d(t,{_:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({sign_:function(e){const t={x:(0,s.YT)(e,"x","sign")};return r.T2.runKernel(a.YVe,t)}})},9519:(e,t,n)=>{"use strict";n.d(t,{F:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({sin_:function(e){const t={x:(0,s.YT)(e,"x","sin","float32")};return r.T2.runKernel(a.hql,t)}})},8143:(e,t,n)=>{"use strict";n.d(t,{L:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({sinh_:function(e){const t={x:(0,s.YT)(e,"x","sinh")};return r.T2.runKernel(a.J3C,t)}})},463:(e,t,n)=>{"use strict";n.d(t,{d:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({slice_:function(e,t,n){const i=(0,s.YT)(e,"x","slice","string_or_numeric");if(0===i.rank)throw new Error("Slicing scalar is not possible");const o={x:i},l={begin:t,size:n};return r.T2.runKernel(a.JiE,o,l)}})},4642:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assertParamsValid:()=>i,computeFlatOffset:()=>v,computeOutShape:()=>l,getNormalizedAxes:()=>h,isSliceContinous:()=>b,maskToAxes:()=>o,parseSliceParams:()=>x,sliceInfo:()=>w,startForAxis:()=>g,startIndicesWithElidedDims:()=>p,stopForAxis:()=>y,stopIndicesWithElidedDims:()=>f,stridesForAxis:()=>m,stridesWithElidedDims:()=>u});var r=n(1426);const a=-2,s=-1;function i(e,t,n){const a=e.shape.length;r.vA(a===t.length,(()=>`Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`)),r.vA(a===n.length,(()=>`Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`));for(let s=0;s<a;++s)r.vA(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${a}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function o(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function l(e,t,n){const r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function u(e,t,n,r){const a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[t]=1:(a.splice(t,0,1),a.pop());return a}function c(e,t,n){return n<=e?n:n-(t-1)}function d(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function h(e,t,n,r,a,s,i,o,l){const c=e.length;let d=new Array(c),h=new Array(c),b=new Array(c);if(t.length&&n>0){const l=t[0],c=n+1;d=p(i,l,c,r,e),h=f(o,l,c,a,e),b=u(s,l,c,e)}else for(let u=0;u<c;u++)d[u]=g(i,r,s,e,u,l),h[u]=y(o,a,s,e,u,l),b[u]=m(s,u,l);return{begin:d,end:h,strides:b}}function p(e,t,n,r,a){const s=[...a],i=d(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{const a=c(t,n,o);let i=r[a];e&1<<a&&(i=0),s[o]=i}return s}function f(e,t,n,a,s){const i=[...s],o=d(n,t);for(let r=0;r<i.length;r++)if(o.indexOf(r)>-1)i[r]=Number.MAX_SAFE_INTEGER;else{const s=c(t,n,r);let o=a[s];e&1<<s&&(o=Number.MAX_SAFE_INTEGER),i[r]=o}for(let l=0;l<i.length;l++){const e=s[l];i[l]<0&&(i[l]+=e),i[l]=r.qE(0,i[l],s[l])}return i}function m(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function g(e,t,n,a,s,i){let o=t[s];const l=n[s]||1;(e&1<<s||i&1<<s||null==o)&&(o=l>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=a[s];return o<0&&(o+=u),o=r.qE(0,o,u-1),o}function y(e,t,n,a,s,i){let o=t[s];const l=n[s]||1;(e&1<<s||i&1<<s||null==o)&&(o=l>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=a[s];return o<0&&(o+=u),o=l>0?r.qE(0,o,u):r.qE(-1,o,u-1),o}function b(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function v(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function x(e,t,n){let a;const s=e.shape.length;let i;return a="number"===typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),a.forEach((e=>{r.vA(-1!==e,(()=>"slice() does not support negative begin indexing."))})),i=null==n?new Array(s).fill(-1):"number"===typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,i=i.map(((t,n)=>t>=0?t:(r.vA(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-a[n]))),[a,i]}function w(e,t,n,r,i,o,l,u,c){let d;if(null==r?(d=new Array(t.length),d.fill(1)):d=r,null!=l&&0!==(l&l-1))throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const p={dims:d.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:d.slice(),beginMask:i,endMask:o,ellipsisMask:l,newAxisMask:u,shrinkAxisMask:c};for(let a=0;a<p.dims;a++)h&&0!==(1<<a&u)&&p.numAddAxisAfterEllipsis++,1<<a&l&&(h=!0);h||(p.ellipsisMask|=1<<p.dims,p.dims++);const f={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(a),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(s),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(p,f);let m=!0,g=!0,y=!0;const b=[],v=[];for(let a=0;a<e.length;++a){if(0===f.strides[a])throw Error(`strides[${a}] must be non-zero`);const t=!!(f.shrinkAxisMask&1<<a),n=e[a];if(-1===n){b.push(t?1:-1);continue}const r=[f.beginMask&1<<a,f.endMask&1<<a],s=[f.strides[a]>0?0:-1,f.strides[a]>0?n:n-1];if(t&&f.strides[a]<=0)throw Error("only stride 1 allowed on non-range indexing.");y=y&&1===f.strides[a];const i=!!(f.beginMask&1<<a&&f.endMask&1<<a);if(f.beginValid&&f.endValid){if(t){const e=f.begin[a]<0?n+f.begin[a]:f.begin[a];if(f.begin[a]=e,f.end[a]=f.begin[a]+1,e<0||e>=n)throw Error(`slice index ${f.begin[a]} of dimension ${a} out of bounds.`)}else f.begin[a]=k(f.begin[a],0,f.strides[a],n,r,s),f.end[a]=k(f.end[a],1,f.strides[a],n,r,s);const e=1===f.strides[a]&&0===f.begin[a]&&f.end[a]===n;m=m&&e,g=g&&(0===a&&1===f.strides[a]||e)}else m=m&&1===f.strides[a]&&i,g=g&&(0===a&&1===f.strides[a]||i);let o,l=!1;if(f.beginValid&&f.endValid?(o=f.end[a]-f.begin[a],l=!0):t?(o=1,l=!0):i&&n>=0&&(o=f.strides[a]<0?-n:n,l=!0),l){let e;e=0===o||o<0!==f.strides[a]<0?0:Math.trunc(o/f.strides[a])+(o%f.strides[a]!==0?1:0),b.push(e)}else b.push(-1)}for(let s=0;s<f.finalShapeGatherIndices.length;++s){const e=f.finalShapeGatherIndices[s];e>=0?v.push(b[e]):e===a&&v.push(1)}return{finalShapeSparse:v.filter(((e,t)=>f.finalShapeGatherIndices[t]!==a)),finalShape:v,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:f.begin,end:f.end,strides:f.strides}}function k(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{const t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}},6719:(e,t,n)=>{"use strict";n.d(t,{V:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=(0,s.YT)(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const i={logits:n},o={dim:t};return r.T2.runKernel(a.rFG,i,o)}})},9973:(e,t,n)=>{"use strict";n.d(t,{l:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({softplus_:function(e){const t={x:(0,s.YT)(e,"x","softplus")};return r.T2.runKernel(a.Fin,t)}})},3585:(e,t,n)=>{"use strict";n.d(t,{e:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({spaceToBatchND_:function(e,t,n){const o=(0,s.YT)(e,"x","spaceToBatchND");i.vA(o.rank>=1+t.length,(()=>`input rank ${o.rank} should be > than [blockShape] ${t.length}`)),i.vA(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),i.vA(o.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>`input spatial dimensions ${o.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const l={x:o},u={blockShape:t,paddings:n};return r.T2.runKernel(a.A8B,l,u)}})},3062:(e,t,n)=>{"use strict";n.d(t,{h:()=>i});var r=n(2164),a=n(9554),s=n(1426);const i=(0,n(7892).op)({fft_:function(e){(0,s.vA)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.T2.runKernel(a.rGP,t)}})},1405:(e,t,n)=>{"use strict";n.d(t,{K:()=>i});var r=n(2164),a=n(9554),s=n(1426);const i=(0,n(7892).op)({ifft_:function(e){(0,s.vA)("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return r.T2.runKernel(a.OAQ,t)}})},7307:(e,t,n)=>{"use strict";n.d(t,{g:()=>f});var r=n(6149),a=n(4429),s=n(1047),i=n(803),o=n(7892),l=n(9477),u=n(5583),c=n(7419),d=n(1997),h=n(463),p=n(1405);const f=(0,o.op)({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let o;if(t<=2){const r=(0,u.t)(e,[n,t]);o=(0,p.K)(r)}else{const f=[n,2*(t-1)],m=(0,u.t)((0,l.x)(e),[n,t]),g=(0,u.t)((0,s.n)(e),[n,t]),y=(0,c.B)((0,h.d)(m,[0,1],[n,t-2]),1),b=(0,i.l)((0,c.B)((0,h.d)(g,[0,1],[n,t-2]),1),(0,d.d)(-1)),v=(0,a.x)([m,y],1),x=(0,a.x)([g,b],1),w=(0,u.t)((0,r.f)(v,x),[f[0],f[1]]);o=(0,p.K)(w)}if(o=(0,l.x)(o),3===e.rank&&0!==e.shape[0]){const t=o,n=e.shape[0];o=(0,u.t)(o,[n,o.shape[0]/n,o.shape[1]]),t.dispose()}return o}})},9486:(e,t,n)=>{"use strict";n.d(t,{z:()=>m});var r=n(1426),a=n(6149),s=n(4429),i=n(1047),o=n(7892),l=n(9477),u=n(5583),c=n(463),d=n(5181),h=n(4218),p=n(3290),f=n(3062);const m=(0,o.op)({rfft_:function(e,t){(0,r.vA)("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const o=e.size/n;let m;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,m=(0,c.d)(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,m=(0,s.x)([e,(0,h.U)(r)],e.shape.length-1),n=t}else m=e;const g=(0,p.P)(m),y=(0,u.t)((0,a.f)(m,g),[o,n]),b=(0,f.h)(y),v=Math.floor(n/2)+1,x=(0,l.x)(b),w=(0,i.n)(b),k=(0,d.l)(x,[v,n-v],x.shape.length-1),S=(0,d.l)(w,[v,n-v],w.shape.length-1),I=m.shape.slice();return I[m.shape.length-1]=v,(0,u.t)((0,a.f)(k[0],S[0]),I)}})},5181:(e,t,n)=>{"use strict";n.d(t,{l:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const i={x:(0,s.YT)(e,"x","split")},o={numOrSizeSplits:t,axis:n};return r.T2.runKernel(a.Blb,i,o)}})},191:(e,t,n)=>{"use strict";n.d(t,{R:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({sqrt_:function(e){const t={x:(0,s.YT)(e,"x","sqrt","float32")};return r.T2.runKernel(a.dFH,t)}})},7738:(e,t,n)=>{"use strict";n.d(t,{E:()=>s});var r=n(2164),a=n(4148);const s=(0,n(7892).op)({square_:function(e){const t=(0,a.YT)(e,"x","square");return r.T2.runKernel("Square",{x:t},{})}})},208:(e,t,n)=>{"use strict";n.d(t,{P:()=>l});var r=n(2164),a=n(9554),s=n(8804),i=n(4148),o=n(8805);const l=(0,n(7892).op)({squaredDifference_:function(e,t){let n=(0,i.YT)(e,"a","squaredDifference"),l=(0,i.YT)(t,"b","squaredDifference");[n,l]=(0,s.makeTypesMatch)(n,l),(0,o.assertAndGetBroadcastShape)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(a.Ddj,u,{})}})},613:(e,t,n)=>{"use strict";n.d(t,{r:()=>o});var r=n(4148),a=n(1426),s=n(7892),i=n(5583);const o=(0,s.op)({squeeze_:function(e,t){const n=(0,r.YT)(e,"x","squeeze","string_or_numeric");return(0,i.t)(n,(0,a.gx)(n.shape,t).newShape)}})},901:(e,t,n)=>{"use strict";n.d(t,{t:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=(0,s.j1)(e,"tensors","stack","string_or_numeric");i.vA(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&i.vA(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const o=n,l={axis:t};return r.T2.runKernel(a.mM$,o,l)}})},319:(e,t,n)=>{"use strict";n.d(t,{P:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:(0,s.YT)(e,"x","step")},i={alpha:t};return r.T2.runKernel(a.pnw,n,i)}})},1231:(e,t,n)=>{"use strict";n.d(t,{Y:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({stridedSlice_:function(e,t,n,i){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,u=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,c=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,d=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const h={x:(0,s.YT)(e,"x","stridedSlice","string_or_numeric")},p={begin:t,end:n,strides:i,beginMask:o,endMask:l,ellipsisMask:u,newAxisMask:c,shrinkAxisMask:d};return r.T2.runKernel(a.UcO,h,p)}})},7951:(e,t,n)=>{"use strict";n.d(t,{j:()=>o});var r=n(2164),a=n(9554),s=n(8804),i=n(4148);const o=(0,n(7892).op)({sub_:function(e,t){let n=(0,i.YT)(e,"a","sub"),o=(0,i.YT)(t,"b","sub");[n,o]=(0,s.makeTypesMatch)(n,o);const l={a:n,b:o};return r.T2.runKernel(a.PbM,l)}})},7382:(e,t,n)=>{"use strict";n.d(t,{c:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(7794);const o=(0,n(7892).op)({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=(0,s.YT)(e,"x","sum");"bool"===o.dtype&&(o=(0,i.w)(o,"int32"));const l={x:o},u={axis:t,keepDims:n};return r.T2.runKernel(a.WuN,l,u)}})},4894:(e,t,n)=>{"use strict";n.d(t,{M:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({tan_:function(e){const t={x:(0,s.YT)(e,"x","tan","float32")};return r.T2.runKernel(a.oFs,t)}})},6532:(e,t,n)=>{"use strict";n.d(t,{y:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({tanh_:function(e){const t={x:(0,s.YT)(e,"x","tanh","float32")};return r.T2.runKernel(a.iuW,t)}})},8032:(e,t,n)=>{"use strict";n.d(t,{O:()=>s});var r=n(4148),a=n(9914);function s(e,t,n){const s=(0,r.MZ)(e,n);return(0,a.Q)(e,t,s,n)}},5395:(e,t,n)=>{"use strict";n.d(t,{$:()=>i});var r=n(4148),a=n(1426),s=n(9914);function i(e,t,n){if((0,a.HO)(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const i=(0,r.MZ)(e,n);if(3!==i.length&&1!==i.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,s.Q)(e,t,i,n)}},9914:(e,t,n)=>{"use strict";n.d(t,{Q:()=>o});var r=n(2164),a=n(8075),s=n(1426),i=n(8977);function o(e,t,n,o){if(null==o)o=(0,s.X$)(e);else if("complex64"===o)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,a.Nw)(e)||(0,a.Oj)(e)){if("float32"!==o&&"int32"!==o)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${o}.`);return r.T2.backend.createTensorFromGPUData(e,t||n,o)}if(!(0,i.isTypedArray)(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){(0,s.SA)(t);const e=(0,s.Ze)(t),r=(0,s.Ze)(n);(0,s.vA)(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){const e=n[a],r=a!==n.length-1||e!==(0,s.Ze)(t.slice(a));(0,s.vA)(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return(0,i.isTypedArray)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==o?(0,i.toTypedArray)(e,o):(0,i.flatten)(e,[],!0),r.T2.makeTensor(e,t,o)}},3017:(e,t,n)=>{"use strict";n.d(t,{V:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({tile_:function(e,t){const n=(0,s.YT)(e,"x","tile","string_or_numeric");i.vA(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const o={x:n},l={reps:t};return r.T2.runKernel(a.FAs,o,l)}})},2765:(e,t,n)=>{"use strict";n.d(t,{r:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const i=(0,s.YT)(e,"x","topk");if(0===i.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const o=i.shape[i.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);const l={x:i},u={k:t,sorted:n},[c,d]=r.T2.runKernel(a.TBb,l,u);return{values:c,indices:d}}})},2154:(e,t,n)=>{"use strict";n.d(t,{m:()=>p});var r=n(2164),a=n(8046),s=n(9554),i=n(4148),o=n(1426),l=n(6149),u=n(1047),c=n(1011),d=n(7892),h=n(9477);const p=(0,d.op)({transpose_:function(e,t,n){const d=(0,i.YT)(e,"x","transpose");if(null==t&&(t=d.shape.map(((e,t)=>t)).reverse()),o.vA(d.rank===t.length,(()=>`Error in transpose: rank of input ${d.rank} must match length of perm ${t}.`)),t.forEach((e=>{o.vA(e>=0&&e<d.rank,(()=>"All entries in 'perm' must be between 0 and "+(d.rank-1)+` but got ${t}`))})),d.rank<=1)return d.clone();const p={x:d},f={perm:t};return"complex64"===d.dtype?(0,a.DZ)((()=>{let e=(0,h.x)(d),t=(0,u.n)(d);return e=r.T2.runKernel(s.wx0,{x:e},f),t=r.T2.runKernel(s.wx0,{x:t},f),n&&(t=(0,c.H)(t)),(0,l.f)(e,t)})):r.T2.runKernel(s.wx0,p,f)}})},9694:(e,t,n)=>{"use strict";n.d(t,{A:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=(0,s.YT)(e,"x","unique","string_or_numeric");(0,i.vA)(n.rank>0,(()=>"The input tensor must be at least 1D"));const o={x:n},l={axis:t},[u,c]=r.T2.runKernel(a.EwU,o,l);return{values:u,indices:c}}})},5149:(e,t,n)=>{"use strict";n.d(t,{z:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({unsortedSegmentSum_:function(e,t,n){const o=(0,s.YT)(e,"x","unsortedSegmentSum"),l=(0,s.YT)(t,"segmentIds","unsortedSegmentSum","int32");(0,i.vA)((0,i.E6)(n),(()=>"numSegments must be of dtype int"));const u={x:o,segmentIds:l},c={numSegments:n};return r.T2.runKernel(a.pPe,u,c)}})},3984:(e,t,n)=>{"use strict";n.d(t,{K:()=>o});var r=n(2164),a=n(9554),s=n(4148),i=n(1426);const o=(0,n(7892).op)({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=(0,s.YT)(e,"x","unstack","string_or_numeric");i.vA(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const o={value:n},l={axis:t};return r.T2.runKernel(a.dXR,o,l)}})},3986:(e,t,n)=>{"use strict";n.d(t,{_:()=>l});var r=n(2164),a=n(9554),s=n(4148),i=n(4920),o=n(8805);const l=(0,n(7892).op)({where_:function(e,t,n){const l=(0,s.YT)(t,"a","where"),u=(0,s.YT)(n,"b","where"),c=(0,s.YT)(e,"condition","where","bool"),d=(0,o.assertAndGetBroadcastShape)((0,o.assertAndGetBroadcastShape)(c.shape,l.shape),u.shape),h={condition:(0,i.h)(c,d),t:(0,i.h)(l,d),e:(0,i.h)(u,d)};return r.T2.runKernel(a.l6P,h)}})},4218:(e,t,n)=>{"use strict";n.d(t,{U:()=>i});var r=n(2164),a=n(1426),s=n(6149);function i(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if((0,a.SA)(e),"complex64"===t){const t=i(e,"float32"),n=i(e,"float32");return(0,s.f)(t,n)}const n=(0,a.Ty)((0,a.Ze)(e),t);return r.T2.makeTensor(n,e,t)}},3290:(e,t,n)=>{"use strict";n.d(t,{P:()=>i});var r=n(2164),a=n(9554),s=n(4148);const i=(0,n(7892).op)({zerosLike_:function(e){const t={x:(0,s.YT)(e,"x","zerosLike")};return r.T2.runKernel(a.xJ3,t)}})},5767:(e,t,n)=>{"use strict";function r(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}n.d(t,{Y:()=>r})},9494:(e,t,n)=>{"use strict";n.d(t,{qY:()=>w,yl:()=>f,rT:()=>S,tp:()=>k,B4:()=>x,Q5:()=>v,qP:()=>b});var r=n(7926),a=n(1426);const s=20,i=3,o=7;function l(e,t,n,r){const s=(0,a.Ur)(t),i=function(e,t,n,r){const s=(0,a.Ze)(t),i=r[r.length-1],o=new Array(i).fill(0),l=t.length,c="complex64"===n?h(e):e;if(l>1)for(let a=0;a<s/i;a++){const e=a*i;for(let t=0;t<i;t++)o[t]=Math.max(o[t],u(c[e+t],0,n).length)}return o}(e,t,n,s),o=t.length,l=d(e,t,n,s,i),c=["Tensor"];return r&&(c.push(`  dtype: ${n}`),c.push(`  rank: ${o}`),c.push(`  shape: [${t}]`),c.push("  values:")),c.push(l.map((e=>"    "+e)).join("\n")),c.join("\n")}function u(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(o))} + ${parseFloat(e[1].toFixed(o))}j`:(0,a.Kg)(e)?`'${e}'`:"bool"===n?c(e):parseFloat(e.toFixed(o)).toString(),(0,a.av)(r,t)}function c(e){return 0===e?"false":"true"}function d(e,t,n,r,a){let o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const l="complex64"===n?2:1,p=t[0],f=t.length;if(0===f){if("complex64"===n){return[u(h(e)[0],0,n)]}return"bool"===n?[c(e[0])]:[e[0].toString()]}if(1===f){if(p>s){const t=i*l;let r=Array.from(e.slice(0,t)),s=Array.from(e.slice((p-i)*l,p*l));return"complex64"===n&&(r=h(r),s=h(s)),["["+r.map(((e,t)=>u(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>u(e,a[p-i+t],n))).join(", ")+"]"]}return["["+("complex64"===n?h(e):Array.from(e)).map(((e,t)=>u(e,a[t],n))).join(", ")+"]"]}const m=t.slice(1),g=r.slice(1),y=r[0]*l,b=[];if(p>s){for(let t=0;t<i;t++){const r=t*y,s=r+y;b.push(...d(e.slice(r,s),m,n,g,a,!1))}b.push("...");for(let t=p-i;t<p;t++){const r=t*y,s=r+y;b.push(...d(e.slice(r,s),m,n,g,a,t===p-1))}}else for(let s=0;s<p;s++){const t=s*y,r=t+y;b.push(...d(e.slice(t,r),m,n,g,a,s===p-1))}const v=2===f?",":"";b[0]="["+(p>0?b[0]+v:"");for(let s=1;s<b.length-1;s++)b[s]=" "+b[s]+v;let x=",\n";for(let s=2;s<f;s++)x+="\n";return b[b.length-1]=" "+b[b.length-1]+"]"+(o?"":x),b}function h(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var p=n(8977);class f{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=a.Ze(e),null!=n){const e=n.length;a.vA(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||a.Ab(t,this.size),this.strides=(0,a.Ur)(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),a.vA(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));const s=this.locToIndex(n);this.values[s]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(const s of t){if(s<0||s>=this.shape[r]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let a=t[t.length-1];for(let s=0;s<t.length-1;++s)a+=this.strides[s]*t[s];return this.values[a]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return m().makeTensor(this.values,this.shape,this.dtype)}}let m=null,g=null,y=null;function b(e){m=e}function v(e){g=e}function x(e){y=e}class w{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=a.Ze(e),this.strides=(0,a.Ur)(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return g.buffer(this.shape,this.dtype,e)}bufferSync(){return g.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return(0,a.yw)(this.shape,e,"complex64"===this.dtype)}arraySync(){return(0,a.yw)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=m().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>p.decodeString(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),m().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=m().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>p.decodeString(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await m().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),m().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return g.print(this,e)}clone(){return this.throwIfDisposed(),g.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return l(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),g.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),m().makeVariable(this,e,t,n)}}function k(){return(0,r.m)("Tensor",(()=>w))}Object.defineProperty(w,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),k();class S extends w{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!a.r1(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);m().disposeTensor(this),this.dataId=e.dataId,m().incRef(this,null)}dispose(){m().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(S,Symbol.hasInstance,{value:e=>e instanceof w&&null!=e.assign&&e.assign instanceof Function})},8804:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assertTypesMatch:()=>o,getTensorsInContainer:()=>u,isTensorInList:()=>l,makeTypesMatch:()=>i});var r=n(9494),a=n(8075),s=n(1426);function i(e,t){if(e.dtype===t.dtype)return[e,t];const n=(0,a.Tu)(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function o(e,t){(0,s.vA)(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function l(e,t){return t.some((t=>t.id===e.id))}function u(e){const t=[];return c(e,t,new Set),t}function c(e,t,n){if(null==e)return;if(e instanceof r.qY)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!==typeof a)return;var a;const s=e;for(const r in s){const e=s[r];n.has(e)||(n.add(e),c(e,t,n))}}},4148:(e,t,n)=>{"use strict";n.d(t,{MZ:()=>u,YT:()=>h,j1:()=>p});var r=n(2164),a=n(5399),s=n(9494),i=n(8075),o=n(8977),l=n(1426);function u(e,t){let n=e;if((0,o.isTypedArray)(e))return"string"===t?[]:[e.length];if((0,i.Oj)(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if((0,i.Nw)(e))return[e.buffer.size/(null==t?4:(0,l.jv)(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||(0,o.isTypedArray)(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&(0,a._K)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&c(e,r,[]),r}function c(e,t,n){if(n=n||[],!Array.isArray(e)&&!(0,o.isTypedArray)(e))return void(0,l.vA)(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));(0,l.vA)(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),(0,l.vA)(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let a=0;a<e.length;++a)c(e[a],r,n.concat(a))}function d(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function h(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof(0,s.tp)())return d(a,e.dtype,t,n),e;let i=(0,l.X$)(e);if("string"!==i&&["bool","int32","float32"].indexOf(a)>=0&&(i=a),d(a,i,t,n),null==e||!(0,o.isTypedArray)(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const c=u(e,i);(0,o.isTypedArray)(e)||Array.isArray(e)||(e=[e]);const h="string"!==i?(0,o.toTypedArray)(e,i):(0,o.flatten)(e,[],!0);return r.T2.makeTensor(h,c,i)}function p(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>h(e,`${t}[${a}]`,n,r)))}},8075:(e,t,n)=>{"use strict";var r,a,s,i,o;n.d(t,{Nw:()=>h,Oj:()=>d,Tu:()=>u,ch:()=>c,rg:()=>r}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(r||(r={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(a||(a={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(s||(s={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(i||(i={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(o||(o={}));const l={float32:i,int32:a,bool:s,complex64:o};function u(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return l[e][t]}function c(e){return u(e,"int32")}function d(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function h(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}},8977:(e,t,n)=>{"use strict";n.r(t),n.d(t,{arraysEqual:()=>s.r1,arraysEqualWithNull:()=>s.e_,assert:()=>s.vA,assertNonNegativeIntegerDimensions:()=>s.SA,assertNonNull:()=>s.HO,assertShapesMatch:()=>s.O3,bytesFromStringArray:()=>s.SL,bytesPerElement:()=>s.jv,checkConversionForErrors:()=>s.nd,clamp:()=>s.qE,computeStrides:()=>s.Ur,convertBackendValuesAndArrayBuffer:()=>s.o2,createScalarValue:()=>x,createShuffledIndices:()=>s.P8,decodeString:()=>T,distSquared:()=>s.oO,encodeString:()=>I,fetch:()=>S,fingerPrint64:()=>v,flatten:()=>C,getArrayFromDType:()=>s.Ab,getTypedArrayFromDType:()=>s.ce,hasEncodingLoss:()=>s.BE,hexToLong:()=>l,indexToLoc:()=>s._k,inferDtype:()=>s.X$,inferFromImplicitShape:()=>s.XT,isBoolean:()=>s.Lm,isFunction:()=>s.Tn,isInt:()=>s.E6,isNumber:()=>s.Et,isPromise:()=>s.yL,isScalarShape:()=>s.Sf,isString:()=>s.Kg,isTypedArray:()=>N,isValidDtype:()=>s.xn,locToIndex:()=>s.sX,makeOnesTypedArray:()=>s.FZ,makeZerosNestedTypedArray:()=>s.c7,makeZerosTypedArray:()=>s.Ty,nearestDivisor:()=>s.lK,nearestLargerEven:()=>s.eV,now:()=>k,parseAxisParam:()=>s.Y6,randUniform:()=>s.so,repeatedTry:()=>s._q,rightPad:()=>s.av,shuffle:()=>s.k4,shuffleCombo:()=>s.a0,sizeFromShape:()=>s.Ze,sizeToSquarishShape:()=>s.gS,squeezeShape:()=>s.gx,sum:()=>s.cz,swap:()=>s.wg,tanh:()=>s.ym,toNestedArray:()=>s.yw,toTypedArray:()=>w});var r=n(5399),a=n(5767),s=n(1426),i=n(8818);const o=n.n(i)()||i;function l(e){return o.fromString(e,!0,16)}const u=l("c3a5c85c97cb3127"),c=l("b492b66fbe98f273"),d=l("9ae16a3b2f90404f");function h(e){return e.xor(e.shru(47))}function p(e,t,n){const r=e.slice(t,t+n);return o.fromBytes(Array.from(r),!0,!0)}function f(e,t){return p(e,t,8)}function m(e,t){return p(e,t,4)}function g(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:l("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function b(e,t,n,r){return function(e,t,n,r,a,s){a=a.add(e),s=g(s.add(a).add(r),21);const i=a;return a=(a=a.add(t)).add(n),s=s.add(g(a,44)),[a.add(r),s.add(i)]}(f(e,t),f(e,t+8),f(e,t+16),f(e,t+24),n,r)}function v(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=o.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=d.add(2*t),r=f(e,0).add(d),a=f(e,t-8);return y(g(a,37).mul(n).add(r),g(r,25).add(a).mul(n),n)}if(t>=4){const n=d.add(2*t);return y(m(e,0).shl(3).add(t),m(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return h(d.mul(n).xor(u.mul(r))).mul(d)}return d}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=d.add(2*t),r=f(e,0).mul(c),a=f(e,8),s=f(e,t-8).mul(n),i=f(e,t-16).mul(d);return y(g(r.add(a),43).add(g(s,30)).add(i),r.add(g(a.add(d),18)).add(s),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=d.add(2*t),r=f(e,0).mul(d),a=f(e,8),s=f(e,t-8).mul(n),i=f(e,t-16).mul(d),o=g(r.add(a),43).add(g(s,30)).add(i),l=y(o,r.add(g(a.add(d),18)).add(s),n),u=f(e,16).mul(n),c=f(e,24),h=o.add(f(e,t-32)).mul(n),p=l.add(f(e,t-24)).mul(n);return y(g(u.add(c),43).add(g(h,30)).add(p),u.add(g(c.add(r),18)).add(h),n)}(e,t);let r=n,a=n.mul(c).add(113),s=h(a.mul(d).add(113)).mul(d),i=[o.UZERO,o.UZERO],l=[o.UZERO,o.UZERO];r=r.mul(d).add(f(e,0));let p=0;const v=64*(t-1>>6),x=v+(t-1&63)-63;do{r=g(r.add(a).add(i[0]).add(f(e,p+8)),37).mul(c),a=g(a.add(i[1]).add(f(e,p+48)),42).mul(c),r=r.xor(l[1]),a=a.add(i[0]).add(f(e,p+40)),s=g(s.add(l[0]),33).mul(c),i=b(e,p,i[1].mul(c),r.add(l[0])),l=b(e,p+32,s.add(l[1]),a.add(f(e,p+16))),[s,r]=[r,s],p+=64}while(p!==v);const w=c.add(s.and(255).shl(1));return p=x,l[0]=l[0].add(t-1&63),i[0]=i[0].add(l[0]),l[0]=l[0].add(i[0]),r=g(r.add(a).add(i[0]).add(f(e,p+8)),37).mul(w),a=g(a.add(i[1]).add(f(e,p+48)),42).mul(w),r=r.xor(l[1].mul(9)),a=a.add(i[0].mul(9).add(f(e,p+40))),s=g(s.add(l[0]),33).mul(w),i=b(e,p,i[1].mul(w),r.add(l[0])),l=b(e,p+32,s.add(l[1]),a.add(f(e,p+16))),[s,r]=[r,s],y(y(i[0],l[0],w).add(h(a).mul(u)).add(s),y(i[1],l[1],w).add(r),w)}function x(e,t){return"string"===t?I(e):w([e],t)}function w(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=C(e)),(0,r._K)().getBool("DEBUG")&&s.nd(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function k(){return(0,r._K)().platform.now()}function S(e,t){return(0,r._K)().platform.fetch(e,t)}function I(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",(0,r._K)().platform.encode(e,t)}function T(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",(0,r._K)().platform.decode(e,t)}function N(e){return null!=(0,r._K)().platform.isTypedArray?(0,r._K)().platform.isTypedArray(e):(0,a.Y)(e)}function C(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||s.yL(e)||null==e||N(e)&&n)t.push(e);else if(Array.isArray(e)||N(e))for(let r=0;r<e.length;++r)C(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)C(e[a],t,n)}return t}},1426:(e,t,n)=>{"use strict";function r(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,o(e,t,n)}function a(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,o(e,n,r),o(t,n,r)}function s(e,t,n){return Math.max(e,Math.min(t,n))}function i(e){return e%2===0?e:e+1}function o(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function l(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function u(e,t){const n=Math.random();return t*n+(1-n)*e}function c(e,t){let n=0;for(let r=0;r<e.length;r++){const a=Number(e[r])-Number(t[r]);n+=a*a}return n}function d(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";d(y(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function p(e){d(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function f(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function m(e){return 0===e.length}function g(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function y(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function b(e){return e%1===0}function v(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function x(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function w(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return r(t),t}function k(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function S(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,s)=>{let i=0;const o=()=>{if(e())return void a();i++;const l=t(i);null!=n&&i>=n?s():null!=r?r(o,l):setTimeout(o,l)};o()}))}function I(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const a=e.slice();return a[r]=t/n,a}function T(e,t){const n=t.length;return d((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),d(e.every((e=>b(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function N(e,t){const n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:T(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function C(e,t){return A(e,t)}function A(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function E(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function _(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function $(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function R(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function D(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function M(e){return"string"===typeof e||e instanceof String}function F(e){return"boolean"===typeof e}function O(e){return"number"===typeof e}function P(e){return Array.isArray(e)?P(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":O(e)?"float32":M(e)?"string":F(e)?"bool":"float32"}function L(e){return!!(e&&e.constructor&&e.call&&e.apply)}function z(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function B(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function V(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=new Array;if(1===t.length){const s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{const s=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=V(e+t*o,i,n,r)}return a}function W(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return V(0,e,t,n)}function U(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function j(e,t){const n=G(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function G(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function H(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return W(e,new Float32Array(n));if("int32"===t)return W(e,new Int32Array(n));if("bool"===t)return W(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function q(e){e.forEach((t=>{d(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function K(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function Y(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function X(e){return e&&e.then&&"function"===typeof e.then}n.d(t,{Ab:()=>A,BE:()=>$,E6:()=>b,Et:()=>O,FZ:()=>j,HO:()=>p,Kg:()=>M,Lm:()=>F,O3:()=>h,P8:()=>w,SA:()=>q,SL:()=>D,Sf:()=>m,Tn:()=>L,Ty:()=>G,Ur:()=>B,X$:()=>P,XT:()=>I,Y6:()=>T,Ze:()=>f,_k:()=>Y,_q:()=>S,a0:()=>a,av:()=>k,c7:()=>H,ce:()=>C,cz:()=>l,eV:()=>i,e_:()=>g,gS:()=>x,gx:()=>N,jv:()=>R,k4:()=>r,lK:()=>z,nd:()=>E,o2:()=>U,oO:()=>c,qE:()=>s,r1:()=>y,sX:()=>K,so:()=>u,vA:()=>d,wg:()=>o,xn:()=>_,yL:()=>X,ym:()=>v,yw:()=>W})},8818:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(T){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var a={},s={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=s[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(s[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=a[e])?r:(n=l(e,e<0?-1:0,!1),i&&(a[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?o(-e,t).neg():l(e%h|0,e/h|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var a=o(u(n,8)),s=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),d=parseInt(e.substring(i,i+l),n);if(l<8){var h=o(u(n,l));s=s.mul(h).add(o(d))}else s=(s=s.mul(a)).add(o(d))}return s.unsigned=t,s}function d(e,t){return"number"===typeof e?o(e,t):"string"===typeof e?c(e,t):l(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var v=i(1,!0);n.UONE=v;var x=i(-1);n.NEG_ONE=x;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=o(u(e,6),this.unsigned),s=this,i="";;){var l=s.div(a),c=(s.sub(l.mul(a)).toInt()>>>0).toString(e);if((s=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},I.neg=I.negate,I.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,a=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,h=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,h+=(p+=a+u)>>>16,c+=(h+=n+o)>>>16,c+=t+i,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(h&=65535),this.unsigned)},I.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=d(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,a=65535&this.high,s=this.low>>>16,i=65535&this.low,u=e.high>>>16,c=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,v=0;return b+=(v+=i*p)>>>16,y+=(b+=s*p)>>>16,b&=65535,y+=(b+=i*h)>>>16,f+=(y+=a*p)>>>16,y&=65535,f+=(y+=s*h)>>>16,y&=65535,f+=(y+=i*c)>>>16,f+=n*p+a*h+s*c+i*u,l((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,a,s;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return v;s=y}else{if(this.eq(S))return e.eq(b)||e.eq(x)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:x:(a=this.sub(e.mul(n)),s=n.add(a.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=g}for(a=this;a.gte(e);){n=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),h=o(n),p=h.mul(e);p.isNegative()||p.gt(a);)p=(h=o(n-=c,this.unsigned)).mul(e);h.isZero()&&(h=b),s=s.add(h),a=a.sub(p)}return s},I.div=I.divide,I.modulo=function(e){return r(e)||(e=d(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(e){return r(e)||(e=d(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return r(e)||(e=d(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return r(e)||(e=d(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},7780:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.BlockCipher,r=e.algo,a=[],s=[],i=[],o=[],l=[],u=[],c=[],d=[],h=[],p=[];!function(){for(var e=[],t=0;t<256;t++)e[t]=t<128?t<<1:t<<1^283;var n=0,r=0;for(t=0;t<256;t++){var f=r^r<<1^r<<2^r<<3^r<<4;f=f>>>8^255&f^99,a[n]=f,s[f]=n;var m=e[n],g=e[m],y=e[g],b=257*e[f]^16843008*f;i[n]=b<<24|b>>>8,o[n]=b<<16|b>>>16,l[n]=b<<8|b>>>24,u[n]=b,b=16843009*y^65537*g^257*m^16843008*n,c[f]=b<<24|b>>>8,d[f]=b<<16|b>>>16,h[f]=b<<8|b>>>24,p[f]=b,n?(n=m^e[e[e[y^m]]],r^=e[e[r]]):n=r=1}}();var f=[0,1,2,4,8,16,32,64,128,27,54],m=r.AES=n.extend({_doReset:function(){if(!this._nRounds||this._keyPriorReset!==this._key){for(var e=this._keyPriorReset=this._key,t=e.words,n=e.sigBytes/4,r=4*((this._nRounds=n+6)+1),s=this._keySchedule=[],i=0;i<r;i++)i<n?s[i]=t[i]:(u=s[i-1],i%n?n>6&&i%n==4&&(u=a[u>>>24]<<24|a[u>>>16&255]<<16|a[u>>>8&255]<<8|a[255&u]):(u=a[(u=u<<8|u>>>24)>>>24]<<24|a[u>>>16&255]<<16|a[u>>>8&255]<<8|a[255&u],u^=f[i/n|0]<<24),s[i]=s[i-n]^u);for(var o=this._invKeySchedule=[],l=0;l<r;l++){if(i=r-l,l%4)var u=s[i];else u=s[i-4];o[l]=l<4||i<=4?u:c[a[u>>>24]]^d[a[u>>>16&255]]^h[a[u>>>8&255]]^p[a[255&u]]}}},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._keySchedule,i,o,l,u,a)},decryptBlock:function(e,t){var n=e[t+1];e[t+1]=e[t+3],e[t+3]=n,this._doCryptBlock(e,t,this._invKeySchedule,c,d,h,p,s),n=e[t+1],e[t+1]=e[t+3],e[t+3]=n},_doCryptBlock:function(e,t,n,r,a,s,i,o){for(var l=this._nRounds,u=e[t]^n[0],c=e[t+1]^n[1],d=e[t+2]^n[2],h=e[t+3]^n[3],p=4,f=1;f<l;f++){var m=r[u>>>24]^a[c>>>16&255]^s[d>>>8&255]^i[255&h]^n[p++],g=r[c>>>24]^a[d>>>16&255]^s[h>>>8&255]^i[255&u]^n[p++],y=r[d>>>24]^a[h>>>16&255]^s[u>>>8&255]^i[255&c]^n[p++],b=r[h>>>24]^a[u>>>16&255]^s[c>>>8&255]^i[255&d]^n[p++];u=m,c=g,d=y,h=b}m=(o[u>>>24]<<24|o[c>>>16&255]<<16|o[d>>>8&255]<<8|o[255&h])^n[p++],g=(o[c>>>24]<<24|o[d>>>16&255]<<16|o[h>>>8&255]<<8|o[255&u])^n[p++],y=(o[d>>>24]<<24|o[h>>>16&255]<<16|o[u>>>8&255]<<8|o[255&c])^n[p++],b=(o[h>>>24]<<24|o[u>>>16&255]<<16|o[c>>>8&255]<<8|o[255&d])^n[p++],e[t]=m,e[t+1]=g,e[t+2]=y,e[t+3]=b},keySize:8});e.AES=n._createHelper(m)}(),t.AES)}()},6501:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.BlockCipher,r=e.algo;const a=16,s=[608135816,2242054355,320440878,57701188,2752067618,698298832,137296536,3964562569,1160258022,953160567,3193202383,887688300,3232508343,3380367581,1065670069,3041331479,2450970073,2306472731],i=[[3509652390,2564797868,805139163,3491422135,3101798381,1780907670,3128725573,4046225305,614570311,3012652279,134345442,2240740374,1667834072,1901547113,2757295779,4103290238,227898511,1921955416,1904987480,2182433518,2069144605,3260701109,2620446009,720527379,3318853667,677414384,3393288472,3101374703,2390351024,1614419982,1822297739,2954791486,3608508353,3174124327,2024746970,1432378464,3864339955,2857741204,1464375394,1676153920,1439316330,715854006,3033291828,289532110,2706671279,2087905683,3018724369,1668267050,732546397,1947742710,3462151702,2609353502,2950085171,1814351708,2050118529,680887927,999245976,1800124847,3300911131,1713906067,1641548236,4213287313,1216130144,1575780402,4018429277,3917837745,3693486850,3949271944,596196993,3549867205,258830323,2213823033,772490370,2760122372,1774776394,2652871518,566650946,4142492826,1728879713,2882767088,1783734482,3629395816,2517608232,2874225571,1861159788,326777828,3124490320,2130389656,2716951837,967770486,1724537150,2185432712,2364442137,1164943284,2105845187,998989502,3765401048,2244026483,1075463327,1455516326,1322494562,910128902,469688178,1117454909,936433444,3490320968,3675253459,1240580251,122909385,2157517691,634681816,4142456567,3825094682,3061402683,2540495037,79693498,3249098678,1084186820,1583128258,426386531,1761308591,1047286709,322548459,995290223,1845252383,2603652396,3431023940,2942221577,3202600964,3727903485,1712269319,422464435,3234572375,1170764815,3523960633,3117677531,1434042557,442511882,3600875718,1076654713,1738483198,4213154764,2393238008,3677496056,1014306527,4251020053,793779912,2902807211,842905082,4246964064,1395751752,1040244610,2656851899,3396308128,445077038,3742853595,3577915638,679411651,2892444358,2354009459,1767581616,3150600392,3791627101,3102740896,284835224,4246832056,1258075500,768725851,2589189241,3069724005,3532540348,1274779536,3789419226,2764799539,1660621633,3471099624,4011903706,913787905,3497959166,737222580,2514213453,2928710040,3937242737,1804850592,3499020752,2949064160,2386320175,2390070455,2415321851,4061277028,2290661394,2416832540,1336762016,1754252060,3520065937,3014181293,791618072,3188594551,3933548030,2332172193,3852520463,3043980520,413987798,3465142937,3030929376,4245938359,2093235073,3534596313,375366246,2157278981,2479649556,555357303,3870105701,2008414854,3344188149,4221384143,3956125452,2067696032,3594591187,2921233993,2428461,544322398,577241275,1471733935,610547355,4027169054,1432588573,1507829418,2025931657,3646575487,545086370,48609733,2200306550,1653985193,298326376,1316178497,3007786442,2064951626,458293330,2589141269,3591329599,3164325604,727753846,2179363840,146436021,1461446943,4069977195,705550613,3059967265,3887724982,4281599278,3313849956,1404054877,2845806497,146425753,1854211946],[1266315497,3048417604,3681880366,3289982499,290971e4,1235738493,2632868024,2414719590,3970600049,1771706367,1449415276,3266420449,422970021,1963543593,2690192192,3826793022,1062508698,1531092325,1804592342,2583117782,2714934279,4024971509,1294809318,4028980673,1289560198,2221992742,1669523910,35572830,157838143,1052438473,1016535060,1802137761,1753167236,1386275462,3080475397,2857371447,1040679964,2145300060,2390574316,1461121720,2956646967,4031777805,4028374788,33600511,2920084762,1018524850,629373528,3691585981,3515945977,2091462646,2486323059,586499841,988145025,935516892,3367335476,2599673255,2839830854,265290510,3972581182,2759138881,3795373465,1005194799,847297441,406762289,1314163512,1332590856,1866599683,4127851711,750260880,613907577,1450815602,3165620655,3734664991,3650291728,3012275730,3704569646,1427272223,778793252,1343938022,2676280711,2052605720,1946737175,3164576444,3914038668,3967478842,3682934266,1661551462,3294938066,4011595847,840292616,3712170807,616741398,312560963,711312465,1351876610,322626781,1910503582,271666773,2175563734,1594956187,70604529,3617834859,1007753275,1495573769,4069517037,2549218298,2663038764,504708206,2263041392,3941167025,2249088522,1514023603,1998579484,1312622330,694541497,2582060303,2151582166,1382467621,776784248,2618340202,3323268794,2497899128,2784771155,503983604,4076293799,907881277,423175695,432175456,1378068232,4145222326,3954048622,3938656102,3820766613,2793130115,2977904593,26017576,3274890735,3194772133,1700274565,1756076034,4006520079,3677328699,720338349,1533947780,354530856,688349552,3973924725,1637815568,332179504,3949051286,53804574,2852348879,3044236432,1282449977,3583942155,3416972820,4006381244,1617046695,2628476075,3002303598,1686838959,431878346,2686675385,1700445008,1080580658,1009431731,832498133,3223435511,2605976345,2271191193,2516031870,1648197032,4164389018,2548247927,300782431,375919233,238389289,3353747414,2531188641,2019080857,1475708069,455242339,2609103871,448939670,3451063019,1395535956,2413381860,1841049896,1491858159,885456874,4264095073,4001119347,1565136089,3898914787,1108368660,540939232,1173283510,2745871338,3681308437,4207628240,3343053890,4016749493,1699691293,1103962373,3625875870,2256883143,3830138730,1031889488,3479347698,1535977030,4236805024,3251091107,2132092099,1774941330,1199868427,1452454533,157007616,2904115357,342012276,595725824,1480756522,206960106,497939518,591360097,863170706,2375253569,3596610801,1814182875,2094937945,3421402208,1082520231,3463918190,2785509508,435703966,3908032597,1641649973,2842273706,3305899714,1510255612,2148256476,2655287854,3276092548,4258621189,236887753,3681803219,274041037,1734335097,3815195456,3317970021,1899903192,1026095262,4050517792,356393447,2410691914,3873677099,3682840055],[3913112168,2491498743,4132185628,2489919796,1091903735,1979897079,3170134830,3567386728,3557303409,857797738,1136121015,1342202287,507115054,2535736646,337727348,3213592640,1301675037,2528481711,1895095763,1721773893,3216771564,62756741,2142006736,835421444,2531993523,1442658625,3659876326,2882144922,676362277,1392781812,170690266,3921047035,1759253602,3611846912,1745797284,664899054,1329594018,3901205900,3045908486,2062866102,2865634940,3543621612,3464012697,1080764994,553557557,3656615353,3996768171,991055499,499776247,1265440854,648242737,3940784050,980351604,3713745714,1749149687,3396870395,4211799374,3640570775,1161844396,3125318951,1431517754,545492359,4268468663,3499529547,1437099964,2702547544,3433638243,2581715763,2787789398,1060185593,1593081372,2418618748,4260947970,69676912,2159744348,86519011,2512459080,3838209314,1220612927,3339683548,133810670,1090789135,1078426020,1569222167,845107691,3583754449,4072456591,1091646820,628848692,1613405280,3757631651,526609435,236106946,48312990,2942717905,3402727701,1797494240,859738849,992217954,4005476642,2243076622,3870952857,3732016268,765654824,3490871365,2511836413,1685915746,3888969200,1414112111,2273134842,3281911079,4080962846,172450625,2569994100,980381355,4109958455,2819808352,2716589560,2568741196,3681446669,3329971472,1835478071,660984891,3704678404,4045999559,3422617507,3040415634,1762651403,1719377915,3470491036,2693910283,3642056355,3138596744,1364962596,2073328063,1983633131,926494387,3423689081,2150032023,4096667949,1749200295,3328846651,309677260,2016342300,1779581495,3079819751,111262694,1274766160,443224088,298511866,1025883608,3806446537,1145181785,168956806,3641502830,3584813610,1689216846,3666258015,3200248200,1692713982,2646376535,4042768518,1618508792,1610833997,3523052358,4130873264,2001055236,3610705100,2202168115,4028541809,2961195399,1006657119,2006996926,3186142756,1430667929,3210227297,1314452623,4074634658,4101304120,2273951170,1399257539,3367210612,3027628629,1190975929,2062231137,2333990788,2221543033,2438960610,1181637006,548689776,2362791313,3372408396,3104550113,3145860560,296247880,1970579870,3078560182,3769228297,1714227617,3291629107,3898220290,166772364,1251581989,493813264,448347421,195405023,2709975567,677966185,3703036547,1463355134,2715995803,1338867538,1343315457,2802222074,2684532164,233230375,2599980071,2000651841,3277868038,1638401717,4028070440,3237316320,6314154,819756386,300326615,590932579,1405279636,3267499572,3150704214,2428286686,3959192993,3461946742,1862657033,1266418056,963775037,2089974820,2263052895,1917689273,448879540,3550394620,3981727096,150775221,3627908307,1303187396,508620638,2975983352,2726630617,1817252668,1876281319,1457606340,908771278,3720792119,3617206836,2455994898,1729034894,1080033504],[976866871,3556439503,2881648439,1522871579,1555064734,1336096578,3548522304,2579274686,3574697629,3205460757,3593280638,3338716283,3079412587,564236357,2993598910,1781952180,1464380207,3163844217,3332601554,1699332808,1393555694,1183702653,3581086237,1288719814,691649499,2847557200,2895455976,3193889540,2717570544,1781354906,1676643554,2592534050,3230253752,1126444790,2770207658,2633158820,2210423226,2615765581,2414155088,3127139286,673620729,2805611233,1269405062,4015350505,3341807571,4149409754,1057255273,2012875353,2162469141,2276492801,2601117357,993977747,3918593370,2654263191,753973209,36408145,2530585658,25011837,3520020182,2088578344,530523599,2918365339,1524020338,1518925132,3760827505,3759777254,1202760957,3985898139,3906192525,674977740,4174734889,2031300136,2019492241,3983892565,4153806404,3822280332,352677332,2297720250,60907813,90501309,3286998549,1016092578,2535922412,2839152426,457141659,509813237,4120667899,652014361,1966332200,2975202805,55981186,2327461051,676427537,3255491064,2882294119,3433927263,1307055953,942726286,933058658,2468411793,3933900994,4215176142,1361170020,2001714738,2830558078,3274259782,1222529897,1679025792,2729314320,3714953764,1770335741,151462246,3013232138,1682292957,1483529935,471910574,1539241949,458788160,3436315007,1807016891,3718408830,978976581,1043663428,3165965781,1927990952,4200891579,2372276910,3208408903,3533431907,1412390302,2931980059,4132332400,1947078029,3881505623,4168226417,2941484381,1077988104,1320477388,886195818,18198404,3786409e3,2509781533,112762804,3463356488,1866414978,891333506,18488651,661792760,1628790961,3885187036,3141171499,876946877,2693282273,1372485963,791857591,2686433993,3759982718,3167212022,3472953795,2716379847,445679433,3561995674,3504004811,3574258232,54117162,3331405415,2381918588,3769707343,4154350007,1140177722,4074052095,668550556,3214352940,367459370,261225585,2610173221,4209349473,3468074219,3265815641,314222801,3066103646,3808782860,282218597,3406013506,3773591054,379116347,1285071038,846784868,2669647154,3771962079,3550491691,2305946142,453669953,1268987020,3317592352,3279303384,3744833421,2610507566,3859509063,266596637,3847019092,517658769,3462560207,3443424879,370717030,4247526661,2224018117,4143653529,4112773975,2788324899,2477274417,1456262402,2901442914,1517677493,1846949527,2295493580,3734397586,2176403920,1280348187,1908823572,3871786941,846861322,1172426758,3287448474,3383383037,1655181056,3139813346,901632758,1897031941,2986607138,3066810236,3447102507,1393639104,373351379,950779232,625454576,3124240540,4148612726,2007998917,544563296,2244738638,2330496472,2058025392,1291430526,424198748,50039436,29584100,3605783033,2429876329,2791104160,1057563949,3255363231,3075367218,3463963227,1469046755,985887462]];var o={pbox:[],sbox:[]};function l(e,t){let n=t>>24&255,r=t>>16&255,a=t>>8&255,s=255&t,i=e.sbox[0][n]+e.sbox[1][r];return i^=e.sbox[2][a],i+=e.sbox[3][s],i}function u(e,t,n){let r,s=t,i=n;for(let o=0;o<a;++o)s^=e.pbox[o],i=l(e,s)^i,r=s,s=i,i=r;return r=s,s=i,i=r,i^=e.pbox[a],s^=e.pbox[a+1],{left:s,right:i}}function c(e,t,n){let r,s=t,i=n;for(let o=a+1;o>1;--o)s^=e.pbox[o],i=l(e,s)^i,r=s,s=i,i=r;return r=s,s=i,i=r,i^=e.pbox[1],s^=e.pbox[0],{left:s,right:i}}function d(e,t,n){for(let a=0;a<4;a++){e.sbox[a]=[];for(let t=0;t<256;t++)e.sbox[a][t]=i[a][t]}let r=0;for(let i=0;i<a+2;i++)e.pbox[i]=s[i]^t[r],r++,r>=n&&(r=0);let o=0,l=0,c=0;for(let s=0;s<a+2;s+=2)c=u(e,o,l),o=c.left,l=c.right,e.pbox[s]=o,e.pbox[s+1]=l;for(let a=0;a<4;a++)for(let t=0;t<256;t+=2)c=u(e,o,l),o=c.left,l=c.right,e.sbox[a][t]=o,e.sbox[a][t+1]=l;return!0}var h=r.Blowfish=n.extend({_doReset:function(){if(this._keyPriorReset!==this._key){var e=this._keyPriorReset=this._key,t=e.words,n=e.sigBytes/4;d(o,t,n)}},encryptBlock:function(e,t){var n=u(o,e[t],e[t+1]);e[t]=n.left,e[t+1]=n.right},decryptBlock:function(e,t){var n=c(o,e[t],e[t+1]);e[t]=n.left,e[t+1]=n.right},blockSize:2,keySize:4,ivSize:2});e.Blowfish=n._createHelper(h)}(),t.Blowfish)}()},2238:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8211),void(t.lib.Cipher||function(e){var n=t,r=n.lib,a=r.Base,s=r.WordArray,i=r.BufferedBlockAlgorithm,o=n.enc,l=(o.Utf8,o.Base64),u=n.algo.EvpKDF,c=r.Cipher=i.extend({cfg:a.extend(),createEncryptor:function(e,t){return this.create(this._ENC_XFORM_MODE,e,t)},createDecryptor:function(e,t){return this.create(this._DEC_XFORM_MODE,e,t)},init:function(e,t,n){this.cfg=this.cfg.extend(n),this._xformMode=e,this._key=t,this.reset()},reset:function(){i.reset.call(this),this._doReset()},process:function(e){return this._append(e),this._process()},finalize:function(e){return e&&this._append(e),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(){function e(e){return"string"==typeof e?v:y}return function(t){return{encrypt:function(n,r,a){return e(r).encrypt(t,n,r,a)},decrypt:function(n,r,a){return e(r).decrypt(t,n,r,a)}}}}()}),d=(r.StreamCipher=c.extend({_doFinalize:function(){return this._process(!0)},blockSize:1}),n.mode={}),h=r.BlockCipherMode=a.extend({createEncryptor:function(e,t){return this.Encryptor.create(e,t)},createDecryptor:function(e,t){return this.Decryptor.create(e,t)},init:function(e,t){this._cipher=e,this._iv=t}}),p=d.CBC=function(){var t=h.extend();function n(t,n,r){var a,s=this._iv;s?(a=s,this._iv=e):a=this._prevBlock;for(var i=0;i<r;i++)t[n+i]^=a[i]}return t.Encryptor=t.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize;n.call(this,e,t,a),r.encryptBlock(e,t),this._prevBlock=e.slice(t,t+a)}}),t.Decryptor=t.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize,s=e.slice(t,t+a);r.decryptBlock(e,t),n.call(this,e,t,a),this._prevBlock=s}}),t}(),f=(n.pad={}).Pkcs7={pad:function(e,t){for(var n=4*t,r=n-e.sigBytes%n,a=r<<24|r<<16|r<<8|r,i=[],o=0;o<r;o+=4)i.push(a);var l=s.create(i,r);e.concat(l)},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},m=(r.BlockCipher=c.extend({cfg:c.cfg.extend({mode:p,padding:f}),reset:function(){var e;c.reset.call(this);var t=this.cfg,n=t.iv,r=t.mode;this._xformMode==this._ENC_XFORM_MODE?e=r.createEncryptor:(e=r.createDecryptor,this._minBufferSize=1),this._mode&&this._mode.__creator==e?this._mode.init(this,n&&n.words):(this._mode=e.call(r,this,n&&n.words),this._mode.__creator=e)},_doProcessBlock:function(e,t){this._mode.processBlock(e,t)},_doFinalize:function(){var e,t=this.cfg.padding;return this._xformMode==this._ENC_XFORM_MODE?(t.pad(this._data,this.blockSize),e=this._process(!0)):(e=this._process(!0),t.unpad(e)),e},blockSize:4}),r.CipherParams=a.extend({init:function(e){this.mixIn(e)},toString:function(e){return(e||this.formatter).stringify(this)}})),g=(n.format={}).OpenSSL={stringify:function(e){var t=e.ciphertext,n=e.salt;return(n?s.create([1398893684,1701076831]).concat(n).concat(t):t).toString(l)},parse:function(e){var t,n=l.parse(e),r=n.words;return 1398893684==r[0]&&1701076831==r[1]&&(t=s.create(r.slice(2,4)),r.splice(0,4),n.sigBytes-=16),m.create({ciphertext:n,salt:t})}},y=r.SerializableCipher=a.extend({cfg:a.extend({format:g}),encrypt:function(e,t,n,r){r=this.cfg.extend(r);var a=e.createEncryptor(n,r),s=a.finalize(t),i=a.cfg;return m.create({ciphertext:s,key:n,iv:i.iv,algorithm:e,mode:i.mode,padding:i.padding,blockSize:e.blockSize,formatter:r.format})},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),e.createDecryptor(n,r).finalize(t.ciphertext)},_parse:function(e,t){return"string"==typeof e?t.parse(e,this):e}}),b=(n.kdf={}).OpenSSL={execute:function(e,t,n,r,a){if(r||(r=s.random(8)),a)i=u.create({keySize:t+n,hasher:a}).compute(e,r);else var i=u.create({keySize:t+n}).compute(e,r);var o=s.create(i.words.slice(t),4*n);return i.sigBytes=4*t,m.create({key:i,iv:o,salt:r})}},v=r.PasswordBasedCipher=y.extend({cfg:y.cfg.extend({kdf:b}),encrypt:function(e,t,n,r){var a=(r=this.cfg.extend(r)).kdf.execute(n,e.keySize,e.ivSize,r.salt,r.hasher);r.iv=a.iv;var s=y.encrypt.call(this,e,t,a.key,r);return s.mixIn(a),s},decrypt:function(e,t,n,r){r=this.cfg.extend(r),t=this._parse(t,r.format);var a=r.kdf.execute(n,e.keySize,e.ivSize,t.salt,r.hasher);return r.iv=a.iv,y.decrypt.call(this,e,t,a.key,r)}})}()))}()},4488:function(e,t,n){e.exports=function(){var e=e||function(e,t){var r;if("undefined"!==typeof window&&window.crypto&&(r=window.crypto),"undefined"!==typeof self&&self.crypto&&(r=self.crypto),"undefined"!==typeof globalThis&&globalThis.crypto&&(r=globalThis.crypto),!r&&"undefined"!==typeof window&&window.msCrypto&&(r=window.msCrypto),!r&&"undefined"!==typeof n.g&&n.g.crypto&&(r=n.g.crypto),!r)try{r=n(477)}catch(g){}var a=function(){if(r){if("function"===typeof r.getRandomValues)try{return r.getRandomValues(new Uint32Array(1))[0]}catch(g){}if("function"===typeof r.randomBytes)try{return r.randomBytes(4).readInt32LE()}catch(g){}}throw new Error("Native crypto module could not be used to get secure random number.")},s=Object.create||function(){function e(){}return function(t){var n;return e.prototype=t,n=new e,e.prototype=null,n}}(),i={},o=i.lib={},l=o.Base={extend:function(e){var t=s(this);return e&&t.mixIn(e),t.hasOwnProperty("init")&&this.init!==t.init||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},u=o.WordArray=l.extend({init:function(e,n){e=this.words=e||[],this.sigBytes=n!=t?n:4*e.length},toString:function(e){return(e||d).stringify(this)},concat:function(e){var t=this.words,n=e.words,r=this.sigBytes,a=e.sigBytes;if(this.clamp(),r%4)for(var s=0;s<a;s++){var i=n[s>>>2]>>>24-s%4*8&255;t[r+s>>>2]|=i<<24-(r+s)%4*8}else for(var o=0;o<a;o+=4)t[r+o>>>2]=n[o>>>2];return this.sigBytes+=a,this},clamp:function(){var t=this.words,n=this.sigBytes;t[n>>>2]&=4294967295<<32-n%4*8,t.length=e.ceil(n/4)},clone:function(){var e=l.clone.call(this);return e.words=this.words.slice(0),e},random:function(e){for(var t=[],n=0;n<e;n+=4)t.push(a());return new u.init(t,e)}}),c=i.enc={},d=c.Hex={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],a=0;a<n;a++){var s=t[a>>>2]>>>24-a%4*8&255;r.push((s>>>4).toString(16)),r.push((15&s).toString(16))}return r.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r+=2)n[r>>>3]|=parseInt(e.substr(r,2),16)<<24-r%8*4;return new u.init(n,t/2)}},h=c.Latin1={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],a=0;a<n;a++){var s=t[a>>>2]>>>24-a%4*8&255;r.push(String.fromCharCode(s))}return r.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r++)n[r>>>2]|=(255&e.charCodeAt(r))<<24-r%4*8;return new u.init(n,t)}},p=c.Utf8={stringify:function(e){try{return decodeURIComponent(escape(h.stringify(e)))}catch(t){throw new Error("Malformed UTF-8 data")}},parse:function(e){return h.parse(unescape(encodeURIComponent(e)))}},f=o.BufferedBlockAlgorithm=l.extend({reset:function(){this._data=new u.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=p.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(t){var n,r=this._data,a=r.words,s=r.sigBytes,i=this.blockSize,o=s/(4*i),l=(o=t?e.ceil(o):e.max((0|o)-this._minBufferSize,0))*i,c=e.min(4*l,s);if(l){for(var d=0;d<l;d+=i)this._doProcessBlock(a,d);n=a.splice(0,l),r.sigBytes-=c}return new u.init(n,c)},clone:function(){var e=l.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0}),m=(o.Hasher=f.extend({cfg:l.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){f.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function(e){return function(t,n){return new e.init(n).finalize(t)}},_createHmacHelper:function(e){return function(t,n){return new m.HMAC.init(e,n).finalize(t)}}}),i.algo={});return i}(Math);return e}()},8523:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib.WordArray;function r(e,t,r){for(var a=[],s=0,i=0;i<t;i++)if(i%4){var o=r[e.charCodeAt(i-1)]<<i%4*2|r[e.charCodeAt(i)]>>>6-i%4*2;a[s>>>2]|=o<<24-s%4*8,s++}return n.create(a,s)}e.enc.Base64={stringify:function(e){var t=e.words,n=e.sigBytes,r=this._map;e.clamp();for(var a=[],s=0;s<n;s+=3)for(var i=(t[s>>>2]>>>24-s%4*8&255)<<16|(t[s+1>>>2]>>>24-(s+1)%4*8&255)<<8|t[s+2>>>2]>>>24-(s+2)%4*8&255,o=0;o<4&&s+.75*o<n;o++)a.push(r.charAt(i>>>6*(3-o)&63));var l=r.charAt(64);if(l)for(;a.length%4;)a.push(l);return a.join("")},parse:function(e){var t=e.length,n=this._map,a=this._reverseMap;if(!a){a=this._reverseMap=[];for(var s=0;s<n.length;s++)a[n.charCodeAt(s)]=s}var i=n.charAt(64);if(i){var o=e.indexOf(i);-1!==o&&(t=o)}return r(e,t,a)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}}(),t.enc.Base64)}()},4646:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib.WordArray;function r(e,t,r){for(var a=[],s=0,i=0;i<t;i++)if(i%4){var o=r[e.charCodeAt(i-1)]<<i%4*2|r[e.charCodeAt(i)]>>>6-i%4*2;a[s>>>2]|=o<<24-s%4*8,s++}return n.create(a,s)}e.enc.Base64url={stringify:function(e,t){void 0===t&&(t=!0);var n=e.words,r=e.sigBytes,a=t?this._safe_map:this._map;e.clamp();for(var s=[],i=0;i<r;i+=3)for(var o=(n[i>>>2]>>>24-i%4*8&255)<<16|(n[i+1>>>2]>>>24-(i+1)%4*8&255)<<8|n[i+2>>>2]>>>24-(i+2)%4*8&255,l=0;l<4&&i+.75*l<r;l++)s.push(a.charAt(o>>>6*(3-l)&63));var u=a.charAt(64);if(u)for(;s.length%4;)s.push(u);return s.join("")},parse:function(e,t){void 0===t&&(t=!0);var n=e.length,a=t?this._safe_map:this._map,s=this._reverseMap;if(!s){s=this._reverseMap=[];for(var i=0;i<a.length;i++)s[a.charCodeAt(i)]=i}var o=a.charAt(64);if(o){var l=e.indexOf(o);-1!==l&&(n=l)}return r(e,n,s)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",_safe_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}}(),t.enc.Base64url)}()},5787:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib.WordArray,r=e.enc;function a(e){return e<<8&4278255360|e>>>8&16711935}r.Utf16=r.Utf16BE={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],a=0;a<n;a+=2){var s=t[a>>>2]>>>16-a%4*8&65535;r.push(String.fromCharCode(s))}return r.join("")},parse:function(e){for(var t=e.length,r=[],a=0;a<t;a++)r[a>>>1]|=e.charCodeAt(a)<<16-a%2*16;return n.create(r,2*t)}},r.Utf16LE={stringify:function(e){for(var t=e.words,n=e.sigBytes,r=[],s=0;s<n;s+=2){var i=a(t[s>>>2]>>>16-s%4*8&65535);r.push(String.fromCharCode(i))}return r.join("")},parse:function(e){for(var t=e.length,r=[],s=0;s<t;s++)r[s>>>1]|=a(e.charCodeAt(s)<<16-s%2*16);return n.create(r,2*t)}}}(),t.enc.Utf16)}()},8211:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2002),n(4220),function(){var e=t,n=e.lib,r=n.Base,a=n.WordArray,s=e.algo,i=s.MD5,o=s.EvpKDF=r.extend({cfg:r.extend({keySize:4,hasher:i,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var n,r=this.cfg,s=r.hasher.create(),i=a.create(),o=i.words,l=r.keySize,u=r.iterations;o.length<l;){n&&s.update(n),n=s.update(e).finalize(t),s.reset();for(var c=1;c<u;c++)n=s.finalize(n),s.reset();i.concat(n)}return i.sigBytes=4*l,i}});e.EvpKDF=function(e,t,n){return o.create(n).compute(e,t)}}(),t.EvpKDF)}()},4708:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),function(){var e=t,n=e.lib.CipherParams,r=e.enc.Hex;e.format.Hex={stringify:function(e){return e.ciphertext.toString(r)},parse:function(e){var t=r.parse(e);return n.create({ciphertext:t})}}}(),t.format.Hex)}()},4220:function(e,t,n){!function(){var t;e.exports=(t=n(4488),void function(){var e=t,n=e.lib.Base,r=e.enc.Utf8;e.algo.HMAC=n.extend({init:function(e,t){e=this._hasher=new e.init,"string"==typeof t&&(t=r.parse(t));var n=e.blockSize,a=4*n;t.sigBytes>a&&(t=e.finalize(t)),t.clamp();for(var s=this._oKey=t.clone(),i=this._iKey=t.clone(),o=s.words,l=i.words,u=0;u<n;u++)o[u]^=1549556828,l[u]^=909522486;s.sigBytes=i.sigBytes=a,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher,n=t.finalize(e);return t.reset(),t.finalize(this._oKey.clone().concat(n))}})}())}()},6111:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),n(4503),n(5787),n(8523),n(4646),n(4199),n(2002),n(6368),n(1641),n(7061),n(9092),n(6600),n(7423),n(4220),n(3930),n(8211),n(2238),n(1112),n(7962),n(8049),n(6380),n(8099),n(1884),n(9132),n(4423),n(548),n(4087),n(4708),n(7780),n(9475),n(9638),n(8875),n(1659),n(6501),t)}()},4503:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){if("function"==typeof ArrayBuffer){var e=t.lib.WordArray,n=e.init,r=e.init=function(e){if(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),(e instanceof Int8Array||"undefined"!==typeof Uint8ClampedArray&&e instanceof Uint8ClampedArray||e instanceof Int16Array||e instanceof Uint16Array||e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array)&&(e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),e instanceof Uint8Array){for(var t=e.byteLength,r=[],a=0;a<t;a++)r[a>>>2]|=e[a]<<24-a%4*8;n.call(this,r,t)}else n.apply(this,arguments)};r.prototype=e}}(),t.lib.WordArray)}()},4199:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(e){var n=t,r=n.lib,a=r.WordArray,s=r.Hasher,i=n.algo,o=[];!function(){for(var t=0;t<64;t++)o[t]=4294967296*e.abs(e.sin(t+1))|0}();var l=i.MD5=s.extend({_doReset:function(){this._hash=new a.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(e,t){for(var n=0;n<16;n++){var r=t+n,a=e[r];e[r]=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8)}var s=this._hash.words,i=e[t+0],l=e[t+1],p=e[t+2],f=e[t+3],m=e[t+4],g=e[t+5],y=e[t+6],b=e[t+7],v=e[t+8],x=e[t+9],w=e[t+10],k=e[t+11],S=e[t+12],I=e[t+13],T=e[t+14],N=e[t+15],C=s[0],A=s[1],E=s[2],_=s[3];C=u(C,A,E,_,i,7,o[0]),_=u(_,C,A,E,l,12,o[1]),E=u(E,_,C,A,p,17,o[2]),A=u(A,E,_,C,f,22,o[3]),C=u(C,A,E,_,m,7,o[4]),_=u(_,C,A,E,g,12,o[5]),E=u(E,_,C,A,y,17,o[6]),A=u(A,E,_,C,b,22,o[7]),C=u(C,A,E,_,v,7,o[8]),_=u(_,C,A,E,x,12,o[9]),E=u(E,_,C,A,w,17,o[10]),A=u(A,E,_,C,k,22,o[11]),C=u(C,A,E,_,S,7,o[12]),_=u(_,C,A,E,I,12,o[13]),E=u(E,_,C,A,T,17,o[14]),C=c(C,A=u(A,E,_,C,N,22,o[15]),E,_,l,5,o[16]),_=c(_,C,A,E,y,9,o[17]),E=c(E,_,C,A,k,14,o[18]),A=c(A,E,_,C,i,20,o[19]),C=c(C,A,E,_,g,5,o[20]),_=c(_,C,A,E,w,9,o[21]),E=c(E,_,C,A,N,14,o[22]),A=c(A,E,_,C,m,20,o[23]),C=c(C,A,E,_,x,5,o[24]),_=c(_,C,A,E,T,9,o[25]),E=c(E,_,C,A,f,14,o[26]),A=c(A,E,_,C,v,20,o[27]),C=c(C,A,E,_,I,5,o[28]),_=c(_,C,A,E,p,9,o[29]),E=c(E,_,C,A,b,14,o[30]),C=d(C,A=c(A,E,_,C,S,20,o[31]),E,_,g,4,o[32]),_=d(_,C,A,E,v,11,o[33]),E=d(E,_,C,A,k,16,o[34]),A=d(A,E,_,C,T,23,o[35]),C=d(C,A,E,_,l,4,o[36]),_=d(_,C,A,E,m,11,o[37]),E=d(E,_,C,A,b,16,o[38]),A=d(A,E,_,C,w,23,o[39]),C=d(C,A,E,_,I,4,o[40]),_=d(_,C,A,E,i,11,o[41]),E=d(E,_,C,A,f,16,o[42]),A=d(A,E,_,C,y,23,o[43]),C=d(C,A,E,_,x,4,o[44]),_=d(_,C,A,E,S,11,o[45]),E=d(E,_,C,A,N,16,o[46]),C=h(C,A=d(A,E,_,C,p,23,o[47]),E,_,i,6,o[48]),_=h(_,C,A,E,b,10,o[49]),E=h(E,_,C,A,T,15,o[50]),A=h(A,E,_,C,g,21,o[51]),C=h(C,A,E,_,S,6,o[52]),_=h(_,C,A,E,f,10,o[53]),E=h(E,_,C,A,w,15,o[54]),A=h(A,E,_,C,l,21,o[55]),C=h(C,A,E,_,v,6,o[56]),_=h(_,C,A,E,N,10,o[57]),E=h(E,_,C,A,y,15,o[58]),A=h(A,E,_,C,I,21,o[59]),C=h(C,A,E,_,m,6,o[60]),_=h(_,C,A,E,k,10,o[61]),E=h(E,_,C,A,p,15,o[62]),A=h(A,E,_,C,x,21,o[63]),s[0]=s[0]+C|0,s[1]=s[1]+A|0,s[2]=s[2]+E|0,s[3]=s[3]+_|0},_doFinalize:function(){var t=this._data,n=t.words,r=8*this._nDataBytes,a=8*t.sigBytes;n[a>>>5]|=128<<24-a%32;var s=e.floor(r/4294967296),i=r;n[15+(a+64>>>9<<4)]=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),n[14+(a+64>>>9<<4)]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),t.sigBytes=4*(n.length+1),this._process();for(var o=this._hash,l=o.words,u=0;u<4;u++){var c=l[u];l[u]=16711935&(c<<8|c>>>24)|4278255360&(c<<24|c>>>8)}return o},clone:function(){var e=s.clone.call(this);return e._hash=this._hash.clone(),e}});function u(e,t,n,r,a,s,i){var o=e+(t&n|~t&r)+a+i;return(o<<s|o>>>32-s)+t}function c(e,t,n,r,a,s,i){var o=e+(t&r|n&~r)+a+i;return(o<<s|o>>>32-s)+t}function d(e,t,n,r,a,s,i){var o=e+(t^n^r)+a+i;return(o<<s|o>>>32-s)+t}function h(e,t,n,r,a,s,i){var o=e+(n^(t|~r))+a+i;return(o<<s|o>>>32-s)+t}n.MD5=s._createHelper(l),n.HmacMD5=s._createHmacHelper(l)}(Math),t.MD5)}()},1112:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.CFB=function(){var e=t.lib.BlockCipherMode.extend();function n(e,t,n,r){var a,s=this._iv;s?(a=s.slice(0),this._iv=void 0):a=this._prevBlock,r.encryptBlock(a,0);for(var i=0;i<n;i++)e[t+i]^=a[i]}return e.Encryptor=e.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize;n.call(this,e,t,a,r),this._prevBlock=e.slice(t,t+a)}}),e.Decryptor=e.extend({processBlock:function(e,t){var r=this._cipher,a=r.blockSize,s=e.slice(t,t+a);n.call(this,e,t,a,r),this._prevBlock=s}}),e}(),t.mode.CFB)}()},8049:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.CTRGladman=function(){var e=t.lib.BlockCipherMode.extend();function n(e){if(255===(e>>24&255)){var t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}else e+=1<<24;return e}function r(e){return 0===(e[0]=n(e[0]))&&(e[1]=n(e[1])),e}var a=e.Encryptor=e.extend({processBlock:function(e,t){var n=this._cipher,a=n.blockSize,s=this._iv,i=this._counter;s&&(i=this._counter=s.slice(0),this._iv=void 0),r(i);var o=i.slice(0);n.encryptBlock(o,0);for(var l=0;l<a;l++)e[t+l]^=o[l]}});return e.Decryptor=a,e}(),t.mode.CTRGladman)}()},7962:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.CTR=function(){var e=t.lib.BlockCipherMode.extend(),n=e.Encryptor=e.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize,a=this._iv,s=this._counter;a&&(s=this._counter=a.slice(0),this._iv=void 0);var i=s.slice(0);n.encryptBlock(i,0),s[r-1]=s[r-1]+1|0;for(var o=0;o<r;o++)e[t+o]^=i[o]}});return e.Decryptor=n,e}(),t.mode.CTR)}()},8099:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.ECB=function(){var e=t.lib.BlockCipherMode.extend();return e.Encryptor=e.extend({processBlock:function(e,t){this._cipher.encryptBlock(e,t)}}),e.Decryptor=e.extend({processBlock:function(e,t){this._cipher.decryptBlock(e,t)}}),e}(),t.mode.ECB)}()},6380:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.mode.OFB=function(){var e=t.lib.BlockCipherMode.extend(),n=e.Encryptor=e.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize,a=this._iv,s=this._keystream;a&&(s=this._keystream=a.slice(0),this._iv=void 0),n.encryptBlock(s,0);for(var i=0;i<r;i++)e[t+i]^=s[i]}});return e.Decryptor=n,e}(),t.mode.OFB)}()},1884:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.AnsiX923={pad:function(e,t){var n=e.sigBytes,r=4*t,a=r-n%r,s=n+a-1;e.clamp(),e.words[s>>>2]|=a<<24-s%4*8,e.sigBytes+=a},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},t.pad.Ansix923)}()},9132:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.Iso10126={pad:function(e,n){var r=4*n,a=r-e.sigBytes%r;e.concat(t.lib.WordArray.random(a-1)).concat(t.lib.WordArray.create([a<<24],1))},unpad:function(e){var t=255&e.words[e.sigBytes-1>>>2];e.sigBytes-=t}},t.pad.Iso10126)}()},4423:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.Iso97971={pad:function(e,n){e.concat(t.lib.WordArray.create([2147483648],1)),t.pad.ZeroPadding.pad(e,n)},unpad:function(e){t.pad.ZeroPadding.unpad(e),e.sigBytes--}},t.pad.Iso97971)}()},4087:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.NoPadding={pad:function(){},unpad:function(){}},t.pad.NoPadding)}()},548:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(2238),t.pad.ZeroPadding={pad:function(e,t){var n=4*t;e.clamp(),e.sigBytes+=n-(e.sigBytes%n||n)},unpad:function(e){var t=e.words,n=e.sigBytes-1;for(n=e.sigBytes-1;n>=0;n--)if(t[n>>>2]>>>24-n%4*8&255){e.sigBytes=n+1;break}}},t.pad.ZeroPadding)}()},3930:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(6368),n(4220),function(){var e=t,n=e.lib,r=n.Base,a=n.WordArray,s=e.algo,i=s.SHA256,o=s.HMAC,l=s.PBKDF2=r.extend({cfg:r.extend({keySize:4,hasher:i,iterations:25e4}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var n=this.cfg,r=o.create(n.hasher,e),s=a.create(),i=a.create([1]),l=s.words,u=i.words,c=n.keySize,d=n.iterations;l.length<c;){var h=r.update(t).finalize(i);r.reset();for(var p=h.words,f=p.length,m=h,g=1;g<d;g++){m=r.finalize(m),r.reset();for(var y=m.words,b=0;b<f;b++)p[b]^=y[b]}s.concat(h),u[0]++}return s.sigBytes=4*c,s}});e.PBKDF2=function(e,t,n){return l.create(n).compute(e,t)}}(),t.PBKDF2)}()},1659:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.StreamCipher,r=e.algo,a=[],s=[],i=[],o=r.RabbitLegacy=n.extend({_doReset:function(){var e=this._key.words,t=this.cfg.iv,n=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],r=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];this._b=0;for(var a=0;a<4;a++)l.call(this);for(a=0;a<8;a++)r[a]^=n[a+4&7];if(t){var s=t.words,i=s[0],o=s[1],u=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),c=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),d=u>>>16|4294901760&c,h=c<<16|65535&u;for(r[0]^=u,r[1]^=d,r[2]^=c,r[3]^=h,r[4]^=u,r[5]^=d,r[6]^=c,r[7]^=h,a=0;a<4;a++)l.call(this)}},_doProcessBlock:function(e,t){var n=this._X;l.call(this),a[0]=n[0]^n[5]>>>16^n[3]<<16,a[1]=n[2]^n[7]>>>16^n[5]<<16,a[2]=n[4]^n[1]>>>16^n[7]<<16,a[3]=n[6]^n[3]>>>16^n[1]<<16;for(var r=0;r<4;r++)a[r]=16711935&(a[r]<<8|a[r]>>>24)|4278255360&(a[r]<<24|a[r]>>>8),e[t+r]^=a[r]},blockSize:4,ivSize:2});function l(){for(var e=this._X,t=this._C,n=0;n<8;n++)s[n]=t[n];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<s[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<s[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<s[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<s[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<s[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<s[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<s[6]>>>0?1:0)|0,this._b=t[7]>>>0<s[7]>>>0?1:0,n=0;n<8;n++){var r=e[n]+t[n],a=65535&r,o=r>>>16,l=((a*a>>>17)+a*o>>>15)+o*o,u=((4294901760&r)*r|0)+((65535&r)*r|0);i[n]=l^u}e[0]=i[0]+(i[7]<<16|i[7]>>>16)+(i[6]<<16|i[6]>>>16)|0,e[1]=i[1]+(i[0]<<8|i[0]>>>24)+i[7]|0,e[2]=i[2]+(i[1]<<16|i[1]>>>16)+(i[0]<<16|i[0]>>>16)|0,e[3]=i[3]+(i[2]<<8|i[2]>>>24)+i[1]|0,e[4]=i[4]+(i[3]<<16|i[3]>>>16)+(i[2]<<16|i[2]>>>16)|0,e[5]=i[5]+(i[4]<<8|i[4]>>>24)+i[3]|0,e[6]=i[6]+(i[5]<<16|i[5]>>>16)+(i[4]<<16|i[4]>>>16)|0,e[7]=i[7]+(i[6]<<8|i[6]>>>24)+i[5]|0}e.RabbitLegacy=n._createHelper(o)}(),t.RabbitLegacy)}()},8875:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.StreamCipher,r=e.algo,a=[],s=[],i=[],o=r.Rabbit=n.extend({_doReset:function(){for(var e=this._key.words,t=this.cfg.iv,n=0;n<4;n++)e[n]=16711935&(e[n]<<8|e[n]>>>24)|4278255360&(e[n]<<24|e[n]>>>8);var r=this._X=[e[0],e[3]<<16|e[2]>>>16,e[1],e[0]<<16|e[3]>>>16,e[2],e[1]<<16|e[0]>>>16,e[3],e[2]<<16|e[1]>>>16],a=this._C=[e[2]<<16|e[2]>>>16,4294901760&e[0]|65535&e[1],e[3]<<16|e[3]>>>16,4294901760&e[1]|65535&e[2],e[0]<<16|e[0]>>>16,4294901760&e[2]|65535&e[3],e[1]<<16|e[1]>>>16,4294901760&e[3]|65535&e[0]];for(this._b=0,n=0;n<4;n++)l.call(this);for(n=0;n<8;n++)a[n]^=r[n+4&7];if(t){var s=t.words,i=s[0],o=s[1],u=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),c=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8),d=u>>>16|4294901760&c,h=c<<16|65535&u;for(a[0]^=u,a[1]^=d,a[2]^=c,a[3]^=h,a[4]^=u,a[5]^=d,a[6]^=c,a[7]^=h,n=0;n<4;n++)l.call(this)}},_doProcessBlock:function(e,t){var n=this._X;l.call(this),a[0]=n[0]^n[5]>>>16^n[3]<<16,a[1]=n[2]^n[7]>>>16^n[5]<<16,a[2]=n[4]^n[1]>>>16^n[7]<<16,a[3]=n[6]^n[3]>>>16^n[1]<<16;for(var r=0;r<4;r++)a[r]=16711935&(a[r]<<8|a[r]>>>24)|4278255360&(a[r]<<24|a[r]>>>8),e[t+r]^=a[r]},blockSize:4,ivSize:2});function l(){for(var e=this._X,t=this._C,n=0;n<8;n++)s[n]=t[n];for(t[0]=t[0]+1295307597+this._b|0,t[1]=t[1]+3545052371+(t[0]>>>0<s[0]>>>0?1:0)|0,t[2]=t[2]+886263092+(t[1]>>>0<s[1]>>>0?1:0)|0,t[3]=t[3]+1295307597+(t[2]>>>0<s[2]>>>0?1:0)|0,t[4]=t[4]+3545052371+(t[3]>>>0<s[3]>>>0?1:0)|0,t[5]=t[5]+886263092+(t[4]>>>0<s[4]>>>0?1:0)|0,t[6]=t[6]+1295307597+(t[5]>>>0<s[5]>>>0?1:0)|0,t[7]=t[7]+3545052371+(t[6]>>>0<s[6]>>>0?1:0)|0,this._b=t[7]>>>0<s[7]>>>0?1:0,n=0;n<8;n++){var r=e[n]+t[n],a=65535&r,o=r>>>16,l=((a*a>>>17)+a*o>>>15)+o*o,u=((4294901760&r)*r|0)+((65535&r)*r|0);i[n]=l^u}e[0]=i[0]+(i[7]<<16|i[7]>>>16)+(i[6]<<16|i[6]>>>16)|0,e[1]=i[1]+(i[0]<<8|i[0]>>>24)+i[7]|0,e[2]=i[2]+(i[1]<<16|i[1]>>>16)+(i[0]<<16|i[0]>>>16)|0,e[3]=i[3]+(i[2]<<8|i[2]>>>24)+i[1]|0,e[4]=i[4]+(i[3]<<16|i[3]>>>16)+(i[2]<<16|i[2]>>>16)|0,e[5]=i[5]+(i[4]<<8|i[4]>>>24)+i[3]|0,e[6]=i[6]+(i[5]<<16|i[5]>>>16)+(i[4]<<16|i[4]>>>16)|0,e[7]=i[7]+(i[6]<<8|i[6]>>>24)+i[5]|0}e.Rabbit=n._createHelper(o)}(),t.Rabbit)}()},9638:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib.StreamCipher,r=e.algo,a=r.RC4=n.extend({_doReset:function(){for(var e=this._key,t=e.words,n=e.sigBytes,r=this._S=[],a=0;a<256;a++)r[a]=a;a=0;for(var s=0;a<256;a++){var i=a%n,o=t[i>>>2]>>>24-i%4*8&255;s=(s+r[a]+o)%256;var l=r[a];r[a]=r[s],r[s]=l}this._i=this._j=0},_doProcessBlock:function(e,t){e[t]^=s.call(this)},keySize:8,ivSize:0});function s(){for(var e=this._S,t=this._i,n=this._j,r=0,a=0;a<4;a++){n=(n+e[t=(t+1)%256])%256;var s=e[t];e[t]=e[n],e[n]=s,r|=e[(e[t]+e[n])%256]<<24-8*a}return this._i=t,this._j=n,r}e.RC4=n._createHelper(a);var i=r.RC4Drop=a.extend({cfg:a.cfg.extend({drop:192}),_doReset:function(){a._doReset.call(this);for(var e=this.cfg.drop;e>0;e--)s.call(this)}});e.RC4Drop=n._createHelper(i)}(),t.RC4)}()},7423:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib,r=n.WordArray,a=n.Hasher,s=e.algo,i=r.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),o=r.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),l=r.create([11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),u=r.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),c=r.create([0,1518500249,1859775393,2400959708,2840853838]),d=r.create([1352829926,1548603684,1836072691,2053994217,0]),h=s.RIPEMD160=a.extend({_doReset:function(){this._hash=r.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var n=0;n<16;n++){var r=t+n,a=e[r];e[r]=16711935&(a<<8|a>>>24)|4278255360&(a<<24|a>>>8)}var s,h,v,x,w,k,S,I,T,N,C,A=this._hash.words,E=c.words,_=d.words,$=i.words,R=o.words,D=l.words,M=u.words;for(k=s=A[0],S=h=A[1],I=v=A[2],T=x=A[3],N=w=A[4],n=0;n<80;n+=1)C=s+e[t+$[n]]|0,C+=n<16?p(h,v,x)+E[0]:n<32?f(h,v,x)+E[1]:n<48?m(h,v,x)+E[2]:n<64?g(h,v,x)+E[3]:y(h,v,x)+E[4],C=(C=b(C|=0,D[n]))+w|0,s=w,w=x,x=b(v,10),v=h,h=C,C=k+e[t+R[n]]|0,C+=n<16?y(S,I,T)+_[0]:n<32?g(S,I,T)+_[1]:n<48?m(S,I,T)+_[2]:n<64?f(S,I,T)+_[3]:p(S,I,T)+_[4],C=(C=b(C|=0,M[n]))+N|0,k=N,N=T,T=b(I,10),I=S,S=C;C=A[1]+v+T|0,A[1]=A[2]+x+N|0,A[2]=A[3]+w+k|0,A[3]=A[4]+s+S|0,A[4]=A[0]+h+I|0,A[0]=C},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;t[r>>>5]|=128<<24-r%32,t[14+(r+64>>>9<<4)]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8),e.sigBytes=4*(t.length+1),this._process();for(var a=this._hash,s=a.words,i=0;i<5;i++){var o=s[i];s[i]=16711935&(o<<8|o>>>24)|4278255360&(o<<24|o>>>8)}return a},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}});function p(e,t,n){return e^t^n}function f(e,t,n){return e&t|~e&n}function m(e,t,n){return(e|~t)^n}function g(e,t,n){return e&n|t&~n}function y(e,t,n){return e^(t|~n)}function b(e,t){return e<<t|e>>>32-t}e.RIPEMD160=a._createHelper(h),e.HmacRIPEMD160=a._createHmacHelper(h)}(Math),t.RIPEMD160)}()},2002:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(){var e=t,n=e.lib,r=n.WordArray,a=n.Hasher,s=e.algo,i=[],o=s.SHA1=a.extend({_doReset:function(){this._hash=new r.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],a=n[1],s=n[2],o=n[3],l=n[4],u=0;u<80;u++){if(u<16)i[u]=0|e[t+u];else{var c=i[u-3]^i[u-8]^i[u-14]^i[u-16];i[u]=c<<1|c>>>31}var d=(r<<5|r>>>27)+l+i[u];d+=u<20?1518500249+(a&s|~a&o):u<40?1859775393+(a^s^o):u<60?(a&s|a&o|s&o)-1894007588:(a^s^o)-899497514,l=o,o=s,s=a<<30|a>>>2,a=r,r=d}n[0]=n[0]+r|0,n[1]=n[1]+a|0,n[2]=n[2]+s|0,n[3]=n[3]+o|0,n[4]=n[4]+l|0},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;return t[r>>>5]|=128<<24-r%32,t[14+(r+64>>>9<<4)]=Math.floor(n/4294967296),t[15+(r+64>>>9<<4)]=n,e.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=a.clone.call(this);return e._hash=this._hash.clone(),e}});e.SHA1=a._createHelper(o),e.HmacSHA1=a._createHmacHelper(o)}(),t.SHA1)}()},1641:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(6368),function(){var e=t,n=e.lib.WordArray,r=e.algo,a=r.SHA256,s=r.SHA224=a.extend({_doReset:function(){this._hash=new n.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var e=a._doFinalize.call(this);return e.sigBytes-=4,e}});e.SHA224=a._createHelper(s),e.HmacSHA224=a._createHmacHelper(s)}(),t.SHA224)}()},6368:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(e){var n=t,r=n.lib,a=r.WordArray,s=r.Hasher,i=n.algo,o=[],l=[];!function(){function t(t){for(var n=e.sqrt(t),r=2;r<=n;r++)if(!(t%r))return!1;return!0}function n(e){return 4294967296*(e-(0|e))|0}for(var r=2,a=0;a<64;)t(r)&&(a<8&&(o[a]=n(e.pow(r,.5))),l[a]=n(e.pow(r,1/3)),a++),r++}();var u=[],c=i.SHA256=s.extend({_doReset:function(){this._hash=new a.init(o.slice(0))},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],a=n[1],s=n[2],i=n[3],o=n[4],c=n[5],d=n[6],h=n[7],p=0;p<64;p++){if(p<16)u[p]=0|e[t+p];else{var f=u[p-15],m=(f<<25|f>>>7)^(f<<14|f>>>18)^f>>>3,g=u[p-2],y=(g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10;u[p]=m+u[p-7]+y+u[p-16]}var b=r&a^r&s^a&s,v=(r<<30|r>>>2)^(r<<19|r>>>13)^(r<<10|r>>>22),x=h+((o<<26|o>>>6)^(o<<21|o>>>11)^(o<<7|o>>>25))+(o&c^~o&d)+l[p]+u[p];h=d,d=c,c=o,o=i+x|0,i=s,s=a,a=r,r=x+(v+b)|0}n[0]=n[0]+r|0,n[1]=n[1]+a|0,n[2]=n[2]+s|0,n[3]=n[3]+i|0,n[4]=n[4]+o|0,n[5]=n[5]+c|0,n[6]=n[6]+d|0,n[7]=n[7]+h|0},_doFinalize:function(){var t=this._data,n=t.words,r=8*this._nDataBytes,a=8*t.sigBytes;return n[a>>>5]|=128<<24-a%32,n[14+(a+64>>>9<<4)]=e.floor(r/4294967296),n[15+(a+64>>>9<<4)]=r,t.sigBytes=4*n.length,this._process(),this._hash},clone:function(){var e=s.clone.call(this);return e._hash=this._hash.clone(),e}});n.SHA256=s._createHelper(c),n.HmacSHA256=s._createHmacHelper(c)}(Math),t.SHA256)}()},6600:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),function(e){var n=t,r=n.lib,a=r.WordArray,s=r.Hasher,i=n.x64.Word,o=n.algo,l=[],u=[],c=[];!function(){for(var e=1,t=0,n=0;n<24;n++){l[e+5*t]=(n+1)*(n+2)/2%64;var r=(2*e+3*t)%5;e=t%5,t=r}for(e=0;e<5;e++)for(t=0;t<5;t++)u[e+5*t]=t+(2*e+3*t)%5*5;for(var a=1,s=0;s<24;s++){for(var o=0,d=0,h=0;h<7;h++){if(1&a){var p=(1<<h)-1;p<32?d^=1<<p:o^=1<<p-32}128&a?a=a<<1^113:a<<=1}c[s]=i.create(o,d)}}();var d=[];!function(){for(var e=0;e<25;e++)d[e]=i.create()}();var h=o.SHA3=s.extend({cfg:s.cfg.extend({outputLength:512}),_doReset:function(){for(var e=this._state=[],t=0;t<25;t++)e[t]=new i.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(e,t){for(var n=this._state,r=this.blockSize/2,a=0;a<r;a++){var s=e[t+2*a],i=e[t+2*a+1];s=16711935&(s<<8|s>>>24)|4278255360&(s<<24|s>>>8),i=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),(A=n[a]).high^=i,A.low^=s}for(var o=0;o<24;o++){for(var h=0;h<5;h++){for(var p=0,f=0,m=0;m<5;m++)p^=(A=n[h+5*m]).high,f^=A.low;var g=d[h];g.high=p,g.low=f}for(h=0;h<5;h++){var y=d[(h+4)%5],b=d[(h+1)%5],v=b.high,x=b.low;for(p=y.high^(v<<1|x>>>31),f=y.low^(x<<1|v>>>31),m=0;m<5;m++)(A=n[h+5*m]).high^=p,A.low^=f}for(var w=1;w<25;w++){var k=(A=n[w]).high,S=A.low,I=l[w];I<32?(p=k<<I|S>>>32-I,f=S<<I|k>>>32-I):(p=S<<I-32|k>>>64-I,f=k<<I-32|S>>>64-I);var T=d[u[w]];T.high=p,T.low=f}var N=d[0],C=n[0];for(N.high=C.high,N.low=C.low,h=0;h<5;h++)for(m=0;m<5;m++){var A=n[w=h+5*m],E=d[w],_=d[(h+1)%5+5*m],$=d[(h+2)%5+5*m];A.high=E.high^~_.high&$.high,A.low=E.low^~_.low&$.low}A=n[0];var R=c[o];A.high^=R.high,A.low^=R.low}},_doFinalize:function(){var t=this._data,n=t.words,r=(this._nDataBytes,8*t.sigBytes),s=32*this.blockSize;n[r>>>5]|=1<<24-r%32,n[(e.ceil((r+1)/s)*s>>>5)-1]|=128,t.sigBytes=4*n.length,this._process();for(var i=this._state,o=this.cfg.outputLength/8,l=o/8,u=[],c=0;c<l;c++){var d=i[c],h=d.high,p=d.low;h=16711935&(h<<8|h>>>24)|4278255360&(h<<24|h>>>8),p=16711935&(p<<8|p>>>24)|4278255360&(p<<24|p>>>8),u.push(p),u.push(h)}return new a.init(u,o)},clone:function(){for(var e=s.clone.call(this),t=e._state=this._state.slice(0),n=0;n<25;n++)t[n]=t[n].clone();return e}});n.SHA3=s._createHelper(h),n.HmacSHA3=s._createHmacHelper(h)}(Math),t.SHA3)}()},9092:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),n(7061),function(){var e=t,n=e.x64,r=n.Word,a=n.WordArray,s=e.algo,i=s.SHA512,o=s.SHA384=i.extend({_doReset:function(){this._hash=new a.init([new r.init(3418070365,3238371032),new r.init(1654270250,914150663),new r.init(2438529370,812702999),new r.init(355462360,4144912697),new r.init(1731405415,4290775857),new r.init(2394180231,1750603025),new r.init(3675008525,1694076839),new r.init(1203062813,3204075428)])},_doFinalize:function(){var e=i._doFinalize.call(this);return e.sigBytes-=16,e}});e.SHA384=i._createHelper(o),e.HmacSHA384=i._createHmacHelper(o)}(),t.SHA384)}()},7061:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(9749),function(){var e=t,n=e.lib.Hasher,r=e.x64,a=r.Word,s=r.WordArray,i=e.algo;function o(){return a.create.apply(a,arguments)}var l=[o(1116352408,3609767458),o(1899447441,602891725),o(3049323471,3964484399),o(3921009573,2173295548),o(961987163,4081628472),o(1508970993,3053834265),o(2453635748,2937671579),o(2870763221,3664609560),o(3624381080,2734883394),o(310598401,1164996542),o(607225278,1323610764),o(1426881987,3590304994),o(1925078388,4068182383),o(2162078206,991336113),o(2614888103,633803317),o(3248222580,3479774868),o(3835390401,2666613458),o(4022224774,944711139),o(264347078,2341262773),o(604807628,2007800933),o(770255983,1495990901),o(1249150122,1856431235),o(1555081692,3175218132),o(1996064986,2198950837),o(2554220882,3999719339),o(2821834349,766784016),o(2952996808,2566594879),o(3210313671,3203337956),o(3336571891,1034457026),o(3584528711,2466948901),o(113926993,3758326383),o(338241895,168717936),o(666307205,1188179964),o(773529912,1546045734),o(1294757372,1522805485),o(1396182291,2643833823),o(1695183700,2343527390),o(1986661051,1014477480),o(2177026350,1206759142),o(2456956037,344077627),o(2730485921,1290863460),o(2820302411,3158454273),o(3259730800,3505952657),o(3345764771,106217008),o(3516065817,3606008344),o(3600352804,1432725776),o(4094571909,1467031594),o(275423344,851169720),o(430227734,3100823752),o(506948616,1363258195),o(659060556,3750685593),o(883997877,3785050280),o(958139571,3318307427),o(1322822218,3812723403),o(1537002063,2003034995),o(1747873779,3602036899),o(1955562222,1575990012),o(2024104815,1125592928),o(2227730452,2716904306),o(2361852424,442776044),o(2428436474,593698344),o(2756734187,3733110249),o(3204031479,2999351573),o(3329325298,3815920427),o(3391569614,3928383900),o(3515267271,566280711),o(3940187606,3454069534),o(4118630271,4000239992),o(116418474,1914138554),o(174292421,2731055270),o(289380356,3203993006),o(460393269,320620315),o(685471733,587496836),o(852142971,1086792851),o(1017036298,365543100),o(1126000580,2618297676),o(1288033470,3409855158),o(1501505948,4234509866),o(1607167915,987167468),o(1816402316,1246189591)],u=[];!function(){for(var e=0;e<80;e++)u[e]=o()}();var c=i.SHA512=n.extend({_doReset:function(){this._hash=new s.init([new a.init(1779033703,4089235720),new a.init(3144134277,2227873595),new a.init(1013904242,4271175723),new a.init(2773480762,1595750129),new a.init(1359893119,2917565137),new a.init(2600822924,725511199),new a.init(528734635,4215389547),new a.init(1541459225,327033209)])},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],a=n[1],s=n[2],i=n[3],o=n[4],c=n[5],d=n[6],h=n[7],p=r.high,f=r.low,m=a.high,g=a.low,y=s.high,b=s.low,v=i.high,x=i.low,w=o.high,k=o.low,S=c.high,I=c.low,T=d.high,N=d.low,C=h.high,A=h.low,E=p,_=f,$=m,R=g,D=y,M=b,F=v,O=x,P=w,L=k,z=S,B=I,V=T,W=N,U=C,j=A,G=0;G<80;G++){var H,q,K=u[G];if(G<16)q=K.high=0|e[t+2*G],H=K.low=0|e[t+2*G+1];else{var Y=u[G-15],X=Y.high,Q=Y.low,Z=(X>>>1|Q<<31)^(X>>>8|Q<<24)^X>>>7,J=(Q>>>1|X<<31)^(Q>>>8|X<<24)^(Q>>>7|X<<25),ee=u[G-2],te=ee.high,ne=ee.low,re=(te>>>19|ne<<13)^(te<<3|ne>>>29)^te>>>6,ae=(ne>>>19|te<<13)^(ne<<3|te>>>29)^(ne>>>6|te<<26),se=u[G-7],ie=se.high,oe=se.low,le=u[G-16],ue=le.high,ce=le.low;q=(q=(q=Z+ie+((H=J+oe)>>>0<J>>>0?1:0))+re+((H+=ae)>>>0<ae>>>0?1:0))+ue+((H+=ce)>>>0<ce>>>0?1:0),K.high=q,K.low=H}var de,he=P&z^~P&V,pe=L&B^~L&W,fe=E&$^E&D^$&D,me=_&R^_&M^R&M,ge=(E>>>28|_<<4)^(E<<30|_>>>2)^(E<<25|_>>>7),ye=(_>>>28|E<<4)^(_<<30|E>>>2)^(_<<25|E>>>7),be=(P>>>14|L<<18)^(P>>>18|L<<14)^(P<<23|L>>>9),ve=(L>>>14|P<<18)^(L>>>18|P<<14)^(L<<23|P>>>9),xe=l[G],we=xe.high,ke=xe.low,Se=U+be+((de=j+ve)>>>0<j>>>0?1:0),Ie=ye+me;U=V,j=W,V=z,W=B,z=P,B=L,P=F+(Se=(Se=(Se=Se+he+((de+=pe)>>>0<pe>>>0?1:0))+we+((de+=ke)>>>0<ke>>>0?1:0))+q+((de+=H)>>>0<H>>>0?1:0))+((L=O+de|0)>>>0<O>>>0?1:0)|0,F=D,O=M,D=$,M=R,$=E,R=_,E=Se+(ge+fe+(Ie>>>0<ye>>>0?1:0))+((_=de+Ie|0)>>>0<de>>>0?1:0)|0}f=r.low=f+_,r.high=p+E+(f>>>0<_>>>0?1:0),g=a.low=g+R,a.high=m+$+(g>>>0<R>>>0?1:0),b=s.low=b+M,s.high=y+D+(b>>>0<M>>>0?1:0),x=i.low=x+O,i.high=v+F+(x>>>0<O>>>0?1:0),k=o.low=k+L,o.high=w+P+(k>>>0<L>>>0?1:0),I=c.low=I+B,c.high=S+z+(I>>>0<B>>>0?1:0),N=d.low=N+W,d.high=T+V+(N>>>0<W>>>0?1:0),A=h.low=A+j,h.high=C+U+(A>>>0<j>>>0?1:0)},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;return t[r>>>5]|=128<<24-r%32,t[30+(r+128>>>10<<5)]=Math.floor(n/4294967296),t[31+(r+128>>>10<<5)]=n,e.sigBytes=4*t.length,this._process(),this._hash.toX32()},clone:function(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e},blockSize:32});e.SHA512=n._createHelper(c),e.HmacSHA512=n._createHmacHelper(c)}(),t.SHA512)}()},9475:function(e,t,n){!function(){var t;e.exports=(t=n(4488),n(8523),n(4199),n(8211),n(2238),function(){var e=t,n=e.lib,r=n.WordArray,a=n.BlockCipher,s=e.algo,i=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],o=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],l=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],u=[{0:8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{0:1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{0:260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{0:2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{0:128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{0:268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{0:1048576,16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{0:134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],c=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],d=s.DES=a.extend({_doReset:function(){for(var e=this._key.words,t=[],n=0;n<56;n++){var r=i[n]-1;t[n]=e[r>>>5]>>>31-r%32&1}for(var a=this._subKeys=[],s=0;s<16;s++){var u=a[s]=[],c=l[s];for(n=0;n<24;n++)u[n/6|0]|=t[(o[n]-1+c)%28]<<31-n%6,u[4+(n/6|0)]|=t[28+(o[n+24]-1+c)%28]<<31-n%6;for(u[0]=u[0]<<1|u[0]>>>31,n=1;n<7;n++)u[n]=u[n]>>>4*(n-1)+3;u[7]=u[7]<<5|u[7]>>>27}var d=this._invSubKeys=[];for(n=0;n<16;n++)d[n]=a[15-n]},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._subKeys)},decryptBlock:function(e,t){this._doCryptBlock(e,t,this._invSubKeys)},_doCryptBlock:function(e,t,n){this._lBlock=e[t],this._rBlock=e[t+1],h.call(this,4,252645135),h.call(this,16,65535),p.call(this,2,858993459),p.call(this,8,16711935),h.call(this,1,1431655765);for(var r=0;r<16;r++){for(var a=n[r],s=this._lBlock,i=this._rBlock,o=0,l=0;l<8;l++)o|=u[l][((i^a[l])&c[l])>>>0];this._lBlock=i,this._rBlock=s^o}var d=this._lBlock;this._lBlock=this._rBlock,this._rBlock=d,h.call(this,1,1431655765),p.call(this,8,16711935),p.call(this,2,858993459),h.call(this,16,65535),h.call(this,4,252645135),e[t]=this._lBlock,e[t+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});function h(e,t){var n=(this._lBlock>>>e^this._rBlock)&t;this._rBlock^=n,this._lBlock^=n<<e}function p(e,t){var n=(this._rBlock>>>e^this._lBlock)&t;this._lBlock^=n,this._rBlock^=n<<e}e.DES=a._createHelper(d);var f=s.TripleDES=a.extend({_doReset:function(){var e=this._key.words;if(2!==e.length&&4!==e.length&&e.length<6)throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");var t=e.slice(0,2),n=e.length<4?e.slice(0,2):e.slice(2,4),a=e.length<6?e.slice(0,2):e.slice(4,6);this._des1=d.createEncryptor(r.create(t)),this._des2=d.createEncryptor(r.create(n)),this._des3=d.createEncryptor(r.create(a))},encryptBlock:function(e,t){this._des1.encryptBlock(e,t),this._des2.decryptBlock(e,t),this._des3.encryptBlock(e,t)},decryptBlock:function(e,t){this._des3.decryptBlock(e,t),this._des2.encryptBlock(e,t),this._des1.decryptBlock(e,t)},keySize:6,ivSize:2,blockSize:2});e.TripleDES=a._createHelper(f)}(),t.TripleDES)}()},9749:function(e,t,n){!function(){var t;e.exports=(t=n(4488),function(e){var n=t,r=n.lib,a=r.Base,s=r.WordArray,i=n.x64={};i.Word=a.extend({init:function(e,t){this.high=e,this.low=t}}),i.WordArray=a.extend({init:function(t,n){t=this.words=t||[],this.sigBytes=n!=e?n:8*t.length},toX32:function(){for(var e=this.words,t=e.length,n=[],r=0;r<t;r++){var a=e[r];n.push(a.high),n.push(a.low)}return s.create(n,this.sigBytes)},clone:function(){for(var e=a.clone.call(this),t=e.words=this.words.slice(0),n=t.length,r=0;r<n;r++)t[r]=t[r].clone();return e}})}(),t)}()},446:function(e){e.exports=function(){"use strict";var e=1e3,t=6e4,n=36e5,r="millisecond",a="second",s="minute",i="hour",o="day",l="week",u="month",c="quarter",d="year",h="date",p="Invalid Date",f=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,m=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,g={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(e){var t=["th","st","nd","rd"],n=e%100;return"["+e+(t[(n-20)%10]||t[n]||t[0])+"]"}},y=function(e,t,n){var r=String(e);return!r||r.length>=t?e:""+Array(t+1-r.length).join(n)+e},b={s:y,z:function(e){var t=-e.utcOffset(),n=Math.abs(t),r=Math.floor(n/60),a=n%60;return(t<=0?"+":"-")+y(r,2,"0")+":"+y(a,2,"0")},m:function e(t,n){if(t.date()<n.date())return-e(n,t);var r=12*(n.year()-t.year())+(n.month()-t.month()),a=t.clone().add(r,u),s=n-a<0,i=t.clone().add(r+(s?-1:1),u);return+(-(r+(n-a)/(s?a-i:i-a))||0)},a:function(e){return e<0?Math.ceil(e)||0:Math.floor(e)},p:function(e){return{M:u,y:d,w:l,d:o,D:h,h:i,m:s,s:a,ms:r,Q:c}[e]||String(e||"").toLowerCase().replace(/s$/,"")},u:function(e){return void 0===e}},v="en",x={};x[v]=g;var w="$isDayjsObject",k=function(e){return e instanceof N||!(!e||!e[w])},S=function e(t,n,r){var a;if(!t)return v;if("string"==typeof t){var s=t.toLowerCase();x[s]&&(a=s),n&&(x[s]=n,a=s);var i=t.split("-");if(!a&&i.length>1)return e(i[0])}else{var o=t.name;x[o]=t,a=o}return!r&&a&&(v=a),a||!r&&v},I=function(e,t){if(k(e))return e.clone();var n="object"==typeof t?t:{};return n.date=e,n.args=arguments,new N(n)},T=b;T.l=S,T.i=k,T.w=function(e,t){return I(e,{locale:t.$L,utc:t.$u,x:t.$x,$offset:t.$offset})};var N=function(){function g(e){this.$L=S(e.locale,null,!0),this.parse(e),this.$x=this.$x||e.x||{},this[w]=!0}var y=g.prototype;return y.parse=function(e){this.$d=function(e){var t=e.date,n=e.utc;if(null===t)return new Date(NaN);if(T.u(t))return new Date;if(t instanceof Date)return new Date(t);if("string"==typeof t&&!/Z$/i.test(t)){var r=t.match(f);if(r){var a=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],a,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],a,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(t)}(e),this.init()},y.init=function(){var e=this.$d;this.$y=e.getFullYear(),this.$M=e.getMonth(),this.$D=e.getDate(),this.$W=e.getDay(),this.$H=e.getHours(),this.$m=e.getMinutes(),this.$s=e.getSeconds(),this.$ms=e.getMilliseconds()},y.$utils=function(){return T},y.isValid=function(){return!(this.$d.toString()===p)},y.isSame=function(e,t){var n=I(e);return this.startOf(t)<=n&&n<=this.endOf(t)},y.isAfter=function(e,t){return I(e)<this.startOf(t)},y.isBefore=function(e,t){return this.endOf(t)<I(e)},y.$g=function(e,t,n){return T.u(e)?this[t]:this.set(n,e)},y.unix=function(){return Math.floor(this.valueOf()/1e3)},y.valueOf=function(){return this.$d.getTime()},y.startOf=function(e,t){var n=this,r=!!T.u(t)||t,c=T.p(e),p=function(e,t){var a=T.w(n.$u?Date.UTC(n.$y,t,e):new Date(n.$y,t,e),n);return r?a:a.endOf(o)},f=function(e,t){return T.w(n.toDate()[e].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(t)),n)},m=this.$W,g=this.$M,y=this.$D,b="set"+(this.$u?"UTC":"");switch(c){case d:return r?p(1,0):p(31,11);case u:return r?p(1,g):p(0,g+1);case l:var v=this.$locale().weekStart||0,x=(m<v?m+7:m)-v;return p(r?y-x:y+(6-x),g);case o:case h:return f(b+"Hours",0);case i:return f(b+"Minutes",1);case s:return f(b+"Seconds",2);case a:return f(b+"Milliseconds",3);default:return this.clone()}},y.endOf=function(e){return this.startOf(e,!1)},y.$set=function(e,t){var n,l=T.p(e),c="set"+(this.$u?"UTC":""),p=(n={},n[o]=c+"Date",n[h]=c+"Date",n[u]=c+"Month",n[d]=c+"FullYear",n[i]=c+"Hours",n[s]=c+"Minutes",n[a]=c+"Seconds",n[r]=c+"Milliseconds",n)[l],f=l===o?this.$D+(t-this.$W):t;if(l===u||l===d){var m=this.clone().set(h,1);m.$d[p](f),m.init(),this.$d=m.set(h,Math.min(this.$D,m.daysInMonth())).$d}else p&&this.$d[p](f);return this.init(),this},y.set=function(e,t){return this.clone().$set(e,t)},y.get=function(e){return this[T.p(e)]()},y.add=function(r,c){var h,p=this;r=Number(r);var f=T.p(c),m=function(e){var t=I(p);return T.w(t.date(t.date()+Math.round(e*r)),p)};if(f===u)return this.set(u,this.$M+r);if(f===d)return this.set(d,this.$y+r);if(f===o)return m(1);if(f===l)return m(7);var g=(h={},h[s]=t,h[i]=n,h[a]=e,h)[f]||1,y=this.$d.getTime()+r*g;return T.w(y,this)},y.subtract=function(e,t){return this.add(-1*e,t)},y.format=function(e){var t=this,n=this.$locale();if(!this.isValid())return n.invalidDate||p;var r=e||"YYYY-MM-DDTHH:mm:ssZ",a=T.z(this),s=this.$H,i=this.$m,o=this.$M,l=n.weekdays,u=n.months,c=n.meridiem,d=function(e,n,a,s){return e&&(e[n]||e(t,r))||a[n].slice(0,s)},h=function(e){return T.s(s%12||12,e,"0")},f=c||function(e,t,n){var r=e<12?"AM":"PM";return n?r.toLowerCase():r};return r.replace(m,(function(e,r){return r||function(e){switch(e){case"YY":return String(t.$y).slice(-2);case"YYYY":return T.s(t.$y,4,"0");case"M":return o+1;case"MM":return T.s(o+1,2,"0");case"MMM":return d(n.monthsShort,o,u,3);case"MMMM":return d(u,o);case"D":return t.$D;case"DD":return T.s(t.$D,2,"0");case"d":return String(t.$W);case"dd":return d(n.weekdaysMin,t.$W,l,2);case"ddd":return d(n.weekdaysShort,t.$W,l,3);case"dddd":return l[t.$W];case"H":return String(s);case"HH":return T.s(s,2,"0");case"h":return h(1);case"hh":return h(2);case"a":return f(s,i,!0);case"A":return f(s,i,!1);case"m":return String(i);case"mm":return T.s(i,2,"0");case"s":return String(t.$s);case"ss":return T.s(t.$s,2,"0");case"SSS":return T.s(t.$ms,3,"0");case"Z":return a}return null}(e)||a.replace(":","")}))},y.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},y.diff=function(r,h,p){var f,m=this,g=T.p(h),y=I(r),b=(y.utcOffset()-this.utcOffset())*t,v=this-y,x=function(){return T.m(m,y)};switch(g){case d:f=x()/12;break;case u:f=x();break;case c:f=x()/3;break;case l:f=(v-b)/6048e5;break;case o:f=(v-b)/864e5;break;case i:f=v/n;break;case s:f=v/t;break;case a:f=v/e;break;default:f=v}return p?f:T.a(f)},y.daysInMonth=function(){return this.endOf(u).$D},y.$locale=function(){return x[this.$L]},y.locale=function(e,t){if(!e)return this.$L;var n=this.clone(),r=S(e,t,!0);return r&&(n.$L=r),n},y.clone=function(){return T.w(this.$d,this)},y.toDate=function(){return new Date(this.valueOf())},y.toJSON=function(){return this.isValid()?this.toISOString():null},y.toISOString=function(){return this.$d.toISOString()},y.toString=function(){return this.$d.toUTCString()},g}(),C=N.prototype;return I.prototype=C,[["$ms",r],["$s",a],["$m",s],["$H",i],["$W",o],["$M",u],["$y",d],["$D",h]].forEach((function(e){C[e[1]]=function(t){return this.$g(t,e[0],e[1])}})),I.extend=function(e,t){return e.$i||(e(t,N,I),e.$i=!0),I},I.locale=S,I.isDayjs=k,I.unix=function(e){return I(1e3*e)},I.en=x[v],I.Ls=x,I.p={},I}()},7076:function(e){e.exports=function(){"use strict";return function(e,t){var n=t.prototype,r=n.format;n.format=function(e){var t=this,n=this.$locale();if(!this.isValid())return r.bind(this)(e);var a=this.$utils(),s=(e||"YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,(function(e){switch(e){case"Q":return Math.ceil((t.$M+1)/3);case"Do":return n.ordinal(t.$D);case"gggg":return t.weekYear();case"GGGG":return t.isoWeekYear();case"wo":return n.ordinal(t.week(),"W");case"w":case"ww":return a.s(t.week(),"w"===e?1:2,"0");case"W":case"WW":return a.s(t.isoWeek(),"W"===e?1:2,"0");case"k":case"kk":return a.s(String(0===t.$H?24:t.$H),"k"===e?1:2,"0");case"X":return Math.floor(t.$d.getTime()/1e3);case"x":return t.$d.getTime();case"z":return"["+t.offsetName()+"]";case"zzz":return"["+t.offsetName("long")+"]";default:return e}}));return r.bind(this)(s)}}}()},8988:function(e){e.exports=function(){"use strict";var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},t=/(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,n=/\d/,r=/\d\d/,a=/\d\d?/,s=/\d*[^-_:/,()\s\d]+/,i={},o=function(e){return(e=+e)+(e>68?1900:2e3)},l=function(e){return function(t){this[e]=+t}},u=[/[+-]\d\d:?(\d\d)?|Z/,function(e){(this.zone||(this.zone={})).offset=function(e){if(!e)return 0;if("Z"===e)return 0;var t=e.match(/([+-]|\d\d)/g),n=60*t[1]+(+t[2]||0);return 0===n?0:"+"===t[0]?-n:n}(e)}],c=function(e){var t=i[e];return t&&(t.indexOf?t:t.s.concat(t.f))},d=function(e,t){var n,r=i.meridiem;if(r){for(var a=1;a<=24;a+=1)if(e.indexOf(r(a,0,t))>-1){n=a>12;break}}else n=e===(t?"pm":"PM");return n},h={A:[s,function(e){this.afternoon=d(e,!1)}],a:[s,function(e){this.afternoon=d(e,!0)}],Q:[n,function(e){this.month=3*(e-1)+1}],S:[n,function(e){this.milliseconds=100*+e}],SS:[r,function(e){this.milliseconds=10*+e}],SSS:[/\d{3}/,function(e){this.milliseconds=+e}],s:[a,l("seconds")],ss:[a,l("seconds")],m:[a,l("minutes")],mm:[a,l("minutes")],H:[a,l("hours")],h:[a,l("hours")],HH:[a,l("hours")],hh:[a,l("hours")],D:[a,l("day")],DD:[r,l("day")],Do:[s,function(e){var t=i.ordinal,n=e.match(/\d+/);if(this.day=n[0],t)for(var r=1;r<=31;r+=1)t(r).replace(/\[|\]/g,"")===e&&(this.day=r)}],w:[a,l("week")],ww:[r,l("week")],M:[a,l("month")],MM:[r,l("month")],MMM:[s,function(e){var t=c("months"),n=(c("monthsShort")||t.map((function(e){return e.slice(0,3)}))).indexOf(e)+1;if(n<1)throw new Error;this.month=n%12||n}],MMMM:[s,function(e){var t=c("months").indexOf(e)+1;if(t<1)throw new Error;this.month=t%12||t}],Y:[/[+-]?\d+/,l("year")],YY:[r,function(e){this.year=o(e)}],YYYY:[/\d{4}/,l("year")],Z:u,ZZ:u};function p(n){var r,a;r=n,a=i&&i.formats;for(var s=(n=r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var s=r&&r.toUpperCase();return n||a[r]||e[r]||a[s].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))).match(t),o=s.length,l=0;l<o;l+=1){var u=s[l],c=h[u],d=c&&c[0],p=c&&c[1];s[l]=p?{regex:d,parser:p}:u.replace(/^\[|\]$/g,"")}return function(e){for(var t={},n=0,r=0;n<o;n+=1){var a=s[n];if("string"==typeof a)r+=a.length;else{var i=a.regex,l=a.parser,u=e.slice(r),c=i.exec(u)[0];l.call(t,c),e=e.replace(c,"")}}return function(e){var t=e.afternoon;if(void 0!==t){var n=e.hours;t?n<12&&(e.hours+=12):12===n&&(e.hours=0),delete e.afternoon}}(t),t}}return function(e,t,n){n.p.customParseFormat=!0,e&&e.parseTwoDigitYear&&(o=e.parseTwoDigitYear);var r=t.prototype,a=r.parse;r.parse=function(e){var t=e.date,r=e.utc,s=e.args;this.$u=r;var o=s[1];if("string"==typeof o){var l=!0===s[2],u=!0===s[3],c=l||u,d=s[2];u&&(d=s[2]),i=this.$locale(),!l&&d&&(i=n.Ls[d]),this.$d=function(e,t,n,r){try{if(["x","X"].indexOf(t)>-1)return new Date(("X"===t?1e3:1)*e);var a=p(t)(e),s=a.year,i=a.month,o=a.day,l=a.hours,u=a.minutes,c=a.seconds,d=a.milliseconds,h=a.zone,f=a.week,m=new Date,g=o||(s||i?1:m.getDate()),y=s||m.getFullYear(),b=0;s&&!i||(b=i>0?i-1:m.getMonth());var v,x=l||0,w=u||0,k=c||0,S=d||0;return h?new Date(Date.UTC(y,b,g,x,w,k,S+60*h.offset*1e3)):n?new Date(Date.UTC(y,b,g,x,w,k,S)):(v=new Date(y,b,g,x,w,k,S),f&&(v=r(v).week(f).toDate()),v)}catch(e){return new Date("")}}(t,o,r,n),this.init(),d&&!0!==d&&(this.$L=this.locale(d).$L),c&&t!=this.format(o)&&(this.$d=new Date("")),i={}}else if(o instanceof Array)for(var h=o.length,f=1;f<=h;f+=1){s[1]=o[f-1];var m=n.apply(this,s);if(m.isValid()){this.$d=m.$d,this.$L=m.$L,this.init();break}f===h&&(this.$d=new Date(""))}else a.call(this,e)}}}()},1525:function(e){e.exports=function(){"use strict";return function(e,t,n){t.prototype.isBetween=function(e,t,r,a){var s=n(e),i=n(t),o="("===(a=a||"()")[0],l=")"===a[1];return(o?this.isAfter(s,r):!this.isBefore(s,r))&&(l?this.isBefore(i,r):!this.isAfter(i,r))||(o?this.isBefore(s,r):!this.isAfter(s,r))&&(l?this.isAfter(i,r):!this.isBefore(i,r))}}}()},4443:function(e){e.exports=function(){"use strict";var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};return function(t,n,r){var a=n.prototype,s=a.format;r.en.formats=e,a.format=function(t){void 0===t&&(t="YYYY-MM-DDTHH:mm:ssZ");var n=this.$locale().formats,r=function(t,n){return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,r,a){var s=a&&a.toUpperCase();return r||n[a]||e[a]||n[s].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))}(t,void 0===n?{}:n);return s.call(this,r)}}}()},6865:function(e){e.exports=function(){"use strict";var e="week",t="year";return function(n,r,a){var s=r.prototype;s.week=function(n){if(void 0===n&&(n=null),null!==n)return this.add(7*(n-this.week()),"day");var r=this.$locale().yearStart||1;if(11===this.month()&&this.date()>25){var s=a(this).startOf(t).add(1,t).date(r),i=a(this).endOf(e);if(s.isBefore(i))return 1}var o=a(this).startOf(t).date(r).startOf(e).subtract(1,"millisecond"),l=this.diff(o,e,!0);return l<0?a(this).startOf("week").week():Math.ceil(l)},s.weeks=function(e){return void 0===e&&(e=null),this.week(e)}}}()},757:function(e){"undefined"!=typeof self&&self,e.exports=function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(r,a,function(t){return e[t]}.bind(null,a));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";n.r(t);var r={};function a(e){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}n.r(r),n.d(r,"VictoryGesture",(function(){return C})),n.d(r,"ThumbsUpGesture",(function(){return R}));var s={Thumb:0,Index:1,Middle:2,Ring:3,Pinky:4,all:[0,1,2,3,4],nameMapping:{0:"Thumb",1:"Index",2:"Middle",3:"Ring",4:"Pinky"},pointsMapping:{0:[[0,1],[1,2],[2,3],[3,4]],1:[[0,5],[5,6],[6,7],[7,8]],2:[[0,9],[9,10],[10,11],[11,12]],3:[[0,13],[13,14],[14,15],[15,16]],4:[[0,17],[17,18],[18,19],[19,20]]},getName:function(e){return void 0!==a(this.nameMapping[e])&&this.nameMapping[e]},getPoints:function(e){return void 0!==a(this.pointsMapping[e])&&this.pointsMapping[e]}},i={NoCurl:0,HalfCurl:1,FullCurl:2,nameMapping:{0:"No Curl",1:"Half Curl",2:"Full Curl"},getName:function(e){return void 0!==a(this.nameMapping[e])&&this.nameMapping[e]}},o={VerticalUp:0,VerticalDown:1,HorizontalLeft:2,HorizontalRight:3,DiagonalUpRight:4,DiagonalUpLeft:5,DiagonalDownRight:6,DiagonalDownLeft:7,nameMapping:{0:"Vertical Up",1:"Vertical Down",2:"Horizontal Left",3:"Horizontal Right",4:"Diagonal Up Right",5:"Diagonal Up Left",6:"Diagonal Down Right",7:"Diagonal Down Left"},getName:function(e){return void 0!==a(this.nameMapping[e])&&this.nameMapping[e]}};function l(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=function(e,t){if(e){if("string"==typeof e)return u(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?u(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,a=function(){};return{s:a,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,i=!0,o=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return i=e.done,e},e:function(e){o=!0,s=e},f:function(){try{i||null==n.return||n.return()}finally{if(o)throw s}}}}function u(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function d(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){h(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function h(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function p(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var f=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options=d(d({},{HALF_CURL_START_LIMIT:60,NO_CURL_START_LIMIT:130,DISTANCE_VOTE_POWER:1.1,SINGLE_ANGLE_VOTE_POWER:.9,TOTAL_ANGLE_VOTE_POWER:1.6}),t)}var t,n,r;return t=e,(n=[{key:"estimate",value:function(e){var t,n=[],r=[],a=l(s.all);try{for(a.s();!(t=a.n()).done;){var i,o=t.value,u=s.getPoints(o),c=[],d=[],h=l(u);try{for(h.s();!(i=h.n()).done;){var p=i.value,f=e[p[0]],m=e[p[1]],g=this.getSlopes(f,m),y=g[0],b=g[1];c.push(y),d.push(b)}}catch(e){h.e(e)}finally{h.f()}n.push(c),r.push(d)}}catch(e){a.e(e)}finally{a.f()}var v,x=[],w=[],k=l(s.all);try{for(k.s();!(v=k.n()).done;){var S=v.value,I=S==s.Thumb?1:0,T=s.getPoints(S),N=e[T[I][0]],C=e[T[I+1][1]],A=e[T[3][1]],E=this.estimateFingerCurl(N,C,A),_=this.calculateFingerDirection(N,C,A,n[S].slice(I));x[S]=E,w[S]=_}}catch(e){k.e(e)}finally{k.f()}return{curls:x,directions:w}}},{key:"getSlopes",value:function(e,t){var n=this.calculateSlope(e[0],e[1],t[0],t[1]);return 2==e.length?n:[n,this.calculateSlope(e[1],e[2],t[1],t[2])]}},{key:"angleOrientationAt",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=0,r=0,a=0;return e>=75&&e<=105?n=1*t:e>=25&&e<=155?r=1*t:a=1*t,[n,r,a]}},{key:"estimateFingerCurl",value:function(e,t,n){var r=e[0]-t[0],a=e[0]-n[0],s=t[0]-n[0],o=e[1]-t[1],l=e[1]-n[1],u=t[1]-n[1],c=e[2]-t[2],d=e[2]-n[2],h=t[2]-n[2],p=Math.sqrt(r*r+o*o+c*c),f=Math.sqrt(a*a+l*l+d*d),m=Math.sqrt(s*s+u*u+h*h),g=(m*m+p*p-f*f)/(2*m*p);g>1?g=1:g<-1&&(g=-1);var y=Math.acos(g);return(y=57.2958*y%180)>this.options.NO_CURL_START_LIMIT?i.NoCurl:y>this.options.HALF_CURL_START_LIMIT?i.HalfCurl:i.FullCurl}},{key:"estimateHorizontalDirection",value:function(e,t,n,r){return r==Math.abs(e)?e>0?o.HorizontalLeft:o.HorizontalRight:r==Math.abs(t)?t>0?o.HorizontalLeft:o.HorizontalRight:n>0?o.HorizontalLeft:o.HorizontalRight}},{key:"estimateVerticalDirection",value:function(e,t,n,r){return r==Math.abs(e)?e<0?o.VerticalDown:o.VerticalUp:r==Math.abs(t)?t<0?o.VerticalDown:o.VerticalUp:n<0?o.VerticalDown:o.VerticalUp}},{key:"estimateDiagonalDirection",value:function(e,t,n,r,a,s,i,l){var u=this.estimateVerticalDirection(e,t,n,r),c=this.estimateHorizontalDirection(a,s,i,l);return u==o.VerticalUp?c==o.HorizontalLeft?o.DiagonalUpLeft:o.DiagonalUpRight:c==o.HorizontalLeft?o.DiagonalDownLeft:o.DiagonalDownRight}},{key:"calculateFingerDirection",value:function(e,t,n,r){var a=e[0]-t[0],s=e[0]-n[0],i=t[0]-n[0],o=e[1]-t[1],u=e[1]-n[1],c=t[1]-n[1],d=Math.max(Math.abs(a),Math.abs(s),Math.abs(i)),h=Math.max(Math.abs(o),Math.abs(u),Math.abs(c)),p=0,f=0,m=0,g=h/(d+1e-5);g>1.5?p+=this.options.DISTANCE_VOTE_POWER:g>.66?f+=this.options.DISTANCE_VOTE_POWER:m+=this.options.DISTANCE_VOTE_POWER;var y=Math.sqrt(a*a+o*o),b=Math.sqrt(s*s+u*u),v=Math.sqrt(i*i+c*c),x=Math.max(y,b,v),w=e[0],k=e[1],S=n[0],I=n[1];x==y?(S=n[0],I=n[1]):x==v&&(w=t[0],k=t[1]);var T=[w,k],N=[S,I],C=this.getSlopes(T,N),A=this.angleOrientationAt(C,this.options.TOTAL_ANGLE_VOTE_POWER);p+=A[0],f+=A[1],m+=A[2];var E,_=l(r);try{for(_.s();!(E=_.n()).done;){var $=E.value,R=this.angleOrientationAt($,this.options.SINGLE_ANGLE_VOTE_POWER);p+=R[0],f+=R[1],m+=R[2]}}catch(e){_.e(e)}finally{_.f()}return p==Math.max(p,f,m)?this.estimateVerticalDirection(u,o,c,h):m==Math.max(f,m)?this.estimateHorizontalDirection(s,a,i,d):this.estimateDiagonalDirection(u,o,c,h,s,a,i,d)}},{key:"calculateSlope",value:function(e,t,n,r){var a=(t-r)/(e-n),s=180*Math.atan(a)/Math.PI;return s<=0?s=-s:s>0&&(s=180-s),s}}])&&p(t.prototype,n),r&&p(t,r),e}();function m(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=function(e,t){if(e){if("string"==typeof e)return g(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?g(e,t):void 0}}(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,a=function(){};return{s:a,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,i=!0,o=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return i=e.done,e},e:function(e){o=!0,s=e},f:function(){try{i||null==n.return||n.return()}finally{if(o)throw s}}}}function g(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function y(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function b(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var v=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};y(this,e),this.estimator=new f(n),this.gestures=t}var t,n,r;return t=e,(n=[{key:"estimate",value:function(e,t){var n,r=[],a=this.estimator.estimate(e),l=[],u=m(s.all);try{for(u.s();!(n=u.n()).done;){var c=n.value;l.push([s.getName(c),i.getName(a.curls[c]),o.getName(a.directions[c])])}}catch(e){u.e(e)}finally{u.f()}var d,h=m(this.gestures);try{for(h.s();!(d=h.n()).done;){var p=d.value,f=p.matchAgainst(a.curls,a.directions);f>=t&&r.push({name:p.name,score:f})}}catch(e){h.e(e)}finally{h.f()}return{poseData:l,gestures:r}}}])&&b(t.prototype,n),r&&b(t,r),e}();function x(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=n){var r,a,s=[],i=!0,o=!1;try{for(n=n.call(e);!(i=(r=n.next()).done)&&(s.push(r.value),!t||s.length!==t);i=!0);}catch(e){o=!0,a=e}finally{try{i||null==n.return||n.return()}finally{if(o)throw a}}return s}}(e,t)||k(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function w(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!n){if(Array.isArray(e)||(n=k(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0,a=function(){};return{s:a,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,i=!0,o=!1;return{s:function(){n=n.call(e)},n:function(){var e=n.next();return i=e.done,e},e:function(e){o=!0,s=e},f:function(){try{i||null==n.return||n.return()}finally{if(o)throw s}}}}function k(e,t){if(e){if("string"==typeof e)return S(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?S(e,t):void 0}}function S(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function I(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var T=function(){function e(t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.name=t,this.curls={},this.directions={}}var t,n,r;return t=e,(n=[{key:"addCurl",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;void 0===this.curls[e]&&(this.curls[e]=[]),this.curls[e].push([t,n])}},{key:"addDirection",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;void 0===this.directions[e]&&(this.directions[e]=[]),this.directions[e].push([t,n])}},{key:"matchAgainst",value:function(e,t){var n=0,r=0;for(var a in e){var s=e[a],i=this.curls[a];if(void 0!==i){r++;var o,l=!1,u=0,c=w(i);try{for(c.s();!(o=c.n()).done;){var d=x(o.value,2),h=d[0],p=d[1];if(s==h){n+=p,u=Math.max(u,p),l=!0;break}}}catch(e){c.e(e)}finally{c.f()}l||(n-=u)}}for(var f in t){var m=t[f],g=this.directions[f];if(void 0!==g){r++;var y,b=!1,v=0,k=w(g);try{for(k.s();!(y=k.n()).done;){var S=x(y.value,2),I=S[0],T=S[1];if(m==I){n+=T,v=Math.max(v,T),b=!0;break}}}catch(e){k.e(e)}finally{k.f()}b||(n-=v)}}return n/r*10}}])&&I(t.prototype,n),r&&I(t,r),e}(),N=new T("victory");N.addDirection(s.Thumb,o.VerticalUp,1),N.addDirection(s.Thumb,o.DiagonalUpLeft,1),N.addDirection(s.Thumb,o.DiagonalUpRight,1),N.addCurl(s.Index,i.NoCurl,1),N.addDirection(s.Index,o.VerticalUp,1),N.addDirection(s.Index,o.DiagonalUpLeft,1),N.addDirection(s.Index,o.DiagonalUpRight,1),N.addDirection(s.Index,o.HorizontalLeft,1),N.addDirection(s.Index,o.HorizontalRight,1),N.addCurl(s.Middle,i.NoCurl,1),N.addDirection(s.Middle,o.VerticalUp,1),N.addDirection(s.Middle,o.DiagonalUpLeft,1),N.addDirection(s.Middle,o.DiagonalUpRight,1),N.addDirection(s.Middle,o.HorizontalLeft,1),N.addDirection(s.Middle,o.HorizontalRight,1),N.addCurl(s.Ring,i.FullCurl,1),N.addCurl(s.Ring,i.HalfCurl,.9),N.addCurl(s.Pinky,i.FullCurl,1),N.addCurl(s.Pinky,i.HalfCurl,.9);var C=N,A=new T("thumbs_up");A.addCurl(s.Thumb,i.NoCurl,1),A.addDirection(s.Thumb,o.VerticalUp,1),A.addDirection(s.Thumb,o.DiagonalUpLeft,.9),A.addDirection(s.Thumb,o.DiagonalUpRight,.9);for(var E=0,_=[s.Index,s.Middle,s.Ring,s.Pinky];E<_.length;E++){var $=_[E];A.addCurl($,i.FullCurl,1),A.addCurl($,i.HalfCurl,.9)}A.addDirection(s.Index,o.DiagonalUpLeft,1),A.addDirection(s.Index,o.HorizontalLeft,1),A.addDirection(s.Index,o.HorizontalRight,1),A.addDirection(s.Index,o.DiagonalUpRight,1);var R=A;t.default={GestureEstimator:v,GestureDescription:T,Finger:s,FingerCurl:i,FingerDirection:o,Gestures:r}}]).default},219:(e,t,n)=>{"use strict";var r=n(3763),a={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},s={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},i={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},o={};function l(e){return r.isMemo(e)?i:o[e.$$typeof]||a}o[r.ForwardRef]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},o[r.Memo]=i;var u=Object.defineProperty,c=Object.getOwnPropertyNames,d=Object.getOwnPropertySymbols,h=Object.getOwnPropertyDescriptor,p=Object.getPrototypeOf,f=Object.prototype;e.exports=function e(t,n,r){if("string"!==typeof n){if(f){var a=p(n);a&&a!==f&&e(t,a,r)}var i=c(n);d&&(i=i.concat(d(n)));for(var o=l(t),m=l(n),g=0;g<i.length;++g){var y=i[g];if(!s[y]&&(!r||!r[y])&&(!m||!m[y])&&(!o||!o[y])){var b=h(n,y);try{u(t,y,b)}catch(v){}}}}return t}},4983:(e,t)=>{"use strict";var n="function"===typeof Symbol&&Symbol.for,r=n?Symbol.for("react.element"):60103,a=n?Symbol.for("react.portal"):60106,s=n?Symbol.for("react.fragment"):60107,i=n?Symbol.for("react.strict_mode"):60108,o=n?Symbol.for("react.profiler"):60114,l=n?Symbol.for("react.provider"):60109,u=n?Symbol.for("react.context"):60110,c=n?Symbol.for("react.async_mode"):60111,d=n?Symbol.for("react.concurrent_mode"):60111,h=n?Symbol.for("react.forward_ref"):60112,p=n?Symbol.for("react.suspense"):60113,f=n?Symbol.for("react.suspense_list"):60120,m=n?Symbol.for("react.memo"):60115,g=n?Symbol.for("react.lazy"):60116,y=n?Symbol.for("react.block"):60121,b=n?Symbol.for("react.fundamental"):60117,v=n?Symbol.for("react.responder"):60118,x=n?Symbol.for("react.scope"):60119;function w(e){if("object"===typeof e&&null!==e){var t=e.$$typeof;switch(t){case r:switch(e=e.type){case c:case d:case s:case o:case i:case p:return e;default:switch(e=e&&e.$$typeof){case u:case h:case g:case m:case l:return e;default:return t}}case a:return t}}}function k(e){return w(e)===d}t.AsyncMode=c,t.ConcurrentMode=d,t.ContextConsumer=u,t.ContextProvider=l,t.Element=r,t.ForwardRef=h,t.Fragment=s,t.Lazy=g,t.Memo=m,t.Portal=a,t.Profiler=o,t.StrictMode=i,t.Suspense=p,t.isAsyncMode=function(e){return k(e)||w(e)===c},t.isConcurrentMode=k,t.isContextConsumer=function(e){return w(e)===u},t.isContextProvider=function(e){return w(e)===l},t.isElement=function(e){return"object"===typeof e&&null!==e&&e.$$typeof===r},t.isForwardRef=function(e){return w(e)===h},t.isFragment=function(e){return w(e)===s},t.isLazy=function(e){return w(e)===g},t.isMemo=function(e){return w(e)===m},t.isPortal=function(e){return w(e)===a},t.isProfiler=function(e){return w(e)===o},t.isStrictMode=function(e){return w(e)===i},t.isSuspense=function(e){return w(e)===p},t.isValidElementType=function(e){return"string"===typeof e||"function"===typeof e||e===s||e===d||e===o||e===i||e===p||e===f||"object"===typeof e&&null!==e&&(e.$$typeof===g||e.$$typeof===m||e.$$typeof===l||e.$$typeof===u||e.$$typeof===h||e.$$typeof===b||e.$$typeof===v||e.$$typeof===x||e.$$typeof===y)},t.typeOf=w},3763:(e,t,n)=>{"use strict";e.exports=n(4983)},1497:(e,t,n)=>{"use strict";var r=n(3218);function a(){}function s(){}s.resetWarningCache=a,e.exports=function(){function e(e,t,n,a,s,i){if(i!==r){var o=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw o.name="Invariant Violation",o}}function t(){return e}e.isRequired=e;var n={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:s,resetWarningCache:a};return n.PropTypes=n,n}},5173:(e,t,n)=>{e.exports=n(1497)()},3218:e=>{"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},2730:(e,t,n)=>{"use strict";var r=n(5043),a=n(8853);function s(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,o={};function l(e,t){u(e,t),u(e+"Capture",t)}function u(e,t){for(o[e]=t,e=0;e<t.length;e++)i.add(t[e])}var c=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),d=Object.prototype.hasOwnProperty,h=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(e,t,n,r,a,s,i){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=r,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=s,this.removeEmptyString=i}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){g[e]=new m(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){g[e]=new m(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){g[e]=new m(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){g[e]=new m(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){g[e]=new m(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)}));var y=/[\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function v(e,t,n,r){var a=g.hasOwnProperty(t)?g[t]:null;(null!==a?0!==a.type:r||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,r){if(null===t||"undefined"===typeof t||function(e,t,n,r){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,a,r)&&(n=null),r||null===a?function(e){return!!d.call(f,e)||!d.call(p,e)&&(h.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):a.mustUseProperty?e[a.propertyName]=null===n?3!==a.type&&"":n:(t=a.attributeName,r=a.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(a=a.type)||4===a&&!0===n?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)})),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)}));var x=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),I=Symbol.for("react.strict_mode"),T=Symbol.for("react.profiler"),N=Symbol.for("react.provider"),C=Symbol.for("react.context"),A=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),_=Symbol.for("react.suspense_list"),$=Symbol.for("react.memo"),R=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var D=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var M=Symbol.iterator;function F(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=M&&e[M]||e["@@iterator"])?e:null}var O,P=Object.assign;function L(e){if(void 0===O)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);O=t&&t[1]||""}return"\n"+O+e}var z=!1;function B(e,t){if(!e||z)return"";z=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(u){var r=u}Reflect.construct(e,[],t)}else{try{t.call()}catch(u){r=u}e.call(t.prototype)}else{try{throw Error()}catch(u){r=u}e()}}catch(u){if(u&&r&&"string"===typeof u.stack){for(var a=u.stack.split("\n"),s=r.stack.split("\n"),i=a.length-1,o=s.length-1;1<=i&&0<=o&&a[i]!==s[o];)o--;for(;1<=i&&0<=o;i--,o--)if(a[i]!==s[o]){if(1!==i||1!==o)do{if(i--,0>--o||a[i]!==s[o]){var l="\n"+a[i].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=i&&0<=o);break}}}finally{z=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?L(e):""}function V(e){switch(e.tag){case 5:return L(e.type);case 16:return L("Lazy");case 13:return L("Suspense");case 19:return L("SuspenseList");case 0:case 2:case 15:return e=B(e.type,!1);case 11:return e=B(e.type.render,!1);case 1:return e=B(e.type,!0);default:return""}}function W(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case S:return"Fragment";case k:return"Portal";case T:return"Profiler";case I:return"StrictMode";case E:return"Suspense";case _:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case C:return(e.displayName||"Context")+".Consumer";case N:return(e._context.displayName||"Context")+".Provider";case A:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case $:return null!==(t=e.displayName||null)?t:W(e.type)||"Memo";case R:t=e._payload,e=e._init;try{return W(e(t))}catch(n){}}return null}function U(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return W(t);case 8:return t===I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function j(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function G(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function H(e){e._valueTracker||(e._valueTracker=function(e){var t=G(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var a=n.get,s=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(e){r=""+e,s.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=G(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function K(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function Y(e,t){var n=t.checked;return P({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function X(e,t){var n=null==t.defaultValue?"":t.defaultValue,r=null!=t.checked?t.checked:t.defaultChecked;n=j(null!=t.value?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Q(e,t){null!=(t=t.checked)&&v(e,"checked",t,!1)}function Z(e,t){Q(e,t);var n=j(t.value),r=t.type;if(null!=n)"number"===r?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===r||"reset"===r)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,j(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function J(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!("submit"!==r&&"reset"!==r||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&K(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,r){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&r&&(e[n].defaultSelected=!0)}else{for(n=""+j(n),t=null,a=0;a<e.length;a++){if(e[a].value===n)return e[a].selected=!0,void(r&&(e[a].defaultSelected=!0));null!==t||e[a].disabled||(t=e[a])}null!==t&&(t.selected=!0)}}function re(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(s(91));return P({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function ae(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(s(92));if(te(n)){if(1<n.length)throw Error(s(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:j(n)}}function se(e,t){var n=j(t.value),r=j(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=r&&(e.defaultValue=""+r)}function ie(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function oe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function le(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?oe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var ue,ce,de=(ce=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((ue=ue||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ue.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,r){MSApp.execUnsafeLocalFunction((function(){return ce(e,t)}))}:ce);function he(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var r=0===n.indexOf("--"),a=me(n,t[n],r);"float"===n&&(n="cssFloat"),r?e.setProperty(n,a):e[n]=a}}Object.keys(pe).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]}))}));var ye=P({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function be(e,t){if(t){if(ye[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(s(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(s(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(s(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(s(62))}}function ve(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var xe=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Se=null,Ie=null;function Te(e){if(e=va(e)){if("function"!==typeof ke)throw Error(s(280));var t=e.stateNode;t&&(t=wa(t),ke(e.stateNode,e.type,t))}}function Ne(e){Se?Ie?Ie.push(e):Ie=[e]:Se=e}function Ce(){if(Se){var e=Se,t=Ie;if(Ie=Se=null,Te(e),t)for(e=0;e<t.length;e++)Te(t[e])}}function Ae(e,t){return e(t)}function Ee(){}var _e=!1;function $e(e,t,n){if(_e)return e(t,n);_e=!0;try{return Ae(e,t,n)}finally{_e=!1,(null!==Se||null!==Ie)&&(Ee(),Ce())}}function Re(e,t){var n=e.stateNode;if(null===n)return null;var r=wa(n);if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(s(231,t,typeof n));return n}var De=!1;if(c)try{var Me={};Object.defineProperty(Me,"passive",{get:function(){De=!0}}),window.addEventListener("test",Me,Me),window.removeEventListener("test",Me,Me)}catch(ce){De=!1}function Fe(e,t,n,r,a,s,i,o,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(c){this.onError(c)}}var Oe=!1,Pe=null,Le=!1,ze=null,Be={onError:function(e){Oe=!0,Pe=e}};function Ve(e,t,n,r,a,s,i,o,l){Oe=!1,Pe=null,Fe.apply(Be,arguments)}function We(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ue(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function je(e){if(We(e)!==e)throw Error(s(188))}function Ge(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=We(e)))throw Error(s(188));return t!==e?null:e}for(var n=e,r=t;;){var a=n.return;if(null===a)break;var i=a.alternate;if(null===i){if(null!==(r=a.return)){n=r;continue}break}if(a.child===i.child){for(i=a.child;i;){if(i===n)return je(a),e;if(i===r)return je(a),t;i=i.sibling}throw Error(s(188))}if(n.return!==r.return)n=a,r=i;else{for(var o=!1,l=a.child;l;){if(l===n){o=!0,n=a,r=i;break}if(l===r){o=!0,r=a,n=i;break}l=l.sibling}if(!o){for(l=i.child;l;){if(l===n){o=!0,n=i,r=a;break}if(l===r){o=!0,r=i,n=a;break}l=l.sibling}if(!o)throw Error(s(189))}}if(n.alternate!==r)throw Error(s(190))}if(3!==n.tag)throw Error(s(188));return n.stateNode.current===n?e:t}(e))?He(e):null}function He(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=He(e);if(null!==t)return t;e=e.sibling}return null}var qe=a.unstable_scheduleCallback,Ke=a.unstable_cancelCallback,Ye=a.unstable_shouldYield,Xe=a.unstable_requestPaint,Qe=a.unstable_now,Ze=a.unstable_getCurrentPriorityLevel,Je=a.unstable_ImmediatePriority,et=a.unstable_UserBlockingPriority,tt=a.unstable_NormalPriority,nt=a.unstable_LowPriority,rt=a.unstable_IdlePriority,at=null,st=null;var it=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(ot(e)/lt|0)|0},ot=Math.log,lt=Math.LN2;var ut=64,ct=4194304;function dt(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function ht(e,t){var n=e.pendingLanes;if(0===n)return 0;var r=0,a=e.suspendedLanes,s=e.pingedLanes,i=268435455&n;if(0!==i){var o=i&~a;0!==o?r=dt(o):0!==(s&=i)&&(r=dt(s))}else 0!==(i=n&~a)?r=dt(i):0!==s&&(r=dt(s));if(0===r)return 0;if(0!==t&&t!==r&&0===(t&a)&&((a=r&-r)>=(s=t&-t)||16===a&&0!==(4194240&s)))return t;if(0!==(4&r)&&(r|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=r;0<t;)a=1<<(n=31-it(t)),r|=e[n],t&=~a;return r}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=ut;return 0===(4194240&(ut<<=1))&&(ut=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function yt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-it(t)]=n}function bt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-it(n),a=1<<r;a&t|e[r]&t&&(e[r]|=t),n&=~a}}var vt=0;function xt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var wt,kt,St,It,Tt,Nt=!1,Ct=[],At=null,Et=null,_t=null,$t=new Map,Rt=new Map,Dt=[],Mt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ft(e,t){switch(e){case"focusin":case"focusout":At=null;break;case"dragenter":case"dragleave":Et=null;break;case"mouseover":case"mouseout":_t=null;break;case"pointerover":case"pointerout":$t.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Rt.delete(t.pointerId)}}function Ot(e,t,n,r,a,s){return null===e||e.nativeEvent!==s?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:s,targetContainers:[a]},null!==t&&(null!==(t=va(t))&&kt(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==a&&-1===t.indexOf(a)&&t.push(a),e)}function Pt(e){var t=ba(e.target);if(null!==t){var n=We(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ue(n)))return e.blockedOn=t,void Tt(e.priority,(function(){St(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function Lt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Yt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=va(n))&&kt(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);xe=r,n.target.dispatchEvent(r),xe=null,t.shift()}return!0}function zt(e,t,n){Lt(e)&&n.delete(t)}function Bt(){Nt=!1,null!==At&&Lt(At)&&(At=null),null!==Et&&Lt(Et)&&(Et=null),null!==_t&&Lt(_t)&&(_t=null),$t.forEach(zt),Rt.forEach(zt)}function Vt(e,t){e.blockedOn===t&&(e.blockedOn=null,Nt||(Nt=!0,a.unstable_scheduleCallback(a.unstable_NormalPriority,Bt)))}function Wt(e){function t(t){return Vt(t,e)}if(0<Ct.length){Vt(Ct[0],e);for(var n=1;n<Ct.length;n++){var r=Ct[n];r.blockedOn===e&&(r.blockedOn=null)}}for(null!==At&&Vt(At,e),null!==Et&&Vt(Et,e),null!==_t&&Vt(_t,e),$t.forEach(t),Rt.forEach(t),n=0;n<Dt.length;n++)(r=Dt[n]).blockedOn===e&&(r.blockedOn=null);for(;0<Dt.length&&null===(n=Dt[0]).blockedOn;)Pt(n),null===n.blockedOn&&Dt.shift()}var Ut=x.ReactCurrentBatchConfig,jt=!0;function Gt(e,t,n,r){var a=vt,s=Ut.transition;Ut.transition=null;try{vt=1,qt(e,t,n,r)}finally{vt=a,Ut.transition=s}}function Ht(e,t,n,r){var a=vt,s=Ut.transition;Ut.transition=null;try{vt=4,qt(e,t,n,r)}finally{vt=a,Ut.transition=s}}function qt(e,t,n,r){if(jt){var a=Yt(e,t,n,r);if(null===a)jr(e,t,r,Kt,n),Ft(e,r);else if(function(e,t,n,r,a){switch(t){case"focusin":return At=Ot(At,e,t,n,r,a),!0;case"dragenter":return Et=Ot(Et,e,t,n,r,a),!0;case"mouseover":return _t=Ot(_t,e,t,n,r,a),!0;case"pointerover":var s=a.pointerId;return $t.set(s,Ot($t.get(s)||null,e,t,n,r,a)),!0;case"gotpointercapture":return s=a.pointerId,Rt.set(s,Ot(Rt.get(s)||null,e,t,n,r,a)),!0}return!1}(a,e,t,n,r))r.stopPropagation();else if(Ft(e,r),4&t&&-1<Mt.indexOf(e)){for(;null!==a;){var s=va(a);if(null!==s&&wt(s),null===(s=Yt(e,t,n,r))&&jr(e,t,r,Kt,n),s===a)break;a=s}null!==a&&r.stopPropagation()}else jr(e,t,r,null,n)}}var Kt=null;function Yt(e,t,n,r){if(Kt=null,null!==(e=ba(e=we(r))))if(null===(t=We(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Ue(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Kt=e,null}function Xt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Ze()){case Je:return 1;case et:return 4;case tt:case nt:return 16;case rt:return 536870912;default:return 16}default:return 16}}var Qt=null,Zt=null,Jt=null;function en(){if(Jt)return Jt;var e,t,n=Zt,r=n.length,a="value"in Qt?Qt.value:Qt.textContent,s=a.length;for(e=0;e<r&&n[e]===a[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===a[s-t];t++);return Jt=a.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function rn(){return!1}function an(e){function t(t,n,r,a,s){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=a,this.target=s,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(a):a[i]);return this.isDefaultPrevented=(null!=a.defaultPrevented?a.defaultPrevented:!1===a.returnValue)?nn:rn,this.isPropagationStopped=rn,this}return P(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var sn,on,ln,un={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},cn=an(un),dn=P({},un,{view:0,detail:0}),hn=an(dn),pn=P({},dn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Tn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==ln&&(ln&&"mousemove"===e.type?(sn=e.screenX-ln.screenX,on=e.screenY-ln.screenY):on=sn=0,ln=e),sn)},movementY:function(e){return"movementY"in e?e.movementY:on}}),fn=an(pn),mn=an(P({},pn,{dataTransfer:0})),gn=an(P({},dn,{relatedTarget:0})),yn=an(P({},un,{animationName:0,elapsedTime:0,pseudoElement:0})),bn=P({},un,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),vn=an(bn),xn=an(P({},un,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function In(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sn[e])&&!!t[e]}function Tn(){return In}var Nn=P({},dn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Tn,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Cn=an(Nn),An=an(P({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),En=an(P({},dn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Tn})),_n=an(P({},un,{propertyName:0,elapsedTime:0,pseudoElement:0})),$n=P({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Rn=an($n),Dn=[9,13,27,32],Mn=c&&"CompositionEvent"in window,Fn=null;c&&"documentMode"in document&&(Fn=document.documentMode);var On=c&&"TextEvent"in window&&!Fn,Pn=c&&(!Mn||Fn&&8<Fn&&11>=Fn),Ln=String.fromCharCode(32),zn=!1;function Bn(e,t){switch(e){case"keyup":return-1!==Dn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Vn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Wn=!1;var Un={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function jn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Un[e.type]:"textarea"===t}function Gn(e,t,n,r){Ne(r),0<(t=Hr(t,"onChange")).length&&(n=new cn("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Hn=null,qn=null;function Kn(e){Lr(e,0)}function Yn(e){if(q(xa(e)))return e}function Xn(e,t){if("change"===e)return t}var Qn=!1;if(c){var Zn;if(c){var Jn="oninput"in document;if(!Jn){var er=document.createElement("div");er.setAttribute("oninput","return;"),Jn="function"===typeof er.oninput}Zn=Jn}else Zn=!1;Qn=Zn&&(!document.documentMode||9<document.documentMode)}function tr(){Hn&&(Hn.detachEvent("onpropertychange",nr),qn=Hn=null)}function nr(e){if("value"===e.propertyName&&Yn(qn)){var t=[];Gn(t,qn,e,we(e)),$e(Kn,t)}}function rr(e,t,n){"focusin"===e?(tr(),qn=n,(Hn=t).attachEvent("onpropertychange",nr)):"focusout"===e&&tr()}function ar(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Yn(qn)}function sr(e,t){if("click"===e)return Yn(t)}function ir(e,t){if("input"===e||"change"===e)return Yn(t)}var or="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function lr(e,t){if(or(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!d.call(t,a)||!or(e[a],t[a]))return!1}return!0}function ur(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function cr(e,t){var n,r=ur(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=ur(r)}}function dr(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?dr(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function hr(){for(var e=window,t=K();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(r){n=!1}if(!n)break;t=K((e=t.contentWindow).document)}return t}function pr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fr(e){var t=hr(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&dr(n.ownerDocument.documentElement,n)){if(null!==r&&pr(n))if(t=r.start,void 0===(e=r.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var a=n.textContent.length,s=Math.min(r.start,a);r=void 0===r.end?s:Math.min(r.end,a),!e.extend&&s>r&&(a=r,r=s,s=a),a=cr(n,s);var i=cr(n,r);a&&i&&(1!==e.rangeCount||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&((t=t.createRange()).setStart(a.node,a.offset),e.removeAllRanges(),s>r?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var mr=c&&"documentMode"in document&&11>=document.documentMode,gr=null,yr=null,br=null,vr=!1;function xr(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;vr||null==gr||gr!==K(r)||("selectionStart"in(r=gr)&&pr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},br&&lr(br,r)||(br=r,0<(r=Hr(yr,"onSelect")).length&&(t=new cn("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=gr)))}function wr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var kr={animationend:wr("Animation","AnimationEnd"),animationiteration:wr("Animation","AnimationIteration"),animationstart:wr("Animation","AnimationStart"),transitionend:wr("Transition","TransitionEnd")},Sr={},Ir={};function Tr(e){if(Sr[e])return Sr[e];if(!kr[e])return e;var t,n=kr[e];for(t in n)if(n.hasOwnProperty(t)&&t in Ir)return Sr[e]=n[t];return e}c&&(Ir=document.createElement("div").style,"AnimationEvent"in window||(delete kr.animationend.animation,delete kr.animationiteration.animation,delete kr.animationstart.animation),"TransitionEvent"in window||delete kr.transitionend.transition);var Nr=Tr("animationend"),Cr=Tr("animationiteration"),Ar=Tr("animationstart"),Er=Tr("transitionend"),_r=new Map,$r="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Rr(e,t){_r.set(e,t),l(t,[e])}for(var Dr=0;Dr<$r.length;Dr++){var Mr=$r[Dr];Rr(Mr.toLowerCase(),"on"+(Mr[0].toUpperCase()+Mr.slice(1)))}Rr(Nr,"onAnimationEnd"),Rr(Cr,"onAnimationIteration"),Rr(Ar,"onAnimationStart"),Rr("dblclick","onDoubleClick"),Rr("focusin","onFocus"),Rr("focusout","onBlur"),Rr(Er,"onTransitionEnd"),u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Fr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Or=new Set("cancel close invalid load scroll toggle".split(" ").concat(Fr));function Pr(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,r,a,i,o,l,u){if(Ve.apply(this,arguments),Oe){if(!Oe)throw Error(s(198));var c=Pe;Oe=!1,Pe=null,Le||(Le=!0,ze=c)}}(r,t,void 0,e),e.currentTarget=null}function Lr(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var r=e[n],a=r.event;r=r.listeners;e:{var s=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==s&&a.isPropagationStopped())break e;Pr(a,o,u),s=l}else for(i=0;i<r.length;i++){if(l=(o=r[i]).instance,u=o.currentTarget,o=o.listener,l!==s&&a.isPropagationStopped())break e;Pr(a,o,u),s=l}}}if(Le)throw e=ze,Le=!1,ze=null,e}function zr(e,t){var n=t[ma];void 0===n&&(n=t[ma]=new Set);var r=e+"__bubble";n.has(r)||(Ur(t,e,2,!1),n.add(r))}function Br(e,t,n){var r=0;t&&(r|=4),Ur(n,e,r,t)}var Vr="_reactListening"+Math.random().toString(36).slice(2);function Wr(e){if(!e[Vr]){e[Vr]=!0,i.forEach((function(t){"selectionchange"!==t&&(Or.has(t)||Br(t,!1,e),Br(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Vr]||(t[Vr]=!0,Br("selectionchange",!1,t))}}function Ur(e,t,n,r){switch(Xt(t)){case 1:var a=Gt;break;case 4:a=Ht;break;default:a=qt}n=a.bind(null,t,n,e),a=void 0,!De||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(a=!0),r?void 0!==a?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):void 0!==a?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function jr(e,t,n,r,a){var s=r;if(0===(1&t)&&0===(2&t)&&null!==r)e:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var o=r.stateNode.containerInfo;if(o===a||8===o.nodeType&&o.parentNode===a)break;if(4===i)for(i=r.return;null!==i;){var l=i.tag;if((3===l||4===l)&&((l=i.stateNode.containerInfo)===a||8===l.nodeType&&l.parentNode===a))return;i=i.return}for(;null!==o;){if(null===(i=ba(o)))return;if(5===(l=i.tag)||6===l){r=s=i;continue e}o=o.parentNode}}r=r.return}$e((function(){var r=s,a=we(n),i=[];e:{var o=_r.get(e);if(void 0!==o){var l=cn,u=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":l=Cn;break;case"focusin":u="focus",l=gn;break;case"focusout":u="blur",l=gn;break;case"beforeblur":case"afterblur":l=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=En;break;case Nr:case Cr:case Ar:l=yn;break;case Er:l=_n;break;case"scroll":l=hn;break;case"wheel":l=Rn;break;case"copy":case"cut":case"paste":l=vn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=An}var c=0!==(4&t),d=!c&&"scroll"===e,h=c?null!==o?o+"Capture":null:o;c=[];for(var p,f=r;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==h&&(null!=(m=Re(f,h))&&c.push(Gr(f,m,p)))),d)break;f=f.return}0<c.length&&(o=new l(o,u,null,n,a),i.push({event:o,listeners:c}))}}if(0===(7&t)){if(l="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===xe||!(u=n.relatedTarget||n.fromElement)||!ba(u)&&!u[fa])&&(l||o)&&(o=a.window===a?a:(o=a.ownerDocument)?o.defaultView||o.parentWindow:window,l?(l=r,null!==(u=(u=n.relatedTarget||n.toElement)?ba(u):null)&&(u!==(d=We(u))||5!==u.tag&&6!==u.tag)&&(u=null)):(l=null,u=r),l!==u)){if(c=fn,m="onMouseLeave",h="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(c=An,m="onPointerLeave",h="onPointerEnter",f="pointer"),d=null==l?o:xa(l),p=null==u?o:xa(u),(o=new c(m,f+"leave",l,n,a)).target=d,o.relatedTarget=p,m=null,ba(a)===r&&((c=new c(h,f+"enter",u,n,a)).target=p,c.relatedTarget=d,m=c),d=m,l&&u)e:{for(h=u,f=0,p=c=l;p;p=qr(p))f++;for(p=0,m=h;m;m=qr(m))p++;for(;0<f-p;)c=qr(c),f--;for(;0<p-f;)h=qr(h),p--;for(;f--;){if(c===h||null!==h&&c===h.alternate)break e;c=qr(c),h=qr(h)}c=null}else c=null;null!==l&&Kr(i,o,l,c,!1),null!==u&&null!==d&&Kr(i,d,u,c,!0)}if("select"===(l=(o=r?xa(r):window).nodeName&&o.nodeName.toLowerCase())||"input"===l&&"file"===o.type)var g=Xn;else if(jn(o))if(Qn)g=ir;else{g=ar;var y=rr}else(l=o.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(g=sr);switch(g&&(g=g(e,r))?Gn(i,g,n,a):(y&&y(e,o,r),"focusout"===e&&(y=o._wrapperState)&&y.controlled&&"number"===o.type&&ee(o,"number",o.value)),y=r?xa(r):window,e){case"focusin":(jn(y)||"true"===y.contentEditable)&&(gr=y,yr=r,br=null);break;case"focusout":br=yr=gr=null;break;case"mousedown":vr=!0;break;case"contextmenu":case"mouseup":case"dragend":vr=!1,xr(i,n,a);break;case"selectionchange":if(mr)break;case"keydown":case"keyup":xr(i,n,a)}var b;if(Mn)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else Wn?Bn(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(Pn&&"ko"!==n.locale&&(Wn||"onCompositionStart"!==v?"onCompositionEnd"===v&&Wn&&(b=en()):(Zt="value"in(Qt=a)?Qt.value:Qt.textContent,Wn=!0)),0<(y=Hr(r,v)).length&&(v=new xn(v,e,null,n,a),i.push({event:v,listeners:y}),b?v.data=b:null!==(b=Vn(n))&&(v.data=b))),(b=On?function(e,t){switch(e){case"compositionend":return Vn(t);case"keypress":return 32!==t.which?null:(zn=!0,Ln);case"textInput":return(e=t.data)===Ln&&zn?null:e;default:return null}}(e,n):function(e,t){if(Wn)return"compositionend"===e||!Mn&&Bn(e,t)?(e=en(),Jt=Zt=Qt=null,Wn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Pn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(r=Hr(r,"onBeforeInput")).length&&(a=new xn("onBeforeInput","beforeinput",null,n,a),i.push({event:a,listeners:r}),a.data=b))}Lr(i,t)}))}function Gr(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Hr(e,t){for(var n=t+"Capture",r=[];null!==e;){var a=e,s=a.stateNode;5===a.tag&&null!==s&&(a=s,null!=(s=Re(e,n))&&r.unshift(Gr(e,s,a)),null!=(s=Re(e,t))&&r.push(Gr(e,s,a))),e=e.return}return r}function qr(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Kr(e,t,n,r,a){for(var s=t._reactName,i=[];null!==n&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(null!==l&&l===r)break;5===o.tag&&null!==u&&(o=u,a?null!=(l=Re(n,s))&&i.unshift(Gr(n,l,o)):a||null!=(l=Re(n,s))&&i.push(Gr(n,l,o))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var Yr=/\r\n?/g,Xr=/\u0000|\uFFFD/g;function Qr(e){return("string"===typeof e?e:""+e).replace(Yr,"\n").replace(Xr,"")}function Zr(e,t,n){if(t=Qr(t),Qr(e)!==t&&n)throw Error(s(425))}function Jr(){}var ea=null,ta=null;function na(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ra="function"===typeof setTimeout?setTimeout:void 0,aa="function"===typeof clearTimeout?clearTimeout:void 0,sa="function"===typeof Promise?Promise:void 0,ia="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof sa?function(e){return sa.resolve(null).then(e).catch(oa)}:ra;function oa(e){setTimeout((function(){throw e}))}function la(e,t){var n=t,r=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0===r)return e.removeChild(a),void Wt(t);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=a}while(n);Wt(t)}function ua(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function ca(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var da=Math.random().toString(36).slice(2),ha="__reactFiber$"+da,pa="__reactProps$"+da,fa="__reactContainer$"+da,ma="__reactEvents$"+da,ga="__reactListeners$"+da,ya="__reactHandles$"+da;function ba(e){var t=e[ha];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fa]||n[ha]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=ca(e);null!==e;){if(n=e[ha])return n;e=ca(e)}return t}n=(e=n).parentNode}return null}function va(e){return!(e=e[ha]||e[fa])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function xa(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(s(33))}function wa(e){return e[pa]||null}var ka=[],Sa=-1;function Ia(e){return{current:e}}function Ta(e){0>Sa||(e.current=ka[Sa],ka[Sa]=null,Sa--)}function Na(e,t){Sa++,ka[Sa]=e.current,e.current=t}var Ca={},Aa=Ia(Ca),Ea=Ia(!1),_a=Ca;function $a(e,t){var n=e.type.contextTypes;if(!n)return Ca;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var a,s={};for(a in n)s[a]=t[a];return r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function Ra(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Da(){Ta(Ea),Ta(Aa)}function Ma(e,t,n){if(Aa.current!==Ca)throw Error(s(168));Na(Aa,t),Na(Ea,n)}function Fa(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,"function"!==typeof r.getChildContext)return n;for(var a in r=r.getChildContext())if(!(a in t))throw Error(s(108,U(e)||"Unknown",a));return P({},n,r)}function Oa(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Ca,_a=Aa.current,Na(Aa,e),Na(Ea,Ea.current),!0}function Pa(e,t,n){var r=e.stateNode;if(!r)throw Error(s(169));n?(e=Fa(e,t,_a),r.__reactInternalMemoizedMergedChildContext=e,Ta(Ea),Ta(Aa),Na(Aa,e)):Ta(Ea),Na(Ea,n)}var La=null,za=!1,Ba=!1;function Va(e){null===La?La=[e]:La.push(e)}function Wa(){if(!Ba&&null!==La){Ba=!0;var e=0,t=vt;try{var n=La;for(vt=1;e<n.length;e++){var r=n[e];do{r=r(!0)}while(null!==r)}La=null,za=!1}catch(a){throw null!==La&&(La=La.slice(e+1)),qe(Je,Wa),a}finally{vt=t,Ba=!1}}return null}var Ua=[],ja=0,Ga=null,Ha=0,qa=[],Ka=0,Ya=null,Xa=1,Qa="";function Za(e,t){Ua[ja++]=Ha,Ua[ja++]=Ga,Ga=e,Ha=t}function Ja(e,t,n){qa[Ka++]=Xa,qa[Ka++]=Qa,qa[Ka++]=Ya,Ya=e;var r=Xa;e=Qa;var a=32-it(r)-1;r&=~(1<<a),n+=1;var s=32-it(t)+a;if(30<s){var i=a-a%5;s=(r&(1<<i)-1).toString(32),r>>=i,a-=i,Xa=1<<32-it(t)+a|n<<a|r,Qa=s+e}else Xa=1<<s|n<<a|r,Qa=e}function es(e){null!==e.return&&(Za(e,1),Ja(e,1,0))}function ts(e){for(;e===Ga;)Ga=Ua[--ja],Ua[ja]=null,Ha=Ua[--ja],Ua[ja]=null;for(;e===Ya;)Ya=qa[--Ka],qa[Ka]=null,Qa=qa[--Ka],qa[Ka]=null,Xa=qa[--Ka],qa[Ka]=null}var ns=null,rs=null,as=!1,ss=null;function is(e,t){var n=$u(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function os(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,ns=e,rs=ua(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,ns=e,rs=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Ya?{id:Xa,overflow:Qa}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=$u(18,null,null,0)).stateNode=t,n.return=e,e.child=n,ns=e,rs=null,!0);default:return!1}}function ls(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function us(e){if(as){var t=rs;if(t){var n=t;if(!os(e,t)){if(ls(e))throw Error(s(418));t=ua(n.nextSibling);var r=ns;t&&os(e,t)?is(r,n):(e.flags=-4097&e.flags|2,as=!1,ns=e)}}else{if(ls(e))throw Error(s(418));e.flags=-4097&e.flags|2,as=!1,ns=e}}}function cs(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;ns=e}function ds(e){if(e!==ns)return!1;if(!as)return cs(e),as=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!na(e.type,e.memoizedProps)),t&&(t=rs)){if(ls(e))throw hs(),Error(s(418));for(;t;)is(e,t),t=ua(t.nextSibling)}if(cs(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(s(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){rs=ua(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}rs=null}}else rs=ns?ua(e.stateNode.nextSibling):null;return!0}function hs(){for(var e=rs;e;)e=ua(e.nextSibling)}function ps(){rs=ns=null,as=!1}function fs(e){null===ss?ss=[e]:ss.push(e)}var ms=x.ReactCurrentBatchConfig;function gs(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(s(309));var r=n.stateNode}if(!r)throw Error(s(147,e));var a=r,i=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===i?t.ref:(t=function(e){var t=a.refs;null===e?delete t[i]:t[i]=e},t._stringRef=i,t)}if("string"!==typeof e)throw Error(s(284));if(!n._owner)throw Error(s(290,e))}return e}function ys(e,t){throw e=Object.prototype.toString.call(t),Error(s(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function bs(e){return(0,e._init)(e._payload)}function vs(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function a(e,t){return(e=Du(e,t)).index=0,e.sibling=null,e}function i(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=2,n):r:(t.flags|=2,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=2),t}function l(e,t,n,r){return null===t||6!==t.tag?((t=Pu(n,e.mode,r)).return=e,t):((t=a(t,n)).return=e,t)}function u(e,t,n,r){var s=n.type;return s===S?d(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===s||"object"===typeof s&&null!==s&&s.$$typeof===R&&bs(s)===t.type)?((r=a(t,n.props)).ref=gs(e,t,n),r.return=e,r):((r=Mu(n.type,n.key,n.props,null,e.mode,r)).ref=gs(e,t,n),r.return=e,r)}function c(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Lu(n,e.mode,r)).return=e,t):((t=a(t,n.children||[])).return=e,t)}function d(e,t,n,r,s){return null===t||7!==t.tag?((t=Fu(n,e.mode,r,s)).return=e,t):((t=a(t,n)).return=e,t)}function h(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=Pu(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Mu(t.type,t.key,t.props,null,e.mode,n)).ref=gs(e,null,t),n.return=e,n;case k:return(t=Lu(t,e.mode,n)).return=e,t;case R:return h(e,(0,t._init)(t._payload),n)}if(te(t)||F(t))return(t=Fu(t,e.mode,n,null)).return=e,t;ys(e,t)}return null}function p(e,t,n,r){var a=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==a?null:l(e,t,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===a?u(e,t,n,r):null;case k:return n.key===a?c(e,t,n,r):null;case R:return p(e,t,(a=n._init)(n._payload),r)}if(te(n)||F(n))return null!==a?null:d(e,t,n,r,null);ys(e,n)}return null}function f(e,t,n,r,a){if("string"===typeof r&&""!==r||"number"===typeof r)return l(t,e=e.get(n)||null,""+r,a);if("object"===typeof r&&null!==r){switch(r.$$typeof){case w:return u(t,e=e.get(null===r.key?n:r.key)||null,r,a);case k:return c(t,e=e.get(null===r.key?n:r.key)||null,r,a);case R:return f(e,t,n,(0,r._init)(r._payload),a)}if(te(r)||F(r))return d(t,e=e.get(n)||null,r,a,null);ys(t,r)}return null}function m(a,s,o,l){for(var u=null,c=null,d=s,m=s=0,g=null;null!==d&&m<o.length;m++){d.index>m?(g=d,d=null):g=d.sibling;var y=p(a,d,o[m],l);if(null===y){null===d&&(d=g);break}e&&d&&null===y.alternate&&t(a,d),s=i(y,s,m),null===c?u=y:c.sibling=y,c=y,d=g}if(m===o.length)return n(a,d),as&&Za(a,m),u;if(null===d){for(;m<o.length;m++)null!==(d=h(a,o[m],l))&&(s=i(d,s,m),null===c?u=d:c.sibling=d,c=d);return as&&Za(a,m),u}for(d=r(a,d);m<o.length;m++)null!==(g=f(d,a,m,o[m],l))&&(e&&null!==g.alternate&&d.delete(null===g.key?m:g.key),s=i(g,s,m),null===c?u=g:c.sibling=g,c=g);return e&&d.forEach((function(e){return t(a,e)})),as&&Za(a,m),u}function g(a,o,l,u){var c=F(l);if("function"!==typeof c)throw Error(s(150));if(null==(l=c.call(l)))throw Error(s(151));for(var d=c=null,m=o,g=o=0,y=null,b=l.next();null!==m&&!b.done;g++,b=l.next()){m.index>g?(y=m,m=null):y=m.sibling;var v=p(a,m,b.value,u);if(null===v){null===m&&(m=y);break}e&&m&&null===v.alternate&&t(a,m),o=i(v,o,g),null===d?c=v:d.sibling=v,d=v,m=y}if(b.done)return n(a,m),as&&Za(a,g),c;if(null===m){for(;!b.done;g++,b=l.next())null!==(b=h(a,b.value,u))&&(o=i(b,o,g),null===d?c=b:d.sibling=b,d=b);return as&&Za(a,g),c}for(m=r(a,m);!b.done;g++,b=l.next())null!==(b=f(m,a,g,b.value,u))&&(e&&null!==b.alternate&&m.delete(null===b.key?g:b.key),o=i(b,o,g),null===d?c=b:d.sibling=b,d=b);return e&&m.forEach((function(e){return t(a,e)})),as&&Za(a,g),c}return function e(r,s,i,l){if("object"===typeof i&&null!==i&&i.type===S&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case w:e:{for(var u=i.key,c=s;null!==c;){if(c.key===u){if((u=i.type)===S){if(7===c.tag){n(r,c.sibling),(s=a(c,i.props.children)).return=r,r=s;break e}}else if(c.elementType===u||"object"===typeof u&&null!==u&&u.$$typeof===R&&bs(u)===c.type){n(r,c.sibling),(s=a(c,i.props)).ref=gs(r,c,i),s.return=r,r=s;break e}n(r,c);break}t(r,c),c=c.sibling}i.type===S?((s=Fu(i.props.children,r.mode,l,i.key)).return=r,r=s):((l=Mu(i.type,i.key,i.props,null,r.mode,l)).ref=gs(r,s,i),l.return=r,r=l)}return o(r);case k:e:{for(c=i.key;null!==s;){if(s.key===c){if(4===s.tag&&s.stateNode.containerInfo===i.containerInfo&&s.stateNode.implementation===i.implementation){n(r,s.sibling),(s=a(s,i.children||[])).return=r,r=s;break e}n(r,s);break}t(r,s),s=s.sibling}(s=Lu(i,r.mode,l)).return=r,r=s}return o(r);case R:return e(r,s,(c=i._init)(i._payload),l)}if(te(i))return m(r,s,i,l);if(F(i))return g(r,s,i,l);ys(r,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==s&&6===s.tag?(n(r,s.sibling),(s=a(s,i)).return=r,r=s):(n(r,s),(s=Pu(i,r.mode,l)).return=r,r=s),o(r)):n(r,s)}}var xs=vs(!0),ws=vs(!1),ks=Ia(null),Ss=null,Is=null,Ts=null;function Ns(){Ts=Is=Ss=null}function Cs(e){var t=ks.current;Ta(ks),e._currentValue=t}function As(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Es(e,t){Ss=e,Ts=Is=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(vo=!0),e.firstContext=null)}function _s(e){var t=e._currentValue;if(Ts!==e)if(e={context:e,memoizedValue:t,next:null},null===Is){if(null===Ss)throw Error(s(308));Is=e,Ss.dependencies={lanes:0,firstContext:e}}else Is=Is.next=e;return t}var $s=null;function Rs(e){null===$s?$s=[e]:$s.push(e)}function Ds(e,t,n,r){var a=t.interleaved;return null===a?(n.next=n,Rs(t)):(n.next=a.next,a.next=n),t.interleaved=n,Ms(e,r)}function Ms(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Fs=!1;function Os(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Ps(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Ls(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function zs(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&Al)){var a=r.pending;return null===a?t.next=t:(t.next=a.next,a.next=t),r.pending=t,Ms(e,n)}return null===(a=r.interleaved)?(t.next=t,Rs(r)):(t.next=a.next,a.next=t),r.interleaved=t,Ms(e,n)}function Bs(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}function Vs(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var a=null,s=null;if(null!==(n=n.firstBaseUpdate)){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===s?a=s=i:s=s.next=i,n=n.next}while(null!==n);null===s?a=s=t:s=s.next=t}else a=s=t;return n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:s,shared:r.shared,effects:r.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Ws(e,t,n,r){var a=e.updateQueue;Fs=!1;var s=a.firstBaseUpdate,i=a.lastBaseUpdate,o=a.shared.pending;if(null!==o){a.shared.pending=null;var l=o,u=l.next;l.next=null,null===i?s=u:i.next=u,i=l;var c=e.alternate;null!==c&&((o=(c=c.updateQueue).lastBaseUpdate)!==i&&(null===o?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(null!==s){var d=a.baseState;for(i=0,c=u=l=null,o=s;;){var h=o.lane,p=o.eventTime;if((r&h)===h){null!==c&&(c=c.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(h=t,p=n,m.tag){case 1:if("function"===typeof(f=m.payload)){d=f.call(p,d,h);break e}d=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(h="function"===typeof(f=m.payload)?f.call(p,d,h):f)||void 0===h)break e;d=P({},d,h);break e;case 2:Fs=!0}}null!==o.callback&&0!==o.lane&&(e.flags|=64,null===(h=a.effects)?a.effects=[o]:h.push(o))}else p={eventTime:p,lane:h,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===c?(u=c=p,l=d):c=c.next=p,i|=h;if(null===(o=o.next)){if(null===(o=a.shared.pending))break;o=(h=o).next,h.next=null,a.lastBaseUpdate=h,a.shared.pending=null}}if(null===c&&(l=d),a.baseState=l,a.firstBaseUpdate=u,a.lastBaseUpdate=c,null!==(t=a.shared.interleaved)){a=t;do{i|=a.lane,a=a.next}while(a!==t)}else null===s&&(a.shared.lanes=0);Ol|=i,e.lanes=i,e.memoizedState=d}}function Us(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var r=e[t],a=r.callback;if(null!==a){if(r.callback=null,r=n,"function"!==typeof a)throw Error(s(191,a));a.call(r)}}}var js={},Gs=Ia(js),Hs=Ia(js),qs=Ia(js);function Ks(e){if(e===js)throw Error(s(174));return e}function Ys(e,t){switch(Na(qs,t),Na(Hs,e),Na(Gs,js),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:le(null,"");break;default:t=le(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Ta(Gs),Na(Gs,t)}function Xs(){Ta(Gs),Ta(Hs),Ta(qs)}function Qs(e){Ks(qs.current);var t=Ks(Gs.current),n=le(t,e.type);t!==n&&(Na(Hs,e),Na(Gs,n))}function Zs(e){Hs.current===e&&(Ta(Gs),Ta(Hs))}var Js=Ia(0);function ei(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ti=[];function ni(){for(var e=0;e<ti.length;e++)ti[e]._workInProgressVersionPrimary=null;ti.length=0}var ri=x.ReactCurrentDispatcher,ai=x.ReactCurrentBatchConfig,si=0,ii=null,oi=null,li=null,ui=!1,ci=!1,di=0,hi=0;function pi(){throw Error(s(321))}function fi(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!or(e[n],t[n]))return!1;return!0}function mi(e,t,n,r,a,i){if(si=i,ii=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,ri.current=null===e||null===e.memoizedState?Zi:Ji,e=n(r,a),ci){i=0;do{if(ci=!1,di=0,25<=i)throw Error(s(301));i+=1,li=oi=null,t.updateQueue=null,ri.current=eo,e=n(r,a)}while(ci)}if(ri.current=Qi,t=null!==oi&&null!==oi.next,si=0,li=oi=ii=null,ui=!1,t)throw Error(s(300));return e}function gi(){var e=0!==di;return di=0,e}function yi(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===li?ii.memoizedState=li=e:li=li.next=e,li}function bi(){if(null===oi){var e=ii.alternate;e=null!==e?e.memoizedState:null}else e=oi.next;var t=null===li?ii.memoizedState:li.next;if(null!==t)li=t,oi=e;else{if(null===e)throw Error(s(310));e={memoizedState:(oi=e).memoizedState,baseState:oi.baseState,baseQueue:oi.baseQueue,queue:oi.queue,next:null},null===li?ii.memoizedState=li=e:li=li.next=e}return li}function vi(e,t){return"function"===typeof t?t(e):t}function xi(e){var t=bi(),n=t.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=e;var r=oi,a=r.baseQueue,i=n.pending;if(null!==i){if(null!==a){var o=a.next;a.next=i.next,i.next=o}r.baseQueue=a=i,n.pending=null}if(null!==a){i=a.next,r=r.baseState;var l=o=null,u=null,c=i;do{var d=c.lane;if((si&d)===d)null!==u&&(u=u.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),r=c.hasEagerState?c.eagerState:e(r,c.action);else{var h={lane:d,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};null===u?(l=u=h,o=r):u=u.next=h,ii.lanes|=d,Ol|=d}c=c.next}while(null!==c&&c!==i);null===u?o=r:u.next=l,or(r,t.memoizedState)||(vo=!0),t.memoizedState=r,t.baseState=o,t.baseQueue=u,n.lastRenderedState=r}if(null!==(e=n.interleaved)){a=e;do{i=a.lane,ii.lanes|=i,Ol|=i,a=a.next}while(a!==e)}else null===a&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function wi(e){var t=bi(),n=t.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=e;var r=n.dispatch,a=n.pending,i=t.memoizedState;if(null!==a){n.pending=null;var o=a=a.next;do{i=e(i,o.action),o=o.next}while(o!==a);or(i,t.memoizedState)||(vo=!0),t.memoizedState=i,null===t.baseQueue&&(t.baseState=i),n.lastRenderedState=i}return[i,r]}function ki(){}function Si(e,t){var n=ii,r=bi(),a=t(),i=!or(r.memoizedState,a);if(i&&(r.memoizedState=a,vo=!0),r=r.queue,Fi(Ni.bind(null,n,r,e),[e]),r.getSnapshot!==t||i||null!==li&&1&li.memoizedState.tag){if(n.flags|=2048,_i(9,Ti.bind(null,n,r,a,t),void 0,null),null===El)throw Error(s(349));0!==(30&si)||Ii(n,t,a)}return a}function Ii(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ti(e,t,n,r){t.value=n,t.getSnapshot=r,Ci(t)&&Ai(e)}function Ni(e,t,n){return n((function(){Ci(t)&&Ai(e)}))}function Ci(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!or(e,n)}catch(r){return!0}}function Ai(e){var t=Ms(e,1);null!==t&&nu(t,e,1,-1)}function Ei(e){var t=yi();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:vi,lastRenderedState:e},t.queue=e,e=e.dispatch=qi.bind(null,ii,e),[t.memoizedState,e]}function _i(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function $i(){return bi().memoizedState}function Ri(e,t,n,r){var a=yi();ii.flags|=e,a.memoizedState=_i(1|t,n,void 0,void 0===r?null:r)}function Di(e,t,n,r){var a=bi();r=void 0===r?null:r;var s=void 0;if(null!==oi){var i=oi.memoizedState;if(s=i.destroy,null!==r&&fi(r,i.deps))return void(a.memoizedState=_i(t,n,s,r))}ii.flags|=e,a.memoizedState=_i(1|t,n,s,r)}function Mi(e,t){return Ri(8390656,8,e,t)}function Fi(e,t){return Di(2048,8,e,t)}function Oi(e,t){return Di(4,2,e,t)}function Pi(e,t){return Di(4,4,e,t)}function Li(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function zi(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Di(4,4,Li.bind(null,t,e),n)}function Bi(){}function Vi(e,t){var n=bi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fi(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Wi(e,t){var n=bi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fi(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Ui(e,t,n){return 0===(21&si)?(e.baseState&&(e.baseState=!1,vo=!0),e.memoizedState=n):(or(n,t)||(n=mt(),ii.lanes|=n,Ol|=n,e.baseState=!0),t)}function ji(e,t){var n=vt;vt=0!==n&&4>n?n:4,e(!0);var r=ai.transition;ai.transition={};try{e(!1),t()}finally{vt=n,ai.transition=r}}function Gi(){return bi().memoizedState}function Hi(e,t,n){var r=tu(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},Ki(e))Yi(t,n);else if(null!==(n=Ds(e,t,n,r))){nu(n,e,r,eu()),Xi(n,t,r)}}function qi(e,t,n){var r=tu(e),a={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ki(e))Yi(t,a);else{var s=e.alternate;if(0===e.lanes&&(null===s||0===s.lanes)&&null!==(s=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=s(i,n);if(a.hasEagerState=!0,a.eagerState=o,or(o,i)){var l=t.interleaved;return null===l?(a.next=a,Rs(t)):(a.next=l.next,l.next=a),void(t.interleaved=a)}}catch(u){}null!==(n=Ds(e,t,a,r))&&(nu(n,e,r,a=eu()),Xi(n,t,r))}}function Ki(e){var t=e.alternate;return e===ii||null!==t&&t===ii}function Yi(e,t){ci=ui=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Xi(e,t,n){if(0!==(4194240&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}var Qi={readContext:_s,useCallback:pi,useContext:pi,useEffect:pi,useImperativeHandle:pi,useInsertionEffect:pi,useLayoutEffect:pi,useMemo:pi,useReducer:pi,useRef:pi,useState:pi,useDebugValue:pi,useDeferredValue:pi,useTransition:pi,useMutableSource:pi,useSyncExternalStore:pi,useId:pi,unstable_isNewReconciler:!1},Zi={readContext:_s,useCallback:function(e,t){return yi().memoizedState=[e,void 0===t?null:t],e},useContext:_s,useEffect:Mi,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Ri(4194308,4,Li.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Ri(4194308,4,e,t)},useInsertionEffect:function(e,t){return Ri(4,2,e,t)},useMemo:function(e,t){var n=yi();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=yi();return t=void 0!==n?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=Hi.bind(null,ii,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},yi().memoizedState=e},useState:Ei,useDebugValue:Bi,useDeferredValue:function(e){return yi().memoizedState=e},useTransition:function(){var e=Ei(!1),t=e[0];return e=ji.bind(null,e[1]),yi().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=ii,a=yi();if(as){if(void 0===n)throw Error(s(407));n=n()}else{if(n=t(),null===El)throw Error(s(349));0!==(30&si)||Ii(r,t,n)}a.memoizedState=n;var i={value:n,getSnapshot:t};return a.queue=i,Mi(Ni.bind(null,r,i,e),[e]),r.flags|=2048,_i(9,Ti.bind(null,r,i,n,t),void 0,null),n},useId:function(){var e=yi(),t=El.identifierPrefix;if(as){var n=Qa;t=":"+t+"R"+(n=(Xa&~(1<<32-it(Xa)-1)).toString(32)+n),0<(n=di++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=hi++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},Ji={readContext:_s,useCallback:Vi,useContext:_s,useEffect:Fi,useImperativeHandle:zi,useInsertionEffect:Oi,useLayoutEffect:Pi,useMemo:Wi,useReducer:xi,useRef:$i,useState:function(){return xi(vi)},useDebugValue:Bi,useDeferredValue:function(e){return Ui(bi(),oi.memoizedState,e)},useTransition:function(){return[xi(vi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1},eo={readContext:_s,useCallback:Vi,useContext:_s,useEffect:Fi,useImperativeHandle:zi,useInsertionEffect:Oi,useLayoutEffect:Pi,useMemo:Wi,useReducer:wi,useRef:$i,useState:function(){return wi(vi)},useDebugValue:Bi,useDeferredValue:function(e){var t=bi();return null===oi?t.memoizedState=e:Ui(t,oi.memoizedState,e)},useTransition:function(){return[wi(vi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1};function to(e,t){if(e&&e.defaultProps){for(var n in t=P({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function no(e,t,n,r){n=null===(n=n(r,t=e.memoizedState))||void 0===n?t:P({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var ro={isMounted:function(e){return!!(e=e._reactInternals)&&We(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=eu(),a=tu(e),s=Ls(r,a);s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=zs(e,s,a))&&(nu(t,e,a,r),Bs(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=eu(),a=tu(e),s=Ls(r,a);s.tag=1,s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=zs(e,s,a))&&(nu(t,e,a,r),Bs(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=eu(),r=tu(e),a=Ls(n,r);a.tag=2,void 0!==t&&null!==t&&(a.callback=t),null!==(t=zs(e,a,r))&&(nu(t,e,r,n),Bs(t,e,r))}};function ao(e,t,n,r,a,s,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,s,i):!t.prototype||!t.prototype.isPureReactComponent||(!lr(n,r)||!lr(a,s))}function so(e,t,n){var r=!1,a=Ca,s=t.contextType;return"object"===typeof s&&null!==s?s=_s(s):(a=Ra(t)?_a:Aa.current,s=(r=null!==(r=t.contextTypes)&&void 0!==r)?$a(e,a):Ca),t=new t(n,s),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ro,e.stateNode=t,t._reactInternals=e,r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=s),t}function io(e,t,n,r){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&ro.enqueueReplaceState(t,t.state,null)}function oo(e,t,n,r){var a=e.stateNode;a.props=n,a.state=e.memoizedState,a.refs={},Os(e);var s=t.contextType;"object"===typeof s&&null!==s?a.context=_s(s):(s=Ra(t)?_a:Aa.current,a.context=$a(e,s)),a.state=e.memoizedState,"function"===typeof(s=t.getDerivedStateFromProps)&&(no(e,t,s,n),a.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof a.getSnapshotBeforeUpdate||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||(t=a.state,"function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),t!==a.state&&ro.enqueueReplaceState(a,a.state,null),Ws(e,n,a,r),a.state=e.memoizedState),"function"===typeof a.componentDidMount&&(e.flags|=4194308)}function lo(e,t){try{var n="",r=t;do{n+=V(r),r=r.return}while(r);var a=n}catch(s){a="\nError generating stack: "+s.message+"\n"+s.stack}return{value:e,source:t,stack:a,digest:null}}function uo(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function co(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}var ho="function"===typeof WeakMap?WeakMap:Map;function po(e,t,n){(n=Ls(-1,n)).tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){jl||(jl=!0,Gl=r),co(0,t)},n}function fo(e,t,n){(n=Ls(-1,n)).tag=3;var r=e.type.getDerivedStateFromError;if("function"===typeof r){var a=t.value;n.payload=function(){return r(a)},n.callback=function(){co(0,t)}}var s=e.stateNode;return null!==s&&"function"===typeof s.componentDidCatch&&(n.callback=function(){co(0,t),"function"!==typeof r&&(null===Hl?Hl=new Set([this]):Hl.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function mo(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new ho;var a=new Set;r.set(t,a)}else void 0===(a=r.get(t))&&(a=new Set,r.set(t,a));a.has(n)||(a.add(n),e=Tu.bind(null,e,t,n),t.then(e,e))}function go(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function yo(e,t,n,r,a){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Ls(-1,1)).tag=2,zs(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=a,e)}var bo=x.ReactCurrentOwner,vo=!1;function xo(e,t,n,r){t.child=null===e?ws(t,null,n,r):xs(t,e.child,n,r)}function wo(e,t,n,r,a){n=n.render;var s=t.ref;return Es(t,a),r=mi(e,t,n,r,s,a),n=gi(),null===e||vo?(as&&n&&es(t),t.flags|=1,xo(e,t,r,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,jo(e,t,a))}function ko(e,t,n,r,a){if(null===e){var s=n.type;return"function"!==typeof s||Ru(s)||void 0!==s.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Mu(n.type,null,r,t,t.mode,a)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=s,So(e,t,s,r,a))}if(s=e.child,0===(e.lanes&a)){var i=s.memoizedProps;if((n=null!==(n=n.compare)?n:lr)(i,r)&&e.ref===t.ref)return jo(e,t,a)}return t.flags|=1,(e=Du(s,r)).ref=t.ref,e.return=t,t.child=e}function So(e,t,n,r,a){if(null!==e){var s=e.memoizedProps;if(lr(s,r)&&e.ref===t.ref){if(vo=!1,t.pendingProps=r=s,0===(e.lanes&a))return t.lanes=e.lanes,jo(e,t,a);0!==(131072&e.flags)&&(vo=!0)}}return No(e,t,n,r,a)}function Io(e,t,n){var r=t.pendingProps,a=r.children,s=null!==e?e.memoizedState:null;if("hidden"===r.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Na(Dl,Rl),Rl|=n;else{if(0===(1073741824&n))return e=null!==s?s.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Na(Dl,Rl),Rl|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==s?s.baseLanes:n,Na(Dl,Rl),Rl|=r}else null!==s?(r=s.baseLanes|n,t.memoizedState=null):r=n,Na(Dl,Rl),Rl|=r;return xo(e,t,a,n),t.child}function To(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function No(e,t,n,r,a){var s=Ra(n)?_a:Aa.current;return s=$a(t,s),Es(t,a),n=mi(e,t,n,r,s,a),r=gi(),null===e||vo?(as&&r&&es(t),t.flags|=1,xo(e,t,n,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,jo(e,t,a))}function Co(e,t,n,r,a){if(Ra(n)){var s=!0;Oa(t)}else s=!1;if(Es(t,a),null===t.stateNode)Uo(e,t),so(t,n,r),oo(t,n,r,a),r=!0;else if(null===e){var i=t.stateNode,o=t.memoizedProps;i.props=o;var l=i.context,u=n.contextType;"object"===typeof u&&null!==u?u=_s(u):u=$a(t,u=Ra(n)?_a:Aa.current);var c=n.getDerivedStateFromProps,d="function"===typeof c||"function"===typeof i.getSnapshotBeforeUpdate;d||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==r||l!==u)&&io(t,i,r,u),Fs=!1;var h=t.memoizedState;i.state=h,Ws(t,r,i,a),l=t.memoizedState,o!==r||h!==l||Ea.current||Fs?("function"===typeof c&&(no(t,n,c,r),l=t.memoizedState),(o=Fs||ao(t,n,o,r,h,l,u))?(d||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(t.flags|=4194308)):("function"===typeof i.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),i.props=r,i.state=l,i.context=u,r=o):("function"===typeof i.componentDidMount&&(t.flags|=4194308),r=!1)}else{i=t.stateNode,Ps(e,t),o=t.memoizedProps,u=t.type===t.elementType?o:to(t.type,o),i.props=u,d=t.pendingProps,h=i.context,"object"===typeof(l=n.contextType)&&null!==l?l=_s(l):l=$a(t,l=Ra(n)?_a:Aa.current);var p=n.getDerivedStateFromProps;(c="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(o!==d||h!==l)&&io(t,i,r,l),Fs=!1,h=t.memoizedState,i.state=h,Ws(t,r,i,a);var f=t.memoizedState;o!==d||h!==f||Ea.current||Fs?("function"===typeof p&&(no(t,n,p,r),f=t.memoizedState),(u=Fs||ao(t,n,u,r,h,f,l)||!1)?(c||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(r,f,l),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(r,f,l)),"function"===typeof i.componentDidUpdate&&(t.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),i.props=r,i.state=f,i.context=l,r=u):("function"!==typeof i.componentDidUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),r=!1)}return Ao(e,t,n,r,s,a)}function Ao(e,t,n,r,a,s){To(e,t);var i=0!==(128&t.flags);if(!r&&!i)return a&&Pa(t,n,!1),jo(e,t,s);r=t.stateNode,bo.current=t;var o=i&&"function"!==typeof n.getDerivedStateFromError?null:r.render();return t.flags|=1,null!==e&&i?(t.child=xs(t,e.child,null,s),t.child=xs(t,null,o,s)):xo(e,t,o,s),t.memoizedState=r.state,a&&Pa(t,n,!0),t.child}function Eo(e){var t=e.stateNode;t.pendingContext?Ma(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Ma(0,t.context,!1),Ys(e,t.containerInfo)}function _o(e,t,n,r,a){return ps(),fs(a),t.flags|=256,xo(e,t,n,r),t.child}var $o,Ro,Do,Mo,Fo={dehydrated:null,treeContext:null,retryLane:0};function Oo(e){return{baseLanes:e,cachePool:null,transitions:null}}function Po(e,t,n){var r,a=t.pendingProps,i=Js.current,o=!1,l=0!==(128&t.flags);if((r=l)||(r=(null===e||null!==e.memoizedState)&&0!==(2&i)),r?(o=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(i|=1),Na(Js,1&i),null===e)return us(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(l=a.children,e=a.fallback,o?(a=t.mode,o=t.child,l={mode:"hidden",children:l},0===(1&a)&&null!==o?(o.childLanes=0,o.pendingProps=l):o=Ou(l,a,0,null),e=Fu(e,a,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=Oo(n),t.memoizedState=Fo,e):Lo(t,l));if(null!==(i=e.memoizedState)&&null!==(r=i.dehydrated))return function(e,t,n,r,a,i,o){if(n)return 256&t.flags?(t.flags&=-257,zo(e,t,o,r=uo(Error(s(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(i=r.fallback,a=t.mode,r=Ou({mode:"visible",children:r.children},a,0,null),(i=Fu(i,a,o,null)).flags|=2,r.return=t,i.return=t,r.sibling=i,t.child=r,0!==(1&t.mode)&&xs(t,e.child,null,o),t.child.memoizedState=Oo(o),t.memoizedState=Fo,i);if(0===(1&t.mode))return zo(e,t,o,null);if("$!"===a.data){if(r=a.nextSibling&&a.nextSibling.dataset)var l=r.dgst;return r=l,zo(e,t,o,r=uo(i=Error(s(419)),r,void 0))}if(l=0!==(o&e.childLanes),vo||l){if(null!==(r=El)){switch(o&-o){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}0!==(a=0!==(a&(r.suspendedLanes|o))?0:a)&&a!==i.retryLane&&(i.retryLane=a,Ms(e,a),nu(r,e,a,-1))}return mu(),zo(e,t,o,r=uo(Error(s(421))))}return"$?"===a.data?(t.flags|=128,t.child=e.child,t=Cu.bind(null,e),a._reactRetry=t,null):(e=i.treeContext,rs=ua(a.nextSibling),ns=t,as=!0,ss=null,null!==e&&(qa[Ka++]=Xa,qa[Ka++]=Qa,qa[Ka++]=Ya,Xa=e.id,Qa=e.overflow,Ya=t),t=Lo(t,r.children),t.flags|=4096,t)}(e,t,l,a,r,i,n);if(o){o=a.fallback,l=t.mode,r=(i=e.child).sibling;var u={mode:"hidden",children:a.children};return 0===(1&l)&&t.child!==i?((a=t.child).childLanes=0,a.pendingProps=u,t.deletions=null):(a=Du(i,u)).subtreeFlags=14680064&i.subtreeFlags,null!==r?o=Du(r,o):(o=Fu(o,l,n,null)).flags|=2,o.return=t,a.return=t,a.sibling=o,t.child=a,a=o,o=t.child,l=null===(l=e.child.memoizedState)?Oo(n):{baseLanes:l.baseLanes|n,cachePool:null,transitions:l.transitions},o.memoizedState=l,o.childLanes=e.childLanes&~n,t.memoizedState=Fo,a}return e=(o=e.child).sibling,a=Du(o,{mode:"visible",children:a.children}),0===(1&t.mode)&&(a.lanes=n),a.return=t,a.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=a,t.memoizedState=null,a}function Lo(e,t){return(t=Ou({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function zo(e,t,n,r){return null!==r&&fs(r),xs(t,e.child,null,n),(e=Lo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Bo(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),As(e.return,t,n)}function Vo(e,t,n,r,a){var s=e.memoizedState;null===s?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(s.isBackwards=t,s.rendering=null,s.renderingStartTime=0,s.last=r,s.tail=n,s.tailMode=a)}function Wo(e,t,n){var r=t.pendingProps,a=r.revealOrder,s=r.tail;if(xo(e,t,r.children,n),0!==(2&(r=Js.current)))r=1&r|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Bo(e,n,t);else if(19===e.tag)Bo(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Na(Js,r),0===(1&t.mode))t.memoizedState=null;else switch(a){case"forwards":for(n=t.child,a=null;null!==n;)null!==(e=n.alternate)&&null===ei(e)&&(a=n),n=n.sibling;null===(n=a)?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),Vo(t,!1,a,n,s);break;case"backwards":for(n=null,a=t.child,t.child=null;null!==a;){if(null!==(e=a.alternate)&&null===ei(e)){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}Vo(t,!0,n,null,s);break;case"together":Vo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Uo(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function jo(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Ol|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(s(153));if(null!==t.child){for(n=Du(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Du(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Go(e,t){if(!as)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Ho(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=14680064&a.subtreeFlags,r|=14680064&a.flags,a.return=e,a=a.sibling;else for(a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function qo(e,t,n){var r=t.pendingProps;switch(ts(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ho(t),null;case 1:case 17:return Ra(t.type)&&Da(),Ho(t),null;case 3:return r=t.stateNode,Xs(),Ta(Ea),Ta(Aa),ni(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==e&&null!==e.child||(ds(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==ss&&(iu(ss),ss=null))),Ro(e,t),Ho(t),null;case 5:Zs(t);var a=Ks(qs.current);if(n=t.type,null!==e&&null!=t.stateNode)Do(e,t,n,r,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(null===t.stateNode)throw Error(s(166));return Ho(t),null}if(e=Ks(Gs.current),ds(t)){r=t.stateNode,n=t.type;var i=t.memoizedProps;switch(r[ha]=t,r[pa]=i,e=0!==(1&t.mode),n){case"dialog":zr("cancel",r),zr("close",r);break;case"iframe":case"object":case"embed":zr("load",r);break;case"video":case"audio":for(a=0;a<Fr.length;a++)zr(Fr[a],r);break;case"source":zr("error",r);break;case"img":case"image":case"link":zr("error",r),zr("load",r);break;case"details":zr("toggle",r);break;case"input":X(r,i),zr("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!i.multiple},zr("invalid",r);break;case"textarea":ae(r,i),zr("invalid",r)}for(var l in be(n,i),a=null,i)if(i.hasOwnProperty(l)){var u=i[l];"children"===l?"string"===typeof u?r.textContent!==u&&(!0!==i.suppressHydrationWarning&&Zr(r.textContent,u,e),a=["children",u]):"number"===typeof u&&r.textContent!==""+u&&(!0!==i.suppressHydrationWarning&&Zr(r.textContent,u,e),a=["children",""+u]):o.hasOwnProperty(l)&&null!=u&&"onScroll"===l&&zr("scroll",r)}switch(n){case"input":H(r),J(r,i,!0);break;case"textarea":H(r),ie(r);break;case"select":case"option":break;default:"function"===typeof i.onClick&&(r.onclick=Jr)}r=a,t.updateQueue=r,null!==r&&(t.flags|=4)}else{l=9===a.nodeType?a:a.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=oe(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=l.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof r.is?e=l.createElement(n,{is:r.is}):(e=l.createElement(n),"select"===n&&(l=e,r.multiple?l.multiple=!0:r.size&&(l.size=r.size))):e=l.createElementNS(e,n),e[ha]=t,e[pa]=r,$o(e,t,!1,!1),t.stateNode=e;e:{switch(l=ve(n,r),n){case"dialog":zr("cancel",e),zr("close",e),a=r;break;case"iframe":case"object":case"embed":zr("load",e),a=r;break;case"video":case"audio":for(a=0;a<Fr.length;a++)zr(Fr[a],e);a=r;break;case"source":zr("error",e),a=r;break;case"img":case"image":case"link":zr("error",e),zr("load",e),a=r;break;case"details":zr("toggle",e),a=r;break;case"input":X(e,r),a=Y(e,r),zr("invalid",e);break;case"option":default:a=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},a=P({},r,{value:void 0}),zr("invalid",e);break;case"textarea":ae(e,r),a=re(e,r),zr("invalid",e)}for(i in be(n,a),u=a)if(u.hasOwnProperty(i)){var c=u[i];"style"===i?ge(e,c):"dangerouslySetInnerHTML"===i?null!=(c=c?c.__html:void 0)&&de(e,c):"children"===i?"string"===typeof c?("textarea"!==n||""!==c)&&he(e,c):"number"===typeof c&&he(e,""+c):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(o.hasOwnProperty(i)?null!=c&&"onScroll"===i&&zr("scroll",e):null!=c&&v(e,i,c,l))}switch(n){case"input":H(e),J(e,r,!1);break;case"textarea":H(e),ie(e);break;case"option":null!=r.value&&e.setAttribute("value",""+j(r.value));break;case"select":e.multiple=!!r.multiple,null!=(i=r.value)?ne(e,!!r.multiple,i,!1):null!=r.defaultValue&&ne(e,!!r.multiple,r.defaultValue,!0);break;default:"function"===typeof a.onClick&&(e.onclick=Jr)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Ho(t),null;case 6:if(e&&null!=t.stateNode)Mo(e,t,e.memoizedProps,r);else{if("string"!==typeof r&&null===t.stateNode)throw Error(s(166));if(n=Ks(qs.current),Ks(Gs.current),ds(t)){if(r=t.stateNode,n=t.memoizedProps,r[ha]=t,(i=r.nodeValue!==n)&&null!==(e=ns))switch(e.tag){case 3:Zr(r.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Zr(r.nodeValue,n,0!==(1&e.mode))}i&&(t.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[ha]=t,t.stateNode=r}return Ho(t),null;case 13:if(Ta(Js),r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(as&&null!==rs&&0!==(1&t.mode)&&0===(128&t.flags))hs(),ps(),t.flags|=98560,i=!1;else if(i=ds(t),null!==r&&null!==r.dehydrated){if(null===e){if(!i)throw Error(s(318));if(!(i=null!==(i=t.memoizedState)?i.dehydrated:null))throw Error(s(317));i[ha]=t}else ps(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Ho(t),i=!1}else null!==ss&&(iu(ss),ss=null),i=!0;if(!i)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((r=null!==r)!==(null!==e&&null!==e.memoizedState)&&r&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&Js.current)?0===Ml&&(Ml=3):mu())),null!==t.updateQueue&&(t.flags|=4),Ho(t),null);case 4:return Xs(),Ro(e,t),null===e&&Wr(t.stateNode.containerInfo),Ho(t),null;case 10:return Cs(t.type._context),Ho(t),null;case 19:if(Ta(Js),null===(i=t.memoizedState))return Ho(t),null;if(r=0!==(128&t.flags),null===(l=i.rendering))if(r)Go(i,!1);else{if(0!==Ml||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(l=ei(e))){for(t.flags|=128,Go(i,!1),null!==(r=l.updateQueue)&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;null!==n;)e=r,(i=n).flags&=14680066,null===(l=i.alternate)?(i.childLanes=0,i.lanes=e,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=l.childLanes,i.lanes=l.lanes,i.child=l.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=l.memoizedProps,i.memoizedState=l.memoizedState,i.updateQueue=l.updateQueue,i.type=l.type,e=l.dependencies,i.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Na(Js,1&Js.current|2),t.child}e=e.sibling}null!==i.tail&&Qe()>Wl&&(t.flags|=128,r=!0,Go(i,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=ei(l))){if(t.flags|=128,r=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Go(i,!0),null===i.tail&&"hidden"===i.tailMode&&!l.alternate&&!as)return Ho(t),null}else 2*Qe()-i.renderingStartTime>Wl&&1073741824!==n&&(t.flags|=128,r=!0,Go(i,!1),t.lanes=4194304);i.isBackwards?(l.sibling=t.child,t.child=l):(null!==(n=i.last)?n.sibling=l:t.child=l,i.last=l)}return null!==i.tail?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.renderingStartTime=Qe(),t.sibling=null,n=Js.current,Na(Js,r?1&n|2:1&n),t):(Ho(t),null);case 22:case 23:return du(),r=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==r&&(t.flags|=8192),r&&0!==(1&t.mode)?0!==(1073741824&Rl)&&(Ho(t),6&t.subtreeFlags&&(t.flags|=8192)):Ho(t),null;case 24:case 25:return null}throw Error(s(156,t.tag))}function Ko(e,t){switch(ts(t),t.tag){case 1:return Ra(t.type)&&Da(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Xs(),Ta(Ea),Ta(Aa),ni(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return Zs(t),null;case 13:if(Ta(Js),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(s(340));ps()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Ta(Js),null;case 4:return Xs(),null;case 10:return Cs(t.type._context),null;case 22:case 23:return du(),null;default:return null}}$o=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Ro=function(){},Do=function(e,t,n,r){var a=e.memoizedProps;if(a!==r){e=t.stateNode,Ks(Gs.current);var s,i=null;switch(n){case"input":a=Y(e,a),r=Y(e,r),i=[];break;case"select":a=P({},a,{value:void 0}),r=P({},r,{value:void 0}),i=[];break;case"textarea":a=re(e,a),r=re(e,r),i=[];break;default:"function"!==typeof a.onClick&&"function"===typeof r.onClick&&(e.onclick=Jr)}for(c in be(n,r),n=null,a)if(!r.hasOwnProperty(c)&&a.hasOwnProperty(c)&&null!=a[c])if("style"===c){var l=a[c];for(s in l)l.hasOwnProperty(s)&&(n||(n={}),n[s]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(o.hasOwnProperty(c)?i||(i=[]):(i=i||[]).push(c,null));for(c in r){var u=r[c];if(l=null!=a?a[c]:void 0,r.hasOwnProperty(c)&&u!==l&&(null!=u||null!=l))if("style"===c)if(l){for(s in l)!l.hasOwnProperty(s)||u&&u.hasOwnProperty(s)||(n||(n={}),n[s]="");for(s in u)u.hasOwnProperty(s)&&l[s]!==u[s]&&(n||(n={}),n[s]=u[s])}else n||(i||(i=[]),i.push(c,n)),n=u;else"dangerouslySetInnerHTML"===c?(u=u?u.__html:void 0,l=l?l.__html:void 0,null!=u&&l!==u&&(i=i||[]).push(c,u)):"children"===c?"string"!==typeof u&&"number"!==typeof u||(i=i||[]).push(c,""+u):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(o.hasOwnProperty(c)?(null!=u&&"onScroll"===c&&zr("scroll",e),i||l===u||(i=[])):(i=i||[]).push(c,u))}n&&(i=i||[]).push("style",n);var c=i;(t.updateQueue=c)&&(t.flags|=4)}},Mo=function(e,t,n,r){n!==r&&(t.flags|=4)};var Yo=!1,Xo=!1,Qo="function"===typeof WeakSet?WeakSet:Set,Zo=null;function Jo(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(r){Iu(e,t,r)}else n.current=null}function el(e,t,n){try{n()}catch(r){Iu(e,t,r)}}var tl=!1;function nl(e,t,n){var r=t.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var a=r=r.next;do{if((a.tag&e)===e){var s=a.destroy;a.destroy=void 0,void 0!==s&&el(t,n,s)}a=a.next}while(a!==r)}}function rl(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function al(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function sl(e){var t=e.alternate;null!==t&&(e.alternate=null,sl(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[ha],delete t[pa],delete t[ma],delete t[ga],delete t[ya])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function il(e){return 5===e.tag||3===e.tag||4===e.tag}function ol(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||il(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function ll(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Jr));else if(4!==r&&null!==(e=e.child))for(ll(e,t,n),e=e.sibling;null!==e;)ll(e,t,n),e=e.sibling}function ul(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&null!==(e=e.child))for(ul(e,t,n),e=e.sibling;null!==e;)ul(e,t,n),e=e.sibling}var cl=null,dl=!1;function hl(e,t,n){for(n=n.child;null!==n;)pl(e,t,n),n=n.sibling}function pl(e,t,n){if(st&&"function"===typeof st.onCommitFiberUnmount)try{st.onCommitFiberUnmount(at,n)}catch(o){}switch(n.tag){case 5:Xo||Jo(n,t);case 6:var r=cl,a=dl;cl=null,hl(e,t,n),dl=a,null!==(cl=r)&&(dl?(e=cl,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):cl.removeChild(n.stateNode));break;case 18:null!==cl&&(dl?(e=cl,n=n.stateNode,8===e.nodeType?la(e.parentNode,n):1===e.nodeType&&la(e,n),Wt(e)):la(cl,n.stateNode));break;case 4:r=cl,a=dl,cl=n.stateNode.containerInfo,dl=!0,hl(e,t,n),cl=r,dl=a;break;case 0:case 11:case 14:case 15:if(!Xo&&(null!==(r=n.updateQueue)&&null!==(r=r.lastEffect))){a=r=r.next;do{var s=a,i=s.destroy;s=s.tag,void 0!==i&&(0!==(2&s)||0!==(4&s))&&el(n,t,i),a=a.next}while(a!==r)}hl(e,t,n);break;case 1:if(!Xo&&(Jo(n,t),"function"===typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(o){Iu(n,t,o)}hl(e,t,n);break;case 21:hl(e,t,n);break;case 22:1&n.mode?(Xo=(r=Xo)||null!==n.memoizedState,hl(e,t,n),Xo=r):hl(e,t,n);break;default:hl(e,t,n)}}function fl(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Qo),t.forEach((function(t){var r=Au.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}}function ml(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var a=n[r];try{var i=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 5:cl=l.stateNode,dl=!1;break e;case 3:case 4:cl=l.stateNode.containerInfo,dl=!0;break e}l=l.return}if(null===cl)throw Error(s(160));pl(i,o,a),cl=null,dl=!1;var u=a.alternate;null!==u&&(u.return=null),a.return=null}catch(c){Iu(a,t,c)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)gl(t,e),t=t.sibling}function gl(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(ml(t,e),yl(e),4&r){try{nl(3,e,e.return),rl(3,e)}catch(g){Iu(e,e.return,g)}try{nl(5,e,e.return)}catch(g){Iu(e,e.return,g)}}break;case 1:ml(t,e),yl(e),512&r&&null!==n&&Jo(n,n.return);break;case 5:if(ml(t,e),yl(e),512&r&&null!==n&&Jo(n,n.return),32&e.flags){var a=e.stateNode;try{he(a,"")}catch(g){Iu(e,e.return,g)}}if(4&r&&null!=(a=e.stateNode)){var i=e.memoizedProps,o=null!==n?n.memoizedProps:i,l=e.type,u=e.updateQueue;if(e.updateQueue=null,null!==u)try{"input"===l&&"radio"===i.type&&null!=i.name&&Q(a,i),ve(l,o);var c=ve(l,i);for(o=0;o<u.length;o+=2){var d=u[o],h=u[o+1];"style"===d?ge(a,h):"dangerouslySetInnerHTML"===d?de(a,h):"children"===d?he(a,h):v(a,d,h,c)}switch(l){case"input":Z(a,i);break;case"textarea":se(a,i);break;case"select":var p=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!i.multiple;var f=i.value;null!=f?ne(a,!!i.multiple,f,!1):p!==!!i.multiple&&(null!=i.defaultValue?ne(a,!!i.multiple,i.defaultValue,!0):ne(a,!!i.multiple,i.multiple?[]:"",!1))}a[pa]=i}catch(g){Iu(e,e.return,g)}}break;case 6:if(ml(t,e),yl(e),4&r){if(null===e.stateNode)throw Error(s(162));a=e.stateNode,i=e.memoizedProps;try{a.nodeValue=i}catch(g){Iu(e,e.return,g)}}break;case 3:if(ml(t,e),yl(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Wt(t.containerInfo)}catch(g){Iu(e,e.return,g)}break;case 4:default:ml(t,e),yl(e);break;case 13:ml(t,e),yl(e),8192&(a=e.child).flags&&(i=null!==a.memoizedState,a.stateNode.isHidden=i,!i||null!==a.alternate&&null!==a.alternate.memoizedState||(Vl=Qe())),4&r&&fl(e);break;case 22:if(d=null!==n&&null!==n.memoizedState,1&e.mode?(Xo=(c=Xo)||d,ml(t,e),Xo=c):ml(t,e),yl(e),8192&r){if(c=null!==e.memoizedState,(e.stateNode.isHidden=c)&&!d&&0!==(1&e.mode))for(Zo=e,d=e.child;null!==d;){for(h=Zo=d;null!==Zo;){switch(f=(p=Zo).child,p.tag){case 0:case 11:case 14:case 15:nl(4,p,p.return);break;case 1:Jo(p,p.return);var m=p.stateNode;if("function"===typeof m.componentWillUnmount){r=p,n=p.return;try{t=r,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(g){Iu(r,n,g)}}break;case 5:Jo(p,p.return);break;case 22:if(null!==p.memoizedState){wl(h);continue}}null!==f?(f.return=p,Zo=f):wl(h)}d=d.sibling}e:for(d=null,h=e;;){if(5===h.tag){if(null===d){d=h;try{a=h.stateNode,c?"function"===typeof(i=a.style).setProperty?i.setProperty("display","none","important"):i.display="none":(l=h.stateNode,o=void 0!==(u=h.memoizedProps.style)&&null!==u&&u.hasOwnProperty("display")?u.display:null,l.style.display=me("display",o))}catch(g){Iu(e,e.return,g)}}}else if(6===h.tag){if(null===d)try{h.stateNode.nodeValue=c?"":h.memoizedProps}catch(g){Iu(e,e.return,g)}}else if((22!==h.tag&&23!==h.tag||null===h.memoizedState||h===e)&&null!==h.child){h.child.return=h,h=h.child;continue}if(h===e)break e;for(;null===h.sibling;){if(null===h.return||h.return===e)break e;d===h&&(d=null),h=h.return}d===h&&(d=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:ml(t,e),yl(e),4&r&&fl(e);case 21:}}function yl(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(il(n)){var r=n;break e}n=n.return}throw Error(s(160))}switch(r.tag){case 5:var a=r.stateNode;32&r.flags&&(he(a,""),r.flags&=-33),ul(e,ol(e),a);break;case 3:case 4:var i=r.stateNode.containerInfo;ll(e,ol(e),i);break;default:throw Error(s(161))}}catch(o){Iu(e,e.return,o)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function bl(e,t,n){Zo=e,vl(e,t,n)}function vl(e,t,n){for(var r=0!==(1&e.mode);null!==Zo;){var a=Zo,s=a.child;if(22===a.tag&&r){var i=null!==a.memoizedState||Yo;if(!i){var o=a.alternate,l=null!==o&&null!==o.memoizedState||Xo;o=Yo;var u=Xo;if(Yo=i,(Xo=l)&&!u)for(Zo=a;null!==Zo;)l=(i=Zo).child,22===i.tag&&null!==i.memoizedState?kl(a):null!==l?(l.return=i,Zo=l):kl(a);for(;null!==s;)Zo=s,vl(s,t,n),s=s.sibling;Zo=a,Yo=o,Xo=u}xl(e)}else 0!==(8772&a.subtreeFlags)&&null!==s?(s.return=a,Zo=s):xl(e)}}function xl(e){for(;null!==Zo;){var t=Zo;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Xo||rl(5,t);break;case 1:var r=t.stateNode;if(4&t.flags&&!Xo)if(null===n)r.componentDidMount();else{var a=t.elementType===t.type?n.memoizedProps:to(t.type,n.memoizedProps);r.componentDidUpdate(a,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var i=t.updateQueue;null!==i&&Us(t,i,r);break;case 3:var o=t.updateQueue;if(null!==o){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Us(t,o,n)}break;case 5:var l=t.stateNode;if(null===n&&4&t.flags){n=l;var u=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":u.autoFocus&&n.focus();break;case"img":u.src&&(n.src=u.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var c=t.alternate;if(null!==c){var d=c.memoizedState;if(null!==d){var h=d.dehydrated;null!==h&&Wt(h)}}}break;default:throw Error(s(163))}Xo||512&t.flags&&al(t)}catch(p){Iu(t,t.return,p)}}if(t===e){Zo=null;break}if(null!==(n=t.sibling)){n.return=t.return,Zo=n;break}Zo=t.return}}function wl(e){for(;null!==Zo;){var t=Zo;if(t===e){Zo=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Zo=n;break}Zo=t.return}}function kl(e){for(;null!==Zo;){var t=Zo;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{rl(4,t)}catch(l){Iu(t,n,l)}break;case 1:var r=t.stateNode;if("function"===typeof r.componentDidMount){var a=t.return;try{r.componentDidMount()}catch(l){Iu(t,a,l)}}var s=t.return;try{al(t)}catch(l){Iu(t,s,l)}break;case 5:var i=t.return;try{al(t)}catch(l){Iu(t,i,l)}}}catch(l){Iu(t,t.return,l)}if(t===e){Zo=null;break}var o=t.sibling;if(null!==o){o.return=t.return,Zo=o;break}Zo=t.return}}var Sl,Il=Math.ceil,Tl=x.ReactCurrentDispatcher,Nl=x.ReactCurrentOwner,Cl=x.ReactCurrentBatchConfig,Al=0,El=null,_l=null,$l=0,Rl=0,Dl=Ia(0),Ml=0,Fl=null,Ol=0,Pl=0,Ll=0,zl=null,Bl=null,Vl=0,Wl=1/0,Ul=null,jl=!1,Gl=null,Hl=null,ql=!1,Kl=null,Yl=0,Xl=0,Ql=null,Zl=-1,Jl=0;function eu(){return 0!==(6&Al)?Qe():-1!==Zl?Zl:Zl=Qe()}function tu(e){return 0===(1&e.mode)?1:0!==(2&Al)&&0!==$l?$l&-$l:null!==ms.transition?(0===Jl&&(Jl=mt()),Jl):0!==(e=vt)?e:e=void 0===(e=window.event)?16:Xt(e.type)}function nu(e,t,n,r){if(50<Xl)throw Xl=0,Ql=null,Error(s(185));yt(e,n,r),0!==(2&Al)&&e===El||(e===El&&(0===(2&Al)&&(Pl|=n),4===Ml&&ou(e,$l)),ru(e,r),1===n&&0===Al&&0===(1&t.mode)&&(Wl=Qe()+500,za&&Wa()))}function ru(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,a=e.expirationTimes,s=e.pendingLanes;0<s;){var i=31-it(s),o=1<<i,l=a[i];-1===l?0!==(o&n)&&0===(o&r)||(a[i]=pt(o,t)):l<=t&&(e.expiredLanes|=o),s&=~o}}(e,t);var r=ht(e,e===El?$l:0);if(0===r)null!==n&&Ke(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(null!=n&&Ke(n),1===t)0===e.tag?function(e){za=!0,Va(e)}(lu.bind(null,e)):Va(lu.bind(null,e)),ia((function(){0===(6&Al)&&Wa()})),n=null;else{switch(xt(r)){case 1:n=Je;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=rt}n=Eu(n,au.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function au(e,t){if(Zl=-1,Jl=0,0!==(6&Al))throw Error(s(327));var n=e.callbackNode;if(ku()&&e.callbackNode!==n)return null;var r=ht(e,e===El?$l:0);if(0===r)return null;if(0!==(30&r)||0!==(r&e.expiredLanes)||t)t=gu(e,r);else{t=r;var a=Al;Al|=2;var i=fu();for(El===e&&$l===t||(Ul=null,Wl=Qe()+500,hu(e,t));;)try{bu();break}catch(l){pu(e,l)}Ns(),Tl.current=i,Al=a,null!==_l?t=0:(El=null,$l=0,t=Ml)}if(0!==t){if(2===t&&(0!==(a=ft(e))&&(r=a,t=su(e,a))),1===t)throw n=Fl,hu(e,0),ou(e,r),ru(e,Qe()),n;if(6===t)ou(e,r);else{if(a=e.current.alternate,0===(30&r)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var a=n[r],s=a.getSnapshot;a=a.value;try{if(!or(s(),a))return!1}catch(o){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(a)&&(2===(t=gu(e,r))&&(0!==(i=ft(e))&&(r=i,t=su(e,i))),1===t))throw n=Fl,hu(e,0),ou(e,r),ru(e,Qe()),n;switch(e.finishedWork=a,e.finishedLanes=r,t){case 0:case 1:throw Error(s(345));case 2:case 5:wu(e,Bl,Ul);break;case 3:if(ou(e,r),(130023424&r)===r&&10<(t=Vl+500-Qe())){if(0!==ht(e,0))break;if(((a=e.suspendedLanes)&r)!==r){eu(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=ra(wu.bind(null,e,Bl,Ul),t);break}wu(e,Bl,Ul);break;case 4:if(ou(e,r),(4194240&r)===r)break;for(t=e.eventTimes,a=-1;0<r;){var o=31-it(r);i=1<<o,(o=t[o])>a&&(a=o),r&=~i}if(r=a,10<(r=(120>(r=Qe()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Il(r/1960))-r)){e.timeoutHandle=ra(wu.bind(null,e,Bl,Ul),r);break}wu(e,Bl,Ul);break;default:throw Error(s(329))}}}return ru(e,Qe()),e.callbackNode===n?au.bind(null,e):null}function su(e,t){var n=zl;return e.current.memoizedState.isDehydrated&&(hu(e,t).flags|=256),2!==(e=gu(e,t))&&(t=Bl,Bl=n,null!==t&&iu(t)),e}function iu(e){null===Bl?Bl=e:Bl.push.apply(Bl,e)}function ou(e,t){for(t&=~Ll,t&=~Pl,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-it(t),r=1<<n;e[n]=-1,t&=~r}}function lu(e){if(0!==(6&Al))throw Error(s(327));ku();var t=ht(e,0);if(0===(1&t))return ru(e,Qe()),null;var n=gu(e,t);if(0!==e.tag&&2===n){var r=ft(e);0!==r&&(t=r,n=su(e,r))}if(1===n)throw n=Fl,hu(e,0),ou(e,t),ru(e,Qe()),n;if(6===n)throw Error(s(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wu(e,Bl,Ul),ru(e,Qe()),null}function uu(e,t){var n=Al;Al|=1;try{return e(t)}finally{0===(Al=n)&&(Wl=Qe()+500,za&&Wa())}}function cu(e){null!==Kl&&0===Kl.tag&&0===(6&Al)&&ku();var t=Al;Al|=1;var n=Cl.transition,r=vt;try{if(Cl.transition=null,vt=1,e)return e()}finally{vt=r,Cl.transition=n,0===(6&(Al=t))&&Wa()}}function du(){Rl=Dl.current,Ta(Dl)}function hu(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,aa(n)),null!==_l)for(n=_l.return;null!==n;){var r=n;switch(ts(r),r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&Da();break;case 3:Xs(),Ta(Ea),Ta(Aa),ni();break;case 5:Zs(r);break;case 4:Xs();break;case 13:case 19:Ta(Js);break;case 10:Cs(r.type._context);break;case 22:case 23:du()}n=n.return}if(El=e,_l=e=Du(e.current,null),$l=Rl=t,Ml=0,Fl=null,Ll=Pl=Ol=0,Bl=zl=null,null!==$s){for(t=0;t<$s.length;t++)if(null!==(r=(n=$s[t]).interleaved)){n.interleaved=null;var a=r.next,s=n.pending;if(null!==s){var i=s.next;s.next=a,r.next=i}n.pending=r}$s=null}return e}function pu(e,t){for(;;){var n=_l;try{if(Ns(),ri.current=Qi,ui){for(var r=ii.memoizedState;null!==r;){var a=r.queue;null!==a&&(a.pending=null),r=r.next}ui=!1}if(si=0,li=oi=ii=null,ci=!1,di=0,Nl.current=null,null===n||null===n.return){Ml=1,Fl=t,_l=null;break}e:{var i=e,o=n.return,l=n,u=t;if(t=$l,l.flags|=32768,null!==u&&"object"===typeof u&&"function"===typeof u.then){var c=u,d=l,h=d.tag;if(0===(1&d.mode)&&(0===h||11===h||15===h)){var p=d.alternate;p?(d.updateQueue=p.updateQueue,d.memoizedState=p.memoizedState,d.lanes=p.lanes):(d.updateQueue=null,d.memoizedState=null)}var f=go(o);if(null!==f){f.flags&=-257,yo(f,o,l,0,t),1&f.mode&&mo(i,c,t),u=c;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(u),t.updateQueue=g}else m.add(u);break e}if(0===(1&t)){mo(i,c,t),mu();break e}u=Error(s(426))}else if(as&&1&l.mode){var y=go(o);if(null!==y){0===(65536&y.flags)&&(y.flags|=256),yo(y,o,l,0,t),fs(lo(u,l));break e}}i=u=lo(u,l),4!==Ml&&(Ml=2),null===zl?zl=[i]:zl.push(i),i=o;do{switch(i.tag){case 3:i.flags|=65536,t&=-t,i.lanes|=t,Vs(i,po(0,u,t));break e;case 1:l=u;var b=i.type,v=i.stateNode;if(0===(128&i.flags)&&("function"===typeof b.getDerivedStateFromError||null!==v&&"function"===typeof v.componentDidCatch&&(null===Hl||!Hl.has(v)))){i.flags|=65536,t&=-t,i.lanes|=t,Vs(i,fo(i,l,t));break e}}i=i.return}while(null!==i)}xu(n)}catch(x){t=x,_l===n&&null!==n&&(_l=n=n.return);continue}break}}function fu(){var e=Tl.current;return Tl.current=Qi,null===e?Qi:e}function mu(){0!==Ml&&3!==Ml&&2!==Ml||(Ml=4),null===El||0===(268435455&Ol)&&0===(268435455&Pl)||ou(El,$l)}function gu(e,t){var n=Al;Al|=2;var r=fu();for(El===e&&$l===t||(Ul=null,hu(e,t));;)try{yu();break}catch(a){pu(e,a)}if(Ns(),Al=n,Tl.current=r,null!==_l)throw Error(s(261));return El=null,$l=0,Ml}function yu(){for(;null!==_l;)vu(_l)}function bu(){for(;null!==_l&&!Ye();)vu(_l)}function vu(e){var t=Sl(e.alternate,e,Rl);e.memoizedProps=e.pendingProps,null===t?xu(e):_l=t,Nl.current=null}function xu(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=qo(n,t,Rl)))return void(_l=n)}else{if(null!==(n=Ko(n,t)))return n.flags&=32767,void(_l=n);if(null===e)return Ml=6,void(_l=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(_l=t);_l=t=e}while(null!==t);0===Ml&&(Ml=5)}function wu(e,t,n){var r=vt,a=Cl.transition;try{Cl.transition=null,vt=1,function(e,t,n,r){do{ku()}while(null!==Kl);if(0!==(6&Al))throw Error(s(327));n=e.finishedWork;var a=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(s(177));e.callbackNode=null,e.callbackPriority=0;var i=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var a=31-it(n),s=1<<a;t[a]=0,r[a]=-1,e[a]=-1,n&=~s}}(e,i),e===El&&(_l=El=null,$l=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||ql||(ql=!0,Eu(tt,(function(){return ku(),null}))),i=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||i){i=Cl.transition,Cl.transition=null;var o=vt;vt=1;var l=Al;Al|=4,Nl.current=null,function(e,t){if(ea=jt,pr(e=hr())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var a=r.anchorOffset,i=r.focusNode;r=r.focusOffset;try{n.nodeType,i.nodeType}catch(w){n=null;break e}var o=0,l=-1,u=-1,c=0,d=0,h=e,p=null;t:for(;;){for(var f;h!==n||0!==a&&3!==h.nodeType||(l=o+a),h!==i||0!==r&&3!==h.nodeType||(u=o+r),3===h.nodeType&&(o+=h.nodeValue.length),null!==(f=h.firstChild);)p=h,h=f;for(;;){if(h===e)break t;if(p===n&&++c===a&&(l=o),p===i&&++d===r&&(u=o),null!==(f=h.nextSibling))break;p=(h=p).parentNode}h=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(ta={focusedElem:e,selectionRange:n},jt=!1,Zo=t;null!==Zo;)if(e=(t=Zo).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Zo=e;else for(;null!==Zo;){t=Zo;try{var m=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,y=m.memoizedState,b=t.stateNode,v=b.getSnapshotBeforeUpdate(t.elementType===t.type?g:to(t.type,g),y);b.__reactInternalSnapshotBeforeUpdate=v}break;case 3:var x=t.stateNode.containerInfo;1===x.nodeType?x.textContent="":9===x.nodeType&&x.documentElement&&x.removeChild(x.documentElement);break;default:throw Error(s(163))}}catch(w){Iu(t,t.return,w)}if(null!==(e=t.sibling)){e.return=t.return,Zo=e;break}Zo=t.return}m=tl,tl=!1}(e,n),gl(n,e),fr(ta),jt=!!ea,ta=ea=null,e.current=n,bl(n,e,a),Xe(),Al=l,vt=o,Cl.transition=i}else e.current=n;if(ql&&(ql=!1,Kl=e,Yl=a),i=e.pendingLanes,0===i&&(Hl=null),function(e){if(st&&"function"===typeof st.onCommitFiberRoot)try{st.onCommitFiberRoot(at,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),ru(e,Qe()),null!==t)for(r=e.onRecoverableError,n=0;n<t.length;n++)a=t[n],r(a.value,{componentStack:a.stack,digest:a.digest});if(jl)throw jl=!1,e=Gl,Gl=null,e;0!==(1&Yl)&&0!==e.tag&&ku(),i=e.pendingLanes,0!==(1&i)?e===Ql?Xl++:(Xl=0,Ql=e):Xl=0,Wa()}(e,t,n,r)}finally{Cl.transition=a,vt=r}return null}function ku(){if(null!==Kl){var e=xt(Yl),t=Cl.transition,n=vt;try{if(Cl.transition=null,vt=16>e?16:e,null===Kl)var r=!1;else{if(e=Kl,Kl=null,Yl=0,0!==(6&Al))throw Error(s(331));var a=Al;for(Al|=4,Zo=e.current;null!==Zo;){var i=Zo,o=i.child;if(0!==(16&Zo.flags)){var l=i.deletions;if(null!==l){for(var u=0;u<l.length;u++){var c=l[u];for(Zo=c;null!==Zo;){var d=Zo;switch(d.tag){case 0:case 11:case 15:nl(8,d,i)}var h=d.child;if(null!==h)h.return=d,Zo=h;else for(;null!==Zo;){var p=(d=Zo).sibling,f=d.return;if(sl(d),d===c){Zo=null;break}if(null!==p){p.return=f,Zo=p;break}Zo=f}}}var m=i.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var y=g.sibling;g.sibling=null,g=y}while(null!==g)}}Zo=i}}if(0!==(2064&i.subtreeFlags)&&null!==o)o.return=i,Zo=o;else e:for(;null!==Zo;){if(0!==(2048&(i=Zo).flags))switch(i.tag){case 0:case 11:case 15:nl(9,i,i.return)}var b=i.sibling;if(null!==b){b.return=i.return,Zo=b;break e}Zo=i.return}}var v=e.current;for(Zo=v;null!==Zo;){var x=(o=Zo).child;if(0!==(2064&o.subtreeFlags)&&null!==x)x.return=o,Zo=x;else e:for(o=v;null!==Zo;){if(0!==(2048&(l=Zo).flags))try{switch(l.tag){case 0:case 11:case 15:rl(9,l)}}catch(k){Iu(l,l.return,k)}if(l===o){Zo=null;break e}var w=l.sibling;if(null!==w){w.return=l.return,Zo=w;break e}Zo=l.return}}if(Al=a,Wa(),st&&"function"===typeof st.onPostCommitFiberRoot)try{st.onPostCommitFiberRoot(at,e)}catch(k){}r=!0}return r}finally{vt=n,Cl.transition=t}}return!1}function Su(e,t,n){e=zs(e,t=po(0,t=lo(n,t),1),1),t=eu(),null!==e&&(yt(e,1,t),ru(e,t))}function Iu(e,t,n){if(3===e.tag)Su(e,e,n);else for(;null!==t;){if(3===t.tag){Su(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===Hl||!Hl.has(r))){t=zs(t,e=fo(t,e=lo(n,e),1),1),e=eu(),null!==t&&(yt(t,1,e),ru(t,e));break}}t=t.return}}function Tu(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),t=eu(),e.pingedLanes|=e.suspendedLanes&n,El===e&&($l&n)===n&&(4===Ml||3===Ml&&(130023424&$l)===$l&&500>Qe()-Vl?hu(e,0):Ll|=n),ru(e,t)}function Nu(e,t){0===t&&(0===(1&e.mode)?t=1:(t=ct,0===(130023424&(ct<<=1))&&(ct=4194304)));var n=eu();null!==(e=Ms(e,t))&&(yt(e,t,n),ru(e,n))}function Cu(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Nu(e,n)}function Au(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,a=e.memoizedState;null!==a&&(n=a.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(s(314))}null!==r&&r.delete(t),Nu(e,n)}function Eu(e,t){return qe(e,t)}function _u(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function $u(e,t,n,r){return new _u(e,t,n,r)}function Ru(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Du(e,t){var n=e.alternate;return null===n?((n=$u(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Mu(e,t,n,r,a,i){var o=2;if(r=e,"function"===typeof e)Ru(e)&&(o=1);else if("string"===typeof e)o=5;else e:switch(e){case S:return Fu(n.children,a,i,t);case I:o=8,a|=8;break;case T:return(e=$u(12,n,t,2|a)).elementType=T,e.lanes=i,e;case E:return(e=$u(13,n,t,a)).elementType=E,e.lanes=i,e;case _:return(e=$u(19,n,t,a)).elementType=_,e.lanes=i,e;case D:return Ou(n,a,i,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case N:o=10;break e;case C:o=9;break e;case A:o=11;break e;case $:o=14;break e;case R:o=16,r=null;break e}throw Error(s(130,null==e?e:typeof e,""))}return(t=$u(o,n,t,a)).elementType=e,t.type=r,t.lanes=i,t}function Fu(e,t,n,r){return(e=$u(7,e,r,t)).lanes=n,e}function Ou(e,t,n,r){return(e=$u(22,e,r,t)).elementType=D,e.lanes=n,e.stateNode={isHidden:!1},e}function Pu(e,t,n){return(e=$u(6,e,null,t)).lanes=n,e}function Lu(e,t,n){return(t=$u(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function zu(e,t,n,r,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=r,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Bu(e,t,n,r,a,s,i,o,l){return e=new zu(e,t,n,o,l),1===t?(t=1,!0===s&&(t|=8)):t=0,s=$u(3,null,null,t),e.current=s,s.stateNode=e,s.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Os(s),e}function Vu(e){if(!e)return Ca;e:{if(We(e=e._reactInternals)!==e||1!==e.tag)throw Error(s(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ra(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(s(171))}if(1===e.tag){var n=e.type;if(Ra(n))return Fa(e,n,t)}return t}function Wu(e,t,n,r,a,s,i,o,l){return(e=Bu(n,r,!0,e,0,s,0,o,l)).context=Vu(null),n=e.current,(s=Ls(r=eu(),a=tu(n))).callback=void 0!==t&&null!==t?t:null,zs(n,s,a),e.current.lanes=a,yt(e,a,r),ru(e,r),e}function Uu(e,t,n,r){var a=t.current,s=eu(),i=tu(a);return n=Vu(n),null===t.context?t.context=n:t.pendingContext=n,(t=Ls(s,i)).payload={element:e},null!==(r=void 0===r?null:r)&&(t.callback=r),null!==(e=zs(a,t,i))&&(nu(e,a,i,s),Bs(e,a,i)),i}function ju(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Gu(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Hu(e,t){Gu(e,t),(e=e.alternate)&&Gu(e,t)}Sl=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Ea.current)vo=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return vo=!1,function(e,t,n){switch(t.tag){case 3:Eo(t),ps();break;case 5:Qs(t);break;case 1:Ra(t.type)&&Oa(t);break;case 4:Ys(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,a=t.memoizedProps.value;Na(ks,r._currentValue),r._currentValue=a;break;case 13:if(null!==(r=t.memoizedState))return null!==r.dehydrated?(Na(Js,1&Js.current),t.flags|=128,null):0!==(n&t.child.childLanes)?Po(e,t,n):(Na(Js,1&Js.current),null!==(e=jo(e,t,n))?e.sibling:null);Na(Js,1&Js.current);break;case 19:if(r=0!==(n&t.childLanes),0!==(128&e.flags)){if(r)return Wo(e,t,n);t.flags|=128}if(null!==(a=t.memoizedState)&&(a.rendering=null,a.tail=null,a.lastEffect=null),Na(Js,Js.current),r)break;return null;case 22:case 23:return t.lanes=0,Io(e,t,n)}return jo(e,t,n)}(e,t,n);vo=0!==(131072&e.flags)}else vo=!1,as&&0!==(1048576&t.flags)&&Ja(t,Ha,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;Uo(e,t),e=t.pendingProps;var a=$a(t,Aa.current);Es(t,n),a=mi(null,t,r,e,a,n);var i=gi();return t.flags|=1,"object"===typeof a&&null!==a&&"function"===typeof a.render&&void 0===a.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ra(r)?(i=!0,Oa(t)):i=!1,t.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,Os(t),a.updater=ro,t.stateNode=a,a._reactInternals=t,oo(t,r,e,n),t=Ao(null,t,r,!0,i,n)):(t.tag=0,as&&i&&es(t),xo(null,t,a,n),t=t.child),t;case 16:r=t.elementType;e:{switch(Uo(e,t),e=t.pendingProps,r=(a=r._init)(r._payload),t.type=r,a=t.tag=function(e){if("function"===typeof e)return Ru(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===A)return 11;if(e===$)return 14}return 2}(r),e=to(r,e),a){case 0:t=No(null,t,r,e,n);break e;case 1:t=Co(null,t,r,e,n);break e;case 11:t=wo(null,t,r,e,n);break e;case 14:t=ko(null,t,r,to(r.type,e),n);break e}throw Error(s(306,r,""))}return t;case 0:return r=t.type,a=t.pendingProps,No(e,t,r,a=t.elementType===r?a:to(r,a),n);case 1:return r=t.type,a=t.pendingProps,Co(e,t,r,a=t.elementType===r?a:to(r,a),n);case 3:e:{if(Eo(t),null===e)throw Error(s(387));r=t.pendingProps,a=(i=t.memoizedState).element,Ps(e,t),Ws(t,r,null,n);var o=t.memoizedState;if(r=o.element,i.isDehydrated){if(i={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=i,t.memoizedState=i,256&t.flags){t=_o(e,t,r,n,a=lo(Error(s(423)),t));break e}if(r!==a){t=_o(e,t,r,n,a=lo(Error(s(424)),t));break e}for(rs=ua(t.stateNode.containerInfo.firstChild),ns=t,as=!0,ss=null,n=ws(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ps(),r===a){t=jo(e,t,n);break e}xo(e,t,r,n)}t=t.child}return t;case 5:return Qs(t),null===e&&us(t),r=t.type,a=t.pendingProps,i=null!==e?e.memoizedProps:null,o=a.children,na(r,a)?o=null:null!==i&&na(r,i)&&(t.flags|=32),To(e,t),xo(e,t,o,n),t.child;case 6:return null===e&&us(t),null;case 13:return Po(e,t,n);case 4:return Ys(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=xs(t,null,r,n):xo(e,t,r,n),t.child;case 11:return r=t.type,a=t.pendingProps,wo(e,t,r,a=t.elementType===r?a:to(r,a),n);case 7:return xo(e,t,t.pendingProps,n),t.child;case 8:case 12:return xo(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,a=t.pendingProps,i=t.memoizedProps,o=a.value,Na(ks,r._currentValue),r._currentValue=o,null!==i)if(or(i.value,o)){if(i.children===a.children&&!Ea.current){t=jo(e,t,n);break e}}else for(null!==(i=t.child)&&(i.return=t);null!==i;){var l=i.dependencies;if(null!==l){o=i.child;for(var u=l.firstContext;null!==u;){if(u.context===r){if(1===i.tag){(u=Ls(-1,n&-n)).tag=2;var c=i.updateQueue;if(null!==c){var d=(c=c.shared).pending;null===d?u.next=u:(u.next=d.next,d.next=u),c.pending=u}}i.lanes|=n,null!==(u=i.alternate)&&(u.lanes|=n),As(i.return,n,t),l.lanes|=n;break}u=u.next}}else if(10===i.tag)o=i.type===t.type?null:i.child;else if(18===i.tag){if(null===(o=i.return))throw Error(s(341));o.lanes|=n,null!==(l=o.alternate)&&(l.lanes|=n),As(o,n,t),o=i.sibling}else o=i.child;if(null!==o)o.return=i;else for(o=i;null!==o;){if(o===t){o=null;break}if(null!==(i=o.sibling)){i.return=o.return,o=i;break}o=o.return}i=o}xo(e,t,a.children,n),t=t.child}return t;case 9:return a=t.type,r=t.pendingProps.children,Es(t,n),r=r(a=_s(a)),t.flags|=1,xo(e,t,r,n),t.child;case 14:return a=to(r=t.type,t.pendingProps),ko(e,t,r,a=to(r.type,a),n);case 15:return So(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:to(r,a),Uo(e,t),t.tag=1,Ra(r)?(e=!0,Oa(t)):e=!1,Es(t,n),so(t,r,a),oo(t,r,a,n),Ao(null,t,r,!0,e,n);case 19:return Wo(e,t,n);case 22:return Io(e,t,n)}throw Error(s(156,t.tag))};var qu="function"===typeof reportError?reportError:function(e){console.error(e)};function Ku(e){this._internalRoot=e}function Yu(e){this._internalRoot=e}function Xu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Qu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Zu(){}function Ju(e,t,n,r,a){var s=n._reactRootContainer;if(s){var i=s;if("function"===typeof a){var o=a;a=function(){var e=ju(i);o.call(e)}}Uu(t,i,e,a)}else i=function(e,t,n,r,a){if(a){if("function"===typeof r){var s=r;r=function(){var e=ju(i);s.call(e)}}var i=Wu(t,r,e,0,null,!1,0,"",Zu);return e._reactRootContainer=i,e[fa]=i.current,Wr(8===e.nodeType?e.parentNode:e),cu(),i}for(;a=e.lastChild;)e.removeChild(a);if("function"===typeof r){var o=r;r=function(){var e=ju(l);o.call(e)}}var l=Bu(e,0,!1,null,0,!1,0,"",Zu);return e._reactRootContainer=l,e[fa]=l.current,Wr(8===e.nodeType?e.parentNode:e),cu((function(){Uu(t,l,n,r)})),l}(n,t,e,a,r);return ju(i)}Yu.prototype.render=Ku.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(s(409));Uu(e,t,null,null)},Yu.prototype.unmount=Ku.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;cu((function(){Uu(null,e,null,null)})),t[fa]=null}},Yu.prototype.unstable_scheduleHydration=function(e){if(e){var t=It();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Dt.length&&0!==t&&t<Dt[n].priority;n++);Dt.splice(n,0,e),0===n&&Pt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=dt(t.pendingLanes);0!==n&&(bt(t,1|n),ru(t,Qe()),0===(6&Al)&&(Wl=Qe()+500,Wa()))}break;case 13:cu((function(){var t=Ms(e,1);if(null!==t){var n=eu();nu(t,e,1,n)}})),Hu(e,1)}},kt=function(e){if(13===e.tag){var t=Ms(e,134217728);if(null!==t)nu(t,e,134217728,eu());Hu(e,134217728)}},St=function(e){if(13===e.tag){var t=tu(e),n=Ms(e,t);if(null!==n)nu(n,e,t,eu());Hu(e,t)}},It=function(){return vt},Tt=function(e,t){var n=vt;try{return vt=e,t()}finally{vt=n}},ke=function(e,t,n){switch(t){case"input":if(Z(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var a=wa(r);if(!a)throw Error(s(90));q(r),Z(r,a)}}}break;case"textarea":se(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ae=uu,Ee=cu;var ec={usingClientEntryPoint:!1,Events:[va,xa,wa,Ne,Ce,uu]},tc={findFiberByHostInstance:ba,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},nc={bundleType:tc.bundleType,version:tc.version,rendererPackageName:tc.rendererPackageName,rendererConfig:tc.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:x.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Ge(e))?null:e.stateNode},findFiberByHostInstance:tc.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var rc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rc.isDisabled&&rc.supportsFiber)try{at=rc.inject(nc),st=rc}catch(ce){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ec,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Xu(t))throw Error(s(200));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Xu(e))throw Error(s(299));var n=!1,r="",a=qu;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onRecoverableError&&(a=t.onRecoverableError)),t=Bu(e,1,!1,null,0,n,0,r,a),e[fa]=t.current,Wr(8===e.nodeType?e.parentNode:e),new Ku(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(s(188));throw e=Object.keys(e).join(","),Error(s(268,e))}return e=null===(e=Ge(t))?null:e.stateNode},t.flushSync=function(e){return cu(e)},t.hydrate=function(e,t,n){if(!Qu(t))throw Error(s(200));return Ju(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Xu(e))throw Error(s(405));var r=null!=n&&n.hydratedSources||null,a=!1,i="",o=qu;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(a=!0),void 0!==n.identifierPrefix&&(i=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),t=Wu(t,null,e,1,null!=n?n:null,a,0,i,o),e[fa]=t.current,Wr(e),r)for(e=0;e<r.length;e++)a=(a=(n=r[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,a]:t.mutableSourceEagerHydrationData.push(n,a);return new Yu(t)},t.render=function(e,t,n){if(!Qu(t))throw Error(s(200));return Ju(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Qu(e))throw Error(s(40));return!!e._reactRootContainer&&(cu((function(){Ju(null,null,e,!1,(function(){e._reactRootContainer=null,e[fa]=null}))})),!0)},t.unstable_batchedUpdates=uu,t.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Qu(n))throw Error(s(200));if(null==e||void 0===e._reactInternals)throw Error(s(38));return Ju(e,t,n,!1,r)},t.version="18.3.1-next-f1338f8080-20240426"},7950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(2730)},5082:(e,t)=>{"use strict";var n,r=Symbol.for("react.element"),a=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),i=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),l=Symbol.for("react.provider"),u=Symbol.for("react.context"),c=Symbol.for("react.server_context"),d=Symbol.for("react.forward_ref"),h=Symbol.for("react.suspense"),p=Symbol.for("react.suspense_list"),f=Symbol.for("react.memo"),m=Symbol.for("react.lazy"),g=Symbol.for("react.offscreen");function y(e){if("object"===typeof e&&null!==e){var t=e.$$typeof;switch(t){case r:switch(e=e.type){case s:case o:case i:case h:case p:return e;default:switch(e=e&&e.$$typeof){case c:case u:case d:case m:case f:case l:return e;default:return t}}case a:return t}}}n=Symbol.for("react.module.reference")},2086:(e,t,n)=>{"use strict";n(5082)},7029:function(e,t,n){var r;r=function(e){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(r,a,function(t){return e[t]}.bind(null,a));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(e,t,n){"use strict";n.r(t);var r=n("react"),a=function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function r(){this.constructor=t}e(t,n),t.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}(),s=function(){return s=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var a in t=arguments[n])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e},s.apply(this,arguments)},i=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};function o(){return!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)}"undefined"!==typeof window&&(void 0===navigator.mediaDevices&&(navigator.mediaDevices={}),void 0===navigator.mediaDevices.getUserMedia&&(navigator.mediaDevices.getUserMedia=function(e){var t=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return t?new Promise((function(n,r){t.call(navigator,e,n,r)})):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}));var l=function(e){function t(t){var n=e.call(this,t)||this;return n.canvas=null,n.ctx=null,n.requestUserMediaId=0,n.unmounted=!1,n.state={hasUserMedia:!1},n}return a(t,e),t.prototype.componentDidMount=function(){var e=this.state,t=this.props;this.unmounted=!1,o()?(e.hasUserMedia||this.requestUserMedia(),t.children&&"function"!=typeof t.children&&console.warn("children must be a function")):t.onUserMediaError("getUserMedia not supported")},t.prototype.componentDidUpdate=function(e){var t=this.props;if(o()){var n=JSON.stringify(e.audioConstraints)!==JSON.stringify(t.audioConstraints),r=JSON.stringify(e.videoConstraints)!==JSON.stringify(t.videoConstraints),a=e.minScreenshotWidth!==t.minScreenshotWidth,s=e.minScreenshotHeight!==t.minScreenshotHeight;(r||a||s)&&(this.canvas=null,this.ctx=null),(n||r)&&(this.stopAndCleanup(),this.requestUserMedia())}else t.onUserMediaError("getUserMedia not supported")},t.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},t.stopMediaStream=function(e){e&&(e.getVideoTracks&&e.getAudioTracks?(e.getVideoTracks().map((function(t){e.removeTrack(t),t.stop()})),e.getAudioTracks().map((function(t){e.removeTrack(t),t.stop()}))):e.stop())},t.prototype.stopAndCleanup=function(){var e=this.state;e.hasUserMedia&&(t.stopMediaStream(this.stream),e.src&&window.URL.revokeObjectURL(e.src))},t.prototype.getScreenshot=function(e){var t=this.state,n=this.props;if(!t.hasUserMedia)return null;var r=this.getCanvas(e);return r&&r.toDataURL(n.screenshotFormat,n.screenshotQuality)},t.prototype.getCanvas=function(e){var t=this.state,n=this.props;if(!this.video)return null;if(!t.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var r=this.video.videoWidth,a=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var s=r/a;a=(r=n.minScreenshotWidth||this.video.clientWidth)/s,n.minScreenshotHeight&&a<n.minScreenshotHeight&&(r=(a=n.minScreenshotHeight)*s)}this.canvas=document.createElement("canvas"),this.canvas.width=(null===e||void 0===e?void 0:e.width)||r,this.canvas.height=(null===e||void 0===e?void 0:e.height)||a,this.ctx=this.canvas.getContext("2d")}var i=this.ctx,o=this.canvas;return i&&o&&(o.width=(null===e||void 0===e?void 0:e.width)||o.width,o.height=(null===e||void 0===e?void 0:e.height)||o.height,n.mirrored&&(i.translate(o.width,0),i.scale(-1,1)),i.imageSmoothingEnabled=n.imageSmoothing,i.drawImage(this.video,0,0,(null===e||void 0===e?void 0:e.width)||o.width,(null===e||void 0===e?void 0:e.height)||o.height),n.mirrored&&(i.scale(-1,1),i.translate(-o.width,0))),o},t.prototype.requestUserMedia=function(){var e=this,n=this.props,r=function(r,a){var s={video:"undefined"===typeof a||a};n.audio&&(s.audio="undefined"===typeof r||r),e.requestUserMediaId++;var i=e.requestUserMediaId;navigator.mediaDevices.getUserMedia(s).then((function(n){e.unmounted||i!==e.requestUserMediaId?t.stopMediaStream(n):e.handleUserMedia(null,n)})).catch((function(t){e.handleUserMedia(t)}))};if("mediaDevices"in navigator)r(n.audioConstraints,n.videoConstraints);else{var a=function(e){return{optional:[{sourceId:e}]}},s=function(e){var t=e.deviceId;return"string"===typeof t?t:Array.isArray(t)&&t.length>0?t[0]:"object"===typeof t&&t.ideal?t.ideal:null};MediaStreamTrack.getSources((function(e){var t=null,i=null;e.forEach((function(e){"audio"===e.kind?t=e.id:"video"===e.kind&&(i=e.id)}));var o=s(n.audioConstraints);o&&(t=o);var l=s(n.videoConstraints);l&&(i=l),r(a(t),a(i))}))}},t.prototype.handleUserMedia=function(e,t){var n=this.props;if(e||!t)return this.setState({hasUserMedia:!1}),void n.onUserMediaError(e);this.stream=t;try{this.video&&(this.video.srcObject=t),this.setState({hasUserMedia:!0})}catch(r){this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(t)})}n.onUserMedia(t)},t.prototype.render=function(){var e=this,t=this.state,n=this.props,a=n.audio,o=(n.forceScreenshotSourceSize,n.disablePictureInPicture),l=(n.onUserMedia,n.onUserMediaError,n.screenshotFormat,n.screenshotQuality,n.minScreenshotWidth,n.minScreenshotHeight,n.audioConstraints,n.videoConstraints,n.imageSmoothing,n.mirrored),u=n.style,c=void 0===u?{}:u,d=n.children,h=i(n,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),p=l?s(s({},c),{transform:(c.transform||"")+" scaleX(-1)"}):c,f={getScreenshot:this.getScreenshot.bind(this)};return r.createElement(r.Fragment,null,r.createElement("video",s({autoPlay:!0,disablePictureInPicture:o,src:t.src,muted:!a,playsInline:!0,ref:function(t){e.video=t},style:p},h)),d&&d(f))},t.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},t}(r.Component);t.default=l},react:function(t,n){t.exports=e}}).default},e.exports=r(n(5043))},1153:(e,t,n)=>{"use strict";var r=n(5043),a=Symbol.for("react.element"),s=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,o=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function u(e,t,n){var r,s={},u=null,c=null;for(r in void 0!==n&&(u=""+n),void 0!==t.key&&(u=""+t.key),void 0!==t.ref&&(c=t.ref),t)i.call(t,r)&&!l.hasOwnProperty(r)&&(s[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps)void 0===s[r]&&(s[r]=t[r]);return{$$typeof:a,type:e,key:u,ref:c,props:s,_owner:o.current}}t.Fragment=s,t.jsx=u,t.jsxs=u},4202:(e,t)=>{"use strict";var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function v(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var x=v.prototype=new b;x.constructor=v,m(x,y.prototype),x.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},I={key:!0,ref:!0,__self:!0,__source:!0};function T(e,t,r){var a,s={},i=null,o=null;if(null!=t)for(a in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(i=""+t.key),t)k.call(t,a)&&!I.hasOwnProperty(a)&&(s[a]=t[a]);var l=arguments.length-2;if(1===l)s.children=r;else if(1<l){for(var u=Array(l),c=0;c<l;c++)u[c]=arguments[c+2];s.children=u}if(e&&e.defaultProps)for(a in l=e.defaultProps)void 0===s[a]&&(s[a]=l[a]);return{$$typeof:n,type:e,key:i,ref:o,props:s,_owner:S.current}}function N(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var C=/\/+/g;function A(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function E(e,t,a,s,i){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var l=!1;if(null===e)l=!0;else switch(o){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case n:case r:l=!0}}if(l)return i=i(l=e),e=""===s?"."+A(l,0):s,w(i)?(a="",null!=e&&(a=e.replace(C,"$&/")+"/"),E(i,t,a,"",(function(e){return e}))):null!=i&&(N(i)&&(i=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,a+(!i.key||l&&l.key===i.key?"":(""+i.key).replace(C,"$&/")+"/")+e)),t.push(i)),1;if(l=0,s=""===s?".":s+":",w(e))for(var u=0;u<e.length;u++){var c=s+A(o=e[u],u);l+=E(o,t,a,c,i)}else if(c=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"===typeof c)for(e=c.call(e),u=0;!(o=e.next()).done;)l+=E(o=o.value,t,a,c=s+A(o,u++),i);else if("object"===o)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return l}function _(e,t,n){if(null==e)return e;var r=[],a=0;return E(e,r,"","",(function(e){return t.call(n,e,a++)})),r}function $(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var R={current:null},D={transition:null},M={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:D,ReactCurrentOwner:S};function F(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:_,forEach:function(e,t,n){_(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return _(e,(function(){t++})),t},toArray:function(e){return _(e,(function(e){return e}))||[]},only:function(e){if(!N(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=a,t.Profiler=i,t.PureComponent=v,t.StrictMode=s,t.Suspense=c,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=M,t.act=F,t.cloneElement=function(e,t,r){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var a=m({},e.props),s=e.key,i=e.ref,o=e._owner;if(null!=t){if(void 0!==t.ref&&(i=t.ref,o=S.current),void 0!==t.key&&(s=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(u in t)k.call(t,u)&&!I.hasOwnProperty(u)&&(a[u]=void 0===t[u]&&void 0!==l?l[u]:t[u])}var u=arguments.length-2;if(1===u)a.children=r;else if(1<u){l=Array(u);for(var c=0;c<u;c++)l[c]=arguments[c+2];a.children=l}return{$$typeof:n,type:e.type,key:s,ref:i,props:a,_owner:o}},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=T,t.createFactory=function(e){var t=T.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=N,t.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:$}},t.memo=function(e,t){return{$$typeof:d,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=D.transition;D.transition={};try{e()}finally{D.transition=t}},t.unstable_act=F,t.useCallback=function(e,t){return R.current.useCallback(e,t)},t.useContext=function(e){return R.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return R.current.useDeferredValue(e)},t.useEffect=function(e,t){return R.current.useEffect(e,t)},t.useId=function(){return R.current.useId()},t.useImperativeHandle=function(e,t,n){return R.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return R.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return R.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return R.current.useMemo(e,t)},t.useReducer=function(e,t,n){return R.current.useReducer(e,t,n)},t.useRef=function(e){return R.current.useRef(e)},t.useState=function(e){return R.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return R.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return R.current.useTransition()},t.version="18.3.1"},5043:(e,t,n)=>{"use strict";e.exports=n(4202)},579:(e,t,n)=>{"use strict";e.exports=n(1153)},7234:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,a=e[r];if(!(0<s(a,t)))break e;e[r]=t,e[n]=a,n=r}}function r(e){return 0===e.length?null:e[0]}function a(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,a=e.length,i=a>>>1;r<i;){var o=2*(r+1)-1,l=e[o],u=o+1,c=e[u];if(0>s(l,n))u<a&&0>s(c,l)?(e[r]=c,e[u]=n,r=u):(e[r]=l,e[o]=n,r=o);else{if(!(u<a&&0>s(c,n)))break e;e[r]=c,e[u]=n,r=u}}}return t}function s(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],c=[],d=1,h=null,p=3,f=!1,m=!1,g=!1,y="function"===typeof setTimeout?setTimeout:null,b="function"===typeof clearTimeout?clearTimeout:null,v="undefined"!==typeof setImmediate?setImmediate:null;function x(e){for(var t=r(c);null!==t;){if(null===t.callback)a(c);else{if(!(t.startTime<=e))break;a(c),t.sortIndex=t.expirationTime,n(u,t)}t=r(c)}}function w(e){if(g=!1,x(e),!m)if(null!==r(u))m=!0,D(k);else{var t=r(c);null!==t&&M(w,t.startTime-e)}}function k(e,n){m=!1,g&&(g=!1,b(N),N=-1),f=!0;var s=p;try{for(x(n),h=r(u);null!==h&&(!(h.expirationTime>n)||e&&!E());){var i=h.callback;if("function"===typeof i){h.callback=null,p=h.priorityLevel;var o=i(h.expirationTime<=n);n=t.unstable_now(),"function"===typeof o?h.callback=o:h===r(u)&&a(u),x(n)}else a(u);h=r(u)}if(null!==h)var l=!0;else{var d=r(c);null!==d&&M(w,d.startTime-n),l=!1}return l}finally{h=null,p=s,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,I=!1,T=null,N=-1,C=5,A=-1;function E(){return!(t.unstable_now()-A<C)}function _(){if(null!==T){var e=t.unstable_now();A=e;var n=!0;try{n=T(!0,e)}finally{n?S():(I=!1,T=null)}}else I=!1}if("function"===typeof v)S=function(){v(_)};else if("undefined"!==typeof MessageChannel){var $=new MessageChannel,R=$.port2;$.port1.onmessage=_,S=function(){R.postMessage(null)}}else S=function(){y(_,0)};function D(e){T=e,I||(I=!0,S())}function M(e,n){N=y((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,D(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):C=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return r(u)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,a,s){var i=t.unstable_now();switch("object"===typeof s&&null!==s?s="number"===typeof(s=s.delay)&&0<s?i+s:i:s=i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:d++,callback:a,priorityLevel:e,startTime:s,expirationTime:o=s+o,sortIndex:-1},s>i?(e.sortIndex=s,n(c,e),null===r(u)&&e===r(c)&&(g?(b(N),N=-1):g=!0,M(w,s-i))):(e.sortIndex=o,n(u,e),m||f||(m=!0,D(k))),e},t.unstable_shouldYield=E,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},8853:(e,t,n)=>{"use strict";e.exports=n(7234)},4334:(e,t,n)=>{var r=n(7359),a=n(7066),s=n(9016),i=n(9538),o=n(6288),l=n(5262),u=n(2430);u.alea=r,u.xor128=a,u.xorwow=s,u.xorshift7=i,u.xor4096=o,u.tychei=l,e.exports=u},7359:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new s(e),r=t&&t.state,a=n.next;return a.int32=function(){return 4294967296*n.next()|0},a.double=function(){return a()+11102230246251565e-32*(2097152*a()|0)},a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.alea=o}(0,e=n.nmd(e),n.amdD)},5262:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.tychei=o}(0,e=n.nmd(e),n.amdD)},7066:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xor128=o}(0,e=n.nmd(e),n.amdD)},6288:function(e,t,n){var r;!function(e,a){function s(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,a=0==(n=o[127&s]^=r+i)?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.X&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},9538:function(e,t,n){var r;!function(e,a){function s(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&(r.x&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},9016:function(e,t,n){var r;!function(e,a){function s(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new s(e),r=t&&t.state,a=function(){return(n.next()>>>0)/4294967296};return a.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},a.int32=n.next,a.quick=a,r&&("object"==typeof r&&i(r,n),a.state=function(){return i(n,{})}),a}a&&a.exports?a.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,a))||(a.exports=r):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},2430:function(e,t,n){var r;!function(a,s,i){var o,l=256,u=i.pow(l,6),c=i.pow(2,52),d=2*c,h=l-1;function p(e,t,n){var r=[],h=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(s)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(l):(e=new Uint8Array(l),(a.crypto||a.msCrypto).getRandomValues(e)),b(e)}catch(r){var t=a.navigator,n=t&&t.plugins;return[+new Date,a,n,a.screen,b(s)]}}():e,3),r),p=new f(r),v=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),s),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(v,h,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);a<l;)i[a]=a++;for(a=0;a<l;a++)i[a]=i[s=h&s+e[a%n]+(t=i[a])],i[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,i=r.S;e--;)t=i[a=h&a+1],n=n*l+i[h&(i[a]=i[s=h&s+t])+(i[s]=t)];return r.i=a,r.j=s,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(g(e[n],t-1))}catch(s){}return r.length?r:"string"==a?e:e+"\0"}function y(e,t){for(var n,r=e+"",a=0;a<r.length;)t[h&a]=h&(n^=19*t[h&a])+r.charCodeAt(a++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),s),e.exports){e.exports=p;try{o=n(1234)}catch(v){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!==typeof self?self:this,[],Math)},3895:(e,t,n)=>{"use strict";var r=n(5043);var a="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t},s=r.useSyncExternalStore,i=r.useRef,o=r.useEffect,l=r.useMemo,u=r.useDebugValue;t.useSyncExternalStoreWithSelector=function(e,t,n,r,c){var d=i(null);if(null===d.current){var h={hasValue:!1,value:null};d.current=h}else h=d.current;d=l((function(){function e(e){if(!o){if(o=!0,s=e,e=r(e),void 0!==c&&h.hasValue){var t=h.value;if(c(t,e))return i=t}return i=e}if(t=i,a(s,e))return t;var n=r(e);return void 0!==c&&c(t,n)?t:(s=e,i=n)}var s,i,o=!1,l=void 0===n?null:n;return[function(){return e(t())},null===l?void 0:function(){return e(l())}]}),[t,n,r,c]);var p=s(e,d[0],d[1]);return o((function(){h.hasValue=!0,h.value=p}),[p]),u(p),p}},7237:(e,t,n)=>{"use strict";e.exports=n(3895)},5817:()=>{},8590:()=>{},4530:()=>{},8108:()=>{},551:()=>{},477:()=>{},1234:()=>{},4994:e=>{e.exports=function(e){return e&&e.__esModule?e:{default:e}},e.exports.__esModule=!0,e.exports.default=e.exports},8168:(e,t,n)=>{"use strict";function r(){return r=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},r.apply(null,arguments)}n.d(t,{A:()=>r})},8387:(e,t,n)=>{"use strict";function r(e){var t,n,a="";if("string"==typeof e||"number"==typeof e)a+=e;else if("object"==typeof e)if(Array.isArray(e)){var s=e.length;for(t=0;t<s;t++)e[t]&&(n=r(e[t]))&&(a&&(a+=" "),a+=n)}else for(n in e)e[n]&&(a&&(a+=" "),a+=n);return a}n.d(t,{A:()=>a});const a=function(){for(var e,t,n=0,a="",s=arguments.length;n<s;n++)(e=arguments[n])&&(t=r(e))&&(a&&(a+=" "),a+=t);return a}}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var s=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},(()=>{var e,t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__;n.t=function(r,a){if(1&a&&(r=this(r)),8&a)return r;if("object"===typeof r&&r){if(4&a&&r.__esModule)return r;if(16&a&&"function"===typeof r.then)return r}var s=Object.create(null);n.r(s);var i={};e=e||[null,t({}),t([]),t(t)];for(var o=2&a&&r;"object"==typeof o&&!~e.indexOf(o);o=t(o))Object.getOwnPropertyNames(o).forEach((e=>i[e]=()=>r[e]));return i.default=()=>r,n.d(s,i),s}})(),n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{"use strict";var e={};n.r(e),n.d(e,{mx:()=>o$e,XI:()=>J$e,Nk:()=>eRe,f6:()=>nRe,ct:()=>n$e,YG:()=>iRe,hH:()=>hRe,z3:()=>XRe,sG:()=>oDe,uM:()=>hDe,vS:()=>EDe,qB:()=>PDe,GG:()=>zDe,lg:()=>jDe,rq:()=>VDe,cu:()=>rMe,WR:()=>eMe,GE:()=>iMe,px:()=>lMe,jC:()=>SMe,He:()=>NMe,hE:()=>OMe,BF:()=>WRe,Dk:()=>HMe,cl:()=>eFe,_B:()=>pFe,ub:()=>bFe,_f:()=>wFe,Ku:()=>CFe,qy:()=>EFe,Zy:()=>VFe,bu:()=>jFe,zv:()=>q_e,dH:()=>g$e,HS:()=>Y$e,yH:()=>cOe,l3:()=>hOe,z9:()=>fOe,x6:()=>vOe,_m:()=>NOe,eW:()=>$Oe,GK:()=>MOe,SP:()=>POe,yr:()=>zOe,dl:()=>bDe,Dw:()=>HOe,xT:()=>XOe,_X:()=>S$e,wz:()=>rPe});var t=n(5043),r=n.t(t,2),a=n(7950),s=n.t(a,2),i=n(7237),o=t,l=Symbol.for("react-redux-context"),u="undefined"!==typeof globalThis?globalThis:{};function c(){if(!o.createContext)return{};const e=u[l]??(u[l]=new Map);let t=e.get(o.createContext);return t||(t=o.createContext(null),e.set(o.createContext,t)),t}var d=c(),h=()=>{throw new Error("uSES not initialized!")};function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:d;return function(){return o.useContext(e)}}var f=p(),m=h,g=(e,t)=>e===t;function y(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:d;const t=e===d?f:p(e),n=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{equalityFn:r=g,devModeChecks:a={}}="function"===typeof n?{equalityFn:n}:n;const{store:s,subscription:i,getServerState:l,stabilityCheck:u,identityFunctionCheck:c}=t(),d=(o.useRef(!0),o.useCallback({[e.name]:t=>e(t)}[e.name],[e,u,a.stabilityCheck])),h=m(i.addNestedSub,s.getState,l||s.getState,d,r);return o.useDebugValue(h),h};return Object.assign(n,{withTypes:()=>n}),n}var b=y();Symbol.for("react.element"),Symbol.for("react.portal"),Symbol.for("react.fragment"),Symbol.for("react.strict_mode"),Symbol.for("react.profiler"),Symbol.for("react.provider"),Symbol.for("react.context"),Symbol.for("react.server_context"),Symbol.for("react.forward_ref"),Symbol.for("react.suspense"),Symbol.for("react.suspense_list"),Symbol.for("react.memo"),Symbol.for("react.lazy"),Symbol.for("react.offscreen"),Symbol.for("react.client.reference");function v(e){e()}var x={notify(){},get:()=>[]};function w(e,t){let n,r=x,a=0,s=!1;function i(){u.onStateChange&&u.onStateChange()}function o(){a++,n||(n=t?t.addNestedSub(i):e.subscribe(i),r=function(){let e=null,t=null;return{clear(){e=null,t=null},notify(){v((()=>{let t=e;for(;t;)t.callback(),t=t.next}))},get(){const t=[];let n=e;for(;n;)t.push(n),n=n.next;return t},subscribe(n){let r=!0;const a=t={callback:n,next:null,prev:t};return a.prev?a.prev.next=a:e=a,function(){r&&null!==e&&(r=!1,a.next?a.next.prev=a.prev:t=a.prev,a.prev?a.prev.next=a.next:e=a.next)}}}}())}function l(){a--,n&&0===a&&(n(),n=void 0,r.clear(),r=x)}const u={addNestedSub:function(e){o();const t=r.subscribe(e);let n=!1;return()=>{n||(n=!0,t(),l())}},notifyNestedSubs:function(){r.notify()},handleChangeWrapper:i,isSubscribed:function(){return s},trySubscribe:function(){s||(s=!0,o())},tryUnsubscribe:function(){s&&(s=!1,l())},getListeners:()=>r};return u}var k=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),S="undefined"!==typeof navigator&&"ReactNative"===navigator.product,I=k||S?o.useLayoutEffect:o.useEffect;Object.defineProperty,Object.getOwnPropertyNames,Object.getOwnPropertySymbols,Object.getOwnPropertyDescriptor,Object.getPrototypeOf,Object.prototype;var T=function(e){let{store:t,context:n,children:r,serverState:a,stabilityCheck:s="once",identityFunctionCheck:i="once"}=e;const l=o.useMemo((()=>{const e=w(t);return{store:t,subscription:e,getServerState:a?()=>a:void 0,stabilityCheck:s,identityFunctionCheck:i}}),[t,a,s,i]),u=o.useMemo((()=>t.getState()),[t]);I((()=>{const{subscription:e}=l;return e.onStateChange=e.notifyNestedSubs,e.trySubscribe(),u!==t.getState()&&e.notifyNestedSubs(),()=>{e.tryUnsubscribe(),e.onStateChange=void 0}}),[l,u]);const c=n||d;return o.createElement(c.Provider,{value:l},r)};function N(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:d;const t=e===d?f:p(e),n=()=>{const{store:e}=t();return e};return Object.assign(n,{withTypes:()=>n}),n}var C=N();function A(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:d;const t=e===d?C:N(e),n=()=>t().dispatch;return Object.assign(n,{withTypes:()=>n}),n}var E=A();function _(e){return`Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `}(e=>{m=e})(i.useSyncExternalStoreWithSelector),(e=>{e})(t.useSyncExternalStore);var $=(()=>"function"===typeof Symbol&&Symbol.observable||"@@observable")(),R=()=>Math.random().toString(36).substring(7).split("").join("."),D={INIT:`@@redux/INIT${R()}`,REPLACE:`@@redux/REPLACE${R()}`,PROBE_UNKNOWN_ACTION:()=>`@@redux/PROBE_UNKNOWN_ACTION${R()}`};function M(e){if("object"!==typeof e||null===e)return!1;let t=e;for(;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t||null===Object.getPrototypeOf(e)}function F(e,t,n){if("function"!==typeof e)throw new Error(_(2));if("function"===typeof t&&"function"===typeof n||"function"===typeof n&&"function"===typeof arguments[3])throw new Error(_(0));if("function"===typeof t&&"undefined"===typeof n&&(n=t,t=void 0),"undefined"!==typeof n){if("function"!==typeof n)throw new Error(_(1));return n(F)(e,t)}let r=e,a=t,s=new Map,i=s,o=0,l=!1;function u(){i===s&&(i=new Map,s.forEach(((e,t)=>{i.set(t,e)})))}function c(){if(l)throw new Error(_(3));return a}function d(e){if("function"!==typeof e)throw new Error(_(4));if(l)throw new Error(_(5));let t=!0;u();const n=o++;return i.set(n,e),function(){if(t){if(l)throw new Error(_(6));t=!1,u(),i.delete(n),s=null}}}function h(e){if(!M(e))throw new Error(_(7));if("undefined"===typeof e.type)throw new Error(_(8));if("string"!==typeof e.type)throw new Error(_(17));if(l)throw new Error(_(9));try{l=!0,a=r(a,e)}finally{l=!1}return(s=i).forEach((e=>{e()})),e}h({type:D.INIT});return{dispatch:h,subscribe:d,getState:c,replaceReducer:function(e){if("function"!==typeof e)throw new Error(_(10));r=e,h({type:D.REPLACE})},[$]:function(){const e=d;return{subscribe(t){if("object"!==typeof t||null===t)throw new Error(_(11));function n(){const e=t;e.next&&e.next(c())}n();return{unsubscribe:e(n)}},[$](){return this}}}}}function O(e){const t=Object.keys(e),n={};for(let s=0;s<t.length;s++){const r=t[s];0,"function"===typeof e[r]&&(n[r]=e[r])}const r=Object.keys(n);let a;try{!function(e){Object.keys(e).forEach((t=>{const n=e[t];if("undefined"===typeof n(void 0,{type:D.INIT}))throw new Error(_(12));if("undefined"===typeof n(void 0,{type:D.PROBE_UNKNOWN_ACTION()}))throw new Error(_(13))}))}(n)}catch(KR){a=KR}return function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1?arguments[1]:void 0;if(a)throw a;let s=!1;const i={};for(let a=0;a<r.length;a++){const o=r[a],l=n[o],u=e[o],c=l(u,t);if("undefined"===typeof c){t&&t.type;throw new Error(_(14))}i[o]=c,s=s||c!==u}return s=s||r.length!==Object.keys(e).length,s?i:e}}function P(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 0===t.length?e=>e:1===t.length?t[0]:t.reduce(((e,t)=>function(){return e(t(...arguments))}))}function L(e){return t=>{let{dispatch:n,getState:r}=t;return t=>a=>"function"===typeof a?a(n,r,e):t(a)}}var z=L(),B=L,V=Symbol.for("immer-nothing"),W=Symbol.for("immer-draftable"),U=Symbol.for("immer-state");function j(e){throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)}var G=Object.getPrototypeOf;function H(e){return!!e&&!!e[U]}function q(e){return!!e&&(Y(e)||Array.isArray(e)||!!e[W]||!!e.constructor?.[W]||ee(e)||te(e))}var K=Object.prototype.constructor.toString();function Y(e){if(!e||"object"!==typeof e)return!1;const t=G(e);if(null===t)return!0;const n=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return n===Object||"function"==typeof n&&Function.toString.call(n)===K}function X(e,t){0===Q(e)?Reflect.ownKeys(e).forEach((n=>{t(n,e[n],e)})):e.forEach(((n,r)=>t(r,n,e)))}function Q(e){const t=e[U];return t?t.type_:Array.isArray(e)?1:ee(e)?2:te(e)?3:0}function Z(e,t){return 2===Q(e)?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function J(e,t,n){const r=Q(e);2===r?e.set(t,n):3===r?e.add(n):e[t]=n}function ee(e){return e instanceof Map}function te(e){return e instanceof Set}function ne(e){return e.copy_||e.base_}function re(e,t){if(ee(e))return new Map(e);if(te(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);const n=Y(e);if(!0===t||"class_only"===t&&!n){const t=Object.getOwnPropertyDescriptors(e);delete t[U];let n=Reflect.ownKeys(t);for(let r=0;r<n.length;r++){const a=n[r],s=t[a];!1===s.writable&&(s.writable=!0,s.configurable=!0),(s.get||s.set)&&(t[a]={configurable:!0,writable:!0,enumerable:s.enumerable,value:e[a]})}return Object.create(G(e),t)}{const t=G(e);if(null!==t&&n)return{...e};const r=Object.create(t);return Object.assign(r,e)}}function ae(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return ie(e)||H(e)||!q(e)||(Q(e)>1&&(e.set=e.add=e.clear=e.delete=se),Object.freeze(e),t&&Object.entries(e).forEach((e=>{let[t,n]=e;return ae(n,!0)}))),e}function se(){j(2)}function ie(e){return Object.isFrozen(e)}var oe,le={};function ue(e){const t=le[e];return t||j(0),t}function ce(){return oe}function de(e,t){t&&(ue("Patches"),e.patches_=[],e.inversePatches_=[],e.patchListener_=t)}function he(e){pe(e),e.drafts_.forEach(me),e.drafts_=null}function pe(e){e===oe&&(oe=e.parent_)}function fe(e){return oe={drafts_:[],parent_:oe,immer_:e,canAutoFreeze_:!0,unfinalizedDrafts_:0}}function me(e){const t=e[U];0===t.type_||1===t.type_?t.revoke_():t.revoked_=!0}function ge(e,t){t.unfinalizedDrafts_=t.drafts_.length;const n=t.drafts_[0];return void 0!==e&&e!==n?(n[U].modified_&&(he(t),j(4)),q(e)&&(e=ye(t,e),t.parent_||ve(t,e)),t.patches_&&ue("Patches").generateReplacementPatches_(n[U].base_,e,t.patches_,t.inversePatches_)):e=ye(t,n,[]),he(t),t.patches_&&t.patchListener_(t.patches_,t.inversePatches_),e!==V?e:void 0}function ye(e,t,n){if(ie(t))return t;const r=t[U];if(!r)return X(t,((a,s)=>be(e,r,t,a,s,n))),t;if(r.scope_!==e)return t;if(!r.modified_)return ve(e,r.base_,!0),r.base_;if(!r.finalized_){r.finalized_=!0,r.scope_.unfinalizedDrafts_--;const t=r.copy_;let a=t,s=!1;3===r.type_&&(a=new Set(t),t.clear(),s=!0),X(a,((a,i)=>be(e,r,t,a,i,n,s))),ve(e,t,!1),n&&e.patches_&&ue("Patches").generatePatches_(r,n,e.patches_,e.inversePatches_)}return r.copy_}function be(e,t,n,r,a,s,i){if(H(a)){const i=ye(e,a,s&&t&&3!==t.type_&&!Z(t.assigned_,r)?s.concat(r):void 0);if(J(n,r,i),!H(i))return;e.canAutoFreeze_=!1}else i&&n.add(a);if(q(a)&&!ie(a)){if(!e.immer_.autoFreeze_&&e.unfinalizedDrafts_<1)return;ye(e,a),t&&t.scope_.parent_||"symbol"===typeof r||!Object.prototype.propertyIsEnumerable.call(n,r)||ve(e,a)}}function ve(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];!e.parent_&&e.immer_.autoFreeze_&&e.canAutoFreeze_&&ae(t,n)}var xe={get(e,t){if(t===U)return e;const n=ne(e);if(!Z(n,t))return function(e,t,n){const r=Se(t,n);return r?"value"in r?r.value:r.get?.call(e.draft_):void 0}(e,n,t);const r=n[t];return e.finalized_||!q(r)?r:r===ke(e.base_,t)?(Te(e),e.copy_[t]=Ne(r,e)):r},has:(e,t)=>t in ne(e),ownKeys:e=>Reflect.ownKeys(ne(e)),set(e,t,n){const r=Se(ne(e),t);if(r?.set)return r.set.call(e.draft_,n),!0;if(!e.modified_){const r=ke(ne(e),t),a=r?.[U];if(a&&a.base_===n)return e.copy_[t]=n,e.assigned_[t]=!1,!0;if(function(e,t){return e===t?0!==e||1/e===1/t:e!==e&&t!==t}(n,r)&&(void 0!==n||Z(e.base_,t)))return!0;Te(e),Ie(e)}return e.copy_[t]===n&&(void 0!==n||t in e.copy_)||Number.isNaN(n)&&Number.isNaN(e.copy_[t])||(e.copy_[t]=n,e.assigned_[t]=!0),!0},deleteProperty:(e,t)=>(void 0!==ke(e.base_,t)||t in e.base_?(e.assigned_[t]=!1,Te(e),Ie(e)):delete e.assigned_[t],e.copy_&&delete e.copy_[t],!0),getOwnPropertyDescriptor(e,t){const n=ne(e),r=Reflect.getOwnPropertyDescriptor(n,t);return r?{writable:!0,configurable:1!==e.type_||"length"!==t,enumerable:r.enumerable,value:n[t]}:r},defineProperty(){j(11)},getPrototypeOf:e=>G(e.base_),setPrototypeOf(){j(12)}},we={};function ke(e,t){const n=e[U];return(n?ne(n):e)[t]}function Se(e,t){if(!(t in e))return;let n=G(e);for(;n;){const e=Object.getOwnPropertyDescriptor(n,t);if(e)return e;n=G(n)}}function Ie(e){e.modified_||(e.modified_=!0,e.parent_&&Ie(e.parent_))}function Te(e){e.copy_||(e.copy_=re(e.base_,e.scope_.immer_.useStrictShallowCopy_))}X(xe,((e,t)=>{we[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),we.deleteProperty=function(e,t){return we.set.call(this,e,t,void 0)},we.set=function(e,t,n){return xe.set.call(this,e[0],t,n,e[0])};function Ne(e,t){const n=ee(e)?ue("MapSet").proxyMap_(e,t):te(e)?ue("MapSet").proxySet_(e,t):function(e,t){const n=Array.isArray(e),r={type_:n?1:0,scope_:t?t.scope_:ce(),modified_:!1,finalized_:!1,assigned_:{},parent_:t,base_:e,draft_:null,copy_:null,revoke_:null,isManual_:!1};let a=r,s=xe;n&&(a=[r],s=we);const{revoke:i,proxy:o}=Proxy.revocable(a,s);return r.draft_=o,r.revoke_=i,o}(e,t);return(t?t.scope_:ce()).drafts_.push(n),n}function Ce(e){if(!q(e)||ie(e))return e;const t=e[U];let n;if(t){if(!t.modified_)return t.base_;t.finalized_=!0,n=re(e,t.scope_.immer_.useStrictShallowCopy_)}else n=re(e,!0);return X(n,((e,t)=>{J(n,e,Ce(t))})),t&&(t.finalized_=!1),n}var Ae=new class{constructor(e){var t=this;this.autoFreeze_=!0,this.useStrictShallowCopy_=!1,this.produce=(e,t,n)=>{if("function"===typeof e&&"function"!==typeof t){const n=t;t=e;const r=this;return function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;for(var a=arguments.length,s=new Array(a>1?a-1:0),i=1;i<a;i++)s[i-1]=arguments[i];return r.produce(e,(e=>t.call(this,e,...s)))}}let r;if("function"!==typeof t&&j(6),void 0!==n&&"function"!==typeof n&&j(7),q(e)){const a=fe(this),s=Ne(e,void 0);let i=!0;try{r=t(s),i=!1}finally{i?he(a):pe(a)}return de(a,n),ge(r,a)}if(!e||"object"!==typeof e){if(r=t(e),void 0===r&&(r=e),r===V&&(r=void 0),this.autoFreeze_&&ae(r,!0),n){const t=[],a=[];ue("Patches").generateReplacementPatches_(e,r,t,a),n(t,a)}return r}j(1)},this.produceWithPatches=(e,n)=>{if("function"===typeof e)return function(n){for(var r=arguments.length,a=new Array(r>1?r-1:0),s=1;s<r;s++)a[s-1]=arguments[s];return t.produceWithPatches(n,(t=>e(t,...a)))};let r,a;const s=this.produce(e,n,((e,t)=>{r=e,a=t}));return[s,r,a]},"boolean"===typeof e?.autoFreeze&&this.setAutoFreeze(e.autoFreeze),"boolean"===typeof e?.useStrictShallowCopy&&this.setUseStrictShallowCopy(e.useStrictShallowCopy)}createDraft(e){q(e)||j(8),H(e)&&(e=function(e){H(e)||j(10);return Ce(e)}(e));const t=fe(this),n=Ne(e,void 0);return n[U].isManual_=!0,pe(t),n}finishDraft(e,t){const n=e&&e[U];n&&n.isManual_||j(9);const{scope_:r}=n;return de(r,t),ge(void 0,r)}setAutoFreeze(e){this.autoFreeze_=e}setUseStrictShallowCopy(e){this.useStrictShallowCopy_=e}applyPatches(e,t){let n;for(n=t.length-1;n>=0;n--){const r=t[n];if(0===r.path.length&&"replace"===r.op){e=r.value;break}}n>-1&&(t=t.slice(n+1));const r=ue("Patches").applyPatches_;return H(e)?r(e,t):this.produce(e,(e=>r(e,t)))}},Ee=Ae.produce;Ae.produceWithPatches.bind(Ae),Ae.setAutoFreeze.bind(Ae),Ae.setUseStrictShallowCopy.bind(Ae),Ae.applyPatches.bind(Ae),Ae.createDraft.bind(Ae),Ae.finishDraft.bind(Ae);var _e="undefined"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__:function(){if(0!==arguments.length)return"object"===typeof arguments[0]?P:P.apply(null,arguments)};"undefined"!==typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__&&window.__REDUX_DEVTOOLS_EXTENSION__;function $e(e,t){function n(){if(t){let n=t(...arguments);if(!n)throw new Error(qe(0));return{type:e,payload:n.payload,..."meta"in n&&{meta:n.meta},..."error"in n&&{error:n.error}}}return{type:e,payload:arguments.length<=0?void 0:arguments[0]}}return n.toString=()=>`${e}`,n.type=e,n.match=t=>function(e){return M(e)&&"type"in e&&"string"===typeof e.type}(t)&&t.type===e,n}var Re=class e extends Array{constructor(){super(...arguments),Object.setPrototypeOf(this,e.prototype)}static get[Symbol.species](){return e}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return super.concat.apply(this,t)}prepend(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return 1===n.length&&Array.isArray(n[0])?new e(...n[0].concat(this)):new e(...n.concat(this))}};function De(e){return q(e)?Ee(e,(()=>{})):e}function Me(e,t,n){if(e.has(t)){let r=e.get(t);return n.update&&(r=n.update(r,t,e),e.set(t,r)),r}if(!n.insert)throw new Error(qe(10));const r=n.insert(t,e);return e.set(t,r),r}var Fe="RTK_autoBatch",Oe=e=>t=>{setTimeout(t,e)},Pe="undefined"!==typeof window&&window.requestAnimationFrame?window.requestAnimationFrame:Oe(10),Le=e=>function(t){const{autoBatch:n=!0}=t??{};let r=new Re(e);return n&&r.push(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{type:"raf"};return t=>function(){const n=t(...arguments);let r=!0,a=!1,s=!1;const i=new Set,o="tick"===e.type?queueMicrotask:"raf"===e.type?Pe:"callback"===e.type?e.queueNotification:Oe(e.timeout),l=()=>{s=!1,a&&(a=!1,i.forEach((e=>e())))};return Object.assign({},n,{subscribe(e){const t=n.subscribe((()=>r&&e()));return i.add(e),()=>{t(),i.delete(e)}},dispatch(e){try{return r=!e?.meta?.[Fe],a=!r,a&&(s||(s=!0,o(l))),n.dispatch(e)}finally{r=!0}}})}}("object"===typeof n?n:void 0)),r};function ze(e){const t={},n=[];let r;const a={addCase(e,n){const r="string"===typeof e?e:e.type;if(!r)throw new Error(qe(28));if(r in t)throw new Error(qe(29));return t[r]=n,a},addMatcher:(e,t)=>(n.push({matcher:e,reducer:t}),a),addDefaultCase:e=>(r=e,a)};return e(a),[t,n,r]}var Be=Symbol.for("rtk-slice-createasyncthunk");function Ve(e,t){return`${e}/${t}`}function We(){let{creators:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=e?.asyncThunk?.[Be];return function(e){const{name:n,reducerPath:r=n}=e;if(!n)throw new Error(qe(11));const a=("function"===typeof e.reducers?e.reducers(function(){function e(e,t){return{_reducerDefinitionType:"asyncThunk",payloadCreator:e,...t}}return e.withTypes=()=>e,{reducer:e=>Object.assign({[e.name](){return e(...arguments)}}[e.name],{_reducerDefinitionType:"reducer"}),preparedReducer:(e,t)=>({_reducerDefinitionType:"reducerWithPrepare",prepare:e,reducer:t}),asyncThunk:e}}()):e.reducers)||{},s=Object.keys(a),i={sliceCaseReducersByName:{},sliceCaseReducersByType:{},actionCreators:{},sliceMatchers:[]},o={addCase(e,t){const n="string"===typeof e?e:e.type;if(!n)throw new Error(qe(12));if(n in i.sliceCaseReducersByType)throw new Error(qe(13));return i.sliceCaseReducersByType[n]=t,o},addMatcher:(e,t)=>(i.sliceMatchers.push({matcher:e,reducer:t}),o),exposeAction:(e,t)=>(i.actionCreators[e]=t,o),exposeCaseReducer:(e,t)=>(i.sliceCaseReducersByName[e]=t,o)};function l(){const[t={},n=[],r]="function"===typeof e.extraReducers?ze(e.extraReducers):[e.extraReducers],a={...t,...i.sliceCaseReducersByType};return function(e,t){let n,[r,a,s]=ze(t);if(function(e){return"function"===typeof e}(e))n=()=>De(e());else{const t=De(e);n=()=>t}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n(),t=arguments.length>1?arguments[1]:void 0,i=[r[t.type],...a.filter((e=>{let{matcher:n}=e;return n(t)})).map((e=>{let{reducer:t}=e;return t}))];return 0===i.filter((e=>!!e)).length&&(i=[s]),i.reduce(((e,n)=>{if(n){if(H(e)){const r=n(e,t);return void 0===r?e:r}if(q(e))return Ee(e,(e=>n(e,t)));{const r=n(e,t);if(void 0===r){if(null===e)return e;throw new Error(qe(9))}return r}}return e}),e)}return i.getInitialState=n,i}(e.initialState,(e=>{for(let t in a)e.addCase(t,a[t]);for(let t of i.sliceMatchers)e.addMatcher(t.matcher,t.reducer);for(let t of n)e.addMatcher(t.matcher,t.reducer);r&&e.addDefaultCase(r)}))}s.forEach((r=>{const s=a[r],i={reducerName:r,type:Ve(n,r),createNotation:"function"===typeof e.reducers};!function(e){return"asyncThunk"===e._reducerDefinitionType}(s)?function(e,t,n){let r,a,{type:s,reducerName:i,createNotation:o}=e;if("reducer"in t){if(o&&!function(e){return"reducerWithPrepare"===e._reducerDefinitionType}(t))throw new Error(qe(17));r=t.reducer,a=t.prepare}else r=t;n.addCase(s,r).exposeCaseReducer(i,r).exposeAction(i,a?$e(s,a):$e(s))}(i,s,o):function(e,t,n,r){let{type:a,reducerName:s}=e;if(!r)throw new Error(qe(18));const{payloadCreator:i,fulfilled:o,pending:l,rejected:u,settled:c,options:d}=t,h=r(a,i,d);n.exposeAction(s,h),o&&n.addCase(h.fulfilled,o);l&&n.addCase(h.pending,l);u&&n.addCase(h.rejected,u);c&&n.addMatcher(h.settled,c);n.exposeCaseReducer(s,{fulfilled:o||Ge,pending:l||Ge,rejected:u||Ge,settled:c||Ge})}(i,s,o,t)}));const u=e=>e,c=new Map;let d;function h(e,t){return d||(d=l()),d(e,t)}function p(){return d||(d=l()),d.getInitialState()}function f(t){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];function r(e){let r=e[t];return"undefined"===typeof r&&n&&(r=p()),r}function a(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:u;const r=Me(c,n,{insert:()=>new WeakMap});return Me(r,t,{insert:()=>{const r={};for(const[a,s]of Object.entries(e.selectors??{}))r[a]=Ue(s,t,p,n);return r}})}return{reducerPath:t,getSelectors:a,get selectors(){return a(r)},selectSlice:r}}const m={name:n,reducer:h,actions:i.actionCreators,caseReducers:i.sliceCaseReducersByName,getInitialState:p,...f(r),injectInto(e){let{reducerPath:t,...n}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const a=t??r;return e.inject({reducerPath:a,reducer:h},n),{...m,...f(a,!0)}}};return m}}function Ue(e,t,n,r){function a(a){let s=t(a);"undefined"===typeof s&&r&&(s=n());for(var i=arguments.length,o=new Array(i>1?i-1:0),l=1;l<i;l++)o[l-1]=arguments[l];return e(s,...o)}return a.unwrapped=e,a}var je=We();function Ge(){}var{assign:He}=Object;Symbol.for("rtk-state-proxy-original");function qe(e){return`Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `}const Ke=je({name:"user",initialState:{name:"",email:"",dateOfBirth:"",userId:"",generatedId:"",error:""},reducers:{setUser:(e,t)=>{const{name:n,email:r,dateOfBirth:a,userId:s}=t.payload;e.name=n,e.email=r,e.dateOfBirth=a,e.userId=s},setGeneratedId:(e,t)=>{e.generatedId=t.payload},setError:(e,t)=>{e.error=t.payload},clearUser:e=>{e.name="",e.email="",e.dateOfBirth="",e.userId="",e.generatedId=""},clearError:e=>{e.error=""},clearId:e=>{e.generatedId=""}}}),{setUser:Ye,setGeneratedId:Xe,setError:Qe,clearUser:Ze,clearId:Je,clearError:et}=Ke.actions,tt=function(e){const t=function(e){const{thunk:t=!0,immutableCheck:n=!0,serializableCheck:r=!0,actionCreatorCheck:a=!0}=e??{};let s=new Re;return t&&(function(e){return"boolean"===typeof e}(t)?s.push(z):s.push(B(t.extraArgument))),s},{reducer:n,middleware:r,devTools:a=!0,preloadedState:s,enhancers:i}=e||{};let o,l;if("function"===typeof n)o=n;else{if(!M(n))throw new Error(qe(1));o=O(n)}l="function"===typeof r?r(t):t();let u=P;a&&(u=_e({trace:!1,..."object"===typeof a&&a}));const c=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return e=>(n,r)=>{const a=e(n,r);let s=()=>{throw new Error(_(15))};const i={getState:a.getState,dispatch:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return s(e,...n)}},o=t.map((e=>e(i)));return s=P(...o)(a.dispatch),{...a,dispatch:s}}}(...l),d=Le(c);return F(o,s,u(..."function"===typeof i?i(d):d()))}({reducer:{user:Ke.reducer}}),nt=tt;function rt(){return rt=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},rt.apply(this,arguments)}var at;!function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"}(at||(at={}));const st="popstate";function it(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function ot(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(KR){}}}function lt(e,t){return{usr:e.state,key:e.key,idx:t}}function ut(e,t,n,r){return void 0===n&&(n=null),rt({pathname:"string"===typeof e?e:e.pathname,search:"",hash:""},"string"===typeof t?dt(t):t,{state:n,key:t&&t.key||r||Math.random().toString(36).substr(2,8)})}function ct(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(t+="#"===r.charAt(0)?r:"#"+r),t}function dt(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substr(r),e=e.substr(0,r)),e&&(t.pathname=e)}return t}function ht(e,t,n,r){void 0===r&&(r={});let{window:a=document.defaultView,v5Compat:s=!1}=r,i=a.history,o=at.Pop,l=null,u=c();function c(){return(i.state||{idx:null}).idx}function d(){o=at.Pop;let e=c(),t=null==e?null:e-u;u=e,l&&l({action:o,location:p.location,delta:t})}function h(e){let t="null"!==a.location.origin?a.location.origin:a.location.href,n="string"===typeof e?e:ct(e);return n=n.replace(/ $/,"%20"),it(t,"No window.location.(origin|href) available to create URL for href: "+n),new URL(n,t)}null==u&&(u=0,i.replaceState(rt({},i.state,{idx:u}),""));let p={get action(){return o},get location(){return e(a,i)},listen(e){if(l)throw new Error("A history only accepts one active listener");return a.addEventListener(st,d),l=e,()=>{a.removeEventListener(st,d),l=null}},createHref:e=>t(a,e),createURL:h,encodeLocation(e){let t=h(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){o=at.Push;let r=ut(p.location,e,t);n&&n(r,e),u=c()+1;let d=lt(r,u),h=p.createHref(r);try{i.pushState(d,"",h)}catch(f){if(f instanceof DOMException&&"DataCloneError"===f.name)throw f;a.location.assign(h)}s&&l&&l({action:o,location:p.location,delta:1})},replace:function(e,t){o=at.Replace;let r=ut(p.location,e,t);n&&n(r,e),u=c();let a=lt(r,u),d=p.createHref(r);i.replaceState(a,"",d),s&&l&&l({action:o,location:p.location,delta:0})},go:e=>i.go(e)};return p}var pt;!function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"}(pt||(pt={}));new Set(["lazy","caseSensitive","path","id","index","children"]);function ft(e,t,n){return void 0===n&&(n="/"),mt(e,t,n,!1)}function mt(e,t,n,r){let a=Et(("string"===typeof t?dt(t):t).pathname||"/",n);if(null==a)return null;let s=gt(e);!function(e){e.sort(((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every(((e,n)=>e===t[n]));return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map((e=>e.childrenIndex)),t.routesMeta.map((e=>e.childrenIndex)))))}(s);let i=null;for(let o=0;null==i&&o<s.length;++o){let e=At(a);i=Nt(s[o],e,r)}return i}function gt(e,t,n,r){void 0===t&&(t=[]),void 0===n&&(n=[]),void 0===r&&(r="");let a=(e,a,s)=>{let i={relativePath:void 0===s?e.path||"":s,caseSensitive:!0===e.caseSensitive,childrenIndex:a,route:e};i.relativePath.startsWith("/")&&(it(i.relativePath.startsWith(r),'Absolute route path "'+i.relativePath+'" nested under path "'+r+'" is not valid. An absolute child route path must start with the combined path of all its parent routes.'),i.relativePath=i.relativePath.slice(r.length));let o=Mt([r,i.relativePath]),l=n.concat(i);e.children&&e.children.length>0&&(it(!0!==e.index,'Index routes must not have child routes. Please remove all child routes from route path "'+o+'".'),gt(e.children,t,l,o)),(null!=e.path||e.index)&&t.push({path:o,score:Tt(o,e.index),routesMeta:l})};return e.forEach(((e,t)=>{var n;if(""!==e.path&&null!=(n=e.path)&&n.includes("?"))for(let r of yt(e.path))a(e,t,r);else a(e,t)})),t}function yt(e){let t=e.split("/");if(0===t.length)return[];let[n,...r]=t,a=n.endsWith("?"),s=n.replace(/\?$/,"");if(0===r.length)return a?[s,""]:[s];let i=yt(r.join("/")),o=[];return o.push(...i.map((e=>""===e?s:[s,e].join("/")))),a&&o.push(...i),o.map((t=>e.startsWith("/")&&""===t?"/":t))}const bt=/^:[\w-]+$/,vt=3,xt=2,wt=1,kt=10,St=-2,It=e=>"*"===e;function Tt(e,t){let n=e.split("/"),r=n.length;return n.some(It)&&(r+=St),t&&(r+=xt),n.filter((e=>!It(e))).reduce(((e,t)=>e+(bt.test(t)?vt:""===t?wt:kt)),r)}function Nt(e,t,n){void 0===n&&(n=!1);let{routesMeta:r}=e,a={},s="/",i=[];for(let o=0;o<r.length;++o){let e=r[o],l=o===r.length-1,u="/"===s?t:t.slice(s.length)||"/",c=Ct({path:e.relativePath,caseSensitive:e.caseSensitive,end:l},u),d=e.route;if(!c&&l&&n&&!r[r.length-1].route.index&&(c=Ct({path:e.relativePath,caseSensitive:e.caseSensitive,end:!1},u)),!c)return null;Object.assign(a,c.params),i.push({params:a,pathname:Mt([s,c.pathname]),pathnameBase:Ft(Mt([s,c.pathnameBase])),route:d}),"/"!==c.pathnameBase&&(s=Mt([s,c.pathnameBase]))}return i}function Ct(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=!0);ot("*"===e||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were "'+e.replace(/\*$/,"/*")+'" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "'+e.replace(/\*$/,"/*")+'".');let r=[],a="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((e,t,n)=>(r.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));e.endsWith("*")?(r.push({paramName:"*"}),a+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?a+="\\/*$":""!==e&&"/"!==e&&(a+="(?:(?=\\/|$))");let s=new RegExp(a,t?void 0:"i");return[s,r]}(e.path,e.caseSensitive,e.end),a=t.match(n);if(!a)return null;let s=a[0],i=s.replace(/(.)\/+$/,"$1"),o=a.slice(1);return{params:r.reduce(((e,t,n)=>{let{paramName:r,isOptional:a}=t;if("*"===r){let e=o[n]||"";i=s.slice(0,s.length-e.length).replace(/(.)\/+$/,"$1")}const l=o[n];return e[r]=a&&!l?void 0:(l||"").replace(/%2F/g,"/"),e}),{}),pathname:s,pathnameBase:i,pattern:e}}function At(e){try{return e.split("/").map((e=>decodeURIComponent(e).replace(/\//g,"%2F"))).join("/")}catch(t){return ot(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding ('+t+")."),e}}function Et(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&"/"!==r?null:e.slice(n)||"/"}function _t(e,t,n,r){return"Cannot include a '"+e+"' character in a manually specified `to."+t+"` field ["+JSON.stringify(r)+"].  Please separate it out to the `to."+n+'` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.'}function $t(e){return e.filter(((e,t)=>0===t||e.route.path&&e.route.path.length>0))}function Rt(e,t){let n=$t(e);return t?n.map(((e,t)=>t===n.length-1?e.pathname:e.pathnameBase)):n.map((e=>e.pathnameBase))}function Dt(e,t,n,r){let a;void 0===r&&(r=!1),"string"===typeof e?a=dt(e):(a=rt({},e),it(!a.pathname||!a.pathname.includes("?"),_t("?","pathname","search",a)),it(!a.pathname||!a.pathname.includes("#"),_t("#","pathname","hash",a)),it(!a.search||!a.search.includes("#"),_t("#","search","hash",a)));let s,i=""===e||""===a.pathname,o=i?"/":a.pathname;if(null==o)s=n;else{let e=t.length-1;if(!r&&o.startsWith("..")){let t=o.split("/");for(;".."===t[0];)t.shift(),e-=1;a.pathname=t.join("/")}s=e>=0?t[e]:"/"}let l=function(e,t){void 0===t&&(t="/");let{pathname:n,search:r="",hash:a=""}="string"===typeof e?dt(e):e,s=n?n.startsWith("/")?n:function(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach((e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)})),n.length>1?n.join("/"):"/"}(n,t):t;return{pathname:s,search:Ot(r),hash:Pt(a)}}(a,s),u=o&&"/"!==o&&o.endsWith("/"),c=(i||"."===o)&&n.endsWith("/");return l.pathname.endsWith("/")||!u&&!c||(l.pathname+="/"),l}const Mt=e=>e.join("/").replace(/\/\/+/g,"/"),Ft=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),Ot=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",Pt=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:"";Error;function Lt(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}const zt=["post","put","patch","delete"],Bt=(new Set(zt),["get",...zt]);new Set(Bt),new Set([301,302,303,307,308]),new Set([307,308]);Symbol("deferred");function Vt(){return Vt=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Vt.apply(this,arguments)}const Wt=t.createContext(null);const Ut=t.createContext(null);const jt=t.createContext(null);const Gt=t.createContext(null);const Ht=t.createContext({outlet:null,matches:[],isDataRoute:!1});const qt=t.createContext(null);function Kt(){return null!=t.useContext(Gt)}function Yt(){return Kt()||it(!1),t.useContext(Gt).location}function Xt(e){t.useContext(jt).static||t.useLayoutEffect(e)}function Qt(){let{isDataRoute:e}=t.useContext(Ht);return e?function(){let{router:e}=on(an.UseNavigateStable),n=un(sn.UseNavigateStable),r=t.useRef(!1);Xt((()=>{r.current=!0}));let a=t.useCallback((function(t,a){void 0===a&&(a={}),r.current&&("number"===typeof t?e.navigate(t):e.navigate(t,Vt({fromRouteId:n},a)))}),[e,n]);return a}():function(){Kt()||it(!1);let e=t.useContext(Wt),{basename:n,future:r,navigator:a}=t.useContext(jt),{matches:s}=t.useContext(Ht),{pathname:i}=Yt(),o=JSON.stringify(Rt(s,r.v7_relativeSplatPath)),l=t.useRef(!1);Xt((()=>{l.current=!0}));let u=t.useCallback((function(t,r){if(void 0===r&&(r={}),!l.current)return;if("number"===typeof t)return void a.go(t);let s=Dt(t,JSON.parse(o),i,"path"===r.relative);null==e&&"/"!==n&&(s.pathname="/"===s.pathname?n:Mt([n,s.pathname])),(r.replace?a.replace:a.push)(s,r.state,r)}),[n,a,o,i,e]);return u}()}function Zt(e,n,r,a){Kt()||it(!1);let{navigator:s}=t.useContext(jt),{matches:i}=t.useContext(Ht),o=i[i.length-1],l=o?o.params:{},u=(o&&o.pathname,o?o.pathnameBase:"/");o&&o.route;let c,d=Yt();if(n){var h;let e="string"===typeof n?dt(n):n;"/"===u||(null==(h=e.pathname)?void 0:h.startsWith(u))||it(!1),c=e}else c=d;let p=c.pathname||"/",f=p;if("/"!==u){let e=u.replace(/^\//,"").split("/");f="/"+p.replace(/^\//,"").split("/").slice(e.length).join("/")}let m=ft(e,{pathname:f});let g=rn(m&&m.map((e=>Object.assign({},e,{params:Object.assign({},l,e.params),pathname:Mt([u,s.encodeLocation?s.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?u:Mt([u,s.encodeLocation?s.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])}))),i,r,a);return n&&g?t.createElement(Gt.Provider,{value:{location:Vt({pathname:"/",search:"",hash:"",state:null,key:"default"},c),navigationType:at.Pop}},g):g}function Jt(){let e=function(){var e;let n=t.useContext(qt),r=ln(sn.UseRouteError),a=un(sn.UseRouteError);if(void 0!==n)return n;return null==(e=r.errors)?void 0:e[a]}(),n=Lt(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),r=e instanceof Error?e.stack:null,a="rgba(200,200,200, 0.5)",s={padding:"0.5rem",backgroundColor:a};return t.createElement(t.Fragment,null,t.createElement("h2",null,"Unexpected Application Error!"),t.createElement("h3",{style:{fontStyle:"italic"}},n),r?t.createElement("pre",{style:s},r):null,null)}const en=t.createElement(Jt,null);class tn extends t.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?t.createElement(Ht.Provider,{value:this.props.routeContext},t.createElement(qt.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function nn(e){let{routeContext:n,match:r,children:a}=e,s=t.useContext(Wt);return s&&s.static&&s.staticContext&&(r.route.errorElement||r.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=r.route.id),t.createElement(Ht.Provider,{value:n},a)}function rn(e,n,r,a){var s;if(void 0===n&&(n=[]),void 0===r&&(r=null),void 0===a&&(a=null),null==e){var i;if(!r)return null;if(r.errors)e=r.matches;else{if(!(null!=(i=a)&&i.v7_partialHydration&&0===n.length&&!r.initialized&&r.matches.length>0))return null;e=r.matches}}let o=e,l=null==(s=r)?void 0:s.errors;if(null!=l){let e=o.findIndex((e=>e.route.id&&void 0!==(null==l?void 0:l[e.route.id])));e>=0||it(!1),o=o.slice(0,Math.min(o.length,e+1))}let u=!1,c=-1;if(r&&a&&a.v7_partialHydration)for(let t=0;t<o.length;t++){let e=o[t];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(c=t),e.route.id){let{loaderData:t,errors:n}=r,a=e.route.loader&&void 0===t[e.route.id]&&(!n||void 0===n[e.route.id]);if(e.route.lazy||a){u=!0,o=c>=0?o.slice(0,c+1):[o[0]];break}}}return o.reduceRight(((e,a,s)=>{let i,d=!1,h=null,p=null;var f;r&&(i=l&&a.route.id?l[a.route.id]:void 0,h=a.route.errorElement||en,u&&(c<0&&0===s?(f="route-fallback",!1||cn[f]||(cn[f]=!0),d=!0,p=null):c===s&&(d=!0,p=a.route.hydrateFallbackElement||null)));let m=n.concat(o.slice(0,s+1)),g=()=>{let n;return n=i?h:d?p:a.route.Component?t.createElement(a.route.Component,null):a.route.element?a.route.element:e,t.createElement(nn,{match:a,routeContext:{outlet:e,matches:m,isDataRoute:null!=r},children:n})};return r&&(a.route.ErrorBoundary||a.route.errorElement||0===s)?t.createElement(tn,{location:r.location,revalidation:r.revalidation,component:h,error:i,children:g(),routeContext:{outlet:null,matches:m,isDataRoute:!0}}):g()}),null)}var an=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(an||{}),sn=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(sn||{});function on(e){let n=t.useContext(Wt);return n||it(!1),n}function ln(e){let n=t.useContext(Ut);return n||it(!1),n}function un(e){let n=function(){let e=t.useContext(Ht);return e||it(!1),e}(),r=n.matches[n.matches.length-1];return r.route.id||it(!1),r.route.id}const cn={};r.startTransition;function dn(e){it(!1)}function hn(e){let{basename:n="/",children:r=null,location:a,navigationType:s=at.Pop,navigator:i,static:o=!1,future:l}=e;Kt()&&it(!1);let u=n.replace(/^\/*/,"/"),c=t.useMemo((()=>({basename:u,navigator:i,static:o,future:Vt({v7_relativeSplatPath:!1},l)})),[u,l,i,o]);"string"===typeof a&&(a=dt(a));let{pathname:d="/",search:h="",hash:p="",state:f=null,key:m="default"}=a,g=t.useMemo((()=>{let e=Et(d,u);return null==e?null:{location:{pathname:e,search:h,hash:p,state:f,key:m},navigationType:s}}),[u,d,h,p,f,m,s]);return null==g?null:t.createElement(jt.Provider,{value:c},t.createElement(Gt.Provider,{children:r,value:g}))}function pn(e){let{children:t,location:n}=e;return Zt(fn(t),n)}new Promise((()=>{}));t.Component;function fn(e,n){void 0===n&&(n=[]);let r=[];return t.Children.forEach(e,((e,a)=>{if(!t.isValidElement(e))return;let s=[...n,a];if(e.type===t.Fragment)return void r.push.apply(r,fn(e.props.children,s));e.type!==dn&&it(!1),e.props.index&&e.props.children&&it(!1);let i={id:e.props.id||s.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(i.children=fn(e.props.children,s)),r.push(i)})),r}new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);try{window.__reactRouterVersion="6"}catch(KR){}new Map;const mn=r.startTransition;s.flushSync,r.useId;function gn(e){let{basename:n,children:r,future:a,window:s}=e,i=t.useRef();var o;null==i.current&&(i.current=(void 0===(o={window:s,v5Compat:!0})&&(o={}),ht((function(e,t){let{pathname:n,search:r,hash:a}=e.location;return ut("",{pathname:n,search:r,hash:a},t.state&&t.state.usr||null,t.state&&t.state.key||"default")}),(function(e,t){return"string"===typeof t?t:ct(t)}),null,o)));let l=i.current,[u,c]=t.useState({action:l.action,location:l.location}),{v7_startTransition:d}=a||{},h=t.useCallback((e=>{d&&mn?mn((()=>c(e))):c(e)}),[c,d]);return t.useLayoutEffect((()=>l.listen(h)),[l,h]),t.createElement(hn,{basename:n,children:r,location:u.location,navigationType:u.action,navigator:l,future:a})}"undefined"!==typeof window&&"undefined"!==typeof window.document&&window.document.createElement;var yn,bn;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(yn||(yn={})),function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"}(bn||(bn={}));var vn=n(8387),xn=n(4984),wn=n(2768),kn=n(9172),Sn=n(138);const In=e=>{const t={systemProps:{},otherProps:{}},n=e?.theme?.unstable_sxConfig??Sn.A;return Object.keys(e).forEach((r=>{n[r]?t.systemProps[r]=e[r]:t.otherProps[r]=e[r]})),t};function Tn(e){const{sx:t,...n}=e,{systemProps:r,otherProps:a}=In(n);let s;return s=Array.isArray(t)?[r,...t]:"function"===typeof t?function(){const e=t(...arguments);return(0,kn.Q)(e)?{...r,...e}:r}:{...r,...t},{...a,sx:s}}var Nn=n(2390),Cn=n(4575);const An=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;const n=t.useContext(Cn.T);return n&&(r=n,0!==Object.keys(r).length)?n:e;var r},En=(0,Nn.A)();const _n=function(){return An(arguments.length>0&&void 0!==arguments[0]?arguments[0]:En)};var $n=n(579);var Rn=n(9386),Dn=n(5913),Mn=n(3375),Fn=n(2532);const On=(0,Fn.A)("MuiBox",["root"]),Pn=(0,Dn.A)(),Ln=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{themeId:n,defaultTheme:r,defaultClassName:a="MuiBox-root",generateClassName:s}=e,i=(0,xn.Ay)("div",{shouldForwardProp:e=>"theme"!==e&&"sx"!==e&&"as"!==e})(wn.A);return t.forwardRef((function(e,t){const o=_n(r),{className:l,component:u="div",...c}=Tn(e);return(0,$n.jsx)(i,{as:u,ref:t,className:(0,vn.A)(l,s?s(a):a),theme:n&&o[n]||o,...c})}))}({themeId:Mn.A,defaultTheme:Pn,defaultClassName:On.root,generateClassName:Rn.A.generate}),zn=Ln;var Bn=n(8610),Vn=n(6596),Wn=n(4535),Un=n(5170);function jn(){const e=_n(Un.A);return e[Mn.A]||e}var Gn=n(6870),Hn=n(8249),qn=n(3582),Kn=n(2372);function Yn(e){return(0,Kn.Ay)("MuiPaper",e)}(0,Fn.A)("MuiPaper",["root","rounded","outlined","elevation","elevation0","elevation1","elevation2","elevation3","elevation4","elevation5","elevation6","elevation7","elevation8","elevation9","elevation10","elevation11","elevation12","elevation13","elevation14","elevation15","elevation16","elevation17","elevation18","elevation19","elevation20","elevation21","elevation22","elevation23","elevation24"]);const Xn=(0,Wn.Ay)("div",{name:"MuiPaper",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],!n.square&&t.rounded,"elevation"===n.variant&&t[`elevation${n.elevation}`]]}})((0,Gn.A)((e=>{let{theme:t}=e;return{backgroundColor:(t.vars||t).palette.background.paper,color:(t.vars||t).palette.text.primary,transition:t.transitions.create("box-shadow"),variants:[{props:e=>{let{ownerState:t}=e;return!t.square},style:{borderRadius:t.shape.borderRadius}},{props:{variant:"outlined"},style:{border:`1px solid ${(t.vars||t).palette.divider}`}},{props:{variant:"elevation"},style:{boxShadow:"var(--Paper-shadow)",backgroundImage:"var(--Paper-overlay)"}}]}}))),Qn=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiPaper"}),r=jn(),{className:a,component:s="div",elevation:i=1,square:o=!1,variant:l="elevation",...u}=n,c={...n,component:s,elevation:i,square:o,variant:l},d=(e=>{const{square:t,elevation:n,variant:r,classes:a}=e,s={root:["root",r,!t&&"rounded","elevation"===r&&`elevation${n}`]};return(0,Bn.A)(s,Yn,a)})(c);return(0,$n.jsx)(Xn,{as:s,ownerState:c,className:(0,vn.A)(d.root,a),ref:t,...u,style:{..."elevation"===l&&{"--Paper-shadow":(r.vars||r).shadows[i],...r.vars&&{"--Paper-overlay":r.vars.overlays?.[i]},...!r.vars&&"dark"===r.palette.mode&&{"--Paper-overlay":`linear-gradient(${(0,Vn.X4)("#fff",(0,qn.A)(i))}, ${(0,Vn.X4)("#fff",(0,qn.A)(i))})`}},...u.style}})})),Zn=Qn;var Jn=n(1722),er=n(9436),tr=n(6598),nr=(n(3803),n(219),(0,Cn.w)((function(e,n){var r=e.styles,a=(0,tr.J)([r],void 0,t.useContext(Cn.T)),s=t.useRef();return(0,er.i)((function(){var e=n.key+"-global",t=new n.sheet.constructor({key:e,nonce:n.sheet.nonce,container:n.sheet.container,speedy:n.sheet.isSpeedy}),r=!1,i=document.querySelector('style[data-emotion="'+e+" "+a.name+'"]');return n.sheet.tags.length&&(t.before=n.sheet.tags[0]),null!==i&&(r=!0,i.setAttribute("data-emotion",e),t.hydrate([i])),s.current=[t,r],function(){t.flush()}}),[n]),(0,er.i)((function(){var e=s.current,t=e[0];if(e[1])e[1]=!1;else{if(void 0!==a.next&&(0,Jn.sk)(n,a.next,!0),t.tags.length){var r=t.tags[t.tags.length-1].nextElementSibling;t.before=r,t.flush()}n.insert("",a,t,!1)}}),[n,a.name]),null})));function rr(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return(0,tr.J)(t)}var ar=function(){var e=rr.apply(void 0,arguments),t="animation-"+e.name;return{name:t,styles:"@keyframes "+t+"{"+e.styles+"}",anim:1,toString:function(){return"_EMO_"+this.name+"_"+this.styles+"_EMO_"}}};function sr(e){const{styles:t,defaultTheme:n={}}=e,r="function"===typeof t?e=>{return t(void 0===(r=e)||null===r||0===Object.keys(r).length?n:e);var r}:t;return(0,$n.jsx)(nr,{styles:r})}const ir=function(e){let{styles:t,themeId:n,defaultTheme:r={}}=e;const a=_n(r),s="function"===typeof t?t(n&&a[n]||a):t;return(0,$n.jsx)(sr,{styles:s})};const or=function(e){return(0,$n.jsx)(ir,{...e,defaultTheme:Un.A,themeId:Mn.A})};var lr=n(6803);function ur(e){return(0,Kn.Ay)("MuiTypography",e)}(0,Fn.A)("MuiTypography",["root","h1","h2","h3","h4","h5","h6","subtitle1","subtitle2","body1","body2","inherit","button","caption","overline","alignLeft","alignRight","alignCenter","alignJustify","noWrap","gutterBottom","paragraph"]);const cr={primary:!0,secondary:!0,error:!0,info:!0,success:!0,warning:!0,textPrimary:!0,textSecondary:!0,textDisabled:!0},dr=Tn,hr=(0,Wn.Ay)("span",{name:"MuiTypography",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.variant&&t[n.variant],"inherit"!==n.align&&t[`align${(0,lr.A)(n.align)}`],n.noWrap&&t.noWrap,n.gutterBottom&&t.gutterBottom,n.paragraph&&t.paragraph]}})((0,Gn.A)((e=>{let{theme:t}=e;return{margin:0,variants:[{props:{variant:"inherit"},style:{font:"inherit",lineHeight:"inherit",letterSpacing:"inherit"}},...Object.entries(t.typography).filter((e=>{let[t,n]=e;return"inherit"!==t&&n&&"object"===typeof n})).map((e=>{let[t,n]=e;return{props:{variant:t},style:n}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars||t).palette[n].main}}})),...Object.entries(t.palette?.text||{}).filter((e=>{let[,t]=e;return"string"===typeof t})).map((e=>{let[n]=e;return{props:{color:`text${(0,lr.A)(n)}`},style:{color:(t.vars||t).palette.text[n]}}})),{props:e=>{let{ownerState:t}=e;return"inherit"!==t.align},style:{textAlign:"var(--Typography-textAlign)"}},{props:e=>{let{ownerState:t}=e;return t.noWrap},style:{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}},{props:e=>{let{ownerState:t}=e;return t.gutterBottom},style:{marginBottom:"0.35em"}},{props:e=>{let{ownerState:t}=e;return t.paragraph},style:{marginBottom:16}}]}}))),pr={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",subtitle1:"h6",subtitle2:"h6",body1:"p",body2:"p",inherit:"p"},fr=t.forwardRef((function(e,t){const{color:n,...r}=(0,Hn.b)({props:e,name:"MuiTypography"}),a=dr({...r,...!cr[n]&&{color:n}}),{align:s="inherit",className:i,component:o,gutterBottom:l=!1,noWrap:u=!1,paragraph:c=!1,variant:d="body1",variantMapping:h=pr,...p}=a,f={...a,align:s,color:n,className:i,component:o,gutterBottom:l,noWrap:u,paragraph:c,variant:d,variantMapping:h},m=o||(c?"p":h[d]||pr[d])||"span",g=(e=>{const{align:t,gutterBottom:n,noWrap:r,paragraph:a,variant:s,classes:i}=e,o={root:["root",s,"inherit"!==e.align&&`align${(0,lr.A)(t)}`,n&&"gutterBottom",r&&"noWrap",a&&"paragraph"]};return(0,Bn.A)(o,ur,i)})(f);return(0,$n.jsx)(hr,{as:m,ref:t,className:(0,vn.A)(g.root,i),...p,ownerState:f,style:{..."inherit"!==s&&{"--Typography-textAlign":s},...p.style}})})),mr=fr;var gr=n(5844),yr=n(7868),br=n(3462),vr=n(3940),xr=n(4440),wr=n(3468);function kr(e){return parseInt(e,10)||0}const Sr={visibility:"hidden",position:"absolute",overflow:"hidden",height:0,top:0,left:0,transform:"translateZ(0)"};const Ir=t.forwardRef((function(e,n){const{onChange:r,maxRows:a,minRows:s=1,style:i,value:o,...l}=e,{current:u}=t.useRef(null!=o),c=t.useRef(null),d=(0,br.A)(n,c),h=t.useRef(null),p=t.useRef(null),f=t.useCallback((()=>{const t=c.current,n=(0,vr.A)(t).getComputedStyle(t);if("0px"===n.width)return{outerHeightStyle:0,overflowing:!1};const r=p.current;r.style.width=n.width,r.value=t.value||e.placeholder||"x","\n"===r.value.slice(-1)&&(r.value+=" ");const i=n.boxSizing,o=kr(n.paddingBottom)+kr(n.paddingTop),l=kr(n.borderBottomWidth)+kr(n.borderTopWidth),u=r.scrollHeight;r.value="x";const d=r.scrollHeight;let h=u;s&&(h=Math.max(Number(s)*d,h)),a&&(h=Math.min(Number(a)*d,h)),h=Math.max(h,d);return{outerHeightStyle:h+("border-box"===i?o+l:0),overflowing:Math.abs(h-u)<=1}}),[a,s,e.placeholder]),m=t.useCallback((()=>{const e=f();if(void 0===(t=e)||null===t||0===Object.keys(t).length||0===t.outerHeightStyle&&!t.overflowing)return;var t;const n=e.outerHeightStyle,r=c.current;h.current!==n&&(h.current=n,r.style.height=`${n}px`),r.style.overflow=e.overflowing?"hidden":""}),[f]);(0,xr.A)((()=>{const e=()=>{m()};let t;const n=(0,wr.A)(e),r=c.current,a=(0,vr.A)(r);let s;return a.addEventListener("resize",n),"undefined"!==typeof ResizeObserver&&(s=new ResizeObserver(e),s.observe(r)),()=>{n.clear(),cancelAnimationFrame(t),a.removeEventListener("resize",n),s&&s.disconnect()}}),[f,m]),(0,xr.A)((()=>{m()}));return(0,$n.jsxs)(t.Fragment,{children:[(0,$n.jsx)("textarea",{value:o,onChange:e=>{u||m(),r&&r(e)},ref:d,rows:s,style:i,...l}),(0,$n.jsx)("textarea",{"aria-hidden":!0,className:e.className,readOnly:!0,ref:p,tabIndex:-1,style:{...Sr,...i,paddingTop:0,paddingBottom:0}})]})})),Tr=Ir;const Nr=function(e){return"string"===typeof e};function Cr(e){let{props:t,states:n,muiFormControl:r}=e;return n.reduce(((e,n)=>(e[n]=t[n],r&&"undefined"===typeof t[n]&&(e[n]=r[n]),e)),{})}const Ar=t.createContext(void 0);function Er(){return t.useContext(Ar)}var _r=n(5849),$r=n(5013);function Rr(e){return null!=e&&!(Array.isArray(e)&&0===e.length)}function Dr(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return e&&(Rr(e.value)&&""!==e.value||t&&Rr(e.defaultValue)&&""!==e.defaultValue)}function Mr(e){return(0,Kn.Ay)("MuiInputBase",e)}const Fr=(0,Fn.A)("MuiInputBase",["root","formControl","focused","disabled","adornedStart","adornedEnd","error","sizeSmall","multiline","colorSecondary","fullWidth","hiddenLabel","readOnly","input","inputSizeSmall","inputMultiline","inputTypeSearch","inputAdornedStart","inputAdornedEnd","inputHiddenLabel"]);var Or;const Pr=(e,t)=>{const{ownerState:n}=e;return[t.root,n.formControl&&t.formControl,n.startAdornment&&t.adornedStart,n.endAdornment&&t.adornedEnd,n.error&&t.error,"small"===n.size&&t.sizeSmall,n.multiline&&t.multiline,n.color&&t[`color${(0,lr.A)(n.color)}`],n.fullWidth&&t.fullWidth,n.hiddenLabel&&t.hiddenLabel]},Lr=(e,t)=>{const{ownerState:n}=e;return[t.input,"small"===n.size&&t.inputSizeSmall,n.multiline&&t.inputMultiline,"search"===n.type&&t.inputTypeSearch,n.startAdornment&&t.inputAdornedStart,n.endAdornment&&t.inputAdornedEnd,n.hiddenLabel&&t.inputHiddenLabel]},zr=(0,Wn.Ay)("div",{name:"MuiInputBase",slot:"Root",overridesResolver:Pr})((0,Gn.A)((e=>{let{theme:t}=e;return{...t.typography.body1,color:(t.vars||t).palette.text.primary,lineHeight:"1.4375em",boxSizing:"border-box",position:"relative",cursor:"text",display:"inline-flex",alignItems:"center",[`&.${Fr.disabled}`]:{color:(t.vars||t).palette.text.disabled,cursor:"default"},variants:[{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:"4px 0 5px"}},{props:e=>{let{ownerState:t,size:n}=e;return t.multiline&&"small"===n},style:{paddingTop:1}},{props:e=>{let{ownerState:t}=e;return t.fullWidth},style:{width:"100%"}}]}}))),Br=(0,Wn.Ay)("input",{name:"MuiInputBase",slot:"Input",overridesResolver:Lr})((0,Gn.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode,r={color:"currentColor",...t.vars?{opacity:t.vars.opacity.inputPlaceholder}:{opacity:n?.42:.5},transition:t.transitions.create("opacity",{duration:t.transitions.duration.shorter})},a={opacity:"0 !important"},s=t.vars?{opacity:t.vars.opacity.inputPlaceholder}:{opacity:n?.42:.5};return{font:"inherit",letterSpacing:"inherit",color:"currentColor",padding:"4px 0 5px",border:0,boxSizing:"content-box",background:"none",height:"1.4375em",margin:0,WebkitTapHighlightColor:"transparent",display:"block",minWidth:0,width:"100%","&::-webkit-input-placeholder":r,"&::-moz-placeholder":r,"&::-ms-input-placeholder":r,"&:focus":{outline:0},"&:invalid":{boxShadow:"none"},"&::-webkit-search-decoration":{WebkitAppearance:"none"},[`label[data-shrink=false] + .${Fr.formControl} &`]:{"&::-webkit-input-placeholder":a,"&::-moz-placeholder":a,"&::-ms-input-placeholder":a,"&:focus::-webkit-input-placeholder":s,"&:focus::-moz-placeholder":s,"&:focus::-ms-input-placeholder":s},[`&.${Fr.disabled}`]:{opacity:1,WebkitTextFillColor:(t.vars||t).palette.text.disabled},variants:[{props:e=>{let{ownerState:t}=e;return!t.disableInjectingGlobalStyles},style:{animationName:"mui-auto-fill-cancel",animationDuration:"10ms","&:-webkit-autofill":{animationDuration:"5000s",animationName:"mui-auto-fill"}}},{props:{size:"small"},style:{paddingTop:1}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{height:"auto",resize:"none",padding:0,paddingTop:0}},{props:{type:"search"},style:{MozAppearance:"textfield"}}]}}))),Vr=function(e){return function(t){return(0,$n.jsx)(or,{styles:"function"===typeof e?n=>e({theme:n,...t}):e})}}({"@keyframes mui-auto-fill":{from:{display:"block"}},"@keyframes mui-auto-fill-cancel":{from:{display:"block"}}}),Wr=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiInputBase"}),{"aria-describedby":a,autoComplete:s,autoFocus:i,className:o,color:l,components:u={},componentsProps:c={},defaultValue:d,disabled:h,disableInjectingGlobalStyles:p,endAdornment:f,error:m,fullWidth:g=!1,id:y,inputComponent:b="input",inputProps:v={},inputRef:x,margin:w,maxRows:k,minRows:S,multiline:I=!1,name:T,onBlur:N,onChange:C,onClick:A,onFocus:E,onKeyDown:_,onKeyUp:$,placeholder:R,readOnly:D,renderSuffix:M,rows:F,size:O,slotProps:P={},slots:L={},startAdornment:z,type:B="text",value:V,...W}=r,U=null!=v.value?v.value:V,{current:j}=t.useRef(null!=U),G=t.useRef(),H=t.useCallback((e=>{0}),[]),q=(0,_r.A)(G,x,v.ref,H),[K,Y]=t.useState(!1),X=Er();const Q=Cr({props:r,muiFormControl:X,states:["color","disabled","error","hiddenLabel","size","required","filled"]});Q.focused=X?X.focused:K,t.useEffect((()=>{!X&&h&&K&&(Y(!1),N&&N())}),[X,h,K,N]);const Z=X&&X.onFilled,J=X&&X.onEmpty,ee=t.useCallback((e=>{Dr(e)?Z&&Z():J&&J()}),[Z,J]);(0,$r.A)((()=>{j&&ee({value:U})}),[U,ee,j]);t.useEffect((()=>{ee(G.current)}),[]);let te=b,ne=v;I&&"input"===te&&(ne=F?{type:void 0,minRows:F,maxRows:F,...ne}:{type:void 0,maxRows:k,minRows:S,...ne},te=Tr);t.useEffect((()=>{X&&X.setAdornedStart(Boolean(z))}),[X,z]);const re={...r,color:Q.color||"primary",disabled:Q.disabled,endAdornment:f,error:Q.error,focused:Q.focused,formControl:X,fullWidth:g,hiddenLabel:Q.hiddenLabel,multiline:I,size:Q.size,startAdornment:z,type:B},ae=(e=>{const{classes:t,color:n,disabled:r,error:a,endAdornment:s,focused:i,formControl:o,fullWidth:l,hiddenLabel:u,multiline:c,readOnly:d,size:h,startAdornment:p,type:f}=e,m={root:["root",`color${(0,lr.A)(n)}`,r&&"disabled",a&&"error",l&&"fullWidth",i&&"focused",o&&"formControl",h&&"medium"!==h&&`size${(0,lr.A)(h)}`,c&&"multiline",p&&"adornedStart",s&&"adornedEnd",u&&"hiddenLabel",d&&"readOnly"],input:["input",r&&"disabled","search"===f&&"inputTypeSearch",c&&"inputMultiline","small"===h&&"inputSizeSmall",u&&"inputHiddenLabel",p&&"inputAdornedStart",s&&"inputAdornedEnd",d&&"readOnly"]};return(0,Bn.A)(m,Mr,t)})(re),se=L.root||u.Root||zr,ie=P.root||c.root||{},oe=L.input||u.Input||Br;return ne={...ne,...P.input??c.input},(0,$n.jsxs)(t.Fragment,{children:[!p&&"function"===typeof Vr&&(Or||(Or=(0,$n.jsx)(Vr,{}))),(0,$n.jsxs)(se,{...ie,ref:n,onClick:e=>{G.current&&e.currentTarget===e.target&&G.current.focus(),A&&A(e)},...W,...!Nr(se)&&{ownerState:{...re,...ie.ownerState}},className:(0,vn.A)(ae.root,ie.className,o,D&&"MuiInputBase-readOnly"),children:[z,(0,$n.jsx)(Ar.Provider,{value:null,children:(0,$n.jsx)(oe,{"aria-invalid":Q.error,"aria-describedby":a,autoComplete:s,autoFocus:i,defaultValue:d,disabled:Q.disabled,id:y,onAnimationStart:e=>{ee("mui-auto-fill-cancel"===e.animationName?G.current:{value:"x"})},name:T,placeholder:R,readOnly:D,required:Q.required,rows:F,value:U,onKeyDown:_,onKeyUp:$,type:B,...ne,...!Nr(oe)&&{as:te,ownerState:{...re,...ne.ownerState}},ref:q,className:(0,vn.A)(ae.input,ne.className,D&&"MuiInputBase-readOnly"),onBlur:e=>{N&&N(e),v.onBlur&&v.onBlur(e),X&&X.onBlur?X.onBlur(e):Y(!1)},onChange:function(e){if(!j){const t=e.target||G.current;if(null==t)throw new Error((0,yr.A)(1));ee({value:t.value})}for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];v.onChange&&v.onChange(e,...n),C&&C(e,...n)},onFocus:e=>{E&&E(e),v.onFocus&&v.onFocus(e),X&&X.onFocus?X.onFocus(e):Y(!0)}})}),f,M?M({...Q,startAdornment:z}):null]})]})})),Ur=Wr;var jr=n(1475);function Gr(e){return(0,Kn.Ay)("MuiInput",e)}const Hr={...Fr,...(0,Fn.A)("MuiInput",["root","underline","input"])},qr=(0,Wn.Ay)(zr,{shouldForwardProp:e=>(0,jr.A)(e)||"classes"===e,name:"MuiInput",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[...Pr(e,t),!n.disableUnderline&&t.underline]}})((0,Gn.A)((e=>{let{theme:t}=e;let n="light"===t.palette.mode?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)";return t.vars&&(n=`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`),{position:"relative",variants:[{props:e=>{let{ownerState:t}=e;return t.formControl},style:{"label + &":{marginTop:16}}},{props:e=>{let{ownerState:t}=e;return!t.disableUnderline},style:{"&::after":{left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${Hr.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${Hr.error}`]:{"&::before, &::after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${n}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${Hr.disabled}, .${Hr.error}):before`]:{borderBottom:`2px solid ${(t.vars||t).palette.text.primary}`,"@media (hover: none)":{borderBottom:`1px solid ${n}`}},[`&.${Hr.disabled}:before`]:{borderBottomStyle:"dotted"}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n,disableUnderline:!1},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[n].main}`}}}}))]}}))),Kr=(0,Wn.Ay)(Br,{name:"MuiInput",slot:"Input",overridesResolver:Lr})({}),Yr=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiInput"}),{disableUnderline:r=!1,components:a={},componentsProps:s,fullWidth:i=!1,inputComponent:o="input",multiline:l=!1,slotProps:u,slots:c={},type:d="text",...h}=n,p=(e=>{const{classes:t,disableUnderline:n}=e,r={root:["root",!n&&"underline"],input:["input"]},a=(0,Bn.A)(r,Gr,t);return{...t,...a}})(n),f={root:{ownerState:{disableUnderline:r}}},m=u??s?(0,kn.A)(u??s,f):f,g=c.root??a.Root??qr,y=c.input??a.Input??Kr;return(0,$n.jsx)(Ur,{slots:{root:g,input:y},slotProps:m,fullWidth:i,inputComponent:o,multiline:l,ref:t,type:d,...h,classes:p})}));Yr&&(Yr.muiName="Input");const Xr=Yr;function Qr(e){return(0,Kn.Ay)("MuiFilledInput",e)}const Zr={...Fr,...(0,Fn.A)("MuiFilledInput",["root","underline","input","adornedStart","adornedEnd","sizeSmall","multiline","hiddenLabel"])},Jr=(0,Wn.Ay)(zr,{shouldForwardProp:e=>(0,jr.A)(e)||"classes"===e,name:"MuiFilledInput",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[...Pr(e,t),!n.disableUnderline&&t.underline]}})((0,Gn.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode,r=n?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)",a=n?"rgba(0, 0, 0, 0.06)":"rgba(255, 255, 255, 0.09)",s=n?"rgba(0, 0, 0, 0.09)":"rgba(255, 255, 255, 0.13)",i=n?"rgba(0, 0, 0, 0.12)":"rgba(255, 255, 255, 0.12)";return{position:"relative",backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a,borderTopLeftRadius:(t.vars||t).shape.borderRadius,borderTopRightRadius:(t.vars||t).shape.borderRadius,transition:t.transitions.create("background-color",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),"&:hover":{backgroundColor:t.vars?t.vars.palette.FilledInput.hoverBg:s,"@media (hover: none)":{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a}},[`&.${Zr.focused}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a},[`&.${Zr.disabled}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.disabledBg:i},variants:[{props:e=>{let{ownerState:t}=e;return!t.disableUnderline},style:{"&::after":{left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${Zr.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${Zr.error}`]:{"&::before, &::after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`:r}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${Zr.disabled}, .${Zr.error}):before`]:{borderBottom:`1px solid ${(t.vars||t).palette.text.primary}`},[`&.${Zr.disabled}:before`]:{borderBottomStyle:"dotted"}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{disableUnderline:!1,color:n},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[n]?.main}`}}}})),{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:12}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:12}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:"25px 12px 8px"}},{props:e=>{let{ownerState:t,size:n}=e;return t.multiline&&"small"===n},style:{paddingTop:21,paddingBottom:4}},{props:e=>{let{ownerState:t}=e;return t.multiline&&t.hiddenLabel},style:{paddingTop:16,paddingBottom:17}},{props:e=>{let{ownerState:t}=e;return t.multiline&&t.hiddenLabel&&"small"===t.size},style:{paddingTop:8,paddingBottom:9}}]}}))),ea=(0,Wn.Ay)(Br,{name:"MuiFilledInput",slot:"Input",overridesResolver:Lr})((0,Gn.A)((e=>{let{theme:t}=e;return{paddingTop:25,paddingRight:12,paddingBottom:8,paddingLeft:12,...!t.vars&&{"&:-webkit-autofill":{WebkitBoxShadow:"light"===t.palette.mode?null:"0 0 0 100px #266798 inset",WebkitTextFillColor:"light"===t.palette.mode?null:"#fff",caretColor:"light"===t.palette.mode?null:"#fff",borderTopLeftRadius:"inherit",borderTopRightRadius:"inherit"}},...t.vars&&{"&:-webkit-autofill":{borderTopLeftRadius:"inherit",borderTopRightRadius:"inherit"},[t.getColorSchemeSelector("dark")]:{"&:-webkit-autofill":{WebkitBoxShadow:"0 0 0 100px #266798 inset",WebkitTextFillColor:"#fff",caretColor:"#fff"}}},variants:[{props:{size:"small"},style:{paddingTop:21,paddingBottom:4}},{props:e=>{let{ownerState:t}=e;return t.hiddenLabel},style:{paddingTop:16,paddingBottom:17}},{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:0}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:0}},{props:e=>{let{ownerState:t}=e;return t.hiddenLabel&&"small"===t.size},style:{paddingTop:8,paddingBottom:9}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{paddingTop:0,paddingBottom:0,paddingLeft:0,paddingRight:0}}]}}))),ta=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiFilledInput"}),{disableUnderline:r=!1,components:a={},componentsProps:s,fullWidth:i=!1,hiddenLabel:o,inputComponent:l="input",multiline:u=!1,slotProps:c,slots:d={},type:h="text",...p}=n,f={...n,disableUnderline:r,fullWidth:i,inputComponent:l,multiline:u,type:h},m=(e=>{const{classes:t,disableUnderline:n,startAdornment:r,endAdornment:a,size:s,hiddenLabel:i,multiline:o}=e,l={root:["root",!n&&"underline",r&&"adornedStart",a&&"adornedEnd","small"===s&&`size${(0,lr.A)(s)}`,i&&"hiddenLabel",o&&"multiline"],input:["input"]},u=(0,Bn.A)(l,Qr,t);return{...t,...u}})(n),g={root:{ownerState:f},input:{ownerState:f}},y=c??s?(0,kn.A)(g,c??s):g,b=d.root??a.Root??Jr,v=d.input??a.Input??ea;return(0,$n.jsx)(Ur,{slots:{root:b,input:v},componentsProps:y,fullWidth:i,inputComponent:l,multiline:u,ref:t,type:h,...p,classes:m})}));ta&&(ta.muiName="Input");const na=ta;var ra;const aa=(0,Wn.Ay)("fieldset",{shouldForwardProp:jr.A})({textAlign:"left",position:"absolute",bottom:0,right:0,top:-5,left:0,margin:0,padding:"0 8px",pointerEvents:"none",borderRadius:"inherit",borderStyle:"solid",borderWidth:1,overflow:"hidden",minWidth:"0%"}),sa=(0,Wn.Ay)("legend",{shouldForwardProp:jr.A})((0,Gn.A)((e=>{let{theme:t}=e;return{float:"unset",width:"auto",overflow:"hidden",variants:[{props:e=>{let{ownerState:t}=e;return!t.withLabel},style:{padding:0,lineHeight:"11px",transition:t.transitions.create("width",{duration:150,easing:t.transitions.easing.easeOut})}},{props:e=>{let{ownerState:t}=e;return t.withLabel},style:{display:"block",padding:0,height:11,fontSize:"0.75em",visibility:"hidden",maxWidth:.01,transition:t.transitions.create("max-width",{duration:50,easing:t.transitions.easing.easeOut}),whiteSpace:"nowrap","& > span":{paddingLeft:5,paddingRight:5,display:"inline-block",opacity:0,visibility:"visible"}}},{props:e=>{let{ownerState:t}=e;return t.withLabel&&t.notched},style:{maxWidth:"100%",transition:t.transitions.create("max-width",{duration:100,easing:t.transitions.easing.easeOut,delay:50})}}]}})));function ia(e){return(0,Kn.Ay)("MuiOutlinedInput",e)}const oa={...Fr,...(0,Fn.A)("MuiOutlinedInput",["root","notchedOutline","input"])},la=(0,Wn.Ay)(zr,{shouldForwardProp:e=>(0,jr.A)(e)||"classes"===e,name:"MuiOutlinedInput",slot:"Root",overridesResolver:Pr})((0,Gn.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{position:"relative",borderRadius:(t.vars||t).shape.borderRadius,[`&:hover .${oa.notchedOutline}`]:{borderColor:(t.vars||t).palette.text.primary},[`&.${oa.focused} .${oa.notchedOutline}`]:{borderWidth:2},variants:[...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{[`&.${oa.focused} .${oa.notchedOutline}`]:{borderColor:(t.vars||t).palette[n].main}}}})),{props:{},style:{"@media (hover: none)":{[`&:hover .${oa.notchedOutline}`]:{borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}},[`&.${oa.error} .${oa.notchedOutline}`]:{borderColor:(t.vars||t).palette.error.main},[`&.${oa.disabled} .${oa.notchedOutline}`]:{borderColor:(t.vars||t).palette.action.disabled}}},{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:14}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:14}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:"16.5px 14px"}},{props:e=>{let{ownerState:t,size:n}=e;return t.multiline&&"small"===n},style:{padding:"8.5px 14px"}}]}}))),ua=(0,Wn.Ay)((function(e){const{children:t,classes:n,className:r,label:a,notched:s,...i}=e,o=null!=a&&""!==a,l={...e,notched:s,withLabel:o};return(0,$n.jsx)(aa,{"aria-hidden":!0,className:r,ownerState:l,...i,children:(0,$n.jsx)(sa,{ownerState:l,children:o?(0,$n.jsx)("span",{children:a}):ra||(ra=(0,$n.jsx)("span",{className:"notranslate",children:"\u200b"}))})})}),{name:"MuiOutlinedInput",slot:"NotchedOutline",overridesResolver:(e,t)=>t.notchedOutline})((0,Gn.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}}))),ca=(0,Wn.Ay)(Br,{name:"MuiOutlinedInput",slot:"Input",overridesResolver:Lr})((0,Gn.A)((e=>{let{theme:t}=e;return{padding:"16.5px 14px",...!t.vars&&{"&:-webkit-autofill":{WebkitBoxShadow:"light"===t.palette.mode?null:"0 0 0 100px #266798 inset",WebkitTextFillColor:"light"===t.palette.mode?null:"#fff",caretColor:"light"===t.palette.mode?null:"#fff",borderRadius:"inherit"}},...t.vars&&{"&:-webkit-autofill":{borderRadius:"inherit"},[t.getColorSchemeSelector("dark")]:{"&:-webkit-autofill":{WebkitBoxShadow:"0 0 0 100px #266798 inset",WebkitTextFillColor:"#fff",caretColor:"#fff"}}},variants:[{props:{size:"small"},style:{padding:"8.5px 14px"}},{props:e=>{let{ownerState:t}=e;return t.multiline},style:{padding:0}},{props:e=>{let{ownerState:t}=e;return t.startAdornment},style:{paddingLeft:0}},{props:e=>{let{ownerState:t}=e;return t.endAdornment},style:{paddingRight:0}}]}}))),da=t.forwardRef((function(e,n){var r;const a=(0,Hn.b)({props:e,name:"MuiOutlinedInput"}),{components:s={},fullWidth:i=!1,inputComponent:o="input",label:l,multiline:u=!1,notched:c,slots:d={},type:h="text",...p}=a,f=(e=>{const{classes:t}=e,n=(0,Bn.A)({root:["root"],notchedOutline:["notchedOutline"],input:["input"]},ia,t);return{...t,...n}})(a),m=Er(),g=Cr({props:a,muiFormControl:m,states:["color","disabled","error","focused","hiddenLabel","size","required"]}),y={...a,color:g.color||"primary",disabled:g.disabled,error:g.error,focused:g.focused,formControl:m,fullWidth:i,hiddenLabel:g.hiddenLabel,multiline:u,size:g.size,type:h},b=d.root??s.Root??la,v=d.input??s.Input??ca;return(0,$n.jsx)(Ur,{slots:{root:b,input:v},renderSuffix:e=>(0,$n.jsx)(ua,{ownerState:y,className:f.notchedOutline,label:null!=l&&""!==l&&g.required?r||(r=(0,$n.jsxs)(t.Fragment,{children:[l,"\u2009","*"]})):l,notched:"undefined"!==typeof c?c:Boolean(e.startAdornment||e.filled||e.focused)}),fullWidth:i,inputComponent:o,multiline:u,ref:n,type:h,...p,classes:{...f,notchedOutline:null}})}));da&&(da.muiName="Input");const ha=da;function pa(e){return(0,Kn.Ay)("MuiFormLabel",e)}const fa=(0,Fn.A)("MuiFormLabel",["root","colorSecondary","focused","disabled","error","filled","required","asterisk"]),ma=(0,Wn.Ay)("label",{name:"MuiFormLabel",slot:"Root",overridesResolver:(e,t)=>{let{ownerState:n}=e;return{...t.root,..."secondary"===n.color&&t.colorSecondary,...n.filled&&t.filled}}})((0,Gn.A)((e=>{let{theme:t}=e;return{color:(t.vars||t).palette.text.secondary,...t.typography.body1,lineHeight:"1.4375em",padding:0,position:"relative",variants:[...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{[`&.${fa.focused}`]:{color:(t.vars||t).palette[n].main}}}})),{props:{},style:{[`&.${fa.disabled}`]:{color:(t.vars||t).palette.text.disabled},[`&.${fa.error}`]:{color:(t.vars||t).palette.error.main}}}]}}))),ga=(0,Wn.Ay)("span",{name:"MuiFormLabel",slot:"Asterisk",overridesResolver:(e,t)=>t.asterisk})((0,Gn.A)((e=>{let{theme:t}=e;return{[`&.${fa.error}`]:{color:(t.vars||t).palette.error.main}}}))),ya=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiFormLabel"}),{children:r,className:a,color:s,component:i="label",disabled:o,error:l,filled:u,focused:c,required:d,...h}=n,p=Cr({props:n,muiFormControl:Er(),states:["color","required","focused","disabled","error","filled"]}),f={...n,color:p.color||"primary",component:i,disabled:p.disabled,error:p.error,filled:p.filled,focused:p.focused,required:p.required},m=(e=>{const{classes:t,color:n,focused:r,disabled:a,error:s,filled:i,required:o}=e,l={root:["root",`color${(0,lr.A)(n)}`,a&&"disabled",s&&"error",i&&"filled",r&&"focused",o&&"required"],asterisk:["asterisk",s&&"error"]};return(0,Bn.A)(l,pa,t)})(f);return(0,$n.jsxs)(ma,{as:i,ownerState:f,className:(0,vn.A)(m.root,a),ref:t,...h,children:[r,p.required&&(0,$n.jsxs)(ga,{ownerState:f,"aria-hidden":!0,className:m.asterisk,children:["\u2009","*"]})]})}));function ba(e){return(0,Kn.Ay)("MuiInputLabel",e)}(0,Fn.A)("MuiInputLabel",["root","focused","disabled","error","required","asterisk","formControl","sizeSmall","shrink","animated","standard","filled","outlined"]);const va=(0,Wn.Ay)(ya,{shouldForwardProp:e=>(0,jr.A)(e)||"classes"===e,name:"MuiInputLabel",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[{[`& .${fa.asterisk}`]:t.asterisk},t.root,n.formControl&&t.formControl,"small"===n.size&&t.sizeSmall,n.shrink&&t.shrink,!n.disableAnimation&&t.animated,n.focused&&t.focused,t[n.variant]]}})((0,Gn.A)((e=>{let{theme:t}=e;return{display:"block",transformOrigin:"top left",whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis",maxWidth:"100%",variants:[{props:e=>{let{ownerState:t}=e;return t.formControl},style:{position:"absolute",left:0,top:0,transform:"translate(0, 20px) scale(1)"}},{props:{size:"small"},style:{transform:"translate(0, 17px) scale(1)"}},{props:e=>{let{ownerState:t}=e;return t.shrink},style:{transform:"translate(0, -1.5px) scale(0.75)",transformOrigin:"top left",maxWidth:"133%"}},{props:e=>{let{ownerState:t}=e;return!t.disableAnimation},style:{transition:t.transitions.create(["color","transform","max-width"],{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut})}},{props:{variant:"filled"},style:{zIndex:1,pointerEvents:"none",transform:"translate(12px, 16px) scale(1)",maxWidth:"calc(100% - 24px)"}},{props:{variant:"filled",size:"small"},style:{transform:"translate(12px, 13px) scale(1)"}},{props:e=>{let{variant:t,ownerState:n}=e;return"filled"===t&&n.shrink},style:{userSelect:"none",pointerEvents:"auto",transform:"translate(12px, 7px) scale(0.75)",maxWidth:"calc(133% - 24px)"}},{props:e=>{let{variant:t,ownerState:n,size:r}=e;return"filled"===t&&n.shrink&&"small"===r},style:{transform:"translate(12px, 4px) scale(0.75)"}},{props:{variant:"outlined"},style:{zIndex:1,pointerEvents:"none",transform:"translate(14px, 16px) scale(1)",maxWidth:"calc(100% - 24px)"}},{props:{variant:"outlined",size:"small"},style:{transform:"translate(14px, 9px) scale(1)"}},{props:e=>{let{variant:t,ownerState:n}=e;return"outlined"===t&&n.shrink},style:{userSelect:"none",pointerEvents:"auto",maxWidth:"calc(133% - 32px)",transform:"translate(14px, -9px) scale(0.75)"}}]}}))),xa=t.forwardRef((function(e,t){const n=(0,Hn.b)({name:"MuiInputLabel",props:e}),{disableAnimation:r=!1,margin:a,shrink:s,variant:i,className:o,...l}=n,u=Er();let c=s;"undefined"===typeof c&&u&&(c=u.filled||u.focused||u.adornedStart);const d=Cr({props:n,muiFormControl:u,states:["size","variant","required","focused"]}),h={...n,disableAnimation:r,formControl:u,shrink:c,size:d.size,variant:d.variant,required:d.required,focused:d.focused},p=(e=>{const{classes:t,formControl:n,size:r,shrink:a,disableAnimation:s,variant:i,required:o}=e,l={root:["root",n&&"formControl",!s&&"animated",a&&"shrink",r&&"normal"!==r&&`size${(0,lr.A)(r)}`,i],asterisk:[o&&"asterisk"]},u=(0,Bn.A)(l,ba,t);return{...t,...u}})(h);return(0,$n.jsx)(va,{"data-shrink":c,ref:t,className:(0,vn.A)(p.root,o),...l,ownerState:h,classes:p})})),wa=xa;var ka=n(7328);function Sa(e){return(0,Kn.Ay)("MuiFormControl",e)}(0,Fn.A)("MuiFormControl",["root","marginNone","marginNormal","marginDense","fullWidth","disabled"]);const Ia=(0,Wn.Ay)("div",{name:"MuiFormControl",slot:"Root",overridesResolver:(e,t)=>{let{ownerState:n}=e;return{...t.root,...t[`margin${(0,lr.A)(n.margin)}`],...n.fullWidth&&t.fullWidth}}})({display:"inline-flex",flexDirection:"column",position:"relative",minWidth:0,padding:0,margin:0,border:0,verticalAlign:"top",variants:[{props:{margin:"normal"},style:{marginTop:16,marginBottom:8}},{props:{margin:"dense"},style:{marginTop:8,marginBottom:4}},{props:{fullWidth:!0},style:{width:"100%"}}]}),Ta=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiFormControl"}),{children:a,className:s,color:i="primary",component:o="div",disabled:l=!1,error:u=!1,focused:c,fullWidth:d=!1,hiddenLabel:h=!1,margin:p="none",required:f=!1,size:m="medium",variant:g="outlined",...y}=r,b={...r,color:i,component:o,disabled:l,error:u,fullWidth:d,hiddenLabel:h,margin:p,required:f,size:m,variant:g},v=(e=>{const{classes:t,margin:n,fullWidth:r}=e,a={root:["root","none"!==n&&`margin${(0,lr.A)(n)}`,r&&"fullWidth"]};return(0,Bn.A)(a,Sa,t)})(b),[x,w]=t.useState((()=>{let e=!1;return a&&t.Children.forEach(a,(t=>{if(!(0,ka.A)(t,["Input","Select"]))return;const n=(0,ka.A)(t,["Select"])?t.props.input:t;n&&n.props.startAdornment&&(e=!0)})),e})),[k,S]=t.useState((()=>{let e=!1;return a&&t.Children.forEach(a,(t=>{(0,ka.A)(t,["Input","Select"])&&(Dr(t.props,!0)||Dr(t.props.inputProps,!0))&&(e=!0)})),e})),[I,T]=t.useState(!1);l&&I&&T(!1);const N=void 0===c||l?I:c;let C;const A=t.useMemo((()=>({adornedStart:x,setAdornedStart:w,color:i,disabled:l,error:u,filled:k,focused:N,fullWidth:d,hiddenLabel:h,size:m,onBlur:()=>{T(!1)},onEmpty:()=>{S(!1)},onFilled:()=>{S(!0)},onFocus:()=>{T(!0)},registerEffect:C,required:f,variant:g})),[x,i,l,u,k,N,d,h,C,f,m,g]);return(0,$n.jsx)(Ar.Provider,{value:A,children:(0,$n.jsx)(Ia,{as:o,ownerState:b,className:(0,vn.A)(v.root,s),ref:n,...y,children:a})})})),Na=Ta;function Ca(e){return(0,Kn.Ay)("MuiFormHelperText",e)}const Aa=(0,Fn.A)("MuiFormHelperText",["root","error","disabled","sizeSmall","sizeMedium","contained","focused","filled","required"]);var Ea;const _a=(0,Wn.Ay)("p",{name:"MuiFormHelperText",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.size&&t[`size${(0,lr.A)(n.size)}`],n.contained&&t.contained,n.filled&&t.filled]}})((0,Gn.A)((e=>{let{theme:t}=e;return{color:(t.vars||t).palette.text.secondary,...t.typography.caption,textAlign:"left",marginTop:3,marginRight:0,marginBottom:0,marginLeft:0,[`&.${Aa.disabled}`]:{color:(t.vars||t).palette.text.disabled},[`&.${Aa.error}`]:{color:(t.vars||t).palette.error.main},variants:[{props:{size:"small"},style:{marginTop:4}},{props:e=>{let{ownerState:t}=e;return t.contained},style:{marginLeft:14,marginRight:14}}]}}))),$a=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiFormHelperText"}),{children:r,className:a,component:s="p",disabled:i,error:o,filled:l,focused:u,margin:c,required:d,variant:h,...p}=n,f=Cr({props:n,muiFormControl:Er(),states:["variant","size","disabled","error","filled","focused","required"]}),m={...n,component:s,contained:"filled"===f.variant||"outlined"===f.variant,variant:f.variant,size:f.size,disabled:f.disabled,error:f.error,filled:f.filled,focused:f.focused,required:f.required};delete m.ownerState;const g=(e=>{const{classes:t,contained:n,size:r,disabled:a,error:s,filled:i,focused:o,required:l}=e,u={root:["root",a&&"disabled",s&&"error",r&&`size${(0,lr.A)(r)}`,n&&"contained",o&&"focused",i&&"filled",l&&"required"]};return(0,Bn.A)(u,Ca,t)})(m);return(0,$n.jsx)(_a,{as:s,className:(0,vn.A)(g.root,a),ref:t,...p,ownerState:m,children:" "===r?Ea||(Ea=(0,$n.jsx)("span",{className:"notranslate",children:"\u200b"})):r})}));function Ra(e){return e&&t.isValidElement(e)?e.props.propertyIsEnumerable("ref")?e.props.ref:e.ref:null}n(2086);var Da=n(2427);const Ma=t.createContext();const Fa=()=>t.useContext(Ma)??!1;const Oa=function(e){return"string"===typeof e};const Pa=function(e,t,n){return void 0===e||Oa(e)?t:{...t,ownerState:{...t.ownerState,...n}}};const La=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];if(void 0===e)return{};const n={};return Object.keys(e).filter((n=>n.match(/^on[A-Z]/)&&"function"===typeof e[n]&&!t.includes(n))).forEach((t=>{n[t]=e[t]})),n};const za=function(e){if(void 0===e)return{};const t={};return Object.keys(e).filter((t=>!(t.match(/^on[A-Z]/)&&"function"===typeof e[t]))).forEach((n=>{t[n]=e[n]})),t};const Ba=function(e){const{getSlotProps:t,additionalProps:n,externalSlotProps:r,externalForwardedProps:a,className:s}=e;if(!t){const e=(0,vn.A)(n?.className,s,a?.className,r?.className),t={...n?.style,...a?.style,...r?.style},i={...n,...a,...r};return e.length>0&&(i.className=e),Object.keys(t).length>0&&(i.style=t),{props:i,internalRef:void 0}}const i=La({...a,...r}),o=za(r),l=za(a),u=t(i),c=(0,vn.A)(u?.className,n?.className,s,a?.className,r?.className),d={...u?.style,...n?.style,...a?.style,...r?.style},h={...u,...n,...l,...o};return c.length>0&&(h.className=c),Object.keys(d).length>0&&(h.style=d),{props:h,internalRef:u.ref}};const Va=function(e,t,n){return"function"===typeof e?e(t,n):e};const Wa=function(e){const{elementType:t,externalSlotProps:n,ownerState:r,skipResolvingSlotProps:a=!1,...s}=e,i=a?{}:Va(n,r),{props:o,internalRef:l}=Ba({...s,externalSlotProps:i}),u=(0,br.A)(l,i?.ref,e.additionalProps?.ref);return Pa(t,{...o,ref:u},r)};const Ua=t.createContext({});function ja(e){return(0,Kn.Ay)("MuiList",e)}(0,Fn.A)("MuiList",["root","padding","dense","subheader"]);const Ga=(0,Wn.Ay)("ul",{name:"MuiList",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,!n.disablePadding&&t.padding,n.dense&&t.dense,n.subheader&&t.subheader]}})({listStyle:"none",margin:0,padding:0,position:"relative",variants:[{props:e=>{let{ownerState:t}=e;return!t.disablePadding},style:{paddingTop:8,paddingBottom:8}},{props:e=>{let{ownerState:t}=e;return t.subheader},style:{paddingTop:0}}]}),Ha=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiList"}),{children:a,className:s,component:i="ul",dense:o=!1,disablePadding:l=!1,subheader:u,...c}=r,d=t.useMemo((()=>({dense:o})),[o]),h={...r,component:i,dense:o,disablePadding:l},p=(e=>{const{classes:t,disablePadding:n,dense:r,subheader:a}=e,s={root:["root",!n&&"padding",r&&"dense",a&&"subheader"]};return(0,Bn.A)(s,ja,t)})(h);return(0,$n.jsx)(Ua.Provider,{value:d,children:(0,$n.jsxs)(Ga,{as:i,className:(0,vn.A)(p.root,s),ref:n,ownerState:h,...c,children:[u,a]})})})),qa=Ha;function Ka(e){const t=e.documentElement.clientWidth;return Math.abs(window.innerWidth-t)}const Ya=Ka;function Xa(e,t,n){return e===t?e.firstChild:t&&t.nextElementSibling?t.nextElementSibling:n?null:e.firstChild}function Qa(e,t,n){return e===t?n?e.firstChild:e.lastChild:t&&t.previousElementSibling?t.previousElementSibling:n?null:e.lastChild}function Za(e,t){if(void 0===t)return!0;let n=e.innerText;return void 0===n&&(n=e.textContent),n=n.trim().toLowerCase(),0!==n.length&&(t.repeating?n[0]===t.keys[0]:n.startsWith(t.keys.join("")))}function Ja(e,t,n,r,a,s){let i=!1,o=a(e,t,!!t&&n);for(;o;){if(o===e.firstChild){if(i)return!1;i=!0}const t=!r&&(o.disabled||"true"===o.getAttribute("aria-disabled"));if(o.hasAttribute("tabindex")&&Za(o,s)&&!t)return o.focus(),!0;o=a(e,o,n)}return!1}const es=t.forwardRef((function(e,n){const{actions:r,autoFocus:a=!1,autoFocusItem:s=!1,children:i,className:o,disabledItemsFocusable:l=!1,disableListWrap:u=!1,onKeyDown:c,variant:d="selectedMenu",...h}=e,p=t.useRef(null),f=t.useRef({keys:[],repeating:!0,previousKeyMatched:!0,lastTime:null});(0,$r.A)((()=>{a&&p.current.focus()}),[a]),t.useImperativeHandle(r,(()=>({adjustStyleForScrollbar:(e,t)=>{let{direction:n}=t;const r=!p.current.style.width;if(e.clientHeight<p.current.clientHeight&&r){const t=`${Ya((0,Da.A)(e))}px`;p.current.style["rtl"===n?"paddingLeft":"paddingRight"]=t,p.current.style.width=`calc(100% + ${t})`}return p.current}})),[]);const m=(0,_r.A)(p,n);let g=-1;t.Children.forEach(i,((e,n)=>{t.isValidElement(e)?(e.props.disabled||("selectedMenu"===d&&e.props.selected||-1===g)&&(g=n),g===n&&(e.props.disabled||e.props.muiSkipListHighlight||e.type.muiSkipListHighlight)&&(g+=1,g>=i.length&&(g=-1))):g===n&&(g+=1,g>=i.length&&(g=-1))}));const y=t.Children.map(i,((e,n)=>{if(n===g){const n={};return s&&(n.autoFocus=!0),void 0===e.props.tabIndex&&"selectedMenu"===d&&(n.tabIndex=0),t.cloneElement(e,n)}return e}));return(0,$n.jsx)(qa,{role:"menu",ref:m,className:o,onKeyDown:e=>{const t=p.current,n=e.key;if(e.ctrlKey||e.metaKey||e.altKey)return void(c&&c(e));const r=(0,Da.A)(t).activeElement;if("ArrowDown"===n)e.preventDefault(),Ja(t,r,u,l,Xa);else if("ArrowUp"===n)e.preventDefault(),Ja(t,r,u,l,Qa);else if("Home"===n)e.preventDefault(),Ja(t,null,u,l,Xa);else if("End"===n)e.preventDefault(),Ja(t,null,u,l,Qa);else if(1===n.length){const a=f.current,s=n.toLowerCase(),i=performance.now();a.keys.length>0&&(i-a.lastTime>500?(a.keys=[],a.repeating=!0,a.previousKeyMatched=!0):a.repeating&&s!==a.keys[0]&&(a.repeating=!1)),a.lastTime=i,a.keys.push(s);const o=r&&!a.repeating&&Za(r,a);a.previousKeyMatched&&(o||Ja(t,r,!1,l,Xa,a))?e.preventDefault():a.previousKeyMatched=!1}c&&c(e)},tabIndex:a?0:-1,...h,children:y})})),ts=es;var ns=n(950),rs=n(6078);const as={};function ss(e,n){const r=t.useRef(as);return r.current===as&&(r.current=e(n)),r}const is=[];class os{static create(){return new os}currentId=null;start(e,t){this.clear(),this.currentId=setTimeout((()=>{this.currentId=null,t()}),e)}clear=()=>{null!==this.currentId&&(clearTimeout(this.currentId),this.currentId=null)};disposeEffect=()=>this.clear}function ls(){const e=ss(os.create).current;return function(e){t.useEffect(e,is)}(e.disposeEffect),e}function us(e,t){if(null==e)return{};var n={};for(var r in e)if({}.hasOwnProperty.call(e,r)){if(t.includes(r))continue;n[r]=e[r]}return n}function cs(e,t){return cs=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},cs(e,t)}function ds(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,cs(e,t)}const hs=!1,ps=t.createContext(null);var fs=function(e){return e.scrollTop},ms="unmounted",gs="exited",ys="entering",bs="entered",vs="exiting",xs=function(e){function n(t,n){var r;r=e.call(this,t,n)||this;var a,s=n&&!n.isMounting?t.enter:t.appear;return r.appearStatus=null,t.in?s?(a=gs,r.appearStatus=ys):a=bs:a=t.unmountOnExit||t.mountOnEnter?ms:gs,r.state={status:a},r.nextCallback=null,r}ds(n,e),n.getDerivedStateFromProps=function(e,t){return e.in&&t.status===ms?{status:gs}:null};var r=n.prototype;return r.componentDidMount=function(){this.updateStatus(!0,this.appearStatus)},r.componentDidUpdate=function(e){var t=null;if(e!==this.props){var n=this.state.status;this.props.in?n!==ys&&n!==bs&&(t=ys):n!==ys&&n!==bs||(t=vs)}this.updateStatus(!1,t)},r.componentWillUnmount=function(){this.cancelNextCallback()},r.getTimeouts=function(){var e,t,n,r=this.props.timeout;return e=t=n=r,null!=r&&"number"!==typeof r&&(e=r.exit,t=r.enter,n=void 0!==r.appear?r.appear:t),{exit:e,enter:t,appear:n}},r.updateStatus=function(e,t){if(void 0===e&&(e=!1),null!==t)if(this.cancelNextCallback(),t===ys){if(this.props.unmountOnExit||this.props.mountOnEnter){var n=this.props.nodeRef?this.props.nodeRef.current:a.findDOMNode(this);n&&fs(n)}this.performEnter(e)}else this.performExit();else this.props.unmountOnExit&&this.state.status===gs&&this.setState({status:ms})},r.performEnter=function(e){var t=this,n=this.props.enter,r=this.context?this.context.isMounting:e,s=this.props.nodeRef?[r]:[a.findDOMNode(this),r],i=s[0],o=s[1],l=this.getTimeouts(),u=r?l.appear:l.enter;!e&&!n||hs?this.safeSetState({status:bs},(function(){t.props.onEntered(i)})):(this.props.onEnter(i,o),this.safeSetState({status:ys},(function(){t.props.onEntering(i,o),t.onTransitionEnd(u,(function(){t.safeSetState({status:bs},(function(){t.props.onEntered(i,o)}))}))})))},r.performExit=function(){var e=this,t=this.props.exit,n=this.getTimeouts(),r=this.props.nodeRef?void 0:a.findDOMNode(this);t&&!hs?(this.props.onExit(r),this.safeSetState({status:vs},(function(){e.props.onExiting(r),e.onTransitionEnd(n.exit,(function(){e.safeSetState({status:gs},(function(){e.props.onExited(r)}))}))}))):this.safeSetState({status:gs},(function(){e.props.onExited(r)}))},r.cancelNextCallback=function(){null!==this.nextCallback&&(this.nextCallback.cancel(),this.nextCallback=null)},r.safeSetState=function(e,t){t=this.setNextCallback(t),this.setState(e,t)},r.setNextCallback=function(e){var t=this,n=!0;return this.nextCallback=function(r){n&&(n=!1,t.nextCallback=null,e(r))},this.nextCallback.cancel=function(){n=!1},this.nextCallback},r.onTransitionEnd=function(e,t){this.setNextCallback(t);var n=this.props.nodeRef?this.props.nodeRef.current:a.findDOMNode(this),r=null==e&&!this.props.addEndListener;if(n&&!r){if(this.props.addEndListener){var s=this.props.nodeRef?[this.nextCallback]:[n,this.nextCallback],i=s[0],o=s[1];this.props.addEndListener(i,o)}null!=e&&setTimeout(this.nextCallback,e)}else setTimeout(this.nextCallback,0)},r.render=function(){var e=this.state.status;if(e===ms)return null;var n=this.props,r=n.children,a=(n.in,n.mountOnEnter,n.unmountOnExit,n.appear,n.enter,n.exit,n.timeout,n.addEndListener,n.onEnter,n.onEntering,n.onEntered,n.onExit,n.onExiting,n.onExited,n.nodeRef,us(n,["children","in","mountOnEnter","unmountOnExit","appear","enter","exit","timeout","addEndListener","onEnter","onEntering","onEntered","onExit","onExiting","onExited","nodeRef"]));return t.createElement(ps.Provider,{value:null},"function"===typeof r?r(e,a):t.cloneElement(t.Children.only(r),a))},n}(t.Component);function ws(){}xs.contextType=ps,xs.propTypes={},xs.defaultProps={in:!1,mountOnEnter:!1,unmountOnExit:!1,appear:!1,enter:!0,exit:!0,onEnter:ws,onEntering:ws,onEntered:ws,onExit:ws,onExiting:ws,onExited:ws},xs.UNMOUNTED=ms,xs.EXITED=gs,xs.ENTERING=ys,xs.ENTERED=bs,xs.EXITING=vs;const ks=xs,Ss=e=>e.scrollTop;function Is(e,t){const{timeout:n,easing:r,style:a={}}=e;return{duration:a.transitionDuration??("number"===typeof n?n:n[t.mode]||0),easing:a.transitionTimingFunction??("object"===typeof r?r[t.mode]:r),delay:a.transitionDelay}}function Ts(e){return`scale(${e}, ${e**2})`}const Ns={entering:{opacity:1,transform:Ts(1)},entered:{opacity:1,transform:"none"}},Cs="undefined"!==typeof navigator&&/^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent)&&/(os |version\/)15(.|_)4/i.test(navigator.userAgent),As=t.forwardRef((function(e,n){const{addEndListener:r,appear:a=!0,children:s,easing:i,in:o,onEnter:l,onEntered:u,onEntering:c,onExit:d,onExited:h,onExiting:p,style:f,timeout:m="auto",TransitionComponent:g=ks,...y}=e,b=ls(),v=t.useRef(),x=jn(),w=t.useRef(null),k=(0,_r.A)(w,Ra(s),n),S=e=>t=>{if(e){const n=w.current;void 0===t?e(n):e(n,t)}},I=S(c),T=S(((e,t)=>{Ss(e);const{duration:n,delay:r,easing:a}=Is({style:f,timeout:m,easing:i},{mode:"enter"});let s;"auto"===m?(s=x.transitions.getAutoHeightDuration(e.clientHeight),v.current=s):s=n,e.style.transition=[x.transitions.create("opacity",{duration:s,delay:r}),x.transitions.create("transform",{duration:Cs?s:.666*s,delay:r,easing:a})].join(","),l&&l(e,t)})),N=S(u),C=S(p),A=S((e=>{const{duration:t,delay:n,easing:r}=Is({style:f,timeout:m,easing:i},{mode:"exit"});let a;"auto"===m?(a=x.transitions.getAutoHeightDuration(e.clientHeight),v.current=a):a=t,e.style.transition=[x.transitions.create("opacity",{duration:a,delay:n}),x.transitions.create("transform",{duration:Cs?a:.666*a,delay:Cs?n:n||.333*a,easing:r})].join(","),e.style.opacity=0,e.style.transform=Ts(.75),d&&d(e)})),E=S(h);return(0,$n.jsx)(g,{appear:a,in:o,nodeRef:w,onEnter:T,onEntered:N,onEntering:I,onExit:A,onExited:E,onExiting:C,addEndListener:e=>{"auto"===m&&b.start(v.current||0,e),r&&r(w.current,e)},timeout:"auto"===m?null:m,...y,children:(e,n)=>t.cloneElement(s,{style:{opacity:0,transform:Ts(.75),visibility:"exited"!==e||o?void 0:"hidden",...Ns[e],...f,...s.props.style},ref:k,...n})})}));As&&(As.muiSupportAuto=!0);const Es=As;var _s=n(1668);const $s=["input","select","textarea","a[href]","button","[tabindex]","audio[controls]","video[controls]",'[contenteditable]:not([contenteditable="false"])'].join(",");function Rs(e){const t=[],n=[];return Array.from(e.querySelectorAll($s)).forEach(((e,r)=>{const a=function(e){const t=parseInt(e.getAttribute("tabindex")||"",10);return Number.isNaN(t)?"true"===e.contentEditable||("AUDIO"===e.nodeName||"VIDEO"===e.nodeName||"DETAILS"===e.nodeName)&&null===e.getAttribute("tabindex")?0:e.tabIndex:t}(e);-1!==a&&function(e){return!(e.disabled||"INPUT"===e.tagName&&"hidden"===e.type||function(e){if("INPUT"!==e.tagName||"radio"!==e.type)return!1;if(!e.name)return!1;const t=t=>e.ownerDocument.querySelector(`input[type="radio"]${t}`);let n=t(`[name="${e.name}"]:checked`);return n||(n=t(`[name="${e.name}"]`)),n!==e}(e))}(e)&&(0===a?t.push(e):n.push({documentOrder:r,tabIndex:a,node:e}))})),n.sort(((e,t)=>e.tabIndex===t.tabIndex?e.documentOrder-t.documentOrder:e.tabIndex-t.tabIndex)).map((e=>e.node)).concat(t)}function Ds(){return!0}const Ms=function(e){const{children:n,disableAutoFocus:r=!1,disableEnforceFocus:a=!1,disableRestoreFocus:s=!1,getTabbable:i=Rs,isEnabled:o=Ds,open:l}=e,u=t.useRef(!1),c=t.useRef(null),d=t.useRef(null),h=t.useRef(null),p=t.useRef(null),f=t.useRef(!1),m=t.useRef(null),g=(0,br.A)(Ra(n),m),y=t.useRef(null);t.useEffect((()=>{l&&m.current&&(f.current=!r)}),[r,l]),t.useEffect((()=>{if(!l||!m.current)return;const e=(0,_s.A)(m.current);return m.current.contains(e.activeElement)||(m.current.hasAttribute("tabIndex")||m.current.setAttribute("tabIndex","-1"),f.current&&m.current.focus()),()=>{s||(h.current&&h.current.focus&&(u.current=!0,h.current.focus()),h.current=null)}}),[l]),t.useEffect((()=>{if(!l||!m.current)return;const e=(0,_s.A)(m.current),t=t=>{y.current=t,!a&&o()&&"Tab"===t.key&&e.activeElement===m.current&&t.shiftKey&&(u.current=!0,d.current&&d.current.focus())},n=()=>{const t=m.current;if(null===t)return;if(!e.hasFocus()||!o()||u.current)return void(u.current=!1);if(t.contains(e.activeElement))return;if(a&&e.activeElement!==c.current&&e.activeElement!==d.current)return;if(e.activeElement!==p.current)p.current=null;else if(null!==p.current)return;if(!f.current)return;let n=[];if(e.activeElement!==c.current&&e.activeElement!==d.current||(n=i(m.current)),n.length>0){const e=Boolean(y.current?.shiftKey&&"Tab"===y.current?.key),t=n[0],r=n[n.length-1];"string"!==typeof t&&"string"!==typeof r&&(e?r.focus():t.focus())}else t.focus()};e.addEventListener("focusin",n),e.addEventListener("keydown",t,!0);const r=setInterval((()=>{e.activeElement&&"BODY"===e.activeElement.tagName&&n()}),50);return()=>{clearInterval(r),e.removeEventListener("focusin",n),e.removeEventListener("keydown",t,!0)}}),[r,a,s,o,l,i]);const b=e=>{null===h.current&&(h.current=e.relatedTarget),f.current=!0};return(0,$n.jsxs)(t.Fragment,{children:[(0,$n.jsx)("div",{tabIndex:l?0:-1,onFocus:b,ref:c,"data-testid":"sentinelStart"}),t.cloneElement(n,{ref:g,onFocus:e=>{null===h.current&&(h.current=e.relatedTarget),f.current=!0,p.current=e.target;const t=n.props.onFocus;t&&t(e)}}),(0,$n.jsx)("div",{tabIndex:l?0:-1,onFocus:b,ref:d,"data-testid":"sentinelEnd"})]})};var Fs=n(6564);const Os=t.forwardRef((function(e,n){const{children:r,container:s,disablePortal:i=!1}=e,[o,l]=t.useState(null),u=(0,br.A)(Ra(r),n);if((0,xr.A)((()=>{i||l(function(e){return"function"===typeof e?e():e}(s)||document.body)}),[s,i]),(0,xr.A)((()=>{if(o&&!i)return(0,Fs.A)(n,o),()=>{(0,Fs.A)(n,null)}}),[n,o,i]),i){if(t.isValidElement(r)){const e={ref:u};return t.cloneElement(r,e)}return(0,$n.jsx)(t.Fragment,{children:r})}return(0,$n.jsx)(t.Fragment,{children:o?a.createPortal(r,o):o})}));function Ps(e,t){const{className:n,elementType:r,ownerState:a,externalForwardedProps:s,getSlotOwnerState:i,internalForwardedProps:o,...l}=t,{component:u,slots:c={[e]:void 0},slotProps:d={[e]:void 0},...h}=s,p=c[e]||r,f=Va(d[e],a),{props:{component:m,...g},internalRef:y}=Ba({className:n,...l,externalForwardedProps:"root"===e?h:void 0,externalSlotProps:f}),b=(0,br.A)(y,f?.ref,t.ref),v=i?i(g):{},x={...a,...v},w="root"===e?m||u:m,k=Pa(p,{..."root"===e&&!u&&!c[e]&&o,..."root"!==e&&!c[e]&&o,...g,...w&&{as:w},ref:b},x);return Object.keys(v).forEach((e=>{delete k[e]})),[p,k]}const Ls={entering:{opacity:1},entered:{opacity:1}},zs=t.forwardRef((function(e,n){const r=jn(),a={enter:r.transitions.duration.enteringScreen,exit:r.transitions.duration.leavingScreen},{addEndListener:s,appear:i=!0,children:o,easing:l,in:u,onEnter:c,onEntered:d,onEntering:h,onExit:p,onExited:f,onExiting:m,style:g,timeout:y=a,TransitionComponent:b=ks,...v}=e,x=t.useRef(null),w=(0,_r.A)(x,Ra(o),n),k=e=>t=>{if(e){const n=x.current;void 0===t?e(n):e(n,t)}},S=k(h),I=k(((e,t)=>{Ss(e);const n=Is({style:g,timeout:y,easing:l},{mode:"enter"});e.style.webkitTransition=r.transitions.create("opacity",n),e.style.transition=r.transitions.create("opacity",n),c&&c(e,t)})),T=k(d),N=k(m),C=k((e=>{const t=Is({style:g,timeout:y,easing:l},{mode:"exit"});e.style.webkitTransition=r.transitions.create("opacity",t),e.style.transition=r.transitions.create("opacity",t),p&&p(e)})),A=k(f);return(0,$n.jsx)(b,{appear:i,in:u,nodeRef:x,onEnter:I,onEntered:T,onEntering:S,onExit:C,onExited:A,onExiting:N,addEndListener:e=>{s&&s(x.current,e)},timeout:y,...v,children:(e,n)=>t.cloneElement(o,{style:{opacity:0,visibility:"exited"!==e||u?void 0:"hidden",...Ls[e],...g,...o.props.style},ref:w,...n})})})),Bs=zs;function Vs(e){return(0,Kn.Ay)("MuiBackdrop",e)}(0,Fn.A)("MuiBackdrop",["root","invisible"]);const Ws=(0,Wn.Ay)("div",{name:"MuiBackdrop",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.invisible&&t.invisible]}})({position:"fixed",display:"flex",alignItems:"center",justifyContent:"center",right:0,bottom:0,top:0,left:0,backgroundColor:"rgba(0, 0, 0, 0.5)",WebkitTapHighlightColor:"transparent",variants:[{props:{invisible:!0},style:{backgroundColor:"transparent"}}]}),Us=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiBackdrop"}),{children:r,className:a,component:s="div",invisible:i=!1,open:o,components:l={},componentsProps:u={},slotProps:c={},slots:d={},TransitionComponent:h,transitionDuration:p,...f}=n,m={...n,component:s,invisible:i},g=(e=>{const{classes:t,invisible:n}=e,r={root:["root",n&&"invisible"]};return(0,Bn.A)(r,Vs,t)})(m),y={slots:{transition:h,root:l.Root,...d},slotProps:{...u,...c}},[b,v]=Ps("root",{elementType:Ws,externalForwardedProps:y,className:(0,vn.A)(g.root,a),ownerState:m}),[x,w]=Ps("transition",{elementType:Bs,externalForwardedProps:y,ownerState:m});return delete w.ownerState,(0,$n.jsx)(x,{in:o,timeout:p,...f,...w,children:(0,$n.jsx)(b,{"aria-hidden":!0,...v,classes:g,ref:t,children:r})})}));var js=n(1782),Gs=n(2456);function Hs(e,t){t?e.setAttribute("aria-hidden","true"):e.removeAttribute("aria-hidden")}function qs(e){return parseInt((0,vr.A)(e).getComputedStyle(e).paddingRight,10)||0}function Ks(e,t,n,r,a){const s=[t,n,...r];[].forEach.call(e.children,(e=>{const t=-1===s.indexOf(e),n=!function(e){const t=-1!==["TEMPLATE","SCRIPT","STYLE","LINK","MAP","META","NOSCRIPT","PICTURE","COL","COLGROUP","PARAM","SLOT","SOURCE","TRACK"].indexOf(e.tagName),n="INPUT"===e.tagName&&"hidden"===e.getAttribute("type");return t||n}(e);t&&n&&Hs(e,a)}))}function Ys(e,t){let n=-1;return e.some(((e,r)=>!!t(e)&&(n=r,!0))),n}function Xs(e,t){const n=[],r=e.container;if(!t.disableScrollLock){if(function(e){const t=(0,_s.A)(e);return t.body===e?(0,vr.A)(e).innerWidth>t.documentElement.clientWidth:e.scrollHeight>e.clientHeight}(r)){const e=Ka((0,_s.A)(r));n.push({value:r.style.paddingRight,property:"padding-right",el:r}),r.style.paddingRight=`${qs(r)+e}px`;const t=(0,_s.A)(r).querySelectorAll(".mui-fixed");[].forEach.call(t,(t=>{n.push({value:t.style.paddingRight,property:"padding-right",el:t}),t.style.paddingRight=`${qs(t)+e}px`}))}let e;if(r.parentNode instanceof DocumentFragment)e=(0,_s.A)(r).body;else{const t=r.parentElement,n=(0,vr.A)(r);e="HTML"===t?.nodeName&&"scroll"===n.getComputedStyle(t).overflowY?t:r}n.push({value:e.style.overflow,property:"overflow",el:e},{value:e.style.overflowX,property:"overflow-x",el:e},{value:e.style.overflowY,property:"overflow-y",el:e}),e.style.overflow="hidden"}return()=>{n.forEach((e=>{let{value:t,el:n,property:r}=e;t?n.style.setProperty(r,t):n.style.removeProperty(r)}))}}const Qs=new class{constructor(){this.modals=[],this.containers=[]}add(e,t){let n=this.modals.indexOf(e);if(-1!==n)return n;n=this.modals.length,this.modals.push(e),e.modalRef&&Hs(e.modalRef,!1);const r=function(e){const t=[];return[].forEach.call(e.children,(e=>{"true"===e.getAttribute("aria-hidden")&&t.push(e)})),t}(t);Ks(t,e.mount,e.modalRef,r,!0);const a=Ys(this.containers,(e=>e.container===t));return-1!==a?(this.containers[a].modals.push(e),n):(this.containers.push({modals:[e],container:t,restore:null,hiddenSiblings:r}),n)}mount(e,t){const n=Ys(this.containers,(t=>-1!==t.modals.indexOf(e))),r=this.containers[n];r.restore||(r.restore=Xs(r,t))}remove(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this.modals.indexOf(e);if(-1===n)return n;const r=Ys(this.containers,(t=>-1!==t.modals.indexOf(e))),a=this.containers[r];if(a.modals.splice(a.modals.indexOf(e),1),this.modals.splice(n,1),0===a.modals.length)a.restore&&a.restore(),e.modalRef&&Hs(e.modalRef,t),Ks(a.container,e.mount,e.modalRef,a.hiddenSiblings,!1),this.containers.splice(r,1);else{const e=a.modals[a.modals.length-1];e.modalRef&&Hs(e.modalRef,!1)}return n}isTopModal(e){return this.modals.length>0&&this.modals[this.modals.length-1]===e}};const Zs=function(e){const{container:n,disableEscapeKeyDown:r=!1,disableScrollLock:a=!1,manager:s=Qs,closeAfterTransition:i=!1,onTransitionEnter:o,onTransitionExited:l,children:u,onClose:c,open:d,rootRef:h}=e,p=t.useRef({}),f=t.useRef(null),m=t.useRef(null),g=(0,br.A)(m,h),[y,b]=t.useState(!d),v=function(e){return!!e&&e.props.hasOwnProperty("in")}(u);let x=!0;"false"!==e["aria-hidden"]&&!1!==e["aria-hidden"]||(x=!1);const w=()=>(p.current.modalRef=m.current,p.current.mount=f.current,p.current),k=()=>{s.mount(w(),{disableScrollLock:a}),m.current&&(m.current.scrollTop=0)},S=(0,js.A)((()=>{const e=function(e){return"function"===typeof e?e():e}(n)||(0,_s.A)(f.current).body;s.add(w(),e),m.current&&k()})),I=t.useCallback((()=>s.isTopModal(w())),[s]),T=(0,js.A)((e=>{f.current=e,e&&(d&&I()?k():m.current&&Hs(m.current,x))})),N=t.useCallback((()=>{s.remove(w(),x)}),[x,s]);t.useEffect((()=>()=>{N()}),[N]),t.useEffect((()=>{d?S():v&&i||N()}),[d,N,v,i,S]);const C=e=>t=>{e.onKeyDown?.(t),"Escape"===t.key&&229!==t.which&&I()&&(r||(t.stopPropagation(),c&&c(t,"escapeKeyDown")))},A=e=>t=>{e.onClick?.(t),t.target===t.currentTarget&&c&&c(t,"backdropClick")};return{getRootProps:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=La(e);delete n.onTransitionEnter,delete n.onTransitionExited;const r={...n,...t};return{role:"presentation",...r,onKeyDown:C(r),ref:g}},getBackdropProps:function(){const e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return{"aria-hidden":!0,...e,onClick:A(e),open:d}},getTransitionProps:()=>({onEnter:(0,Gs.A)((()=>{b(!1),o&&o()}),u?.props.onEnter),onExited:(0,Gs.A)((()=>{b(!0),l&&l(),i&&N()}),u?.props.onExited)}),rootRef:g,portalRef:T,isTopModal:I,exited:y,hasTransition:v}};function Js(e){return(0,Kn.Ay)("MuiModal",e)}(0,Fn.A)("MuiModal",["root","hidden","backdrop"]);const ei=(0,Wn.Ay)("div",{name:"MuiModal",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,!n.open&&n.exited&&t.hidden]}})((0,Gn.A)((e=>{let{theme:t}=e;return{position:"fixed",zIndex:(t.vars||t).zIndex.modal,right:0,bottom:0,top:0,left:0,variants:[{props:e=>{let{ownerState:t}=e;return!t.open&&t.exited},style:{visibility:"hidden"}}]}}))),ti=(0,Wn.Ay)(Us,{name:"MuiModal",slot:"Backdrop",overridesResolver:(e,t)=>t.backdrop})({zIndex:-1}),ni=t.forwardRef((function(e,n){const r=(0,Hn.b)({name:"MuiModal",props:e}),{BackdropComponent:a=ti,BackdropProps:s,classes:i,className:o,closeAfterTransition:l=!1,children:u,container:c,component:d,components:h={},componentsProps:p={},disableAutoFocus:f=!1,disableEnforceFocus:m=!1,disableEscapeKeyDown:g=!1,disablePortal:y=!1,disableRestoreFocus:b=!1,disableScrollLock:v=!1,hideBackdrop:x=!1,keepMounted:w=!1,onBackdropClick:k,onClose:S,onTransitionEnter:I,onTransitionExited:T,open:N,slotProps:C={},slots:A={},theme:E,..._}=r,$={...r,closeAfterTransition:l,disableAutoFocus:f,disableEnforceFocus:m,disableEscapeKeyDown:g,disablePortal:y,disableRestoreFocus:b,disableScrollLock:v,hideBackdrop:x,keepMounted:w},{getRootProps:R,getBackdropProps:D,getTransitionProps:M,portalRef:F,isTopModal:O,exited:P,hasTransition:L}=Zs({...$,rootRef:n}),z={...$,exited:P},B=(e=>{const{open:t,exited:n,classes:r}=e,a={root:["root",!t&&n&&"hidden"],backdrop:["backdrop"]};return(0,Bn.A)(a,Js,r)})(z),V={};if(void 0===u.props.tabIndex&&(V.tabIndex="-1"),L){const{onEnter:e,onExited:t}=M();V.onEnter=e,V.onExited=t}const W={slots:{root:h.Root,backdrop:h.Backdrop,...A},slotProps:{...p,...C}},[U,j]=Ps("root",{elementType:ei,externalForwardedProps:W,getSlotProps:R,additionalProps:{ref:n,as:d},ownerState:z,className:(0,vn.A)(o,B?.root,!z.open&&z.exited&&B?.hidden)}),[G,H]=Ps("backdrop",{elementType:a,externalForwardedProps:W,additionalProps:s,getSlotProps:e=>D({...e,onClick:t=>{k&&k(t),e?.onClick&&e.onClick(t)}}),className:(0,vn.A)(s?.className,B?.backdrop),ownerState:z}),q=(0,_r.A)(s?.ref,H.ref);return w||N||L&&!P?(0,$n.jsx)(Os,{ref:F,container:c,disablePortal:y,children:(0,$n.jsxs)(U,{...j,..._,children:[!x&&a?(0,$n.jsx)(G,{...H,ref:q}):null,(0,$n.jsx)(Ms,{disableEnforceFocus:m,disableAutoFocus:f,disableRestoreFocus:b,isEnabled:O,open:N,children:t.cloneElement(u,V)})]})}):null})),ri=ni;function ai(e){return(0,Kn.Ay)("MuiPopover",e)}(0,Fn.A)("MuiPopover",["root","paper"]);function si(e,t){let n=0;return"number"===typeof t?n=t:"center"===t?n=e.height/2:"bottom"===t&&(n=e.height),n}function ii(e,t){let n=0;return"number"===typeof t?n=t:"center"===t?n=e.width/2:"right"===t&&(n=e.width),n}function oi(e){return[e.horizontal,e.vertical].map((e=>"number"===typeof e?`${e}px`:e)).join(" ")}function li(e){return"function"===typeof e?e():e}const ui=(0,Wn.Ay)(ri,{name:"MuiPopover",slot:"Root",overridesResolver:(e,t)=>t.root})({}),ci=(0,Wn.Ay)(Zn,{name:"MuiPopover",slot:"Paper",overridesResolver:(e,t)=>t.paper})({position:"absolute",overflowY:"auto",overflowX:"hidden",minWidth:16,minHeight:16,maxWidth:"calc(100% - 32px)",maxHeight:"calc(100% - 32px)",outline:0}),di=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiPopover"}),{action:a,anchorEl:s,anchorOrigin:i={vertical:"top",horizontal:"left"},anchorPosition:o,anchorReference:l="anchorEl",children:u,className:c,container:d,elevation:h=8,marginThreshold:p=16,open:f,PaperProps:m={},slots:g={},slotProps:y={},transformOrigin:b={vertical:"top",horizontal:"left"},TransitionComponent:v=Es,transitionDuration:x="auto",TransitionProps:{onEntering:w,...k}={},disableScrollLock:S=!1,...I}=r,T=y?.paper??m,N=t.useRef(),C={...r,anchorOrigin:i,anchorReference:l,elevation:h,marginThreshold:p,externalPaperSlotProps:T,transformOrigin:b,TransitionComponent:v,transitionDuration:x,TransitionProps:k},A=(e=>{const{classes:t}=e;return(0,Bn.A)({root:["root"],paper:["paper"]},ai,t)})(C),E=t.useCallback((()=>{if("anchorPosition"===l)return o;const e=li(s),t=(e&&1===e.nodeType?e:(0,Da.A)(N.current).body).getBoundingClientRect();return{top:t.top+si(t,i.vertical),left:t.left+ii(t,i.horizontal)}}),[s,i.horizontal,i.vertical,o,l]),_=t.useCallback((e=>({vertical:si(e,b.vertical),horizontal:ii(e,b.horizontal)})),[b.horizontal,b.vertical]),$=t.useCallback((e=>{const t={width:e.offsetWidth,height:e.offsetHeight},n=_(t);if("none"===l)return{top:null,left:null,transformOrigin:oi(n)};const r=E();let a=r.top-n.vertical,i=r.left-n.horizontal;const o=a+t.height,u=i+t.width,c=(0,rs.A)(li(s)),d=c.innerHeight-p,h=c.innerWidth-p;if(null!==p&&a<p){const e=a-p;a-=e,n.vertical+=e}else if(null!==p&&o>d){const e=o-d;a-=e,n.vertical+=e}if(null!==p&&i<p){const e=i-p;i-=e,n.horizontal+=e}else if(u>h){const e=u-h;i-=e,n.horizontal+=e}return{top:`${Math.round(a)}px`,left:`${Math.round(i)}px`,transformOrigin:oi(n)}}),[s,l,E,_,p]),[R,D]=t.useState(f),M=t.useCallback((()=>{const e=N.current;if(!e)return;const t=$(e);null!==t.top&&(e.style.top=t.top),null!==t.left&&(e.style.left=t.left),e.style.transformOrigin=t.transformOrigin,D(!0)}),[$]);t.useEffect((()=>(S&&window.addEventListener("scroll",M),()=>window.removeEventListener("scroll",M))),[s,S,M]);t.useEffect((()=>{f&&M()})),t.useImperativeHandle(a,(()=>f?{updatePosition:()=>{M()}}:null),[f,M]),t.useEffect((()=>{if(!f)return;const e=(0,ns.A)((()=>{M()})),t=(0,rs.A)(s);return t.addEventListener("resize",e),()=>{e.clear(),t.removeEventListener("resize",e)}}),[s,f,M]);let F=x;"auto"!==x||v.muiSupportAuto||(F=void 0);const O=d||(s?(0,Da.A)(li(s)).body:void 0),P={slots:g,slotProps:{...y,paper:T}},[L,z]=Ps("paper",{elementType:ci,externalForwardedProps:P,additionalProps:{elevation:h,className:(0,vn.A)(A.paper,T?.className),style:R?T.style:{...T.style,opacity:0}},ownerState:C}),[B,{slotProps:V,...W}]=Ps("root",{elementType:ui,externalForwardedProps:P,additionalProps:{slotProps:{backdrop:{invisible:!0}},container:O,open:f},ownerState:C,className:(0,vn.A)(A.root,c)}),U=(0,_r.A)(N,z.ref);return(0,$n.jsx)(B,{...W,...!Nr(B)&&{slotProps:V,disableScrollLock:S},...I,ref:n,children:(0,$n.jsx)(v,{appear:!0,in:f,onEntering:(e,t)=>{w&&w(e,t),M()},onExited:()=>{D(!1)},timeout:F,...k,children:(0,$n.jsx)(L,{...z,ref:U,children:u})})})})),hi=di;function pi(e){return(0,Kn.Ay)("MuiMenu",e)}(0,Fn.A)("MuiMenu",["root","paper","list"]);const fi={vertical:"top",horizontal:"right"},mi={vertical:"top",horizontal:"left"},gi=(0,Wn.Ay)(hi,{shouldForwardProp:e=>(0,jr.A)(e)||"classes"===e,name:"MuiMenu",slot:"Root",overridesResolver:(e,t)=>t.root})({}),yi=(0,Wn.Ay)(ci,{name:"MuiMenu",slot:"Paper",overridesResolver:(e,t)=>t.paper})({maxHeight:"calc(100% - 96px)",WebkitOverflowScrolling:"touch"}),bi=(0,Wn.Ay)(ts,{name:"MuiMenu",slot:"List",overridesResolver:(e,t)=>t.list})({outline:0}),vi=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiMenu"}),{autoFocus:a=!0,children:s,className:i,disableAutoFocusItem:o=!1,MenuListProps:l={},onClose:u,open:c,PaperProps:d={},PopoverClasses:h,transitionDuration:p="auto",TransitionProps:{onEntering:f,...m}={},variant:g="selectedMenu",slots:y={},slotProps:b={},...v}=r,x=Fa(),w={...r,autoFocus:a,disableAutoFocusItem:o,MenuListProps:l,onEntering:f,PaperProps:d,transitionDuration:p,TransitionProps:m,variant:g},k=(e=>{const{classes:t}=e;return(0,Bn.A)({root:["root"],paper:["paper"],list:["list"]},pi,t)})(w),S=a&&!o&&c,I=t.useRef(null);let T=-1;t.Children.map(s,((e,n)=>{t.isValidElement(e)&&(e.props.disabled||("selectedMenu"===g&&e.props.selected||-1===T)&&(T=n))}));const N=y.paper??yi,C=b.paper??d,A=Wa({elementType:y.root,externalSlotProps:b.root,ownerState:w,className:[k.root,i]}),E=Wa({elementType:N,externalSlotProps:C,ownerState:w,className:k.paper});return(0,$n.jsx)(gi,{onClose:u,anchorOrigin:{vertical:"bottom",horizontal:x?"right":"left"},transformOrigin:x?fi:mi,slots:{paper:N,root:y.root},slotProps:{root:A,paper:E},open:c,ref:n,transitionDuration:p,TransitionProps:{onEntering:(e,t)=>{I.current&&I.current.adjustStyleForScrollbar(e,{direction:x?"rtl":"ltr"}),f&&f(e,t)},...m},ownerState:w,...v,classes:h,children:(0,$n.jsx)(bi,{onKeyDown:e=>{"Tab"===e.key&&(e.preventDefault(),u&&u(e,"tabKeyDown"))},actions:I,autoFocus:a&&(-1===T||o),autoFocusItem:S,variant:g,...l,className:(0,vn.A)(k.list,l.className),children:s})})})),xi=vi;function wi(e){return(0,Kn.Ay)("MuiNativeSelect",e)}const ki=(0,Fn.A)("MuiNativeSelect",["root","select","multiple","filled","outlined","standard","disabled","icon","iconOpen","iconFilled","iconOutlined","iconStandard","nativeInput","error"]),Si=(0,Wn.Ay)("select")((e=>{let{theme:t}=e;return{MozAppearance:"none",WebkitAppearance:"none",userSelect:"none",borderRadius:0,cursor:"pointer","&:focus":{borderRadius:0},[`&.${ki.disabled}`]:{cursor:"default"},"&[multiple]":{height:"auto"},"&:not([multiple]) option, &:not([multiple]) optgroup":{backgroundColor:(t.vars||t).palette.background.paper},variants:[{props:e=>{let{ownerState:t}=e;return"filled"!==t.variant&&"outlined"!==t.variant},style:{"&&&":{paddingRight:24,minWidth:16}}},{props:{variant:"filled"},style:{"&&&":{paddingRight:32}}},{props:{variant:"outlined"},style:{borderRadius:(t.vars||t).shape.borderRadius,"&:focus":{borderRadius:(t.vars||t).shape.borderRadius},"&&&":{paddingRight:32}}}]}})),Ii=(0,Wn.Ay)(Si,{name:"MuiNativeSelect",slot:"Select",shouldForwardProp:jr.A,overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.select,t[n.variant],n.error&&t.error,{[`&.${ki.multiple}`]:t.multiple}]}})({}),Ti=(0,Wn.Ay)("svg")((e=>{let{theme:t}=e;return{position:"absolute",right:0,top:"calc(50% - .5em)",pointerEvents:"none",color:(t.vars||t).palette.action.active,[`&.${ki.disabled}`]:{color:(t.vars||t).palette.action.disabled},variants:[{props:e=>{let{ownerState:t}=e;return t.open},style:{transform:"rotate(180deg)"}},{props:{variant:"filled"},style:{right:7}},{props:{variant:"outlined"},style:{right:7}}]}})),Ni=(0,Wn.Ay)(Ti,{name:"MuiNativeSelect",slot:"Icon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.icon,n.variant&&t[`icon${(0,lr.A)(n.variant)}`],n.open&&t.iconOpen]}})({}),Ci=t.forwardRef((function(e,n){const{className:r,disabled:a,error:s,IconComponent:i,inputRef:o,variant:l="standard",...u}=e,c={...e,disabled:a,variant:l,error:s},d=(e=>{const{classes:t,variant:n,disabled:r,multiple:a,open:s,error:i}=e,o={select:["select",n,r&&"disabled",a&&"multiple",i&&"error"],icon:["icon",`icon${(0,lr.A)(n)}`,s&&"iconOpen",r&&"disabled"]};return(0,Bn.A)(o,wi,t)})(c);return(0,$n.jsxs)(t.Fragment,{children:[(0,$n.jsx)(Ii,{ownerState:c,className:(0,vn.A)(d.select,r),disabled:a,ref:o||n,...u}),e.multiple?null:(0,$n.jsx)(Ni,{as:i,ownerState:c,className:d.icon})]})})),Ai=Ci;var Ei=n(7123),_i=n(5420);function $i(e){return(0,Kn.Ay)("MuiSelect",e)}const Ri=(0,Fn.A)("MuiSelect",["root","select","multiple","filled","outlined","standard","disabled","focused","icon","iconOpen","iconFilled","iconOutlined","iconStandard","nativeInput","error"]);var Di;const Mi=(0,Wn.Ay)(Si,{name:"MuiSelect",slot:"Select",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[{[`&.${Ri.select}`]:t.select},{[`&.${Ri.select}`]:t[n.variant]},{[`&.${Ri.error}`]:t.error},{[`&.${Ri.multiple}`]:t.multiple}]}})({[`&.${Ri.select}`]:{height:"auto",minHeight:"1.4375em",textOverflow:"ellipsis",whiteSpace:"nowrap",overflow:"hidden"}}),Fi=(0,Wn.Ay)(Ti,{name:"MuiSelect",slot:"Icon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.icon,n.variant&&t[`icon${(0,lr.A)(n.variant)}`],n.open&&t.iconOpen]}})({}),Oi=(0,Wn.Ay)("input",{shouldForwardProp:e=>(0,Ei.A)(e)&&"classes"!==e,name:"MuiSelect",slot:"NativeInput",overridesResolver:(e,t)=>t.nativeInput})({bottom:0,left:0,position:"absolute",opacity:0,pointerEvents:"none",width:"100%",boxSizing:"border-box"});function Pi(e,t){return"object"===typeof t&&null!==t?e===t:String(e)===String(t)}function Li(e){return null==e||"string"===typeof e&&!e.trim()}const zi=t.forwardRef((function(e,n){const{"aria-describedby":r,"aria-label":a,autoFocus:s,autoWidth:i,children:o,className:l,defaultOpen:u,defaultValue:c,disabled:d,displayEmpty:h,error:p=!1,IconComponent:f,inputRef:m,labelId:g,MenuProps:y={},multiple:b,name:v,onBlur:x,onChange:w,onClose:k,onFocus:S,onOpen:I,open:T,readOnly:N,renderValue:C,SelectDisplayProps:A={},tabIndex:E,type:_,value:$,variant:R="standard",...D}=e,[M,F]=(0,_i.A)({controlled:$,default:c,name:"Select"}),[O,P]=(0,_i.A)({controlled:T,default:u,name:"Select"}),L=t.useRef(null),z=t.useRef(null),[B,V]=t.useState(null),{current:W}=t.useRef(null!=T),[U,j]=t.useState(),G=(0,_r.A)(n,m),H=t.useCallback((e=>{z.current=e,e&&V(e)}),[]),q=B?.parentNode;t.useImperativeHandle(G,(()=>({focus:()=>{z.current.focus()},node:L.current,value:M})),[M]),t.useEffect((()=>{u&&O&&B&&!W&&(j(i?null:q.clientWidth),z.current.focus())}),[B,i]),t.useEffect((()=>{s&&z.current.focus()}),[s]),t.useEffect((()=>{if(!g)return;const e=(0,Da.A)(z.current).getElementById(g);if(e){const t=()=>{getSelection().isCollapsed&&z.current.focus()};return e.addEventListener("click",t),()=>{e.removeEventListener("click",t)}}}),[g]);const K=(e,t)=>{e?I&&I(t):k&&k(t),W||(j(i?null:q.clientWidth),P(e))},Y=t.Children.toArray(o),X=e=>t=>{let n;if(t.currentTarget.hasAttribute("tabindex")){if(b){n=Array.isArray(M)?M.slice():[];const t=M.indexOf(e.props.value);-1===t?n.push(e.props.value):n.splice(t,1)}else n=e.props.value;if(e.props.onClick&&e.props.onClick(t),M!==n&&(F(n),w)){const r=t.nativeEvent||t,a=new r.constructor(r.type,r);Object.defineProperty(a,"target",{writable:!0,value:{value:n,name:v}}),w(a,e)}b||K(!1,t)}},Q=null!==B&&O;let Z,J;delete D["aria-invalid"];const ee=[];let te=!1,ne=!1;(Dr({value:M})||h)&&(C?Z=C(M):te=!0);const re=Y.map((e=>{if(!t.isValidElement(e))return null;let n;if(b){if(!Array.isArray(M))throw new Error((0,yr.A)(2));n=M.some((t=>Pi(t,e.props.value))),n&&te&&ee.push(e.props.children)}else n=Pi(M,e.props.value),n&&te&&(J=e.props.children);return n&&(ne=!0),t.cloneElement(e,{"aria-selected":n?"true":"false",onClick:X(e),onKeyUp:t=>{" "===t.key&&t.preventDefault(),e.props.onKeyUp&&e.props.onKeyUp(t)},role:"option",selected:n,value:void 0,"data-value":e.props.value})}));te&&(Z=b?0===ee.length?null:ee.reduce(((e,t,n)=>(e.push(t),n<ee.length-1&&e.push(", "),e)),[]):J);let ae,se=U;!i&&W&&B&&(se=q.clientWidth),ae="undefined"!==typeof E?E:d?null:0;const ie=A.id||(v?`mui-component-select-${v}`:void 0),oe={...e,variant:R,value:M,open:Q,error:p},le=(e=>{const{classes:t,variant:n,disabled:r,multiple:a,open:s,error:i}=e,o={select:["select",n,r&&"disabled",a&&"multiple",i&&"error"],icon:["icon",`icon${(0,lr.A)(n)}`,s&&"iconOpen",r&&"disabled"],nativeInput:["nativeInput"]};return(0,Bn.A)(o,$i,t)})(oe),ue={...y.PaperProps,...y.slotProps?.paper},ce=(0,gr.A)();return(0,$n.jsxs)(t.Fragment,{children:[(0,$n.jsx)(Mi,{as:"div",ref:H,tabIndex:ae,role:"combobox","aria-controls":ce,"aria-disabled":d?"true":void 0,"aria-expanded":Q?"true":"false","aria-haspopup":"listbox","aria-label":a,"aria-labelledby":[g,ie].filter(Boolean).join(" ")||void 0,"aria-describedby":r,onKeyDown:e=>{if(!N){[" ","ArrowUp","ArrowDown","Enter"].includes(e.key)&&(e.preventDefault(),K(!0,e))}},onMouseDown:d||N?null:e=>{0===e.button&&(e.preventDefault(),z.current.focus(),K(!0,e))},onBlur:e=>{!Q&&x&&(Object.defineProperty(e,"target",{writable:!0,value:{value:M,name:v}}),x(e))},onFocus:S,...A,ownerState:oe,className:(0,vn.A)(A.className,le.select,l),id:ie,children:Li(Z)?Di||(Di=(0,$n.jsx)("span",{className:"notranslate",children:"\u200b"})):Z}),(0,$n.jsx)(Oi,{"aria-invalid":p,value:Array.isArray(M)?M.join(","):M,name:v,ref:L,"aria-hidden":!0,onChange:e=>{const t=Y.find((t=>t.props.value===e.target.value));void 0!==t&&(F(t.props.value),w&&w(e,t))},tabIndex:-1,disabled:d,className:le.nativeInput,autoFocus:s,...D,ownerState:oe}),(0,$n.jsx)(Fi,{as:f,className:le.icon,ownerState:oe}),(0,$n.jsx)(xi,{id:`menu-${v||""}`,anchorEl:q,open:Q,onClose:e=>{K(!1,e)},anchorOrigin:{vertical:"bottom",horizontal:"center"},transformOrigin:{vertical:"top",horizontal:"center"},...y,MenuListProps:{"aria-labelledby":g,role:"listbox","aria-multiselectable":b?"true":void 0,disableListWrap:!0,id:ce,...y.MenuListProps},slotProps:{...y.slotProps,paper:{...ue,style:{minWidth:se,...null!=ue?ue.style:null}}},children:re})]})})),Bi=zi;var Vi=n(9662);const Wi=(0,Vi.A)((0,$n.jsx)("path",{d:"M7 10l5 5 5-5z"}),"ArrowDropDown");var Ui=n(3030);function ji(e){const{theme:t,name:n,props:r}=e;return t&&t.components&&t.components[n]&&t.components[n].defaultProps?(0,Ui.A)(t.components[n].defaultProps,r):r}function Gi(e){let{props:t,name:n,defaultTheme:r,themeId:a}=e,s=_n(r);return a&&(s=s[a]||s),ji({theme:s,name:n,props:t})}function Hi(e){let{props:t,name:n}=e;return Gi({props:t,name:n,defaultTheme:Un.A,themeId:Mn.A})}const qi={name:"MuiSelect",overridesResolver:(e,t)=>t.root,shouldForwardProp:e=>(0,jr.A)(e)&&"variant"!==e,slot:"Root"},Ki=(0,Wn.Ay)(Xr,qi)(""),Yi=(0,Wn.Ay)(ha,qi)(""),Xi=(0,Wn.Ay)(na,qi)(""),Qi=t.forwardRef((function(e,n){const r=Hi({name:"MuiSelect",props:e}),{autoWidth:a=!1,children:s,classes:i={},className:o,defaultOpen:l=!1,displayEmpty:u=!1,IconComponent:c=Wi,id:d,input:h,inputProps:p,label:f,labelId:m,MenuProps:g,multiple:y=!1,native:b=!1,onClose:v,onOpen:x,open:w,renderValue:k,SelectDisplayProps:S,variant:I="outlined",...T}=r,N=b?Ai:Bi,C=Cr({props:r,muiFormControl:Er(),states:["variant","error"]}),A=C.variant||I,E={...r,variant:A,classes:i},_=(e=>{const{classes:t}=e;return t})(E),{root:$,...R}=_,D=h||{standard:(0,$n.jsx)(Ki,{ownerState:E}),outlined:(0,$n.jsx)(Yi,{label:f,ownerState:E}),filled:(0,$n.jsx)(Xi,{ownerState:E})}[A],M=(0,_r.A)(n,Ra(D));return(0,$n.jsx)(t.Fragment,{children:t.cloneElement(D,{inputComponent:N,inputProps:{children:s,error:C.error,IconComponent:c,variant:A,type:void 0,multiple:y,...b?{id:d}:{autoWidth:a,defaultOpen:l,displayEmpty:u,labelId:m,MenuProps:g,onClose:v,onOpen:x,open:w,renderValue:k,SelectDisplayProps:{id:d,...S}},...p,classes:p?(0,kn.A)(R,p.classes):R,...h?h.props.inputProps:{}},...(y&&b||u)&&"outlined"===A?{notched:!0}:{},ref:M,className:(0,vn.A)(D.props.className,o,_.root),...!h&&{variant:A},...T})})}));Qi.muiName="Select";const Zi=Qi;function Ji(e){return(0,Kn.Ay)("MuiTextField",e)}(0,Fn.A)("MuiTextField",["root"]);const eo={standard:Xr,filled:na,outlined:ha},to=(0,Wn.Ay)(Na,{name:"MuiTextField",slot:"Root",overridesResolver:(e,t)=>t.root})({}),no=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiTextField"}),{autoComplete:r,autoFocus:a=!1,children:s,className:i,color:o="primary",defaultValue:l,disabled:u=!1,error:c=!1,FormHelperTextProps:d,fullWidth:h=!1,helperText:p,id:f,InputLabelProps:m,inputProps:g,InputProps:y,inputRef:b,label:v,maxRows:x,minRows:w,multiline:k=!1,name:S,onBlur:I,onChange:T,onFocus:N,placeholder:C,required:A=!1,rows:E,select:_=!1,SelectProps:$,slots:R={},slotProps:D={},type:M,value:F,variant:O="outlined",...P}=n,L={...n,autoFocus:a,color:o,disabled:u,error:c,fullWidth:h,multiline:k,required:A,select:_,variant:O},z=(e=>{const{classes:t}=e;return(0,Bn.A)({root:["root"]},Ji,t)})(L);const B=(0,gr.A)(f),V=p&&B?`${B}-helper-text`:void 0,W=v&&B?`${B}-label`:void 0,U=eo[O],j={slots:R,slotProps:{input:y,inputLabel:m,htmlInput:g,formHelperText:d,select:$,...D}},G={},H=j.slotProps.inputLabel;"outlined"===O&&(H&&"undefined"!==typeof H.shrink&&(G.notched=H.shrink),G.label=v),_&&($&&$.native||(G.id=void 0),G["aria-describedby"]=void 0);const[q,K]=Ps("input",{elementType:U,externalForwardedProps:j,additionalProps:G,ownerState:L}),[Y,X]=Ps("inputLabel",{elementType:wa,externalForwardedProps:j,ownerState:L}),[Q,Z]=Ps("htmlInput",{elementType:"input",externalForwardedProps:j,ownerState:L}),[J,ee]=Ps("formHelperText",{elementType:$a,externalForwardedProps:j,ownerState:L}),[te,ne]=Ps("select",{elementType:Zi,externalForwardedProps:j,ownerState:L}),re=(0,$n.jsx)(q,{"aria-describedby":V,autoComplete:r,autoFocus:a,defaultValue:l,fullWidth:h,multiline:k,name:S,rows:E,maxRows:x,minRows:w,type:M,value:F,id:B,inputRef:b,onBlur:I,onChange:T,onFocus:N,placeholder:C,inputProps:Z,slots:{input:R.htmlInput?Q:void 0},...K});return(0,$n.jsxs)(to,{className:(0,vn.A)(z.root,i),disabled:u,error:c,fullWidth:h,ref:t,required:A,color:o,variant:O,ownerState:L,...P,children:[null!=v&&""!==v&&(0,$n.jsx)(Y,{htmlFor:B,id:W,...X,children:v}),_?(0,$n.jsx)(te,{"aria-describedby":V,id:B,labelId:W,value:F,input:re,...ne,children:s}):re,p&&(0,$n.jsx)(J,{id:V,...ee,children:p})]})})),ro=no;function ao(e){try{return e.matches(":focus-visible")}catch(t){0}return!1}var so=n(3319);class io{static create(){return new io}static use(){const e=ss(io.create).current,[n,r]=t.useState(!1);return e.shouldMount=n,e.setShouldMount=r,t.useEffect(e.mountEffect,[n]),e}constructor(){this.ref={current:null},this.mounted=null,this.didMount=!1,this.shouldMount=!1,this.setShouldMount=null}mount(){return this.mounted||(this.mounted=function(){let e,t;const n=new Promise(((n,r)=>{e=n,t=r}));return n.resolve=e,n.reject=t,n}(),this.shouldMount=!0,this.setShouldMount(this.shouldMount)),this.mounted}mountEffect=()=>{this.shouldMount&&!this.didMount&&null!==this.ref.current&&(this.didMount=!0,this.mounted.resolve())};start(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this.mount().then((()=>this.ref.current?.start(...t)))}stop(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this.mount().then((()=>this.ref.current?.stop(...t)))}pulsate(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this.mount().then((()=>this.ref.current?.pulsate(...t)))}}var oo=n(8168);function lo(e,n){var r=Object.create(null);return e&&t.Children.map(e,(function(e){return e})).forEach((function(e){r[e.key]=function(e){return n&&(0,t.isValidElement)(e)?n(e):e}(e)})),r}function uo(e,t,n){return null!=n[t]?n[t]:e.props[t]}function co(e,n,r){var a=lo(e.children),s=function(e,t){function n(n){return n in t?t[n]:e[n]}e=e||{},t=t||{};var r,a=Object.create(null),s=[];for(var i in e)i in t?s.length&&(a[i]=s,s=[]):s.push(i);var o={};for(var l in t){if(a[l])for(r=0;r<a[l].length;r++){var u=a[l][r];o[a[l][r]]=n(u)}o[l]=n(l)}for(r=0;r<s.length;r++)o[s[r]]=n(s[r]);return o}(n,a);return Object.keys(s).forEach((function(i){var o=s[i];if((0,t.isValidElement)(o)){var l=i in n,u=i in a,c=n[i],d=(0,t.isValidElement)(c)&&!c.props.in;!u||l&&!d?u||!l||d?u&&l&&(0,t.isValidElement)(c)&&(s[i]=(0,t.cloneElement)(o,{onExited:r.bind(null,o),in:c.props.in,exit:uo(o,"exit",e),enter:uo(o,"enter",e)})):s[i]=(0,t.cloneElement)(o,{in:!1}):s[i]=(0,t.cloneElement)(o,{onExited:r.bind(null,o),in:!0,exit:uo(o,"exit",e),enter:uo(o,"enter",e)})}})),s}var ho=Object.values||function(e){return Object.keys(e).map((function(t){return e[t]}))},po=function(e){function n(t,n){var r,a=(r=e.call(this,t,n)||this).handleExited.bind(function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(r));return r.state={contextValue:{isMounting:!0},handleExited:a,firstRender:!0},r}ds(n,e);var r=n.prototype;return r.componentDidMount=function(){this.mounted=!0,this.setState({contextValue:{isMounting:!1}})},r.componentWillUnmount=function(){this.mounted=!1},n.getDerivedStateFromProps=function(e,n){var r,a,s=n.children,i=n.handleExited;return{children:n.firstRender?(r=e,a=i,lo(r.children,(function(e){return(0,t.cloneElement)(e,{onExited:a.bind(null,e),in:!0,appear:uo(e,"appear",r),enter:uo(e,"enter",r),exit:uo(e,"exit",r)})}))):co(e,s,i),firstRender:!1}},r.handleExited=function(e,t){var n=lo(this.props.children);e.key in n||(e.props.onExited&&e.props.onExited(t),this.mounted&&this.setState((function(t){var n=(0,oo.A)({},t.children);return delete n[e.key],{children:n}})))},r.render=function(){var e=this.props,n=e.component,r=e.childFactory,a=us(e,["component","childFactory"]),s=this.state.contextValue,i=ho(this.state.children).map(r);return delete a.appear,delete a.enter,delete a.exit,null===n?t.createElement(ps.Provider,{value:s},i):t.createElement(ps.Provider,{value:s},t.createElement(n,a,i))},n}(t.Component);po.propTypes={},po.defaultProps={component:"div",childFactory:function(e){return e}};const fo=po;const mo=function(e){const{className:n,classes:r,pulsate:a=!1,rippleX:s,rippleY:i,rippleSize:o,in:l,onExited:u,timeout:c}=e,[d,h]=t.useState(!1),p=(0,vn.A)(n,r.ripple,r.rippleVisible,a&&r.ripplePulsate),f={width:o,height:o,top:-o/2+i,left:-o/2+s},m=(0,vn.A)(r.child,d&&r.childLeaving,a&&r.childPulsate);return l||d||h(!0),t.useEffect((()=>{if(!l&&null!=u){const e=setTimeout(u,c);return()=>{clearTimeout(e)}}}),[u,l,c]),(0,$n.jsx)("span",{className:p,style:f,children:(0,$n.jsx)("span",{className:m})})};const go=(0,Fn.A)("MuiTouchRipple",["root","ripple","rippleVisible","ripplePulsate","child","childLeaving","childPulsate"]),yo=ar`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`,bo=ar`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`,vo=ar`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`,xo=(0,Wn.Ay)("span",{name:"MuiTouchRipple",slot:"Root"})({overflow:"hidden",pointerEvents:"none",position:"absolute",zIndex:0,top:0,right:0,bottom:0,left:0,borderRadius:"inherit"}),wo=(0,Wn.Ay)(mo,{name:"MuiTouchRipple",slot:"Ripple"})`
  opacity: 0;
  position: absolute;

  &.${go.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${yo};
    animation-duration: ${550}ms;
    animation-timing-function: ${e=>{let{theme:t}=e;return t.transitions.easing.easeInOut}};
  }

  &.${go.ripplePulsate} {
    animation-duration: ${e=>{let{theme:t}=e;return t.transitions.duration.shorter}}ms;
  }

  & .${go.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${go.childLeaving} {
    opacity: 0;
    animation-name: ${bo};
    animation-duration: ${550}ms;
    animation-timing-function: ${e=>{let{theme:t}=e;return t.transitions.easing.easeInOut}};
  }

  & .${go.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${vo};
    animation-duration: 2500ms;
    animation-timing-function: ${e=>{let{theme:t}=e;return t.transitions.easing.easeInOut}};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`,ko=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiTouchRipple"}),{center:a=!1,classes:s={},className:i,...o}=r,[l,u]=t.useState([]),c=t.useRef(0),d=t.useRef(null);t.useEffect((()=>{d.current&&(d.current(),d.current=null)}),[l]);const h=t.useRef(!1),p=ls(),f=t.useRef(null),m=t.useRef(null),g=t.useCallback((e=>{const{pulsate:t,rippleX:n,rippleY:r,rippleSize:a,cb:i}=e;u((e=>[...e,(0,$n.jsx)(wo,{classes:{ripple:(0,vn.A)(s.ripple,go.ripple),rippleVisible:(0,vn.A)(s.rippleVisible,go.rippleVisible),ripplePulsate:(0,vn.A)(s.ripplePulsate,go.ripplePulsate),child:(0,vn.A)(s.child,go.child),childLeaving:(0,vn.A)(s.childLeaving,go.childLeaving),childPulsate:(0,vn.A)(s.childPulsate,go.childPulsate)},timeout:550,pulsate:t,rippleX:n,rippleY:r,rippleSize:a},c.current)])),c.current+=1,d.current=i}),[s]),y=t.useCallback((function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>{};const{pulsate:r=!1,center:s=a||t.pulsate,fakeElement:i=!1}=t;if("mousedown"===e?.type&&h.current)return void(h.current=!1);"touchstart"===e?.type&&(h.current=!0);const o=i?null:m.current,l=o?o.getBoundingClientRect():{width:0,height:0,left:0,top:0};let u,c,d;if(s||void 0===e||0===e.clientX&&0===e.clientY||!e.clientX&&!e.touches)u=Math.round(l.width/2),c=Math.round(l.height/2);else{const{clientX:t,clientY:n}=e.touches&&e.touches.length>0?e.touches[0]:e;u=Math.round(t-l.left),c=Math.round(n-l.top)}if(s)d=Math.sqrt((2*l.width**2+l.height**2)/3),d%2===0&&(d+=1);else{const e=2*Math.max(Math.abs((o?o.clientWidth:0)-u),u)+2,t=2*Math.max(Math.abs((o?o.clientHeight:0)-c),c)+2;d=Math.sqrt(e**2+t**2)}e?.touches?null===f.current&&(f.current=()=>{g({pulsate:r,rippleX:u,rippleY:c,rippleSize:d,cb:n})},p.start(80,(()=>{f.current&&(f.current(),f.current=null)}))):g({pulsate:r,rippleX:u,rippleY:c,rippleSize:d,cb:n})}),[a,g,p]),b=t.useCallback((()=>{y({},{pulsate:!0})}),[y]),v=t.useCallback(((e,t)=>{if(p.clear(),"touchend"===e?.type&&f.current)return f.current(),f.current=null,void p.start(0,(()=>{v(e,t)}));f.current=null,u((e=>e.length>0?e.slice(1):e)),d.current=t}),[p]);return t.useImperativeHandle(n,(()=>({pulsate:b,start:y,stop:v})),[b,y,v]),(0,$n.jsx)(xo,{className:(0,vn.A)(go.root,s.root,i),ref:m,...o,children:(0,$n.jsx)(fo,{component:null,exit:!0,children:l})})})),So=ko;function Io(e){return(0,Kn.Ay)("MuiButtonBase",e)}const To=(0,Fn.A)("MuiButtonBase",["root","disabled","focusVisible"]),No=(0,Wn.Ay)("button",{name:"MuiButtonBase",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"inline-flex",alignItems:"center",justifyContent:"center",position:"relative",boxSizing:"border-box",WebkitTapHighlightColor:"transparent",backgroundColor:"transparent",outline:0,border:0,margin:0,borderRadius:0,padding:0,cursor:"pointer",userSelect:"none",verticalAlign:"middle",MozAppearance:"none",WebkitAppearance:"none",textDecoration:"none",color:"inherit","&::-moz-focus-inner":{borderStyle:"none"},[`&.${To.disabled}`]:{pointerEvents:"none",cursor:"default"},"@media print":{colorAdjust:"exact"}}),Co=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiButtonBase"}),{action:a,centerRipple:s=!1,children:i,className:o,component:l="button",disabled:u=!1,disableRipple:c=!1,disableTouchRipple:d=!1,focusRipple:h=!1,focusVisibleClassName:p,LinkComponent:f="a",onBlur:m,onClick:g,onContextMenu:y,onDragLeave:b,onFocus:v,onFocusVisible:x,onKeyDown:w,onKeyUp:k,onMouseDown:S,onMouseLeave:I,onMouseUp:T,onTouchEnd:N,onTouchMove:C,onTouchStart:A,tabIndex:E=0,TouchRippleProps:_,touchRippleRef:$,type:R,...D}=r,M=t.useRef(null),F=io.use(),O=(0,_r.A)(F.ref,$),[P,L]=t.useState(!1);u&&P&&L(!1),t.useImperativeHandle(a,(()=>({focusVisible:()=>{L(!0),M.current.focus()}})),[]);const z=F.shouldMount&&!c&&!u;function B(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:d;return(0,so.A)((r=>{t&&t(r);return n||F[e](r),!0}))}t.useEffect((()=>{P&&h&&!c&&F.pulsate()}),[c,h,P,F]);const V=B("start",S),W=B("stop",y),U=B("stop",b),j=B("stop",T),G=B("stop",(e=>{P&&e.preventDefault(),I&&I(e)})),H=B("start",A),q=B("stop",N),K=B("stop",C),Y=B("stop",(e=>{ao(e.target)||L(!1),m&&m(e)}),!1),X=(0,so.A)((e=>{M.current||(M.current=e.currentTarget),ao(e.target)&&(L(!0),x&&x(e)),v&&v(e)})),Q=()=>{const e=M.current;return l&&"button"!==l&&!("A"===e.tagName&&e.href)},Z=(0,so.A)((e=>{h&&!e.repeat&&P&&" "===e.key&&F.stop(e,(()=>{F.start(e)})),e.target===e.currentTarget&&Q()&&" "===e.key&&e.preventDefault(),w&&w(e),e.target===e.currentTarget&&Q()&&"Enter"===e.key&&!u&&(e.preventDefault(),g&&g(e))})),J=(0,so.A)((e=>{h&&" "===e.key&&P&&!e.defaultPrevented&&F.stop(e,(()=>{F.pulsate(e)})),k&&k(e),g&&e.target===e.currentTarget&&Q()&&" "===e.key&&!e.defaultPrevented&&g(e)}));let ee=l;"button"===ee&&(D.href||D.to)&&(ee=f);const te={};"button"===ee?(te.type=void 0===R?"button":R,te.disabled=u):(D.href||D.to||(te.role="button"),u&&(te["aria-disabled"]=u));const ne=(0,_r.A)(n,M),re={...r,centerRipple:s,component:l,disabled:u,disableRipple:c,disableTouchRipple:d,focusRipple:h,tabIndex:E,focusVisible:P},ae=(e=>{const{disabled:t,focusVisible:n,focusVisibleClassName:r,classes:a}=e,s={root:["root",t&&"disabled",n&&"focusVisible"]},i=(0,Bn.A)(s,Io,a);return n&&r&&(i.root+=` ${r}`),i})(re);return(0,$n.jsxs)(No,{as:ee,className:(0,vn.A)(ae.root,o),ownerState:re,onBlur:Y,onClick:g,onContextMenu:W,onFocus:X,onKeyDown:Z,onKeyUp:J,onMouseDown:V,onMouseLeave:G,onMouseUp:j,onDragLeave:U,onTouchEnd:q,onTouchMove:K,onTouchStart:H,ref:ne,tabIndex:u?-1:E,type:R,...te,...D,children:[i,z?(0,$n.jsx)(So,{ref:O,center:s,..._}):null]})}));function Ao(e){return(0,Kn.Ay)("MuiButton",e)}const Eo=(0,Fn.A)("MuiButton",["root","text","textInherit","textPrimary","textSecondary","textSuccess","textError","textInfo","textWarning","outlined","outlinedInherit","outlinedPrimary","outlinedSecondary","outlinedSuccess","outlinedError","outlinedInfo","outlinedWarning","contained","containedInherit","containedPrimary","containedSecondary","containedSuccess","containedError","containedInfo","containedWarning","disableElevation","focusVisible","disabled","colorInherit","colorPrimary","colorSecondary","colorSuccess","colorError","colorInfo","colorWarning","textSizeSmall","textSizeMedium","textSizeLarge","outlinedSizeSmall","outlinedSizeMedium","outlinedSizeLarge","containedSizeSmall","containedSizeMedium","containedSizeLarge","sizeMedium","sizeSmall","sizeLarge","fullWidth","startIcon","endIcon","icon","iconSizeSmall","iconSizeMedium","iconSizeLarge"]);const _o=t.createContext({});const $o=t.createContext(void 0),Ro=[{props:{size:"small"},style:{"& > *:nth-of-type(1)":{fontSize:18}}},{props:{size:"medium"},style:{"& > *:nth-of-type(1)":{fontSize:20}}},{props:{size:"large"},style:{"& > *:nth-of-type(1)":{fontSize:22}}}],Do=(0,Wn.Ay)(Co,{shouldForwardProp:e=>(0,jr.A)(e)||"classes"===e,name:"MuiButton",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],t[`${n.variant}${(0,lr.A)(n.color)}`],t[`size${(0,lr.A)(n.size)}`],t[`${n.variant}Size${(0,lr.A)(n.size)}`],"inherit"===n.color&&t.colorInherit,n.disableElevation&&t.disableElevation,n.fullWidth&&t.fullWidth]}})((0,Gn.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?t.palette.grey[300]:t.palette.grey[800],r="light"===t.palette.mode?t.palette.grey.A100:t.palette.grey[700];return{...t.typography.button,minWidth:64,padding:"6px 16px",border:0,borderRadius:(t.vars||t).shape.borderRadius,transition:t.transitions.create(["background-color","box-shadow","border-color","color"],{duration:t.transitions.duration.short}),"&:hover":{textDecoration:"none"},[`&.${Eo.disabled}`]:{color:(t.vars||t).palette.action.disabled},variants:[{props:{variant:"contained"},style:{color:"var(--variant-containedColor)",backgroundColor:"var(--variant-containedBg)",boxShadow:(t.vars||t).shadows[2],"&:hover":{boxShadow:(t.vars||t).shadows[4],"@media (hover: none)":{boxShadow:(t.vars||t).shadows[2]}},"&:active":{boxShadow:(t.vars||t).shadows[8]},[`&.${Eo.focusVisible}`]:{boxShadow:(t.vars||t).shadows[6]},[`&.${Eo.disabled}`]:{color:(t.vars||t).palette.action.disabled,boxShadow:(t.vars||t).shadows[0],backgroundColor:(t.vars||t).palette.action.disabledBackground}}},{props:{variant:"outlined"},style:{padding:"5px 15px",border:"1px solid currentColor",borderColor:"var(--variant-outlinedBorder, currentColor)",backgroundColor:"var(--variant-outlinedBg)",color:"var(--variant-outlinedColor)",[`&.${Eo.disabled}`]:{border:`1px solid ${(t.vars||t).palette.action.disabledBackground}`}}},{props:{variant:"text"},style:{padding:"6px 8px",color:"var(--variant-textColor)",backgroundColor:"var(--variant-textBg)"}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.dark&&t.contrastText})).map((e=>{let[n]=e;return{props:{color:n},style:{"--variant-textColor":(t.vars||t).palette[n].main,"--variant-outlinedColor":(t.vars||t).palette[n].main,"--variant-outlinedBorder":t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.5)`:(0,Vn.X4)(t.palette[n].main,.5),"--variant-containedColor":(t.vars||t).palette[n].contrastText,"--variant-containedBg":(t.vars||t).palette[n].main,"@media (hover: hover)":{"&:hover":{"--variant-containedBg":(t.vars||t).palette[n].dark,"--variant-textBg":t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Vn.X4)(t.palette[n].main,t.palette.action.hoverOpacity),"--variant-outlinedBorder":(t.vars||t).palette[n].main,"--variant-outlinedBg":t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Vn.X4)(t.palette[n].main,t.palette.action.hoverOpacity)}}}}})),{props:{color:"inherit"},style:{"--variant-containedColor":t.vars?t.vars.palette.text.primary:t.palette.getContrastText?.(n),"--variant-containedBg":t.vars?t.vars.palette.Button.inheritContainedBg:n,"@media (hover: hover)":{"&:hover":{"--variant-containedBg":t.vars?t.vars.palette.Button.inheritContainedHoverBg:r,"--variant-textBg":t.vars?`rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Vn.X4)(t.palette.text.primary,t.palette.action.hoverOpacity),"--variant-outlinedBg":t.vars?`rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Vn.X4)(t.palette.text.primary,t.palette.action.hoverOpacity)}}}},{props:{size:"small",variant:"text"},style:{padding:"4px 5px",fontSize:t.typography.pxToRem(13)}},{props:{size:"large",variant:"text"},style:{padding:"8px 11px",fontSize:t.typography.pxToRem(15)}},{props:{size:"small",variant:"outlined"},style:{padding:"3px 9px",fontSize:t.typography.pxToRem(13)}},{props:{size:"large",variant:"outlined"},style:{padding:"7px 21px",fontSize:t.typography.pxToRem(15)}},{props:{size:"small",variant:"contained"},style:{padding:"4px 10px",fontSize:t.typography.pxToRem(13)}},{props:{size:"large",variant:"contained"},style:{padding:"8px 22px",fontSize:t.typography.pxToRem(15)}},{props:{disableElevation:!0},style:{boxShadow:"none","&:hover":{boxShadow:"none"},[`&.${Eo.focusVisible}`]:{boxShadow:"none"},"&:active":{boxShadow:"none"},[`&.${Eo.disabled}`]:{boxShadow:"none"}}},{props:{fullWidth:!0},style:{width:"100%"}}]}}))),Mo=(0,Wn.Ay)("span",{name:"MuiButton",slot:"StartIcon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.startIcon,t[`iconSize${(0,lr.A)(n.size)}`]]}})({display:"inherit",marginRight:8,marginLeft:-4,variants:[{props:{size:"small"},style:{marginLeft:-2}},...Ro]}),Fo=(0,Wn.Ay)("span",{name:"MuiButton",slot:"EndIcon",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.endIcon,t[`iconSize${(0,lr.A)(n.size)}`]]}})({display:"inherit",marginRight:-4,marginLeft:8,variants:[{props:{size:"small"},style:{marginRight:-2}},...Ro]}),Oo=t.forwardRef((function(e,n){const r=t.useContext(_o),a=t.useContext($o),s=(0,Ui.A)(r,e),i=(0,Hn.b)({props:s,name:"MuiButton"}),{children:o,color:l="primary",component:u="button",className:c,disabled:d=!1,disableElevation:h=!1,disableFocusRipple:p=!1,endIcon:f,focusVisibleClassName:m,fullWidth:g=!1,size:y="medium",startIcon:b,type:v,variant:x="text",...w}=i,k={...i,color:l,component:u,disabled:d,disableElevation:h,disableFocusRipple:p,fullWidth:g,size:y,type:v,variant:x},S=(e=>{const{color:t,disableElevation:n,fullWidth:r,size:a,variant:s,classes:i}=e,o={root:["root",s,`${s}${(0,lr.A)(t)}`,`size${(0,lr.A)(a)}`,`${s}Size${(0,lr.A)(a)}`,`color${(0,lr.A)(t)}`,n&&"disableElevation",r&&"fullWidth"],label:["label"],startIcon:["icon","startIcon",`iconSize${(0,lr.A)(a)}`],endIcon:["icon","endIcon",`iconSize${(0,lr.A)(a)}`]},l=(0,Bn.A)(o,Ao,i);return{...i,...l}})(k),I=b&&(0,$n.jsx)(Mo,{className:S.startIcon,ownerState:k,children:b}),T=f&&(0,$n.jsx)(Fo,{className:S.endIcon,ownerState:k,children:f}),N=a||"";return(0,$n.jsxs)(Do,{ownerState:k,className:(0,vn.A)(r.className,S.root,c,N),component:u,disabled:d,focusRipple:!p,focusVisibleClassName:(0,vn.A)(S.focusVisible,m),ref:n,type:v,...w,classes:S,children:[I,o,T]})})),Po=Oo;function Lo(e){return(0,Kn.Ay)("MuiAlert",e)}const zo=(0,Fn.A)("MuiAlert",["root","action","icon","message","filled","colorSuccess","colorInfo","colorWarning","colorError","filledSuccess","filledInfo","filledWarning","filledError","outlined","outlinedSuccess","outlinedInfo","outlinedWarning","outlinedError","standard","standardSuccess","standardInfo","standardWarning","standardError"]);function Bo(e){return(0,Kn.Ay)("MuiIconButton",e)}const Vo=(0,Fn.A)("MuiIconButton",["root","disabled","colorInherit","colorPrimary","colorSecondary","colorError","colorInfo","colorSuccess","colorWarning","edgeStart","edgeEnd","sizeSmall","sizeMedium","sizeLarge"]),Wo=(0,Wn.Ay)(Co,{name:"MuiIconButton",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,"default"!==n.color&&t[`color${(0,lr.A)(n.color)}`],n.edge&&t[`edge${(0,lr.A)(n.edge)}`],t[`size${(0,lr.A)(n.size)}`]]}})((0,Gn.A)((e=>{let{theme:t}=e;return{textAlign:"center",flex:"0 0 auto",fontSize:t.typography.pxToRem(24),padding:8,borderRadius:"50%",color:(t.vars||t).palette.action.active,transition:t.transitions.create("background-color",{duration:t.transitions.duration.shortest}),variants:[{props:{disableRipple:!1},style:{"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Vn.X4)(t.palette.action.active,t.palette.action.hoverOpacity),"@media (hover: none)":{backgroundColor:"transparent"}}}},{props:{edge:"start"},style:{marginLeft:-12}},{props:{edge:"start",size:"small"},style:{marginLeft:-3}},{props:{edge:"end"},style:{marginRight:-12}},{props:{edge:"end",size:"small"},style:{marginRight:-3}}]}})),(0,Gn.A)((e=>{let{theme:t}=e;return{variants:[{props:{color:"inherit"},style:{color:"inherit"}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars||t).palette[n].main}}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n,disableRipple:!1},style:{"&:hover":{backgroundColor:t.vars?`rgba(${(t.vars||t).palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Vn.X4)((t.vars||t).palette[n].main,t.palette.action.hoverOpacity),"@media (hover: none)":{backgroundColor:"transparent"}}}}})),{props:{size:"small"},style:{padding:5,fontSize:t.typography.pxToRem(18)}},{props:{size:"large"},style:{padding:12,fontSize:t.typography.pxToRem(28)}}],[`&.${Vo.disabled}`]:{backgroundColor:"transparent",color:(t.vars||t).palette.action.disabled}}}))),Uo=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiIconButton"}),{edge:r=!1,children:a,className:s,color:i="default",disabled:o=!1,disableFocusRipple:l=!1,disableRipple:u=!1,size:c="medium",...d}=n,h={...n,edge:r,color:i,disabled:o,disableFocusRipple:l,disableRipple:u,size:c},p=(e=>{const{classes:t,disabled:n,color:r,edge:a,size:s}=e,i={root:["root",n&&"disabled","default"!==r&&`color${(0,lr.A)(r)}`,a&&`edge${(0,lr.A)(a)}`,`size${(0,lr.A)(s)}`]};return(0,Bn.A)(i,Bo,t)})(h);return(0,$n.jsx)(Wo,{className:(0,vn.A)(p.root,s),centerRipple:!0,focusRipple:!l,disabled:o,disableRipple:u,ref:t,...d,ownerState:h,children:a})})),jo=(0,Vi.A)((0,$n.jsx)("path",{d:"M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"}),"SuccessOutlined"),Go=(0,Vi.A)((0,$n.jsx)("path",{d:"M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"}),"ReportProblemOutlined"),Ho=(0,Vi.A)((0,$n.jsx)("path",{d:"M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"}),"ErrorOutline"),qo=(0,Vi.A)((0,$n.jsx)("path",{d:"M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"}),"InfoOutlined"),Ko=(0,Vi.A)((0,$n.jsx)("path",{d:"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"}),"Close"),Yo=(0,Wn.Ay)(Zn,{name:"MuiAlert",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],t[`${n.variant}${(0,lr.A)(n.color||n.severity)}`]]}})((0,Gn.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?Vn.e$:Vn.a,r="light"===t.palette.mode?Vn.a:Vn.e$;return{...t.typography.body2,backgroundColor:"transparent",display:"flex",padding:"6px 16px",variants:[...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.light})).map((e=>{let[a]=e;return{props:{colorSeverity:a,variant:"standard"},style:{color:t.vars?t.vars.palette.Alert[`${a}Color`]:n(t.palette[a].light,.6),backgroundColor:t.vars?t.vars.palette.Alert[`${a}StandardBg`]:r(t.palette[a].light,.9),[`& .${zo.icon}`]:t.vars?{color:t.vars.palette.Alert[`${a}IconColor`]}:{color:t.palette[a].main}}}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.light})).map((e=>{let[r]=e;return{props:{colorSeverity:r,variant:"outlined"},style:{color:t.vars?t.vars.palette.Alert[`${r}Color`]:n(t.palette[r].light,.6),border:`1px solid ${(t.vars||t).palette[r].light}`,[`& .${zo.icon}`]:t.vars?{color:t.vars.palette.Alert[`${r}IconColor`]}:{color:t.palette[r].main}}}})),...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.dark})).map((e=>{let[n]=e;return{props:{colorSeverity:n,variant:"filled"},style:{fontWeight:t.typography.fontWeightMedium,...t.vars?{color:t.vars.palette.Alert[`${n}FilledColor`],backgroundColor:t.vars.palette.Alert[`${n}FilledBg`]}:{backgroundColor:"dark"===t.palette.mode?t.palette[n].dark:t.palette[n].main,color:t.palette.getContrastText(t.palette[n].main)}}}}))]}}))),Xo=(0,Wn.Ay)("div",{name:"MuiAlert",slot:"Icon",overridesResolver:(e,t)=>t.icon})({marginRight:12,padding:"7px 0",display:"flex",fontSize:22,opacity:.9}),Qo=(0,Wn.Ay)("div",{name:"MuiAlert",slot:"Message",overridesResolver:(e,t)=>t.message})({padding:"8px 0",minWidth:0,overflow:"auto"}),Zo=(0,Wn.Ay)("div",{name:"MuiAlert",slot:"Action",overridesResolver:(e,t)=>t.action})({display:"flex",alignItems:"flex-start",padding:"4px 0 0 16px",marginLeft:"auto",marginRight:-8}),Jo={success:(0,$n.jsx)(jo,{fontSize:"inherit"}),warning:(0,$n.jsx)(Go,{fontSize:"inherit"}),error:(0,$n.jsx)(Ho,{fontSize:"inherit"}),info:(0,$n.jsx)(qo,{fontSize:"inherit"})},el=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiAlert"}),{action:r,children:a,className:s,closeText:i="Close",color:o,components:l={},componentsProps:u={},icon:c,iconMapping:d=Jo,onClose:h,role:p="alert",severity:f="success",slotProps:m={},slots:g={},variant:y="standard",...b}=n,v={...n,color:o,severity:f,variant:y,colorSeverity:o||f},x=(e=>{const{variant:t,color:n,severity:r,classes:a}=e,s={root:["root",`color${(0,lr.A)(n||r)}`,`${t}${(0,lr.A)(n||r)}`,`${t}`],icon:["icon"],message:["message"],action:["action"]};return(0,Bn.A)(s,Lo,a)})(v),w={slots:{closeButton:l.CloseButton,closeIcon:l.CloseIcon,...g},slotProps:{...u,...m}},[k,S]=Ps("closeButton",{elementType:Uo,externalForwardedProps:w,ownerState:v}),[I,T]=Ps("closeIcon",{elementType:Ko,externalForwardedProps:w,ownerState:v});return(0,$n.jsxs)(Yo,{role:p,elevation:0,ownerState:v,className:(0,vn.A)(x.root,s),ref:t,...b,children:[!1!==c?(0,$n.jsx)(Xo,{ownerState:v,className:x.icon,children:c||d[f]||Jo[f]}):null,(0,$n.jsx)(Qo,{ownerState:v,className:x.message,children:a}),null!=r?(0,$n.jsx)(Zo,{ownerState:v,className:x.action,children:r}):null,null==r&&h?(0,$n.jsx)(Zo,{ownerState:v,className:x.action,children:(0,$n.jsx)(k,{size:"small","aria-label":i,title:i,color:"inherit",onClick:h,...S,children:(0,$n.jsx)(I,{fontSize:"small",...T})})}):null]})})),tl=el;function nl(e){return(0,Kn.Ay)("MuiLink",e)}const rl=(0,Fn.A)("MuiLink",["root","underlineNone","underlineHover","underlineAlways","button","focusVisible"]);var al=n(6224);const sl=e=>{let{theme:t,ownerState:n}=e;const r=n.color,a=(0,al.Yn)(t,`palette.${r}`,!1)||n.color,s=(0,al.Yn)(t,`palette.${r}Channel`);return"vars"in t&&s?`rgba(${s} / 0.4)`:(0,Vn.X4)(a,.4)},il={primary:!0,secondary:!0,error:!0,info:!0,success:!0,warning:!0,textPrimary:!0,textSecondary:!0,textDisabled:!0},ol=(0,Wn.Ay)(mr,{name:"MuiLink",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`underline${(0,lr.A)(n.underline)}`],"button"===n.component&&t.button]}})((0,Gn.A)((e=>{let{theme:t}=e;return{variants:[{props:{underline:"none"},style:{textDecoration:"none"}},{props:{underline:"hover"},style:{textDecoration:"none","&:hover":{textDecoration:"underline"}}},{props:{underline:"always"},style:{textDecoration:"underline","&:hover":{textDecorationColor:"inherit"}}},{props:e=>{let{underline:t,ownerState:n}=e;return"always"===t&&"inherit"!==n.color},style:{textDecorationColor:"var(--Link-underlineColor)"}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{underline:"always",color:n},style:{"--Link-underlineColor":t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.4)`:(0,Vn.X4)(t.palette[n].main,.4)}}})),{props:{underline:"always",color:"textPrimary"},style:{"--Link-underlineColor":t.vars?`rgba(${t.vars.palette.text.primaryChannel} / 0.4)`:(0,Vn.X4)(t.palette.text.primary,.4)}},{props:{underline:"always",color:"textSecondary"},style:{"--Link-underlineColor":t.vars?`rgba(${t.vars.palette.text.secondaryChannel} / 0.4)`:(0,Vn.X4)(t.palette.text.secondary,.4)}},{props:{underline:"always",color:"textDisabled"},style:{"--Link-underlineColor":(t.vars||t).palette.text.disabled}},{props:{component:"button"},style:{position:"relative",WebkitTapHighlightColor:"transparent",backgroundColor:"transparent",outline:0,border:0,margin:0,borderRadius:0,padding:0,cursor:"pointer",userSelect:"none",verticalAlign:"middle",MozAppearance:"none",WebkitAppearance:"none","&::-moz-focus-inner":{borderStyle:"none"},[`&.${rl.focusVisible}`]:{outline:"auto"}}}]}}))),ll=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiLink"}),a=jn(),{className:s,color:i="primary",component:o="a",onBlur:l,onFocus:u,TypographyClasses:c,underline:d="always",variant:h="inherit",sx:p,...f}=r,[m,g]=t.useState(!1),y={...r,color:i,component:o,focusVisible:m,underline:d,variant:h},b=(e=>{const{classes:t,component:n,focusVisible:r,underline:a}=e,s={root:["root",`underline${(0,lr.A)(a)}`,"button"===n&&"button",r&&"focusVisible"]};return(0,Bn.A)(s,nl,t)})(y);return(0,$n.jsx)(ol,{color:i,className:(0,vn.A)(b.root,s),classes:c,component:o,onBlur:e=>{ao(e.target)||g(!1),l&&l(e)},onFocus:e=>{ao(e.target)&&g(!0),u&&u(e)},ref:n,ownerState:y,variant:h,...f,sx:[...void 0===il[i]?[{color:i}]:[],...Array.isArray(p)?p:[p]],style:{...f.style,..."always"===d&&"inherit"!==i&&!il[i]&&{"--Link-underlineColor":sl({theme:a,ownerState:y})}}})})),ul=ll;var cl=n(4914);const dl=()=>{const[e,n]=(0,t.useState)(!1),r=Qt(),a=b((e=>e.user.generatedId));(0,t.useEffect)((()=>{a||r("/error")}),[a,r]);return a?(0,$n.jsx)(zn,{display:"flex",justifyContent:"center",alignItems:"center",minHeight:"100vh",bgcolor:"#f5f5f5",padding:3,children:(0,$n.jsxs)(Zn,{elevation:3,sx:{padding:4,borderRadius:2,maxWidth:500},children:[(0,$n.jsx)(mr,{variant:"h4",textAlign:"center",gutterBottom:!0,children:"Congratulations!"}),(0,$n.jsx)(mr,{variant:"body1",textAlign:"center",gutterBottom:!0,children:"You have been successfully registered in our system."}),(0,$n.jsx)(mr,{variant:"h6",textAlign:"center",gutterBottom:!0,children:"User ID:"}),(0,$n.jsxs)(zn,{display:"flex",alignItems:"center",justifyContent:"center",mb:2,children:[(0,$n.jsx)(ro,{value:a,InputProps:{readOnly:!0},sx:{width:"80%"}}),(0,$n.jsx)(Po,{variant:"contained",color:"primary",onClick:()=>{navigator.clipboard.writeText(a),n(!0),setTimeout((()=>n(!1)),2e3)},sx:{ml:2},startIcon:(0,$n.jsx)(cl.A,{}),children:"Copy"})]}),e&&(0,$n.jsx)(tl,{severity:"success",sx:{mb:2},onClose:()=>n(!1),children:"User ID copied to clipboard!"}),(0,$n.jsx)(mr,{variant:"body2",textAlign:"center",children:"Kindly save this ID safely as it will be used to authenticate you."}),(0,$n.jsxs)(mr,{variant:"body2",textAlign:"center",children:["Want to use this ID \xa0",(0,$n.jsx)(ul,{component:"button",variant:"body2",onClick:()=>{r("/login")},children:"Click here to Login"})]})]})}):null};var hl=n(7598),pl=n(3860);const fl=(0,pl.Ay)(),ml=(0,Nn.A)(),gl=fl("div",{name:"MuiContainer",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`maxWidth${(0,hl.A)(String(n.maxWidth))}`],n.fixed&&t.fixed,n.disableGutters&&t.disableGutters]}}),yl=e=>Gi({props:e,name:"MuiContainer",defaultTheme:ml});const bl=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{createStyledComponent:n=gl,useThemeProps:r=yl,componentName:a="MuiContainer"}=e,s=n((e=>{let{theme:t,ownerState:n}=e;return{width:"100%",marginLeft:"auto",boxSizing:"border-box",marginRight:"auto",...!n.disableGutters&&{paddingLeft:t.spacing(2),paddingRight:t.spacing(2),[t.breakpoints.up("sm")]:{paddingLeft:t.spacing(3),paddingRight:t.spacing(3)}}}}),(e=>{let{theme:t,ownerState:n}=e;return n.fixed&&Object.keys(t.breakpoints.values).reduce(((e,n)=>{const r=n,a=t.breakpoints.values[r];return 0!==a&&(e[t.breakpoints.up(r)]={maxWidth:`${a}${t.breakpoints.unit}`}),e}),{})}),(e=>{let{theme:t,ownerState:n}=e;return{..."xs"===n.maxWidth&&{[t.breakpoints.up("xs")]:{maxWidth:Math.max(t.breakpoints.values.xs,444)}},...n.maxWidth&&"xs"!==n.maxWidth&&{[t.breakpoints.up(n.maxWidth)]:{maxWidth:`${t.breakpoints.values[n.maxWidth]}${t.breakpoints.unit}`}}}})),i=t.forwardRef((function(e,t){const n=r(e),{className:i,component:o="div",disableGutters:l=!1,fixed:u=!1,maxWidth:c="lg",classes:d,...h}=n,p={...n,component:o,disableGutters:l,fixed:u,maxWidth:c},f=((e,t)=>{const{classes:n,fixed:r,disableGutters:a,maxWidth:s}=e,i={root:["root",s&&`maxWidth${(0,hl.A)(String(s))}`,r&&"fixed",a&&"disableGutters"]};return(0,Bn.A)(i,(e=>(0,Kn.Ay)(t,e)),n)})(p,a);return(0,$n.jsx)(s,{as:o,ownerState:p,className:(0,vn.A)(f.root,i),ref:t,...h})}));return i}({createStyledComponent:(0,Wn.Ay)("div",{name:"MuiContainer",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`maxWidth${(0,lr.A)(String(n.maxWidth))}`],n.fixed&&t.fixed,n.disableGutters&&t.disableGutters]}}),useThemeProps:e=>Hi({props:e,name:"MuiContainer"})}),vl=bl;function xl(e){return(0,Kn.Ay)("MuiDialog",e)}const wl=(0,Fn.A)("MuiDialog",["root","scrollPaper","scrollBody","container","paper","paperScrollPaper","paperScrollBody","paperWidthFalse","paperWidthXs","paperWidthSm","paperWidthMd","paperWidthLg","paperWidthXl","paperFullWidth","paperFullScreen"]);const kl=t.createContext({}),Sl=(0,Wn.Ay)(Us,{name:"MuiDialog",slot:"Backdrop",overrides:(e,t)=>t.backdrop})({zIndex:-1}),Il=(0,Wn.Ay)(ri,{name:"MuiDialog",slot:"Root",overridesResolver:(e,t)=>t.root})({"@media print":{position:"absolute !important"}}),Tl=(0,Wn.Ay)("div",{name:"MuiDialog",slot:"Container",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.container,t[`scroll${(0,lr.A)(n.scroll)}`]]}})({height:"100%","@media print":{height:"auto"},outline:0,variants:[{props:{scroll:"paper"},style:{display:"flex",justifyContent:"center",alignItems:"center"}},{props:{scroll:"body"},style:{overflowY:"auto",overflowX:"hidden",textAlign:"center","&::after":{content:'""',display:"inline-block",verticalAlign:"middle",height:"100%",width:"0"}}}]}),Nl=(0,Wn.Ay)(Zn,{name:"MuiDialog",slot:"Paper",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.paper,t[`scrollPaper${(0,lr.A)(n.scroll)}`],t[`paperWidth${(0,lr.A)(String(n.maxWidth))}`],n.fullWidth&&t.paperFullWidth,n.fullScreen&&t.paperFullScreen]}})((0,Gn.A)((e=>{let{theme:t}=e;return{margin:32,position:"relative","@media print":{overflowY:"visible",boxShadow:"none"},variants:[{props:{scroll:"paper"},style:{display:"flex",flexDirection:"column",maxHeight:"calc(100% - 64px)"}},{props:{scroll:"body"},style:{display:"inline-block",verticalAlign:"middle",textAlign:"initial"}},{props:e=>{let{ownerState:t}=e;return!t.maxWidth},style:{maxWidth:"calc(100% - 64px)"}},{props:{maxWidth:"xs"},style:{maxWidth:"px"===t.breakpoints.unit?Math.max(t.breakpoints.values.xs,444):`max(${t.breakpoints.values.xs}${t.breakpoints.unit}, 444px)`,[`&.${wl.paperScrollBody}`]:{[t.breakpoints.down(Math.max(t.breakpoints.values.xs,444)+64)]:{maxWidth:"calc(100% - 64px)"}}}},...Object.keys(t.breakpoints.values).filter((e=>"xs"!==e)).map((e=>({props:{maxWidth:e},style:{maxWidth:`${t.breakpoints.values[e]}${t.breakpoints.unit}`,[`&.${wl.paperScrollBody}`]:{[t.breakpoints.down(t.breakpoints.values[e]+64)]:{maxWidth:"calc(100% - 64px)"}}}}))),{props:e=>{let{ownerState:t}=e;return t.fullWidth},style:{width:"calc(100% - 64px)"}},{props:e=>{let{ownerState:t}=e;return t.fullScreen},style:{margin:0,width:"100%",maxWidth:"100%",height:"100%",maxHeight:"none",borderRadius:0,[`&.${wl.paperScrollBody}`]:{margin:0,maxWidth:"100%"}}}]}}))),Cl=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiDialog"}),a=jn(),s={enter:a.transitions.duration.enteringScreen,exit:a.transitions.duration.leavingScreen},{"aria-describedby":i,"aria-labelledby":o,BackdropComponent:l,BackdropProps:u,children:c,className:d,disableEscapeKeyDown:h=!1,fullScreen:p=!1,fullWidth:f=!1,maxWidth:m="sm",onBackdropClick:g,onClick:y,onClose:b,open:v,PaperComponent:x=Zn,PaperProps:w={},scroll:k="paper",TransitionComponent:S=Bs,transitionDuration:I=s,TransitionProps:T,...N}=r,C={...r,disableEscapeKeyDown:h,fullScreen:p,fullWidth:f,maxWidth:m,scroll:k},A=(e=>{const{classes:t,scroll:n,maxWidth:r,fullWidth:a,fullScreen:s}=e,i={root:["root"],container:["container",`scroll${(0,lr.A)(n)}`],paper:["paper",`paperScroll${(0,lr.A)(n)}`,`paperWidth${(0,lr.A)(String(r))}`,a&&"paperFullWidth",s&&"paperFullScreen"]};return(0,Bn.A)(i,xl,t)})(C),E=t.useRef(),_=(0,gr.A)(o),$=t.useMemo((()=>({titleId:_})),[_]);return(0,$n.jsx)(Il,{className:(0,vn.A)(A.root,d),closeAfterTransition:!0,components:{Backdrop:Sl},componentsProps:{backdrop:{transitionDuration:I,as:l,...u}},disableEscapeKeyDown:h,onClose:b,open:v,ref:n,onClick:e=>{y&&y(e),E.current&&(E.current=null,g&&g(e),b&&b(e,"backdropClick"))},ownerState:C,...N,children:(0,$n.jsx)(S,{appear:!0,in:v,timeout:I,role:"presentation",...T,children:(0,$n.jsx)(Tl,{className:(0,vn.A)(A.container),onMouseDown:e=>{E.current=e.target===e.currentTarget},ownerState:C,children:(0,$n.jsx)(Nl,{as:x,elevation:24,role:"dialog","aria-describedby":i,"aria-labelledby":_,...w,className:(0,vn.A)(A.paper,w.className),ownerState:C,children:(0,$n.jsx)(kl.Provider,{value:$,children:c})})})})})}));function Al(e){return(0,Kn.Ay)("MuiDialogTitle",e)}const El=(0,Fn.A)("MuiDialogTitle",["root"]),_l=(0,Wn.Ay)(mr,{name:"MuiDialogTitle",slot:"Root",overridesResolver:(e,t)=>t.root})({padding:"16px 24px",flex:"0 0 auto"}),$l=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiDialogTitle"}),{className:a,id:s,...i}=r,o=r,l=(e=>{const{classes:t}=e;return(0,Bn.A)({root:["root"]},Al,t)})(o),{titleId:u=s}=t.useContext(kl);return(0,$n.jsx)(_l,{component:"h2",className:(0,vn.A)(l.root,a),ownerState:o,ref:n,variant:"h6",id:s??u,...i})}));function Rl(e){return(0,Kn.Ay)("MuiDialogContent",e)}(0,Fn.A)("MuiDialogContent",["root","dividers"]);const Dl=(0,Wn.Ay)("div",{name:"MuiDialogContent",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.dividers&&t.dividers]}})((0,Gn.A)((e=>{let{theme:t}=e;return{flex:"1 1 auto",WebkitOverflowScrolling:"touch",overflowY:"auto",padding:"20px 24px",variants:[{props:e=>{let{ownerState:t}=e;return t.dividers},style:{padding:"16px 24px",borderTop:`1px solid ${(t.vars||t).palette.divider}`,borderBottom:`1px solid ${(t.vars||t).palette.divider}`}},{props:e=>{let{ownerState:t}=e;return!t.dividers},style:{[`.${El.root} + &`]:{paddingTop:0}}}]}}))),Ml=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiDialogContent"}),{className:r,dividers:a=!1,...s}=n,i={...n,dividers:a},o=(e=>{const{classes:t,dividers:n}=e,r={root:["root",n&&"dividers"]};return(0,Bn.A)(r,Rl,t)})(i);return(0,$n.jsx)(Dl,{className:(0,vn.A)(o.root,r),ownerState:i,ref:t,...s})}));function Fl(e){return(0,Kn.Ay)("MuiDialogActions",e)}(0,Fn.A)("MuiDialogActions",["root","spacing"]);const Ol=(0,Wn.Ay)("div",{name:"MuiDialogActions",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,!n.disableSpacing&&t.spacing]}})({display:"flex",alignItems:"center",padding:8,justifyContent:"flex-end",flex:"0 0 auto",variants:[{props:e=>{let{ownerState:t}=e;return!t.disableSpacing},style:{"& > :not(style) ~ :not(style)":{marginLeft:8}}}]}),Pl=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiDialogActions"}),{className:r,disableSpacing:a=!1,...s}=n,i={...n,disableSpacing:a},o=(e=>{const{classes:t,disableSpacing:n}=e,r={root:["root",!n&&"spacing"]};return(0,Bn.A)(r,Fl,t)})(i);return(0,$n.jsx)(Ol,{className:(0,vn.A)(o.root,r),ownerState:i,ref:t,...s})}));var Ll=n(3531),zl=n(7948);const Bl=function(e){const t=[];let n=0;for(let r=0;r<e.length;r++){let a=e.charCodeAt(r);a<128?t[n++]=a:a<2048?(t[n++]=a>>6|192,t[n++]=63&a|128):55296===(64512&a)&&r+1<e.length&&56320===(64512&e.charCodeAt(r+1))?(a=65536+((1023&a)<<10)+(1023&e.charCodeAt(++r)),t[n++]=a>>18|240,t[n++]=a>>12&63|128,t[n++]=a>>6&63|128,t[n++]=63&a|128):(t[n++]=a>>12|224,t[n++]=a>>6&63|128,t[n++]=63&a|128)}return t},Vl={byteToCharMap_:null,charToByteMap_:null,byteToCharMapWebSafe_:null,charToByteMapWebSafe_:null,ENCODED_VALS_BASE:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",get ENCODED_VALS(){return this.ENCODED_VALS_BASE+"+/="},get ENCODED_VALS_WEBSAFE(){return this.ENCODED_VALS_BASE+"-_."},HAS_NATIVE_SUPPORT:"function"===typeof atob,encodeByteArray(e,t){if(!Array.isArray(e))throw Error("encodeByteArray takes an array as a parameter");this.init_();const n=t?this.byteToCharMapWebSafe_:this.byteToCharMap_,r=[];for(let a=0;a<e.length;a+=3){const t=e[a],s=a+1<e.length,i=s?e[a+1]:0,o=a+2<e.length,l=o?e[a+2]:0,u=t>>2,c=(3&t)<<4|i>>4;let d=(15&i)<<2|l>>6,h=63&l;o||(h=64,s||(d=64)),r.push(n[u],n[c],n[d],n[h])}return r.join("")},encodeString(e,t){return this.HAS_NATIVE_SUPPORT&&!t?btoa(e):this.encodeByteArray(Bl(e),t)},decodeString(e,t){return this.HAS_NATIVE_SUPPORT&&!t?atob(e):function(e){const t=[];let n=0,r=0;for(;n<e.length;){const a=e[n++];if(a<128)t[r++]=String.fromCharCode(a);else if(a>191&&a<224){const s=e[n++];t[r++]=String.fromCharCode((31&a)<<6|63&s)}else if(a>239&&a<365){const s=((7&a)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536;t[r++]=String.fromCharCode(55296+(s>>10)),t[r++]=String.fromCharCode(56320+(1023&s))}else{const s=e[n++],i=e[n++];t[r++]=String.fromCharCode((15&a)<<12|(63&s)<<6|63&i)}}return t.join("")}(this.decodeStringToByteArray(e,t))},decodeStringToByteArray(e,t){this.init_();const n=t?this.charToByteMapWebSafe_:this.charToByteMap_,r=[];for(let a=0;a<e.length;){const t=n[e.charAt(a++)],s=a<e.length?n[e.charAt(a)]:0;++a;const i=a<e.length?n[e.charAt(a)]:64;++a;const o=a<e.length?n[e.charAt(a)]:64;if(++a,null==t||null==s||null==i||null==o)throw new Wl;const l=t<<2|s>>4;if(r.push(l),64!==i){const e=s<<4&240|i>>2;if(r.push(e),64!==o){const e=i<<6&192|o;r.push(e)}}}return r},init_(){if(!this.byteToCharMap_){this.byteToCharMap_={},this.charToByteMap_={},this.byteToCharMapWebSafe_={},this.charToByteMapWebSafe_={};for(let e=0;e<this.ENCODED_VALS.length;e++)this.byteToCharMap_[e]=this.ENCODED_VALS.charAt(e),this.charToByteMap_[this.byteToCharMap_[e]]=e,this.byteToCharMapWebSafe_[e]=this.ENCODED_VALS_WEBSAFE.charAt(e),this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]]=e,e>=this.ENCODED_VALS_BASE.length&&(this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)]=e,this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)]=e)}}};class Wl extends Error{constructor(){super(...arguments),this.name="DecodeBase64StringError"}}const Ul=function(e){return function(e){const t=Bl(e);return Vl.encodeByteArray(t,!0)}(e).replace(/\./g,"")},jl=function(e){try{return Vl.decodeString(e,!0)}catch(KR){console.error("base64Decode failed: ",KR)}return null};const Gl=()=>function(){if("undefined"!==typeof self)return self;if("undefined"!==typeof window)return window;if("undefined"!==typeof n.g)return n.g;throw new Error("Unable to locate global object.")}().__FIREBASE_DEFAULTS__,Hl=()=>{try{return Gl()||(()=>{if("undefined"===typeof process)return;const e={NODE_ENV:"production",PUBLIC_URL:"/auth-tfjs",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0,REACT_APP_API_KEY:"'AIzaSyCMm9VBymR43tOkkv4wQ6szA2yGfH3j3RE';",REACT_APP_ENV_SENDER_ID:"1021363670094",REACT_APP_APP_ID:"1:1021363670094:web:252b1088a0266e0573c71f",REACT_APP_TOKEN:"d891e715-d5ab-49ee-8c4c-d14c25d7fb7a"}.__FIREBASE_DEFAULTS__;return e?JSON.parse(e):void 0})()||(()=>{if("undefined"===typeof document)return;let e;try{e=document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)}catch(KR){return}const t=e&&jl(e[1]);return t&&JSON.parse(t)})()}catch(KR){return void console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${KR}`)}},ql=e=>{const t=(e=>{var t,n;return null===(n=null===(t=Hl())||void 0===t?void 0:t.emulatorHosts)||void 0===n?void 0:n[e]})(e);if(!t)return;const n=t.lastIndexOf(":");if(n<=0||n+1===t.length)throw new Error(`Invalid host ${t} with no separate hostname and port!`);const r=parseInt(t.substring(n+1),10);return"["===t[0]?[t.substring(1,n-1),r]:[t.substring(0,n),r]},Kl=()=>{var e;return null===(e=Hl())||void 0===e?void 0:e.config};class Yl{constructor(){this.reject=()=>{},this.resolve=()=>{},this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}wrapCallback(e){return(t,n)=>{t?this.reject(t):this.resolve(n),"function"===typeof e&&(this.promise.catch((()=>{})),1===e.length?e(t):e(t,n))}}}function Xl(){return"undefined"!==typeof navigator&&"string"===typeof navigator.userAgent?navigator.userAgent:""}function Ql(){return!function(){var e;const t=null===(e=Hl())||void 0===e?void 0:e.forceEnvironment;if("node"===t)return!0;if("browser"===t)return!1;try{return"[object process]"===Object.prototype.toString.call(n.g.process)}catch(KR){return!1}}()&&!!navigator.userAgent&&navigator.userAgent.includes("Safari")&&!navigator.userAgent.includes("Chrome")}function Zl(){try{return"object"===typeof indexedDB}catch(KR){return!1}}class Jl extends Error{constructor(e,t,n){super(t),this.code=e,this.customData=n,this.name="FirebaseError",Object.setPrototypeOf(this,Jl.prototype),Error.captureStackTrace&&Error.captureStackTrace(this,eu.prototype.create)}}class eu{constructor(e,t,n){this.service=e,this.serviceName=t,this.errors=n}create(e){const t=(arguments.length<=1?void 0:arguments[1])||{},n=`${this.service}/${e}`,r=this.errors[e],a=r?function(e,t){return e.replace(tu,((e,n)=>{const r=t[n];return null!=r?String(r):`<${n}?>`}))}(r,t):"Error",s=`${this.serviceName}: ${a} (${n}).`;return new Jl(n,s,t)}}const tu=/\{\$([^}]+)}/g;function nu(e,t){if(e===t)return!0;const n=Object.keys(e),r=Object.keys(t);for(const a of n){if(!r.includes(a))return!1;const n=e[a],s=t[a];if(ru(n)&&ru(s)){if(!nu(n,s))return!1}else if(n!==s)return!1}for(const a of r)if(!n.includes(a))return!1;return!0}function ru(e){return null!==e&&"object"===typeof e}function au(e){return e&&e._delegate?e._delegate:e}class su{constructor(e,t,n){this.name=e,this.instanceFactory=t,this.type=n,this.multipleInstances=!1,this.serviceProps={},this.instantiationMode="LAZY",this.onInstanceCreated=null}setInstantiationMode(e){return this.instantiationMode=e,this}setMultipleInstances(e){return this.multipleInstances=e,this}setServiceProps(e){return this.serviceProps=e,this}setInstanceCreatedCallback(e){return this.onInstanceCreated=e,this}}const iu="[DEFAULT]";class ou{constructor(e,t){this.name=e,this.container=t,this.component=null,this.instances=new Map,this.instancesDeferred=new Map,this.instancesOptions=new Map,this.onInitCallbacks=new Map}get(e){const t=this.normalizeInstanceIdentifier(e);if(!this.instancesDeferred.has(t)){const e=new Yl;if(this.instancesDeferred.set(t,e),this.isInitialized(t)||this.shouldAutoInitialize())try{const n=this.getOrInitializeService({instanceIdentifier:t});n&&e.resolve(n)}catch(KR){}}return this.instancesDeferred.get(t).promise}getImmediate(e){var t;const n=this.normalizeInstanceIdentifier(null===e||void 0===e?void 0:e.identifier),r=null!==(t=null===e||void 0===e?void 0:e.optional)&&void 0!==t&&t;if(!this.isInitialized(n)&&!this.shouldAutoInitialize()){if(r)return null;throw Error(`Service ${this.name} is not available`)}try{return this.getOrInitializeService({instanceIdentifier:n})}catch(KR){if(r)return null;throw KR}}getComponent(){return this.component}setComponent(e){if(e.name!==this.name)throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);if(this.component)throw Error(`Component for ${this.name} has already been provided`);if(this.component=e,this.shouldAutoInitialize()){if(function(e){return"EAGER"===e.instantiationMode}(e))try{this.getOrInitializeService({instanceIdentifier:iu})}catch(KR){}for(const[e,t]of this.instancesDeferred.entries()){const n=this.normalizeInstanceIdentifier(e);try{const e=this.getOrInitializeService({instanceIdentifier:n});t.resolve(e)}catch(KR){}}}}clearInstance(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:iu;this.instancesDeferred.delete(e),this.instancesOptions.delete(e),this.instances.delete(e)}async delete(){const e=Array.from(this.instances.values());await Promise.all([...e.filter((e=>"INTERNAL"in e)).map((e=>e.INTERNAL.delete())),...e.filter((e=>"_delete"in e)).map((e=>e._delete()))])}isComponentSet(){return null!=this.component}isInitialized(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:iu;return this.instances.has(e)}getOptions(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:iu;return this.instancesOptions.get(e)||{}}initialize(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{options:t={}}=e,n=this.normalizeInstanceIdentifier(e.instanceIdentifier);if(this.isInitialized(n))throw Error(`${this.name}(${n}) has already been initialized`);if(!this.isComponentSet())throw Error(`Component ${this.name} has not been registered yet`);const r=this.getOrInitializeService({instanceIdentifier:n,options:t});for(const[a,s]of this.instancesDeferred.entries()){n===this.normalizeInstanceIdentifier(a)&&s.resolve(r)}return r}onInit(e,t){var n;const r=this.normalizeInstanceIdentifier(t),a=null!==(n=this.onInitCallbacks.get(r))&&void 0!==n?n:new Set;a.add(e),this.onInitCallbacks.set(r,a);const s=this.instances.get(r);return s&&e(s,r),()=>{a.delete(e)}}invokeOnInitCallbacks(e,t){const n=this.onInitCallbacks.get(t);if(n)for(const r of n)try{r(e,t)}catch(DP){}}getOrInitializeService(e){let{instanceIdentifier:t,options:n={}}=e,r=this.instances.get(t);if(!r&&this.component&&(r=this.component.instanceFactory(this.container,{instanceIdentifier:lu(t),options:n}),this.instances.set(t,r),this.instancesOptions.set(t,n),this.invokeOnInitCallbacks(r,t),this.component.onInstanceCreated))try{this.component.onInstanceCreated(this.container,t,r)}catch(DP){}return r||null}normalizeInstanceIdentifier(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:iu;return this.component?this.component.multipleInstances?e:iu:e}shouldAutoInitialize(){return!!this.component&&"EXPLICIT"!==this.component.instantiationMode}}function lu(e){return e===iu?void 0:e}class uu{constructor(e){this.name=e,this.providers=new Map}addComponent(e){const t=this.getProvider(e.name);if(t.isComponentSet())throw new Error(`Component ${e.name} has already been registered with ${this.name}`);t.setComponent(e)}addOrOverwriteComponent(e){this.getProvider(e.name).isComponentSet()&&this.providers.delete(e.name),this.addComponent(e)}getProvider(e){if(this.providers.has(e))return this.providers.get(e);const t=new ou(e,this);return this.providers.set(e,t),t}getProviders(){return Array.from(this.providers.values())}}const cu=[];var du;!function(e){e[e.DEBUG=0]="DEBUG",e[e.VERBOSE=1]="VERBOSE",e[e.INFO=2]="INFO",e[e.WARN=3]="WARN",e[e.ERROR=4]="ERROR",e[e.SILENT=5]="SILENT"}(du||(du={}));const hu={debug:du.DEBUG,verbose:du.VERBOSE,info:du.INFO,warn:du.WARN,error:du.ERROR,silent:du.SILENT},pu=du.INFO,fu={[du.DEBUG]:"log",[du.VERBOSE]:"log",[du.INFO]:"info",[du.WARN]:"warn",[du.ERROR]:"error"},mu=function(e,t){if(t<e.logLevel)return;const n=(new Date).toISOString(),r=fu[t];if(!r)throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`);for(var a=arguments.length,s=new Array(a>2?a-2:0),i=2;i<a;i++)s[i-2]=arguments[i];console[r](`[${n}]  ${e.name}:`,...s)};class gu{constructor(e){this.name=e,this._logLevel=pu,this._logHandler=mu,this._userLogHandler=null,cu.push(this)}get logLevel(){return this._logLevel}set logLevel(e){if(!(e in du))throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);this._logLevel=e}setLogLevel(e){this._logLevel="string"===typeof e?hu[e]:e}get logHandler(){return this._logHandler}set logHandler(e){if("function"!==typeof e)throw new TypeError("Value assigned to `logHandler` must be a function");this._logHandler=e}get userLogHandler(){return this._userLogHandler}set userLogHandler(e){this._userLogHandler=e}debug(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,du.DEBUG,...t),this._logHandler(this,du.DEBUG,...t)}log(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,du.VERBOSE,...t),this._logHandler(this,du.VERBOSE,...t)}info(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,du.INFO,...t),this._logHandler(this,du.INFO,...t)}warn(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,du.WARN,...t),this._logHandler(this,du.WARN,...t)}error(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._userLogHandler&&this._userLogHandler(this,du.ERROR,...t),this._logHandler(this,du.ERROR,...t)}}const yu=(e,t)=>t.some((t=>e instanceof t));let bu,vu;const xu=new WeakMap,wu=new WeakMap,ku=new WeakMap,Su=new WeakMap,Iu=new WeakMap;let Tu={get(e,t,n){if(e instanceof IDBTransaction){if("done"===t)return wu.get(e);if("objectStoreNames"===t)return e.objectStoreNames||ku.get(e);if("store"===t)return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return Au(e[t])},set:(e,t,n)=>(e[t]=n,!0),has:(e,t)=>e instanceof IDBTransaction&&("done"===t||"store"===t)||t in e};function Nu(e){return e!==IDBDatabase.prototype.transaction||"objectStoreNames"in IDBTransaction.prototype?(vu||(vu=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(e)?function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return e.apply(Eu(this),n),Au(xu.get(this))}:function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return Au(e.apply(Eu(this),n))}:function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];const s=e.call(Eu(this),t,...r);return ku.set(s,t.sort?t.sort():[t]),Au(s)}}function Cu(e){return"function"===typeof e?Nu(e):(e instanceof IDBTransaction&&function(e){if(wu.has(e))return;const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("complete",a),e.removeEventListener("error",s),e.removeEventListener("abort",s)},a=()=>{t(),r()},s=()=>{n(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",a),e.addEventListener("error",s),e.addEventListener("abort",s)}));wu.set(e,t)}(e),yu(e,bu||(bu=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction]))?new Proxy(e,Tu):e)}function Au(e){if(e instanceof IDBRequest)return function(e){const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("success",a),e.removeEventListener("error",s)},a=()=>{t(Au(e.result)),r()},s=()=>{n(e.error),r()};e.addEventListener("success",a),e.addEventListener("error",s)}));return t.then((t=>{t instanceof IDBCursor&&xu.set(t,e)})).catch((()=>{})),Iu.set(t,e),t}(e);if(Su.has(e))return Su.get(e);const t=Cu(e);return t!==e&&(Su.set(e,t),Iu.set(t,e)),t}const Eu=e=>Iu.get(e);const _u=["get","getKey","getAll","getAllKeys","count"],$u=["put","add","delete","clear"],Ru=new Map;function Du(e,t){if(!(e instanceof IDBDatabase)||t in e||"string"!==typeof t)return;if(Ru.get(t))return Ru.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,a=$u.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!a&&!_u.includes(n))return;const s=async function(e){const t=this.transaction(e,a?"readwrite":"readonly");let s=t.store;for(var i=arguments.length,o=new Array(i>1?i-1:0),l=1;l<i;l++)o[l-1]=arguments[l];return r&&(s=s.index(o.shift())),(await Promise.all([s[n](...o),a&&t.done]))[0]};return Ru.set(t,s),s}Tu=(e=>({...e,get:(t,n,r)=>Du(t,n)||e.get(t,n,r),has:(t,n)=>!!Du(t,n)||e.has(t,n)}))(Tu);class Mu{constructor(e){this.container=e}getPlatformInfoString(){return this.container.getProviders().map((e=>{if(function(e){const t=e.getComponent();return"VERSION"===(null===t||void 0===t?void 0:t.type)}(e)){const t=e.getImmediate();return`${t.library}/${t.version}`}return null})).filter((e=>e)).join(" ")}}const Fu="@firebase/app",Ou="0.10.10",Pu=new gu("@firebase/app"),Lu="@firebase/app-compat",zu="@firebase/analytics-compat",Bu="@firebase/analytics",Vu="@firebase/app-check-compat",Wu="@firebase/app-check",Uu="@firebase/auth",ju="@firebase/auth-compat",Gu="@firebase/database",Hu="@firebase/database-compat",qu="@firebase/functions",Ku="@firebase/functions-compat",Yu="@firebase/installations",Xu="@firebase/installations-compat",Qu="@firebase/messaging",Zu="@firebase/messaging-compat",Ju="@firebase/performance",ec="@firebase/performance-compat",tc="@firebase/remote-config",nc="@firebase/remote-config-compat",rc="@firebase/storage",ac="@firebase/storage-compat",sc="@firebase/firestore",ic="@firebase/vertexai-preview",oc="@firebase/firestore-compat",lc="firebase",uc="[DEFAULT]",cc={[Fu]:"fire-core",[Lu]:"fire-core-compat",[Bu]:"fire-analytics",[zu]:"fire-analytics-compat",[Wu]:"fire-app-check",[Vu]:"fire-app-check-compat",[Uu]:"fire-auth",[ju]:"fire-auth-compat",[Gu]:"fire-rtdb",[Hu]:"fire-rtdb-compat",[qu]:"fire-fn",[Ku]:"fire-fn-compat",[Yu]:"fire-iid",[Xu]:"fire-iid-compat",[Qu]:"fire-fcm",[Zu]:"fire-fcm-compat",[Ju]:"fire-perf",[ec]:"fire-perf-compat",[tc]:"fire-rc",[nc]:"fire-rc-compat",[rc]:"fire-gcs",[ac]:"fire-gcs-compat",[sc]:"fire-fst",[oc]:"fire-fst-compat",[ic]:"fire-vertex","fire-js":"fire-js",[lc]:"fire-js-all"},dc=new Map,hc=new Map,pc=new Map;function fc(e,t){try{e.container.addComponent(t)}catch(KR){Pu.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`,KR)}}function mc(e){const t=e.name;if(pc.has(t))return Pu.debug(`There were multiple attempts to register component ${t}.`),!1;pc.set(t,e);for(const n of dc.values())fc(n,e);for(const n of hc.values())fc(n,e);return!0}function gc(e,t){const n=e.container.getProvider("heartbeat").getImmediate({optional:!0});return n&&n.triggerHeartbeat(),e.container.getProvider(t)}const yc=new eu("app","Firebase",{"no-app":"No Firebase App '{$appName}' has been created - call initializeApp() first","bad-app-name":"Illegal App name: '{$appName}'","duplicate-app":"Firebase App named '{$appName}' already exists with different options or config","app-deleted":"Firebase App named '{$appName}' already deleted","server-app-deleted":"Firebase Server App has been deleted","no-options":"Need to provide options, when not being deployed to hosting via source.","invalid-app-argument":"firebase.{$appName}() takes either no argument or a Firebase App instance.","invalid-log-argument":"First argument to `onLog` must be null or a function.","idb-open":"Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.","idb-get":"Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.","idb-set":"Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.","idb-delete":"Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.","finalization-registry-not-supported":"FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.","invalid-server-app-environment":"FirebaseServerApp is not for use in browser environments."});class bc{constructor(e,t,n){this._isDeleted=!1,this._options=Object.assign({},e),this._config=Object.assign({},t),this._name=t.name,this._automaticDataCollectionEnabled=t.automaticDataCollectionEnabled,this._container=n,this.container.addComponent(new su("app",(()=>this),"PUBLIC"))}get automaticDataCollectionEnabled(){return this.checkDestroyed(),this._automaticDataCollectionEnabled}set automaticDataCollectionEnabled(e){this.checkDestroyed(),this._automaticDataCollectionEnabled=e}get name(){return this.checkDestroyed(),this._name}get options(){return this.checkDestroyed(),this._options}get config(){return this.checkDestroyed(),this._config}get container(){return this._container}get isDeleted(){return this._isDeleted}set isDeleted(e){this._isDeleted=e}checkDestroyed(){if(this.isDeleted)throw yc.create("app-deleted",{appName:this._name})}}function vc(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e;if("object"!==typeof t){t={name:t}}const r=Object.assign({name:uc,automaticDataCollectionEnabled:!1},t),a=r.name;if("string"!==typeof a||!a)throw yc.create("bad-app-name",{appName:String(a)});if(n||(n=Kl()),!n)throw yc.create("no-options");const s=dc.get(a);if(s){if(nu(n,s.options)&&nu(r,s.config))return s;throw yc.create("duplicate-app",{appName:a})}const i=new uu(a);for(const l of pc.values())i.addComponent(l);const o=new bc(n,r,i);return dc.set(a,o),o}function xc(e,t,n){var r;let a=null!==(r=cc[e])&&void 0!==r?r:e;n&&(a+=`-${n}`);const s=a.match(/\s|\//),i=t.match(/\s|\//);if(s||i){const e=[`Unable to register library "${a}" with version "${t}":`];return s&&e.push(`library name "${a}" contains illegal characters (whitespace or "/")`),s&&i&&e.push("and"),i&&e.push(`version name "${t}" contains illegal characters (whitespace or "/")`),void Pu.warn(e.join(" "))}mc(new su(`${a}-version`,(()=>({library:a,version:t})),"VERSION"))}const wc="firebase-heartbeat-database",kc=1,Sc="firebase-heartbeat-store";let Ic=null;function Tc(){return Ic||(Ic=function(e,t){let{blocked:n,upgrade:r,blocking:a,terminated:s}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=indexedDB.open(e,t),o=Au(i);return r&&i.addEventListener("upgradeneeded",(e=>{r(Au(i.result),e.oldVersion,e.newVersion,Au(i.transaction),e)})),n&&i.addEventListener("blocked",(e=>n(e.oldVersion,e.newVersion,e))),o.then((e=>{s&&e.addEventListener("close",(()=>s())),a&&e.addEventListener("versionchange",(e=>a(e.oldVersion,e.newVersion,e)))})).catch((()=>{})),o}(wc,kc,{upgrade:(e,t)=>{if(0===t)try{e.createObjectStore(Sc)}catch(KR){console.warn(KR)}}}).catch((e=>{throw yc.create("idb-open",{originalErrorMessage:e.message})}))),Ic}async function Nc(e,t){try{const n=(await Tc()).transaction(Sc,"readwrite"),r=n.objectStore(Sc);await r.put(t,Cc(e)),await n.done}catch(KR){if(KR instanceof Jl)Pu.warn(KR.message);else{const t=yc.create("idb-set",{originalErrorMessage:null===KR||void 0===KR?void 0:KR.message});Pu.warn(t.message)}}}function Cc(e){return`${e.name}!${e.options.appId}`}class Ac{constructor(e){this.container=e,this._heartbeatsCache=null;const t=this.container.getProvider("app").getImmediate();this._storage=new _c(t),this._heartbeatsCachePromise=this._storage.read().then((e=>(this._heartbeatsCache=e,e)))}async triggerHeartbeat(){var e,t;try{const n=this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),r=Ec();if(null==(null===(e=this._heartbeatsCache)||void 0===e?void 0:e.heartbeats)&&(this._heartbeatsCache=await this._heartbeatsCachePromise,null==(null===(t=this._heartbeatsCache)||void 0===t?void 0:t.heartbeats)))return;if(this._heartbeatsCache.lastSentHeartbeatDate===r||this._heartbeatsCache.heartbeats.some((e=>e.date===r)))return;return this._heartbeatsCache.heartbeats.push({date:r,agent:n}),this._heartbeatsCache.heartbeats=this._heartbeatsCache.heartbeats.filter((e=>{const t=new Date(e.date).valueOf();return Date.now()-t<=2592e6})),this._storage.overwrite(this._heartbeatsCache)}catch(KR){Pu.warn(KR)}}async getHeartbeatsHeader(){var e;try{if(null===this._heartbeatsCache&&await this._heartbeatsCachePromise,null==(null===(e=this._heartbeatsCache)||void 0===e?void 0:e.heartbeats)||0===this._heartbeatsCache.heartbeats.length)return"";const t=Ec(),{heartbeatsToSend:n,unsentEntries:r}=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1024;const n=[];let r=e.slice();for(const a of e){const e=n.find((e=>e.agent===a.agent));if(e){if(e.dates.push(a.date),$c(n)>t){e.dates.pop();break}}else if(n.push({agent:a.agent,dates:[a.date]}),$c(n)>t){n.pop();break}r=r.slice(1)}return{heartbeatsToSend:n,unsentEntries:r}}(this._heartbeatsCache.heartbeats),a=Ul(JSON.stringify({version:2,heartbeats:n}));return this._heartbeatsCache.lastSentHeartbeatDate=t,r.length>0?(this._heartbeatsCache.heartbeats=r,await this._storage.overwrite(this._heartbeatsCache)):(this._heartbeatsCache.heartbeats=[],this._storage.overwrite(this._heartbeatsCache)),a}catch(KR){return Pu.warn(KR),""}}}function Ec(){return(new Date).toISOString().substring(0,10)}class _c{constructor(e){this.app=e,this._canUseIndexedDBPromise=this.runIndexedDBEnvironmentCheck()}async runIndexedDBEnvironmentCheck(){return!!Zl()&&new Promise(((e,t)=>{try{let n=!0;const r="validate-browser-context-for-indexeddb-analytics-module",a=self.indexedDB.open(r);a.onsuccess=()=>{a.result.close(),n||self.indexedDB.deleteDatabase(r),e(!0)},a.onupgradeneeded=()=>{n=!1},a.onerror=()=>{var e;t((null===(e=a.error)||void 0===e?void 0:e.message)||"")}}catch(n){t(n)}})).then((()=>!0)).catch((()=>!1))}async read(){if(await this._canUseIndexedDBPromise){const e=await async function(e){try{const t=(await Tc()).transaction(Sc),n=await t.objectStore(Sc).get(Cc(e));return await t.done,n}catch(KR){if(KR instanceof Jl)Pu.warn(KR.message);else{const t=yc.create("idb-get",{originalErrorMessage:null===KR||void 0===KR?void 0:KR.message});Pu.warn(t.message)}}}(this.app);return(null===e||void 0===e?void 0:e.heartbeats)?e:{heartbeats:[]}}return{heartbeats:[]}}async overwrite(e){var t;if(await this._canUseIndexedDBPromise){const n=await this.read();return Nc(this.app,{lastSentHeartbeatDate:null!==(t=e.lastSentHeartbeatDate)&&void 0!==t?t:n.lastSentHeartbeatDate,heartbeats:e.heartbeats})}}async add(e){var t;if(await this._canUseIndexedDBPromise){const n=await this.read();return Nc(this.app,{lastSentHeartbeatDate:null!==(t=e.lastSentHeartbeatDate)&&void 0!==t?t:n.lastSentHeartbeatDate,heartbeats:[...n.heartbeats,...e.heartbeats]})}}}function $c(e){return Ul(JSON.stringify({version:2,heartbeats:e})).length}var Rc;Rc="",mc(new su("platform-logger",(e=>new Mu(e)),"PRIVATE")),mc(new su("heartbeat",(e=>new Ac(e)),"PRIVATE")),xc(Fu,Ou,Rc),xc(Fu,Ou,"esm2017"),xc("fire-js","");var Dc,Mc,Fc="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{},Oc={};(function(){var e;function t(){this.blockSize=-1,this.blockSize=64,this.g=Array(4),this.B=Array(this.blockSize),this.o=this.h=0,this.s()}function n(e,t,n){n||(n=0);var r=Array(16);if("string"===typeof t)for(var a=0;16>a;++a)r[a]=t.charCodeAt(n++)|t.charCodeAt(n++)<<8|t.charCodeAt(n++)<<16|t.charCodeAt(n++)<<24;else for(a=0;16>a;++a)r[a]=t[n++]|t[n++]<<8|t[n++]<<16|t[n++]<<24;t=e.g[0],n=e.g[1],a=e.g[2];var s=e.g[3],i=t+(s^n&(a^s))+r[0]+3614090360&4294967295;i=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=(n=(a=(s=(t=n+(i<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[1]+3905402710&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[2]+606105819&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[3]+3250441966&4294967295)<<22&4294967295|i>>>10))+((i=t+(s^n&(a^s))+r[4]+4118548399&4294967295)<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[5]+1200080426&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[6]+2821735955&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[7]+4249261313&4294967295)<<22&4294967295|i>>>10))+((i=t+(s^n&(a^s))+r[8]+1770035416&4294967295)<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[9]+2336552879&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[10]+4294925233&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[11]+2304563134&4294967295)<<22&4294967295|i>>>10))+((i=t+(s^n&(a^s))+r[12]+1804603682&4294967295)<<7&4294967295|i>>>25))+((i=s+(a^t&(n^a))+r[13]+4254626195&4294967295)<<12&4294967295|i>>>20))+((i=a+(n^s&(t^n))+r[14]+2792965006&4294967295)<<17&4294967295|i>>>15))+((i=n+(t^a&(s^t))+r[15]+1236535329&4294967295)<<22&4294967295|i>>>10))+((i=t+(a^s&(n^a))+r[1]+4129170786&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[6]+3225465664&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[11]+643717713&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[0]+3921069994&4294967295)<<20&4294967295|i>>>12))+((i=t+(a^s&(n^a))+r[5]+3593408605&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[10]+38016083&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[15]+3634488961&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[4]+3889429448&4294967295)<<20&4294967295|i>>>12))+((i=t+(a^s&(n^a))+r[9]+568446438&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[14]+3275163606&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[3]+4107603335&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[8]+1163531501&4294967295)<<20&4294967295|i>>>12))+((i=t+(a^s&(n^a))+r[13]+2850285829&4294967295)<<5&4294967295|i>>>27))+((i=s+(n^a&(t^n))+r[2]+4243563512&4294967295)<<9&4294967295|i>>>23))+((i=a+(t^n&(s^t))+r[7]+1735328473&4294967295)<<14&4294967295|i>>>18))+((i=n+(s^t&(a^s))+r[12]+2368359562&4294967295)<<20&4294967295|i>>>12))+((i=t+(n^a^s)+r[5]+4294588738&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[8]+2272392833&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[11]+1839030562&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[14]+4259657740&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^a^s)+r[1]+2763975236&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[4]+1272893353&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[7]+4139469664&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[10]+3200236656&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^a^s)+r[13]+681279174&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[0]+3936430074&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[3]+3572445317&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[6]+76029189&4294967295)<<23&4294967295|i>>>9))+((i=t+(n^a^s)+r[9]+3654602809&4294967295)<<4&4294967295|i>>>28))+((i=s+(t^n^a)+r[12]+3873151461&4294967295)<<11&4294967295|i>>>21))+((i=a+(s^t^n)+r[15]+530742520&4294967295)<<16&4294967295|i>>>16))+((i=n+(a^s^t)+r[2]+3299628645&4294967295)<<23&4294967295|i>>>9))+((i=t+(a^(n|~s))+r[0]+4096336452&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[7]+1126891415&4294967295)<<10&4294967295|i>>>22))+((i=a+(t^(s|~n))+r[14]+2878612391&4294967295)<<15&4294967295|i>>>17))+((i=n+(s^(a|~t))+r[5]+4237533241&4294967295)<<21&4294967295|i>>>11))+((i=t+(a^(n|~s))+r[12]+1700485571&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[3]+2399980690&4294967295)<<10&4294967295|i>>>22))+((i=a+(t^(s|~n))+r[10]+4293915773&4294967295)<<15&4294967295|i>>>17))+((i=n+(s^(a|~t))+r[1]+2240044497&4294967295)<<21&4294967295|i>>>11))+((i=t+(a^(n|~s))+r[8]+1873313359&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[15]+4264355552&4294967295)<<10&4294967295|i>>>22))+((i=a+(t^(s|~n))+r[6]+2734768916&4294967295)<<15&4294967295|i>>>17))+((i=n+(s^(a|~t))+r[13]+1309151649&4294967295)<<21&4294967295|i>>>11))+((s=(t=n+((i=t+(a^(n|~s))+r[4]+4149444226&4294967295)<<6&4294967295|i>>>26))+((i=s+(n^(t|~a))+r[11]+3174756917&4294967295)<<10&4294967295|i>>>22))^((a=s+((i=a+(t^(s|~n))+r[2]+718787259&4294967295)<<15&4294967295|i>>>17))|~t))+r[9]+3951481745&4294967295,e.g[0]=e.g[0]+t&4294967295,e.g[1]=e.g[1]+(a+(i<<21&4294967295|i>>>11))&4294967295,e.g[2]=e.g[2]+a&4294967295,e.g[3]=e.g[3]+s&4294967295}function r(e,t){this.h=t;for(var n=[],r=!0,a=e.length-1;0<=a;a--){var s=0|e[a];r&&s==t||(n[a]=s,r=!1)}this.g=n}!function(e,t){function n(){}n.prototype=t.prototype,e.D=t.prototype,e.prototype=new n,e.prototype.constructor=e,e.C=function(e,n,r){for(var a=Array(arguments.length-2),s=2;s<arguments.length;s++)a[s-2]=arguments[s];return t.prototype[n].apply(e,a)}}(t,(function(){this.blockSize=-1})),t.prototype.s=function(){this.g[0]=1732584193,this.g[1]=4023233417,this.g[2]=2562383102,this.g[3]=271733878,this.o=this.h=0},t.prototype.u=function(e,t){void 0===t&&(t=e.length);for(var r=t-this.blockSize,a=this.B,s=this.h,i=0;i<t;){if(0==s)for(;i<=r;)n(this,e,i),i+=this.blockSize;if("string"===typeof e){for(;i<t;)if(a[s++]=e.charCodeAt(i++),s==this.blockSize){n(this,a),s=0;break}}else for(;i<t;)if(a[s++]=e[i++],s==this.blockSize){n(this,a),s=0;break}}this.h=s,this.o+=t},t.prototype.v=function(){var e=Array((56>this.h?this.blockSize:2*this.blockSize)-this.h);e[0]=128;for(var t=1;t<e.length-8;++t)e[t]=0;var n=8*this.o;for(t=e.length-8;t<e.length;++t)e[t]=255&n,n/=256;for(this.u(e),e=Array(16),t=n=0;4>t;++t)for(var r=0;32>r;r+=8)e[n++]=this.g[t]>>>r&255;return e};var a={};function s(e){return-128<=e&&128>e?function(e,t){var n=a;return Object.prototype.hasOwnProperty.call(n,e)?n[e]:n[e]=t(e)}(e,(function(e){return new r([0|e],0>e?-1:0)})):new r([0|e],0>e?-1:0)}function i(e){if(isNaN(e)||!isFinite(e))return o;if(0>e)return h(i(-e));for(var t=[],n=1,a=0;e>=n;a++)t[a]=e/n|0,n*=4294967296;return new r(t,0)}var o=s(0),l=s(1),u=s(16777216);function c(e){if(0!=e.h)return!1;for(var t=0;t<e.g.length;t++)if(0!=e.g[t])return!1;return!0}function d(e){return-1==e.h}function h(e){for(var t=e.g.length,n=[],a=0;a<t;a++)n[a]=~e.g[a];return new r(n,~e.h).add(l)}function p(e,t){return e.add(h(t))}function f(e,t){for(;(65535&e[t])!=e[t];)e[t+1]+=e[t]>>>16,e[t]&=65535,t++}function m(e,t){this.g=e,this.h=t}function g(e,t){if(c(t))throw Error("division by zero");if(c(e))return new m(o,o);if(d(e))return t=g(h(e),t),new m(h(t.g),h(t.h));if(d(t))return t=g(e,h(t)),new m(h(t.g),t.h);if(30<e.g.length){if(d(e)||d(t))throw Error("slowDivide_ only works with positive integers.");for(var n=l,r=t;0>=r.l(e);)n=y(n),r=y(r);var a=b(n,1),s=b(r,1);for(r=b(r,2),n=b(n,2);!c(r);){var u=s.add(r);0>=u.l(e)&&(a=a.add(n),s=u),r=b(r,1),n=b(n,1)}return t=p(e,a.j(t)),new m(a,t)}for(a=o;0<=e.l(t);){for(n=Math.max(1,Math.floor(e.m()/t.m())),r=48>=(r=Math.ceil(Math.log(n)/Math.LN2))?1:Math.pow(2,r-48),u=(s=i(n)).j(t);d(u)||0<u.l(e);)u=(s=i(n-=r)).j(t);c(s)&&(s=l),a=a.add(s),e=p(e,u)}return new m(a,e)}function y(e){for(var t=e.g.length+1,n=[],a=0;a<t;a++)n[a]=e.i(a)<<1|e.i(a-1)>>>31;return new r(n,e.h)}function b(e,t){var n=t>>5;t%=32;for(var a=e.g.length-n,s=[],i=0;i<a;i++)s[i]=0<t?e.i(i+n)>>>t|e.i(i+n+1)<<32-t:e.i(i+n);return new r(s,e.h)}(e=r.prototype).m=function(){if(d(this))return-h(this).m();for(var e=0,t=1,n=0;n<this.g.length;n++){var r=this.i(n);e+=(0<=r?r:4294967296+r)*t,t*=4294967296}return e},e.toString=function(e){if(2>(e=e||10)||36<e)throw Error("radix out of range: "+e);if(c(this))return"0";if(d(this))return"-"+h(this).toString(e);for(var t=i(Math.pow(e,6)),n=this,r="";;){var a=g(n,t).g,s=((0<(n=p(n,a.j(t))).g.length?n.g[0]:n.h)>>>0).toString(e);if(c(n=a))return s+r;for(;6>s.length;)s="0"+s;r=s+r}},e.i=function(e){return 0>e?0:e<this.g.length?this.g[e]:this.h},e.l=function(e){return d(e=p(this,e))?-1:c(e)?0:1},e.abs=function(){return d(this)?h(this):this},e.add=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0,s=0;s<=t;s++){var i=a+(65535&this.i(s))+(65535&e.i(s)),o=(i>>>16)+(this.i(s)>>>16)+(e.i(s)>>>16);a=o>>>16,i&=65535,o&=65535,n[s]=o<<16|i}return new r(n,-2147483648&n[n.length-1]?-1:0)},e.j=function(e){if(c(this)||c(e))return o;if(d(this))return d(e)?h(this).j(h(e)):h(h(this).j(e));if(d(e))return h(this.j(h(e)));if(0>this.l(u)&&0>e.l(u))return i(this.m()*e.m());for(var t=this.g.length+e.g.length,n=[],a=0;a<2*t;a++)n[a]=0;for(a=0;a<this.g.length;a++)for(var s=0;s<e.g.length;s++){var l=this.i(a)>>>16,p=65535&this.i(a),m=e.i(s)>>>16,g=65535&e.i(s);n[2*a+2*s]+=p*g,f(n,2*a+2*s),n[2*a+2*s+1]+=l*g,f(n,2*a+2*s+1),n[2*a+2*s+1]+=p*m,f(n,2*a+2*s+1),n[2*a+2*s+2]+=l*m,f(n,2*a+2*s+2)}for(a=0;a<t;a++)n[a]=n[2*a+1]<<16|n[2*a];for(a=t;a<2*t;a++)n[a]=0;return new r(n,0)},e.A=function(e){return g(this,e).h},e.and=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0;a<t;a++)n[a]=this.i(a)&e.i(a);return new r(n,this.h&e.h)},e.or=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0;a<t;a++)n[a]=this.i(a)|e.i(a);return new r(n,this.h|e.h)},e.xor=function(e){for(var t=Math.max(this.g.length,e.g.length),n=[],a=0;a<t;a++)n[a]=this.i(a)^e.i(a);return new r(n,this.h^e.h)},t.prototype.digest=t.prototype.v,t.prototype.reset=t.prototype.s,t.prototype.update=t.prototype.u,Mc=Oc.Md5=t,r.prototype.add=r.prototype.add,r.prototype.multiply=r.prototype.j,r.prototype.modulo=r.prototype.A,r.prototype.compare=r.prototype.l,r.prototype.toNumber=r.prototype.m,r.prototype.toString=r.prototype.toString,r.prototype.getBits=r.prototype.i,r.fromNumber=i,r.fromString=function e(t,n){if(0==t.length)throw Error("number format error: empty string");if(2>(n=n||10)||36<n)throw Error("radix out of range: "+n);if("-"==t.charAt(0))return h(e(t.substring(1),n));if(0<=t.indexOf("-"))throw Error('number format error: interior "-" character');for(var r=i(Math.pow(n,8)),a=o,s=0;s<t.length;s+=8){var l=Math.min(8,t.length-s),u=parseInt(t.substring(s,s+l),n);8>l?(l=i(Math.pow(n,l)),a=a.j(l).add(i(u))):a=(a=a.j(r)).add(i(u))}return a},Dc=Oc.Integer=r}).apply("undefined"!==typeof Fc?Fc:"undefined"!==typeof self?self:"undefined"!==typeof window?window:{});var Pc,Lc,zc,Bc,Vc,Wc,Uc,jc,Gc,Hc="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{},qc={};(function(){var e,t="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){return e==Array.prototype||e==Object.prototype||(e[t]=n.value),e};var n=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof Hc&&Hc];for(var t=0;t<e.length;++t){var n=e[t];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);!function(e,r){if(r)e:{var a=n;e=e.split(".");for(var s=0;s<e.length-1;s++){var i=e[s];if(!(i in a))break e;a=a[i]}(r=r(s=a[e=e[e.length-1]]))!=s&&null!=r&&t(a,e,{configurable:!0,writable:!0,value:r})}}("Array.prototype.values",(function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var n=0,r=!1,a={next:function(){if(!r&&n<e.length){var a=n++;return{value:t(a,e[a]),done:!1}}return r=!0,{done:!0,value:void 0}}};return a[Symbol.iterator]=function(){return a},a}(this,(function(e,t){return t}))}}));var r=r||{},a=this||self;function s(e){var t=typeof e;return"array"==(t="object"!=t?t:e?Array.isArray(e)?"array":t:"null")||"object"==t&&"number"==typeof e.length}function i(e){var t=typeof e;return"object"==t&&null!=e||"function"==t}function o(e,t,n){return e.call.apply(e.bind,arguments)}function l(e,t,n){if(!e)throw Error();if(2<arguments.length){var r=Array.prototype.slice.call(arguments,2);return function(){var n=Array.prototype.slice.call(arguments);return Array.prototype.unshift.apply(n,r),e.apply(t,n)}}return function(){return e.apply(t,arguments)}}function u(e,t,n){return(u=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?o:l).apply(null,arguments)}function c(e,t){var n=Array.prototype.slice.call(arguments,1);return function(){var t=n.slice();return t.push.apply(t,arguments),e.apply(this,t)}}function d(e,t){function n(){}n.prototype=t.prototype,e.aa=t.prototype,e.prototype=new n,e.prototype.constructor=e,e.Qb=function(e,n,r){for(var a=Array(arguments.length-2),s=2;s<arguments.length;s++)a[s-2]=arguments[s];return t.prototype[n].apply(e,a)}}function h(e){const t=e.length;if(0<t){const n=Array(t);for(let r=0;r<t;r++)n[r]=e[r];return n}return[]}function p(e,t){for(let n=1;n<arguments.length;n++){const t=arguments[n];if(s(t)){const n=e.length||0,r=t.length||0;e.length=n+r;for(let a=0;a<r;a++)e[n+a]=t[a]}else e.push(t)}}function f(e){return/^[\s\xa0]*$/.test(e)}function m(){var e=a.navigator;return e&&(e=e.userAgent)?e:""}function g(e){return g[" "](e),e}g[" "]=function(){};var y=-1!=m().indexOf("Gecko")&&!(-1!=m().toLowerCase().indexOf("webkit")&&-1==m().indexOf("Edge"))&&!(-1!=m().indexOf("Trident")||-1!=m().indexOf("MSIE"))&&-1==m().indexOf("Edge");function b(e,t,n){for(const r in e)t.call(n,e[r],r,e)}function v(e){const t={};for(const n in e)t[n]=e[n];return t}const x="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function w(e,t){let n,r;for(let a=1;a<arguments.length;a++){for(n in r=arguments[a],r)e[n]=r[n];for(let t=0;t<x.length;t++)n=x[t],Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}}function k(e){var t=1;e=e.split(":");const n=[];for(;0<t&&e.length;)n.push(e.shift()),t--;return e.length&&n.push(e.join(":")),n}function S(e){a.setTimeout((()=>{throw e}),0)}function I(){var e=E;let t=null;return e.g&&(t=e.g,e.g=e.g.next,e.g||(e.h=null),t.next=null),t}var T=new class{constructor(e,t){this.i=e,this.j=t,this.h=0,this.g=null}get(){let e;return 0<this.h?(this.h--,e=this.g,this.g=e.next,e.next=null):e=this.i(),e}}((()=>new N),(e=>e.reset()));class N{constructor(){this.next=this.g=this.h=null}set(e,t){this.h=e,this.g=t,this.next=null}reset(){this.next=this.g=this.h=null}}let C,A=!1,E=new class{constructor(){this.h=this.g=null}add(e,t){const n=T.get();n.set(e,t),this.h?this.h.next=n:this.g=n,this.h=n}},_=()=>{const e=a.Promise.resolve(void 0);C=()=>{e.then($)}};var $=()=>{for(var e;e=I();){try{e.h.call(e.g)}catch(n){S(n)}var t=T;t.j(e),100>t.h&&(t.h++,e.next=t.g,t.g=e)}A=!1};function R(){this.s=this.s,this.C=this.C}function D(e,t){this.type=e,this.g=this.target=t,this.defaultPrevented=!1}R.prototype.s=!1,R.prototype.ma=function(){this.s||(this.s=!0,this.N())},R.prototype.N=function(){if(this.C)for(;this.C.length;)this.C.shift()()},D.prototype.h=function(){this.defaultPrevented=!0};var M=function(){if(!a.addEventListener||!Object.defineProperty)return!1;var e=!1,t=Object.defineProperty({},"passive",{get:function(){e=!0}});try{const e=()=>{};a.addEventListener("test",e,t),a.removeEventListener("test",e,t)}catch(n){}return e}();function F(e,t){if(D.call(this,e?e.type:""),this.relatedTarget=this.g=this.target=null,this.button=this.screenY=this.screenX=this.clientY=this.clientX=0,this.key="",this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1,this.state=null,this.pointerId=0,this.pointerType="",this.i=null,e){var n=this.type=e.type,r=e.changedTouches&&e.changedTouches.length?e.changedTouches[0]:null;if(this.target=e.target||e.srcElement,this.g=t,t=e.relatedTarget){if(y){e:{try{g(t.nodeName);var a=!0;break e}catch(s){}a=!1}a||(t=null)}}else"mouseover"==n?t=e.fromElement:"mouseout"==n&&(t=e.toElement);this.relatedTarget=t,r?(this.clientX=void 0!==r.clientX?r.clientX:r.pageX,this.clientY=void 0!==r.clientY?r.clientY:r.pageY,this.screenX=r.screenX||0,this.screenY=r.screenY||0):(this.clientX=void 0!==e.clientX?e.clientX:e.pageX,this.clientY=void 0!==e.clientY?e.clientY:e.pageY,this.screenX=e.screenX||0,this.screenY=e.screenY||0),this.button=e.button,this.key=e.key||"",this.ctrlKey=e.ctrlKey,this.altKey=e.altKey,this.shiftKey=e.shiftKey,this.metaKey=e.metaKey,this.pointerId=e.pointerId||0,this.pointerType="string"===typeof e.pointerType?e.pointerType:O[e.pointerType]||"",this.state=e.state,this.i=e,e.defaultPrevented&&F.aa.h.call(this)}}d(F,D);var O={2:"touch",3:"pen",4:"mouse"};F.prototype.h=function(){F.aa.h.call(this);var e=this.i;e.preventDefault?e.preventDefault():e.returnValue=!1};var P="closure_listenable_"+(1e6*Math.random()|0),L=0;function z(e,t,n,r,a){this.listener=e,this.proxy=null,this.src=t,this.type=n,this.capture=!!r,this.ha=a,this.key=++L,this.da=this.fa=!1}function B(e){e.da=!0,e.listener=null,e.proxy=null,e.src=null,e.ha=null}function V(e){this.src=e,this.g={},this.h=0}function W(e,t){var n=t.type;if(n in e.g){var r,a=e.g[n],s=Array.prototype.indexOf.call(a,t,void 0);(r=0<=s)&&Array.prototype.splice.call(a,s,1),r&&(B(t),0==e.g[n].length&&(delete e.g[n],e.h--))}}function U(e,t,n,r){for(var a=0;a<e.length;++a){var s=e[a];if(!s.da&&s.listener==t&&s.capture==!!n&&s.ha==r)return a}return-1}V.prototype.add=function(e,t,n,r,a){var s=e.toString();(e=this.g[s])||(e=this.g[s]=[],this.h++);var i=U(e,t,r,a);return-1<i?(t=e[i],n||(t.fa=!1)):((t=new z(t,this.src,s,!!r,a)).fa=n,e.push(t)),t};var j="closure_lm_"+(1e6*Math.random()|0),G={};function H(e,t,n,r,a){if(r&&r.once)return K(e,t,n,r,a);if(Array.isArray(t)){for(var s=0;s<t.length;s++)H(e,t[s],n,r,a);return null}return n=te(n),e&&e[P]?e.K(t,n,i(r)?!!r.capture:!!r,a):q(e,t,n,!1,r,a)}function q(e,t,n,r,a,s){if(!t)throw Error("Invalid event type");var o=i(a)?!!a.capture:!!a,l=J(e);if(l||(e[j]=l=new V(e)),(n=l.add(t,n,r,o,s)).proxy)return n;if(r=function(){function e(n){return t.call(e.src,e.listener,n)}const t=Z;return e}(),n.proxy=r,r.src=e,r.listener=n,e.addEventListener)M||(a=o),void 0===a&&(a=!1),e.addEventListener(t.toString(),r,a);else if(e.attachEvent)e.attachEvent(Q(t.toString()),r);else{if(!e.addListener||!e.removeListener)throw Error("addEventListener and attachEvent are unavailable.");e.addListener(r)}return n}function K(e,t,n,r,a){if(Array.isArray(t)){for(var s=0;s<t.length;s++)K(e,t[s],n,r,a);return null}return n=te(n),e&&e[P]?e.L(t,n,i(r)?!!r.capture:!!r,a):q(e,t,n,!0,r,a)}function Y(e,t,n,r,a){if(Array.isArray(t))for(var s=0;s<t.length;s++)Y(e,t[s],n,r,a);else r=i(r)?!!r.capture:!!r,n=te(n),e&&e[P]?(e=e.i,(t=String(t).toString())in e.g&&(-1<(n=U(s=e.g[t],n,r,a))&&(B(s[n]),Array.prototype.splice.call(s,n,1),0==s.length&&(delete e.g[t],e.h--)))):e&&(e=J(e))&&(t=e.g[t.toString()],e=-1,t&&(e=U(t,n,r,a)),(n=-1<e?t[e]:null)&&X(n))}function X(e){if("number"!==typeof e&&e&&!e.da){var t=e.src;if(t&&t[P])W(t.i,e);else{var n=e.type,r=e.proxy;t.removeEventListener?t.removeEventListener(n,r,e.capture):t.detachEvent?t.detachEvent(Q(n),r):t.addListener&&t.removeListener&&t.removeListener(r),(n=J(t))?(W(n,e),0==n.h&&(n.src=null,t[j]=null)):B(e)}}}function Q(e){return e in G?G[e]:G[e]="on"+e}function Z(e,t){if(e.da)e=!0;else{t=new F(t,this);var n=e.listener,r=e.ha||e.src;e.fa&&X(e),e=n.call(r,t)}return e}function J(e){return(e=e[j])instanceof V?e:null}var ee="__closure_events_fn_"+(1e9*Math.random()>>>0);function te(e){return"function"===typeof e?e:(e[ee]||(e[ee]=function(t){return e.handleEvent(t)}),e[ee])}function ne(){R.call(this),this.i=new V(this),this.M=this,this.F=null}function re(e,t){var n,r=e.F;if(r)for(n=[];r;r=r.F)n.push(r);if(e=e.M,r=t.type||t,"string"===typeof t)t=new D(t,e);else if(t instanceof D)t.target=t.target||e;else{var a=t;w(t=new D(r,e),a)}if(a=!0,n)for(var s=n.length-1;0<=s;s--){var i=t.g=n[s];a=ae(i,r,!0,t)&&a}if(a=ae(i=t.g=e,r,!0,t)&&a,a=ae(i,r,!1,t)&&a,n)for(s=0;s<n.length;s++)a=ae(i=t.g=n[s],r,!1,t)&&a}function ae(e,t,n,r){if(!(t=e.i.g[String(t)]))return!0;t=t.concat();for(var a=!0,s=0;s<t.length;++s){var i=t[s];if(i&&!i.da&&i.capture==n){var o=i.listener,l=i.ha||i.src;i.fa&&W(e.i,i),a=!1!==o.call(l,r)&&a}}return a&&!r.defaultPrevented}function se(e,t,n){if("function"===typeof e)n&&(e=u(e,n));else{if(!e||"function"!=typeof e.handleEvent)throw Error("Invalid listener argument");e=u(e.handleEvent,e)}return 2147483647<Number(t)?-1:a.setTimeout(e,t||0)}function ie(e){e.g=se((()=>{e.g=null,e.i&&(e.i=!1,ie(e))}),e.l);const t=e.h;e.h=null,e.m.apply(null,t)}d(ne,R),ne.prototype[P]=!0,ne.prototype.removeEventListener=function(e,t,n,r){Y(this,e,t,n,r)},ne.prototype.N=function(){if(ne.aa.N.call(this),this.i){var e,t=this.i;for(e in t.g){for(var n=t.g[e],r=0;r<n.length;r++)B(n[r]);delete t.g[e],t.h--}}this.F=null},ne.prototype.K=function(e,t,n,r){return this.i.add(String(e),t,!1,n,r)},ne.prototype.L=function(e,t,n,r){return this.i.add(String(e),t,!0,n,r)};class oe extends R{constructor(e,t){super(),this.m=e,this.l=t,this.h=null,this.i=!1,this.g=null}j(e){this.h=arguments,this.g?this.i=!0:ie(this)}N(){super.N(),this.g&&(a.clearTimeout(this.g),this.g=null,this.i=!1,this.h=null)}}function le(e){R.call(this),this.h=e,this.g={}}d(le,R);var ue=[];function ce(e){b(e.g,(function(e,t){this.g.hasOwnProperty(t)&&X(e)}),e),e.g={}}le.prototype.N=function(){le.aa.N.call(this),ce(this)},le.prototype.handleEvent=function(){throw Error("EventHandler.handleEvent not implemented")};var de=a.JSON.stringify,he=a.JSON.parse,pe=class{stringify(e){return a.JSON.stringify(e,void 0)}parse(e){return a.JSON.parse(e,void 0)}};function fe(){}function me(e){return e.h||(e.h=e.i())}function ge(){}fe.prototype.h=null;var ye={OPEN:"a",kb:"b",Ja:"c",wb:"d"};function be(){D.call(this,"d")}function ve(){D.call(this,"c")}d(be,D),d(ve,D);var xe={},we=null;function ke(){return we=we||new ne}function Se(e){D.call(this,xe.La,e)}function Ie(e){const t=ke();re(t,new Se(t))}function Te(e,t){D.call(this,xe.STAT_EVENT,e),this.stat=t}function Ne(e){const t=ke();re(t,new Te(t,e))}function Ce(e,t){D.call(this,xe.Ma,e),this.size=t}function Ae(e,t){if("function"!==typeof e)throw Error("Fn must not be null and must be a function");return a.setTimeout((function(){e()}),t)}function Ee(){this.g=!0}function _e(e,t,n,r){e.info((function(){return"XMLHTTP TEXT ("+t+"): "+function(e,t){if(!e.g)return t;if(!t)return null;try{var n=JSON.parse(t);if(n)for(e=0;e<n.length;e++)if(Array.isArray(n[e])){var r=n[e];if(!(2>r.length)){var a=r[1];if(Array.isArray(a)&&!(1>a.length)){var s=a[0];if("noop"!=s&&"stop"!=s&&"close"!=s)for(var i=1;i<a.length;i++)a[i]=""}}}return de(n)}catch(o){return t}}(e,n)+(r?" "+r:"")}))}xe.La="serverreachability",d(Se,D),xe.STAT_EVENT="statevent",d(Te,D),xe.Ma="timingevent",d(Ce,D),Ee.prototype.xa=function(){this.g=!1},Ee.prototype.info=function(){};var $e,Re={NO_ERROR:0,gb:1,tb:2,sb:3,nb:4,rb:5,ub:6,Ia:7,TIMEOUT:8,xb:9},De={lb:"complete",Hb:"success",Ja:"error",Ia:"abort",zb:"ready",Ab:"readystatechange",TIMEOUT:"timeout",vb:"incrementaldata",yb:"progress",ob:"downloadprogress",Pb:"uploadprogress"};function Me(){}function Fe(e,t,n,r){this.j=e,this.i=t,this.l=n,this.R=r||1,this.U=new le(this),this.I=45e3,this.H=null,this.o=!1,this.m=this.A=this.v=this.L=this.F=this.S=this.B=null,this.D=[],this.g=null,this.C=0,this.s=this.u=null,this.X=-1,this.J=!1,this.O=0,this.M=null,this.W=this.K=this.T=this.P=!1,this.h=new Oe}function Oe(){this.i=null,this.g="",this.h=!1}d(Me,fe),Me.prototype.g=function(){return new XMLHttpRequest},Me.prototype.i=function(){return{}},$e=new Me;var Pe={},Le={};function ze(e,t,n){e.L=1,e.v=dt(it(t)),e.m=n,e.P=!0,Be(e,null)}function Be(e,t){e.F=Date.now(),Ue(e),e.A=it(e.v);var n=e.A,r=e.R;Array.isArray(r)||(r=[String(r)]),Tt(n.i,"t",r),e.C=0,n=e.j.J,e.h=new Oe,e.g=pn(e.j,n?t:null,!e.m),0<e.O&&(e.M=new oe(u(e.Y,e,e.g),e.O)),t=e.U,n=e.g,r=e.ca;var a="readystatechange";Array.isArray(a)||(a&&(ue[0]=a.toString()),a=ue);for(var s=0;s<a.length;s++){var i=H(n,a[s],r||t.handleEvent,!1,t.h||t);if(!i)break;t.g[i.key]=i}t=e.H?v(e.H):{},e.m?(e.u||(e.u="POST"),t["Content-Type"]="application/x-www-form-urlencoded",e.g.ea(e.A,e.u,e.m,t)):(e.u="GET",e.g.ea(e.A,e.u,null,t)),Ie(),function(e,t,n,r,a,s){e.info((function(){if(e.g)if(s)for(var i="",o=s.split("&"),l=0;l<o.length;l++){var u=o[l].split("=");if(1<u.length){var c=u[0];u=u[1];var d=c.split("_");i=2<=d.length&&"type"==d[1]?i+(c+"=")+u+"&":i+(c+"=redacted&")}}else i=null;else i=s;return"XMLHTTP REQ ("+r+") [attempt "+a+"]: "+t+"\n"+n+"\n"+i}))}(e.i,e.u,e.A,e.l,e.R,e.m)}function Ve(e){return!!e.g&&("GET"==e.u&&2!=e.L&&e.j.Ca)}function We(e,t){var n=e.C,r=t.indexOf("\n",n);return-1==r?Le:(n=Number(t.substring(n,r)),isNaN(n)?Pe:(r+=1)+n>t.length?Le:(t=t.slice(r,r+n),e.C=r+n,t))}function Ue(e){e.S=Date.now()+e.I,je(e,e.I)}function je(e,t){if(null!=e.B)throw Error("WatchDog timer not null");e.B=Ae(u(e.ba,e),t)}function Ge(e){e.B&&(a.clearTimeout(e.B),e.B=null)}function He(e){0==e.j.G||e.J||ln(e.j,e)}function qe(e){Ge(e);var t=e.M;t&&"function"==typeof t.ma&&t.ma(),e.M=null,ce(e.U),e.g&&(t=e.g,e.g=null,t.abort(),t.ma())}function Ke(e,t){try{var n=e.j;if(0!=n.G&&(n.g==e||Je(n.h,e)))if(!e.K&&Je(n.h,e)&&3==n.G){try{var r=n.Da.g.parse(t)}catch(c){r=null}if(Array.isArray(r)&&3==r.length){var a=r;if(0==a[0]){e:if(!n.u){if(n.g){if(!(n.g.F+3e3<e.F))break e;on(n),Xt(n)}rn(n),Ne(18)}}else n.za=a[1],0<n.za-n.T&&37500>a[2]&&n.F&&0==n.v&&!n.C&&(n.C=Ae(u(n.Za,n),6e3));if(1>=Ze(n.h)&&n.ca){try{n.ca()}catch(c){}n.ca=void 0}}else cn(n,11)}else if((e.K||n.g==e)&&on(n),!f(t))for(a=n.Da.g.parse(t),t=0;t<a.length;t++){let u=a[t];if(n.T=u[0],u=u[1],2==n.G)if("c"==u[0]){n.K=u[1],n.ia=u[2];const t=u[3];null!=t&&(n.la=t,n.j.info("VER="+n.la));const a=u[4];null!=a&&(n.Aa=a,n.j.info("SVER="+n.Aa));const c=u[5];null!=c&&"number"===typeof c&&0<c&&(r=1.5*c,n.L=r,n.j.info("backChannelRequestTimeoutMs_="+r)),r=n;const d=e.g;if(d){const e=d.g?d.g.getResponseHeader("X-Client-Wire-Protocol"):null;if(e){var s=r.h;s.g||-1==e.indexOf("spdy")&&-1==e.indexOf("quic")&&-1==e.indexOf("h2")||(s.j=s.l,s.g=new Set,s.h&&(et(s,s.h),s.h=null))}if(r.D){const e=d.g?d.g.getResponseHeader("X-HTTP-Session-Id"):null;e&&(r.ya=e,ct(r.I,r.D,e))}}n.G=3,n.l&&n.l.ua(),n.ba&&(n.R=Date.now()-e.F,n.j.info("Handshake RTT: "+n.R+"ms"));var i=e;if((r=n).qa=hn(r,r.J?r.ia:null,r.W),i.K){tt(r.h,i);var o=i,l=r.L;l&&(o.I=l),o.B&&(Ge(o),Ue(o)),r.g=i}else nn(r);0<n.i.length&&Zt(n)}else"stop"!=u[0]&&"close"!=u[0]||cn(n,7);else 3==n.G&&("stop"==u[0]||"close"==u[0]?"stop"==u[0]?cn(n,7):Yt(n):"noop"!=u[0]&&n.l&&n.l.ta(u),n.v=0)}Ie()}catch(c){}}Fe.prototype.ca=function(e){e=e.target;const t=this.M;t&&3==Gt(e)?t.j():this.Y(e)},Fe.prototype.Y=function(e){try{if(e==this.g)e:{const h=Gt(this.g);var t=this.g.Ba();this.g.Z();if(!(3>h)&&(3!=h||this.g&&(this.h.h||this.g.oa()||Ht(this.g)))){this.J||4!=h||7==t||Ie(),Ge(this);var n=this.g.Z();this.X=n;t:if(Ve(this)){var r=Ht(this.g);e="";var s=r.length,i=4==Gt(this.g);if(!this.h.i){if("undefined"===typeof TextDecoder){qe(this),He(this);var o="";break t}this.h.i=new a.TextDecoder}for(t=0;t<s;t++)this.h.h=!0,e+=this.h.i.decode(r[t],{stream:!(i&&t==s-1)});r.length=0,this.h.g+=e,this.C=0,o=this.h.g}else o=this.g.oa();if(this.o=200==n,function(e,t,n,r,a,s,i){e.info((function(){return"XMLHTTP RESP ("+r+") [ attempt "+a+"]: "+t+"\n"+n+"\n"+s+" "+i}))}(this.i,this.u,this.A,this.l,this.R,h,n),this.o){if(this.T&&!this.K){t:{if(this.g){var l,u=this.g;if((l=u.g?u.g.getResponseHeader("X-HTTP-Initial-Response"):null)&&!f(l)){var c=l;break t}}c=null}if(!(n=c)){this.o=!1,this.s=3,Ne(12),qe(this),He(this);break e}_e(this.i,this.l,n,"Initial handshake response via X-HTTP-Initial-Response"),this.K=!0,Ke(this,n)}if(this.P){let e;for(n=!0;!this.J&&this.C<o.length;){if(e=We(this,o),e==Le){4==h&&(this.s=4,Ne(14),n=!1),_e(this.i,this.l,null,"[Incomplete Response]");break}if(e==Pe){this.s=4,Ne(15),_e(this.i,this.l,o,"[Invalid Chunk]"),n=!1;break}_e(this.i,this.l,e,null),Ke(this,e)}if(Ve(this)&&0!=this.C&&(this.h.g=this.h.g.slice(this.C),this.C=0),4!=h||0!=o.length||this.h.h||(this.s=1,Ne(16),n=!1),this.o=this.o&&n,n){if(0<o.length&&!this.W){this.W=!0;var d=this.j;d.g==this&&d.ba&&!d.M&&(d.j.info("Great, no buffering proxy detected. Bytes received: "+o.length),an(d),d.M=!0,Ne(11))}}else _e(this.i,this.l,o,"[Invalid Chunked Response]"),qe(this),He(this)}else _e(this.i,this.l,o,null),Ke(this,o);4==h&&qe(this),this.o&&!this.J&&(4==h?ln(this.j,this):(this.o=!1,Ue(this)))}else(function(e){const t={};e=(e.g&&2<=Gt(e)&&e.g.getAllResponseHeaders()||"").split("\r\n");for(let r=0;r<e.length;r++){if(f(e[r]))continue;var n=k(e[r]);const a=n[0];if("string"!==typeof(n=n[1]))continue;n=n.trim();const s=t[a]||[];t[a]=s,s.push(n)}!function(e,t){for(const n in e)t.call(void 0,e[n],n,e)}(t,(function(e){return e.join(", ")}))})(this.g),400==n&&0<o.indexOf("Unknown SID")?(this.s=3,Ne(12)):(this.s=0,Ne(13)),qe(this),He(this)}}}catch(iR){}},Fe.prototype.cancel=function(){this.J=!0,qe(this)},Fe.prototype.ba=function(){this.B=null;const e=Date.now();0<=e-this.S?(function(e,t){e.info((function(){return"TIMEOUT: "+t}))}(this.i,this.A),2!=this.L&&(Ie(),Ne(17)),qe(this),this.s=2,He(this)):je(this,this.S-e)};var Ye=class{constructor(e,t){this.g=e,this.map=t}};function Xe(e){this.l=e||10,a.PerformanceNavigationTiming?e=0<(e=a.performance.getEntriesByType("navigation")).length&&("hq"==e[0].nextHopProtocol||"h2"==e[0].nextHopProtocol):e=!!(a.chrome&&a.chrome.loadTimes&&a.chrome.loadTimes()&&a.chrome.loadTimes().wasFetchedViaSpdy),this.j=e?this.l:1,this.g=null,1<this.j&&(this.g=new Set),this.h=null,this.i=[]}function Qe(e){return!!e.h||!!e.g&&e.g.size>=e.j}function Ze(e){return e.h?1:e.g?e.g.size:0}function Je(e,t){return e.h?e.h==t:!!e.g&&e.g.has(t)}function et(e,t){e.g?e.g.add(t):e.h=t}function tt(e,t){e.h&&e.h==t?e.h=null:e.g&&e.g.has(t)&&e.g.delete(t)}function nt(e){if(null!=e.h)return e.i.concat(e.h.D);if(null!=e.g&&0!==e.g.size){let t=e.i;for(const n of e.g.values())t=t.concat(n.D);return t}return h(e.i)}function rt(e,t){if(e.forEach&&"function"==typeof e.forEach)e.forEach(t,void 0);else if(s(e)||"string"===typeof e)Array.prototype.forEach.call(e,t,void 0);else for(var n=function(e){if(e.na&&"function"==typeof e.na)return e.na();if(!e.V||"function"!=typeof e.V){if("undefined"!==typeof Map&&e instanceof Map)return Array.from(e.keys());if(!("undefined"!==typeof Set&&e instanceof Set)){if(s(e)||"string"===typeof e){var t=[];e=e.length;for(var n=0;n<e;n++)t.push(n);return t}t=[],n=0;for(const r in e)t[n++]=r;return t}}}(e),r=function(e){if(e.V&&"function"==typeof e.V)return e.V();if("undefined"!==typeof Map&&e instanceof Map||"undefined"!==typeof Set&&e instanceof Set)return Array.from(e.values());if("string"===typeof e)return e.split("");if(s(e)){for(var t=[],n=e.length,r=0;r<n;r++)t.push(e[r]);return t}for(r in t=[],n=0,e)t[n++]=e[r];return t}(e),a=r.length,i=0;i<a;i++)t.call(void 0,r[i],n&&n[i],e)}Xe.prototype.cancel=function(){if(this.i=nt(this),this.h)this.h.cancel(),this.h=null;else if(this.g&&0!==this.g.size){for(const e of this.g.values())e.cancel();this.g.clear()}};var at=RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");function st(e){if(this.g=this.o=this.j="",this.s=null,this.m=this.l="",this.h=!1,e instanceof st){this.h=e.h,ot(this,e.j),this.o=e.o,this.g=e.g,lt(this,e.s),this.l=e.l;var t=e.i,n=new wt;n.i=t.i,t.g&&(n.g=new Map(t.g),n.h=t.h),ut(this,n),this.m=e.m}else e&&(t=String(e).match(at))?(this.h=!1,ot(this,t[1]||"",!0),this.o=ht(t[2]||""),this.g=ht(t[3]||"",!0),lt(this,t[4]),this.l=ht(t[5]||"",!0),ut(this,t[6]||"",!0),this.m=ht(t[7]||"")):(this.h=!1,this.i=new wt(null,this.h))}function it(e){return new st(e)}function ot(e,t,n){e.j=n?ht(t,!0):t,e.j&&(e.j=e.j.replace(/:$/,""))}function lt(e,t){if(t){if(t=Number(t),isNaN(t)||0>t)throw Error("Bad port number "+t);e.s=t}else e.s=null}function ut(e,t,n){t instanceof wt?(e.i=t,function(e,t){t&&!e.j&&(kt(e),e.i=null,e.g.forEach((function(e,t){var n=t.toLowerCase();t!=n&&(St(this,t),Tt(this,n,e))}),e)),e.j=t}(e.i,e.h)):(n||(t=pt(t,vt)),e.i=new wt(t,e.h))}function ct(e,t,n){e.i.set(t,n)}function dt(e){return ct(e,"zx",Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^Date.now()).toString(36)),e}function ht(e,t){return e?t?decodeURI(e.replace(/%25/g,"%2525")):decodeURIComponent(e):""}function pt(e,t,n){return"string"===typeof e?(e=encodeURI(e).replace(t,ft),n&&(e=e.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),e):null}function ft(e){return"%"+((e=e.charCodeAt(0))>>4&15).toString(16)+(15&e).toString(16)}st.prototype.toString=function(){var e=[],t=this.j;t&&e.push(pt(t,gt,!0),":");var n=this.g;return(n||"file"==t)&&(e.push("//"),(t=this.o)&&e.push(pt(t,gt,!0),"@"),e.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),null!=(n=this.s)&&e.push(":",String(n))),(n=this.l)&&(this.g&&"/"!=n.charAt(0)&&e.push("/"),e.push(pt(n,"/"==n.charAt(0)?bt:yt,!0))),(n=this.i.toString())&&e.push("?",n),(n=this.m)&&e.push("#",pt(n,xt)),e.join("")};var mt,gt=/[#\/\?@]/g,yt=/[#\?:]/g,bt=/[#\?]/g,vt=/[#\?@]/g,xt=/#/g;function wt(e,t){this.h=this.g=null,this.i=e||null,this.j=!!t}function kt(e){e.g||(e.g=new Map,e.h=0,e.i&&function(e,t){if(e){e=e.split("&");for(var n=0;n<e.length;n++){var r=e[n].indexOf("="),a=null;if(0<=r){var s=e[n].substring(0,r);a=e[n].substring(r+1)}else s=e[n];t(s,a?decodeURIComponent(a.replace(/\+/g," ")):"")}}}(e.i,(function(t,n){e.add(decodeURIComponent(t.replace(/\+/g," ")),n)})))}function St(e,t){kt(e),t=Nt(e,t),e.g.has(t)&&(e.i=null,e.h-=e.g.get(t).length,e.g.delete(t))}function It(e,t){return kt(e),t=Nt(e,t),e.g.has(t)}function Tt(e,t,n){St(e,t),0<n.length&&(e.i=null,e.g.set(Nt(e,t),h(n)),e.h+=n.length)}function Nt(e,t){return t=String(t),e.j&&(t=t.toLowerCase()),t}function Ct(e,t,n,r,a){try{a&&(a.onload=null,a.onerror=null,a.onabort=null,a.ontimeout=null),r(n)}catch(s){}}function At(){this.g=new pe}function Et(e,t,n){const r=n||"";try{rt(e,(function(e,n){let a=e;i(e)&&(a=de(e)),t.push(r+n+"="+encodeURIComponent(a))}))}catch(KR){throw t.push(r+"type="+encodeURIComponent("_badmap")),KR}}function _t(e){this.l=e.Ub||null,this.j=e.eb||!1}function $t(e,t){ne.call(this),this.D=e,this.o=t,this.m=void 0,this.status=this.readyState=0,this.responseType=this.responseText=this.response=this.statusText="",this.onreadystatechange=null,this.u=new Headers,this.h=null,this.B="GET",this.A="",this.g=!1,this.v=this.j=this.l=null}function Rt(e){e.j.read().then(e.Pa.bind(e)).catch(e.ga.bind(e))}function Dt(e){e.readyState=4,e.l=null,e.j=null,e.v=null,Mt(e)}function Mt(e){e.onreadystatechange&&e.onreadystatechange.call(e)}function Ft(e){let t="";return b(e,(function(e,n){t+=n,t+=":",t+=e,t+="\r\n"})),t}function Ot(e,t,n){e:{for(r in n){var r=!1;break e}r=!0}r||(n=Ft(n),"string"===typeof e?null!=n&&encodeURIComponent(String(n)):ct(e,t,n))}function Pt(e){ne.call(this),this.headers=new Map,this.o=e||null,this.h=!1,this.v=this.g=null,this.D="",this.m=0,this.l="",this.j=this.B=this.u=this.A=!1,this.I=null,this.H="",this.J=!1}(e=wt.prototype).add=function(e,t){kt(this),this.i=null,e=Nt(this,e);var n=this.g.get(e);return n||this.g.set(e,n=[]),n.push(t),this.h+=1,this},e.forEach=function(e,t){kt(this),this.g.forEach((function(n,r){n.forEach((function(n){e.call(t,n,r,this)}),this)}),this)},e.na=function(){kt(this);const e=Array.from(this.g.values()),t=Array.from(this.g.keys()),n=[];for(let r=0;r<t.length;r++){const a=e[r];for(let e=0;e<a.length;e++)n.push(t[r])}return n},e.V=function(e){kt(this);let t=[];if("string"===typeof e)It(this,e)&&(t=t.concat(this.g.get(Nt(this,e))));else{e=Array.from(this.g.values());for(let n=0;n<e.length;n++)t=t.concat(e[n])}return t},e.set=function(e,t){return kt(this),this.i=null,It(this,e=Nt(this,e))&&(this.h-=this.g.get(e).length),this.g.set(e,[t]),this.h+=1,this},e.get=function(e,t){return e&&0<(e=this.V(e)).length?String(e[0]):t},e.toString=function(){if(this.i)return this.i;if(!this.g)return"";const e=[],t=Array.from(this.g.keys());for(var n=0;n<t.length;n++){var r=t[n];const s=encodeURIComponent(String(r)),i=this.V(r);for(r=0;r<i.length;r++){var a=s;""!==i[r]&&(a+="="+encodeURIComponent(String(i[r]))),e.push(a)}}return this.i=e.join("&")},d(_t,fe),_t.prototype.g=function(){return new $t(this.l,this.j)},_t.prototype.i=(mt={},function(){return mt}),d($t,ne),(e=$t.prototype).open=function(e,t){if(0!=this.readyState)throw this.abort(),Error("Error reopening a connection");this.B=e,this.A=t,this.readyState=1,Mt(this)},e.send=function(e){if(1!=this.readyState)throw this.abort(),Error("need to call open() first. ");this.g=!0;const t={headers:this.u,method:this.B,credentials:this.m,cache:void 0};e&&(t.body=e),(this.D||a).fetch(new Request(this.A,t)).then(this.Sa.bind(this),this.ga.bind(this))},e.abort=function(){this.response=this.responseText="",this.u=new Headers,this.status=0,this.j&&this.j.cancel("Request was aborted.").catch((()=>{})),1<=this.readyState&&this.g&&4!=this.readyState&&(this.g=!1,Dt(this)),this.readyState=0},e.Sa=function(e){if(this.g&&(this.l=e,this.h||(this.status=this.l.status,this.statusText=this.l.statusText,this.h=e.headers,this.readyState=2,Mt(this)),this.g&&(this.readyState=3,Mt(this),this.g)))if("arraybuffer"===this.responseType)e.arrayBuffer().then(this.Qa.bind(this),this.ga.bind(this));else if("undefined"!==typeof a.ReadableStream&&"body"in e){if(this.j=e.body.getReader(),this.o){if(this.responseType)throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');this.response=[]}else this.response=this.responseText="",this.v=new TextDecoder;Rt(this)}else e.text().then(this.Ra.bind(this),this.ga.bind(this))},e.Pa=function(e){if(this.g){if(this.o&&e.value)this.response.push(e.value);else if(!this.o){var t=e.value?e.value:new Uint8Array(0);(t=this.v.decode(t,{stream:!e.done}))&&(this.response=this.responseText+=t)}e.done?Dt(this):Mt(this),3==this.readyState&&Rt(this)}},e.Ra=function(e){this.g&&(this.response=this.responseText=e,Dt(this))},e.Qa=function(e){this.g&&(this.response=e,Dt(this))},e.ga=function(){this.g&&Dt(this)},e.setRequestHeader=function(e,t){this.u.append(e,t)},e.getResponseHeader=function(e){return this.h&&this.h.get(e.toLowerCase())||""},e.getAllResponseHeaders=function(){if(!this.h)return"";const e=[],t=this.h.entries();for(var n=t.next();!n.done;)n=n.value,e.push(n[0]+": "+n[1]),n=t.next();return e.join("\r\n")},Object.defineProperty($t.prototype,"withCredentials",{get:function(){return"include"===this.m},set:function(e){this.m=e?"include":"same-origin"}}),d(Pt,ne);var Lt=/^https?$/i,zt=["POST","PUT"];function Bt(e,t){e.h=!1,e.g&&(e.j=!0,e.g.abort(),e.j=!1),e.l=t,e.m=5,Vt(e),Ut(e)}function Vt(e){e.A||(e.A=!0,re(e,"complete"),re(e,"error"))}function Wt(e){if(e.h&&"undefined"!=typeof r&&(!e.v[1]||4!=Gt(e)||2!=e.Z()))if(e.u&&4==Gt(e))se(e.Ea,0,e);else if(re(e,"readystatechange"),4==Gt(e)){e.h=!1;try{const r=e.Z();e:switch(r){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var t=!0;break e;default:t=!1}var n;if(!(n=t)){var s;if(s=0===r){var i=String(e.D).match(at)[1]||null;!i&&a.self&&a.self.location&&(i=a.self.location.protocol.slice(0,-1)),s=!Lt.test(i?i.toLowerCase():"")}n=s}if(n)re(e,"complete"),re(e,"success");else{e.m=6;try{var o=2<Gt(e)?e.g.statusText:""}catch(l){o=""}e.l=o+" ["+e.Z()+"]",Vt(e)}}finally{Ut(e)}}}function Ut(e,t){if(e.g){jt(e);const n=e.g,r=e.v[0]?()=>{}:null;e.g=null,e.v=null,t||re(e,"ready");try{n.onreadystatechange=r}catch(KR){}}}function jt(e){e.I&&(a.clearTimeout(e.I),e.I=null)}function Gt(e){return e.g?e.g.readyState:0}function Ht(e){try{if(!e.g)return null;if("response"in e.g)return e.g.response;switch(e.H){case"":case"text":return e.g.responseText;case"arraybuffer":if("mozResponseArrayBuffer"in e.g)return e.g.mozResponseArrayBuffer}return null}catch(Xc){return null}}function qt(e,t,n){return n&&n.internalChannelParams&&n.internalChannelParams[e]||t}function Kt(e){this.Aa=0,this.i=[],this.j=new Ee,this.ia=this.qa=this.I=this.W=this.g=this.ya=this.D=this.H=this.m=this.S=this.o=null,this.Ya=this.U=0,this.Va=qt("failFast",!1,e),this.F=this.C=this.u=this.s=this.l=null,this.X=!0,this.za=this.T=-1,this.Y=this.v=this.B=0,this.Ta=qt("baseRetryDelayMs",5e3,e),this.cb=qt("retryDelaySeedMs",1e4,e),this.Wa=qt("forwardChannelMaxRetries",2,e),this.wa=qt("forwardChannelRequestTimeoutMs",2e4,e),this.pa=e&&e.xmlHttpFactory||void 0,this.Xa=e&&e.Tb||void 0,this.Ca=e&&e.useFetchStreams||!1,this.L=void 0,this.J=e&&e.supportsCrossDomainXhr||!1,this.K="",this.h=new Xe(e&&e.concurrentRequestLimit),this.Da=new At,this.P=e&&e.fastHandshake||!1,this.O=e&&e.encodeInitMessageHeaders||!1,this.P&&this.O&&(this.O=!1),this.Ua=e&&e.Rb||!1,e&&e.xa&&this.j.xa(),e&&e.forceLongPolling&&(this.X=!1),this.ba=!this.P&&this.X&&e&&e.detectBufferingProxy||!1,this.ja=void 0,e&&e.longPollingTimeout&&0<e.longPollingTimeout&&(this.ja=e.longPollingTimeout),this.ca=void 0,this.R=0,this.M=!1,this.ka=this.A=null}function Yt(e){if(Qt(e),3==e.G){var t=e.U++,n=it(e.I);if(ct(n,"SID",e.K),ct(n,"RID",t),ct(n,"TYPE","terminate"),en(e,n),(t=new Fe(e,e.j,t)).L=2,t.v=dt(it(n)),n=!1,a.navigator&&a.navigator.sendBeacon)try{n=a.navigator.sendBeacon(t.v.toString(),"")}catch(r){}!n&&a.Image&&((new Image).src=t.v,n=!0),n||(t.g=pn(t.j,null),t.g.ea(t.v)),t.F=Date.now(),Ue(t)}dn(e)}function Xt(e){e.g&&(an(e),e.g.cancel(),e.g=null)}function Qt(e){Xt(e),e.u&&(a.clearTimeout(e.u),e.u=null),on(e),e.h.cancel(),e.s&&("number"===typeof e.s&&a.clearTimeout(e.s),e.s=null)}function Zt(e){if(!Qe(e.h)&&!e.s){e.s=!0;var t=e.Ga;C||_(),A||(C(),A=!0),E.add(t,e),e.B=0}}function Jt(e,t){var n;n=t?t.l:e.U++;const r=it(e.I);ct(r,"SID",e.K),ct(r,"RID",n),ct(r,"AID",e.T),en(e,r),e.m&&e.o&&Ot(r,e.m,e.o),n=new Fe(e,e.j,n,e.B+1),null===e.m&&(n.H=e.o),t&&(e.i=t.D.concat(e.i)),t=tn(e,n,1e3),n.I=Math.round(.5*e.wa)+Math.round(.5*e.wa*Math.random()),et(e.h,n),ze(n,r,t)}function en(e,t){e.H&&b(e.H,(function(e,n){ct(t,n,e)})),e.l&&rt({},(function(e,n){ct(t,n,e)}))}function tn(e,t,n){n=Math.min(e.i.length,n);var r=e.l?u(e.l.Na,e.l,e):null;e:{var a=e.i;let t=-1;for(;;){const e=["count="+n];-1==t?0<n?(t=a[0].g,e.push("ofs="+t)):t=0:e.push("ofs="+t);let s=!0;for(let i=0;i<n;i++){let n=a[i].g;const o=a[i].map;if(n-=t,0>n)t=Math.max(0,a[i].g-100),s=!1;else try{Et(o,e,"req"+n+"_")}catch(iR){r&&r(o)}}if(s){r=e.join("&");break e}}}return e=e.i.splice(0,n),t.D=e,r}function nn(e){if(!e.g&&!e.u){e.Y=1;var t=e.Fa;C||_(),A||(C(),A=!0),E.add(t,e),e.v=0}}function rn(e){return!(e.g||e.u||3<=e.v)&&(e.Y++,e.u=Ae(u(e.Fa,e),un(e,e.v)),e.v++,!0)}function an(e){null!=e.A&&(a.clearTimeout(e.A),e.A=null)}function sn(e){e.g=new Fe(e,e.j,"rpc",e.Y),null===e.m&&(e.g.H=e.o),e.g.O=0;var t=it(e.qa);ct(t,"RID","rpc"),ct(t,"SID",e.K),ct(t,"AID",e.T),ct(t,"CI",e.F?"0":"1"),!e.F&&e.ja&&ct(t,"TO",e.ja),ct(t,"TYPE","xmlhttp"),en(e,t),e.m&&e.o&&Ot(t,e.m,e.o),e.L&&(e.g.I=e.L);var n=e.g;e=e.ia,n.L=1,n.v=dt(it(t)),n.m=null,n.P=!0,Be(n,e)}function on(e){null!=e.C&&(a.clearTimeout(e.C),e.C=null)}function ln(e,t){var n=null;if(e.g==t){on(e),an(e),e.g=null;var r=2}else{if(!Je(e.h,t))return;n=t.D,tt(e.h,t),r=1}if(0!=e.G)if(t.o)if(1==r){n=t.m?t.m.length:0,t=Date.now()-t.F;var a=e.B;re(r=ke(),new Ce(r,n)),Zt(e)}else nn(e);else if(3==(a=t.s)||0==a&&0<t.X||!(1==r&&function(e,t){return!(Ze(e.h)>=e.h.j-(e.s?1:0))&&(e.s?(e.i=t.D.concat(e.i),!0):!(1==e.G||2==e.G||e.B>=(e.Va?0:e.Wa))&&(e.s=Ae(u(e.Ga,e,t),un(e,e.B)),e.B++,!0))}(e,t)||2==r&&rn(e)))switch(n&&0<n.length&&(t=e.h,t.i=t.i.concat(n)),a){case 1:cn(e,5);break;case 4:cn(e,10);break;case 3:cn(e,6);break;default:cn(e,2)}}function un(e,t){let n=e.Ta+Math.floor(Math.random()*e.cb);return e.isActive()||(n*=2),n*t}function cn(e,t){if(e.j.info("Error code "+t),2==t){var n=u(e.fb,e),r=e.Xa;const t=!r;r=new st(r||"//www.google.com/images/cleardot.gif"),a.location&&"http"==a.location.protocol||ot(r,"https"),dt(r),t?function(e,t){const n=new Ee;if(a.Image){const r=new Image;r.onload=c(Ct,n,"TestLoadImage: loaded",!0,t,r),r.onerror=c(Ct,n,"TestLoadImage: error",!1,t,r),r.onabort=c(Ct,n,"TestLoadImage: abort",!1,t,r),r.ontimeout=c(Ct,n,"TestLoadImage: timeout",!1,t,r),a.setTimeout((function(){r.ontimeout&&r.ontimeout()}),1e4),r.src=e}else t(!1)}(r.toString(),n):function(e,t){new Ee;const n=new AbortController,r=setTimeout((()=>{n.abort(),Ct(0,0,!1,t)}),1e4);fetch(e,{signal:n.signal}).then((e=>{clearTimeout(r),e.ok?Ct(0,0,!0,t):Ct(0,0,!1,t)})).catch((()=>{clearTimeout(r),Ct(0,0,!1,t)}))}(r.toString(),n)}else Ne(2);e.G=0,e.l&&e.l.sa(t),dn(e),Qt(e)}function dn(e){if(e.G=0,e.ka=[],e.l){const t=nt(e.h);0==t.length&&0==e.i.length||(p(e.ka,t),p(e.ka,e.i),e.h.i.length=0,h(e.i),e.i.length=0),e.l.ra()}}function hn(e,t,n){var r=n instanceof st?it(n):new st(n);if(""!=r.g)t&&(r.g=t+"."+r.g),lt(r,r.s);else{var s=a.location;r=s.protocol,t=t?t+"."+s.hostname:s.hostname,s=+s.port;var i=new st(null);r&&ot(i,r),t&&(i.g=t),s&&lt(i,s),n&&(i.l=n),r=i}return n=e.D,t=e.ya,n&&t&&ct(r,n,t),ct(r,"VER",e.la),en(e,r),r}function pn(e,t,n){if(t&&!e.J)throw Error("Can't create secondary domain capable XhrIo object.");return(t=e.Ca&&!e.pa?new Pt(new _t({eb:n})):new Pt(e.pa)).Ha(e.J),t}function fn(){}function mn(){}function gn(e,t){ne.call(this),this.g=new Kt(t),this.l=e,this.h=t&&t.messageUrlParams||null,e=t&&t.messageHeaders||null,t&&t.clientProtocolHeaderRequired&&(e?e["X-Client-Protocol"]="webchannel":e={"X-Client-Protocol":"webchannel"}),this.g.o=e,e=t&&t.initMessageHeaders||null,t&&t.messageContentType&&(e?e["X-WebChannel-Content-Type"]=t.messageContentType:e={"X-WebChannel-Content-Type":t.messageContentType}),t&&t.va&&(e?e["X-WebChannel-Client-Profile"]=t.va:e={"X-WebChannel-Client-Profile":t.va}),this.g.S=e,(e=t&&t.Sb)&&!f(e)&&(this.g.m=e),this.v=t&&t.supportsCrossDomainXhr||!1,this.u=t&&t.sendRawJson||!1,(t=t&&t.httpSessionIdParam)&&!f(t)&&(this.g.D=t,null!==(e=this.h)&&t in e&&(t in(e=this.h)&&delete e[t])),this.j=new vn(this)}function yn(e){be.call(this),e.__headers__&&(this.headers=e.__headers__,this.statusCode=e.__status__,delete e.__headers__,delete e.__status__);var t=e.__sm__;if(t){e:{for(const n in t){e=n;break e}e=void 0}(this.i=e)&&(e=this.i,t=null!==t&&e in t?t[e]:void 0),this.data=t}else this.data=e}function bn(){ve.call(this),this.status=1}function vn(e){this.g=e}(e=Pt.prototype).Ha=function(e){this.J=e},e.ea=function(e,t,n,r){if(this.g)throw Error("[goog.net.XhrIo] Object is active with another request="+this.D+"; newUri="+e);t=t?t.toUpperCase():"GET",this.D=e,this.l="",this.m=0,this.A=!1,this.h=!0,this.g=this.o?this.o.g():$e.g(),this.v=this.o?me(this.o):me($e),this.g.onreadystatechange=u(this.Ea,this);try{this.B=!0,this.g.open(t,String(e),!0),this.B=!1}catch(i){return void Bt(this,i)}if(e=n||"",n=new Map(this.headers),r)if(Object.getPrototypeOf(r)===Object.prototype)for(var s in r)n.set(s,r[s]);else{if("function"!==typeof r.keys||"function"!==typeof r.get)throw Error("Unknown input type for opt_headers: "+String(r));for(const e of r.keys())n.set(e,r.get(e))}r=Array.from(n.keys()).find((e=>"content-type"==e.toLowerCase())),s=a.FormData&&e instanceof a.FormData,!(0<=Array.prototype.indexOf.call(zt,t,void 0))||r||s||n.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");for(const[a,o]of n)this.g.setRequestHeader(a,o);this.H&&(this.g.responseType=this.H),"withCredentials"in this.g&&this.g.withCredentials!==this.J&&(this.g.withCredentials=this.J);try{jt(this),this.u=!0,this.g.send(e),this.u=!1}catch(i){Bt(this,i)}},e.abort=function(e){this.g&&this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1,this.m=e||7,re(this,"complete"),re(this,"abort"),Ut(this))},e.N=function(){this.g&&(this.h&&(this.h=!1,this.j=!0,this.g.abort(),this.j=!1),Ut(this,!0)),Pt.aa.N.call(this)},e.Ea=function(){this.s||(this.B||this.u||this.j?Wt(this):this.bb())},e.bb=function(){Wt(this)},e.isActive=function(){return!!this.g},e.Z=function(){try{return 2<Gt(this)?this.g.status:-1}catch(mt){return-1}},e.oa=function(){try{return this.g?this.g.responseText:""}catch(mt){return""}},e.Oa=function(e){if(this.g){var t=this.g.responseText;return e&&0==t.indexOf(e)&&(t=t.substring(e.length)),he(t)}},e.Ba=function(){return this.m},e.Ka=function(){return"string"===typeof this.l?this.l:String(this.l)},(e=Kt.prototype).la=8,e.G=1,e.connect=function(e,t,n,r){Ne(0),this.W=e,this.H=t||{},n&&void 0!==r&&(this.H.OSID=n,this.H.OAID=r),this.F=this.X,this.I=hn(this,null,this.W),Zt(this)},e.Ga=function(e){if(this.s)if(this.s=null,1==this.G){if(!e){this.U=Math.floor(1e5*Math.random()),e=this.U++;const a=new Fe(this,this.j,e);let s=this.o;if(this.S&&(s?(s=v(s),w(s,this.S)):s=this.S),null!==this.m||this.O||(a.H=s,s=null),this.P)e:{for(var t=0,n=0;n<this.i.length;n++){var r=this.i[n];if(void 0===(r="__data__"in r.map&&"string"===typeof(r=r.map.__data__)?r.length:void 0))break;if(4096<(t+=r)){t=n;break e}if(4096===t||n===this.i.length-1){t=n+1;break e}}t=1e3}else t=1e3;t=tn(this,a,t),ct(n=it(this.I),"RID",e),ct(n,"CVER",22),this.D&&ct(n,"X-HTTP-Session-Id",this.D),en(this,n),s&&(this.O?t="headers="+encodeURIComponent(String(Ft(s)))+"&"+t:this.m&&Ot(n,this.m,s)),et(this.h,a),this.Ua&&ct(n,"TYPE","init"),this.P?(ct(n,"$req",t),ct(n,"SID","null"),a.T=!0,ze(a,n,null)):ze(a,n,t),this.G=2}}else 3==this.G&&(e?Jt(this,e):0==this.i.length||Qe(this.h)||Jt(this))},e.Fa=function(){if(this.u=null,sn(this),this.ba&&!(this.M||null==this.g||0>=this.R)){var e=2*this.R;this.j.info("BP detection timer enabled: "+e),this.A=Ae(u(this.ab,this),e)}},e.ab=function(){this.A&&(this.A=null,this.j.info("BP detection timeout reached."),this.j.info("Buffering proxy detected and switch to long-polling!"),this.F=!1,this.M=!0,Ne(10),Xt(this),sn(this))},e.Za=function(){null!=this.C&&(this.C=null,Xt(this),rn(this),Ne(19))},e.fb=function(e){e?(this.j.info("Successfully pinged google.com"),Ne(2)):(this.j.info("Failed to ping google.com"),Ne(1))},e.isActive=function(){return!!this.l&&this.l.isActive(this)},(e=fn.prototype).ua=function(){},e.ta=function(){},e.sa=function(){},e.ra=function(){},e.isActive=function(){return!0},e.Na=function(){},mn.prototype.g=function(e,t){return new gn(e,t)},d(gn,ne),gn.prototype.m=function(){this.g.l=this.j,this.v&&(this.g.J=!0),this.g.connect(this.l,this.h||void 0)},gn.prototype.close=function(){Yt(this.g)},gn.prototype.o=function(e){var t=this.g;if("string"===typeof e){var n={};n.__data__=e,e=n}else this.u&&((n={}).__data__=de(e),e=n);t.i.push(new Ye(t.Ya++,e)),3==t.G&&Zt(t)},gn.prototype.N=function(){this.g.l=null,delete this.j,Yt(this.g),delete this.g,gn.aa.N.call(this)},d(yn,be),d(bn,ve),d(vn,fn),vn.prototype.ua=function(){re(this.g,"a")},vn.prototype.ta=function(e){re(this.g,new yn(e))},vn.prototype.sa=function(e){re(this.g,new bn)},vn.prototype.ra=function(){re(this.g,"b")},mn.prototype.createWebChannel=mn.prototype.g,gn.prototype.send=gn.prototype.o,gn.prototype.open=gn.prototype.m,gn.prototype.close=gn.prototype.close,Gc=qc.createWebChannelTransport=function(){return new mn},jc=qc.getStatEventTarget=function(){return ke()},Uc=qc.Event=xe,Wc=qc.Stat={mb:0,pb:1,qb:2,Jb:3,Ob:4,Lb:5,Mb:6,Kb:7,Ib:8,Nb:9,PROXY:10,NOPROXY:11,Gb:12,Cb:13,Db:14,Bb:15,Eb:16,Fb:17,ib:18,hb:19,jb:20},Re.NO_ERROR=0,Re.TIMEOUT=8,Re.HTTP_ERROR=6,Vc=qc.ErrorCode=Re,De.COMPLETE="complete",Bc=qc.EventType=De,ge.EventType=ye,ye.OPEN="a",ye.CLOSE="b",ye.ERROR="c",ye.MESSAGE="d",ne.prototype.listen=ne.prototype.K,zc=qc.WebChannel=ge,Lc=qc.FetchXmlHttpFactory=_t,Pt.prototype.listenOnce=Pt.prototype.L,Pt.prototype.getLastError=Pt.prototype.Ka,Pt.prototype.getLastErrorCode=Pt.prototype.Ba,Pt.prototype.getStatus=Pt.prototype.Z,Pt.prototype.getResponseJson=Pt.prototype.Oa,Pt.prototype.getResponseText=Pt.prototype.oa,Pt.prototype.send=Pt.prototype.ea,Pt.prototype.setWithCredentials=Pt.prototype.Ha,Pc=qc.XhrIo=Pt}).apply("undefined"!==typeof Hc?Hc:"undefined"!==typeof self?self:"undefined"!==typeof window?window:{});const Kc="@firebase/firestore";class Yc{constructor(e){this.uid=e}isAuthenticated(){return null!=this.uid}toKey(){return this.isAuthenticated()?"uid:"+this.uid:"anonymous-user"}isEqual(e){return e.uid===this.uid}}Yc.UNAUTHENTICATED=new Yc(null),Yc.GOOGLE_CREDENTIALS=new Yc("google-credentials-uid"),Yc.FIRST_PARTY=new Yc("first-party-uid"),Yc.MOCK_USER=new Yc("mock-user");let Xc="10.13.1";const Qc=new gu("@firebase/firestore");function Zc(){return Qc.logLevel}function Jc(e){if(Qc.logLevel<=du.DEBUG){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(nd);Qc.debug(`Firestore (${Xc}): ${e}`,...a)}}function ed(e){if(Qc.logLevel<=du.ERROR){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(nd);Qc.error(`Firestore (${Xc}): ${e}`,...a)}}function td(e){if(Qc.logLevel<=du.WARN){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const a=n.map(nd);Qc.warn(`Firestore (${Xc}): ${e}`,...a)}}function nd(e){if("string"==typeof e)return e;try{return function(e){return JSON.stringify(e)}(e)}catch(t){return e}}function rd(){const e=`FIRESTORE (${Xc}) INTERNAL ASSERTION FAILED: `+(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Unexpected state");throw ed(e),new Error(e)}function ad(e,t){e||rd()}function sd(e,t){return e}const id={OK:"ok",CANCELLED:"cancelled",UNKNOWN:"unknown",INVALID_ARGUMENT:"invalid-argument",DEADLINE_EXCEEDED:"deadline-exceeded",NOT_FOUND:"not-found",ALREADY_EXISTS:"already-exists",PERMISSION_DENIED:"permission-denied",UNAUTHENTICATED:"unauthenticated",RESOURCE_EXHAUSTED:"resource-exhausted",FAILED_PRECONDITION:"failed-precondition",ABORTED:"aborted",OUT_OF_RANGE:"out-of-range",UNIMPLEMENTED:"unimplemented",INTERNAL:"internal",UNAVAILABLE:"unavailable",DATA_LOSS:"data-loss"};class od extends Jl{constructor(e,t){super(e,t),this.code=e,this.message=t,this.toString=()=>`${this.name}: [code=${this.code}]: ${this.message}`}}class ld{constructor(){this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}}class ud{constructor(e,t){this.user=t,this.type="OAuth",this.headers=new Map,this.headers.set("Authorization",`Bearer ${e}`)}}class cd{getToken(){return Promise.resolve(null)}invalidateToken(){}start(e,t){e.enqueueRetryable((()=>t(Yc.UNAUTHENTICATED)))}shutdown(){}}class dd{constructor(e){this.token=e,this.changeListener=null}getToken(){return Promise.resolve(this.token)}invalidateToken(){}start(e,t){this.changeListener=t,e.enqueueRetryable((()=>t(this.token.user)))}shutdown(){this.changeListener=null}}class hd{constructor(e){this.t=e,this.currentUser=Yc.UNAUTHENTICATED,this.i=0,this.forceRefresh=!1,this.auth=null}start(e,t){let n=this.i;const r=e=>this.i!==n?(n=this.i,t(e)):Promise.resolve();let a=new ld;this.o=()=>{this.i++,this.currentUser=this.u(),a.resolve(),a=new ld,e.enqueueRetryable((()=>r(this.currentUser)))};const s=()=>{const t=a;e.enqueueRetryable((async()=>{await t.promise,await r(this.currentUser)}))},i=e=>{Jc("FirebaseAuthCredentialsProvider","Auth detected"),this.auth=e,this.auth.addAuthTokenListener(this.o),s()};this.t.onInit((e=>i(e))),setTimeout((()=>{if(!this.auth){const e=this.t.getImmediate({optional:!0});e?i(e):(Jc("FirebaseAuthCredentialsProvider","Auth not yet detected"),a.resolve(),a=new ld)}}),0),s()}getToken(){const e=this.i,t=this.forceRefresh;return this.forceRefresh=!1,this.auth?this.auth.getToken(t).then((t=>this.i!==e?(Jc("FirebaseAuthCredentialsProvider","getToken aborted due to token change."),this.getToken()):t?(ad("string"==typeof t.accessToken),new ud(t.accessToken,this.currentUser)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.auth&&this.auth.removeAuthTokenListener(this.o)}u(){const e=this.auth&&this.auth.getUid();return ad(null===e||"string"==typeof e),new Yc(e)}}class pd{constructor(e,t,n){this.l=e,this.h=t,this.P=n,this.type="FirstParty",this.user=Yc.FIRST_PARTY,this.I=new Map}T(){return this.P?this.P():null}get headers(){this.I.set("X-Goog-AuthUser",this.l);const e=this.T();return e&&this.I.set("Authorization",e),this.h&&this.I.set("X-Goog-Iam-Authorization-Token",this.h),this.I}}class fd{constructor(e,t,n){this.l=e,this.h=t,this.P=n}getToken(){return Promise.resolve(new pd(this.l,this.h,this.P))}start(e,t){e.enqueueRetryable((()=>t(Yc.FIRST_PARTY)))}shutdown(){}invalidateToken(){}}class md{constructor(e){this.value=e,this.type="AppCheck",this.headers=new Map,e&&e.length>0&&this.headers.set("x-firebase-appcheck",this.value)}}class gd{constructor(e){this.A=e,this.forceRefresh=!1,this.appCheck=null,this.R=null}start(e,t){const n=e=>{null!=e.error&&Jc("FirebaseAppCheckTokenProvider",`Error getting App Check token; using placeholder token instead. Error: ${e.error.message}`);const n=e.token!==this.R;return this.R=e.token,Jc("FirebaseAppCheckTokenProvider",`Received ${n?"new":"existing"} token.`),n?t(e.token):Promise.resolve()};this.o=t=>{e.enqueueRetryable((()=>n(t)))};const r=e=>{Jc("FirebaseAppCheckTokenProvider","AppCheck detected"),this.appCheck=e,this.appCheck.addTokenListener(this.o)};this.A.onInit((e=>r(e))),setTimeout((()=>{if(!this.appCheck){const e=this.A.getImmediate({optional:!0});e?r(e):Jc("FirebaseAppCheckTokenProvider","AppCheck not yet detected")}}),0)}getToken(){const e=this.forceRefresh;return this.forceRefresh=!1,this.appCheck?this.appCheck.getToken(e).then((e=>e?(ad("string"==typeof e.token),this.R=e.token,new md(e.token)):null)):Promise.resolve(null)}invalidateToken(){this.forceRefresh=!0}shutdown(){this.appCheck&&this.appCheck.removeTokenListener(this.o)}}function yd(e){const t="undefined"!=typeof self&&(self.crypto||self.msCrypto),n=new Uint8Array(e);if(t&&"function"==typeof t.getRandomValues)t.getRandomValues(n);else for(let r=0;r<e;r++)n[r]=Math.floor(256*Math.random());return n}class bd{static newId(){const e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",t=62*Math.floor(256/62);let n="";for(;n.length<20;){const r=yd(40);for(let a=0;a<r.length;++a)n.length<20&&r[a]<t&&(n+=e.charAt(r[a]%62))}return n}}function vd(e,t){return e<t?-1:e>t?1:0}function xd(e,t,n){return e.length===t.length&&e.every(((e,r)=>n(e,t[r])))}class wd{constructor(e,t){if(this.seconds=e,this.nanoseconds=t,t<0)throw new od(id.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+t);if(t>=1e9)throw new od(id.INVALID_ARGUMENT,"Timestamp nanoseconds out of range: "+t);if(e<-62135596800)throw new od(id.INVALID_ARGUMENT,"Timestamp seconds out of range: "+e);if(e>=253402300800)throw new od(id.INVALID_ARGUMENT,"Timestamp seconds out of range: "+e)}static now(){return wd.fromMillis(Date.now())}static fromDate(e){return wd.fromMillis(e.getTime())}static fromMillis(e){const t=Math.floor(e/1e3),n=Math.floor(1e6*(e-1e3*t));return new wd(t,n)}toDate(){return new Date(this.toMillis())}toMillis(){return 1e3*this.seconds+this.nanoseconds/1e6}_compareTo(e){return this.seconds===e.seconds?vd(this.nanoseconds,e.nanoseconds):vd(this.seconds,e.seconds)}isEqual(e){return e.seconds===this.seconds&&e.nanoseconds===this.nanoseconds}toString(){return"Timestamp(seconds="+this.seconds+", nanoseconds="+this.nanoseconds+")"}toJSON(){return{seconds:this.seconds,nanoseconds:this.nanoseconds}}valueOf(){const e=this.seconds- -62135596800;return String(e).padStart(12,"0")+"."+String(this.nanoseconds).padStart(9,"0")}}class kd{constructor(e){this.timestamp=e}static fromTimestamp(e){return new kd(e)}static min(){return new kd(new wd(0,0))}static max(){return new kd(new wd(253402300799,999999999))}compareTo(e){return this.timestamp._compareTo(e.timestamp)}isEqual(e){return this.timestamp.isEqual(e.timestamp)}toMicroseconds(){return 1e6*this.timestamp.seconds+this.timestamp.nanoseconds/1e3}toString(){return"SnapshotVersion("+this.timestamp.toString()+")"}toTimestamp(){return this.timestamp}}class Sd{constructor(e,t,n){void 0===t?t=0:t>e.length&&rd(),void 0===n?n=e.length-t:n>e.length-t&&rd(),this.segments=e,this.offset=t,this.len=n}get length(){return this.len}isEqual(e){return 0===Sd.comparator(this,e)}child(e){const t=this.segments.slice(this.offset,this.limit());return e instanceof Sd?e.forEach((e=>{t.push(e)})):t.push(e),this.construct(t)}limit(){return this.offset+this.length}popFirst(e){return e=void 0===e?1:e,this.construct(this.segments,this.offset+e,this.length-e)}popLast(){return this.construct(this.segments,this.offset,this.length-1)}firstSegment(){return this.segments[this.offset]}lastSegment(){return this.get(this.length-1)}get(e){return this.segments[this.offset+e]}isEmpty(){return 0===this.length}isPrefixOf(e){if(e.length<this.length)return!1;for(let t=0;t<this.length;t++)if(this.get(t)!==e.get(t))return!1;return!0}isImmediateParentOf(e){if(this.length+1!==e.length)return!1;for(let t=0;t<this.length;t++)if(this.get(t)!==e.get(t))return!1;return!0}forEach(e){for(let t=this.offset,n=this.limit();t<n;t++)e(this.segments[t])}toArray(){return this.segments.slice(this.offset,this.limit())}static comparator(e,t){const n=Math.min(e.length,t.length);for(let r=0;r<n;r++){const n=e.get(r),a=t.get(r);if(n<a)return-1;if(n>a)return 1}return e.length<t.length?-1:e.length>t.length?1:0}}class Id extends Sd{construct(e,t,n){return new Id(e,t,n)}canonicalString(){return this.toArray().join("/")}toString(){return this.canonicalString()}toUriEncodedString(){return this.toArray().map(encodeURIComponent).join("/")}static fromString(){const e=[];for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const a of n){if(a.indexOf("//")>=0)throw new od(id.INVALID_ARGUMENT,`Invalid segment (${a}). Paths must not contain // in them.`);e.push(...a.split("/").filter((e=>e.length>0)))}return new Id(e)}static emptyPath(){return new Id([])}}const Td=/^[_a-zA-Z][_a-zA-Z0-9]*$/;class Nd extends Sd{construct(e,t,n){return new Nd(e,t,n)}static isValidIdentifier(e){return Td.test(e)}canonicalString(){return this.toArray().map((e=>(e=e.replace(/\\/g,"\\\\").replace(/`/g,"\\`"),Nd.isValidIdentifier(e)||(e="`"+e+"`"),e))).join(".")}toString(){return this.canonicalString()}isKeyField(){return 1===this.length&&"__name__"===this.get(0)}static keyField(){return new Nd(["__name__"])}static fromServerFormat(e){const t=[];let n="",r=0;const a=()=>{if(0===n.length)throw new od(id.INVALID_ARGUMENT,`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);t.push(n),n=""};let s=!1;for(;r<e.length;){const t=e[r];if("\\"===t){if(r+1===e.length)throw new od(id.INVALID_ARGUMENT,"Path has trailing escape character: "+e);const t=e[r+1];if("\\"!==t&&"."!==t&&"`"!==t)throw new od(id.INVALID_ARGUMENT,"Path has invalid escape sequence: "+e);n+=t,r+=2}else"`"===t?(s=!s,r++):"."!==t||s?(n+=t,r++):(a(),r++)}if(a(),s)throw new od(id.INVALID_ARGUMENT,"Unterminated ` in path: "+e);return new Nd(t)}static emptyPath(){return new Nd([])}}class Cd{constructor(e){this.path=e}static fromPath(e){return new Cd(Id.fromString(e))}static fromName(e){return new Cd(Id.fromString(e).popFirst(5))}static empty(){return new Cd(Id.emptyPath())}get collectionGroup(){return this.path.popLast().lastSegment()}hasCollectionId(e){return this.path.length>=2&&this.path.get(this.path.length-2)===e}getCollectionGroup(){return this.path.get(this.path.length-2)}getCollectionPath(){return this.path.popLast()}isEqual(e){return null!==e&&0===Id.comparator(this.path,e.path)}toString(){return this.path.toString()}static comparator(e,t){return Id.comparator(e.path,t.path)}static isDocumentKey(e){return e.length%2==0}static fromSegments(e){return new Cd(new Id(e.slice()))}}class Ad{constructor(e,t,n,r){this.indexId=e,this.collectionGroup=t,this.fields=n,this.indexState=r}}Ad.UNKNOWN_ID=-1;function Ed(e,t){const n=e.toTimestamp().seconds,r=e.toTimestamp().nanoseconds+1,a=kd.fromTimestamp(1e9===r?new wd(n+1,0):new wd(n,r));return new $d(a,Cd.empty(),t)}function _d(e){return new $d(e.readTime,e.key,-1)}class $d{constructor(e,t,n){this.readTime=e,this.documentKey=t,this.largestBatchId=n}static min(){return new $d(kd.min(),Cd.empty(),-1)}static max(){return new $d(kd.max(),Cd.empty(),-1)}}function Rd(e,t){let n=e.readTime.compareTo(t.readTime);return 0!==n?n:(n=Cd.comparator(e.documentKey,t.documentKey),0!==n?n:vd(e.largestBatchId,t.largestBatchId))}const Dd="The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";class Md{constructor(){this.onCommittedListeners=[]}addOnCommittedListener(e){this.onCommittedListeners.push(e)}raiseOnCommittedEvent(){this.onCommittedListeners.forEach((e=>e()))}}async function Fd(e){if(e.code!==id.FAILED_PRECONDITION||e.message!==Dd)throw e;Jc("LocalStore","Unexpectedly lost primary lease")}class Od{constructor(e){this.nextCallback=null,this.catchCallback=null,this.result=void 0,this.error=void 0,this.isDone=!1,this.callbackAttached=!1,e((e=>{this.isDone=!0,this.result=e,this.nextCallback&&this.nextCallback(e)}),(e=>{this.isDone=!0,this.error=e,this.catchCallback&&this.catchCallback(e)}))}catch(e){return this.next(void 0,e)}next(e,t){return this.callbackAttached&&rd(),this.callbackAttached=!0,this.isDone?this.error?this.wrapFailure(t,this.error):this.wrapSuccess(e,this.result):new Od(((n,r)=>{this.nextCallback=t=>{this.wrapSuccess(e,t).next(n,r)},this.catchCallback=e=>{this.wrapFailure(t,e).next(n,r)}}))}toPromise(){return new Promise(((e,t)=>{this.next(e,t)}))}wrapUserFunction(e){try{const t=e();return t instanceof Od?t:Od.resolve(t)}catch(e){return Od.reject(e)}}wrapSuccess(e,t){return e?this.wrapUserFunction((()=>e(t))):Od.resolve(t)}wrapFailure(e,t){return e?this.wrapUserFunction((()=>e(t))):Od.reject(t)}static resolve(e){return new Od(((t,n)=>{t(e)}))}static reject(e){return new Od(((t,n)=>{n(e)}))}static waitFor(e){return new Od(((t,n)=>{let r=0,a=0,s=!1;e.forEach((e=>{++r,e.next((()=>{++a,s&&a===r&&t()}),(e=>n(e)))})),s=!0,a===r&&t()}))}static or(e){let t=Od.resolve(!1);for(const n of e)t=t.next((e=>e?Od.resolve(e):n()));return t}static forEach(e,t){const n=[];return e.forEach(((e,r)=>{n.push(t.call(this,e,r))})),this.waitFor(n)}static mapArray(e,t){return new Od(((n,r)=>{const a=e.length,s=new Array(a);let i=0;for(let o=0;o<a;o++){const l=o;t(e[l]).next((e=>{s[l]=e,++i,i===a&&n(s)}),(e=>r(e)))}}))}static doWhile(e,t){return new Od(((n,r)=>{const a=()=>{!0===e()?t().next((()=>{a()}),r):n()};a()}))}}function Pd(e){const t=e.match(/Android ([\d.]+)/i),n=t?t[1].split(".").slice(0,2).join("."):"-1";return Number(n)}function Ld(e){return"IndexedDbTransactionError"===e.name}class zd{constructor(e,t){this.previousValue=e,t&&(t.sequenceNumberHandler=e=>this.ie(e),this.se=e=>t.writeSequenceNumber(e))}ie(e){return this.previousValue=Math.max(e,this.previousValue),this.previousValue}next(){const e=++this.previousValue;return this.se&&this.se(e),e}}function Bd(e){return null==e}function Vd(e){return 0===e&&1/e==-1/0}function Wd(e){return"number"==typeof e&&Number.isInteger(e)&&!Vd(e)&&e<=Number.MAX_SAFE_INTEGER&&e>=Number.MIN_SAFE_INTEGER}zd.oe=-1;const Ud=["mutationQueues","mutations","documentMutations","remoteDocuments","targets","owner","targetGlobal","targetDocuments","clientMetadata","remoteDocumentGlobal","collectionParents","bundles","namedQueries"],jd=["mutationQueues","mutations","documentMutations","remoteDocumentsV14","targets","owner","targetGlobal","targetDocuments","clientMetadata","remoteDocumentGlobal","collectionParents","bundles","namedQueries","documentOverlays"],Gd=jd,Hd=[...Gd,"indexConfiguration","indexState","indexEntries"];function qd(e){let t=0;for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t++;return t}function Kd(e,t){for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t(n,e[n])}function Yd(e){for(const t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!1;return!0}class Xd{constructor(e,t){this.comparator=e,this.root=t||Zd.EMPTY}insert(e,t){return new Xd(this.comparator,this.root.insert(e,t,this.comparator).copy(null,null,Zd.BLACK,null,null))}remove(e){return new Xd(this.comparator,this.root.remove(e,this.comparator).copy(null,null,Zd.BLACK,null,null))}get(e){let t=this.root;for(;!t.isEmpty();){const n=this.comparator(e,t.key);if(0===n)return t.value;n<0?t=t.left:n>0&&(t=t.right)}return null}indexOf(e){let t=0,n=this.root;for(;!n.isEmpty();){const r=this.comparator(e,n.key);if(0===r)return t+n.left.size;r<0?n=n.left:(t+=n.left.size+1,n=n.right)}return-1}isEmpty(){return this.root.isEmpty()}get size(){return this.root.size}minKey(){return this.root.minKey()}maxKey(){return this.root.maxKey()}inorderTraversal(e){return this.root.inorderTraversal(e)}forEach(e){this.inorderTraversal(((t,n)=>(e(t,n),!1)))}toString(){const e=[];return this.inorderTraversal(((t,n)=>(e.push(`${t}:${n}`),!1))),`{${e.join(", ")}}`}reverseTraversal(e){return this.root.reverseTraversal(e)}getIterator(){return new Qd(this.root,null,this.comparator,!1)}getIteratorFrom(e){return new Qd(this.root,e,this.comparator,!1)}getReverseIterator(){return new Qd(this.root,null,this.comparator,!0)}getReverseIteratorFrom(e){return new Qd(this.root,e,this.comparator,!0)}}class Qd{constructor(e,t,n,r){this.isReverse=r,this.nodeStack=[];let a=1;for(;!e.isEmpty();)if(a=t?n(e.key,t):1,t&&r&&(a*=-1),a<0)e=this.isReverse?e.left:e.right;else{if(0===a){this.nodeStack.push(e);break}this.nodeStack.push(e),e=this.isReverse?e.right:e.left}}getNext(){let e=this.nodeStack.pop();const t={key:e.key,value:e.value};if(this.isReverse)for(e=e.left;!e.isEmpty();)this.nodeStack.push(e),e=e.right;else for(e=e.right;!e.isEmpty();)this.nodeStack.push(e),e=e.left;return t}hasNext(){return this.nodeStack.length>0}peek(){if(0===this.nodeStack.length)return null;const e=this.nodeStack[this.nodeStack.length-1];return{key:e.key,value:e.value}}}class Zd{constructor(e,t,n,r,a){this.key=e,this.value=t,this.color=null!=n?n:Zd.RED,this.left=null!=r?r:Zd.EMPTY,this.right=null!=a?a:Zd.EMPTY,this.size=this.left.size+1+this.right.size}copy(e,t,n,r,a){return new Zd(null!=e?e:this.key,null!=t?t:this.value,null!=n?n:this.color,null!=r?r:this.left,null!=a?a:this.right)}isEmpty(){return!1}inorderTraversal(e){return this.left.inorderTraversal(e)||e(this.key,this.value)||this.right.inorderTraversal(e)}reverseTraversal(e){return this.right.reverseTraversal(e)||e(this.key,this.value)||this.left.reverseTraversal(e)}min(){return this.left.isEmpty()?this:this.left.min()}minKey(){return this.min().key}maxKey(){return this.right.isEmpty()?this.key:this.right.maxKey()}insert(e,t,n){let r=this;const a=n(e,r.key);return r=a<0?r.copy(null,null,null,r.left.insert(e,t,n),null):0===a?r.copy(null,t,null,null,null):r.copy(null,null,null,null,r.right.insert(e,t,n)),r.fixUp()}removeMin(){if(this.left.isEmpty())return Zd.EMPTY;let e=this;return e.left.isRed()||e.left.left.isRed()||(e=e.moveRedLeft()),e=e.copy(null,null,null,e.left.removeMin(),null),e.fixUp()}remove(e,t){let n,r=this;if(t(e,r.key)<0)r.left.isEmpty()||r.left.isRed()||r.left.left.isRed()||(r=r.moveRedLeft()),r=r.copy(null,null,null,r.left.remove(e,t),null);else{if(r.left.isRed()&&(r=r.rotateRight()),r.right.isEmpty()||r.right.isRed()||r.right.left.isRed()||(r=r.moveRedRight()),0===t(e,r.key)){if(r.right.isEmpty())return Zd.EMPTY;n=r.right.min(),r=r.copy(n.key,n.value,null,null,r.right.removeMin())}r=r.copy(null,null,null,null,r.right.remove(e,t))}return r.fixUp()}isRed(){return this.color}fixUp(){let e=this;return e.right.isRed()&&!e.left.isRed()&&(e=e.rotateLeft()),e.left.isRed()&&e.left.left.isRed()&&(e=e.rotateRight()),e.left.isRed()&&e.right.isRed()&&(e=e.colorFlip()),e}moveRedLeft(){let e=this.colorFlip();return e.right.left.isRed()&&(e=e.copy(null,null,null,null,e.right.rotateRight()),e=e.rotateLeft(),e=e.colorFlip()),e}moveRedRight(){let e=this.colorFlip();return e.left.left.isRed()&&(e=e.rotateRight(),e=e.colorFlip()),e}rotateLeft(){const e=this.copy(null,null,Zd.RED,null,this.right.left);return this.right.copy(null,null,this.color,e,null)}rotateRight(){const e=this.copy(null,null,Zd.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,e)}colorFlip(){const e=this.left.copy(null,null,!this.left.color,null,null),t=this.right.copy(null,null,!this.right.color,null,null);return this.copy(null,null,!this.color,e,t)}checkMaxDepth(){const e=this.check();return Math.pow(2,e)<=this.size+1}check(){if(this.isRed()&&this.left.isRed())throw rd();if(this.right.isRed())throw rd();const e=this.left.check();if(e!==this.right.check())throw rd();return e+(this.isRed()?0:1)}}Zd.EMPTY=null,Zd.RED=!0,Zd.BLACK=!1,Zd.EMPTY=new class{constructor(){this.size=0}get key(){throw rd()}get value(){throw rd()}get color(){throw rd()}get left(){throw rd()}get right(){throw rd()}copy(e,t,n,r,a){return this}insert(e,t,n){return new Zd(e,t)}remove(e,t){return this}isEmpty(){return!0}inorderTraversal(e){return!1}reverseTraversal(e){return!1}minKey(){return null}maxKey(){return null}isRed(){return!1}checkMaxDepth(){return!0}check(){return 0}};class Jd{constructor(e){this.comparator=e,this.data=new Xd(this.comparator)}has(e){return null!==this.data.get(e)}first(){return this.data.minKey()}last(){return this.data.maxKey()}get size(){return this.data.size}indexOf(e){return this.data.indexOf(e)}forEach(e){this.data.inorderTraversal(((t,n)=>(e(t),!1)))}forEachInRange(e,t){const n=this.data.getIteratorFrom(e[0]);for(;n.hasNext();){const r=n.getNext();if(this.comparator(r.key,e[1])>=0)return;t(r.key)}}forEachWhile(e,t){let n;for(n=void 0!==t?this.data.getIteratorFrom(t):this.data.getIterator();n.hasNext();)if(!e(n.getNext().key))return}firstAfterOrEqual(e){const t=this.data.getIteratorFrom(e);return t.hasNext()?t.getNext().key:null}getIterator(){return new eh(this.data.getIterator())}getIteratorFrom(e){return new eh(this.data.getIteratorFrom(e))}add(e){return this.copy(this.data.remove(e).insert(e,!0))}delete(e){return this.has(e)?this.copy(this.data.remove(e)):this}isEmpty(){return this.data.isEmpty()}unionWith(e){let t=this;return t.size<e.size&&(t=e,e=this),e.forEach((e=>{t=t.add(e)})),t}isEqual(e){if(!(e instanceof Jd))return!1;if(this.size!==e.size)return!1;const t=this.data.getIterator(),n=e.data.getIterator();for(;t.hasNext();){const e=t.getNext().key,r=n.getNext().key;if(0!==this.comparator(e,r))return!1}return!0}toArray(){const e=[];return this.forEach((t=>{e.push(t)})),e}toString(){const e=[];return this.forEach((t=>e.push(t))),"SortedSet("+e.toString()+")"}copy(e){const t=new Jd(this.comparator);return t.data=e,t}}class eh{constructor(e){this.iter=e}getNext(){return this.iter.getNext().key}hasNext(){return this.iter.hasNext()}}class th{constructor(e){this.fields=e,e.sort(Nd.comparator)}static empty(){return new th([])}unionWith(e){let t=new Jd(Nd.comparator);for(const n of this.fields)t=t.add(n);for(const n of e)t=t.add(n);return new th(t.toArray())}covers(e){for(const t of this.fields)if(t.isPrefixOf(e))return!0;return!1}isEqual(e){return xd(this.fields,e.fields,((e,t)=>e.isEqual(t)))}}class nh extends Error{constructor(){super(...arguments),this.name="Base64DecodeError"}}class rh{constructor(e){this.binaryString=e}static fromBase64String(e){const t=function(e){try{return atob(e)}catch(e){throw"undefined"!=typeof DOMException&&e instanceof DOMException?new nh("Invalid base64 string: "+e):e}}(e);return new rh(t)}static fromUint8Array(e){const t=function(e){let t="";for(let n=0;n<e.length;++n)t+=String.fromCharCode(e[n]);return t}(e);return new rh(t)}[Symbol.iterator](){let e=0;return{next:()=>e<this.binaryString.length?{value:this.binaryString.charCodeAt(e++),done:!1}:{value:void 0,done:!0}}}toBase64(){return e=this.binaryString,btoa(e);var e}toUint8Array(){return function(e){const t=new Uint8Array(e.length);for(let n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}(this.binaryString)}approximateByteSize(){return 2*this.binaryString.length}compareTo(e){return vd(this.binaryString,e.binaryString)}isEqual(e){return this.binaryString===e.binaryString}}rh.EMPTY_BYTE_STRING=new rh("");const ah=new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);function sh(e){if(ad(!!e),"string"==typeof e){let t=0;const n=ah.exec(e);if(ad(!!n),n[1]){let e=n[1];e=(e+"000000000").substr(0,9),t=Number(e)}const r=new Date(e);return{seconds:Math.floor(r.getTime()/1e3),nanos:t}}return{seconds:ih(e.seconds),nanos:ih(e.nanos)}}function ih(e){return"number"==typeof e?e:"string"==typeof e?Number(e):0}function oh(e){return"string"==typeof e?rh.fromBase64String(e):rh.fromUint8Array(e)}function lh(e){var t,n;return"server_timestamp"===(null===(n=((null===(t=null==e?void 0:e.mapValue)||void 0===t?void 0:t.fields)||{}).__type__)||void 0===n?void 0:n.stringValue)}function uh(e){const t=e.mapValue.fields.__previous_value__;return lh(t)?uh(t):t}function ch(e){const t=sh(e.mapValue.fields.__local_write_time__.timestampValue);return new wd(t.seconds,t.nanos)}class dh{constructor(e,t,n,r,a,s,i,o,l){this.databaseId=e,this.appId=t,this.persistenceKey=n,this.host=r,this.ssl=a,this.forceLongPolling=s,this.autoDetectLongPolling=i,this.longPollingOptions=o,this.useFetchStreams=l}}class hh{constructor(e,t){this.projectId=e,this.database=t||"(default)"}static empty(){return new hh("","")}get isDefaultDatabase(){return"(default)"===this.database}isEqual(e){return e instanceof hh&&e.projectId===this.projectId&&e.database===this.database}}const ph={mapValue:{fields:{__type__:{stringValue:"__max__"}}}};function fh(e){return"nullValue"in e?0:"booleanValue"in e?1:"integerValue"in e||"doubleValue"in e?2:"timestampValue"in e?3:"stringValue"in e?5:"bytesValue"in e?6:"referenceValue"in e?7:"geoPointValue"in e?8:"arrayValue"in e?9:"mapValue"in e?lh(e)?4:Eh(e)?9007199254740991:Ch(e)?10:11:rd()}function mh(e,t){if(e===t)return!0;const n=fh(e);if(n!==fh(t))return!1;switch(n){case 0:case 9007199254740991:return!0;case 1:return e.booleanValue===t.booleanValue;case 4:return ch(e).isEqual(ch(t));case 3:return function(e,t){if("string"==typeof e.timestampValue&&"string"==typeof t.timestampValue&&e.timestampValue.length===t.timestampValue.length)return e.timestampValue===t.timestampValue;const n=sh(e.timestampValue),r=sh(t.timestampValue);return n.seconds===r.seconds&&n.nanos===r.nanos}(e,t);case 5:return e.stringValue===t.stringValue;case 6:return function(e,t){return oh(e.bytesValue).isEqual(oh(t.bytesValue))}(e,t);case 7:return e.referenceValue===t.referenceValue;case 8:return function(e,t){return ih(e.geoPointValue.latitude)===ih(t.geoPointValue.latitude)&&ih(e.geoPointValue.longitude)===ih(t.geoPointValue.longitude)}(e,t);case 2:return function(e,t){if("integerValue"in e&&"integerValue"in t)return ih(e.integerValue)===ih(t.integerValue);if("doubleValue"in e&&"doubleValue"in t){const n=ih(e.doubleValue),r=ih(t.doubleValue);return n===r?Vd(n)===Vd(r):isNaN(n)&&isNaN(r)}return!1}(e,t);case 9:return xd(e.arrayValue.values||[],t.arrayValue.values||[],mh);case 10:case 11:return function(e,t){const n=e.mapValue.fields||{},r=t.mapValue.fields||{};if(qd(n)!==qd(r))return!1;for(const a in n)if(n.hasOwnProperty(a)&&(void 0===r[a]||!mh(n[a],r[a])))return!1;return!0}(e,t);default:return rd()}}function gh(e,t){return void 0!==(e.values||[]).find((e=>mh(e,t)))}function yh(e,t){if(e===t)return 0;const n=fh(e),r=fh(t);if(n!==r)return vd(n,r);switch(n){case 0:case 9007199254740991:return 0;case 1:return vd(e.booleanValue,t.booleanValue);case 2:return function(e,t){const n=ih(e.integerValue||e.doubleValue),r=ih(t.integerValue||t.doubleValue);return n<r?-1:n>r?1:n===r?0:isNaN(n)?isNaN(r)?0:-1:1}(e,t);case 3:return bh(e.timestampValue,t.timestampValue);case 4:return bh(ch(e),ch(t));case 5:return vd(e.stringValue,t.stringValue);case 6:return function(e,t){const n=oh(e),r=oh(t);return n.compareTo(r)}(e.bytesValue,t.bytesValue);case 7:return function(e,t){const n=e.split("/"),r=t.split("/");for(let a=0;a<n.length&&a<r.length;a++){const e=vd(n[a],r[a]);if(0!==e)return e}return vd(n.length,r.length)}(e.referenceValue,t.referenceValue);case 8:return function(e,t){const n=vd(ih(e.latitude),ih(t.latitude));return 0!==n?n:vd(ih(e.longitude),ih(t.longitude))}(e.geoPointValue,t.geoPointValue);case 9:return vh(e.arrayValue,t.arrayValue);case 10:return function(e,t){var n,r,a,s;const i=e.fields||{},o=t.fields||{},l=null===(n=i.value)||void 0===n?void 0:n.arrayValue,u=null===(r=o.value)||void 0===r?void 0:r.arrayValue,c=vd((null===(a=null==l?void 0:l.values)||void 0===a?void 0:a.length)||0,(null===(s=null==u?void 0:u.values)||void 0===s?void 0:s.length)||0);return 0!==c?c:vh(l,u)}(e.mapValue,t.mapValue);case 11:return function(e,t){if(e===ph.mapValue&&t===ph.mapValue)return 0;if(e===ph.mapValue)return 1;if(t===ph.mapValue)return-1;const n=e.fields||{},r=Object.keys(n),a=t.fields||{},s=Object.keys(a);r.sort(),s.sort();for(let i=0;i<r.length&&i<s.length;++i){const e=vd(r[i],s[i]);if(0!==e)return e;const t=yh(n[r[i]],a[s[i]]);if(0!==t)return t}return vd(r.length,s.length)}(e.mapValue,t.mapValue);default:throw rd()}}function bh(e,t){if("string"==typeof e&&"string"==typeof t&&e.length===t.length)return vd(e,t);const n=sh(e),r=sh(t),a=vd(n.seconds,r.seconds);return 0!==a?a:vd(n.nanos,r.nanos)}function vh(e,t){const n=e.values||[],r=t.values||[];for(let a=0;a<n.length&&a<r.length;++a){const e=yh(n[a],r[a]);if(e)return e}return vd(n.length,r.length)}function xh(e){return wh(e)}function wh(e){return"nullValue"in e?"null":"booleanValue"in e?""+e.booleanValue:"integerValue"in e?""+e.integerValue:"doubleValue"in e?""+e.doubleValue:"timestampValue"in e?function(e){const t=sh(e);return`time(${t.seconds},${t.nanos})`}(e.timestampValue):"stringValue"in e?e.stringValue:"bytesValue"in e?function(e){return oh(e).toBase64()}(e.bytesValue):"referenceValue"in e?function(e){return Cd.fromName(e).toString()}(e.referenceValue):"geoPointValue"in e?function(e){return`geo(${e.latitude},${e.longitude})`}(e.geoPointValue):"arrayValue"in e?function(e){let t="[",n=!0;for(const r of e.values||[])n?n=!1:t+=",",t+=wh(r);return t+"]"}(e.arrayValue):"mapValue"in e?function(e){const t=Object.keys(e.fields||{}).sort();let n="{",r=!0;for(const a of t)r?r=!1:n+=",",n+=`${a}:${wh(e.fields[a])}`;return n+"}"}(e.mapValue):rd()}function kh(e){return!!e&&"integerValue"in e}function Sh(e){return!!e&&"arrayValue"in e}function Ih(e){return!!e&&"nullValue"in e}function Th(e){return!!e&&"doubleValue"in e&&isNaN(Number(e.doubleValue))}function Nh(e){return!!e&&"mapValue"in e}function Ch(e){var t,n;return"__vector__"===(null===(n=((null===(t=null==e?void 0:e.mapValue)||void 0===t?void 0:t.fields)||{}).__type__)||void 0===n?void 0:n.stringValue)}function Ah(e){if(e.geoPointValue)return{geoPointValue:Object.assign({},e.geoPointValue)};if(e.timestampValue&&"object"==typeof e.timestampValue)return{timestampValue:Object.assign({},e.timestampValue)};if(e.mapValue){const t={mapValue:{fields:{}}};return Kd(e.mapValue.fields,((e,n)=>t.mapValue.fields[e]=Ah(n))),t}if(e.arrayValue){const t={arrayValue:{values:[]}};for(let n=0;n<(e.arrayValue.values||[]).length;++n)t.arrayValue.values[n]=Ah(e.arrayValue.values[n]);return t}return Object.assign({},e)}function Eh(e){return"__max__"===(((e.mapValue||{}).fields||{}).__type__||{}).stringValue}class _h{constructor(e){this.value=e}static empty(){return new _h({mapValue:{}})}field(e){if(e.isEmpty())return this.value;{let t=this.value;for(let n=0;n<e.length-1;++n)if(t=(t.mapValue.fields||{})[e.get(n)],!Nh(t))return null;return t=(t.mapValue.fields||{})[e.lastSegment()],t||null}}set(e,t){this.getFieldsMap(e.popLast())[e.lastSegment()]=Ah(t)}setAll(e){let t=Nd.emptyPath(),n={},r=[];e.forEach(((e,a)=>{if(!t.isImmediateParentOf(a)){const e=this.getFieldsMap(t);this.applyChanges(e,n,r),n={},r=[],t=a.popLast()}e?n[a.lastSegment()]=Ah(e):r.push(a.lastSegment())}));const a=this.getFieldsMap(t);this.applyChanges(a,n,r)}delete(e){const t=this.field(e.popLast());Nh(t)&&t.mapValue.fields&&delete t.mapValue.fields[e.lastSegment()]}isEqual(e){return mh(this.value,e.value)}getFieldsMap(e){let t=this.value;t.mapValue.fields||(t.mapValue={fields:{}});for(let n=0;n<e.length;++n){let r=t.mapValue.fields[e.get(n)];Nh(r)&&r.mapValue.fields||(r={mapValue:{fields:{}}},t.mapValue.fields[e.get(n)]=r),t=r}return t.mapValue.fields}applyChanges(e,t,n){Kd(t,((t,n)=>e[t]=n));for(const r of n)delete e[r]}clone(){return new _h(Ah(this.value))}}function $h(e){const t=[];return Kd(e.fields,((e,n)=>{const r=new Nd([e]);if(Nh(n)){const e=$h(n.mapValue).fields;if(0===e.length)t.push(r);else for(const n of e)t.push(r.child(n))}else t.push(r)})),new th(t)}class Rh{constructor(e,t,n,r,a,s,i){this.key=e,this.documentType=t,this.version=n,this.readTime=r,this.createTime=a,this.data=s,this.documentState=i}static newInvalidDocument(e){return new Rh(e,0,kd.min(),kd.min(),kd.min(),_h.empty(),0)}static newFoundDocument(e,t,n,r){return new Rh(e,1,t,kd.min(),n,r,0)}static newNoDocument(e,t){return new Rh(e,2,t,kd.min(),kd.min(),_h.empty(),0)}static newUnknownDocument(e,t){return new Rh(e,3,t,kd.min(),kd.min(),_h.empty(),2)}convertToFoundDocument(e,t){return!this.createTime.isEqual(kd.min())||2!==this.documentType&&0!==this.documentType||(this.createTime=e),this.version=e,this.documentType=1,this.data=t,this.documentState=0,this}convertToNoDocument(e){return this.version=e,this.documentType=2,this.data=_h.empty(),this.documentState=0,this}convertToUnknownDocument(e){return this.version=e,this.documentType=3,this.data=_h.empty(),this.documentState=2,this}setHasCommittedMutations(){return this.documentState=2,this}setHasLocalMutations(){return this.documentState=1,this.version=kd.min(),this}setReadTime(e){return this.readTime=e,this}get hasLocalMutations(){return 1===this.documentState}get hasCommittedMutations(){return 2===this.documentState}get hasPendingWrites(){return this.hasLocalMutations||this.hasCommittedMutations}isValidDocument(){return 0!==this.documentType}isFoundDocument(){return 1===this.documentType}isNoDocument(){return 2===this.documentType}isUnknownDocument(){return 3===this.documentType}isEqual(e){return e instanceof Rh&&this.key.isEqual(e.key)&&this.version.isEqual(e.version)&&this.documentType===e.documentType&&this.documentState===e.documentState&&this.data.isEqual(e.data)}mutableCopy(){return new Rh(this.key,this.documentType,this.version,this.readTime,this.createTime,this.data.clone(),this.documentState)}toString(){return`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`}}class Dh{constructor(e,t){this.position=e,this.inclusive=t}}function Mh(e,t,n){let r=0;for(let a=0;a<e.position.length;a++){const s=t[a],i=e.position[a];if(r=s.field.isKeyField()?Cd.comparator(Cd.fromName(i.referenceValue),n.key):yh(i,n.data.field(s.field)),"desc"===s.dir&&(r*=-1),0!==r)break}return r}function Fh(e,t){if(null===e)return null===t;if(null===t)return!1;if(e.inclusive!==t.inclusive||e.position.length!==t.position.length)return!1;for(let n=0;n<e.position.length;n++)if(!mh(e.position[n],t.position[n]))return!1;return!0}class Oh{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"asc";this.field=e,this.dir=t}}function Ph(e,t){return e.dir===t.dir&&e.field.isEqual(t.field)}class Lh{}class zh extends Lh{constructor(e,t,n){super(),this.field=e,this.op=t,this.value=n}static create(e,t,n){return e.isKeyField()?"in"===t||"not-in"===t?this.createKeyFieldInFilter(e,t,n):new qh(e,t,n):"array-contains"===t?new Qh(e,n):"in"===t?new Zh(e,n):"not-in"===t?new Jh(e,n):"array-contains-any"===t?new ep(e,n):new zh(e,t,n)}static createKeyFieldInFilter(e,t,n){return"in"===t?new Kh(e,n):new Yh(e,n)}matches(e){const t=e.data.field(this.field);return"!="===this.op?null!==t&&this.matchesComparison(yh(t,this.value)):null!==t&&fh(this.value)===fh(t)&&this.matchesComparison(yh(t,this.value))}matchesComparison(e){switch(this.op){case"<":return e<0;case"<=":return e<=0;case"==":return 0===e;case"!=":return 0!==e;case">":return e>0;case">=":return e>=0;default:return rd()}}isInequality(){return["<","<=",">",">=","!=","not-in"].indexOf(this.op)>=0}getFlattenedFilters(){return[this]}getFilters(){return[this]}}class Bh extends Lh{constructor(e,t){super(),this.filters=e,this.op=t,this.ae=null}static create(e,t){return new Bh(e,t)}matches(e){return Vh(this)?void 0===this.filters.find((t=>!t.matches(e))):void 0!==this.filters.find((t=>t.matches(e)))}getFlattenedFilters(){return null!==this.ae||(this.ae=this.filters.reduce(((e,t)=>e.concat(t.getFlattenedFilters())),[])),this.ae}getFilters(){return Object.assign([],this.filters)}}function Vh(e){return"and"===e.op}function Wh(e){return Uh(e)&&Vh(e)}function Uh(e){for(const t of e.filters)if(t instanceof Bh)return!1;return!0}function jh(e){if(e instanceof zh)return e.field.canonicalString()+e.op.toString()+xh(e.value);if(Wh(e))return e.filters.map((e=>jh(e))).join(",");{const t=e.filters.map((e=>jh(e))).join(",");return`${e.op}(${t})`}}function Gh(e,t){return e instanceof zh?function(e,t){return t instanceof zh&&e.op===t.op&&e.field.isEqual(t.field)&&mh(e.value,t.value)}(e,t):e instanceof Bh?function(e,t){return t instanceof Bh&&e.op===t.op&&e.filters.length===t.filters.length&&e.filters.reduce(((e,n,r)=>e&&Gh(n,t.filters[r])),!0)}(e,t):void rd()}function Hh(e){return e instanceof zh?function(e){return`${e.field.canonicalString()} ${e.op} ${xh(e.value)}`}(e):e instanceof Bh?function(e){return e.op.toString()+" {"+e.getFilters().map(Hh).join(" ,")+"}"}(e):"Filter"}class qh extends zh{constructor(e,t,n){super(e,t,n),this.key=Cd.fromName(n.referenceValue)}matches(e){const t=Cd.comparator(e.key,this.key);return this.matchesComparison(t)}}class Kh extends zh{constructor(e,t){super(e,"in",t),this.keys=Xh("in",t)}matches(e){return this.keys.some((t=>t.isEqual(e.key)))}}class Yh extends zh{constructor(e,t){super(e,"not-in",t),this.keys=Xh("not-in",t)}matches(e){return!this.keys.some((t=>t.isEqual(e.key)))}}function Xh(e,t){var n;return((null===(n=t.arrayValue)||void 0===n?void 0:n.values)||[]).map((e=>Cd.fromName(e.referenceValue)))}class Qh extends zh{constructor(e,t){super(e,"array-contains",t)}matches(e){const t=e.data.field(this.field);return Sh(t)&&gh(t.arrayValue,this.value)}}class Zh extends zh{constructor(e,t){super(e,"in",t)}matches(e){const t=e.data.field(this.field);return null!==t&&gh(this.value.arrayValue,t)}}class Jh extends zh{constructor(e,t){super(e,"not-in",t)}matches(e){if(gh(this.value.arrayValue,{nullValue:"NULL_VALUE"}))return!1;const t=e.data.field(this.field);return null!==t&&!gh(this.value.arrayValue,t)}}class ep extends zh{constructor(e,t){super(e,"array-contains-any",t)}matches(e){const t=e.data.field(this.field);return!(!Sh(t)||!t.arrayValue.values)&&t.arrayValue.values.some((e=>gh(this.value.arrayValue,e)))}}class tp{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;this.path=e,this.collectionGroup=t,this.orderBy=n,this.filters=r,this.limit=a,this.startAt=s,this.endAt=i,this.ue=null}}function np(e){return new tp(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,arguments.length>6&&void 0!==arguments[6]?arguments[6]:null)}function rp(e){const t=sd(e);if(null===t.ue){let e=t.path.canonicalString();null!==t.collectionGroup&&(e+="|cg:"+t.collectionGroup),e+="|f:",e+=t.filters.map((e=>jh(e))).join(","),e+="|ob:",e+=t.orderBy.map((e=>function(e){return e.field.canonicalString()+e.dir}(e))).join(","),Bd(t.limit)||(e+="|l:",e+=t.limit),t.startAt&&(e+="|lb:",e+=t.startAt.inclusive?"b:":"a:",e+=t.startAt.position.map((e=>xh(e))).join(",")),t.endAt&&(e+="|ub:",e+=t.endAt.inclusive?"a:":"b:",e+=t.endAt.position.map((e=>xh(e))).join(",")),t.ue=e}return t.ue}function ap(e,t){if(e.limit!==t.limit)return!1;if(e.orderBy.length!==t.orderBy.length)return!1;for(let n=0;n<e.orderBy.length;n++)if(!Ph(e.orderBy[n],t.orderBy[n]))return!1;if(e.filters.length!==t.filters.length)return!1;for(let n=0;n<e.filters.length;n++)if(!Gh(e.filters[n],t.filters[n]))return!1;return e.collectionGroup===t.collectionGroup&&!!e.path.isEqual(t.path)&&!!Fh(e.startAt,t.startAt)&&Fh(e.endAt,t.endAt)}function sp(e){return Cd.isDocumentKey(e.path)&&null===e.collectionGroup&&0===e.filters.length}class ip{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"F",i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;this.path=e,this.collectionGroup=t,this.explicitOrderBy=n,this.filters=r,this.limit=a,this.limitType=s,this.startAt=i,this.endAt=o,this.ce=null,this.le=null,this.he=null,this.startAt,this.endAt}}function op(e,t,n,r,a,s,i,o){return new ip(e,t,n,r,a,s,i,o)}function lp(e){return new ip(e)}function up(e){return 0===e.filters.length&&null===e.limit&&null==e.startAt&&null==e.endAt&&(0===e.explicitOrderBy.length||1===e.explicitOrderBy.length&&e.explicitOrderBy[0].field.isKeyField())}function cp(e){return null!==e.collectionGroup}function dp(e){const t=sd(e);if(null===t.ce){t.ce=[];const e=new Set;for(const a of t.explicitOrderBy)t.ce.push(a),e.add(a.field.canonicalString());const n=t.explicitOrderBy.length>0?t.explicitOrderBy[t.explicitOrderBy.length-1].dir:"asc",r=function(e){let t=new Jd(Nd.comparator);return e.filters.forEach((e=>{e.getFlattenedFilters().forEach((e=>{e.isInequality()&&(t=t.add(e.field))}))})),t}(t);r.forEach((r=>{e.has(r.canonicalString())||r.isKeyField()||t.ce.push(new Oh(r,n))})),e.has(Nd.keyField().canonicalString())||t.ce.push(new Oh(Nd.keyField(),n))}return t.ce}function hp(e){const t=sd(e);return t.le||(t.le=pp(t,dp(e))),t.le}function pp(e,t){if("F"===e.limitType)return np(e.path,e.collectionGroup,t,e.filters,e.limit,e.startAt,e.endAt);{t=t.map((e=>{const t="desc"===e.dir?"asc":"desc";return new Oh(e.field,t)}));const n=e.endAt?new Dh(e.endAt.position,e.endAt.inclusive):null,r=e.startAt?new Dh(e.startAt.position,e.startAt.inclusive):null;return np(e.path,e.collectionGroup,t,e.filters,e.limit,n,r)}}function fp(e,t,n){return new ip(e.path,e.collectionGroup,e.explicitOrderBy.slice(),e.filters.slice(),t,n,e.startAt,e.endAt)}function mp(e,t){return ap(hp(e),hp(t))&&e.limitType===t.limitType}function gp(e){return`${rp(hp(e))}|lt:${e.limitType}`}function yp(e){return`Query(target=${function(e){let t=e.path.canonicalString();return null!==e.collectionGroup&&(t+=" collectionGroup="+e.collectionGroup),e.filters.length>0&&(t+=`, filters: [${e.filters.map((e=>Hh(e))).join(", ")}]`),Bd(e.limit)||(t+=", limit: "+e.limit),e.orderBy.length>0&&(t+=`, orderBy: [${e.orderBy.map((e=>function(e){return`${e.field.canonicalString()} (${e.dir})`}(e))).join(", ")}]`),e.startAt&&(t+=", startAt: ",t+=e.startAt.inclusive?"b:":"a:",t+=e.startAt.position.map((e=>xh(e))).join(",")),e.endAt&&(t+=", endAt: ",t+=e.endAt.inclusive?"a:":"b:",t+=e.endAt.position.map((e=>xh(e))).join(",")),`Target(${t})`}(hp(e))}; limitType=${e.limitType})`}function bp(e,t){return t.isFoundDocument()&&function(e,t){const n=t.key.path;return null!==e.collectionGroup?t.key.hasCollectionId(e.collectionGroup)&&e.path.isPrefixOf(n):Cd.isDocumentKey(e.path)?e.path.isEqual(n):e.path.isImmediateParentOf(n)}(e,t)&&function(e,t){for(const n of dp(e))if(!n.field.isKeyField()&&null===t.data.field(n.field))return!1;return!0}(e,t)&&function(e,t){for(const n of e.filters)if(!n.matches(t))return!1;return!0}(e,t)&&function(e,t){return!(e.startAt&&!function(e,t,n){const r=Mh(e,t,n);return e.inclusive?r<=0:r<0}(e.startAt,dp(e),t))&&!(e.endAt&&!function(e,t,n){const r=Mh(e,t,n);return e.inclusive?r>=0:r>0}(e.endAt,dp(e),t))}(e,t)}function vp(e){return e.collectionGroup||(e.path.length%2==1?e.path.lastSegment():e.path.get(e.path.length-2))}function xp(e){return(t,n)=>{let r=!1;for(const a of dp(e)){const e=wp(a,t,n);if(0!==e)return e;r=r||a.field.isKeyField()}return 0}}function wp(e,t,n){const r=e.field.isKeyField()?Cd.comparator(t.key,n.key):function(e,t,n){const r=t.data.field(e),a=n.data.field(e);return null!==r&&null!==a?yh(r,a):rd()}(e.field,t,n);switch(e.dir){case"asc":return r;case"desc":return-1*r;default:return rd()}}class kp{constructor(e,t){this.mapKeyFn=e,this.equalsFn=t,this.inner={},this.innerSize=0}get(e){const t=this.mapKeyFn(e),n=this.inner[t];if(void 0!==n)for(const[r,a]of n)if(this.equalsFn(r,e))return a}has(e){return void 0!==this.get(e)}set(e,t){const n=this.mapKeyFn(e),r=this.inner[n];if(void 0===r)return this.inner[n]=[[e,t]],void this.innerSize++;for(let a=0;a<r.length;a++)if(this.equalsFn(r[a][0],e))return void(r[a]=[e,t]);r.push([e,t]),this.innerSize++}delete(e){const t=this.mapKeyFn(e),n=this.inner[t];if(void 0===n)return!1;for(let r=0;r<n.length;r++)if(this.equalsFn(n[r][0],e))return 1===n.length?delete this.inner[t]:n.splice(r,1),this.innerSize--,!0;return!1}forEach(e){Kd(this.inner,((t,n)=>{for(const[r,a]of n)e(r,a)}))}isEmpty(){return Yd(this.inner)}size(){return this.innerSize}}const Sp=new Xd(Cd.comparator);function Ip(){return Sp}const Tp=new Xd(Cd.comparator);function Np(){let e=Tp;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const a of n)e=e.insert(a.key,a);return e}function Cp(e){let t=Tp;return e.forEach(((e,n)=>t=t.insert(e,n.overlayedDocument))),t}function Ap(){return _p()}function Ep(){return _p()}function _p(){return new kp((e=>e.toString()),((e,t)=>e.isEqual(t)))}const $p=new Xd(Cd.comparator),Rp=new Jd(Cd.comparator);function Dp(){let e=Rp;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const a of n)e=e.add(a);return e}const Mp=new Jd(vd);function Fp(){return Mp}function Op(e,t){if(e.useProto3Json){if(isNaN(t))return{doubleValue:"NaN"};if(t===1/0)return{doubleValue:"Infinity"};if(t===-1/0)return{doubleValue:"-Infinity"}}return{doubleValue:Vd(t)?"-0":t}}function Pp(e){return{integerValue:""+e}}function Lp(e,t){return Wd(t)?Pp(t):Op(e,t)}class zp{constructor(){this._=void 0}}function Bp(e,t,n){return e instanceof Up?function(e,t){const n={fields:{__type__:{stringValue:"server_timestamp"},__local_write_time__:{timestampValue:{seconds:e.seconds,nanos:e.nanoseconds}}}};return t&&lh(t)&&(t=uh(t)),t&&(n.fields.__previous_value__=t),{mapValue:n}}(n,t):e instanceof jp?Gp(e,t):e instanceof Hp?qp(e,t):function(e,t){const n=Wp(e,t),r=Yp(n)+Yp(e.Pe);return kh(n)&&kh(e.Pe)?Pp(r):Op(e.serializer,r)}(e,t)}function Vp(e,t,n){return e instanceof jp?Gp(e,t):e instanceof Hp?qp(e,t):n}function Wp(e,t){return e instanceof Kp?function(e){return kh(e)||function(e){return!!e&&"doubleValue"in e}(e)}(t)?t:{integerValue:0}:null}class Up extends zp{}class jp extends zp{constructor(e){super(),this.elements=e}}function Gp(e,t){const n=Xp(t);for(const r of e.elements)n.some((e=>mh(e,r)))||n.push(r);return{arrayValue:{values:n}}}class Hp extends zp{constructor(e){super(),this.elements=e}}function qp(e,t){let n=Xp(t);for(const r of e.elements)n=n.filter((e=>!mh(e,r)));return{arrayValue:{values:n}}}class Kp extends zp{constructor(e,t){super(),this.serializer=e,this.Pe=t}}function Yp(e){return ih(e.integerValue||e.doubleValue)}function Xp(e){return Sh(e)&&e.arrayValue.values?e.arrayValue.values.slice():[]}class Qp{constructor(e,t){this.version=e,this.transformResults=t}}class Zp{constructor(e,t){this.updateTime=e,this.exists=t}static none(){return new Zp}static exists(e){return new Zp(void 0,e)}static updateTime(e){return new Zp(e)}get isNone(){return void 0===this.updateTime&&void 0===this.exists}isEqual(e){return this.exists===e.exists&&(this.updateTime?!!e.updateTime&&this.updateTime.isEqual(e.updateTime):!e.updateTime)}}function Jp(e,t){return void 0!==e.updateTime?t.isFoundDocument()&&t.version.isEqual(e.updateTime):void 0===e.exists||e.exists===t.isFoundDocument()}class ef{}function tf(e,t){if(!e.hasLocalMutations||t&&0===t.fields.length)return null;if(null===t)return e.isNoDocument()?new hf(e.key,Zp.none()):new of(e.key,e.data,Zp.none());{const n=e.data,r=_h.empty();let a=new Jd(Nd.comparator);for(let e of t.fields)if(!a.has(e)){let t=n.field(e);null===t&&e.length>1&&(e=e.popLast(),t=n.field(e)),null===t?r.delete(e):r.set(e,t),a=a.add(e)}return new lf(e.key,r,new th(a.toArray()),Zp.none())}}function nf(e,t,n){e instanceof of?function(e,t,n){const r=e.value.clone(),a=cf(e.fieldTransforms,t,n.transformResults);r.setAll(a),t.convertToFoundDocument(n.version,r).setHasCommittedMutations()}(e,t,n):e instanceof lf?function(e,t,n){if(!Jp(e.precondition,t))return void t.convertToUnknownDocument(n.version);const r=cf(e.fieldTransforms,t,n.transformResults),a=t.data;a.setAll(uf(e)),a.setAll(r),t.convertToFoundDocument(n.version,a).setHasCommittedMutations()}(e,t,n):function(e,t,n){t.convertToNoDocument(n.version).setHasCommittedMutations()}(0,t,n)}function rf(e,t,n,r){return e instanceof of?function(e,t,n,r){if(!Jp(e.precondition,t))return n;const a=e.value.clone(),s=df(e.fieldTransforms,r,t);return a.setAll(s),t.convertToFoundDocument(t.version,a).setHasLocalMutations(),null}(e,t,n,r):e instanceof lf?function(e,t,n,r){if(!Jp(e.precondition,t))return n;const a=df(e.fieldTransforms,r,t),s=t.data;return s.setAll(uf(e)),s.setAll(a),t.convertToFoundDocument(t.version,s).setHasLocalMutations(),null===n?null:n.unionWith(e.fieldMask.fields).unionWith(e.fieldTransforms.map((e=>e.field)))}(e,t,n,r):function(e,t,n){return Jp(e.precondition,t)?(t.convertToNoDocument(t.version).setHasLocalMutations(),null):n}(e,t,n)}function af(e,t){let n=null;for(const r of e.fieldTransforms){const e=t.data.field(r.field),a=Wp(r.transform,e||null);null!=a&&(null===n&&(n=_h.empty()),n.set(r.field,a))}return n||null}function sf(e,t){return e.type===t.type&&!!e.key.isEqual(t.key)&&!!e.precondition.isEqual(t.precondition)&&!!function(e,t){return void 0===e&&void 0===t||!(!e||!t)&&xd(e,t,((e,t)=>function(e,t){return e.field.isEqual(t.field)&&function(e,t){return e instanceof jp&&t instanceof jp||e instanceof Hp&&t instanceof Hp?xd(e.elements,t.elements,mh):e instanceof Kp&&t instanceof Kp?mh(e.Pe,t.Pe):e instanceof Up&&t instanceof Up}(e.transform,t.transform)}(e,t)))}(e.fieldTransforms,t.fieldTransforms)&&(0===e.type?e.value.isEqual(t.value):1!==e.type||e.data.isEqual(t.data)&&e.fieldMask.isEqual(t.fieldMask))}class of extends ef{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];super(),this.key=e,this.value=t,this.precondition=n,this.fieldTransforms=r,this.type=0}getFieldMask(){return null}}class lf extends ef{constructor(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[];super(),this.key=e,this.data=t,this.fieldMask=n,this.precondition=r,this.fieldTransforms=a,this.type=1}getFieldMask(){return this.fieldMask}}function uf(e){const t=new Map;return e.fieldMask.fields.forEach((n=>{if(!n.isEmpty()){const r=e.data.field(n);t.set(n,r)}})),t}function cf(e,t,n){const r=new Map;ad(e.length===n.length);for(let a=0;a<n.length;a++){const s=e[a],i=s.transform,o=t.data.field(s.field);r.set(s.field,Vp(i,o,n[a]))}return r}function df(e,t,n){const r=new Map;for(const a of e){const e=a.transform,s=n.data.field(a.field);r.set(a.field,Bp(e,s,t))}return r}class hf extends ef{constructor(e,t){super(),this.key=e,this.precondition=t,this.type=2,this.fieldTransforms=[]}getFieldMask(){return null}}class pf extends ef{constructor(e,t){super(),this.key=e,this.precondition=t,this.type=3,this.fieldTransforms=[]}getFieldMask(){return null}}class ff{constructor(e,t,n,r){this.batchId=e,this.localWriteTime=t,this.baseMutations=n,this.mutations=r}applyToRemoteDocument(e,t){const n=t.mutationResults;for(let r=0;r<this.mutations.length;r++){const t=this.mutations[r];t.key.isEqual(e.key)&&nf(t,e,n[r])}}applyToLocalView(e,t){for(const n of this.baseMutations)n.key.isEqual(e.key)&&(t=rf(n,e,t,this.localWriteTime));for(const n of this.mutations)n.key.isEqual(e.key)&&(t=rf(n,e,t,this.localWriteTime));return t}applyToLocalDocumentSet(e,t){const n=Ep();return this.mutations.forEach((r=>{const a=e.get(r.key),s=a.overlayedDocument;let i=this.applyToLocalView(s,a.mutatedFields);i=t.has(r.key)?null:i;const o=tf(s,i);null!==o&&n.set(r.key,o),s.isValidDocument()||s.convertToNoDocument(kd.min())})),n}keys(){return this.mutations.reduce(((e,t)=>e.add(t.key)),Dp())}isEqual(e){return this.batchId===e.batchId&&xd(this.mutations,e.mutations,((e,t)=>sf(e,t)))&&xd(this.baseMutations,e.baseMutations,((e,t)=>sf(e,t)))}}class mf{constructor(e,t,n,r){this.batch=e,this.commitVersion=t,this.mutationResults=n,this.docVersions=r}static from(e,t,n){ad(e.mutations.length===n.length);let r=$p;const a=e.mutations;for(let s=0;s<a.length;s++)r=r.insert(a[s].key,n[s].version);return new mf(e,t,n,r)}}class gf{constructor(e,t){this.largestBatchId=e,this.mutation=t}getKey(){return this.mutation.key}isEqual(e){return null!==e&&this.mutation===e.mutation}toString(){return`Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`}}class yf{constructor(e,t){this.count=e,this.unchangedNames=t}}var bf,vf;function xf(e){switch(e){default:return rd();case id.CANCELLED:case id.UNKNOWN:case id.DEADLINE_EXCEEDED:case id.RESOURCE_EXHAUSTED:case id.INTERNAL:case id.UNAVAILABLE:case id.UNAUTHENTICATED:return!1;case id.INVALID_ARGUMENT:case id.NOT_FOUND:case id.ALREADY_EXISTS:case id.PERMISSION_DENIED:case id.FAILED_PRECONDITION:case id.ABORTED:case id.OUT_OF_RANGE:case id.UNIMPLEMENTED:case id.DATA_LOSS:return!0}}function wf(e){if(void 0===e)return ed("GRPC error has no .code"),id.UNKNOWN;switch(e){case bf.OK:return id.OK;case bf.CANCELLED:return id.CANCELLED;case bf.UNKNOWN:return id.UNKNOWN;case bf.DEADLINE_EXCEEDED:return id.DEADLINE_EXCEEDED;case bf.RESOURCE_EXHAUSTED:return id.RESOURCE_EXHAUSTED;case bf.INTERNAL:return id.INTERNAL;case bf.UNAVAILABLE:return id.UNAVAILABLE;case bf.UNAUTHENTICATED:return id.UNAUTHENTICATED;case bf.INVALID_ARGUMENT:return id.INVALID_ARGUMENT;case bf.NOT_FOUND:return id.NOT_FOUND;case bf.ALREADY_EXISTS:return id.ALREADY_EXISTS;case bf.PERMISSION_DENIED:return id.PERMISSION_DENIED;case bf.FAILED_PRECONDITION:return id.FAILED_PRECONDITION;case bf.ABORTED:return id.ABORTED;case bf.OUT_OF_RANGE:return id.OUT_OF_RANGE;case bf.UNIMPLEMENTED:return id.UNIMPLEMENTED;case bf.DATA_LOSS:return id.DATA_LOSS;default:return rd()}}(vf=bf||(bf={}))[vf.OK=0]="OK",vf[vf.CANCELLED=1]="CANCELLED",vf[vf.UNKNOWN=2]="UNKNOWN",vf[vf.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",vf[vf.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",vf[vf.NOT_FOUND=5]="NOT_FOUND",vf[vf.ALREADY_EXISTS=6]="ALREADY_EXISTS",vf[vf.PERMISSION_DENIED=7]="PERMISSION_DENIED",vf[vf.UNAUTHENTICATED=16]="UNAUTHENTICATED",vf[vf.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",vf[vf.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",vf[vf.ABORTED=10]="ABORTED",vf[vf.OUT_OF_RANGE=11]="OUT_OF_RANGE",vf[vf.UNIMPLEMENTED=12]="UNIMPLEMENTED",vf[vf.INTERNAL=13]="INTERNAL",vf[vf.UNAVAILABLE=14]="UNAVAILABLE",vf[vf.DATA_LOSS=15]="DATA_LOSS";let kf=null;function Sf(){return new TextEncoder}const If=new Dc([4294967295,4294967295],0);function Tf(e){const t=Sf().encode(e),n=new Mc;return n.update(t),new Uint8Array(n.digest())}function Nf(e){const t=new DataView(e.buffer),n=t.getUint32(0,!0),r=t.getUint32(4,!0),a=t.getUint32(8,!0),s=t.getUint32(12,!0);return[new Dc([n,r],0),new Dc([a,s],0)]}class Cf{constructor(e,t,n){if(this.bitmap=e,this.padding=t,this.hashCount=n,t<0||t>=8)throw new Af(`Invalid padding: ${t}`);if(n<0)throw new Af(`Invalid hash count: ${n}`);if(e.length>0&&0===this.hashCount)throw new Af(`Invalid hash count: ${n}`);if(0===e.length&&0!==t)throw new Af(`Invalid padding when bitmap length is 0: ${t}`);this.Ie=8*e.length-t,this.Te=Dc.fromNumber(this.Ie)}Ee(e,t,n){let r=e.add(t.multiply(Dc.fromNumber(n)));return 1===r.compare(If)&&(r=new Dc([r.getBits(0),r.getBits(1)],0)),r.modulo(this.Te).toNumber()}de(e){return 0!=(this.bitmap[Math.floor(e/8)]&1<<e%8)}mightContain(e){if(0===this.Ie)return!1;const t=Tf(e),[n,r]=Nf(t);for(let a=0;a<this.hashCount;a++){const e=this.Ee(n,r,a);if(!this.de(e))return!1}return!0}static create(e,t,n){const r=e%8==0?0:8-e%8,a=new Uint8Array(Math.ceil(e/8)),s=new Cf(a,r,t);return n.forEach((e=>s.insert(e))),s}insert(e){if(0===this.Ie)return;const t=Tf(e),[n,r]=Nf(t);for(let a=0;a<this.hashCount;a++){const e=this.Ee(n,r,a);this.Ae(e)}}Ae(e){const t=Math.floor(e/8),n=e%8;this.bitmap[t]|=1<<n}}class Af extends Error{constructor(){super(...arguments),this.name="BloomFilterError"}}class Ef{constructor(e,t,n,r,a){this.snapshotVersion=e,this.targetChanges=t,this.targetMismatches=n,this.documentUpdates=r,this.resolvedLimboDocuments=a}static createSynthesizedRemoteEventForCurrentChange(e,t,n){const r=new Map;return r.set(e,_f.createSynthesizedTargetChangeForCurrentChange(e,t,n)),new Ef(kd.min(),r,new Xd(vd),Ip(),Dp())}}class _f{constructor(e,t,n,r,a){this.resumeToken=e,this.current=t,this.addedDocuments=n,this.modifiedDocuments=r,this.removedDocuments=a}static createSynthesizedTargetChangeForCurrentChange(e,t,n){return new _f(n,t,Dp(),Dp(),Dp())}}class $f{constructor(e,t,n,r){this.Re=e,this.removedTargetIds=t,this.key=n,this.Ve=r}}class Rf{constructor(e,t){this.targetId=e,this.me=t}}class Df{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:rh.EMPTY_BYTE_STRING,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;this.state=e,this.targetIds=t,this.resumeToken=n,this.cause=r}}class Mf{constructor(){this.fe=0,this.ge=Pf(),this.pe=rh.EMPTY_BYTE_STRING,this.ye=!1,this.we=!0}get current(){return this.ye}get resumeToken(){return this.pe}get Se(){return 0!==this.fe}get be(){return this.we}De(e){e.approximateByteSize()>0&&(this.we=!0,this.pe=e)}ve(){let e=Dp(),t=Dp(),n=Dp();return this.ge.forEach(((r,a)=>{switch(a){case 0:e=e.add(r);break;case 2:t=t.add(r);break;case 1:n=n.add(r);break;default:rd()}})),new _f(this.pe,this.ye,e,t,n)}Ce(){this.we=!1,this.ge=Pf()}Fe(e,t){this.we=!0,this.ge=this.ge.insert(e,t)}Me(e){this.we=!0,this.ge=this.ge.remove(e)}xe(){this.fe+=1}Oe(){this.fe-=1,ad(this.fe>=0)}Ne(){this.we=!0,this.ye=!0}}class Ff{constructor(e){this.Le=e,this.Be=new Map,this.ke=Ip(),this.qe=Of(),this.Qe=new Xd(vd)}Ke(e){for(const t of e.Re)e.Ve&&e.Ve.isFoundDocument()?this.$e(t,e.Ve):this.Ue(t,e.key,e.Ve);for(const t of e.removedTargetIds)this.Ue(t,e.key,e.Ve)}We(e){this.forEachTarget(e,(t=>{const n=this.Ge(t);switch(e.state){case 0:this.ze(t)&&n.De(e.resumeToken);break;case 1:n.Oe(),n.Se||n.Ce(),n.De(e.resumeToken);break;case 2:n.Oe(),n.Se||this.removeTarget(t);break;case 3:this.ze(t)&&(n.Ne(),n.De(e.resumeToken));break;case 4:this.ze(t)&&(this.je(t),n.De(e.resumeToken));break;default:rd()}}))}forEachTarget(e,t){e.targetIds.length>0?e.targetIds.forEach(t):this.Be.forEach(((e,n)=>{this.ze(n)&&t(n)}))}He(e){const t=e.targetId,n=e.me.count,r=this.Je(t);if(r){const a=r.target;if(sp(a))if(0===n){const e=new Cd(a.path);this.Ue(t,e,Rh.newNoDocument(e,kd.min()))}else ad(1===n);else{const r=this.Ye(t);if(r!==n){const n=this.Ze(e),a=n?this.Xe(n,e,r):1;if(0!==a){this.je(t);const e=2===a?"TargetPurposeExistenceFilterMismatchBloom":"TargetPurposeExistenceFilterMismatch";this.Qe=this.Qe.insert(t,e)}null==kf||kf.et(function(e,t,n,r,a){var s,i,o,l,u,c;const d={localCacheCount:e,existenceFilterCount:t.count,databaseId:n.database,projectId:n.projectId},h=t.unchangedNames;return h&&(d.bloomFilter={applied:0===a,hashCount:null!==(s=null==h?void 0:h.hashCount)&&void 0!==s?s:0,bitmapLength:null!==(l=null===(o=null===(i=null==h?void 0:h.bits)||void 0===i?void 0:i.bitmap)||void 0===o?void 0:o.length)&&void 0!==l?l:0,padding:null!==(c=null===(u=null==h?void 0:h.bits)||void 0===u?void 0:u.padding)&&void 0!==c?c:0,mightContain:e=>{var t;return null!==(t=null==r?void 0:r.mightContain(e))&&void 0!==t&&t}}),d}(r,e.me,this.Le.tt(),n,a))}}}}Ze(e){const t=e.me.unchangedNames;if(!t||!t.bits)return null;const{bits:{bitmap:n="",padding:r=0},hashCount:a=0}=t;let s,i;try{s=oh(n).toUint8Array()}catch(e){if(e instanceof nh)return td("Decoding the base64 bloom filter in existence filter failed ("+e.message+"); ignoring the bloom filter and falling back to full re-query."),null;throw e}try{i=new Cf(s,r,a)}catch(e){return td(e instanceof Af?"BloomFilter error: ":"Applying bloom filter failed: ",e),null}return 0===i.Ie?null:i}Xe(e,t,n){return t.me.count===n-this.nt(e,t.targetId)?0:2}nt(e,t){const n=this.Le.getRemoteKeysForTarget(t);let r=0;return n.forEach((n=>{const a=this.Le.tt(),s=`projects/${a.projectId}/databases/${a.database}/documents/${n.path.canonicalString()}`;e.mightContain(s)||(this.Ue(t,n,null),r++)})),r}rt(e){const t=new Map;this.Be.forEach(((n,r)=>{const a=this.Je(r);if(a){if(n.current&&sp(a.target)){const t=new Cd(a.target.path);null!==this.ke.get(t)||this.it(r,t)||this.Ue(r,t,Rh.newNoDocument(t,e))}n.be&&(t.set(r,n.ve()),n.Ce())}}));let n=Dp();this.qe.forEach(((e,t)=>{let r=!0;t.forEachWhile((e=>{const t=this.Je(e);return!t||"TargetPurposeLimboResolution"===t.purpose||(r=!1,!1)})),r&&(n=n.add(e))})),this.ke.forEach(((t,n)=>n.setReadTime(e)));const r=new Ef(e,t,this.Qe,this.ke,n);return this.ke=Ip(),this.qe=Of(),this.Qe=new Xd(vd),r}$e(e,t){if(!this.ze(e))return;const n=this.it(e,t.key)?2:0;this.Ge(e).Fe(t.key,n),this.ke=this.ke.insert(t.key,t),this.qe=this.qe.insert(t.key,this.st(t.key).add(e))}Ue(e,t,n){if(!this.ze(e))return;const r=this.Ge(e);this.it(e,t)?r.Fe(t,1):r.Me(t),this.qe=this.qe.insert(t,this.st(t).delete(e)),n&&(this.ke=this.ke.insert(t,n))}removeTarget(e){this.Be.delete(e)}Ye(e){const t=this.Ge(e).ve();return this.Le.getRemoteKeysForTarget(e).size+t.addedDocuments.size-t.removedDocuments.size}xe(e){this.Ge(e).xe()}Ge(e){let t=this.Be.get(e);return t||(t=new Mf,this.Be.set(e,t)),t}st(e){let t=this.qe.get(e);return t||(t=new Jd(vd),this.qe=this.qe.insert(e,t)),t}ze(e){const t=null!==this.Je(e);return t||Jc("WatchChangeAggregator","Detected inactive target",e),t}Je(e){const t=this.Be.get(e);return t&&t.Se?null:this.Le.ot(e)}je(e){this.Be.set(e,new Mf),this.Le.getRemoteKeysForTarget(e).forEach((t=>{this.Ue(e,t,null)}))}it(e,t){return this.Le.getRemoteKeysForTarget(e).has(t)}}function Of(){return new Xd(Cd.comparator)}function Pf(){return new Xd(Cd.comparator)}const Lf={asc:"ASCENDING",desc:"DESCENDING"},zf={"<":"LESS_THAN","<=":"LESS_THAN_OR_EQUAL",">":"GREATER_THAN",">=":"GREATER_THAN_OR_EQUAL","==":"EQUAL","!=":"NOT_EQUAL","array-contains":"ARRAY_CONTAINS",in:"IN","not-in":"NOT_IN","array-contains-any":"ARRAY_CONTAINS_ANY"},Bf={and:"AND",or:"OR"};class Vf{constructor(e,t){this.databaseId=e,this.useProto3Json=t}}function Wf(e,t){return e.useProto3Json||Bd(t)?t:{value:t}}function Uf(e,t){return e.useProto3Json?`${new Date(1e3*t.seconds).toISOString().replace(/\.\d*/,"").replace("Z","")}.${("000000000"+t.nanoseconds).slice(-9)}Z`:{seconds:""+t.seconds,nanos:t.nanoseconds}}function jf(e,t){return e.useProto3Json?t.toBase64():t.toUint8Array()}function Gf(e,t){return Uf(e,t.toTimestamp())}function Hf(e){return ad(!!e),kd.fromTimestamp(function(e){const t=sh(e);return new wd(t.seconds,t.nanos)}(e))}function qf(e,t){return Kf(e,t).canonicalString()}function Kf(e,t){const n=function(e){return new Id(["projects",e.projectId,"databases",e.database])}(e).child("documents");return void 0===t?n:n.child(t)}function Yf(e){const t=Id.fromString(e);return ad(mm(t)),t}function Xf(e,t){return qf(e.databaseId,t.path)}function Qf(e,t){const n=Yf(t);if(n.get(1)!==e.databaseId.projectId)throw new od(id.INVALID_ARGUMENT,"Tried to deserialize key from different project: "+n.get(1)+" vs "+e.databaseId.projectId);if(n.get(3)!==e.databaseId.database)throw new od(id.INVALID_ARGUMENT,"Tried to deserialize key from different database: "+n.get(3)+" vs "+e.databaseId.database);return new Cd(tm(n))}function Zf(e,t){return qf(e.databaseId,t)}function Jf(e){const t=Yf(e);return 4===t.length?Id.emptyPath():tm(t)}function em(e){return new Id(["projects",e.databaseId.projectId,"databases",e.databaseId.database]).canonicalString()}function tm(e){return ad(e.length>4&&"documents"===e.get(4)),e.popFirst(5)}function nm(e,t,n){return{name:Xf(e,t),fields:n.value.mapValue.fields}}function rm(e,t){let n;if(t instanceof of)n={update:nm(e,t.key,t.value)};else if(t instanceof hf)n={delete:Xf(e,t.key)};else if(t instanceof lf)n={update:nm(e,t.key,t.data),updateMask:fm(t.fieldMask)};else{if(!(t instanceof pf))return rd();n={verify:Xf(e,t.key)}}return t.fieldTransforms.length>0&&(n.updateTransforms=t.fieldTransforms.map((e=>function(e,t){const n=t.transform;if(n instanceof Up)return{fieldPath:t.field.canonicalString(),setToServerValue:"REQUEST_TIME"};if(n instanceof jp)return{fieldPath:t.field.canonicalString(),appendMissingElements:{values:n.elements}};if(n instanceof Hp)return{fieldPath:t.field.canonicalString(),removeAllFromArray:{values:n.elements}};if(n instanceof Kp)return{fieldPath:t.field.canonicalString(),increment:n.Pe};throw rd()}(0,e)))),t.precondition.isNone||(n.currentDocument=function(e,t){return void 0!==t.updateTime?{updateTime:Gf(e,t.updateTime)}:void 0!==t.exists?{exists:t.exists}:rd()}(e,t.precondition)),n}function am(e,t){return{documents:[Zf(e,t.path)]}}function sm(e,t){const n={structuredQuery:{}},r=t.path;let a;null!==t.collectionGroup?(a=r,n.structuredQuery.from=[{collectionId:t.collectionGroup,allDescendants:!0}]):(a=r.popLast(),n.structuredQuery.from=[{collectionId:r.lastSegment()}]),n.parent=Zf(e,a);const s=function(e){if(0!==e.length)return pm(Bh.create(e,"and"))}(t.filters);s&&(n.structuredQuery.where=s);const i=function(e){if(0!==e.length)return e.map((e=>function(e){return{field:dm(e.field),direction:lm(e.dir)}}(e)))}(t.orderBy);i&&(n.structuredQuery.orderBy=i);const o=Wf(e,t.limit);return null!==o&&(n.structuredQuery.limit=o),t.startAt&&(n.structuredQuery.startAt=function(e){return{before:e.inclusive,values:e.position}}(t.startAt)),t.endAt&&(n.structuredQuery.endAt=function(e){return{before:!e.inclusive,values:e.position}}(t.endAt)),{_t:n,parent:a}}function im(e){let t=Jf(e.parent);const n=e.structuredQuery,r=n.from?n.from.length:0;let a=null;if(r>0){ad(1===r);const e=n.from[0];e.allDescendants?a=e.collectionId:t=t.child(e.collectionId)}let s=[];n.where&&(s=function(e){const t=om(e);return t instanceof Bh&&Wh(t)?t.getFilters():[t]}(n.where));let i=[];n.orderBy&&(i=function(e){return e.map((e=>function(e){return new Oh(hm(e.field),function(e){switch(e){case"ASCENDING":return"asc";case"DESCENDING":return"desc";default:return}}(e.direction))}(e)))}(n.orderBy));let o=null;n.limit&&(o=function(e){let t;return t="object"==typeof e?e.value:e,Bd(t)?null:t}(n.limit));let l=null;n.startAt&&(l=function(e){const t=!!e.before,n=e.values||[];return new Dh(n,t)}(n.startAt));let u=null;return n.endAt&&(u=function(e){const t=!e.before,n=e.values||[];return new Dh(n,t)}(n.endAt)),op(t,a,i,s,o,"F",l,u)}function om(e){return void 0!==e.unaryFilter?function(e){switch(e.unaryFilter.op){case"IS_NAN":const t=hm(e.unaryFilter.field);return zh.create(t,"==",{doubleValue:NaN});case"IS_NULL":const n=hm(e.unaryFilter.field);return zh.create(n,"==",{nullValue:"NULL_VALUE"});case"IS_NOT_NAN":const r=hm(e.unaryFilter.field);return zh.create(r,"!=",{doubleValue:NaN});case"IS_NOT_NULL":const a=hm(e.unaryFilter.field);return zh.create(a,"!=",{nullValue:"NULL_VALUE"});default:return rd()}}(e):void 0!==e.fieldFilter?function(e){return zh.create(hm(e.fieldFilter.field),function(e){switch(e){case"EQUAL":return"==";case"NOT_EQUAL":return"!=";case"GREATER_THAN":return">";case"GREATER_THAN_OR_EQUAL":return">=";case"LESS_THAN":return"<";case"LESS_THAN_OR_EQUAL":return"<=";case"ARRAY_CONTAINS":return"array-contains";case"IN":return"in";case"NOT_IN":return"not-in";case"ARRAY_CONTAINS_ANY":return"array-contains-any";default:return rd()}}(e.fieldFilter.op),e.fieldFilter.value)}(e):void 0!==e.compositeFilter?function(e){return Bh.create(e.compositeFilter.filters.map((e=>om(e))),function(e){switch(e){case"AND":return"and";case"OR":return"or";default:return rd()}}(e.compositeFilter.op))}(e):rd()}function lm(e){return Lf[e]}function um(e){return zf[e]}function cm(e){return Bf[e]}function dm(e){return{fieldPath:e.canonicalString()}}function hm(e){return Nd.fromServerFormat(e.fieldPath)}function pm(e){return e instanceof zh?function(e){if("=="===e.op){if(Th(e.value))return{unaryFilter:{field:dm(e.field),op:"IS_NAN"}};if(Ih(e.value))return{unaryFilter:{field:dm(e.field),op:"IS_NULL"}}}else if("!="===e.op){if(Th(e.value))return{unaryFilter:{field:dm(e.field),op:"IS_NOT_NAN"}};if(Ih(e.value))return{unaryFilter:{field:dm(e.field),op:"IS_NOT_NULL"}}}return{fieldFilter:{field:dm(e.field),op:um(e.op),value:e.value}}}(e):e instanceof Bh?function(e){const t=e.getFilters().map((e=>pm(e)));return 1===t.length?t[0]:{compositeFilter:{op:cm(e.op),filters:t}}}(e):rd()}function fm(e){const t=[];return e.fields.forEach((e=>t.push(e.canonicalString()))),{fieldPaths:t}}function mm(e){return e.length>=4&&"projects"===e.get(0)&&"databases"===e.get(2)}class gm{constructor(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:kd.min(),s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:kd.min(),i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:rh.EMPTY_BYTE_STRING,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;this.target=e,this.targetId=t,this.purpose=n,this.sequenceNumber=r,this.snapshotVersion=a,this.lastLimboFreeSnapshotVersion=s,this.resumeToken=i,this.expectedCount=o}withSequenceNumber(e){return new gm(this.target,this.targetId,this.purpose,e,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,this.expectedCount)}withResumeToken(e,t){return new gm(this.target,this.targetId,this.purpose,this.sequenceNumber,t,this.lastLimboFreeSnapshotVersion,e,null)}withExpectedCount(e){return new gm(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,this.lastLimboFreeSnapshotVersion,this.resumeToken,e)}withLastLimboFreeSnapshotVersion(e){return new gm(this.target,this.targetId,this.purpose,this.sequenceNumber,this.snapshotVersion,e,this.resumeToken,this.expectedCount)}}class ym{constructor(e){this.ct=e}}function bm(e){const t=im({parent:e.parent,structuredQuery:e.structuredQuery});return"LAST"===e.limitType?fp(t,t.limit,"L"):t}class vm{constructor(){}It(e,t){this.Tt(e,t),t.Et()}Tt(e,t){if("nullValue"in e)this.dt(t,5);else if("booleanValue"in e)this.dt(t,10),t.At(e.booleanValue?1:0);else if("integerValue"in e)this.dt(t,15),t.At(ih(e.integerValue));else if("doubleValue"in e){const n=ih(e.doubleValue);isNaN(n)?this.dt(t,13):(this.dt(t,15),Vd(n)?t.At(0):t.At(n))}else if("timestampValue"in e){let n=e.timestampValue;this.dt(t,20),"string"==typeof n&&(n=sh(n)),t.Rt(`${n.seconds||""}`),t.At(n.nanos||0)}else if("stringValue"in e)this.Vt(e.stringValue,t),this.ft(t);else if("bytesValue"in e)this.dt(t,30),t.gt(oh(e.bytesValue)),this.ft(t);else if("referenceValue"in e)this.yt(e.referenceValue,t);else if("geoPointValue"in e){const n=e.geoPointValue;this.dt(t,45),t.At(n.latitude||0),t.At(n.longitude||0)}else"mapValue"in e?Eh(e)?this.dt(t,Number.MAX_SAFE_INTEGER):Ch(e)?this.wt(e.mapValue,t):(this.St(e.mapValue,t),this.ft(t)):"arrayValue"in e?(this.bt(e.arrayValue,t),this.ft(t)):rd()}Vt(e,t){this.dt(t,25),this.Dt(e,t)}Dt(e,t){t.Rt(e)}St(e,t){const n=e.fields||{};this.dt(t,55);for(const r of Object.keys(n))this.Vt(r,t),this.Tt(n[r],t)}wt(e,t){var n,r;const a=e.fields||{};this.dt(t,53);const s="value",i=(null===(r=null===(n=a[s].arrayValue)||void 0===n?void 0:n.values)||void 0===r?void 0:r.length)||0;this.dt(t,15),t.At(ih(i)),this.Vt(s,t),this.Tt(a[s],t)}bt(e,t){const n=e.values||[];this.dt(t,50);for(const r of n)this.Tt(r,t)}yt(e,t){this.dt(t,37),Cd.fromName(e).path.forEach((e=>{this.dt(t,60),this.Dt(e,t)}))}dt(e,t){e.At(t)}ft(e){e.At(2)}}vm.vt=new vm;class xm{constructor(){this.un=new wm}addToCollectionParentIndex(e,t){return this.un.add(t),Od.resolve()}getCollectionParents(e,t){return Od.resolve(this.un.getEntries(t))}addFieldIndex(e,t){return Od.resolve()}deleteFieldIndex(e,t){return Od.resolve()}deleteAllFieldIndexes(e){return Od.resolve()}createTargetIndexes(e,t){return Od.resolve()}getDocumentsMatchingTarget(e,t){return Od.resolve(null)}getIndexType(e,t){return Od.resolve(0)}getFieldIndexes(e,t){return Od.resolve([])}getNextCollectionGroupToUpdate(e){return Od.resolve(null)}getMinOffset(e,t){return Od.resolve($d.min())}getMinOffsetFromCollectionGroup(e,t){return Od.resolve($d.min())}updateCollectionGroup(e,t,n){return Od.resolve()}updateIndexEntries(e,t){return Od.resolve()}}class wm{constructor(){this.index={}}add(e){const t=e.lastSegment(),n=e.popLast(),r=this.index[t]||new Jd(Id.comparator),a=!r.has(n);return this.index[t]=r.add(n),a}has(e){const t=e.lastSegment(),n=e.popLast(),r=this.index[t];return r&&r.has(n)}getEntries(e){return(this.index[e]||new Jd(Id.comparator)).toArray()}}new Uint8Array(0);class km{constructor(e,t,n){this.cacheSizeCollectionThreshold=e,this.percentileToCollect=t,this.maximumSequenceNumbersToCollect=n}static withCacheSize(e){return new km(e,km.DEFAULT_COLLECTION_PERCENTILE,km.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT)}}km.DEFAULT_COLLECTION_PERCENTILE=10,km.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT=1e3,km.DEFAULT=new km(41943040,km.DEFAULT_COLLECTION_PERCENTILE,km.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT),km.DISABLED=new km(-1,0,0);class Sm{constructor(e){this.Ln=e}next(){return this.Ln+=2,this.Ln}static Bn(){return new Sm(0)}static kn(){return new Sm(-1)}}class Im{constructor(){this.changes=new kp((e=>e.toString()),((e,t)=>e.isEqual(t))),this.changesApplied=!1}addEntry(e){this.assertNotApplied(),this.changes.set(e.key,e)}removeEntry(e,t){this.assertNotApplied(),this.changes.set(e,Rh.newInvalidDocument(e).setReadTime(t))}getEntry(e,t){this.assertNotApplied();const n=this.changes.get(t);return void 0!==n?Od.resolve(n):this.getFromCache(e,t)}getEntries(e,t){return this.getAllFromCache(e,t)}apply(e){return this.assertNotApplied(),this.changesApplied=!0,this.applyChanges(e)}assertNotApplied(){}}class Tm{constructor(e,t){this.overlayedDocument=e,this.mutatedFields=t}}class Nm{constructor(e,t,n,r){this.remoteDocumentCache=e,this.mutationQueue=t,this.documentOverlayCache=n,this.indexManager=r}getDocument(e,t){let n=null;return this.documentOverlayCache.getOverlay(e,t).next((r=>(n=r,this.remoteDocumentCache.getEntry(e,t)))).next((e=>(null!==n&&rf(n.mutation,e,th.empty(),wd.now()),e)))}getDocuments(e,t){return this.remoteDocumentCache.getEntries(e,t).next((t=>this.getLocalViewOfDocuments(e,t,Dp()).next((()=>t))))}getLocalViewOfDocuments(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Dp();const r=Ap();return this.populateOverlays(e,r,t).next((()=>this.computeViews(e,t,r,n).next((e=>{let t=Np();return e.forEach(((e,n)=>{t=t.insert(e,n.overlayedDocument)})),t}))))}getOverlayedDocuments(e,t){const n=Ap();return this.populateOverlays(e,n,t).next((()=>this.computeViews(e,t,n,Dp())))}populateOverlays(e,t,n){const r=[];return n.forEach((e=>{t.has(e)||r.push(e)})),this.documentOverlayCache.getOverlays(e,r).next((e=>{e.forEach(((e,n)=>{t.set(e,n)}))}))}computeViews(e,t,n,r){let a=Ip();const s=_p(),i=_p();return t.forEach(((e,t)=>{const i=n.get(t.key);r.has(t.key)&&(void 0===i||i.mutation instanceof lf)?a=a.insert(t.key,t):void 0!==i?(s.set(t.key,i.mutation.getFieldMask()),rf(i.mutation,t,i.mutation.getFieldMask(),wd.now())):s.set(t.key,th.empty())})),this.recalculateAndSaveOverlays(e,a).next((e=>(e.forEach(((e,t)=>s.set(e,t))),t.forEach(((e,t)=>{var n;return i.set(e,new Tm(t,null!==(n=s.get(e))&&void 0!==n?n:null))})),i)))}recalculateAndSaveOverlays(e,t){const n=_p();let r=new Xd(((e,t)=>e-t)),a=Dp();return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e,t).next((e=>{for(const a of e)a.keys().forEach((e=>{const s=t.get(e);if(null===s)return;let i=n.get(e)||th.empty();i=a.applyToLocalView(s,i),n.set(e,i);const o=(r.get(a.batchId)||Dp()).add(e);r=r.insert(a.batchId,o)}))})).next((()=>{const s=[],i=r.getReverseIterator();for(;i.hasNext();){const r=i.getNext(),o=r.key,l=r.value,u=Ep();l.forEach((e=>{if(!a.has(e)){const r=tf(t.get(e),n.get(e));null!==r&&u.set(e,r),a=a.add(e)}})),s.push(this.documentOverlayCache.saveOverlays(e,o,u))}return Od.waitFor(s)})).next((()=>n))}recalculateAndSaveOverlaysForDocumentKeys(e,t){return this.remoteDocumentCache.getEntries(e,t).next((t=>this.recalculateAndSaveOverlays(e,t)))}getDocumentsMatchingQuery(e,t,n,r){return function(e){return Cd.isDocumentKey(e.path)&&null===e.collectionGroup&&0===e.filters.length}(t)?this.getDocumentsMatchingDocumentQuery(e,t.path):cp(t)?this.getDocumentsMatchingCollectionGroupQuery(e,t,n,r):this.getDocumentsMatchingCollectionQuery(e,t,n,r)}getNextDocuments(e,t,n,r){return this.remoteDocumentCache.getAllFromCollectionGroup(e,t,n,r).next((a=>{const s=r-a.size>0?this.documentOverlayCache.getOverlaysForCollectionGroup(e,t,n.largestBatchId,r-a.size):Od.resolve(Ap());let i=-1,o=a;return s.next((t=>Od.forEach(t,((t,n)=>(i<n.largestBatchId&&(i=n.largestBatchId),a.get(t)?Od.resolve():this.remoteDocumentCache.getEntry(e,t).next((e=>{o=o.insert(t,e)}))))).next((()=>this.populateOverlays(e,t,a))).next((()=>this.computeViews(e,o,t,Dp()))).next((e=>({batchId:i,changes:Cp(e)})))))}))}getDocumentsMatchingDocumentQuery(e,t){return this.getDocument(e,new Cd(t)).next((e=>{let t=Np();return e.isFoundDocument()&&(t=t.insert(e.key,e)),t}))}getDocumentsMatchingCollectionGroupQuery(e,t,n,r){const a=t.collectionGroup;let s=Np();return this.indexManager.getCollectionParents(e,a).next((i=>Od.forEach(i,(i=>{const o=function(e,t){return new ip(t,null,e.explicitOrderBy.slice(),e.filters.slice(),e.limit,e.limitType,e.startAt,e.endAt)}(t,i.child(a));return this.getDocumentsMatchingCollectionQuery(e,o,n,r).next((e=>{e.forEach(((e,t)=>{s=s.insert(e,t)}))}))})).next((()=>s))))}getDocumentsMatchingCollectionQuery(e,t,n,r){let a;return this.documentOverlayCache.getOverlaysForCollection(e,t.path,n.largestBatchId).next((s=>(a=s,this.remoteDocumentCache.getDocumentsMatchingQuery(e,t,n,a,r)))).next((e=>{a.forEach(((t,n)=>{const r=n.getKey();null===e.get(r)&&(e=e.insert(r,Rh.newInvalidDocument(r)))}));let n=Np();return e.forEach(((e,r)=>{const s=a.get(e);void 0!==s&&rf(s.mutation,r,th.empty(),wd.now()),bp(t,r)&&(n=n.insert(e,r))})),n}))}}class Cm{constructor(e){this.serializer=e,this.hr=new Map,this.Pr=new Map}getBundleMetadata(e,t){return Od.resolve(this.hr.get(t))}saveBundleMetadata(e,t){return this.hr.set(t.id,function(e){return{id:e.id,version:e.version,createTime:Hf(e.createTime)}}(t)),Od.resolve()}getNamedQuery(e,t){return Od.resolve(this.Pr.get(t))}saveNamedQuery(e,t){return this.Pr.set(t.name,function(e){return{name:e.name,query:bm(e.bundledQuery),readTime:Hf(e.readTime)}}(t)),Od.resolve()}}class Am{constructor(){this.overlays=new Xd(Cd.comparator),this.Ir=new Map}getOverlay(e,t){return Od.resolve(this.overlays.get(t))}getOverlays(e,t){const n=Ap();return Od.forEach(t,(t=>this.getOverlay(e,t).next((e=>{null!==e&&n.set(t,e)})))).next((()=>n))}saveOverlays(e,t,n){return n.forEach(((n,r)=>{this.ht(e,t,r)})),Od.resolve()}removeOverlaysForBatchId(e,t,n){const r=this.Ir.get(n);return void 0!==r&&(r.forEach((e=>this.overlays=this.overlays.remove(e))),this.Ir.delete(n)),Od.resolve()}getOverlaysForCollection(e,t,n){const r=Ap(),a=t.length+1,s=new Cd(t.child("")),i=this.overlays.getIteratorFrom(s);for(;i.hasNext();){const e=i.getNext().value,s=e.getKey();if(!t.isPrefixOf(s.path))break;s.path.length===a&&e.largestBatchId>n&&r.set(e.getKey(),e)}return Od.resolve(r)}getOverlaysForCollectionGroup(e,t,n,r){let a=new Xd(((e,t)=>e-t));const s=this.overlays.getIterator();for(;s.hasNext();){const e=s.getNext().value;if(e.getKey().getCollectionGroup()===t&&e.largestBatchId>n){let t=a.get(e.largestBatchId);null===t&&(t=Ap(),a=a.insert(e.largestBatchId,t)),t.set(e.getKey(),e)}}const i=Ap(),o=a.getIterator();for(;o.hasNext()&&(o.getNext().value.forEach(((e,t)=>i.set(e,t))),!(i.size()>=r)););return Od.resolve(i)}ht(e,t,n){const r=this.overlays.get(n.key);if(null!==r){const e=this.Ir.get(r.largestBatchId).delete(n.key);this.Ir.set(r.largestBatchId,e)}this.overlays=this.overlays.insert(n.key,new gf(t,n));let a=this.Ir.get(t);void 0===a&&(a=Dp(),this.Ir.set(t,a)),this.Ir.set(t,a.add(n.key))}}class Em{constructor(){this.sessionToken=rh.EMPTY_BYTE_STRING}getSessionToken(e){return Od.resolve(this.sessionToken)}setSessionToken(e,t){return this.sessionToken=t,Od.resolve()}}class _m{constructor(){this.Tr=new Jd($m.Er),this.dr=new Jd($m.Ar)}isEmpty(){return this.Tr.isEmpty()}addReference(e,t){const n=new $m(e,t);this.Tr=this.Tr.add(n),this.dr=this.dr.add(n)}Rr(e,t){e.forEach((e=>this.addReference(e,t)))}removeReference(e,t){this.Vr(new $m(e,t))}mr(e,t){e.forEach((e=>this.removeReference(e,t)))}gr(e){const t=new Cd(new Id([])),n=new $m(t,e),r=new $m(t,e+1),a=[];return this.dr.forEachInRange([n,r],(e=>{this.Vr(e),a.push(e.key)})),a}pr(){this.Tr.forEach((e=>this.Vr(e)))}Vr(e){this.Tr=this.Tr.delete(e),this.dr=this.dr.delete(e)}yr(e){const t=new Cd(new Id([])),n=new $m(t,e),r=new $m(t,e+1);let a=Dp();return this.dr.forEachInRange([n,r],(e=>{a=a.add(e.key)})),a}containsKey(e){const t=new $m(e,0),n=this.Tr.firstAfterOrEqual(t);return null!==n&&e.isEqual(n.key)}}class $m{constructor(e,t){this.key=e,this.wr=t}static Er(e,t){return Cd.comparator(e.key,t.key)||vd(e.wr,t.wr)}static Ar(e,t){return vd(e.wr,t.wr)||Cd.comparator(e.key,t.key)}}class Rm{constructor(e,t){this.indexManager=e,this.referenceDelegate=t,this.mutationQueue=[],this.Sr=1,this.br=new Jd($m.Er)}checkEmpty(e){return Od.resolve(0===this.mutationQueue.length)}addMutationBatch(e,t,n,r){const a=this.Sr;this.Sr++,this.mutationQueue.length>0&&this.mutationQueue[this.mutationQueue.length-1];const s=new ff(a,t,n,r);this.mutationQueue.push(s);for(const i of r)this.br=this.br.add(new $m(i.key,a)),this.indexManager.addToCollectionParentIndex(e,i.key.path.popLast());return Od.resolve(s)}lookupMutationBatch(e,t){return Od.resolve(this.Dr(t))}getNextMutationBatchAfterBatchId(e,t){const n=t+1,r=this.vr(n),a=r<0?0:r;return Od.resolve(this.mutationQueue.length>a?this.mutationQueue[a]:null)}getHighestUnacknowledgedBatchId(){return Od.resolve(0===this.mutationQueue.length?-1:this.Sr-1)}getAllMutationBatches(e){return Od.resolve(this.mutationQueue.slice())}getAllMutationBatchesAffectingDocumentKey(e,t){const n=new $m(t,0),r=new $m(t,Number.POSITIVE_INFINITY),a=[];return this.br.forEachInRange([n,r],(e=>{const t=this.Dr(e.wr);a.push(t)})),Od.resolve(a)}getAllMutationBatchesAffectingDocumentKeys(e,t){let n=new Jd(vd);return t.forEach((e=>{const t=new $m(e,0),r=new $m(e,Number.POSITIVE_INFINITY);this.br.forEachInRange([t,r],(e=>{n=n.add(e.wr)}))})),Od.resolve(this.Cr(n))}getAllMutationBatchesAffectingQuery(e,t){const n=t.path,r=n.length+1;let a=n;Cd.isDocumentKey(a)||(a=a.child(""));const s=new $m(new Cd(a),0);let i=new Jd(vd);return this.br.forEachWhile((e=>{const t=e.key.path;return!!n.isPrefixOf(t)&&(t.length===r&&(i=i.add(e.wr)),!0)}),s),Od.resolve(this.Cr(i))}Cr(e){const t=[];return e.forEach((e=>{const n=this.Dr(e);null!==n&&t.push(n)})),t}removeMutationBatch(e,t){ad(0===this.Fr(t.batchId,"removed")),this.mutationQueue.shift();let n=this.br;return Od.forEach(t.mutations,(r=>{const a=new $m(r.key,t.batchId);return n=n.delete(a),this.referenceDelegate.markPotentiallyOrphaned(e,r.key)})).next((()=>{this.br=n}))}On(e){}containsKey(e,t){const n=new $m(t,0),r=this.br.firstAfterOrEqual(n);return Od.resolve(t.isEqual(r&&r.key))}performConsistencyCheck(e){return this.mutationQueue.length,Od.resolve()}Fr(e,t){return this.vr(e)}vr(e){return 0===this.mutationQueue.length?0:e-this.mutationQueue[0].batchId}Dr(e){const t=this.vr(e);return t<0||t>=this.mutationQueue.length?null:this.mutationQueue[t]}}class Dm{constructor(e){this.Mr=e,this.docs=new Xd(Cd.comparator),this.size=0}setIndexManager(e){this.indexManager=e}addEntry(e,t){const n=t.key,r=this.docs.get(n),a=r?r.size:0,s=this.Mr(t);return this.docs=this.docs.insert(n,{document:t.mutableCopy(),size:s}),this.size+=s-a,this.indexManager.addToCollectionParentIndex(e,n.path.popLast())}removeEntry(e){const t=this.docs.get(e);t&&(this.docs=this.docs.remove(e),this.size-=t.size)}getEntry(e,t){const n=this.docs.get(t);return Od.resolve(n?n.document.mutableCopy():Rh.newInvalidDocument(t))}getEntries(e,t){let n=Ip();return t.forEach((e=>{const t=this.docs.get(e);n=n.insert(e,t?t.document.mutableCopy():Rh.newInvalidDocument(e))})),Od.resolve(n)}getDocumentsMatchingQuery(e,t,n,r){let a=Ip();const s=t.path,i=new Cd(s.child("")),o=this.docs.getIteratorFrom(i);for(;o.hasNext();){const{key:e,value:{document:i}}=o.getNext();if(!s.isPrefixOf(e.path))break;e.path.length>s.length+1||Rd(_d(i),n)<=0||(r.has(i.key)||bp(t,i))&&(a=a.insert(i.key,i.mutableCopy()))}return Od.resolve(a)}getAllFromCollectionGroup(e,t,n,r){rd()}Or(e,t){return Od.forEach(this.docs,(e=>t(e)))}newChangeBuffer(e){return new Mm(this)}getSize(e){return Od.resolve(this.size)}}class Mm extends Im{constructor(e){super(),this.cr=e}applyChanges(e){const t=[];return this.changes.forEach(((n,r)=>{r.isValidDocument()?t.push(this.cr.addEntry(e,r)):this.cr.removeEntry(n)})),Od.waitFor(t)}getFromCache(e,t){return this.cr.getEntry(e,t)}getAllFromCache(e,t){return this.cr.getEntries(e,t)}}class Fm{constructor(e){this.persistence=e,this.Nr=new kp((e=>rp(e)),ap),this.lastRemoteSnapshotVersion=kd.min(),this.highestTargetId=0,this.Lr=0,this.Br=new _m,this.targetCount=0,this.kr=Sm.Bn()}forEachTarget(e,t){return this.Nr.forEach(((e,n)=>t(n))),Od.resolve()}getLastRemoteSnapshotVersion(e){return Od.resolve(this.lastRemoteSnapshotVersion)}getHighestSequenceNumber(e){return Od.resolve(this.Lr)}allocateTargetId(e){return this.highestTargetId=this.kr.next(),Od.resolve(this.highestTargetId)}setTargetsMetadata(e,t,n){return n&&(this.lastRemoteSnapshotVersion=n),t>this.Lr&&(this.Lr=t),Od.resolve()}Kn(e){this.Nr.set(e.target,e);const t=e.targetId;t>this.highestTargetId&&(this.kr=new Sm(t),this.highestTargetId=t),e.sequenceNumber>this.Lr&&(this.Lr=e.sequenceNumber)}addTargetData(e,t){return this.Kn(t),this.targetCount+=1,Od.resolve()}updateTargetData(e,t){return this.Kn(t),Od.resolve()}removeTargetData(e,t){return this.Nr.delete(t.target),this.Br.gr(t.targetId),this.targetCount-=1,Od.resolve()}removeTargets(e,t,n){let r=0;const a=[];return this.Nr.forEach(((s,i)=>{i.sequenceNumber<=t&&null===n.get(i.targetId)&&(this.Nr.delete(s),a.push(this.removeMatchingKeysForTargetId(e,i.targetId)),r++)})),Od.waitFor(a).next((()=>r))}getTargetCount(e){return Od.resolve(this.targetCount)}getTargetData(e,t){const n=this.Nr.get(t)||null;return Od.resolve(n)}addMatchingKeys(e,t,n){return this.Br.Rr(t,n),Od.resolve()}removeMatchingKeys(e,t,n){this.Br.mr(t,n);const r=this.persistence.referenceDelegate,a=[];return r&&t.forEach((t=>{a.push(r.markPotentiallyOrphaned(e,t))})),Od.waitFor(a)}removeMatchingKeysForTargetId(e,t){return this.Br.gr(t),Od.resolve()}getMatchingKeysForTargetId(e,t){const n=this.Br.yr(t);return Od.resolve(n)}containsKey(e,t){return Od.resolve(this.Br.containsKey(t))}}class Om{constructor(e,t){this.qr={},this.overlays={},this.Qr=new zd(0),this.Kr=!1,this.Kr=!0,this.$r=new Em,this.referenceDelegate=e(this),this.Ur=new Fm(this),this.indexManager=new xm,this.remoteDocumentCache=function(e){return new Dm(e)}((e=>this.referenceDelegate.Wr(e))),this.serializer=new ym(t),this.Gr=new Cm(this.serializer)}start(){return Promise.resolve()}shutdown(){return this.Kr=!1,Promise.resolve()}get started(){return this.Kr}setDatabaseDeletedListener(){}setNetworkEnabled(){}getIndexManager(e){return this.indexManager}getDocumentOverlayCache(e){let t=this.overlays[e.toKey()];return t||(t=new Am,this.overlays[e.toKey()]=t),t}getMutationQueue(e,t){let n=this.qr[e.toKey()];return n||(n=new Rm(t,this.referenceDelegate),this.qr[e.toKey()]=n),n}getGlobalsCache(){return this.$r}getTargetCache(){return this.Ur}getRemoteDocumentCache(){return this.remoteDocumentCache}getBundleCache(){return this.Gr}runTransaction(e,t,n){Jc("MemoryPersistence","Starting transaction:",e);const r=new Pm(this.Qr.next());return this.referenceDelegate.zr(),n(r).next((e=>this.referenceDelegate.jr(r).next((()=>e)))).toPromise().then((e=>(r.raiseOnCommittedEvent(),e)))}Hr(e,t){return Od.or(Object.values(this.qr).map((n=>()=>n.containsKey(e,t))))}}class Pm extends Md{constructor(e){super(),this.currentSequenceNumber=e}}class Lm{constructor(e){this.persistence=e,this.Jr=new _m,this.Yr=null}static Zr(e){return new Lm(e)}get Xr(){if(this.Yr)return this.Yr;throw rd()}addReference(e,t,n){return this.Jr.addReference(n,t),this.Xr.delete(n.toString()),Od.resolve()}removeReference(e,t,n){return this.Jr.removeReference(n,t),this.Xr.add(n.toString()),Od.resolve()}markPotentiallyOrphaned(e,t){return this.Xr.add(t.toString()),Od.resolve()}removeTarget(e,t){this.Jr.gr(t.targetId).forEach((e=>this.Xr.add(e.toString())));const n=this.persistence.getTargetCache();return n.getMatchingKeysForTargetId(e,t.targetId).next((e=>{e.forEach((e=>this.Xr.add(e.toString())))})).next((()=>n.removeTargetData(e,t)))}zr(){this.Yr=new Set}jr(e){const t=this.persistence.getRemoteDocumentCache().newChangeBuffer();return Od.forEach(this.Xr,(n=>{const r=Cd.fromPath(n);return this.ei(e,r).next((e=>{e||t.removeEntry(r,kd.min())}))})).next((()=>(this.Yr=null,t.apply(e))))}updateLimboDocument(e,t){return this.ei(e,t).next((e=>{e?this.Xr.delete(t.toString()):this.Xr.add(t.toString())}))}Wr(e){return 0}ei(e,t){return Od.or([()=>Od.resolve(this.Jr.containsKey(t)),()=>this.persistence.getTargetCache().containsKey(e,t),()=>this.persistence.Hr(e,t)])}}class zm{constructor(e,t,n,r){this.targetId=e,this.fromCache=t,this.$i=n,this.Ui=r}static Wi(e,t){let n=Dp(),r=Dp();for(const a of t.docChanges)switch(a.type){case 0:n=n.add(a.doc.key);break;case 1:r=r.add(a.doc.key)}return new zm(e,t.fromCache,n,r)}}class Bm{constructor(){this._documentReadCount=0}get documentReadCount(){return this._documentReadCount}incrementDocumentReadCount(e){this._documentReadCount+=e}}class Vm{constructor(){this.Gi=!1,this.zi=!1,this.ji=100,this.Hi=Ql()?8:Pd(Xl())>0?6:4}initialize(e,t){this.Ji=e,this.indexManager=t,this.Gi=!0}getDocumentsMatchingQuery(e,t,n,r){const a={result:null};return this.Yi(e,t).next((e=>{a.result=e})).next((()=>{if(!a.result)return this.Zi(e,t,r,n).next((e=>{a.result=e}))})).next((()=>{if(a.result)return;const n=new Bm;return this.Xi(e,t,n).next((r=>{if(a.result=r,this.zi)return this.es(e,t,n,r.size)}))})).next((()=>a.result))}es(e,t,n,r){return n.documentReadCount<this.ji?(Zc()<=du.DEBUG&&Jc("QueryEngine","SDK will not create cache indexes for query:",yp(t),"since it only creates cache indexes for collection contains","more than or equal to",this.ji,"documents"),Od.resolve()):(Zc()<=du.DEBUG&&Jc("QueryEngine","Query:",yp(t),"scans",n.documentReadCount,"local documents and returns",r,"documents as results."),n.documentReadCount>this.Hi*r?(Zc()<=du.DEBUG&&Jc("QueryEngine","The SDK decides to create cache indexes for query:",yp(t),"as using cache indexes may help improve performance."),this.indexManager.createTargetIndexes(e,hp(t))):Od.resolve())}Yi(e,t){if(up(t))return Od.resolve(null);let n=hp(t);return this.indexManager.getIndexType(e,n).next((r=>0===r?null:(null!==t.limit&&1===r&&(t=fp(t,null,"F"),n=hp(t)),this.indexManager.getDocumentsMatchingTarget(e,n).next((r=>{const a=Dp(...r);return this.Ji.getDocuments(e,a).next((r=>this.indexManager.getMinOffset(e,n).next((n=>{const s=this.ts(t,r);return this.ns(t,s,a,n.readTime)?this.Yi(e,fp(t,null,"F")):this.rs(e,s,t,n)}))))})))))}Zi(e,t,n,r){return up(t)||r.isEqual(kd.min())?Od.resolve(null):this.Ji.getDocuments(e,n).next((a=>{const s=this.ts(t,a);return this.ns(t,s,n,r)?Od.resolve(null):(Zc()<=du.DEBUG&&Jc("QueryEngine","Re-using previous result from %s to execute query: %s",r.toString(),yp(t)),this.rs(e,s,t,Ed(r,-1)).next((e=>e)))}))}ts(e,t){let n=new Jd(xp(e));return t.forEach(((t,r)=>{bp(e,r)&&(n=n.add(r))})),n}ns(e,t,n,r){if(null===e.limit)return!1;if(n.size!==t.size)return!0;const a="F"===e.limitType?t.last():t.first();return!!a&&(a.hasPendingWrites||a.version.compareTo(r)>0)}Xi(e,t,n){return Zc()<=du.DEBUG&&Jc("QueryEngine","Using full collection scan to execute query:",yp(t)),this.Ji.getDocumentsMatchingQuery(e,t,$d.min(),n)}rs(e,t,n,r){return this.Ji.getDocumentsMatchingQuery(e,n,r).next((e=>(t.forEach((t=>{e=e.insert(t.key,t)})),e)))}}class Wm{constructor(e,t,n,r){this.persistence=e,this.ss=t,this.serializer=r,this.os=new Xd(vd),this._s=new kp((e=>rp(e)),ap),this.us=new Map,this.cs=e.getRemoteDocumentCache(),this.Ur=e.getTargetCache(),this.Gr=e.getBundleCache(),this.ls(n)}ls(e){this.documentOverlayCache=this.persistence.getDocumentOverlayCache(e),this.indexManager=this.persistence.getIndexManager(e),this.mutationQueue=this.persistence.getMutationQueue(e,this.indexManager),this.localDocuments=new Nm(this.cs,this.mutationQueue,this.documentOverlayCache,this.indexManager),this.cs.setIndexManager(this.indexManager),this.ss.initialize(this.localDocuments,this.indexManager)}collectGarbage(e){return this.persistence.runTransaction("Collect garbage","readwrite-primary",(t=>e.collect(t,this.os)))}}function Um(e,t,n,r){return new Wm(e,t,n,r)}async function jm(e,t){const n=sd(e);return await n.persistence.runTransaction("Handle user change","readonly",(e=>{let r;return n.mutationQueue.getAllMutationBatches(e).next((a=>(r=a,n.ls(t),n.mutationQueue.getAllMutationBatches(e)))).next((t=>{const a=[],s=[];let i=Dp();for(const e of r){a.push(e.batchId);for(const t of e.mutations)i=i.add(t.key)}for(const e of t){s.push(e.batchId);for(const t of e.mutations)i=i.add(t.key)}return n.localDocuments.getDocuments(e,i).next((e=>({hs:e,removedBatchIds:a,addedBatchIds:s})))}))}))}function Gm(e){const t=sd(e);return t.persistence.runTransaction("Get last remote snapshot version","readonly",(e=>t.Ur.getLastRemoteSnapshotVersion(e)))}function Hm(e,t,n){let r=Dp(),a=Dp();return n.forEach((e=>r=r.add(e))),t.getEntries(e,r).next((e=>{let r=Ip();return n.forEach(((n,s)=>{const i=e.get(n);s.isFoundDocument()!==i.isFoundDocument()&&(a=a.add(n)),s.isNoDocument()&&s.version.isEqual(kd.min())?(t.removeEntry(n,s.readTime),r=r.insert(n,s)):!i.isValidDocument()||s.version.compareTo(i.version)>0||0===s.version.compareTo(i.version)&&i.hasPendingWrites?(t.addEntry(s),r=r.insert(n,s)):Jc("LocalStore","Ignoring outdated watch update for ",n,". Current version:",i.version," Watch version:",s.version)})),{Ps:r,Is:a}}))}function qm(e,t){const n=sd(e);return n.persistence.runTransaction("Get next mutation batch","readonly",(e=>(void 0===t&&(t=-1),n.mutationQueue.getNextMutationBatchAfterBatchId(e,t))))}function Km(e,t){const n=sd(e);return n.persistence.runTransaction("Allocate target","readwrite",(e=>{let r;return n.Ur.getTargetData(e,t).next((a=>a?(r=a,Od.resolve(r)):n.Ur.allocateTargetId(e).next((a=>(r=new gm(t,a,"TargetPurposeListen",e.currentSequenceNumber),n.Ur.addTargetData(e,r).next((()=>r)))))))})).then((e=>{const r=n.os.get(e.targetId);return(null===r||e.snapshotVersion.compareTo(r.snapshotVersion)>0)&&(n.os=n.os.insert(e.targetId,e),n._s.set(t,e.targetId)),e}))}async function Ym(e,t,n){const r=sd(e),a=r.os.get(t),s=n?"readwrite":"readwrite-primary";try{n||await r.persistence.runTransaction("Release target",s,(e=>r.persistence.referenceDelegate.removeTarget(e,a)))}catch(e){if(!Ld(e))throw e;Jc("LocalStore",`Failed to update sequence numbers for target ${t}: ${e}`)}r.os=r.os.remove(t),r._s.delete(a.target)}function Xm(e,t,n){const r=sd(e);let a=kd.min(),s=Dp();return r.persistence.runTransaction("Execute query","readwrite",(e=>function(e,t,n){const r=sd(e),a=r._s.get(n);return void 0!==a?Od.resolve(r.os.get(a)):r.Ur.getTargetData(t,n)}(r,e,hp(t)).next((t=>{if(t)return a=t.lastLimboFreeSnapshotVersion,r.Ur.getMatchingKeysForTargetId(e,t.targetId).next((e=>{s=e}))})).next((()=>r.ss.getDocumentsMatchingQuery(e,t,n?a:kd.min(),n?s:Dp()))).next((e=>(Qm(r,vp(t),e),{documents:e,Ts:s})))))}function Qm(e,t,n){let r=e.us.get(t)||kd.min();n.forEach(((e,t)=>{t.readTime.compareTo(r)>0&&(r=t.readTime)})),e.us.set(t,r)}class Zm{constructor(){this.activeTargetIds=Fp()}fs(e){this.activeTargetIds=this.activeTargetIds.add(e)}gs(e){this.activeTargetIds=this.activeTargetIds.delete(e)}Vs(){const e={activeTargetIds:this.activeTargetIds.toArray(),updateTimeMs:Date.now()};return JSON.stringify(e)}}class Jm{constructor(){this.so=new Zm,this.oo={},this.onlineStateHandler=null,this.sequenceNumberHandler=null}addPendingMutation(e){}updateMutationState(e,t,n){}addLocalQueryTarget(e){return this.so.fs(e),this.oo[e]||"not-current"}updateQueryState(e,t,n){this.oo[e]=t}removeLocalQueryTarget(e){this.so.gs(e)}isLocalQueryTarget(e){return this.so.activeTargetIds.has(e)}clearQueryState(e){delete this.oo[e]}getAllActiveQueryTargets(){return this.so.activeTargetIds}isActiveQueryTarget(e){return this.so.activeTargetIds.has(e)}start(){return this.so=new Zm,Promise.resolve()}handleUserChange(e,t,n){}setOnlineState(e){}shutdown(){}writeSequenceNumber(e){}notifyBundleLoaded(e){}}class eg{_o(e){}shutdown(){}}class tg{constructor(){this.ao=()=>this.uo(),this.co=()=>this.lo(),this.ho=[],this.Po()}_o(e){this.ho.push(e)}shutdown(){window.removeEventListener("online",this.ao),window.removeEventListener("offline",this.co)}Po(){window.addEventListener("online",this.ao),window.addEventListener("offline",this.co)}uo(){Jc("ConnectivityMonitor","Network connectivity changed: AVAILABLE");for(const e of this.ho)e(0)}lo(){Jc("ConnectivityMonitor","Network connectivity changed: UNAVAILABLE");for(const e of this.ho)e(1)}static D(){return"undefined"!=typeof window&&void 0!==window.addEventListener&&void 0!==window.removeEventListener}}let ng=null;function rg(){return null===ng?ng=268435456+Math.round(2147483648*Math.random()):ng++,"0x"+ng.toString(16)}const ag={BatchGetDocuments:"batchGet",Commit:"commit",RunQuery:"runQuery",RunAggregationQuery:"runAggregationQuery"};class sg{constructor(e){this.Io=e.Io,this.To=e.To}Eo(e){this.Ao=e}Ro(e){this.Vo=e}mo(e){this.fo=e}onMessage(e){this.po=e}close(){this.To()}send(e){this.Io(e)}yo(){this.Ao()}wo(){this.Vo()}So(e){this.fo(e)}bo(e){this.po(e)}}const ig="WebChannelConnection";class og extends class{constructor(e){this.databaseInfo=e,this.databaseId=e.databaseId;const t=e.ssl?"https":"http",n=encodeURIComponent(this.databaseId.projectId),r=encodeURIComponent(this.databaseId.database);this.Do=t+"://"+e.host,this.vo=`projects/${n}/databases/${r}`,this.Co="(default)"===this.databaseId.database?`project_id=${n}`:`project_id=${n}&database_id=${r}`}get Fo(){return!1}Mo(e,t,n,r,a){const s=rg(),i=this.xo(e,t.toUriEncodedString());Jc("RestConnection",`Sending RPC '${e}' ${s}:`,i,n);const o={"google-cloud-resource-prefix":this.vo,"x-goog-request-params":this.Co};return this.Oo(o,r,a),this.No(e,i,o,n).then((t=>(Jc("RestConnection",`Received RPC '${e}' ${s}: `,t),t)),(t=>{throw td("RestConnection",`RPC '${e}' ${s} failed with error: `,t,"url: ",i,"request:",n),t}))}Lo(e,t,n,r,a,s){return this.Mo(e,t,n,r,a)}Oo(e,t,n){e["X-Goog-Api-Client"]="gl-js/ fire/"+Xc,e["Content-Type"]="text/plain",this.databaseInfo.appId&&(e["X-Firebase-GMPID"]=this.databaseInfo.appId),t&&t.headers.forEach(((t,n)=>e[n]=t)),n&&n.headers.forEach(((t,n)=>e[n]=t))}xo(e,t){const n=ag[e];return`${this.Do}/v1/${t}:${n}`}terminate(){}}{constructor(e){super(e),this.forceLongPolling=e.forceLongPolling,this.autoDetectLongPolling=e.autoDetectLongPolling,this.useFetchStreams=e.useFetchStreams,this.longPollingOptions=e.longPollingOptions}No(e,t,n,r){const a=rg();return new Promise(((s,i)=>{const o=new Pc;o.setWithCredentials(!0),o.listenOnce(Bc.COMPLETE,(()=>{try{switch(o.getLastErrorCode()){case Vc.NO_ERROR:const t=o.getResponseJson();Jc(ig,`XHR for RPC '${e}' ${a} received:`,JSON.stringify(t)),s(t);break;case Vc.TIMEOUT:Jc(ig,`RPC '${e}' ${a} timed out`),i(new od(id.DEADLINE_EXCEEDED,"Request time out"));break;case Vc.HTTP_ERROR:const n=o.getStatus();if(Jc(ig,`RPC '${e}' ${a} failed with status:`,n,"response text:",o.getResponseText()),n>0){let e=o.getResponseJson();Array.isArray(e)&&(e=e[0]);const t=null==e?void 0:e.error;if(t&&t.status&&t.message){const e=function(e){const t=e.toLowerCase().replace(/_/g,"-");return Object.values(id).indexOf(t)>=0?t:id.UNKNOWN}(t.status);i(new od(e,t.message))}else i(new od(id.UNKNOWN,"Server responded with status "+o.getStatus()))}else i(new od(id.UNAVAILABLE,"Connection failed."));break;default:rd()}}finally{Jc(ig,`RPC '${e}' ${a} completed.`)}}));const l=JSON.stringify(r);Jc(ig,`RPC '${e}' ${a} sending request:`,r),o.send(t,"POST",l,n,15)}))}Bo(e,t,n){const r=rg(),a=[this.Do,"/","google.firestore.v1.Firestore","/",e,"/channel"],s=Gc(),i=jc(),o={httpSessionIdParam:"gsessionid",initMessageHeaders:{},messageUrlParams:{database:`projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`},sendRawJson:!0,supportsCrossDomainXhr:!0,internalChannelParams:{forwardChannelRequestTimeoutMs:6e5},forceLongPolling:this.forceLongPolling,detectBufferingProxy:this.autoDetectLongPolling},l=this.longPollingOptions.timeoutSeconds;void 0!==l&&(o.longPollingTimeout=Math.round(1e3*l)),this.useFetchStreams&&(o.xmlHttpFactory=new Lc({})),this.Oo(o.initMessageHeaders,t,n),o.encodeInitMessageHeaders=!0;const u=a.join("");Jc(ig,`Creating RPC '${e}' stream ${r}: ${u}`,o);const c=s.createWebChannel(u,o);let d=!1,h=!1;const p=new sg({Io:t=>{h?Jc(ig,`Not sending because RPC '${e}' stream ${r} is closed:`,t):(d||(Jc(ig,`Opening RPC '${e}' stream ${r} transport.`),c.open(),d=!0),Jc(ig,`RPC '${e}' stream ${r} sending:`,t),c.send(t))},To:()=>c.close()}),f=(e,t,n)=>{e.listen(t,(e=>{try{n(e)}catch(e){setTimeout((()=>{throw e}),0)}}))};return f(c,zc.EventType.OPEN,(()=>{h||(Jc(ig,`RPC '${e}' stream ${r} transport opened.`),p.yo())})),f(c,zc.EventType.CLOSE,(()=>{h||(h=!0,Jc(ig,`RPC '${e}' stream ${r} transport closed`),p.So())})),f(c,zc.EventType.ERROR,(t=>{h||(h=!0,td(ig,`RPC '${e}' stream ${r} transport errored:`,t),p.So(new od(id.UNAVAILABLE,"The operation could not be completed")))})),f(c,zc.EventType.MESSAGE,(t=>{var n;if(!h){const a=t.data[0];ad(!!a);const s=a,i=s.error||(null===(n=s[0])||void 0===n?void 0:n.error);if(i){Jc(ig,`RPC '${e}' stream ${r} received error:`,i);const t=i.status;let n=function(e){const t=bf[e];if(void 0!==t)return wf(t)}(t),a=i.message;void 0===n&&(n=id.INTERNAL,a="Unknown error status: "+t+" with message "+i.message),h=!0,p.So(new od(n,a)),c.close()}else Jc(ig,`RPC '${e}' stream ${r} received:`,a),p.bo(a)}})),f(i,Uc.STAT_EVENT,(t=>{t.stat===Wc.PROXY?Jc(ig,`RPC '${e}' stream ${r} detected buffering proxy`):t.stat===Wc.NOPROXY&&Jc(ig,`RPC '${e}' stream ${r} detected no buffering proxy`)})),setTimeout((()=>{p.wo()}),0),p}}function lg(){return"undefined"!=typeof document?document:null}function ug(e){return new Vf(e,!0)}class cg{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:6e4;this.ui=e,this.timerId=t,this.ko=n,this.qo=r,this.Qo=a,this.Ko=0,this.$o=null,this.Uo=Date.now(),this.reset()}reset(){this.Ko=0}Wo(){this.Ko=this.Qo}Go(e){this.cancel();const t=Math.floor(this.Ko+this.zo()),n=Math.max(0,Date.now()-this.Uo),r=Math.max(0,t-n);r>0&&Jc("ExponentialBackoff",`Backing off for ${r} ms (base delay: ${this.Ko} ms, delay with jitter: ${t} ms, last attempt: ${n} ms ago)`),this.$o=this.ui.enqueueAfterDelay(this.timerId,r,(()=>(this.Uo=Date.now(),e()))),this.Ko*=this.qo,this.Ko<this.ko&&(this.Ko=this.ko),this.Ko>this.Qo&&(this.Ko=this.Qo)}jo(){null!==this.$o&&(this.$o.skipDelay(),this.$o=null)}cancel(){null!==this.$o&&(this.$o.cancel(),this.$o=null)}zo(){return(Math.random()-.5)*this.Ko}}class dg{constructor(e,t,n,r,a,s,i,o){this.ui=e,this.Ho=n,this.Jo=r,this.connection=a,this.authCredentialsProvider=s,this.appCheckCredentialsProvider=i,this.listener=o,this.state=0,this.Yo=0,this.Zo=null,this.Xo=null,this.stream=null,this.e_=0,this.t_=new cg(e,t)}n_(){return 1===this.state||5===this.state||this.r_()}r_(){return 2===this.state||3===this.state}start(){this.e_=0,4!==this.state?this.auth():this.i_()}async stop(){this.n_()&&await this.close(0)}s_(){this.state=0,this.t_.reset()}o_(){this.r_()&&null===this.Zo&&(this.Zo=this.ui.enqueueAfterDelay(this.Ho,6e4,(()=>this.__())))}a_(e){this.u_(),this.stream.send(e)}async __(){if(this.r_())return this.close(0)}u_(){this.Zo&&(this.Zo.cancel(),this.Zo=null)}c_(){this.Xo&&(this.Xo.cancel(),this.Xo=null)}async close(e,t){this.u_(),this.c_(),this.t_.cancel(),this.Yo++,4!==e?this.t_.reset():t&&t.code===id.RESOURCE_EXHAUSTED?(ed(t.toString()),ed("Using maximum backoff delay to prevent overloading the backend."),this.t_.Wo()):t&&t.code===id.UNAUTHENTICATED&&3!==this.state&&(this.authCredentialsProvider.invalidateToken(),this.appCheckCredentialsProvider.invalidateToken()),null!==this.stream&&(this.l_(),this.stream.close(),this.stream=null),this.state=e,await this.listener.mo(t)}l_(){}auth(){this.state=1;const e=this.h_(this.Yo),t=this.Yo;Promise.all([this.authCredentialsProvider.getToken(),this.appCheckCredentialsProvider.getToken()]).then((e=>{let[n,r]=e;this.Yo===t&&this.P_(n,r)}),(t=>{e((()=>{const e=new od(id.UNKNOWN,"Fetching auth token failed: "+t.message);return this.I_(e)}))}))}P_(e,t){const n=this.h_(this.Yo);this.stream=this.T_(e,t),this.stream.Eo((()=>{n((()=>this.listener.Eo()))})),this.stream.Ro((()=>{n((()=>(this.state=2,this.Xo=this.ui.enqueueAfterDelay(this.Jo,1e4,(()=>(this.r_()&&(this.state=3),Promise.resolve()))),this.listener.Ro())))})),this.stream.mo((e=>{n((()=>this.I_(e)))})),this.stream.onMessage((e=>{n((()=>1==++this.e_?this.E_(e):this.onNext(e)))}))}i_(){this.state=5,this.t_.Go((async()=>{this.state=0,this.start()}))}I_(e){return Jc("PersistentStream",`close with error: ${e}`),this.stream=null,this.close(4,e)}h_(e){return t=>{this.ui.enqueueAndForget((()=>this.Yo===e?t():(Jc("PersistentStream","stream callback skipped by getCloseGuardedDispatcher."),Promise.resolve())))}}}class hg extends dg{constructor(e,t,n,r,a,s){super(e,"listen_stream_connection_backoff","listen_stream_idle","health_check_timeout",t,n,r,s),this.serializer=a}T_(e,t){return this.connection.Bo("Listen",e,t)}E_(e){return this.onNext(e)}onNext(e){this.t_.reset();const t=function(e,t){let n;if("targetChange"in t){t.targetChange;const r=function(e){return"NO_CHANGE"===e?0:"ADD"===e?1:"REMOVE"===e?2:"CURRENT"===e?3:"RESET"===e?4:rd()}(t.targetChange.targetChangeType||"NO_CHANGE"),a=t.targetChange.targetIds||[],s=function(e,t){return e.useProto3Json?(ad(void 0===t||"string"==typeof t),rh.fromBase64String(t||"")):(ad(void 0===t||t instanceof Buffer||t instanceof Uint8Array),rh.fromUint8Array(t||new Uint8Array))}(e,t.targetChange.resumeToken),i=t.targetChange.cause,o=i&&function(e){const t=void 0===e.code?id.UNKNOWN:wf(e.code);return new od(t,e.message||"")}(i);n=new Df(r,a,s,o||null)}else if("documentChange"in t){t.documentChange;const r=t.documentChange;r.document,r.document.name,r.document.updateTime;const a=Qf(e,r.document.name),s=Hf(r.document.updateTime),i=r.document.createTime?Hf(r.document.createTime):kd.min(),o=new _h({mapValue:{fields:r.document.fields}}),l=Rh.newFoundDocument(a,s,i,o),u=r.targetIds||[],c=r.removedTargetIds||[];n=new $f(u,c,l.key,l)}else if("documentDelete"in t){t.documentDelete;const r=t.documentDelete;r.document;const a=Qf(e,r.document),s=r.readTime?Hf(r.readTime):kd.min(),i=Rh.newNoDocument(a,s),o=r.removedTargetIds||[];n=new $f([],o,i.key,i)}else if("documentRemove"in t){t.documentRemove;const r=t.documentRemove;r.document;const a=Qf(e,r.document),s=r.removedTargetIds||[];n=new $f([],s,a,null)}else{if(!("filter"in t))return rd();{t.filter;const e=t.filter;e.targetId;const{count:r=0,unchangedNames:a}=e,s=new yf(r,a),i=e.targetId;n=new Rf(i,s)}}return n}(this.serializer,e),n=function(e){if(!("targetChange"in e))return kd.min();const t=e.targetChange;return t.targetIds&&t.targetIds.length?kd.min():t.readTime?Hf(t.readTime):kd.min()}(e);return this.listener.d_(t,n)}A_(e){const t={};t.database=em(this.serializer),t.addTarget=function(e,t){let n;const r=t.target;if(n=sp(r)?{documents:am(e,r)}:{query:sm(e,r)._t},n.targetId=t.targetId,t.resumeToken.approximateByteSize()>0){n.resumeToken=jf(e,t.resumeToken);const r=Wf(e,t.expectedCount);null!==r&&(n.expectedCount=r)}else if(t.snapshotVersion.compareTo(kd.min())>0){n.readTime=Uf(e,t.snapshotVersion.toTimestamp());const r=Wf(e,t.expectedCount);null!==r&&(n.expectedCount=r)}return n}(this.serializer,e);const n=function(e,t){const n=function(e){switch(e){case"TargetPurposeListen":return null;case"TargetPurposeExistenceFilterMismatch":return"existence-filter-mismatch";case"TargetPurposeExistenceFilterMismatchBloom":return"existence-filter-mismatch-bloom";case"TargetPurposeLimboResolution":return"limbo-document";default:return rd()}}(t.purpose);return null==n?null:{"goog-listen-tags":n}}(this.serializer,e);n&&(t.labels=n),this.a_(t)}R_(e){const t={};t.database=em(this.serializer),t.removeTarget=e,this.a_(t)}}class pg extends dg{constructor(e,t,n,r,a,s){super(e,"write_stream_connection_backoff","write_stream_idle","health_check_timeout",t,n,r,s),this.serializer=a}get V_(){return this.e_>0}start(){this.lastStreamToken=void 0,super.start()}l_(){this.V_&&this.m_([])}T_(e,t){return this.connection.Bo("Write",e,t)}E_(e){return ad(!!e.streamToken),this.lastStreamToken=e.streamToken,ad(!e.writeResults||0===e.writeResults.length),this.listener.f_()}onNext(e){ad(!!e.streamToken),this.lastStreamToken=e.streamToken,this.t_.reset();const t=function(e,t){return e&&e.length>0?(ad(void 0!==t),e.map((e=>function(e,t){let n=e.updateTime?Hf(e.updateTime):Hf(t);return n.isEqual(kd.min())&&(n=Hf(t)),new Qp(n,e.transformResults||[])}(e,t)))):[]}(e.writeResults,e.commitTime),n=Hf(e.commitTime);return this.listener.g_(n,t)}p_(){const e={};e.database=em(this.serializer),this.a_(e)}m_(e){const t={streamToken:this.lastStreamToken,writes:e.map((e=>rm(this.serializer,e)))};this.a_(t)}}class fg extends class{}{constructor(e,t,n,r){super(),this.authCredentials=e,this.appCheckCredentials=t,this.connection=n,this.serializer=r,this.y_=!1}w_(){if(this.y_)throw new od(id.FAILED_PRECONDITION,"The client has already been terminated.")}Mo(e,t,n,r){return this.w_(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((a=>{let[s,i]=a;return this.connection.Mo(e,Kf(t,n),r,s,i)})).catch((e=>{throw"FirebaseError"===e.name?(e.code===id.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),e):new od(id.UNKNOWN,e.toString())}))}Lo(e,t,n,r,a){return this.w_(),Promise.all([this.authCredentials.getToken(),this.appCheckCredentials.getToken()]).then((s=>{let[i,o]=s;return this.connection.Lo(e,Kf(t,n),r,i,o,a)})).catch((e=>{throw"FirebaseError"===e.name?(e.code===id.UNAUTHENTICATED&&(this.authCredentials.invalidateToken(),this.appCheckCredentials.invalidateToken()),e):new od(id.UNKNOWN,e.toString())}))}terminate(){this.y_=!0,this.connection.terminate()}}class mg{constructor(e,t){this.asyncQueue=e,this.onlineStateHandler=t,this.state="Unknown",this.S_=0,this.b_=null,this.D_=!0}v_(){0===this.S_&&(this.C_("Unknown"),this.b_=this.asyncQueue.enqueueAfterDelay("online_state_timeout",1e4,(()=>(this.b_=null,this.F_("Backend didn't respond within 10 seconds."),this.C_("Offline"),Promise.resolve()))))}M_(e){"Online"===this.state?this.C_("Unknown"):(this.S_++,this.S_>=1&&(this.x_(),this.F_(`Connection failed 1 times. Most recent error: ${e.toString()}`),this.C_("Offline")))}set(e){this.x_(),this.S_=0,"Online"===e&&(this.D_=!1),this.C_(e)}C_(e){e!==this.state&&(this.state=e,this.onlineStateHandler(e))}F_(e){const t=`Could not reach Cloud Firestore backend. ${e}\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;this.D_?(ed(t),this.D_=!1):Jc("OnlineStateTracker",t)}x_(){null!==this.b_&&(this.b_.cancel(),this.b_=null)}}class gg{constructor(e,t,n,r,a){this.localStore=e,this.datastore=t,this.asyncQueue=n,this.remoteSyncer={},this.O_=[],this.N_=new Map,this.L_=new Set,this.B_=[],this.k_=a,this.k_._o((e=>{n.enqueueAndForget((async()=>{Tg(this)&&(Jc("RemoteStore","Restarting streams for network reachability change."),await async function(e){const t=sd(e);t.L_.add(4),await bg(t),t.q_.set("Unknown"),t.L_.delete(4),await yg(t)}(this))}))})),this.q_=new mg(n,r)}}async function yg(e){if(Tg(e))for(const t of e.B_)await t(!0)}async function bg(e){for(const t of e.B_)await t(!1)}function vg(e,t){const n=sd(e);n.N_.has(t.targetId)||(n.N_.set(t.targetId,t),Ig(n)?Sg(n):jg(n).r_()&&wg(n,t))}function xg(e,t){const n=sd(e),r=jg(n);n.N_.delete(t),r.r_()&&kg(n,t),0===n.N_.size&&(r.r_()?r.o_():Tg(n)&&n.q_.set("Unknown"))}function wg(e,t){if(e.Q_.xe(t.targetId),t.resumeToken.approximateByteSize()>0||t.snapshotVersion.compareTo(kd.min())>0){const n=e.remoteSyncer.getRemoteKeysForTarget(t.targetId).size;t=t.withExpectedCount(n)}jg(e).A_(t)}function kg(e,t){e.Q_.xe(t),jg(e).R_(t)}function Sg(e){e.Q_=new Ff({getRemoteKeysForTarget:t=>e.remoteSyncer.getRemoteKeysForTarget(t),ot:t=>e.N_.get(t)||null,tt:()=>e.datastore.serializer.databaseId}),jg(e).start(),e.q_.v_()}function Ig(e){return Tg(e)&&!jg(e).n_()&&e.N_.size>0}function Tg(e){return 0===sd(e).L_.size}function Ng(e){e.Q_=void 0}async function Cg(e){e.q_.set("Online")}async function Ag(e){e.N_.forEach(((t,n)=>{wg(e,t)}))}async function Eg(e,t){Ng(e),Ig(e)?(e.q_.M_(t),Sg(e)):e.q_.set("Unknown")}async function _g(e,t,n){if(e.q_.set("Online"),t instanceof Df&&2===t.state&&t.cause)try{await async function(e,t){const n=t.cause;for(const r of t.targetIds)e.N_.has(r)&&(await e.remoteSyncer.rejectListen(r,n),e.N_.delete(r),e.Q_.removeTarget(r))}(e,t)}catch(n){Jc("RemoteStore","Failed to remove targets %s: %s ",t.targetIds.join(","),n),await $g(e,n)}else if(t instanceof $f?e.Q_.Ke(t):t instanceof Rf?e.Q_.He(t):e.Q_.We(t),!n.isEqual(kd.min()))try{const t=await Gm(e.localStore);n.compareTo(t)>=0&&await function(e,t){const n=e.Q_.rt(t);return n.targetChanges.forEach(((n,r)=>{if(n.resumeToken.approximateByteSize()>0){const a=e.N_.get(r);a&&e.N_.set(r,a.withResumeToken(n.resumeToken,t))}})),n.targetMismatches.forEach(((t,n)=>{const r=e.N_.get(t);if(!r)return;e.N_.set(t,r.withResumeToken(rh.EMPTY_BYTE_STRING,r.snapshotVersion)),kg(e,t);const a=new gm(r.target,t,n,r.sequenceNumber);wg(e,a)})),e.remoteSyncer.applyRemoteEvent(n)}(e,n)}catch(t){Jc("RemoteStore","Failed to raise snapshot:",t),await $g(e,t)}}async function $g(e,t,n){if(!Ld(t))throw t;e.L_.add(1),await bg(e),e.q_.set("Offline"),n||(n=()=>Gm(e.localStore)),e.asyncQueue.enqueueRetryable((async()=>{Jc("RemoteStore","Retrying IndexedDB access"),await n(),e.L_.delete(1),await yg(e)}))}function Rg(e,t){return t().catch((n=>$g(e,n,t)))}async function Dg(e){const t=sd(e),n=Gg(t);let r=t.O_.length>0?t.O_[t.O_.length-1].batchId:-1;for(;Mg(t);)try{const e=await qm(t.localStore,r);if(null===e){0===t.O_.length&&n.o_();break}r=e.batchId,Fg(t,e)}catch(e){await $g(t,e)}Og(t)&&Pg(t)}function Mg(e){return Tg(e)&&e.O_.length<10}function Fg(e,t){e.O_.push(t);const n=Gg(e);n.r_()&&n.V_&&n.m_(t.mutations)}function Og(e){return Tg(e)&&!Gg(e).n_()&&e.O_.length>0}function Pg(e){Gg(e).start()}async function Lg(e){Gg(e).p_()}async function zg(e){const t=Gg(e);for(const n of e.O_)t.m_(n.mutations)}async function Bg(e,t,n){const r=e.O_.shift(),a=mf.from(r,t,n);await Rg(e,(()=>e.remoteSyncer.applySuccessfulWrite(a))),await Dg(e)}async function Vg(e,t){t&&Gg(e).V_&&await async function(e,t){if(function(e){return xf(e)&&e!==id.ABORTED}(t.code)){const n=e.O_.shift();Gg(e).s_(),await Rg(e,(()=>e.remoteSyncer.rejectFailedWrite(n.batchId,t))),await Dg(e)}}(e,t),Og(e)&&Pg(e)}async function Wg(e,t){const n=sd(e);n.asyncQueue.verifyOperationInProgress(),Jc("RemoteStore","RemoteStore received new credentials");const r=Tg(n);n.L_.add(3),await bg(n),r&&n.q_.set("Unknown"),await n.remoteSyncer.handleCredentialChange(t),n.L_.delete(3),await yg(n)}async function Ug(e,t){const n=sd(e);t?(n.L_.delete(2),await yg(n)):t||(n.L_.add(2),await bg(n),n.q_.set("Unknown"))}function jg(e){return e.K_||(e.K_=function(e,t,n){const r=sd(e);return r.w_(),new hg(t,r.connection,r.authCredentials,r.appCheckCredentials,r.serializer,n)}(e.datastore,e.asyncQueue,{Eo:Cg.bind(null,e),Ro:Ag.bind(null,e),mo:Eg.bind(null,e),d_:_g.bind(null,e)}),e.B_.push((async t=>{t?(e.K_.s_(),Ig(e)?Sg(e):e.q_.set("Unknown")):(await e.K_.stop(),Ng(e))}))),e.K_}function Gg(e){return e.U_||(e.U_=function(e,t,n){const r=sd(e);return r.w_(),new pg(t,r.connection,r.authCredentials,r.appCheckCredentials,r.serializer,n)}(e.datastore,e.asyncQueue,{Eo:()=>Promise.resolve(),Ro:Lg.bind(null,e),mo:Vg.bind(null,e),f_:zg.bind(null,e),g_:Bg.bind(null,e)}),e.B_.push((async t=>{t?(e.U_.s_(),await Dg(e)):(await e.U_.stop(),e.O_.length>0&&(Jc("RemoteStore",`Stopping write stream with ${e.O_.length} pending writes`),e.O_=[]))}))),e.U_}class Hg{constructor(e,t,n,r,a){this.asyncQueue=e,this.timerId=t,this.targetTimeMs=n,this.op=r,this.removalCallback=a,this.deferred=new ld,this.then=this.deferred.promise.then.bind(this.deferred.promise),this.deferred.promise.catch((e=>{}))}get promise(){return this.deferred.promise}static createAndSchedule(e,t,n,r,a){const s=Date.now()+n,i=new Hg(e,t,s,r,a);return i.start(n),i}start(e){this.timerHandle=setTimeout((()=>this.handleDelayElapsed()),e)}skipDelay(){return this.handleDelayElapsed()}cancel(e){null!==this.timerHandle&&(this.clearTimeout(),this.deferred.reject(new od(id.CANCELLED,"Operation cancelled"+(e?": "+e:""))))}handleDelayElapsed(){this.asyncQueue.enqueueAndForget((()=>null!==this.timerHandle?(this.clearTimeout(),this.op().then((e=>this.deferred.resolve(e)))):Promise.resolve()))}clearTimeout(){null!==this.timerHandle&&(this.removalCallback(this),clearTimeout(this.timerHandle),this.timerHandle=null)}}function qg(e,t){if(ed("AsyncQueue",`${t}: ${e}`),Ld(e))return new od(id.UNAVAILABLE,`${t}: ${e}`);throw e}class Kg{constructor(e){this.comparator=e?(t,n)=>e(t,n)||Cd.comparator(t.key,n.key):(e,t)=>Cd.comparator(e.key,t.key),this.keyedMap=Np(),this.sortedSet=new Xd(this.comparator)}static emptySet(e){return new Kg(e.comparator)}has(e){return null!=this.keyedMap.get(e)}get(e){return this.keyedMap.get(e)}first(){return this.sortedSet.minKey()}last(){return this.sortedSet.maxKey()}isEmpty(){return this.sortedSet.isEmpty()}indexOf(e){const t=this.keyedMap.get(e);return t?this.sortedSet.indexOf(t):-1}get size(){return this.sortedSet.size}forEach(e){this.sortedSet.inorderTraversal(((t,n)=>(e(t),!1)))}add(e){const t=this.delete(e.key);return t.copy(t.keyedMap.insert(e.key,e),t.sortedSet.insert(e,null))}delete(e){const t=this.get(e);return t?this.copy(this.keyedMap.remove(e),this.sortedSet.remove(t)):this}isEqual(e){if(!(e instanceof Kg))return!1;if(this.size!==e.size)return!1;const t=this.sortedSet.getIterator(),n=e.sortedSet.getIterator();for(;t.hasNext();){const e=t.getNext().key,r=n.getNext().key;if(!e.isEqual(r))return!1}return!0}toString(){const e=[];return this.forEach((t=>{e.push(t.toString())})),0===e.length?"DocumentSet ()":"DocumentSet (\n  "+e.join("  \n")+"\n)"}copy(e,t){const n=new Kg;return n.comparator=this.comparator,n.keyedMap=e,n.sortedSet=t,n}}class Yg{constructor(){this.W_=new Xd(Cd.comparator)}track(e){const t=e.doc.key,n=this.W_.get(t);n?0!==e.type&&3===n.type?this.W_=this.W_.insert(t,e):3===e.type&&1!==n.type?this.W_=this.W_.insert(t,{type:n.type,doc:e.doc}):2===e.type&&2===n.type?this.W_=this.W_.insert(t,{type:2,doc:e.doc}):2===e.type&&0===n.type?this.W_=this.W_.insert(t,{type:0,doc:e.doc}):1===e.type&&0===n.type?this.W_=this.W_.remove(t):1===e.type&&2===n.type?this.W_=this.W_.insert(t,{type:1,doc:n.doc}):0===e.type&&1===n.type?this.W_=this.W_.insert(t,{type:2,doc:e.doc}):rd():this.W_=this.W_.insert(t,e)}G_(){const e=[];return this.W_.inorderTraversal(((t,n)=>{e.push(n)})),e}}class Xg{constructor(e,t,n,r,a,s,i,o,l){this.query=e,this.docs=t,this.oldDocs=n,this.docChanges=r,this.mutatedKeys=a,this.fromCache=s,this.syncStateChanged=i,this.excludesMetadataChanges=o,this.hasCachedResults=l}static fromInitialDocuments(e,t,n,r,a){const s=[];return t.forEach((e=>{s.push({type:0,doc:e})})),new Xg(e,t,Kg.emptySet(t),s,n,r,!0,!1,a)}get hasPendingWrites(){return!this.mutatedKeys.isEmpty()}isEqual(e){if(!(this.fromCache===e.fromCache&&this.hasCachedResults===e.hasCachedResults&&this.syncStateChanged===e.syncStateChanged&&this.mutatedKeys.isEqual(e.mutatedKeys)&&mp(this.query,e.query)&&this.docs.isEqual(e.docs)&&this.oldDocs.isEqual(e.oldDocs)))return!1;const t=this.docChanges,n=e.docChanges;if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++)if(t[r].type!==n[r].type||!t[r].doc.isEqual(n[r].doc))return!1;return!0}}class Qg{constructor(){this.z_=void 0,this.j_=[]}H_(){return this.j_.some((e=>e.J_()))}}class Zg{constructor(){this.queries=Jg(),this.onlineState="Unknown",this.Y_=new Set}terminate(){!function(e,t){const n=sd(e),r=n.queries;n.queries=Jg(),r.forEach(((e,n)=>{for(const r of n.j_)r.onError(t)}))}(this,new od(id.ABORTED,"Firestore shutting down"))}}function Jg(){return new kp((e=>gp(e)),mp)}async function ey(e,t){const n=sd(e);let r=3;const a=t.query;let s=n.queries.get(a);s?!s.H_()&&t.J_()&&(r=2):(s=new Qg,r=t.J_()?0:1);try{switch(r){case 0:s.z_=await n.onListen(a,!0);break;case 1:s.z_=await n.onListen(a,!1);break;case 2:await n.onFirstRemoteStoreListen(a)}}catch(e){const n=qg(e,`Initialization of query '${yp(t.query)}' failed`);return void t.onError(n)}n.queries.set(a,s),s.j_.push(t),t.Z_(n.onlineState),s.z_&&t.X_(s.z_)&&ay(n)}async function ty(e,t){const n=sd(e),r=t.query;let a=3;const s=n.queries.get(r);if(s){const e=s.j_.indexOf(t);e>=0&&(s.j_.splice(e,1),0===s.j_.length?a=t.J_()?0:1:!s.H_()&&t.J_()&&(a=2))}switch(a){case 0:return n.queries.delete(r),n.onUnlisten(r,!0);case 1:return n.queries.delete(r),n.onUnlisten(r,!1);case 2:return n.onLastRemoteStoreUnlisten(r);default:return}}function ny(e,t){const n=sd(e);let r=!1;for(const a of t){const e=a.query,t=n.queries.get(e);if(t){for(const e of t.j_)e.X_(a)&&(r=!0);t.z_=a}}r&&ay(n)}function ry(e,t,n){const r=sd(e),a=r.queries.get(t);if(a)for(const s of a.j_)s.onError(n);r.queries.delete(t)}function ay(e){e.Y_.forEach((e=>{e.next()}))}var sy,iy;(iy=sy||(sy={})).ea="default",iy.Cache="cache";class oy{constructor(e,t,n){this.query=e,this.ta=t,this.na=!1,this.ra=null,this.onlineState="Unknown",this.options=n||{}}X_(e){if(!this.options.includeMetadataChanges){const t=[];for(const n of e.docChanges)3!==n.type&&t.push(n);e=new Xg(e.query,e.docs,e.oldDocs,t,e.mutatedKeys,e.fromCache,e.syncStateChanged,!0,e.hasCachedResults)}let t=!1;return this.na?this.ia(e)&&(this.ta.next(e),t=!0):this.sa(e,this.onlineState)&&(this.oa(e),t=!0),this.ra=e,t}onError(e){this.ta.error(e)}Z_(e){this.onlineState=e;let t=!1;return this.ra&&!this.na&&this.sa(this.ra,e)&&(this.oa(this.ra),t=!0),t}sa(e,t){if(!e.fromCache)return!0;if(!this.J_())return!0;const n="Offline"!==t;return(!this.options._a||!n)&&(!e.docs.isEmpty()||e.hasCachedResults||"Offline"===t)}ia(e){if(e.docChanges.length>0)return!0;const t=this.ra&&this.ra.hasPendingWrites!==e.hasPendingWrites;return!(!e.syncStateChanged&&!t)&&!0===this.options.includeMetadataChanges}oa(e){e=Xg.fromInitialDocuments(e.query,e.docs,e.mutatedKeys,e.fromCache,e.hasCachedResults),this.na=!0,this.ta.next(e)}J_(){return this.options.source!==sy.Cache}}class ly{constructor(e){this.key=e}}class uy{constructor(e){this.key=e}}class cy{constructor(e,t){this.query=e,this.Ta=t,this.Ea=null,this.hasCachedResults=!1,this.current=!1,this.da=Dp(),this.mutatedKeys=Dp(),this.Aa=xp(e),this.Ra=new Kg(this.Aa)}get Va(){return this.Ta}ma(e,t){const n=t?t.fa:new Yg,r=t?t.Ra:this.Ra;let a=t?t.mutatedKeys:this.mutatedKeys,s=r,i=!1;const o="F"===this.query.limitType&&r.size===this.query.limit?r.last():null,l="L"===this.query.limitType&&r.size===this.query.limit?r.first():null;if(e.inorderTraversal(((e,t)=>{const u=r.get(e),c=bp(this.query,t)?t:null,d=!!u&&this.mutatedKeys.has(u.key),h=!!c&&(c.hasLocalMutations||this.mutatedKeys.has(c.key)&&c.hasCommittedMutations);let p=!1;u&&c?u.data.isEqual(c.data)?d!==h&&(n.track({type:3,doc:c}),p=!0):this.ga(u,c)||(n.track({type:2,doc:c}),p=!0,(o&&this.Aa(c,o)>0||l&&this.Aa(c,l)<0)&&(i=!0)):!u&&c?(n.track({type:0,doc:c}),p=!0):u&&!c&&(n.track({type:1,doc:u}),p=!0,(o||l)&&(i=!0)),p&&(c?(s=s.add(c),a=h?a.add(e):a.delete(e)):(s=s.delete(e),a=a.delete(e)))})),null!==this.query.limit)for(;s.size>this.query.limit;){const e="F"===this.query.limitType?s.last():s.first();s=s.delete(e.key),a=a.delete(e.key),n.track({type:1,doc:e})}return{Ra:s,fa:n,ns:i,mutatedKeys:a}}ga(e,t){return e.hasLocalMutations&&t.hasCommittedMutations&&!t.hasLocalMutations}applyChanges(e,t,n,r){const a=this.Ra;this.Ra=e.Ra,this.mutatedKeys=e.mutatedKeys;const s=e.fa.G_();s.sort(((e,t)=>function(e,t){const n=e=>{switch(e){case 0:return 1;case 2:case 3:return 2;case 1:return 0;default:return rd()}};return n(e)-n(t)}(e.type,t.type)||this.Aa(e.doc,t.doc))),this.pa(n),r=null!=r&&r;const i=t&&!r?this.ya():[],o=0===this.da.size&&this.current&&!r?1:0,l=o!==this.Ea;return this.Ea=o,0!==s.length||l?{snapshot:new Xg(this.query,e.Ra,a,s,e.mutatedKeys,0===o,l,!1,!!n&&n.resumeToken.approximateByteSize()>0),wa:i}:{wa:i}}Z_(e){return this.current&&"Offline"===e?(this.current=!1,this.applyChanges({Ra:this.Ra,fa:new Yg,mutatedKeys:this.mutatedKeys,ns:!1},!1)):{wa:[]}}Sa(e){return!this.Ta.has(e)&&!!this.Ra.has(e)&&!this.Ra.get(e).hasLocalMutations}pa(e){e&&(e.addedDocuments.forEach((e=>this.Ta=this.Ta.add(e))),e.modifiedDocuments.forEach((e=>{})),e.removedDocuments.forEach((e=>this.Ta=this.Ta.delete(e))),this.current=e.current)}ya(){if(!this.current)return[];const e=this.da;this.da=Dp(),this.Ra.forEach((e=>{this.Sa(e.key)&&(this.da=this.da.add(e.key))}));const t=[];return e.forEach((e=>{this.da.has(e)||t.push(new uy(e))})),this.da.forEach((n=>{e.has(n)||t.push(new ly(n))})),t}ba(e){this.Ta=e.Ts,this.da=Dp();const t=this.ma(e.documents);return this.applyChanges(t,!0)}Da(){return Xg.fromInitialDocuments(this.query,this.Ra,this.mutatedKeys,0===this.Ea,this.hasCachedResults)}}class dy{constructor(e,t,n){this.query=e,this.targetId=t,this.view=n}}class hy{constructor(e){this.key=e,this.va=!1}}class py{constructor(e,t,n,r,a,s){this.localStore=e,this.remoteStore=t,this.eventManager=n,this.sharedClientState=r,this.currentUser=a,this.maxConcurrentLimboResolutions=s,this.Ca={},this.Fa=new kp((e=>gp(e)),mp),this.Ma=new Map,this.xa=new Set,this.Oa=new Xd(Cd.comparator),this.Na=new Map,this.La=new _m,this.Ba={},this.ka=new Map,this.qa=Sm.kn(),this.onlineState="Unknown",this.Qa=void 0}get isPrimaryClient(){return!0===this.Qa}}async function fy(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=Fy(e);let a;const s=r.Fa.get(t);return s?(r.sharedClientState.addLocalQueryTarget(s.targetId),a=s.view.Da()):a=await gy(r,t,n,!0),a}async function my(e,t){const n=Fy(e);await gy(n,t,!0,!1)}async function gy(e,t,n,r){const a=await Km(e.localStore,hp(t)),s=a.targetId,i=n?e.sharedClientState.addLocalQueryTarget(s):"not-current";let o;return r&&(o=await yy(e,t,s,"current"===i,a.resumeToken)),e.isPrimaryClient&&n&&vg(e.remoteStore,a),o}async function yy(e,t,n,r,a){e.Ka=(t,n,r)=>async function(e,t,n,r){let a=t.view.ma(n);a.ns&&(a=await Xm(e.localStore,t.query,!1).then((e=>{let{documents:n}=e;return t.view.ma(n,a)})));const s=r&&r.targetChanges.get(t.targetId),i=r&&null!=r.targetMismatches.get(t.targetId),o=t.view.applyChanges(a,e.isPrimaryClient,s,i);return Ey(e,t.targetId,o.wa),o.snapshot}(e,t,n,r);const s=await Xm(e.localStore,t,!0),i=new cy(t,s.Ts),o=i.ma(s.documents),l=_f.createSynthesizedTargetChangeForCurrentChange(n,r&&"Offline"!==e.onlineState,a),u=i.applyChanges(o,e.isPrimaryClient,l);Ey(e,n,u.wa);const c=new dy(t,n,i);return e.Fa.set(t,c),e.Ma.has(n)?e.Ma.get(n).push(t):e.Ma.set(n,[t]),u.snapshot}async function by(e,t,n){const r=sd(e),a=r.Fa.get(t),s=r.Ma.get(a.targetId);if(s.length>1)return r.Ma.set(a.targetId,s.filter((e=>!mp(e,t)))),void r.Fa.delete(t);r.isPrimaryClient?(r.sharedClientState.removeLocalQueryTarget(a.targetId),r.sharedClientState.isActiveQueryTarget(a.targetId)||await Ym(r.localStore,a.targetId,!1).then((()=>{r.sharedClientState.clearQueryState(a.targetId),n&&xg(r.remoteStore,a.targetId),Cy(r,a.targetId)})).catch(Fd)):(Cy(r,a.targetId),await Ym(r.localStore,a.targetId,!0))}async function vy(e,t){const n=sd(e),r=n.Fa.get(t),a=n.Ma.get(r.targetId);n.isPrimaryClient&&1===a.length&&(n.sharedClientState.removeLocalQueryTarget(r.targetId),xg(n.remoteStore,r.targetId))}async function xy(e,t){const n=sd(e);try{const e=await function(e,t){const n=sd(e),r=t.snapshotVersion;let a=n.os;return n.persistence.runTransaction("Apply remote event","readwrite-primary",(e=>{const s=n.cs.newChangeBuffer({trackRemovals:!0});a=n.os;const i=[];t.targetChanges.forEach(((s,o)=>{const l=a.get(o);if(!l)return;i.push(n.Ur.removeMatchingKeys(e,s.removedDocuments,o).next((()=>n.Ur.addMatchingKeys(e,s.addedDocuments,o))));let u=l.withSequenceNumber(e.currentSequenceNumber);null!==t.targetMismatches.get(o)?u=u.withResumeToken(rh.EMPTY_BYTE_STRING,kd.min()).withLastLimboFreeSnapshotVersion(kd.min()):s.resumeToken.approximateByteSize()>0&&(u=u.withResumeToken(s.resumeToken,r)),a=a.insert(o,u),function(e,t,n){return 0===e.resumeToken.approximateByteSize()||t.snapshotVersion.toMicroseconds()-e.snapshotVersion.toMicroseconds()>=3e8||n.addedDocuments.size+n.modifiedDocuments.size+n.removedDocuments.size>0}(l,u,s)&&i.push(n.Ur.updateTargetData(e,u))}));let o=Ip(),l=Dp();if(t.documentUpdates.forEach((r=>{t.resolvedLimboDocuments.has(r)&&i.push(n.persistence.referenceDelegate.updateLimboDocument(e,r))})),i.push(Hm(e,s,t.documentUpdates).next((e=>{o=e.Ps,l=e.Is}))),!r.isEqual(kd.min())){const t=n.Ur.getLastRemoteSnapshotVersion(e).next((t=>n.Ur.setTargetsMetadata(e,e.currentSequenceNumber,r)));i.push(t)}return Od.waitFor(i).next((()=>s.apply(e))).next((()=>n.localDocuments.getLocalViewOfDocuments(e,o,l))).next((()=>o))})).then((e=>(n.os=a,e)))}(n.localStore,t);t.targetChanges.forEach(((e,t)=>{const r=n.Na.get(t);r&&(ad(e.addedDocuments.size+e.modifiedDocuments.size+e.removedDocuments.size<=1),e.addedDocuments.size>0?r.va=!0:e.modifiedDocuments.size>0?ad(r.va):e.removedDocuments.size>0&&(ad(r.va),r.va=!1))})),await Ry(n,e,t)}catch(e){await Fd(e)}}function wy(e,t,n){const r=sd(e);if(r.isPrimaryClient&&0===n||!r.isPrimaryClient&&1===n){const e=[];r.Fa.forEach(((n,r)=>{const a=r.view.Z_(t);a.snapshot&&e.push(a.snapshot)})),function(e,t){const n=sd(e);n.onlineState=t;let r=!1;n.queries.forEach(((e,n)=>{for(const a of n.j_)a.Z_(t)&&(r=!0)})),r&&ay(n)}(r.eventManager,t),e.length&&r.Ca.d_(e),r.onlineState=t,r.isPrimaryClient&&r.sharedClientState.setOnlineState(t)}}async function ky(e,t,n){const r=sd(e);r.sharedClientState.updateQueryState(t,"rejected",n);const a=r.Na.get(t),s=a&&a.key;if(s){let e=new Xd(Cd.comparator);e=e.insert(s,Rh.newNoDocument(s,kd.min()));const n=Dp().add(s),a=new Ef(kd.min(),new Map,new Xd(vd),e,n);await xy(r,a),r.Oa=r.Oa.remove(s),r.Na.delete(t),$y(r)}else await Ym(r.localStore,t,!1).then((()=>Cy(r,t,n))).catch(Fd)}async function Sy(e,t){const n=sd(e),r=t.batch.batchId;try{const e=await function(e,t){const n=sd(e);return n.persistence.runTransaction("Acknowledge batch","readwrite-primary",(e=>{const r=t.batch.keys(),a=n.cs.newChangeBuffer({trackRemovals:!0});return function(e,t,n,r){const a=n.batch,s=a.keys();let i=Od.resolve();return s.forEach((e=>{i=i.next((()=>r.getEntry(t,e))).next((t=>{const s=n.docVersions.get(e);ad(null!==s),t.version.compareTo(s)<0&&(a.applyToRemoteDocument(t,n),t.isValidDocument()&&(t.setReadTime(n.commitVersion),r.addEntry(t)))}))})),i.next((()=>e.mutationQueue.removeMutationBatch(t,a)))}(n,e,t,a).next((()=>a.apply(e))).next((()=>n.mutationQueue.performConsistencyCheck(e))).next((()=>n.documentOverlayCache.removeOverlaysForBatchId(e,r,t.batch.batchId))).next((()=>n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e,function(e){let t=Dp();for(let n=0;n<e.mutationResults.length;++n)e.mutationResults[n].transformResults.length>0&&(t=t.add(e.batch.mutations[n].key));return t}(t)))).next((()=>n.localDocuments.getDocuments(e,r)))}))}(n.localStore,t);Ny(n,r,null),Ty(n,r),n.sharedClientState.updateMutationState(r,"acknowledged"),await Ry(n,e)}catch(e){await Fd(e)}}async function Iy(e,t,n){const r=sd(e);try{const e=await function(e,t){const n=sd(e);return n.persistence.runTransaction("Reject batch","readwrite-primary",(e=>{let r;return n.mutationQueue.lookupMutationBatch(e,t).next((t=>(ad(null!==t),r=t.keys(),n.mutationQueue.removeMutationBatch(e,t)))).next((()=>n.mutationQueue.performConsistencyCheck(e))).next((()=>n.documentOverlayCache.removeOverlaysForBatchId(e,r,t))).next((()=>n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(e,r))).next((()=>n.localDocuments.getDocuments(e,r)))}))}(r.localStore,t);Ny(r,t,n),Ty(r,t),r.sharedClientState.updateMutationState(t,"rejected",n),await Ry(r,e)}catch(n){await Fd(n)}}function Ty(e,t){(e.ka.get(t)||[]).forEach((e=>{e.resolve()})),e.ka.delete(t)}function Ny(e,t,n){const r=sd(e);let a=r.Ba[r.currentUser.toKey()];if(a){const e=a.get(t);e&&(n?e.reject(n):e.resolve(),a=a.remove(t)),r.Ba[r.currentUser.toKey()]=a}}function Cy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;e.sharedClientState.removeLocalQueryTarget(t);for(const r of e.Ma.get(t))e.Fa.delete(r),n&&e.Ca.$a(r,n);e.Ma.delete(t),e.isPrimaryClient&&e.La.gr(t).forEach((t=>{e.La.containsKey(t)||Ay(e,t)}))}function Ay(e,t){e.xa.delete(t.path.canonicalString());const n=e.Oa.get(t);null!==n&&(xg(e.remoteStore,n),e.Oa=e.Oa.remove(t),e.Na.delete(n),$y(e))}function Ey(e,t,n){for(const r of n)r instanceof ly?(e.La.addReference(r.key,t),_y(e,r)):r instanceof uy?(Jc("SyncEngine","Document no longer in limbo: "+r.key),e.La.removeReference(r.key,t),e.La.containsKey(r.key)||Ay(e,r.key)):rd()}function _y(e,t){const n=t.key,r=n.path.canonicalString();e.Oa.get(n)||e.xa.has(r)||(Jc("SyncEngine","New document in limbo: "+n),e.xa.add(r),$y(e))}function $y(e){for(;e.xa.size>0&&e.Oa.size<e.maxConcurrentLimboResolutions;){const t=e.xa.values().next().value;e.xa.delete(t);const n=new Cd(Id.fromString(t)),r=e.qa.next();e.Na.set(r,new hy(n)),e.Oa=e.Oa.insert(n,r),vg(e.remoteStore,new gm(hp(lp(n.path)),r,"TargetPurposeLimboResolution",zd.oe))}}async function Ry(e,t,n){const r=sd(e),a=[],s=[],i=[];r.Fa.isEmpty()||(r.Fa.forEach(((e,o)=>{i.push(r.Ka(o,t,n).then((e=>{var t;if((e||n)&&r.isPrimaryClient){const a=e?!e.fromCache:null===(t=null==n?void 0:n.targetChanges.get(o.targetId))||void 0===t?void 0:t.current;r.sharedClientState.updateQueryState(o.targetId,a?"current":"not-current")}if(e){a.push(e);const t=zm.Wi(o.targetId,e);s.push(t)}})))})),await Promise.all(i),r.Ca.d_(a),await async function(e,t){const n=sd(e);try{await n.persistence.runTransaction("notifyLocalViewChanges","readwrite",(e=>Od.forEach(t,(t=>Od.forEach(t.$i,(r=>n.persistence.referenceDelegate.addReference(e,t.targetId,r))).next((()=>Od.forEach(t.Ui,(r=>n.persistence.referenceDelegate.removeReference(e,t.targetId,r)))))))))}catch(e){if(!Ld(e))throw e;Jc("LocalStore","Failed to update sequence numbers: "+e)}for(const r of t){const e=r.targetId;if(!r.fromCache){const t=n.os.get(e),r=t.snapshotVersion,a=t.withLastLimboFreeSnapshotVersion(r);n.os=n.os.insert(e,a)}}}(r.localStore,s))}async function Dy(e,t){const n=sd(e);if(!n.currentUser.isEqual(t)){Jc("SyncEngine","User change. New user:",t.toKey());const e=await jm(n.localStore,t);n.currentUser=t,function(e,t){e.ka.forEach((e=>{e.forEach((e=>{e.reject(new od(id.CANCELLED,t))}))})),e.ka.clear()}(n,"'waitForPendingWrites' promise is rejected due to a user change."),n.sharedClientState.handleUserChange(t,e.removedBatchIds,e.addedBatchIds),await Ry(n,e.hs)}}function My(e,t){const n=sd(e),r=n.Na.get(t);if(r&&r.va)return Dp().add(r.key);{let e=Dp();const r=n.Ma.get(t);if(!r)return e;for(const t of r){const r=n.Fa.get(t);e=e.unionWith(r.view.Va)}return e}}function Fy(e){const t=sd(e);return t.remoteStore.remoteSyncer.applyRemoteEvent=xy.bind(null,t),t.remoteStore.remoteSyncer.getRemoteKeysForTarget=My.bind(null,t),t.remoteStore.remoteSyncer.rejectListen=ky.bind(null,t),t.Ca.d_=ny.bind(null,t.eventManager),t.Ca.$a=ry.bind(null,t.eventManager),t}function Oy(e){const t=sd(e);return t.remoteStore.remoteSyncer.applySuccessfulWrite=Sy.bind(null,t),t.remoteStore.remoteSyncer.rejectFailedWrite=Iy.bind(null,t),t}class Py{constructor(){this.synchronizeTabs=!1}async initialize(e){this.serializer=ug(e.databaseInfo.databaseId),this.sharedClientState=this.createSharedClientState(e),this.persistence=this.createPersistence(e),await this.persistence.start(),this.localStore=this.createLocalStore(e),this.gcScheduler=this.createGarbageCollectionScheduler(e,this.localStore),this.indexBackfillerScheduler=this.createIndexBackfillerScheduler(e,this.localStore)}createGarbageCollectionScheduler(e,t){return null}createIndexBackfillerScheduler(e,t){return null}createLocalStore(e){return Um(this.persistence,new Vm,e.initialUser,this.serializer)}createPersistence(e){return new Om(Lm.Zr,this.serializer)}createSharedClientState(e){return new Jm}async terminate(){var e,t;null===(e=this.gcScheduler)||void 0===e||e.stop(),null===(t=this.indexBackfillerScheduler)||void 0===t||t.stop(),this.sharedClientState.shutdown(),await this.persistence.shutdown()}}class Ly{async initialize(e,t){this.localStore||(this.localStore=e.localStore,this.sharedClientState=e.sharedClientState,this.datastore=this.createDatastore(t),this.remoteStore=this.createRemoteStore(t),this.eventManager=this.createEventManager(t),this.syncEngine=this.createSyncEngine(t,!e.synchronizeTabs),this.sharedClientState.onlineStateHandler=e=>wy(this.syncEngine,e,1),this.remoteStore.remoteSyncer.handleCredentialChange=Dy.bind(null,this.syncEngine),await Ug(this.remoteStore,this.syncEngine.isPrimaryClient))}createEventManager(e){return new Zg}createDatastore(e){const t=ug(e.databaseInfo.databaseId),n=function(e){return new og(e)}(e.databaseInfo);return function(e,t,n,r){return new fg(e,t,n,r)}(e.authCredentials,e.appCheckCredentials,n,t)}createRemoteStore(e){return function(e,t,n,r,a){return new gg(e,t,n,r,a)}(this.localStore,this.datastore,e.asyncQueue,(e=>wy(this.syncEngine,e,0)),tg.D()?new tg:new eg)}createSyncEngine(e,t){return function(e,t,n,r,a,s,i){const o=new py(e,t,n,r,a,s);return i&&(o.Qa=!0),o}(this.localStore,this.remoteStore,this.eventManager,this.sharedClientState,e.initialUser,e.maxConcurrentLimboResolutions,t)}async terminate(){var e,t;await async function(e){const t=sd(e);Jc("RemoteStore","RemoteStore shutting down."),t.L_.add(5),await bg(t),t.k_.shutdown(),t.q_.set("Unknown")}(this.remoteStore),null===(e=this.datastore)||void 0===e||e.terminate(),null===(t=this.eventManager)||void 0===t||t.terminate()}}class zy{constructor(e){this.observer=e,this.muted=!1}next(e){this.observer.next&&this.Ga(this.observer.next,e)}error(e){this.observer.error?this.Ga(this.observer.error,e):ed("Uncaught Error in snapshot listener:",e.toString())}za(){this.muted=!0}Ga(e,t){this.muted||setTimeout((()=>{this.muted||e(t)}),0)}}class By{constructor(e,t,n,r){this.authCredentials=e,this.appCheckCredentials=t,this.asyncQueue=n,this.databaseInfo=r,this.user=Yc.UNAUTHENTICATED,this.clientId=bd.newId(),this.authCredentialListener=()=>Promise.resolve(),this.appCheckCredentialListener=()=>Promise.resolve(),this.authCredentials.start(n,(async e=>{Jc("FirestoreClient","Received user=",e.uid),await this.authCredentialListener(e),this.user=e})),this.appCheckCredentials.start(n,(e=>(Jc("FirestoreClient","Received new app check token=",e),this.appCheckCredentialListener(e,this.user))))}get configuration(){return{asyncQueue:this.asyncQueue,databaseInfo:this.databaseInfo,clientId:this.clientId,authCredentials:this.authCredentials,appCheckCredentials:this.appCheckCredentials,initialUser:this.user,maxConcurrentLimboResolutions:100}}setCredentialChangeListener(e){this.authCredentialListener=e}setAppCheckTokenChangeListener(e){this.appCheckCredentialListener=e}verifyNotTerminated(){if(this.asyncQueue.isShuttingDown)throw new od(id.FAILED_PRECONDITION,"The client has already been terminated.")}terminate(){this.asyncQueue.enterRestrictedMode();const e=new ld;return this.asyncQueue.enqueueAndForgetEvenWhileRestricted((async()=>{try{this._onlineComponents&&await this._onlineComponents.terminate(),this._offlineComponents&&await this._offlineComponents.terminate(),this.authCredentials.shutdown(),this.appCheckCredentials.shutdown(),e.resolve()}catch(t){const n=qg(t,"Failed to shutdown persistence");e.reject(n)}})),e.promise}}async function Vy(e,t){e.asyncQueue.verifyOperationInProgress(),Jc("FirestoreClient","Initializing OfflineComponentProvider");const n=e.configuration;await t.initialize(n);let r=n.initialUser;e.setCredentialChangeListener((async e=>{r.isEqual(e)||(await jm(t.localStore,e),r=e)})),t.persistence.setDatabaseDeletedListener((()=>e.terminate())),e._offlineComponents=t}async function Wy(e,t){e.asyncQueue.verifyOperationInProgress();const n=await jy(e);Jc("FirestoreClient","Initializing OnlineComponentProvider"),await t.initialize(n,e.configuration),e.setCredentialChangeListener((e=>Wg(t.remoteStore,e))),e.setAppCheckTokenChangeListener(((e,n)=>Wg(t.remoteStore,n))),e._onlineComponents=t}function Uy(e){return"FirebaseError"===e.name?e.code===id.FAILED_PRECONDITION||e.code===id.UNIMPLEMENTED:!("undefined"!=typeof DOMException&&e instanceof DOMException)||22===e.code||20===e.code||11===e.code}async function jy(e){if(!e._offlineComponents)if(e._uninitializedComponentsProvider){Jc("FirestoreClient","Using user provided OfflineComponentProvider");try{await Vy(e,e._uninitializedComponentsProvider._offline)}catch(t){const n=t;if(!Uy(n))throw n;td("Error using user provided cache. Falling back to memory cache: "+n),await Vy(e,new Py)}}else Jc("FirestoreClient","Using default OfflineComponentProvider"),await Vy(e,new Py);return e._offlineComponents}async function Gy(e){return e._onlineComponents||(e._uninitializedComponentsProvider?(Jc("FirestoreClient","Using user provided OnlineComponentProvider"),await Wy(e,e._uninitializedComponentsProvider._online)):(Jc("FirestoreClient","Using default OnlineComponentProvider"),await Wy(e,new Ly))),e._onlineComponents}function Hy(e){return Gy(e).then((e=>e.syncEngine))}async function qy(e){const t=await Gy(e),n=t.eventManager;return n.onListen=fy.bind(null,t.syncEngine),n.onUnlisten=by.bind(null,t.syncEngine),n.onFirstRemoteStoreListen=my.bind(null,t.syncEngine),n.onLastRemoteStoreUnlisten=vy.bind(null,t.syncEngine),n}function Ky(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new ld;return e.asyncQueue.enqueueAndForget((async()=>function(e,t,n,r,a){const s=new zy({next:s=>{t.enqueueAndForget((()=>ty(e,i)));const o=s.docs.has(n);!o&&s.fromCache?a.reject(new od(id.UNAVAILABLE,"Failed to get document because the client is offline.")):o&&s.fromCache&&r&&"server"===r.source?a.reject(new od(id.UNAVAILABLE,'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')):a.resolve(s)},error:e=>a.reject(e)}),i=new oy(lp(n.path),s,{includeMetadataChanges:!0,_a:!0});return ey(e,i)}(await qy(e),e.asyncQueue,t,n,r))),r.promise}function Yy(e){const t={};return void 0!==e.timeoutSeconds&&(t.timeoutSeconds=e.timeoutSeconds),t}const Xy=new Map;function Qy(e,t,n){if(!n)throw new od(id.INVALID_ARGUMENT,`Function ${e}() cannot be called with an empty ${t}.`)}function Zy(e){if(!Cd.isDocumentKey(e))throw new od(id.INVALID_ARGUMENT,`Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`)}function Jy(e){if(Cd.isDocumentKey(e))throw new od(id.INVALID_ARGUMENT,`Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`)}function eb(e){if(void 0===e)return"undefined";if(null===e)return"null";if("string"==typeof e)return e.length>20&&(e=`${e.substring(0,20)}...`),JSON.stringify(e);if("number"==typeof e||"boolean"==typeof e)return""+e;if("object"==typeof e){if(e instanceof Array)return"an array";{const t=function(e){return e.constructor?e.constructor.name:null}(e);return t?`a custom ${t} object`:"an object"}}return"function"==typeof e?"a function":rd()}function tb(e,t){if("_delegate"in e&&(e=e._delegate),!(e instanceof t)){if(t.name===e.constructor.name)throw new od(id.INVALID_ARGUMENT,"Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");{const n=eb(e);throw new od(id.INVALID_ARGUMENT,`Expected type '${t.name}', but it was: ${n}`)}}return e}class nb{constructor(e){var t,n;if(void 0===e.host){if(void 0!==e.ssl)throw new od(id.INVALID_ARGUMENT,"Can't provide ssl option if host option is not set");this.host="firestore.googleapis.com",this.ssl=!0}else this.host=e.host,this.ssl=null===(t=e.ssl)||void 0===t||t;if(this.credentials=e.credentials,this.ignoreUndefinedProperties=!!e.ignoreUndefinedProperties,this.localCache=e.localCache,void 0===e.cacheSizeBytes)this.cacheSizeBytes=41943040;else{if(-1!==e.cacheSizeBytes&&e.cacheSizeBytes<1048576)throw new od(id.INVALID_ARGUMENT,"cacheSizeBytes must be at least 1048576");this.cacheSizeBytes=e.cacheSizeBytes}(function(e,t,n,r){if(!0===t&&!0===r)throw new od(id.INVALID_ARGUMENT,`${e} and ${n} cannot be used together.`)})("experimentalForceLongPolling",e.experimentalForceLongPolling,"experimentalAutoDetectLongPolling",e.experimentalAutoDetectLongPolling),this.experimentalForceLongPolling=!!e.experimentalForceLongPolling,this.experimentalForceLongPolling?this.experimentalAutoDetectLongPolling=!1:void 0===e.experimentalAutoDetectLongPolling?this.experimentalAutoDetectLongPolling=!0:this.experimentalAutoDetectLongPolling=!!e.experimentalAutoDetectLongPolling,this.experimentalLongPollingOptions=Yy(null!==(n=e.experimentalLongPollingOptions)&&void 0!==n?n:{}),function(e){if(void 0!==e.timeoutSeconds){if(isNaN(e.timeoutSeconds))throw new od(id.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (must not be NaN)`);if(e.timeoutSeconds<5)throw new od(id.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (minimum allowed value is 5)`);if(e.timeoutSeconds>30)throw new od(id.INVALID_ARGUMENT,`invalid long polling timeout: ${e.timeoutSeconds} (maximum allowed value is 30)`)}}(this.experimentalLongPollingOptions),this.useFetchStreams=!!e.useFetchStreams}isEqual(e){return this.host===e.host&&this.ssl===e.ssl&&this.credentials===e.credentials&&this.cacheSizeBytes===e.cacheSizeBytes&&this.experimentalForceLongPolling===e.experimentalForceLongPolling&&this.experimentalAutoDetectLongPolling===e.experimentalAutoDetectLongPolling&&function(e,t){return e.timeoutSeconds===t.timeoutSeconds}(this.experimentalLongPollingOptions,e.experimentalLongPollingOptions)&&this.ignoreUndefinedProperties===e.ignoreUndefinedProperties&&this.useFetchStreams===e.useFetchStreams}}class rb{constructor(e,t,n,r){this._authCredentials=e,this._appCheckCredentials=t,this._databaseId=n,this._app=r,this.type="firestore-lite",this._persistenceKey="(lite)",this._settings=new nb({}),this._settingsFrozen=!1}get app(){if(!this._app)throw new od(id.FAILED_PRECONDITION,"Firestore was not initialized using the Firebase SDK. 'app' is not available");return this._app}get _initialized(){return this._settingsFrozen}get _terminated(){return void 0!==this._terminateTask}_setSettings(e){if(this._settingsFrozen)throw new od(id.FAILED_PRECONDITION,"Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");this._settings=new nb(e),void 0!==e.credentials&&(this._authCredentials=function(e){if(!e)return new cd;switch(e.type){case"firstParty":return new fd(e.sessionIndex||"0",e.iamToken||null,e.authTokenFactory||null);case"provider":return e.client;default:throw new od(id.INVALID_ARGUMENT,"makeAuthCredentialsProvider failed due to invalid credential type")}}(e.credentials))}_getSettings(){return this._settings}_freezeSettings(){return this._settingsFrozen=!0,this._settings}_delete(){return this._terminateTask||(this._terminateTask=this._terminate()),this._terminateTask}toJSON(){return{app:this._app,databaseId:this._databaseId,settings:this._settings}}_terminate(){return function(e){const t=Xy.get(e);t&&(Jc("ComponentProvider","Removing Datastore"),Xy.delete(e),t.terminate())}(this),Promise.resolve()}}function ab(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};var a;const s=(e=tb(e,rb))._getSettings(),i=`${t}:${n}`;if("firestore.googleapis.com"!==s.host&&s.host!==i&&td("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."),e._setSettings(Object.assign(Object.assign({},s),{host:i,ssl:!1})),r.mockUserToken){let t,n;if("string"==typeof r.mockUserToken)t=r.mockUserToken,n=Yc.MOCK_USER;else{t=function(e,t){if(e.uid)throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');const n=t||"demo-project",r=e.iat||0,a=e.sub||e.user_id;if(!a)throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");const s=Object.assign({iss:`https://securetoken.google.com/${n}`,aud:n,iat:r,exp:r+3600,auth_time:r,sub:a,user_id:a,firebase:{sign_in_provider:"custom",identities:{}}},e);return[Ul(JSON.stringify({alg:"none",type:"JWT"})),Ul(JSON.stringify(s)),""].join(".")}(r.mockUserToken,null===(a=e._app)||void 0===a?void 0:a.options.projectId);const s=r.mockUserToken.sub||r.mockUserToken.user_id;if(!s)throw new od(id.INVALID_ARGUMENT,"mockUserToken must contain 'sub' or 'user_id' field!");n=new Yc(s)}e._authCredentials=new dd(new ud(t,n))}}class sb{constructor(e,t,n){this.converter=t,this._query=n,this.type="query",this.firestore=e}withConverter(e){return new sb(this.firestore,e,this._query)}}class ib{constructor(e,t,n){this.converter=t,this._key=n,this.type="document",this.firestore=e}get _path(){return this._key.path}get id(){return this._key.path.lastSegment()}get path(){return this._key.path.canonicalString()}get parent(){return new ob(this.firestore,this.converter,this._key.path.popLast())}withConverter(e){return new ib(this.firestore,e,this._key)}}class ob extends sb{constructor(e,t,n){super(e,t,lp(n)),this._path=n,this.type="collection"}get id(){return this._query.path.lastSegment()}get path(){return this._query.path.canonicalString()}get parent(){const e=this._path.popLast();return e.isEmpty()?null:new ib(this.firestore,null,new Cd(e))}withConverter(e){return new ob(this.firestore,e,this._path)}}function lb(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),a=2;a<n;a++)r[a-2]=arguments[a];if(e=au(e),Qy("collection","path",t),e instanceof rb){const n=Id.fromString(t,...r);return Jy(n),new ob(e,null,n)}{if(!(e instanceof ib||e instanceof ob))throw new od(id.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const n=e._path.child(Id.fromString(t,...r));return Jy(n),new ob(e.firestore,null,n)}}function ub(e,t){for(var n=arguments.length,r=new Array(n>2?n-2:0),a=2;a<n;a++)r[a-2]=arguments[a];if(e=au(e),1===arguments.length&&(t=bd.newId()),Qy("doc","path",t),e instanceof rb){const n=Id.fromString(t,...r);return Zy(n),new ib(e,null,new Cd(n))}{if(!(e instanceof ib||e instanceof ob))throw new od(id.INVALID_ARGUMENT,"Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");const n=e._path.child(Id.fromString(t,...r));return Zy(n),new ib(e.firestore,e instanceof ob?e.converter:null,new Cd(n))}}class cb{constructor(){this.au=Promise.resolve(),this.uu=[],this.cu=!1,this.lu=[],this.hu=null,this.Pu=!1,this.Iu=!1,this.Tu=[],this.t_=new cg(this,"async_queue_retry"),this.Eu=()=>{const e=lg();e&&Jc("AsyncQueue","Visibility state changed to "+e.visibilityState),this.t_.jo()};const e=lg();e&&"function"==typeof e.addEventListener&&e.addEventListener("visibilitychange",this.Eu)}get isShuttingDown(){return this.cu}enqueueAndForget(e){this.enqueue(e)}enqueueAndForgetEvenWhileRestricted(e){this.du(),this.Au(e)}enterRestrictedMode(e){if(!this.cu){this.cu=!0,this.Iu=e||!1;const t=lg();t&&"function"==typeof t.removeEventListener&&t.removeEventListener("visibilitychange",this.Eu)}}enqueue(e){if(this.du(),this.cu)return new Promise((()=>{}));const t=new ld;return this.Au((()=>this.cu&&this.Iu?Promise.resolve():(e().then(t.resolve,t.reject),t.promise))).then((()=>t.promise))}enqueueRetryable(e){this.enqueueAndForget((()=>(this.uu.push(e),this.Ru())))}async Ru(){if(0!==this.uu.length){try{await this.uu[0](),this.uu.shift(),this.t_.reset()}catch(KR){if(!Ld(KR))throw KR;Jc("AsyncQueue","Operation failed with retryable error: "+KR)}this.uu.length>0&&this.t_.Go((()=>this.Ru()))}}Au(e){const t=this.au.then((()=>(this.Pu=!0,e().catch((e=>{this.hu=e,this.Pu=!1;const t=function(e){let t=e.message||"";return e.stack&&(t=e.stack.includes(e.message)?e.stack:e.message+"\n"+e.stack),t}(e);throw ed("INTERNAL UNHANDLED ERROR: ",t),e})).then((e=>(this.Pu=!1,e))))));return this.au=t,t}enqueueAfterDelay(e,t,n){this.du(),this.Tu.indexOf(e)>-1&&(t=0);const r=Hg.createAndSchedule(this,e,t,n,(e=>this.Vu(e)));return this.lu.push(r),r}du(){this.hu&&rd()}verifyOperationInProgress(){}async mu(){let e;do{e=this.au,await e}while(e!==this.au)}fu(e){for(const t of this.lu)if(t.timerId===e)return!0;return!1}gu(e){return this.mu().then((()=>{this.lu.sort(((e,t)=>e.targetTimeMs-t.targetTimeMs));for(const t of this.lu)if(t.skipDelay(),"all"!==e&&t.timerId===e)break;return this.mu()}))}pu(e){this.Tu.push(e)}Vu(e){const t=this.lu.indexOf(e);this.lu.splice(t,1)}}class db extends rb{constructor(e,t,n,r){super(e,t,n,r),this.type="firestore",this._queue=new cb,this._persistenceKey=(null==r?void 0:r.name)||"[DEFAULT]"}_terminate(){return this._firestoreClient||pb(this),this._firestoreClient.terminate()}}function hb(e){return e._firestoreClient||pb(e),e._firestoreClient.verifyNotTerminated(),e._firestoreClient}function pb(e){var t,n,r;const a=e._freezeSettings(),s=function(e,t,n,r){return new dh(e,t,n,r.host,r.ssl,r.experimentalForceLongPolling,r.experimentalAutoDetectLongPolling,Yy(r.experimentalLongPollingOptions),r.useFetchStreams)}(e._databaseId,(null===(t=e._app)||void 0===t?void 0:t.options.appId)||"",e._persistenceKey,a);e._firestoreClient=new By(e._authCredentials,e._appCheckCredentials,e._queue,s),(null===(n=a.localCache)||void 0===n?void 0:n._offlineComponentProvider)&&(null===(r=a.localCache)||void 0===r?void 0:r._onlineComponentProvider)&&(e._firestoreClient._uninitializedComponentsProvider={_offlineKind:a.localCache.kind,_offline:a.localCache._offlineComponentProvider,_online:a.localCache._onlineComponentProvider})}class fb{constructor(e){this._byteString=e}static fromBase64String(e){try{return new fb(rh.fromBase64String(e))}catch(e){throw new od(id.INVALID_ARGUMENT,"Failed to construct data from Base64 string: "+e)}}static fromUint8Array(e){return new fb(rh.fromUint8Array(e))}toBase64(){return this._byteString.toBase64()}toUint8Array(){return this._byteString.toUint8Array()}toString(){return"Bytes(base64: "+this.toBase64()+")"}isEqual(e){return this._byteString.isEqual(e._byteString)}}class mb{constructor(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];for(let r=0;r<t.length;++r)if(0===t[r].length)throw new od(id.INVALID_ARGUMENT,"Invalid field name at argument $(i + 1). Field names must not be empty.");this._internalPath=new Nd(t)}isEqual(e){return this._internalPath.isEqual(e._internalPath)}}class gb{constructor(e){this._methodName=e}}class yb{constructor(e,t){if(!isFinite(e)||e<-90||e>90)throw new od(id.INVALID_ARGUMENT,"Latitude must be a number between -90 and 90, but was: "+e);if(!isFinite(t)||t<-180||t>180)throw new od(id.INVALID_ARGUMENT,"Longitude must be a number between -180 and 180, but was: "+t);this._lat=e,this._long=t}get latitude(){return this._lat}get longitude(){return this._long}isEqual(e){return this._lat===e._lat&&this._long===e._long}toJSON(){return{latitude:this._lat,longitude:this._long}}_compareTo(e){return vd(this._lat,e._lat)||vd(this._long,e._long)}}class bb{constructor(e){this._values=(e||[]).map((e=>e))}toArray(){return this._values.map((e=>e))}isEqual(e){return function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n])return!1;return!0}(this._values,e._values)}}const vb=/^__.*__$/;class xb{constructor(e,t,n){this.data=e,this.fieldMask=t,this.fieldTransforms=n}toMutation(e,t){return null!==this.fieldMask?new lf(e,this.data,this.fieldMask,t,this.fieldTransforms):new of(e,this.data,t,this.fieldTransforms)}}function wb(e){switch(e){case 0:case 2:case 1:return!0;case 3:case 4:return!1;default:throw rd()}}class kb{constructor(e,t,n,r,a,s){this.settings=e,this.databaseId=t,this.serializer=n,this.ignoreUndefinedProperties=r,void 0===a&&this.yu(),this.fieldTransforms=a||[],this.fieldMask=s||[]}get path(){return this.settings.path}get wu(){return this.settings.wu}Su(e){return new kb(Object.assign(Object.assign({},this.settings),e),this.databaseId,this.serializer,this.ignoreUndefinedProperties,this.fieldTransforms,this.fieldMask)}bu(e){var t;const n=null===(t=this.path)||void 0===t?void 0:t.child(e),r=this.Su({path:n,Du:!1});return r.vu(e),r}Cu(e){var t;const n=null===(t=this.path)||void 0===t?void 0:t.child(e),r=this.Su({path:n,Du:!1});return r.yu(),r}Fu(e){return this.Su({path:void 0,Du:!0})}Mu(e){return Db(e,this.settings.methodName,this.settings.xu||!1,this.path,this.settings.Ou)}contains(e){return void 0!==this.fieldMask.find((t=>e.isPrefixOf(t)))||void 0!==this.fieldTransforms.find((t=>e.isPrefixOf(t.field)))}yu(){if(this.path)for(let e=0;e<this.path.length;e++)this.vu(this.path.get(e))}vu(e){if(0===e.length)throw this.Mu("Document fields must not be empty");if(wb(this.wu)&&vb.test(e))throw this.Mu('Document fields cannot begin and end with "__"')}}class Sb{constructor(e,t,n){this.databaseId=e,this.ignoreUndefinedProperties=t,this.serializer=n||ug(e)}Nu(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return new kb({wu:e,methodName:t,Ou:n,path:Nd.emptyPath(),Du:!1,xu:r},this.databaseId,this.serializer,this.ignoreUndefinedProperties)}}function Ib(e){const t=e._freezeSettings(),n=ug(e._databaseId);return new Sb(e._databaseId,!!t.ignoreUndefinedProperties,n)}function Tb(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};const i=e.Nu(s.merge||s.mergeFields?2:0,t,n,a);Eb("Data must be an object, but it was:",i,r);const o=Cb(r,i);let l,u;if(s.merge)l=new th(i.fieldMask),u=i.fieldTransforms;else if(s.mergeFields){const e=[];for(const r of s.mergeFields){const a=_b(t,r,n);if(!i.contains(a))throw new od(id.INVALID_ARGUMENT,`Field '${a}' is specified in your field mask but missing from your input data.`);Mb(e,a)||e.push(a)}l=new th(e),u=i.fieldTransforms.filter((e=>l.covers(e.field)))}else l=null,u=i.fieldTransforms;return new xb(new _h(o),l,u)}function Nb(e,t){if(Ab(e=au(e)))return Eb("Unsupported field value:",t,e),Cb(e,t);if(e instanceof gb)return function(e,t){if(!wb(t.wu))throw t.Mu(`${e._methodName}() can only be used with update() and set()`);if(!t.path)throw t.Mu(`${e._methodName}() is not currently supported inside arrays`);const n=e._toFieldTransform(t);n&&t.fieldTransforms.push(n)}(e,t),null;if(void 0===e&&t.ignoreUndefinedProperties)return null;if(t.path&&t.fieldMask.push(t.path),e instanceof Array){if(t.settings.Du&&4!==t.wu)throw t.Mu("Nested arrays are not supported");return function(e,t){const n=[];let r=0;for(const a of e){let e=Nb(a,t.Fu(r));null==e&&(e={nullValue:"NULL_VALUE"}),n.push(e),r++}return{arrayValue:{values:n}}}(e,t)}return function(e,t){if(null===(e=au(e)))return{nullValue:"NULL_VALUE"};if("number"==typeof e)return Lp(t.serializer,e);if("boolean"==typeof e)return{booleanValue:e};if("string"==typeof e)return{stringValue:e};if(e instanceof Date){const n=wd.fromDate(e);return{timestampValue:Uf(t.serializer,n)}}if(e instanceof wd){const n=new wd(e.seconds,1e3*Math.floor(e.nanoseconds/1e3));return{timestampValue:Uf(t.serializer,n)}}if(e instanceof yb)return{geoPointValue:{latitude:e.latitude,longitude:e.longitude}};if(e instanceof fb)return{bytesValue:jf(t.serializer,e._byteString)};if(e instanceof ib){const n=t.databaseId,r=e.firestore._databaseId;if(!r.isEqual(n))throw t.Mu(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`);return{referenceValue:qf(e.firestore._databaseId||t.databaseId,e._key.path)}}if(e instanceof bb)return function(e,t){return{mapValue:{fields:{__type__:{stringValue:"__vector__"},value:{arrayValue:{values:e.toArray().map((e=>{if("number"!=typeof e)throw t.Mu("VectorValues must only contain numeric values.");return Op(t.serializer,e)}))}}}}}}(e,t);throw t.Mu(`Unsupported field value: ${eb(e)}`)}(e,t)}function Cb(e,t){const n={};return Yd(e)?t.path&&t.path.length>0&&t.fieldMask.push(t.path):Kd(e,((e,r)=>{const a=Nb(r,t.bu(e));null!=a&&(n[e]=a)})),{mapValue:{fields:n}}}function Ab(e){return!("object"!=typeof e||null===e||e instanceof Array||e instanceof Date||e instanceof wd||e instanceof yb||e instanceof fb||e instanceof ib||e instanceof gb||e instanceof bb)}function Eb(e,t,n){if(!Ab(n)||!function(e){return"object"==typeof e&&null!==e&&(Object.getPrototypeOf(e)===Object.prototype||null===Object.getPrototypeOf(e))}(n)){const r=eb(n);throw"an object"===r?t.Mu(e+" a custom object"):t.Mu(e+" "+r)}}function _b(e,t,n){if((t=au(t))instanceof mb)return t._internalPath;if("string"==typeof t)return Rb(e,t);throw Db("Field path arguments must be of type string or ",e,!1,void 0,n)}const $b=new RegExp("[~\\*/\\[\\]]");function Rb(e,t,n){if(t.search($b)>=0)throw Db(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`,e,!1,void 0,n);try{return new mb(...t.split("."))._internalPath}catch(gge){throw Db(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,e,!1,void 0,n)}}function Db(e,t,n,r,a){const s=r&&!r.isEmpty(),i=void 0!==a;let o=`Function ${t}() called with invalid data`;n&&(o+=" (via `toFirestore()`)"),o+=". ";let l="";return(s||i)&&(l+=" (found",s&&(l+=` in field ${r}`),i&&(l+=` in document ${a}`),l+=")"),new od(id.INVALID_ARGUMENT,o+e+l)}function Mb(e,t){return e.some((e=>e.isEqual(t)))}class Fb{constructor(e,t,n,r,a){this._firestore=e,this._userDataWriter=t,this._key=n,this._document=r,this._converter=a}get id(){return this._key.path.lastSegment()}get ref(){return new ib(this._firestore,this._converter,this._key)}exists(){return null!==this._document}data(){if(this._document){if(this._converter){const e=new Ob(this._firestore,this._userDataWriter,this._key,this._document,null);return this._converter.fromFirestore(e)}return this._userDataWriter.convertValue(this._document.data.value)}}get(e){if(this._document){const t=this._document.data.field(Pb("DocumentSnapshot.get",e));if(null!==t)return this._userDataWriter.convertValue(t)}}}class Ob extends Fb{data(){return super.data()}}function Pb(e,t){return"string"==typeof t?Rb(e,t):t instanceof mb?t._internalPath:t._delegate._internalPath}class Lb{convertValue(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"none";switch(fh(e)){case 0:return null;case 1:return e.booleanValue;case 2:return ih(e.integerValue||e.doubleValue);case 3:return this.convertTimestamp(e.timestampValue);case 4:return this.convertServerTimestamp(e,t);case 5:return e.stringValue;case 6:return this.convertBytes(oh(e.bytesValue));case 7:return this.convertReference(e.referenceValue);case 8:return this.convertGeoPoint(e.geoPointValue);case 9:return this.convertArray(e.arrayValue,t);case 11:return this.convertObject(e.mapValue,t);case 10:return this.convertVectorValue(e.mapValue);default:throw rd()}}convertObject(e,t){return this.convertObjectMap(e.fields,t)}convertObjectMap(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"none";const n={};return Kd(e,((e,r)=>{n[e]=this.convertValue(r,t)})),n}convertVectorValue(e){var t,n,r;const a=null===(r=null===(n=null===(t=e.fields)||void 0===t?void 0:t.value.arrayValue)||void 0===n?void 0:n.values)||void 0===r?void 0:r.map((e=>ih(e.doubleValue)));return new bb(a)}convertGeoPoint(e){return new yb(ih(e.latitude),ih(e.longitude))}convertArray(e,t){return(e.values||[]).map((e=>this.convertValue(e,t)))}convertServerTimestamp(e,t){switch(t){case"previous":const n=uh(e);return null==n?null:this.convertValue(n,t);case"estimate":return this.convertTimestamp(ch(e));default:return null}}convertTimestamp(e){const t=sh(e);return new wd(t.seconds,t.nanos)}convertDocumentKey(e,t){const n=Id.fromString(e);ad(mm(n));const r=new hh(n.get(1),n.get(3)),a=new Cd(n.popFirst(5));return r.isEqual(t)||ed(`Document ${a} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`),a}}function zb(e,t,n){let r;return r=e?n&&(n.merge||n.mergeFields)?e.toFirestore(t,n):e.toFirestore(t):t,r}class Bb{constructor(e,t){this.hasPendingWrites=e,this.fromCache=t}isEqual(e){return this.hasPendingWrites===e.hasPendingWrites&&this.fromCache===e.fromCache}}class Vb extends Fb{constructor(e,t,n,r,a,s){super(e,t,n,r,s),this._firestore=e,this._firestoreImpl=e,this.metadata=a}exists(){return super.exists()}data(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._document){if(this._converter){const t=new Wb(this._firestore,this._userDataWriter,this._key,this._document,this.metadata,null);return this._converter.fromFirestore(t,e)}return this._userDataWriter.convertValue(this._document.data.value,e.serverTimestamps)}}get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(this._document){const n=this._document.data.field(Pb("DocumentSnapshot.get",e));if(null!==n)return this._userDataWriter.convertValue(n,t.serverTimestamps)}}}class Wb extends Vb{data(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return super.data(e)}}class Ub extends Lb{constructor(e){super(),this.firestore=e}convertBytes(e){return new fb(e)}convertReference(e){const t=this.convertDocumentKey(e,this.firestore._databaseId);return new ib(this.firestore,null,t)}}function jb(e,t){const n=tb(e.firestore,db),r=ub(e),a=zb(e.converter,t);return Gb(n,[Tb(Ib(e.firestore),"addDoc",r._key,a,null!==e.converter,{}).toMutation(r._key,Zp.exists(!1))]).then((()=>r))}function Gb(e,t){return function(e,t){const n=new ld;return e.asyncQueue.enqueueAndForget((async()=>async function(e,t,n){const r=Oy(e);try{const e=await function(e,t){const n=sd(e),r=wd.now(),a=t.reduce(((e,t)=>e.add(t.key)),Dp());let s,i;return n.persistence.runTransaction("Locally write mutations","readwrite",(e=>{let o=Ip(),l=Dp();return n.cs.getEntries(e,a).next((e=>{o=e,o.forEach(((e,t)=>{t.isValidDocument()||(l=l.add(e))}))})).next((()=>n.localDocuments.getOverlayedDocuments(e,o))).next((a=>{s=a;const i=[];for(const e of t){const t=af(e,s.get(e.key).overlayedDocument);null!=t&&i.push(new lf(e.key,t,$h(t.value.mapValue),Zp.exists(!0)))}return n.mutationQueue.addMutationBatch(e,r,i,t)})).next((t=>{i=t;const r=t.applyToLocalDocumentSet(s,l);return n.documentOverlayCache.saveOverlays(e,t.batchId,r)}))})).then((()=>({batchId:i.batchId,changes:Cp(s)})))}(r.localStore,t);r.sharedClientState.addPendingMutation(e.batchId),function(e,t,n){let r=e.Ba[e.currentUser.toKey()];r||(r=new Xd(vd)),r=r.insert(t,n),e.Ba[e.currentUser.toKey()]=r}(r,e.batchId,n),await Ry(r,e.changes),await Dg(r.remoteStore)}catch(e){const t=qg(e,"Failed to persist write");n.reject(t)}}(await Hy(e),t,n))),n.promise}(hb(e),t)}function Hb(e,t,n){const r=n.docs.get(t._key),a=new Ub(e);return new Vb(e,a,t._key,r,new Bb(n.hasPendingWrites,n.fromCache),t.converter)}new WeakMap;!function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];!function(e){Xc=e}("10.13.1"),mc(new su("firestore",((e,n)=>{let{instanceIdentifier:r,options:a}=n;const s=e.getProvider("app").getImmediate(),i=new db(new hd(e.getProvider("auth-internal")),new gd(e.getProvider("app-check-internal")),function(e,t){if(!Object.prototype.hasOwnProperty.apply(e.options,["projectId"]))throw new od(id.INVALID_ARGUMENT,'"projectId" not provided in firebase.initializeApp.');return new hh(e.options.projectId,t)}(s,r),s);return a=Object.assign({useFetchStreams:t},a),i._setSettings(a),i}),"PUBLIC").setMultipleInstances(!0)),xc(Kc,"4.7.1",e),xc(Kc,"4.7.1","esm2017")}();xc("firebase","10.13.1","app");const qb={NODE_ENV:"production",PUBLIC_URL:"/auth-tfjs",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0,REACT_APP_API_KEY:"'AIzaSyCMm9VBymR43tOkkv4wQ6szA2yGfH3j3RE';",REACT_APP_ENV_SENDER_ID:"1021363670094",REACT_APP_APP_ID:"1:1021363670094:web:252b1088a0266e0573c71f",REACT_APP_TOKEN:"d891e715-d5ab-49ee-8c4c-d14c25d7fb7a"},Kb=function(e,t){const n="object"==typeof e?e:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:uc;const t=dc.get(e);if(!t&&e===uc&&Kl())return vc();if(!t)throw yc.create("no-app",{appName:e});return t}(),r="string"==typeof e?e:t||"(default)",a=gc(n,"firestore").getImmediate({identifier:r});if(!a._initialized){const e=ql("firestore");e&&ab(a,...e)}return a}(vc({apiKey:qb.REACT_APP_API_KEY,authDomain:"auth-tfjs.firebaseapp.com",projectId:"auth-tfjs",storageBucket:"auth-tfjs.appspot.com",messagingSenderId:qb.REACT_APP_SENDER_ID,appId:qb.REACT_APP_APP_ID})),Yb=async e=>{const t=ub(Kb,"users",e);return await function(e){e=tb(e,ib);const t=tb(e.firestore,db);return Ky(hb(t),e._key).then((n=>Hb(t,e,n)))}(t)},Xb=async e=>{const t=ub(Kb,"users",e);var n;await(n=t,Gb(tb(n.firestore,db),[new hf(n._key,Zp.none())]))},Qb=()=>{const e=b((e=>e.user)),n=E(),r=Qt(),[a,s]=(0,t.useState)(!1),[i,o]=(0,t.useState)(""),[l,u]=(0,t.useState)(!1),c=()=>{s(!1),o("")},d=()=>{u(!1),n(Ze()),n(et()),n(Je()),r("/")};return(0,$n.jsxs)(vl,{maxWidth:"sm",children:[(0,$n.jsx)(zn,{sx:{mt:8,mb:4},children:(0,$n.jsxs)(Zn,{elevation:3,sx:{p:4,textAlign:"center"},children:[e.name?(0,$n.jsxs)($n.Fragment,{children:[(0,$n.jsx)(Ll.A,{color:"success",sx:{fontSize:60,mb:2}}),(0,$n.jsxs)(mr,{variant:"h5",gutterBottom:!0,children:["Welcome, ",e.name,"!"]}),(0,$n.jsx)(mr,{variant:"body1",sx:{mb:3},children:"You are successfully logged in."}),(0,$n.jsxs)(mr,{variant:"body2",sx:{mb:3},children:["Email: ",e.email]}),(0,$n.jsxs)(mr,{variant:"body2",sx:{mb:3},children:["Date of Birth: ",(e=>{const t=new Date(e);return`${String(t.getDate()).padStart(2,"0")}/${String(t.getMonth()+1).padStart(2,"0")}/${t.getFullYear()}`})(e.dateOfBirth)," "]}),(0,$n.jsx)(Po,{variant:"contained",color:"error",onClick:()=>{s(!0)},children:"Delete Account"})]}):(0,$n.jsxs)($n.Fragment,{children:[(0,$n.jsx)(zl.A,{color:"error",sx:{fontSize:60,mb:2}}),(0,$n.jsx)(mr,{variant:"h5",gutterBottom:!0,children:"Authentication Error"}),(0,$n.jsx)(mr,{variant:"body1",sx:{mb:3},children:e.error||"Please try again."})]}),!l&&(0,$n.jsx)(zn,{sx:{mt:2},children:(0,$n.jsx)(Po,{variant:"contained",color:"primary",onClick:()=>{n(Ze()),n(et()),n(Je()),r("/login")},children:"Login Again"})})]})}),(0,$n.jsxs)(Cl,{open:a,onClose:c,children:[(0,$n.jsx)($l,{children:"Delete Account"}),(0,$n.jsxs)(Ml,{children:[(0,$n.jsx)(mr,{children:"Please type your email to confirm account deletion:"}),(0,$n.jsx)(ro,{autoFocus:!0,margin:"dense",label:"Email",type:"email",fullWidth:!0,variant:"outlined",value:i,onChange:e=>o(e.target.value)})]}),(0,$n.jsxs)(Pl,{children:[(0,$n.jsx)(Po,{onClick:c,color:"primary",children:"Cancel"}),(0,$n.jsx)(Po,{onClick:async()=>{if(i===e.email)try{await Xb(e.userId),n(Ze()),u(!0)}catch(t){console.error("Error deleting user data: ",t)}c()},color:"error",children:"Delete"})]})]}),(0,$n.jsxs)(Cl,{open:l,onClose:d,children:[(0,$n.jsx)($l,{children:"Account Deleted"}),(0,$n.jsx)(Ml,{children:(0,$n.jsx)(mr,{children:"Your account has been deleted successfully. Please note that your biometric is also been deleted."})}),(0,$n.jsx)(Pl,{children:(0,$n.jsx)(Po,{onClick:d,color:"primary",children:"OK"})})]})]})};function Zb(e){return(0,Kn.Ay)("MuiCard",e)}(0,Fn.A)("MuiCard",["root"]);const Jb=(0,Wn.Ay)(Zn,{name:"MuiCard",slot:"Root",overridesResolver:(e,t)=>t.root})({overflow:"hidden"}),ev=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiCard"}),{className:r,raised:a=!1,...s}=n,i={...n,raised:a},o=(e=>{const{classes:t}=e;return(0,Bn.A)({root:["root"]},Zb,t)})(i);return(0,$n.jsx)(Jb,{className:(0,vn.A)(o.root,r),elevation:a?8:void 0,ref:t,ownerState:i,...s})}));function tv(e){return(0,Kn.Ay)("MuiCardContent",e)}(0,Fn.A)("MuiCardContent",["root"]);const nv=(0,Wn.Ay)("div",{name:"MuiCardContent",slot:"Root",overridesResolver:(e,t)=>t.root})({padding:16,"&:last-child":{paddingBottom:24}}),rv=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiCardContent"}),{className:r,component:a="div",...s}=n,i={...n,component:a},o=(e=>{const{classes:t}=e;return(0,Bn.A)({root:["root"]},tv,t)})(i);return(0,$n.jsx)(nv,{as:a,className:(0,vn.A)(o.root,r),ownerState:i,ref:t,...s})})),av=["localeText"],sv=t.createContext(null);const iv=function(e){const{localeText:n}=e,r=us(e,av),{utils:a,localeText:s}=t.useContext(sv)??{utils:void 0,localeText:void 0},i=Hi({props:r,name:"MuiLocalizationProvider"}),{children:o,dateAdapter:l,dateFormats:u,dateLibInstance:c,adapterLocale:d,localeText:h}=i,p=t.useMemo((()=>(0,oo.A)({},h,s,n)),[h,s,n]),f=t.useMemo((()=>{if(!l)return a||null;const e=new l({locale:d,formats:u,instance:c});if(!e.isMUIAdapter)throw new Error(["MUI X: The date adapter should be imported from `@mui/x-date-pickers` or `@mui/x-date-pickers-pro`, not from `@date-io`","For example, `import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs'` instead of `import AdapterDayjs from '@date-io/dayjs'`","More information on the installation documentation: https://mui.com/x/react-date-pickers/getting-started/#installation"].join("\n"));return e}),[l,d,u,c,a]),m=t.useMemo((()=>f?{minDate:f.date("1900-01-01T00:00:00.000"),maxDate:f.date("2099-12-31T00:00:00.000")}:null),[f]),g=t.useMemo((()=>({utils:f,defaultDates:m,localeText:p})),[m,f,p]);return(0,$n.jsx)(sv.Provider,{value:g,children:o})};function ov(e,n,r,a,s){const[i,o]=t.useState((()=>s&&r?r(e).matches:a?a(e).matches:n));return(0,xr.A)((()=>{if(!r)return;const t=r(e),n=()=>{o(t.matches)};return n(),t.addEventListener("change",n),()=>{t.removeEventListener("change",n)}}),[e,r]),i}const lv=r.useSyncExternalStore;function uv(e,n,r,a,s){const i=t.useCallback((()=>n),[n]),o=t.useMemo((()=>{if(s&&r)return()=>r(e).matches;if(null!==a){const{matches:t}=a(e);return()=>t}return i}),[i,e,a,s,r]),[l,u]=t.useMemo((()=>{if(null===r)return[i,()=>()=>{}];const t=r(e);return[()=>t.matches,e=>(t.addEventListener("change",e),()=>{t.removeEventListener("change",e)})]}),[i,r,e]);return lv(u,l,o)}function cv(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=An(),r="undefined"!==typeof window&&"undefined"!==typeof window.matchMedia,{defaultMatches:a=!1,matchMedia:s=(r?window.matchMedia:null),ssrMatchMedia:i=null,noSsr:o=!1}=ji({name:"MuiUseMediaQuery",props:t,theme:n});let l="function"===typeof e?e(n):e;l=l.replace(/^@media( ?)/m,"");return(void 0!==lv?uv:ov)(l,a,s,i,o)}var dv=n(5173),hv=n.n(dv);const pv=function(e,t,n){return"function"===typeof e?e(t,n):e},fv=hv().oneOfType([hv().func,hv().object]),mv=(e,t)=>e.length===t.length&&t.every((t=>e.includes(t))),gv=(e,t,n)=>{let r=t;return r=e.setHours(r,e.getHours(n)),r=e.setMinutes(r,e.getMinutes(n)),r=e.setSeconds(r,e.getSeconds(n)),r=e.setMilliseconds(r,e.getMilliseconds(n)),r},yv=e=>{let{date:t,disableFuture:n,disablePast:r,maxDate:a,minDate:s,isDateDisabled:i,utils:o,timezone:l}=e;const u=gv(o,o.date(void 0,l),t);r&&o.isBefore(s,u)&&(s=u),n&&o.isAfter(a,u)&&(a=u);let c=t,d=t;for(o.isBefore(t,s)&&(c=s,d=null),o.isAfter(t,a)&&(d&&(d=a),c=null);c||d;){if(c&&o.isAfter(c,a)&&(c=null),d&&o.isBefore(d,s)&&(d=null),c){if(!i(c))return c;c=o.addDays(c,1)}if(d){if(!i(d))return d;d=o.addDays(d,-1)}}return null},bv=(e,t,n)=>null!=t&&e.isValid(t)?t:n,vv=(e,t)=>{const n=[e.startOfYear(t)];for(;n.length<12;){const t=n[n.length-1];n.push(e.addMonths(t,1))}return n},xv=(e,t,n)=>"date"===n?e.startOfDay(e.date(void 0,t)):e.date(void 0,t),wv=["year","month","day"],kv=e=>wv.includes(e),Sv=(e,t,n)=>{let{format:r,views:a}=t;if(null!=r)return r;const s=e.formats;return mv(a,["year"])?s.year:mv(a,["month"])?s.month:mv(a,["day"])?s.dayOfMonth:mv(a,["month","year"])?`${s.month} ${s.year}`:mv(a,["day","month"])?`${s.month} ${s.dayOfMonth}`:n?/en/.test(e.getCurrentLocaleCode())?s.normalDateWithWeekday:s.normalDate:s.keyboardDate},Iv=(e,t)=>{const n=e.startOfWeek(t);return[0,1,2,3,4,5,6].map((t=>e.addDays(n,t)))},Tv=["hours","minutes","seconds"],Nv=(e,t)=>3600*t.getHours(e)+60*t.getMinutes(e)+t.getSeconds(e),Cv={year:1,month:2,day:3,hours:4,minutes:5,seconds:6,milliseconds:7},Av=(e,t,n)=>{if(t===Cv.year)return e.startOfYear(n);if(t===Cv.month)return e.startOfMonth(n);if(t===Cv.day)return e.startOfDay(n);let r=n;return t<Cv.minutes&&(r=e.setMinutes(r,0)),t<Cv.seconds&&(r=e.setSeconds(r,0)),t<Cv.milliseconds&&(r=e.setMilliseconds(r,0)),r},Ev=e=>{let{props:t,utils:n,granularity:r,timezone:a,getTodayDate:s}=e,i=s?s():Av(n,r,xv(n,a));null!=t.minDate&&n.isAfterDay(t.minDate,i)&&(i=Av(n,r,t.minDate)),null!=t.maxDate&&n.isBeforeDay(t.maxDate,i)&&(i=Av(n,r,t.maxDate));const o=((e,t)=>(n,r)=>e?t.isAfter(n,r):Nv(n,t)>Nv(r,t))(t.disableIgnoringDatePartForTimeValidation??!1,n);return null!=t.minTime&&o(t.minTime,i)&&(i=Av(n,r,t.disableIgnoringDatePartForTimeValidation?t.minTime:gv(n,i,t.minTime))),null!=t.maxTime&&o(i,t.maxTime)&&(i=Av(n,r,t.disableIgnoringDatePartForTimeValidation?t.maxTime:gv(n,i,t.maxTime))),i},_v=(e,t)=>{const n=e.formatTokenMap[t];if(null==n)throw new Error([`MUI X: The token "${t}" is not supported by the Date and Time Pickers.`,"Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported."].join("\n"));return"string"===typeof n?{type:n,contentType:"meridiem"===n?"letter":"digit",maxLength:void 0}:{type:n.sectionType,contentType:n.contentType,maxLength:n.maxLength}},$v=(e,t,n)=>{const r=[],a=e.date(void 0,t),s=e.startOfWeek(a),i=e.endOfWeek(a);let o=s;for(;e.isBefore(o,i);)r.push(o),o=e.addDays(o,1);return r.map((t=>e.formatByString(t,n)))},Rv=(e,t,n,r)=>{switch(n){case"month":return vv(e,e.date(void 0,t)).map((t=>e.formatByString(t,r)));case"weekDay":return $v(e,t,r);case"meridiem":{const n=e.date(void 0,t);return[e.startOfDay(n),e.endOfDay(n)].map((t=>e.formatByString(t,r)))}default:return[]}},Dv=["0","1","2","3","4","5","6","7","8","9"],Mv=(e,t)=>{if("0"===t[0])return e;const n=[];let r="";for(let a=0;a<e.length;a+=1){r+=e[a];const s=t.indexOf(r);s>-1&&(n.push(s.toString()),r="")}return n.join("")},Fv=(e,t)=>"0"===t[0]?e:e.split("").map((e=>t[Number(e)])).join(""),Ov=(e,t)=>{const n=Mv(e,t);return" "!==n&&!Number.isNaN(Number(n))},Pv=(e,t)=>{let n=e;for(n=Number(n).toString();n.length<t;)n=`0${n}`;return n},Lv=(e,t,n,r,a)=>{if("day"===a.type&&"digit-with-letter"===a.contentType){const r=e.setDate(n.longestMonth,t);return e.formatByString(r,a.format)}let s=t.toString();return a.hasLeadingZerosInInput&&(s=Pv(s,a.maxLength)),Fv(s,r)},zv=(e,t,n,r,a,s,i,o)=>{const l=(e=>{switch(e){case"ArrowUp":return 1;case"ArrowDown":return-1;case"PageUp":return 5;case"PageDown":return-5;default:return 0}})(r),u="Home"===r,c="End"===r,d=""===n.value||u||c;return"digit"===n.contentType||"digit-with-letter"===n.contentType?(()=>{const r=a[n.type]({currentDate:i,format:n.format,contentType:n.contentType}),h=t=>Lv(e,t,r,s,n),p="minutes"===n.type&&o?.minutesStep?o.minutesStep:1;let f=parseInt(Mv(n.value,s),10)+l*p;if(d){if("year"===n.type&&!c&&!u)return e.formatByString(e.date(void 0,t),n.format);f=l>0||u?r.minimum:r.maximum}return f%p!==0&&((l<0||u)&&(f+=p-(p+f)%p),(l>0||c)&&(f-=f%p)),f>r.maximum?h(r.minimum+(f-r.maximum-1)%(r.maximum-r.minimum+1)):f<r.minimum?h(r.maximum-(r.minimum-f-1)%(r.maximum-r.minimum+1)):h(f)})():(()=>{const r=Rv(e,t,n.type,n.format);if(0===r.length)return n.value;if(d)return l>0||u?r[0]:r[r.length-1];const a=r.indexOf(n.value);return r[((a+l)%r.length+r.length)%r.length]})()},Bv=(e,t,n)=>{let r=e.value||e.placeholder;const a="non-input"===t?e.hasLeadingZerosInFormat:e.hasLeadingZerosInInput;"non-input"===t&&e.hasLeadingZerosInInput&&!e.hasLeadingZerosInFormat&&(r=Number(Mv(r,n)).toString());return["input-rtl","input-ltr"].includes(t)&&"digit"===e.contentType&&!a&&1===r.length&&(r=`${r}\u200e`),"input-rtl"===t&&(r=`\u2068${r}\u2069`),r},Vv=(e,t,n,r)=>e.formatByString(e.parse(t,n),r),Wv=(e,t,n)=>4===e.formatByString(e.date(void 0,t),n).length,Uv=(e,t,n,r,a)=>{if("digit"!==n)return!1;const s=e.date(void 0,t);switch(r){case"year":if(Wv(e,t,a)){return"0001"===e.formatByString(e.setYear(s,1),a)}return"01"===e.formatByString(e.setYear(s,2001),a);case"month":return e.formatByString(e.startOfYear(s),a).length>1;case"day":return e.formatByString(e.startOfMonth(s),a).length>1;case"weekDay":return e.formatByString(e.startOfWeek(s),a).length>1;case"hours":return e.formatByString(e.setHours(s,1),a).length>1;case"minutes":return e.formatByString(e.setMinutes(s,1),a).length>1;case"seconds":return e.formatByString(e.setSeconds(s,1),a).length>1;default:throw new Error("Invalid section type")}};const jv=(e,t)=>{0},Gv={year:1,month:2,day:3,weekDay:4,hours:5,minutes:6,seconds:7,meridiem:8,empty:9},Hv=(e,t,n,r,a,s)=>[...r].sort(((e,t)=>Gv[e.type]-Gv[t.type])).reduce(((r,a)=>!s||a.modified?((e,t,n,r,a)=>{switch(n.type){case"year":return e.setYear(a,e.getYear(r));case"month":return e.setMonth(a,e.getMonth(r));case"weekDay":{const a=$v(e,t,n.format),s=e.formatByString(r,n.format),i=a.indexOf(s),o=a.indexOf(n.value)-i;return e.addDays(r,o)}case"day":return e.setDate(a,e.getDate(r));case"meridiem":{const t=e.getHours(r)<12,n=e.getHours(a);return t&&n>=12?e.addHours(a,-12):!t&&n<12?e.addHours(a,12):a}case"hours":return e.setHours(a,e.getHours(r));case"minutes":return e.setMinutes(a,e.getMinutes(r));case"seconds":return e.setSeconds(a,e.getSeconds(r));default:return a}})(e,t,a,n,r):r),a),qv=(e,t)=>null==e?null:"all"===e?"all":"string"===typeof e?t.findIndex((t=>t.type===e)):e,Kv=(e,t)=>{if(e.value)switch(e.type){case"month":{if("digit"===e.contentType)return t.format(t.setMonth(t.date(),Number(e.value)-1),"month");const n=t.parse(e.value,e.format);return n?t.format(n,"month"):void 0}case"day":return"digit"===e.contentType?t.format(t.setDate(t.startOfYear(t.date()),Number(e.value)),"dayOfMonthFull"):e.value;default:return}},Yv=(e,t)=>{if(e.value)switch(e.type){case"weekDay":if("letter"===e.contentType)return;return Number(e.value);case"meridiem":{const n=t.parse(`01:00 ${e.value}`,`${t.formats.hours12h}:${t.formats.minutes} ${e.format}`);return n?t.getHours(n)>=12?1:0:void 0}case"day":return"digit-with-letter"===e.contentType?parseInt(e.value,10):Number(e.value);case"month":{if("digit"===e.contentType)return Number(e.value);const n=t.parse(e.value,e.format);return n?t.getMonth(n)+1:void 0}default:return"letter"!==e.contentType?Number(e.value):void 0}},Xv=["value","referenceDate"],Qv={emptyValue:null,getTodayValue:xv,getInitialReferenceValue:e=>{let{value:t,referenceDate:n}=e,r=us(e,Xv);return null!=t&&r.utils.isValid(t)?t:null!=n?n:Ev(r)},cleanValue:(e,t)=>null!=t&&e.isValid(t)?t:null,areValuesEqual:(e,t,n)=>!e.isValid(t)&&null!=t&&!e.isValid(n)&&null!=n||e.isEqual(t,n),isSameError:(e,t)=>e===t,hasError:e=>null!=e,defaultErrorState:null,getTimezone:(e,t)=>null!=t&&e.isValid(t)?e.getTimezone(t):null,setTimezone:(e,t,n)=>null==n?null:e.setTimezone(n,t)},Zv={updateReferenceValue:(e,t,n)=>null!=t&&e.isValid(t)?t:n,getSectionsFromValue:(e,t,n,r)=>!e.isValid(t)&&!!n?n:r(t),getV7HiddenInputValueFromSections:e=>e.map((e=>`${e.startSeparator}${e.value||e.placeholder}${e.endSeparator}`)).join(""),getV6InputValueFromSections:(e,t,n)=>{const r=e.map((e=>{const r=Bv(e,n?"input-rtl":"input-ltr",t);return`${e.startSeparator}${r}${e.endSeparator}`})).join("");return n?`\u2066${r}\u2069`:r},getActiveDateManager:(e,t)=>({date:t.value,referenceDate:t.referenceValue,getSections:e=>e,getNewValuesFromNewActiveDate:n=>({value:n,referenceValue:null!=n&&e.isValid(n)?n:t.referenceValue})}),parseValueStr:(e,t,n)=>n(e.trim(),t)},Jv={previousMonth:"Previous month",nextMonth:"Next month",openPreviousView:"Open previous view",openNextView:"Open next view",calendarViewSwitchingButtonAriaLabel:e=>"year"===e?"year view is open, switch to calendar view":"calendar view is open, switch to year view",start:"Start",end:"End",startDate:"Start date",startTime:"Start time",endDate:"End date",endTime:"End time",cancelButtonLabel:"Cancel",clearButtonLabel:"Clear",okButtonLabel:"OK",todayButtonLabel:"Today",datePickerToolbarTitle:"Select date",dateTimePickerToolbarTitle:"Select date & time",timePickerToolbarTitle:"Select time",dateRangePickerToolbarTitle:"Select date range",clockLabelText:(e,t,n)=>`Select ${e}. ${null===t?"No time selected":`Selected time is ${n.format(t,"fullTime")}`}`,hoursClockNumberText:e=>`${e} hours`,minutesClockNumberText:e=>`${e} minutes`,secondsClockNumberText:e=>`${e} seconds`,selectViewText:e=>`Select ${e}`,calendarWeekNumberHeaderLabel:"Week number",calendarWeekNumberHeaderText:"#",calendarWeekNumberAriaLabelText:e=>`Week ${e}`,calendarWeekNumberText:e=>`${e}`,openDatePickerDialogue:(e,t)=>null!==e&&t.isValid(e)?`Choose date, selected date is ${t.format(e,"fullDate")}`:"Choose date",openTimePickerDialogue:(e,t)=>null!==e&&t.isValid(e)?`Choose time, selected time is ${t.format(e,"fullTime")}`:"Choose time",fieldClearLabel:"Clear value",timeTableLabel:"pick time",dateTableLabel:"pick date",fieldYearPlaceholder:e=>"Y".repeat(e.digitAmount),fieldMonthPlaceholder:e=>"letter"===e.contentType?"MMMM":"MM",fieldDayPlaceholder:()=>"DD",fieldWeekDayPlaceholder:e=>"letter"===e.contentType?"EEEE":"EE",fieldHoursPlaceholder:()=>"hh",fieldMinutesPlaceholder:()=>"mm",fieldSecondsPlaceholder:()=>"ss",fieldMeridiemPlaceholder:()=>"aa",year:"Year",month:"Month",day:"Day",weekDay:"Week day",hours:"Hours",minutes:"Minutes",seconds:"Seconds",meridiem:"Meridiem",empty:"Empty"},ex=Jv;tx=Jv,(0,oo.A)({},tx);var tx;const nx=()=>{const e=t.useContext(sv);if(null===e)throw new Error(["MUI X: Can not find the date and time pickers localization context.","It looks like you forgot to wrap your component in LocalizationProvider.","This can also happen if you are bundling multiple versions of the `@mui/x-date-pickers` package"].join("\n"));if(null===e.utils)throw new Error(["MUI X: Can not find the date and time pickers adapter from its localization context.","It looks like you forgot to pass a `dateAdapter` to your LocalizationProvider."].join("\n"));const n=t.useMemo((()=>(0,oo.A)({},ex,e.localeText)),[e.localeText]);return t.useMemo((()=>(0,oo.A)({},e,{localeText:n})),[e,n])},rx=()=>nx().utils,ax=()=>nx().defaultDates,sx=e=>{const n=rx(),r=t.useRef();return void 0===r.current&&(r.current=n.date(void 0,e)),r.current};function ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;const r={};return Object.keys(e).forEach((a=>{r[a]=e[a].reduce(((e,r)=>{if(r){const a=t(r);""!==a&&e.push(a),n&&n[r]&&e.push(n[r])}return e}),[]).join(" ")})),r}const ox=e=>e,lx=(()=>{let e=ox;return{configure(t){e=t},generate:t=>e(t),reset(){e=ox}}})(),ux=lx,cx={active:"active",checked:"checked",completed:"completed",disabled:"disabled",error:"error",expanded:"expanded",focused:"focused",focusVisible:"focusVisible",open:"open",readOnly:"readOnly",required:"required",selected:"selected"};function dx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const r=cx[t];return r?`${n}-${r}`:`${ux.generate(e)}-${t}`}function hx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"Mui";const r={};return t.forEach((t=>{r[t]=dx(e,t,n)})),r}function px(e){return dx("MuiPickersToolbar",e)}hx("MuiPickersToolbar",["root","content"]);const fx=["children","className","toolbarTitle","hidden","titleId","isLandscape","classes","landscapeDirection"],mx=(0,Wn.Ay)("div",{name:"MuiPickersToolbar",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;return{display:"flex",flexDirection:"column",alignItems:"flex-start",justifyContent:"space-between",padding:t.spacing(2,3),variants:[{props:{isLandscape:!0},style:{height:"auto",maxWidth:160,padding:16,justifyContent:"flex-start",flexWrap:"wrap"}}]}})),gx=(0,Wn.Ay)("div",{name:"MuiPickersToolbar",slot:"Content",overridesResolver:(e,t)=>t.content})({display:"flex",flexWrap:"wrap",width:"100%",flex:1,justifyContent:"space-between",alignItems:"center",flexDirection:"row",variants:[{props:{isLandscape:!0},style:{justifyContent:"flex-start",alignItems:"flex-start",flexDirection:"column"}},{props:{isLandscape:!0,landscapeDirection:"row"},style:{flexDirection:"row"}}]}),yx=t.forwardRef((function(e,t){const n=Hi({props:e,name:"MuiPickersToolbar"}),{children:r,className:a,toolbarTitle:s,hidden:i,titleId:o}=n,l=us(n,fx),u=n,c=(e=>{const{classes:t,isLandscape:n}=e;return ix({root:["root"],content:["content"],penIconButton:["penIconButton",n&&"penIconButtonLandscape"]},px,t)})(u);return i?null:(0,$n.jsxs)(mx,(0,oo.A)({ref:t,className:(0,vn.A)(c.root,a),ownerState:u},l,{children:[(0,$n.jsx)(mr,{color:"text.secondary",variant:"overline",id:o,children:s}),(0,$n.jsx)(gx,{className:c.content,ownerState:u,children:r})]}))})),bx=()=>nx().localeText;function vx(e){return dx("MuiDatePickerToolbar",e)}hx("MuiDatePickerToolbar",["root","title"]);const xx=["value","isLandscape","onChange","toolbarFormat","toolbarPlaceholder","views","className","onViewChange","view"],wx=(0,Wn.Ay)(yx,{name:"MuiDatePickerToolbar",slot:"Root",overridesResolver:(e,t)=>t.root})({}),kx=(0,Wn.Ay)(mr,{name:"MuiDatePickerToolbar",slot:"Title",overridesResolver:(e,t)=>t.title})({variants:[{props:{isLandscape:!0},style:{margin:"auto 16px auto auto"}}]}),Sx=t.forwardRef((function(e,n){const r=Hi({props:e,name:"MuiDatePickerToolbar"}),{value:a,isLandscape:s,toolbarFormat:i,toolbarPlaceholder:o="\u2013\u2013",views:l,className:u}=r,c=us(r,xx),d=rx(),h=bx(),p=(e=>{const{classes:t}=e;return ix({root:["root"],title:["title"]},vx,t)})(r),f=t.useMemo((()=>{if(!a)return o;const e=Sv(d,{format:i,views:l},!0);return d.formatByString(a,e)}),[a,i,o,d,l]),m=r;return(0,$n.jsx)(wx,(0,oo.A)({ref:n,toolbarTitle:h.datePickerToolbarTitle,isLandscape:s,className:(0,vn.A)(p.root,u)},c,{children:(0,$n.jsx)(kx,{variant:"h4",align:s?"left":"center",ownerState:m,className:p.title,children:f})}))}));function Ix(e,n){const r=rx(),a=ax(),s=Hi({props:e,name:n}),i=t.useMemo((()=>null==s.localeText?.toolbarTitle?s.localeText:(0,oo.A)({},s.localeText,{datePickerToolbarTitle:s.localeText.toolbarTitle})),[s.localeText]);return(0,oo.A)({},s,{localeText:i},(e=>{let{openTo:t,defaultOpenTo:n,views:r,defaultViews:a}=e;const s=r??a;let i;if(null!=t)i=t;else if(s.includes(n))i=n;else{if(!(s.length>0))throw new Error("MUI X: The `views` prop must contain at least one view.");i=s[0]}return{views:s,openTo:i}})({views:s.views,openTo:s.openTo,defaultViews:["year","day"],defaultOpenTo:"day"}),{disableFuture:s.disableFuture??!1,disablePast:s.disablePast??!1,minDate:bv(r,s.minDate,a.minDate),maxDate:bv(r,s.maxDate,a.maxDate),slots:(0,oo.A)({toolbar:Sx},s.slots)})}const Tx=e=>{let{props:t,value:n,adapter:r}=e;if(null===n)return null;const{shouldDisableDate:a,shouldDisableMonth:s,shouldDisableYear:i,disablePast:o,disableFuture:l,timezone:u}=t,c=r.utils.date(void 0,u),d=bv(r.utils,t.minDate,r.defaultDates.minDate),h=bv(r.utils,t.maxDate,r.defaultDates.maxDate);switch(!0){case!r.utils.isValid(n):return"invalidDate";case Boolean(a&&a(n)):return"shouldDisableDate";case Boolean(s&&s(n)):return"shouldDisableMonth";case Boolean(i&&i(n)):return"shouldDisableYear";case Boolean(l&&r.utils.isAfterDay(n,c)):return"disableFuture";case Boolean(o&&r.utils.isBeforeDay(n,c)):return"disablePast";case Boolean(d&&r.utils.isBeforeDay(n,d)):return"minDate";case Boolean(h&&r.utils.isAfterDay(n,h)):return"maxDate";default:return null}};function Nx(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.useMemo((()=>n.every((e=>null==e))?null:e=>{n.forEach((t=>{!function(e,t){"function"===typeof e?e(t):e&&(e.current=t)}(t,e)}))}),n)}const Cx=function(e){return"string"===typeof e};const Ax=function(e,t,n){return void 0===e||Cx(e)?t:(0,oo.A)({},t,{ownerState:(0,oo.A)({},t.ownerState,n)})};const Ex=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];if(void 0===e)return{};const n={};return Object.keys(e).filter((n=>n.match(/^on[A-Z]/)&&"function"===typeof e[n]&&!t.includes(n))).forEach((t=>{n[t]=e[t]})),n};const _x=function(e){if(void 0===e)return{};const t={};return Object.keys(e).filter((t=>!(t.match(/^on[A-Z]/)&&"function"===typeof e[t]))).forEach((n=>{t[n]=e[n]})),t};const $x=function(e){const{getSlotProps:t,additionalProps:n,externalSlotProps:r,externalForwardedProps:a,className:s}=e;if(!t){const e=(0,vn.A)(null==n?void 0:n.className,s,null==a?void 0:a.className,null==r?void 0:r.className),t=(0,oo.A)({},null==n?void 0:n.style,null==a?void 0:a.style,null==r?void 0:r.style),i=(0,oo.A)({},n,a,r);return e.length>0&&(i.className=e),Object.keys(t).length>0&&(i.style=t),{props:i,internalRef:void 0}}const i=Ex((0,oo.A)({},a,r)),o=_x(r),l=_x(a),u=t(i),c=(0,vn.A)(null==u?void 0:u.className,null==n?void 0:n.className,s,null==a?void 0:a.className,null==r?void 0:r.className),d=(0,oo.A)({},null==u?void 0:u.style,null==n?void 0:n.style,null==a?void 0:a.style,null==r?void 0:r.style),h=(0,oo.A)({},u,n,l,o);return c.length>0&&(h.className=c),Object.keys(d).length>0&&(h.style=d),{props:h,internalRef:u.ref}},Rx=["elementType","externalSlotProps","ownerState","skipResolvingSlotProps"];const Dx=function(e){var t;const{elementType:n,externalSlotProps:r,ownerState:a,skipResolvingSlotProps:s=!1}=e,i=us(e,Rx),o=s?{}:pv(r,a),{props:l,internalRef:u}=$x((0,oo.A)({},i,{externalSlotProps:o})),c=Nx(u,null==o?void 0:o.ref,null==(t=e.additionalProps)?void 0:t.ref);return Ax(n,(0,oo.A)({},l,{ref:c}),a)};function Mx(e){return(0,Kn.Ay)("MuiInputAdornment",e)}const Fx=(0,Fn.A)("MuiInputAdornment",["root","filled","standard","outlined","positionStart","positionEnd","disablePointerEvents","hiddenLabel","sizeSmall"]);var Ox;const Px=(0,Wn.Ay)("div",{name:"MuiInputAdornment",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`position${(0,lr.A)(n.position)}`],!0===n.disablePointerEvents&&t.disablePointerEvents,t[n.variant]]}})((0,Gn.A)((e=>{let{theme:t}=e;return{display:"flex",maxHeight:"2em",alignItems:"center",whiteSpace:"nowrap",color:(t.vars||t).palette.action.active,variants:[{props:{variant:"filled"},style:{[`&.${Fx.positionStart}&:not(.${Fx.hiddenLabel})`]:{marginTop:16}}},{props:{position:"start"},style:{marginRight:8}},{props:{position:"end"},style:{marginLeft:8}},{props:{disablePointerEvents:!0},style:{pointerEvents:"none"}}]}}))),Lx=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiInputAdornment"}),{children:a,className:s,component:i="div",disablePointerEvents:o=!1,disableTypography:l=!1,position:u,variant:c,...d}=r,h=Er()||{};let p=c;c&&h.variant,h&&!p&&(p=h.variant);const f={...r,hiddenLabel:h.hiddenLabel,size:h.size,disablePointerEvents:o,position:u,variant:p},m=(e=>{const{classes:t,disablePointerEvents:n,hiddenLabel:r,position:a,size:s,variant:i}=e,o={root:["root",n&&"disablePointerEvents",a&&`position${(0,lr.A)(a)}`,i,r&&"hiddenLabel",s&&`size${(0,lr.A)(s)}`]};return(0,Bn.A)(o,Mx,t)})(f);return(0,$n.jsx)(Ar.Provider,{value:null,children:(0,$n.jsx)(Px,{as:i,ownerState:f,className:(0,vn.A)(m.root,s),ref:n,...d,children:"string"!==typeof a||l?(0,$n.jsxs)(t.Fragment,{children:["start"===u?Ox||(Ox=(0,$n.jsx)("span",{className:"notranslate",children:"\u200b"})):null,a]}):(0,$n.jsx)(mr,{color:"textSecondary",children:a})})})})),zx=Lx;let Bx=0;const Vx=r["useId".toString()];function Wx(e){if(void 0!==Vx){const t=Vx();return null!=e?e:t}return function(e){const[n,r]=t.useState(e),a=e||n;return t.useEffect((()=>{null==n&&(Bx+=1,r(`mui-${Bx}`))}),[n]),a}(e)}function Ux(e){if(null==e)return window;if("[object Window]"!==e.toString()){var t=e.ownerDocument;return t&&t.defaultView||window}return e}function jx(e){return e instanceof Ux(e).Element||e instanceof Element}function Gx(e){return e instanceof Ux(e).HTMLElement||e instanceof HTMLElement}function Hx(e){return"undefined"!==typeof ShadowRoot&&(e instanceof Ux(e).ShadowRoot||e instanceof ShadowRoot)}var qx=Math.max,Kx=Math.min,Yx=Math.round;function Xx(){var e=navigator.userAgentData;return null!=e&&e.brands&&Array.isArray(e.brands)?e.brands.map((function(e){return e.brand+"/"+e.version})).join(" "):navigator.userAgent}function Qx(){return!/^((?!chrome|android).)*safari/i.test(Xx())}function Zx(e,t,n){void 0===t&&(t=!1),void 0===n&&(n=!1);var r=e.getBoundingClientRect(),a=1,s=1;t&&Gx(e)&&(a=e.offsetWidth>0&&Yx(r.width)/e.offsetWidth||1,s=e.offsetHeight>0&&Yx(r.height)/e.offsetHeight||1);var i=(jx(e)?Ux(e):window).visualViewport,o=!Qx()&&n,l=(r.left+(o&&i?i.offsetLeft:0))/a,u=(r.top+(o&&i?i.offsetTop:0))/s,c=r.width/a,d=r.height/s;return{width:c,height:d,top:u,right:l+c,bottom:u+d,left:l,x:l,y:u}}function Jx(e){var t=Ux(e);return{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function ew(e){return e?(e.nodeName||"").toLowerCase():null}function tw(e){return((jx(e)?e.ownerDocument:e.document)||window.document).documentElement}function nw(e){return Zx(tw(e)).left+Jx(e).scrollLeft}function rw(e){return Ux(e).getComputedStyle(e)}function aw(e){var t=rw(e),n=t.overflow,r=t.overflowX,a=t.overflowY;return/auto|scroll|overlay|hidden/.test(n+a+r)}function sw(e,t,n){void 0===n&&(n=!1);var r=Gx(t),a=Gx(t)&&function(e){var t=e.getBoundingClientRect(),n=Yx(t.width)/e.offsetWidth||1,r=Yx(t.height)/e.offsetHeight||1;return 1!==n||1!==r}(t),s=tw(t),i=Zx(e,a,n),o={scrollLeft:0,scrollTop:0},l={x:0,y:0};return(r||!r&&!n)&&(("body"!==ew(t)||aw(s))&&(o=function(e){return e!==Ux(e)&&Gx(e)?{scrollLeft:(t=e).scrollLeft,scrollTop:t.scrollTop}:Jx(e);var t}(t)),Gx(t)?((l=Zx(t,!0)).x+=t.clientLeft,l.y+=t.clientTop):s&&(l.x=nw(s))),{x:i.left+o.scrollLeft-l.x,y:i.top+o.scrollTop-l.y,width:i.width,height:i.height}}function iw(e){var t=Zx(e),n=e.offsetWidth,r=e.offsetHeight;return Math.abs(t.width-n)<=1&&(n=t.width),Math.abs(t.height-r)<=1&&(r=t.height),{x:e.offsetLeft,y:e.offsetTop,width:n,height:r}}function ow(e){return"html"===ew(e)?e:e.assignedSlot||e.parentNode||(Hx(e)?e.host:null)||tw(e)}function lw(e){return["html","body","#document"].indexOf(ew(e))>=0?e.ownerDocument.body:Gx(e)&&aw(e)?e:lw(ow(e))}function uw(e,t){var n;void 0===t&&(t=[]);var r=lw(e),a=r===(null==(n=e.ownerDocument)?void 0:n.body),s=Ux(r),i=a?[s].concat(s.visualViewport||[],aw(r)?r:[]):r,o=t.concat(i);return a?o:o.concat(uw(ow(i)))}function cw(e){return["table","td","th"].indexOf(ew(e))>=0}function dw(e){return Gx(e)&&"fixed"!==rw(e).position?e.offsetParent:null}function hw(e){for(var t=Ux(e),n=dw(e);n&&cw(n)&&"static"===rw(n).position;)n=dw(n);return n&&("html"===ew(n)||"body"===ew(n)&&"static"===rw(n).position)?t:n||function(e){var t=/firefox/i.test(Xx());if(/Trident/i.test(Xx())&&Gx(e)&&"fixed"===rw(e).position)return null;var n=ow(e);for(Hx(n)&&(n=n.host);Gx(n)&&["html","body"].indexOf(ew(n))<0;){var r=rw(n);if("none"!==r.transform||"none"!==r.perspective||"paint"===r.contain||-1!==["transform","perspective"].indexOf(r.willChange)||t&&"filter"===r.willChange||t&&r.filter&&"none"!==r.filter)return n;n=n.parentNode}return null}(e)||t}var pw="top",fw="bottom",mw="right",gw="left",yw="auto",bw=[pw,fw,mw,gw],vw="start",xw="end",ww="clippingParents",kw="viewport",Sw="popper",Iw="reference",Tw=bw.reduce((function(e,t){return e.concat([t+"-"+vw,t+"-"+xw])}),[]),Nw=[].concat(bw,[yw]).reduce((function(e,t){return e.concat([t,t+"-"+vw,t+"-"+xw])}),[]),Cw=["beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite"];function Aw(e){var t=new Map,n=new Set,r=[];function a(e){n.add(e.name),[].concat(e.requires||[],e.requiresIfExists||[]).forEach((function(e){if(!n.has(e)){var r=t.get(e);r&&a(r)}})),r.push(e)}return e.forEach((function(e){t.set(e.name,e)})),e.forEach((function(e){n.has(e.name)||a(e)})),r}function Ew(e){var t;return function(){return t||(t=new Promise((function(n){Promise.resolve().then((function(){t=void 0,n(e())}))}))),t}}var _w={placement:"bottom",modifiers:[],strategy:"absolute"};function $w(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return!t.some((function(e){return!(e&&"function"===typeof e.getBoundingClientRect)}))}function Rw(e){void 0===e&&(e={});var t=e,n=t.defaultModifiers,r=void 0===n?[]:n,a=t.defaultOptions,s=void 0===a?_w:a;return function(e,t,n){void 0===n&&(n=s);var a={placement:"bottom",orderedModifiers:[],options:Object.assign({},_w,s),modifiersData:{},elements:{reference:e,popper:t},attributes:{},styles:{}},i=[],o=!1,l={state:a,setOptions:function(n){var o="function"===typeof n?n(a.options):n;u(),a.options=Object.assign({},s,a.options,o),a.scrollParents={reference:jx(e)?uw(e):e.contextElement?uw(e.contextElement):[],popper:uw(t)};var c=function(e){var t=Aw(e);return Cw.reduce((function(e,n){return e.concat(t.filter((function(e){return e.phase===n})))}),[])}(function(e){var t=e.reduce((function(e,t){var n=e[t.name];return e[t.name]=n?Object.assign({},n,t,{options:Object.assign({},n.options,t.options),data:Object.assign({},n.data,t.data)}):t,e}),{});return Object.keys(t).map((function(e){return t[e]}))}([].concat(r,a.options.modifiers)));return a.orderedModifiers=c.filter((function(e){return e.enabled})),a.orderedModifiers.forEach((function(e){var t=e.name,n=e.options,r=void 0===n?{}:n,s=e.effect;if("function"===typeof s){var o=s({state:a,name:t,instance:l,options:r}),u=function(){};i.push(o||u)}})),l.update()},forceUpdate:function(){if(!o){var e=a.elements,t=e.reference,n=e.popper;if($w(t,n)){a.rects={reference:sw(t,hw(n),"fixed"===a.options.strategy),popper:iw(n)},a.reset=!1,a.placement=a.options.placement,a.orderedModifiers.forEach((function(e){return a.modifiersData[e.name]=Object.assign({},e.data)}));for(var r=0;r<a.orderedModifiers.length;r++)if(!0!==a.reset){var s=a.orderedModifiers[r],i=s.fn,u=s.options,c=void 0===u?{}:u,d=s.name;"function"===typeof i&&(a=i({state:a,options:c,name:d,instance:l})||a)}else a.reset=!1,r=-1}}},update:Ew((function(){return new Promise((function(e){l.forceUpdate(),e(a)}))})),destroy:function(){u(),o=!0}};if(!$w(e,t))return l;function u(){i.forEach((function(e){return e()})),i=[]}return l.setOptions(n).then((function(e){!o&&n.onFirstUpdate&&n.onFirstUpdate(e)})),l}}var Dw={passive:!0};function Mw(e){return e.split("-")[0]}function Fw(e){return e.split("-")[1]}function Ow(e){return["top","bottom"].indexOf(e)>=0?"x":"y"}function Pw(e){var t,n=e.reference,r=e.element,a=e.placement,s=a?Mw(a):null,i=a?Fw(a):null,o=n.x+n.width/2-r.width/2,l=n.y+n.height/2-r.height/2;switch(s){case pw:t={x:o,y:n.y-r.height};break;case fw:t={x:o,y:n.y+n.height};break;case mw:t={x:n.x+n.width,y:l};break;case gw:t={x:n.x-r.width,y:l};break;default:t={x:n.x,y:n.y}}var u=s?Ow(s):null;if(null!=u){var c="y"===u?"height":"width";switch(i){case vw:t[u]=t[u]-(n[c]/2-r[c]/2);break;case xw:t[u]=t[u]+(n[c]/2-r[c]/2)}}return t}var Lw={top:"auto",right:"auto",bottom:"auto",left:"auto"};function zw(e){var t,n=e.popper,r=e.popperRect,a=e.placement,s=e.variation,i=e.offsets,o=e.position,l=e.gpuAcceleration,u=e.adaptive,c=e.roundOffsets,d=e.isFixed,h=i.x,p=void 0===h?0:h,f=i.y,m=void 0===f?0:f,g="function"===typeof c?c({x:p,y:m}):{x:p,y:m};p=g.x,m=g.y;var y=i.hasOwnProperty("x"),b=i.hasOwnProperty("y"),v=gw,x=pw,w=window;if(u){var k=hw(n),S="clientHeight",I="clientWidth";if(k===Ux(n)&&"static"!==rw(k=tw(n)).position&&"absolute"===o&&(S="scrollHeight",I="scrollWidth"),a===pw||(a===gw||a===mw)&&s===xw)x=fw,m-=(d&&k===w&&w.visualViewport?w.visualViewport.height:k[S])-r.height,m*=l?1:-1;if(a===gw||(a===pw||a===fw)&&s===xw)v=mw,p-=(d&&k===w&&w.visualViewport?w.visualViewport.width:k[I])-r.width,p*=l?1:-1}var T,N=Object.assign({position:o},u&&Lw),C=!0===c?function(e,t){var n=e.x,r=e.y,a=t.devicePixelRatio||1;return{x:Yx(n*a)/a||0,y:Yx(r*a)/a||0}}({x:p,y:m},Ux(n)):{x:p,y:m};return p=C.x,m=C.y,l?Object.assign({},N,((T={})[x]=b?"0":"",T[v]=y?"0":"",T.transform=(w.devicePixelRatio||1)<=1?"translate("+p+"px, "+m+"px)":"translate3d("+p+"px, "+m+"px, 0)",T)):Object.assign({},N,((t={})[x]=b?m+"px":"",t[v]=y?p+"px":"",t.transform="",t))}const Bw={name:"applyStyles",enabled:!0,phase:"write",fn:function(e){var t=e.state;Object.keys(t.elements).forEach((function(e){var n=t.styles[e]||{},r=t.attributes[e]||{},a=t.elements[e];Gx(a)&&ew(a)&&(Object.assign(a.style,n),Object.keys(r).forEach((function(e){var t=r[e];!1===t?a.removeAttribute(e):a.setAttribute(e,!0===t?"":t)})))}))},effect:function(e){var t=e.state,n={popper:{position:t.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(t.elements.popper.style,n.popper),t.styles=n,t.elements.arrow&&Object.assign(t.elements.arrow.style,n.arrow),function(){Object.keys(t.elements).forEach((function(e){var r=t.elements[e],a=t.attributes[e]||{},s=Object.keys(t.styles.hasOwnProperty(e)?t.styles[e]:n[e]).reduce((function(e,t){return e[t]="",e}),{});Gx(r)&&ew(r)&&(Object.assign(r.style,s),Object.keys(a).forEach((function(e){r.removeAttribute(e)})))}))}},requires:["computeStyles"]};const Vw={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(e){var t=e.state,n=e.options,r=e.name,a=n.offset,s=void 0===a?[0,0]:a,i=Nw.reduce((function(e,n){return e[n]=function(e,t,n){var r=Mw(e),a=[gw,pw].indexOf(r)>=0?-1:1,s="function"===typeof n?n(Object.assign({},t,{placement:e})):n,i=s[0],o=s[1];return i=i||0,o=(o||0)*a,[gw,mw].indexOf(r)>=0?{x:o,y:i}:{x:i,y:o}}(n,t.rects,s),e}),{}),o=i[t.placement],l=o.x,u=o.y;null!=t.modifiersData.popperOffsets&&(t.modifiersData.popperOffsets.x+=l,t.modifiersData.popperOffsets.y+=u),t.modifiersData[r]=i}};var Ww={left:"right",right:"left",bottom:"top",top:"bottom"};function Uw(e){return e.replace(/left|right|bottom|top/g,(function(e){return Ww[e]}))}var jw={start:"end",end:"start"};function Gw(e){return e.replace(/start|end/g,(function(e){return jw[e]}))}function Hw(e,t){var n=t.getRootNode&&t.getRootNode();if(e.contains(t))return!0;if(n&&Hx(n)){var r=t;do{if(r&&e.isSameNode(r))return!0;r=r.parentNode||r.host}while(r)}return!1}function qw(e){return Object.assign({},e,{left:e.x,top:e.y,right:e.x+e.width,bottom:e.y+e.height})}function Kw(e,t,n){return t===kw?qw(function(e,t){var n=Ux(e),r=tw(e),a=n.visualViewport,s=r.clientWidth,i=r.clientHeight,o=0,l=0;if(a){s=a.width,i=a.height;var u=Qx();(u||!u&&"fixed"===t)&&(o=a.offsetLeft,l=a.offsetTop)}return{width:s,height:i,x:o+nw(e),y:l}}(e,n)):jx(t)?function(e,t){var n=Zx(e,!1,"fixed"===t);return n.top=n.top+e.clientTop,n.left=n.left+e.clientLeft,n.bottom=n.top+e.clientHeight,n.right=n.left+e.clientWidth,n.width=e.clientWidth,n.height=e.clientHeight,n.x=n.left,n.y=n.top,n}(t,n):qw(function(e){var t,n=tw(e),r=Jx(e),a=null==(t=e.ownerDocument)?void 0:t.body,s=qx(n.scrollWidth,n.clientWidth,a?a.scrollWidth:0,a?a.clientWidth:0),i=qx(n.scrollHeight,n.clientHeight,a?a.scrollHeight:0,a?a.clientHeight:0),o=-r.scrollLeft+nw(e),l=-r.scrollTop;return"rtl"===rw(a||n).direction&&(o+=qx(n.clientWidth,a?a.clientWidth:0)-s),{width:s,height:i,x:o,y:l}}(tw(e)))}function Yw(e,t,n,r){var a="clippingParents"===t?function(e){var t=uw(ow(e)),n=["absolute","fixed"].indexOf(rw(e).position)>=0&&Gx(e)?hw(e):e;return jx(n)?t.filter((function(e){return jx(e)&&Hw(e,n)&&"body"!==ew(e)})):[]}(e):[].concat(t),s=[].concat(a,[n]),i=s[0],o=s.reduce((function(t,n){var a=Kw(e,n,r);return t.top=qx(a.top,t.top),t.right=Kx(a.right,t.right),t.bottom=Kx(a.bottom,t.bottom),t.left=qx(a.left,t.left),t}),Kw(e,i,r));return o.width=o.right-o.left,o.height=o.bottom-o.top,o.x=o.left,o.y=o.top,o}function Xw(e){return Object.assign({},{top:0,right:0,bottom:0,left:0},e)}function Qw(e,t){return t.reduce((function(t,n){return t[n]=e,t}),{})}function Zw(e,t){void 0===t&&(t={});var n=t,r=n.placement,a=void 0===r?e.placement:r,s=n.strategy,i=void 0===s?e.strategy:s,o=n.boundary,l=void 0===o?ww:o,u=n.rootBoundary,c=void 0===u?kw:u,d=n.elementContext,h=void 0===d?Sw:d,p=n.altBoundary,f=void 0!==p&&p,m=n.padding,g=void 0===m?0:m,y=Xw("number"!==typeof g?g:Qw(g,bw)),b=h===Sw?Iw:Sw,v=e.rects.popper,x=e.elements[f?b:h],w=Yw(jx(x)?x:x.contextElement||tw(e.elements.popper),l,c,i),k=Zx(e.elements.reference),S=Pw({reference:k,element:v,strategy:"absolute",placement:a}),I=qw(Object.assign({},v,S)),T=h===Sw?I:k,N={top:w.top-T.top+y.top,bottom:T.bottom-w.bottom+y.bottom,left:w.left-T.left+y.left,right:T.right-w.right+y.right},C=e.modifiersData.offset;if(h===Sw&&C){var A=C[a];Object.keys(N).forEach((function(e){var t=[mw,fw].indexOf(e)>=0?1:-1,n=[pw,fw].indexOf(e)>=0?"y":"x";N[e]+=A[n]*t}))}return N}const Jw={name:"flip",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name;if(!t.modifiersData[r]._skip){for(var a=n.mainAxis,s=void 0===a||a,i=n.altAxis,o=void 0===i||i,l=n.fallbackPlacements,u=n.padding,c=n.boundary,d=n.rootBoundary,h=n.altBoundary,p=n.flipVariations,f=void 0===p||p,m=n.allowedAutoPlacements,g=t.options.placement,y=Mw(g),b=l||(y===g||!f?[Uw(g)]:function(e){if(Mw(e)===yw)return[];var t=Uw(e);return[Gw(e),t,Gw(t)]}(g)),v=[g].concat(b).reduce((function(e,n){return e.concat(Mw(n)===yw?function(e,t){void 0===t&&(t={});var n=t,r=n.placement,a=n.boundary,s=n.rootBoundary,i=n.padding,o=n.flipVariations,l=n.allowedAutoPlacements,u=void 0===l?Nw:l,c=Fw(r),d=c?o?Tw:Tw.filter((function(e){return Fw(e)===c})):bw,h=d.filter((function(e){return u.indexOf(e)>=0}));0===h.length&&(h=d);var p=h.reduce((function(t,n){return t[n]=Zw(e,{placement:n,boundary:a,rootBoundary:s,padding:i})[Mw(n)],t}),{});return Object.keys(p).sort((function(e,t){return p[e]-p[t]}))}(t,{placement:n,boundary:c,rootBoundary:d,padding:u,flipVariations:f,allowedAutoPlacements:m}):n)}),[]),x=t.rects.reference,w=t.rects.popper,k=new Map,S=!0,I=v[0],T=0;T<v.length;T++){var N=v[T],C=Mw(N),A=Fw(N)===vw,E=[pw,fw].indexOf(C)>=0,_=E?"width":"height",$=Zw(t,{placement:N,boundary:c,rootBoundary:d,altBoundary:h,padding:u}),R=E?A?mw:gw:A?fw:pw;x[_]>w[_]&&(R=Uw(R));var D=Uw(R),M=[];if(s&&M.push($[C]<=0),o&&M.push($[R]<=0,$[D]<=0),M.every((function(e){return e}))){I=N,S=!1;break}k.set(N,M)}if(S)for(var F=function(e){var t=v.find((function(t){var n=k.get(t);if(n)return n.slice(0,e).every((function(e){return e}))}));if(t)return I=t,"break"},O=f?3:1;O>0;O--){if("break"===F(O))break}t.placement!==I&&(t.modifiersData[r]._skip=!0,t.placement=I,t.reset=!0)}},requiresIfExists:["offset"],data:{_skip:!1}};function ek(e,t,n){return qx(e,Kx(t,n))}const tk={name:"preventOverflow",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name,a=n.mainAxis,s=void 0===a||a,i=n.altAxis,o=void 0!==i&&i,l=n.boundary,u=n.rootBoundary,c=n.altBoundary,d=n.padding,h=n.tether,p=void 0===h||h,f=n.tetherOffset,m=void 0===f?0:f,g=Zw(t,{boundary:l,rootBoundary:u,padding:d,altBoundary:c}),y=Mw(t.placement),b=Fw(t.placement),v=!b,x=Ow(y),w="x"===x?"y":"x",k=t.modifiersData.popperOffsets,S=t.rects.reference,I=t.rects.popper,T="function"===typeof m?m(Object.assign({},t.rects,{placement:t.placement})):m,N="number"===typeof T?{mainAxis:T,altAxis:T}:Object.assign({mainAxis:0,altAxis:0},T),C=t.modifiersData.offset?t.modifiersData.offset[t.placement]:null,A={x:0,y:0};if(k){if(s){var E,_="y"===x?pw:gw,$="y"===x?fw:mw,R="y"===x?"height":"width",D=k[x],M=D+g[_],F=D-g[$],O=p?-I[R]/2:0,P=b===vw?S[R]:I[R],L=b===vw?-I[R]:-S[R],z=t.elements.arrow,B=p&&z?iw(z):{width:0,height:0},V=t.modifiersData["arrow#persistent"]?t.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},W=V[_],U=V[$],j=ek(0,S[R],B[R]),G=v?S[R]/2-O-j-W-N.mainAxis:P-j-W-N.mainAxis,H=v?-S[R]/2+O+j+U+N.mainAxis:L+j+U+N.mainAxis,q=t.elements.arrow&&hw(t.elements.arrow),K=q?"y"===x?q.clientTop||0:q.clientLeft||0:0,Y=null!=(E=null==C?void 0:C[x])?E:0,X=D+H-Y,Q=ek(p?Kx(M,D+G-Y-K):M,D,p?qx(F,X):F);k[x]=Q,A[x]=Q-D}if(o){var Z,J="x"===x?pw:gw,ee="x"===x?fw:mw,te=k[w],ne="y"===w?"height":"width",re=te+g[J],ae=te-g[ee],se=-1!==[pw,gw].indexOf(y),ie=null!=(Z=null==C?void 0:C[w])?Z:0,oe=se?re:te-S[ne]-I[ne]-ie+N.altAxis,le=se?te+S[ne]+I[ne]-ie-N.altAxis:ae,ue=p&&se?function(e,t,n){var r=ek(e,t,n);return r>n?n:r}(oe,te,le):ek(p?oe:re,te,p?le:ae);k[w]=ue,A[w]=ue-te}t.modifiersData[r]=A}},requiresIfExists:["offset"]};const nk={name:"arrow",enabled:!0,phase:"main",fn:function(e){var t,n=e.state,r=e.name,a=e.options,s=n.elements.arrow,i=n.modifiersData.popperOffsets,o=Mw(n.placement),l=Ow(o),u=[gw,mw].indexOf(o)>=0?"height":"width";if(s&&i){var c=function(e,t){return Xw("number"!==typeof(e="function"===typeof e?e(Object.assign({},t.rects,{placement:t.placement})):e)?e:Qw(e,bw))}(a.padding,n),d=iw(s),h="y"===l?pw:gw,p="y"===l?fw:mw,f=n.rects.reference[u]+n.rects.reference[l]-i[l]-n.rects.popper[u],m=i[l]-n.rects.reference[l],g=hw(s),y=g?"y"===l?g.clientHeight||0:g.clientWidth||0:0,b=f/2-m/2,v=c[h],x=y-d[u]-c[p],w=y/2-d[u]/2+b,k=ek(v,w,x),S=l;n.modifiersData[r]=((t={})[S]=k,t.centerOffset=k-w,t)}},effect:function(e){var t=e.state,n=e.options.element,r=void 0===n?"[data-popper-arrow]":n;null!=r&&("string"!==typeof r||(r=t.elements.popper.querySelector(r)))&&Hw(t.elements.popper,r)&&(t.elements.arrow=r)},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function rk(e,t,n){return void 0===n&&(n={x:0,y:0}),{top:e.top-t.height-n.y,right:e.right-t.width+n.x,bottom:e.bottom-t.height+n.y,left:e.left-t.width-n.x}}function ak(e){return[pw,mw,fw,gw].some((function(t){return e[t]>=0}))}var sk=Rw({defaultModifiers:[{name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(e){var t=e.state,n=e.instance,r=e.options,a=r.scroll,s=void 0===a||a,i=r.resize,o=void 0===i||i,l=Ux(t.elements.popper),u=[].concat(t.scrollParents.reference,t.scrollParents.popper);return s&&u.forEach((function(e){e.addEventListener("scroll",n.update,Dw)})),o&&l.addEventListener("resize",n.update,Dw),function(){s&&u.forEach((function(e){e.removeEventListener("scroll",n.update,Dw)})),o&&l.removeEventListener("resize",n.update,Dw)}},data:{}},{name:"popperOffsets",enabled:!0,phase:"read",fn:function(e){var t=e.state,n=e.name;t.modifiersData[n]=Pw({reference:t.rects.reference,element:t.rects.popper,strategy:"absolute",placement:t.placement})},data:{}},{name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(e){var t=e.state,n=e.options,r=n.gpuAcceleration,a=void 0===r||r,s=n.adaptive,i=void 0===s||s,o=n.roundOffsets,l=void 0===o||o,u={placement:Mw(t.placement),variation:Fw(t.placement),popper:t.elements.popper,popperRect:t.rects.popper,gpuAcceleration:a,isFixed:"fixed"===t.options.strategy};null!=t.modifiersData.popperOffsets&&(t.styles.popper=Object.assign({},t.styles.popper,zw(Object.assign({},u,{offsets:t.modifiersData.popperOffsets,position:t.options.strategy,adaptive:i,roundOffsets:l})))),null!=t.modifiersData.arrow&&(t.styles.arrow=Object.assign({},t.styles.arrow,zw(Object.assign({},u,{offsets:t.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:l})))),t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-placement":t.placement})},data:{}},Bw,Vw,Jw,tk,nk,{name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(e){var t=e.state,n=e.name,r=t.rects.reference,a=t.rects.popper,s=t.modifiersData.preventOverflow,i=Zw(t,{elementContext:"reference"}),o=Zw(t,{altBoundary:!0}),l=rk(i,r),u=rk(o,a,s),c=ak(l),d=ak(u);t.modifiersData[n]={referenceClippingOffsets:l,popperEscapeOffsets:u,isReferenceHidden:c,hasPopperEscaped:d},t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-reference-hidden":c,"data-popper-escaped":d})}}]});function ik(e){return(0,Kn.Ay)("MuiPopper",e)}(0,Fn.A)("MuiPopper",["root"]);function ok(e){return"function"===typeof e?e():e}function lk(e){return void 0!==e.nodeType}const uk={},ck=t.forwardRef((function(e,n){const{anchorEl:r,children:a,direction:s,disablePortal:i,modifiers:o,open:l,placement:u,popperOptions:c,popperRef:d,slotProps:h={},slots:p={},TransitionProps:f,ownerState:m,...g}=e,y=t.useRef(null),b=(0,br.A)(y,n),v=t.useRef(null),x=(0,br.A)(v,d),w=t.useRef(x);(0,xr.A)((()=>{w.current=x}),[x]),t.useImperativeHandle(d,(()=>v.current),[]);const k=function(e,t){if("ltr"===t)return e;switch(e){case"bottom-end":return"bottom-start";case"bottom-start":return"bottom-end";case"top-end":return"top-start";case"top-start":return"top-end";default:return e}}(u,s),[S,I]=t.useState(k),[T,N]=t.useState(ok(r));t.useEffect((()=>{v.current&&v.current.forceUpdate()})),t.useEffect((()=>{r&&N(ok(r))}),[r]),(0,xr.A)((()=>{if(!T||!l)return;let e=[{name:"preventOverflow",options:{altBoundary:i}},{name:"flip",options:{altBoundary:i}},{name:"onUpdate",enabled:!0,phase:"afterWrite",fn:e=>{let{state:t}=e;(e=>{I(e.placement)})(t)}}];null!=o&&(e=e.concat(o)),c&&null!=c.modifiers&&(e=e.concat(c.modifiers));const t=sk(T,y.current,{placement:k,...c,modifiers:e});return w.current(t),()=>{t.destroy(),w.current(null)}}),[T,i,o,l,c,k]);const C={placement:S};null!==f&&(C.TransitionProps=f);const A=(e=>{const{classes:t}=e;return(0,Bn.A)({root:["root"]},ik,t)})(e),E=p.root??"div",_=Wa({elementType:E,externalSlotProps:h.root,externalForwardedProps:g,additionalProps:{role:"tooltip",ref:b},ownerState:e,className:A.root});return(0,$n.jsx)(E,{..._,children:"function"===typeof a?a(C):a})})),dk=t.forwardRef((function(e,n){const{anchorEl:r,children:a,container:s,direction:i="ltr",disablePortal:o=!1,keepMounted:l=!1,modifiers:u,open:c,placement:d="bottom",popperOptions:h=uk,popperRef:p,style:f,transition:m=!1,slotProps:g={},slots:y={},...b}=e,[v,x]=t.useState(!0);if(!l&&!c&&(!m||v))return null;let w;if(s)w=s;else if(r){const e=ok(r);w=e&&lk(e)?(0,_s.A)(e).body:(0,_s.A)(null).body}const k=c||!l||m&&!v?void 0:"none",S=m?{in:c,onEnter:()=>{x(!1)},onExited:()=>{x(!0)}}:void 0;return(0,$n.jsx)(Os,{disablePortal:o,container:w,children:(0,$n.jsx)(ck,{anchorEl:r,direction:i,disablePortal:o,modifiers:u,ref:n,open:m?!v:c,placement:d,popperOptions:h,popperRef:p,slotProps:g,slots:y,...b,style:{position:"fixed",top:0,left:0,display:k,...f},TransitionProps:S,children:a})})})),hk=dk,pk=(0,Wn.Ay)(hk,{name:"MuiPopper",slot:"Root",overridesResolver:(e,t)=>t.root})({}),fk=t.forwardRef((function(e,t){const n=Fa(),r=(0,Hn.b)({props:e,name:"MuiPopper"}),{anchorEl:a,component:s,components:i,componentsProps:o,container:l,disablePortal:u,keepMounted:c,modifiers:d,open:h,placement:p,popperOptions:f,popperRef:m,transition:g,slots:y,slotProps:b,...v}=r,x=y?.root??i?.Root,w={anchorEl:a,container:l,disablePortal:u,keepMounted:c,modifiers:d,open:h,placement:p,popperOptions:f,popperRef:m,transition:g,...v};return(0,$n.jsx)(pk,{as:s,direction:n?"rtl":"ltr",slots:{root:x},slotProps:b??o,...w,ref:t})})),mk="undefined"!==typeof window?t.useLayoutEffect:t.useEffect;const gk=function(e){const n=t.useRef(e);return mk((()=>{n.current=e})),t.useRef((function(){return(0,n.current)(...arguments)})).current};function yk(e){return e&&e.ownerDocument||document}function bk(e){return dx("MuiPickersPopper",e)}hx("MuiPickersPopper",["root","paper"]);const vk=function(){const e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:document).activeElement;return e?e.shadowRoot?vk(e.shadowRoot):e:null},xk="@media (pointer: fine)",wk="undefined"!==typeof navigator&&navigator.userAgent.match(/android\s(\d+)|OS\s(\d+)/i),kk=wk&&wk[1]?parseInt(wk[1],10):null,Sk=wk&&wk[2]?parseInt(wk[2],10):null,Ik=kk&&kk<10||Sk&&Sk<13||!1,Tk=()=>cv("@media (prefers-reduced-motion: reduce)",{defaultMatches:!1})||Ik,Nk=["PaperComponent","popperPlacement","ownerState","children","paperSlotProps","paperClasses","onPaperClick","onPaperTouchStart"],Ck=(0,Wn.Ay)(fk,{name:"MuiPickersPopper",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;return{zIndex:t.zIndex.modal}})),Ak=(0,Wn.Ay)(Zn,{name:"MuiPickersPopper",slot:"Paper",overridesResolver:(e,t)=>t.paper})({outline:0,transformOrigin:"top center",variants:[{props:e=>{let{placement:t}=e;return["top","top-start","top-end"].includes(t)},style:{transformOrigin:"bottom center"}}]});const Ek=t.forwardRef(((e,t)=>{const{PaperComponent:n,popperPlacement:r,ownerState:a,children:s,paperSlotProps:i,paperClasses:o,onPaperClick:l,onPaperTouchStart:u}=e,c=us(e,Nk),d=(0,oo.A)({},a,{placement:r}),h=Dx({elementType:n,externalSlotProps:i,additionalProps:{tabIndex:-1,elevation:8,ref:t},className:o,ownerState:d});return(0,$n.jsx)(n,(0,oo.A)({},c,h,{onClick:e=>{l(e),h.onClick?.(e)},onTouchStart:e=>{u(e),h.onTouchStart?.(e)},ownerState:d,children:s}))}));function _k(e){const n=Hi({props:e,name:"MuiPickersPopper"}),{anchorEl:r,children:a,containerRef:s=null,shouldRestoreFocus:i,onBlur:o,onDismiss:l,open:u,role:c,placement:d,slots:h,slotProps:p,reduceAnimations:f}=n;t.useEffect((()=>{function e(e){u&&"Escape"===e.key&&l()}return document.addEventListener("keydown",e),()=>{document.removeEventListener("keydown",e)}}),[l,u]);const m=t.useRef(null);t.useEffect((()=>{"tooltip"===c||i&&!i()||(u?m.current=vk(document):m.current&&m.current instanceof HTMLElement&&setTimeout((()=>{m.current instanceof HTMLElement&&m.current.focus()})))}),[u,c,i]);const[g,y,b]=function(e,n){const r=t.useRef(!1),a=t.useRef(!1),s=t.useRef(null),i=t.useRef(!1);t.useEffect((()=>{if(e)return document.addEventListener("mousedown",t,!0),document.addEventListener("touchstart",t,!0),()=>{document.removeEventListener("mousedown",t,!0),document.removeEventListener("touchstart",t,!0),i.current=!1};function t(){i.current=!0}}),[e]);const o=gk((e=>{if(!i.current)return;const t=a.current;a.current=!1;const o=yk(s.current);if(!s.current||"clientX"in e&&function(e,t){return t.documentElement.clientWidth<e.clientX||t.documentElement.clientHeight<e.clientY}(e,o))return;if(r.current)return void(r.current=!1);let l;l=e.composedPath?e.composedPath().indexOf(s.current)>-1:!o.documentElement.contains(e.target)||s.current.contains(e.target),l||t||n(e)})),l=()=>{a.current=!0};return t.useEffect((()=>{if(e){const e=yk(s.current),t=()=>{r.current=!0};return e.addEventListener("touchstart",o),e.addEventListener("touchmove",t),()=>{e.removeEventListener("touchstart",o),e.removeEventListener("touchmove",t)}}}),[e,o]),t.useEffect((()=>{if(e){const e=yk(s.current);return e.addEventListener("click",o),()=>{e.removeEventListener("click",o),a.current=!1}}}),[e,o]),[s,l,l]}(u,o??l),v=Nx(t.useRef(null),s),x=Nx(v,g),w=n,k=(e=>{const{classes:t}=e;return ix({root:["root"],paper:["paper"]},bk,t)})(w),S=Tk(),I=f??S,T=h?.desktopTransition??I?Bs:Es,N=h?.desktopTrapFocus??Ms,C=h?.desktopPaper??Ak,A=h?.popper??Ck,E=Dx({elementType:A,externalSlotProps:p?.popper,additionalProps:{transition:!0,role:c,open:u,anchorEl:r,placement:d,onKeyDown:e=>{"Escape"===e.key&&(e.stopPropagation(),l())}},className:k.root,ownerState:n});return(0,$n.jsx)(A,(0,oo.A)({},E,{children:e=>{let{TransitionProps:t,placement:n}=e;return(0,$n.jsx)(N,(0,oo.A)({open:u,disableAutoFocus:!0,disableRestoreFocus:!0,disableEnforceFocus:"tooltip"===c,isEnabled:()=>!0},p?.desktopTrapFocus,{children:(0,$n.jsx)(T,(0,oo.A)({},t,p?.desktopTransition,{children:(0,$n.jsx)(Ek,{PaperComponent:C,ownerState:w,popperPlacement:n,ref:x,onPaperClick:y,onPaperTouchStart:b,paperClasses:k.paper,paperSlotProps:p?.desktopPaper,children:a})}))}))}}))}function $k(e,n,r,a){const{value:s,onError:i}=e,o=nx(),l=t.useRef(a),u=n({adapter:o,value:s,props:e});return t.useEffect((()=>{i&&!r(u,l.current)&&i(u,s),l.current=u}),[r,i,l,u,s]),u}function Rk(e){let{controlled:n,default:r,name:a,state:s="value"}=e;const{current:i}=t.useRef(void 0!==n),[o,l]=t.useState(r);return[i?n:o,t.useCallback((e=>{i||l(e)}),[])]}const Dk=e=>{let{timezone:n,value:r,defaultValue:a,onChange:s,valueManager:i}=e;const o=rx(),l=t.useRef(a),u=r??l.current??i.emptyValue,c=t.useMemo((()=>i.getTimezone(o,u)),[o,i,u]),d=gk((e=>null==c?e:i.setTimezone(o,c,e))),h=n??c??"default";return{value:t.useMemo((()=>i.setTimezone(o,h,u)),[i,o,h,u]),handleValueChange:gk((function(e){const t=d(e);for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];s?.(t,...r)})),timezone:h}},Mk=e=>{let{name:t,timezone:n,value:r,defaultValue:a,onChange:s,valueManager:i}=e;const[o,l]=Rk({name:t,state:"value",controlled:r,default:a??i.emptyValue}),u=gk((function(e){l(e);for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];s?.(e,...n)}));return Dk({timezone:n,value:o,defaultValue:void 0,onChange:u,valueManager:i})},Fk=e=>{let{props:n,valueManager:r,valueType:a,wrapperVariant:s,validator:i}=e;const{onAccept:o,onChange:l,value:u,defaultValue:c,closeOnSelect:d="desktop"===s,timezone:h}=n,{current:p}=t.useRef(c),{current:f}=t.useRef(void 0!==u);const m=rx(),g=nx(),{isOpen:y,setIsOpen:b}=(e=>{let{open:n,onOpen:r,onClose:a}=e;const s=t.useRef("boolean"===typeof n).current,[i,o]=t.useState(!1);return t.useEffect((()=>{if(s){if("boolean"!==typeof n)throw new Error("You must not mix controlling and uncontrolled mode for `open` prop");o(n)}}),[s,n]),{isOpen:i,setIsOpen:t.useCallback((e=>{s||o(e),e&&r&&r(),!e&&a&&a()}),[s,r,a])}})(n),{timezone:v,value:x,handleValueChange:w}=Dk({timezone:h,value:u,defaultValue:p,onChange:l,valueManager:r}),[k,S]=t.useState((()=>{let e;return e=void 0!==x?x:void 0!==p?p:r.emptyValue,{draft:e,lastPublishedValue:e,lastCommittedValue:e,lastControlledValue:x,hasBeenModifiedSinceMount:!1}}));$k((0,oo.A)({},n,{value:k.draft,timezone:v}),i,r.isSameError,r.defaultErrorState);const I=gk((e=>{const t={action:e,dateState:k,hasChanged:t=>!r.areValuesEqual(m,e.value,t),isControlled:f,closeOnSelect:d},a=(e=>{const{action:t,hasChanged:n,dateState:r,isControlled:a}=e,s=!a&&!r.hasBeenModifiedSinceMount;return"setValueFromField"===t.name||("setValueFromAction"===t.name?!(!s||!["accept","today","clear"].includes(t.pickerAction))||n(r.lastPublishedValue):("setValueFromView"===t.name&&"shallow"!==t.selectionState||"setValueFromShortcut"===t.name)&&(!!s||n(r.lastPublishedValue)))})(t),s=(e=>{const{action:t,hasChanged:n,dateState:r,isControlled:a,closeOnSelect:s}=e,i=!a&&!r.hasBeenModifiedSinceMount;return"setValueFromAction"===t.name?!(!i||!["accept","today","clear"].includes(t.pickerAction))||n(r.lastCommittedValue):"setValueFromView"===t.name&&"finish"===t.selectionState&&s?!!i||n(r.lastCommittedValue):"setValueFromShortcut"===t.name&&"accept"===t.changeImportance&&n(r.lastCommittedValue)})(t),l=(e=>{const{action:t,closeOnSelect:n}=e;return"setValueFromAction"===t.name||("setValueFromView"===t.name?"finish"===t.selectionState&&n:"setValueFromShortcut"===t.name&&"accept"===t.changeImportance)})(t);S((t=>(0,oo.A)({},t,{draft:e.value,lastPublishedValue:a?e.value:t.lastPublishedValue,lastCommittedValue:s?e.value:t.lastCommittedValue,hasBeenModifiedSinceMount:!0})));let u=null;const c=()=>{if(!u){const t="setValueFromField"===e.name?e.context.validationError:i({adapter:g,value:e.value,props:(0,oo.A)({},n,{value:e.value,timezone:v})});u={validationError:t},"setValueFromShortcut"===e.name&&(u.shortcut=e.shortcut)}return u};a&&w(e.value,c()),s&&o&&o(e.value,c()),l&&b(!1)}));if(void 0!==x&&(void 0===k.lastControlledValue||!r.areValuesEqual(m,k.lastControlledValue,x))){const e=r.areValuesEqual(m,k.draft,x);S((t=>(0,oo.A)({},t,{lastControlledValue:x},e?{}:{lastCommittedValue:x,lastPublishedValue:x,draft:x,hasBeenModifiedSinceMount:!0})))}const T=gk((()=>{I({value:r.emptyValue,name:"setValueFromAction",pickerAction:"clear"})})),N=gk((()=>{I({value:k.lastPublishedValue,name:"setValueFromAction",pickerAction:"accept"})})),C=gk((()=>{I({value:k.lastPublishedValue,name:"setValueFromAction",pickerAction:"dismiss"})})),A=gk((()=>{I({value:k.lastCommittedValue,name:"setValueFromAction",pickerAction:"cancel"})})),E=gk((()=>{I({value:r.getTodayValue(m,v,a),name:"setValueFromAction",pickerAction:"today"})})),_=gk((e=>{e.preventDefault(),b(!0)})),$=gk((e=>{e?.preventDefault(),b(!1)})),R=gk((function(e){return I({name:"setValueFromView",value:e,selectionState:arguments.length>1&&void 0!==arguments[1]?arguments[1]:"partial"})})),D=gk(((e,t,n)=>I({name:"setValueFromShortcut",value:e,changeImportance:t,shortcut:n}))),M=gk(((e,t)=>I({name:"setValueFromField",value:e,context:t}))),F={onClear:T,onAccept:N,onDismiss:C,onCancel:A,onSetToday:E,onOpen:_,onClose:$},O={value:k.draft,onChange:M},P=t.useMemo((()=>r.cleanValue(m,k.draft)),[m,r,k.draft]);return{open:y,fieldProps:O,viewProps:{value:P,onChange:R,onClose:$,open:y},layoutProps:(0,oo.A)({},F,{value:P,onChange:R,onSelectShortcut:D,isValid:e=>{const t=i({adapter:g,value:e,props:(0,oo.A)({},n,{value:e,timezone:v})});return!r.hasError(t)}}),actions:F}};function Ok(e){let{onChange:n,onViewChange:r,openTo:a,view:s,views:i,autoFocus:o,focusedView:l,onFocusedViewChange:u}=e;const c=t.useRef(a),d=t.useRef(i),h=t.useRef(i.includes(a)?a:i[0]),[p,f]=Rk({name:"useViews",state:"view",controlled:s,default:h.current}),m=t.useRef(o?p:null),[g,y]=Rk({name:"useViews",state:"focusedView",controlled:l,default:m.current});t.useEffect((()=>{(c.current&&c.current!==a||d.current&&d.current.some((e=>!i.includes(e))))&&(f(i.includes(a)?a:i[0]),d.current=i,c.current=a)}),[a,f,p,i]);const b=i.indexOf(p),v=i[b-1]??null,x=i[b+1]??null,w=gk(((e,t)=>{y(t?e:t=>e===t?null:t),u?.(e,t)})),k=gk((e=>{w(e,!0),e!==p&&(f(e),r&&r(e))})),S=gk((()=>{x&&k(x)})),I=gk(((e,t,r)=>{const a="finish"===t,s=r?i.indexOf(r)<i.length-1:Boolean(x);if(n(e,a&&s?"partial":t,r),r&&r!==p){const e=i[i.indexOf(r)+1];e&&k(e)}else a&&S()}));return{view:p,setView:k,focusedView:g,setFocusedView:w,nextView:x,previousView:v,defaultView:i.includes(a)?a:i[0],goToNextView:S,setValueAndGoToNextView:I}}const Pk=["className","sx"],Lk=e=>{let{props:n,propsFromPickerValue:r,additionalViewProps:a,autoFocusView:s,rendererInterceptor:i,fieldRef:o}=e;const{onChange:l,open:u,onClose:c}=r,{view:d,views:h,openTo:p,onViewChange:f,viewRenderers:m,timezone:g}=n,y=us(n,Pk),{view:b,setView:v,defaultView:x,focusedView:w,setFocusedView:k,setValueAndGoToNextView:S}=Ok({view:d,views:h,openTo:p,onChange:l,onViewChange:f,autoFocus:s}),{hasUIView:I,viewModeLookup:T}=t.useMemo((()=>h.reduce(((e,t)=>{let n;return n=null!=m[t]?"UI":"field",e.viewModeLookup[t]=n,"UI"===n&&(e.hasUIView=!0),e}),{hasUIView:!1,viewModeLookup:{}})),[m,h]),N=t.useMemo((()=>h.reduce(((e,t)=>null!=m[t]&&(e=>Tv.includes(e))(t)?e+1:e),0)),[m,h]),C=T[b],A=gk((()=>"UI"===C)),[E,_]=t.useState("UI"===C?b:null);E!==b&&"UI"===T[b]&&_(b),mk((()=>{"field"===C&&u&&(c(),setTimeout((()=>{o?.current?.setSelectedSections(b),o?.current?.focusField(b)})))}),[b]),mk((()=>{if(!u)return;let e=b;"field"===C&&null!=E&&(e=E),e!==x&&"UI"===T[e]&&"UI"===T[x]&&(e=x),e!==b&&v(e),k(e,!0)}),[u]);return{hasUIView:I,shouldRestoreFocus:A,layoutProps:{views:h,view:E,onViewChange:v},renderCurrentView:()=>{if(null==E)return null;const e=m[E];if(null==e)return null;const t=(0,oo.A)({},y,a,r,{views:h,timezone:g,onChange:S,view:E,onViewChange:v,focusedView:w,onFocusedViewChange:k,showViewSwitcher:N>1,timeViewsCount:N});return i?i(m,E,t):e(t)}}};function zk(){return"undefined"===typeof window?"portrait":window.screen&&window.screen.orientation&&window.screen.orientation.angle?90===Math.abs(window.screen.orientation.angle)?"landscape":"portrait":window.orientation&&90===Math.abs(Number(window.orientation))?"landscape":"portrait"}const Bk=(e,n)=>{const[r,a]=t.useState(zk);if(mk((()=>{const e=()=>{a(zk())};return window.addEventListener("orientationchange",e),()=>{window.removeEventListener("orientationchange",e)}}),[]),function(e,t){return Array.isArray(t)?t.every((t=>-1!==e.indexOf(t))):-1!==e.indexOf(t)}(e,["hours","minutes","seconds"]))return!1;return"landscape"===(n||r)},Vk=e=>{let{props:t,valueManager:n,valueType:r,wrapperVariant:a,additionalViewProps:s,validator:i,autoFocusView:o,rendererInterceptor:l,fieldRef:u}=e;const c=Fk({props:t,valueManager:n,valueType:r,wrapperVariant:a,validator:i}),d=Lk({props:t,additionalViewProps:s,autoFocusView:o,fieldRef:u,propsFromPickerValue:c.viewProps,rendererInterceptor:l}),h=(e=>{let{props:t,propsFromPickerValue:n,propsFromPickerViews:r,wrapperVariant:a}=e;const{orientation:s}=t,i=Bk(r.views,s),o=Fa();return{layoutProps:(0,oo.A)({},r,n,{isLandscape:i,isRtl:o,wrapperVariant:a,disabled:t.disabled,readOnly:t.readOnly})}})({props:t,wrapperVariant:a,propsFromPickerValue:c.layoutProps,propsFromPickerViews:d.layoutProps});return{open:c.open,actions:c.actions,fieldProps:c.fieldProps,renderCurrentView:d.renderCurrentView,hasUIView:d.hasUIView,shouldRestoreFocus:d.shouldRestoreFocus,layoutProps:h.layoutProps}};function Wk(e){return dx("MuiPickersLayout",e)}const Uk=hx("MuiPickersLayout",["root","landscape","contentWrapper","toolbar","actionBar","tabs","shortcuts"]),jk=["onAccept","onClear","onCancel","onSetToday","actions"];function Gk(e){const{onAccept:t,onClear:n,onCancel:r,onSetToday:a,actions:s}=e,i=us(e,jk),o=bx();if(null==s||0===s.length)return null;const l=s?.map((e=>{switch(e){case"clear":return(0,$n.jsx)(Po,{onClick:n,children:o.clearButtonLabel},e);case"cancel":return(0,$n.jsx)(Po,{onClick:r,children:o.cancelButtonLabel},e);case"accept":return(0,$n.jsx)(Po,{onClick:t,children:o.okButtonLabel},e);case"today":return(0,$n.jsx)(Po,{onClick:a,children:o.todayButtonLabel},e);default:return null}}));return(0,$n.jsx)(Pl,(0,oo.A)({},i,{children:l}))}function Hk(e){return(0,Kn.Ay)("MuiListItem",e)}(0,Fn.A)("MuiListItem",["root","container","dense","alignItemsFlexStart","divider","gutters","padding","secondaryAction"]);const qk=(0,Fn.A)("MuiListItemButton",["root","focusVisible","dense","alignItemsFlexStart","disabled","divider","gutters","selected"]);function Kk(e){return(0,Kn.Ay)("MuiListItemSecondaryAction",e)}(0,Fn.A)("MuiListItemSecondaryAction",["root","disableGutters"]);const Yk=(0,Wn.Ay)("div",{name:"MuiListItemSecondaryAction",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.disableGutters&&t.disableGutters]}})({position:"absolute",right:16,top:"50%",transform:"translateY(-50%)",variants:[{props:e=>{let{ownerState:t}=e;return t.disableGutters},style:{right:0}}]}),Xk=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiListItemSecondaryAction"}),{className:a,...s}=r,i=t.useContext(Ua),o={...r,disableGutters:i.disableGutters},l=(e=>{const{disableGutters:t,classes:n}=e,r={root:["root",t&&"disableGutters"]};return(0,Bn.A)(r,Kk,n)})(o);return(0,$n.jsx)(Yk,{className:(0,vn.A)(l.root,a),ownerState:o,ref:n,...s})}));Xk.muiName="ListItemSecondaryAction";const Qk=Xk,Zk=(0,Wn.Ay)("div",{name:"MuiListItem",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,n.dense&&t.dense,"flex-start"===n.alignItems&&t.alignItemsFlexStart,n.divider&&t.divider,!n.disableGutters&&t.gutters,!n.disablePadding&&t.padding,n.hasSecondaryAction&&t.secondaryAction]}})((0,Gn.A)((e=>{let{theme:t}=e;return{display:"flex",justifyContent:"flex-start",alignItems:"center",position:"relative",textDecoration:"none",width:"100%",boxSizing:"border-box",textAlign:"left",variants:[{props:e=>{let{ownerState:t}=e;return!t.disablePadding},style:{paddingTop:8,paddingBottom:8}},{props:e=>{let{ownerState:t}=e;return!t.disablePadding&&t.dense},style:{paddingTop:4,paddingBottom:4}},{props:e=>{let{ownerState:t}=e;return!t.disablePadding&&!t.disableGutters},style:{paddingLeft:16,paddingRight:16}},{props:e=>{let{ownerState:t}=e;return!t.disablePadding&&!!t.secondaryAction},style:{paddingRight:48}},{props:e=>{let{ownerState:t}=e;return!!t.secondaryAction},style:{[`& > .${qk.root}`]:{paddingRight:48}}},{props:{alignItems:"flex-start"},style:{alignItems:"flex-start"}},{props:e=>{let{ownerState:t}=e;return t.divider},style:{borderBottom:`1px solid ${(t.vars||t).palette.divider}`,backgroundClip:"padding-box"}},{props:e=>{let{ownerState:t}=e;return t.button},style:{transition:t.transitions.create("background-color",{duration:t.transitions.duration.shortest}),"&:hover":{textDecoration:"none",backgroundColor:(t.vars||t).palette.action.hover,"@media (hover: none)":{backgroundColor:"transparent"}}}},{props:e=>{let{ownerState:t}=e;return t.hasSecondaryAction},style:{paddingRight:48}}]}}))),Jk=(0,Wn.Ay)("li",{name:"MuiListItem",slot:"Container",overridesResolver:(e,t)=>t.container})({position:"relative"}),eS=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiListItem"}),{alignItems:a="center",children:s,className:i,component:o,components:l={},componentsProps:u={},ContainerComponent:c="li",ContainerProps:{className:d,...h}={},dense:p=!1,disableGutters:f=!1,disablePadding:m=!1,divider:g=!1,secondaryAction:y,slotProps:b={},slots:v={},...x}=r,w=t.useContext(Ua),k=t.useMemo((()=>({dense:p||w.dense||!1,alignItems:a,disableGutters:f})),[a,w.dense,p,f]),S=t.useRef(null),I=t.Children.toArray(s),T=I.length&&(0,ka.A)(I[I.length-1],["ListItemSecondaryAction"]),N={...r,alignItems:a,dense:k.dense,disableGutters:f,disablePadding:m,divider:g,hasSecondaryAction:T},C=(e=>{const{alignItems:t,classes:n,dense:r,disableGutters:a,disablePadding:s,divider:i,hasSecondaryAction:o}=e,l={root:["root",r&&"dense",!a&&"gutters",!s&&"padding",i&&"divider","flex-start"===t&&"alignItemsFlexStart",o&&"secondaryAction"],container:["container"]};return(0,Bn.A)(l,Hk,n)})(N),A=(0,_r.A)(S,n),E=v.root||l.Root||Zk,_=b.root||u.root||{},$={className:(0,vn.A)(C.root,_.className,i),...x};let R=o||"li";return T?(R=$.component||o?R:"div","li"===c&&("li"===R?R="div":"li"===$.component&&($.component="div")),(0,$n.jsx)(Ua.Provider,{value:k,children:(0,$n.jsxs)(Jk,{as:c,className:(0,vn.A)(C.container,d),ref:A,ownerState:N,...h,children:[(0,$n.jsx)(E,{..._,...!Nr(E)&&{as:R,ownerState:{...N,..._.ownerState}},...$,children:I}),I.pop()]})})):(0,$n.jsx)(Ua.Provider,{value:k,children:(0,$n.jsxs)(E,{..._,as:R,ref:A,...!Nr(E)&&{ownerState:{...N,..._.ownerState}},...$,children:[I,y&&(0,$n.jsx)(Qk,{children:y})]})})})),tS=eS,nS=(0,Vi.A)((0,$n.jsx)("path",{d:"M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"}),"Cancel");function rS(e){return(0,Kn.Ay)("MuiChip",e)}const aS=(0,Fn.A)("MuiChip",["root","sizeSmall","sizeMedium","colorDefault","colorError","colorInfo","colorPrimary","colorSecondary","colorSuccess","colorWarning","disabled","clickable","clickableColorPrimary","clickableColorSecondary","deletable","deletableColorPrimary","deletableColorSecondary","outlined","filled","outlinedPrimary","outlinedSecondary","filledPrimary","filledSecondary","avatar","avatarSmall","avatarMedium","avatarColorPrimary","avatarColorSecondary","icon","iconSmall","iconMedium","iconColorPrimary","iconColorSecondary","label","labelSmall","labelMedium","deleteIcon","deleteIconSmall","deleteIconMedium","deleteIconColorPrimary","deleteIconColorSecondary","deleteIconOutlinedColorPrimary","deleteIconOutlinedColorSecondary","deleteIconFilledColorPrimary","deleteIconFilledColorSecondary","focusVisible"]),sS=(0,Wn.Ay)("div",{name:"MuiChip",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e,{color:r,iconColor:a,clickable:s,onDelete:i,size:o,variant:l}=n;return[{[`& .${aS.avatar}`]:t.avatar},{[`& .${aS.avatar}`]:t[`avatar${(0,lr.A)(o)}`]},{[`& .${aS.avatar}`]:t[`avatarColor${(0,lr.A)(r)}`]},{[`& .${aS.icon}`]:t.icon},{[`& .${aS.icon}`]:t[`icon${(0,lr.A)(o)}`]},{[`& .${aS.icon}`]:t[`iconColor${(0,lr.A)(a)}`]},{[`& .${aS.deleteIcon}`]:t.deleteIcon},{[`& .${aS.deleteIcon}`]:t[`deleteIcon${(0,lr.A)(o)}`]},{[`& .${aS.deleteIcon}`]:t[`deleteIconColor${(0,lr.A)(r)}`]},{[`& .${aS.deleteIcon}`]:t[`deleteIcon${(0,lr.A)(l)}Color${(0,lr.A)(r)}`]},t.root,t[`size${(0,lr.A)(o)}`],t[`color${(0,lr.A)(r)}`],s&&t.clickable,s&&"default"!==r&&t[`clickableColor${(0,lr.A)(r)})`],i&&t.deletable,i&&"default"!==r&&t[`deletableColor${(0,lr.A)(r)}`],t[l],t[`${l}${(0,lr.A)(r)}`]]}})((0,Gn.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?t.palette.grey[700]:t.palette.grey[300];return{maxWidth:"100%",fontFamily:t.typography.fontFamily,fontSize:t.typography.pxToRem(13),display:"inline-flex",alignItems:"center",justifyContent:"center",height:32,color:(t.vars||t).palette.text.primary,backgroundColor:(t.vars||t).palette.action.selected,borderRadius:16,whiteSpace:"nowrap",transition:t.transitions.create(["background-color","box-shadow"]),cursor:"unset",outline:0,textDecoration:"none",border:0,padding:0,verticalAlign:"middle",boxSizing:"border-box",[`&.${aS.disabled}`]:{opacity:(t.vars||t).palette.action.disabledOpacity,pointerEvents:"none"},[`& .${aS.avatar}`]:{marginLeft:5,marginRight:-6,width:24,height:24,color:t.vars?t.vars.palette.Chip.defaultAvatarColor:n,fontSize:t.typography.pxToRem(12)},[`& .${aS.avatarColorPrimary}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.dark},[`& .${aS.avatarColorSecondary}`]:{color:(t.vars||t).palette.secondary.contrastText,backgroundColor:(t.vars||t).palette.secondary.dark},[`& .${aS.avatarSmall}`]:{marginLeft:4,marginRight:-4,width:18,height:18,fontSize:t.typography.pxToRem(10)},[`& .${aS.icon}`]:{marginLeft:5,marginRight:-6},[`& .${aS.deleteIcon}`]:{WebkitTapHighlightColor:"transparent",color:t.vars?`rgba(${t.vars.palette.text.primaryChannel} / 0.26)`:(0,Vn.X4)(t.palette.text.primary,.26),fontSize:22,cursor:"pointer",margin:"0 5px 0 -6px","&:hover":{color:t.vars?`rgba(${t.vars.palette.text.primaryChannel} / 0.4)`:(0,Vn.X4)(t.palette.text.primary,.4)}},variants:[{props:{size:"small"},style:{height:24,[`& .${aS.icon}`]:{fontSize:18,marginLeft:4,marginRight:-4},[`& .${aS.deleteIcon}`]:{fontSize:16,marginRight:4,marginLeft:-4}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main&&t.contrastText})).map((e=>{let[n]=e;return{props:{color:n},style:{backgroundColor:(t.vars||t).palette[n].main,color:(t.vars||t).palette[n].contrastText,[`& .${aS.deleteIcon}`]:{color:t.vars?`rgba(${t.vars.palette[n].contrastTextChannel} / 0.7)`:(0,Vn.X4)(t.palette[n].contrastText,.7),"&:hover, &:active":{color:(t.vars||t).palette[n].contrastText}}}}})),{props:e=>e.iconColor===e.color,style:{[`& .${aS.icon}`]:{color:t.vars?t.vars.palette.Chip.defaultIconColor:n}}},{props:e=>e.iconColor===e.color&&"default"!==e.color,style:{[`& .${aS.icon}`]:{color:"inherit"}}},{props:{onDelete:!0},style:{[`&.${aS.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.focusOpacity}))`:(0,Vn.X4)(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.focusOpacity)}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.dark})).map((e=>{let[n]=e;return{props:{color:n,onDelete:!0},style:{[`&.${aS.focusVisible}`]:{background:(t.vars||t).palette[n].dark}}}})),{props:{clickable:!0},style:{userSelect:"none",WebkitTapHighlightColor:"transparent",cursor:"pointer","&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.hoverOpacity}))`:(0,Vn.X4)(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.hoverOpacity)},[`&.${aS.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.focusOpacity}))`:(0,Vn.X4)(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.focusOpacity)},"&:active":{boxShadow:(t.vars||t).shadows[1]}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.dark})).map((e=>{let[n]=e;return{props:{color:n,clickable:!0},style:{[`&:hover, &.${aS.focusVisible}`]:{backgroundColor:(t.vars||t).palette[n].dark}}}})),{props:{variant:"outlined"},style:{backgroundColor:"transparent",border:t.vars?`1px solid ${t.vars.palette.Chip.defaultBorder}`:`1px solid ${"light"===t.palette.mode?t.palette.grey[400]:t.palette.grey[700]}`,[`&.${aS.clickable}:hover`]:{backgroundColor:(t.vars||t).palette.action.hover},[`&.${aS.focusVisible}`]:{backgroundColor:(t.vars||t).palette.action.focus},[`& .${aS.avatar}`]:{marginLeft:4},[`& .${aS.avatarSmall}`]:{marginLeft:2},[`& .${aS.icon}`]:{marginLeft:4},[`& .${aS.iconSmall}`]:{marginLeft:2},[`& .${aS.deleteIcon}`]:{marginRight:5},[`& .${aS.deleteIconSmall}`]:{marginRight:3}}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{variant:"outlined",color:n},style:{color:(t.vars||t).palette[n].main,border:`1px solid ${t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.7)`:(0,Vn.X4)(t.palette[n].main,.7)}`,[`&.${aS.clickable}:hover`]:{backgroundColor:t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Vn.X4)(t.palette[n].main,t.palette.action.hoverOpacity)},[`&.${aS.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette[n].mainChannel} / ${t.vars.palette.action.focusOpacity})`:(0,Vn.X4)(t.palette[n].main,t.palette.action.focusOpacity)},[`& .${aS.deleteIcon}`]:{color:t.vars?`rgba(${t.vars.palette[n].mainChannel} / 0.7)`:(0,Vn.X4)(t.palette[n].main,.7),"&:hover, &:active":{color:(t.vars||t).palette[n].main}}}}}))]}}))),iS=(0,Wn.Ay)("span",{name:"MuiChip",slot:"Label",overridesResolver:(e,t)=>{const{ownerState:n}=e,{size:r}=n;return[t.label,t[`label${(0,lr.A)(r)}`]]}})({overflow:"hidden",textOverflow:"ellipsis",paddingLeft:12,paddingRight:12,whiteSpace:"nowrap",variants:[{props:{variant:"outlined"},style:{paddingLeft:11,paddingRight:11}},{props:{size:"small"},style:{paddingLeft:8,paddingRight:8}},{props:{size:"small",variant:"outlined"},style:{paddingLeft:7,paddingRight:7}}]});function oS(e){return"Backspace"===e.key||"Delete"===e.key}const lS=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiChip"}),{avatar:a,className:s,clickable:i,color:o="default",component:l,deleteIcon:u,disabled:c=!1,icon:d,label:h,onClick:p,onDelete:f,onKeyDown:m,onKeyUp:g,size:y="medium",variant:b="filled",tabIndex:v,skipFocusWhenDisabled:x=!1,...w}=r,k=t.useRef(null),S=(0,_r.A)(k,n),I=e=>{e.stopPropagation(),f&&f(e)},T=!(!1===i||!p)||i,N=T||f?Co:l||"div",C={...r,component:N,disabled:c,size:y,color:o,iconColor:t.isValidElement(d)&&d.props.color||o,onDelete:!!f,clickable:T,variant:b},A=(e=>{const{classes:t,disabled:n,size:r,color:a,iconColor:s,onDelete:i,clickable:o,variant:l}=e,u={root:["root",l,n&&"disabled",`size${(0,lr.A)(r)}`,`color${(0,lr.A)(a)}`,o&&"clickable",o&&`clickableColor${(0,lr.A)(a)}`,i&&"deletable",i&&`deletableColor${(0,lr.A)(a)}`,`${l}${(0,lr.A)(a)}`],label:["label",`label${(0,lr.A)(r)}`],avatar:["avatar",`avatar${(0,lr.A)(r)}`,`avatarColor${(0,lr.A)(a)}`],icon:["icon",`icon${(0,lr.A)(r)}`,`iconColor${(0,lr.A)(s)}`],deleteIcon:["deleteIcon",`deleteIcon${(0,lr.A)(r)}`,`deleteIconColor${(0,lr.A)(a)}`,`deleteIcon${(0,lr.A)(l)}Color${(0,lr.A)(a)}`]};return(0,Bn.A)(u,rS,t)})(C),E=N===Co?{component:l||"div",focusVisibleClassName:A.focusVisible,...f&&{disableRipple:!0}}:{};let _=null;f&&(_=u&&t.isValidElement(u)?t.cloneElement(u,{className:(0,vn.A)(u.props.className,A.deleteIcon),onClick:I}):(0,$n.jsx)(nS,{className:(0,vn.A)(A.deleteIcon),onClick:I}));let $=null;a&&t.isValidElement(a)&&($=t.cloneElement(a,{className:(0,vn.A)(A.avatar,a.props.className)}));let R=null;return d&&t.isValidElement(d)&&(R=t.cloneElement(d,{className:(0,vn.A)(A.icon,d.props.className)})),(0,$n.jsxs)(sS,{as:N,className:(0,vn.A)(A.root,s),disabled:!(!T||!c)||void 0,onClick:p,onKeyDown:e=>{e.currentTarget===e.target&&oS(e)&&e.preventDefault(),m&&m(e)},onKeyUp:e=>{e.currentTarget===e.target&&f&&oS(e)&&f(e),g&&g(e)},ref:S,tabIndex:x&&c?-1:v,ownerState:C,...E,...w,children:[$||R,(0,$n.jsx)(iS,{className:(0,vn.A)(A.label),ownerState:C,children:h}),_]})})),uS=lS,cS=320,dS=["items","changeImportance","isLandscape","onChange","isValid"],hS=["getValue"];function pS(e){const{items:t,changeImportance:n="accept",onChange:r,isValid:a}=e,s=us(e,dS);if(null==t||0===t.length)return null;const i=t.map((e=>{let{getValue:t}=e,s=us(e,hS);const i=t({isValid:a});return(0,oo.A)({},s,{label:s.label,onClick:()=>{r(i,n,s)},disabled:!a(i)})}));return(0,$n.jsx)(qa,(0,oo.A)({dense:!0,sx:[{maxHeight:336,maxWidth:200,overflow:"auto"},...Array.isArray(s.sx)?s.sx:[s.sx]]},s,{children:i.map((e=>(0,$n.jsx)(tS,{children:(0,$n.jsx)(uS,(0,oo.A)({},e))},e.id??e.label)))}))}const fS=e=>{const{wrapperVariant:t,onAccept:n,onClear:r,onCancel:a,onSetToday:s,view:i,views:o,onViewChange:l,value:u,onChange:c,onSelectShortcut:d,isValid:h,isLandscape:p,disabled:f,readOnly:m,children:g,slots:y,slotProps:b}=e,v=(e=>{const{classes:t,isLandscape:n}=e;return ix({root:["root",n&&"landscape"],contentWrapper:["contentWrapper"],toolbar:["toolbar"],actionBar:["actionBar"],tabs:["tabs"],landscape:["landscape"],shortcuts:["shortcuts"]},Wk,t)})(e),x=y?.actionBar??Gk,w=Dx({elementType:x,externalSlotProps:b?.actionBar,additionalProps:{onAccept:n,onClear:r,onCancel:a,onSetToday:s,actions:"desktop"===t?[]:["cancel","accept"]},className:v.actionBar,ownerState:(0,oo.A)({},e,{wrapperVariant:t})}),k=(0,$n.jsx)(x,(0,oo.A)({},w)),S=y?.toolbar,I=Dx({elementType:S,externalSlotProps:b?.toolbar,additionalProps:{isLandscape:p,onChange:c,value:u,view:i,onViewChange:l,views:o,disabled:f,readOnly:m},className:v.toolbar,ownerState:(0,oo.A)({},e,{wrapperVariant:t})}),T=function(e){return null!==e.view}(I)&&S?(0,$n.jsx)(S,(0,oo.A)({},I)):null,N=g,C=y?.tabs,A=i&&C?(0,$n.jsx)(C,(0,oo.A)({view:i,onViewChange:l,className:v.tabs},b?.tabs)):null,E=y?.shortcuts??pS,_=Dx({elementType:E,externalSlotProps:b?.shortcuts,additionalProps:{isValid:h,isLandscape:p,onChange:d},className:v.shortcuts,ownerState:{isValid:h,isLandscape:p,onChange:d,wrapperVariant:t}});return{toolbar:T,content:N,tabs:A,actionBar:k,shortcuts:i&&E?(0,$n.jsx)(E,(0,oo.A)({},_)):null}},mS=(0,Wn.Ay)("div",{name:"MuiPickersLayout",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"grid",gridAutoColumns:"max-content auto max-content",gridAutoRows:"max-content auto max-content",[`& .${Uk.actionBar}`]:{gridColumn:"1 / 4",gridRow:3},variants:[{props:{isLandscape:!0},style:{[`& .${Uk.toolbar}`]:{gridColumn:1,gridRow:"2 / 3"},[`.${Uk.shortcuts}`]:{gridColumn:"2 / 4",gridRow:1}}},{props:{isLandscape:!0,isRtl:!0},style:{[`& .${Uk.toolbar}`]:{gridColumn:3}}},{props:{isLandscape:!1},style:{[`& .${Uk.toolbar}`]:{gridColumn:"2 / 4",gridRow:1},[`& .${Uk.shortcuts}`]:{gridColumn:1,gridRow:"2 / 3"}}},{props:{isLandscape:!1,isRtl:!0},style:{[`& .${Uk.shortcuts}`]:{gridColumn:3}}}]}),gS=(0,Wn.Ay)("div",{name:"MuiPickersLayout",slot:"ContentWrapper",overridesResolver:(e,t)=>t.contentWrapper})({gridColumn:2,gridRow:2,display:"flex",flexDirection:"column"}),yS=t.forwardRef((function(e,n){const r=Hi({props:e,name:"MuiPickersLayout"}),{toolbar:a,content:s,tabs:i,actionBar:o,shortcuts:l}=fS(r),{sx:u,className:c,isLandscape:d,wrapperVariant:h}=r,p=(e=>{const{isLandscape:t,classes:n}=e;return ix({root:["root",t&&"landscape"],contentWrapper:["contentWrapper"]},Wk,n)})(r);return(0,$n.jsxs)(mS,{ref:n,sx:u,className:(0,vn.A)(c,p.root),ownerState:r,children:[d?l:a,d?a:l,(0,$n.jsx)(gS,{className:p.contentWrapper,children:"desktop"===h?(0,$n.jsxs)(t.Fragment,{children:[s,i]}):(0,$n.jsxs)(t.Fragment,{children:[i,s]})}),o]})})),bS=["props","getOpenDialogAriaText"],vS=["ownerState"],xS=["ownerState"],wS=(0,Vi.A)((0,$n.jsx)("path",{d:"M7 10l5 5 5-5z"}),"ArrowDropDown"),kS=(0,Vi.A)((0,$n.jsx)("path",{d:"M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"}),"ArrowLeft"),SS=(0,Vi.A)((0,$n.jsx)("path",{d:"M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"}),"ArrowRight"),IS=(0,Vi.A)((0,$n.jsx)("path",{d:"M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"}),"Calendar"),TS=((0,Vi.A)((0,$n.jsxs)(t.Fragment,{children:[(0,$n.jsx)("path",{d:"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"}),(0,$n.jsx)("path",{d:"M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"})]}),"Clock"),(0,Vi.A)((0,$n.jsx)("path",{d:"M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"}),"DateRange"),(0,Vi.A)((0,$n.jsxs)(t.Fragment,{children:[(0,$n.jsx)("path",{d:"M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"}),(0,$n.jsx)("path",{d:"M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z"})]}),"Time"),(0,Vi.A)((0,$n.jsx)("path",{d:"M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"}),"Clear")),NS=(e,t,n,r,a)=>{switch(r.type){case"year":return n.fieldYearPlaceholder({digitAmount:e.formatByString(e.date(void 0,t),a).length,format:a});case"month":return n.fieldMonthPlaceholder({contentType:r.contentType,format:a});case"day":return n.fieldDayPlaceholder({format:a});case"weekDay":return n.fieldWeekDayPlaceholder({contentType:r.contentType,format:a});case"hours":return n.fieldHoursPlaceholder({format:a});case"minutes":return n.fieldMinutesPlaceholder({format:a});case"seconds":return n.fieldSecondsPlaceholder({format:a});case"meridiem":return n.fieldMeridiemPlaceholder({format:a});default:return a}},CS=e=>{let{utils:t,timezone:n,date:r,shouldRespectLeadingZeros:a,localeText:s,localizedDigits:i,now:o,token:l,startSeparator:u}=e;if(""===l)throw new Error("MUI X: Should not call `commitToken` with an empty token");const c=_v(t,l),d=Uv(t,n,c.contentType,c.type,l),h=a?d:"digit"===c.contentType,p=null!=r&&t.isValid(r);let f=p?t.formatByString(r,l):"",m=null;if(h)if(d)m=""===f?t.formatByString(o,l).length:f.length;else{if(null==c.maxLength)throw new Error(`MUI X: The token ${l} should have a 'maxDigitNumber' property on it's adapter`);m=c.maxLength,p&&(f=Fv(Pv(Mv(f,i),m),i))}return(0,oo.A)({},c,{format:l,maxLength:m,value:f,placeholder:NS(t,n,s,c,l),hasLeadingZerosInFormat:d,hasLeadingZerosInInput:h,startSeparator:u,endSeparator:"",modified:!1})},AS=e=>{let t=(e=>{let{utils:t,format:n}=e,r=10,a=n,s=t.expandFormat(n);for(;s!==a;)if(a=s,s=t.expandFormat(a),r-=1,r<0)throw new Error("MUI X: The format expansion seems to be in an infinite loop. Please open an issue with the format passed to the picker component.");return s})(e);e.isRtl&&e.enableAccessibleFieldDOMStructure&&(t=t.split(" ").reverse().join(" "));const n=(e=>{let{utils:t,expandedFormat:n}=e;const r=[],{start:a,end:s}=t.escapedCharacters,i=new RegExp(`(\\${a}[^\\${s}]*\\${s})+`,"g");let o=null;for(;o=i.exec(n);)r.push({start:o.index,end:i.lastIndex-1});return r})((0,oo.A)({},e,{expandedFormat:t})),r=(e=>{const{utils:t,expandedFormat:n,escapedParts:r}=e,a=t.date(void 0),s=[];let i="";const o=Object.keys(t.formatTokenMap).sort(((e,t)=>t.length-e.length)),l=/^([a-zA-Z]+)/,u=new RegExp(`^(${o.join("|")})*$`),c=new RegExp(`^(${o.join("|")})`),d=e=>r.find((t=>t.start<=e&&t.end>=e));let h=0;for(;h<n.length;){const t=d(h),r=null!=t,o=l.exec(n.slice(h))?.[1];if(!r&&null!=o&&u.test(o)){let t=o;for(;t.length>0;){const n=c.exec(t)[1];t=t.slice(n.length),s.push(CS((0,oo.A)({},e,{now:a,token:n,startSeparator:i}))),i=""}h+=o.length}else{const e=n[h];r&&t?.start===h||t?.end===h||(0===s.length?i+=e:s[s.length-1].endSeparator+=e),h+=1}}return 0===s.length&&i.length>0&&s.push({type:"empty",contentType:"letter",maxLength:null,format:"",value:"",placeholder:"",hasLeadingZerosInFormat:!1,hasLeadingZerosInInput:!1,startSeparator:i,endSeparator:"",modified:!1}),s})((0,oo.A)({},e,{expandedFormat:t,escapedParts:n}));return(e=>{let{isRtl:t,formatDensity:n,sections:r}=e;return r.map((e=>{const r=e=>{let r=e;return t&&null!==r&&r.includes(" ")&&(r=`\u2069${r}\u2066`),"spacious"===n&&["/",".","-"].includes(r)&&(r=` ${r} `),r};return e.startSeparator=r(e.startSeparator),e.endSeparator=r(e.endSeparator),e}))})((0,oo.A)({},e,{sections:r}))},ES=e=>{const n=rx(),r=bx(),a=nx(),s=Fa(),{valueManager:i,fieldValueManager:o,valueType:l,validator:u,internalProps:c,internalProps:{value:d,defaultValue:h,referenceDate:p,onChange:f,format:m,formatDensity:g="dense",selectedSections:y,onSelectedSectionsChange:b,shouldRespectLeadingZeros:v=!1,timezone:x,enableAccessibleFieldDOMStructure:w=!1}}=e,{timezone:k,value:S,handleValueChange:I}=Dk({timezone:x,value:d,defaultValue:h,onChange:f,valueManager:i}),T=t.useMemo((()=>(e=>{const t=e.date(void 0);return"0"===e.formatByString(e.setSeconds(t,0),"s")?Dv:Array.from({length:10}).map(((n,r)=>e.formatByString(e.setSeconds(t,r),"s")))})(n)),[n]),N=t.useMemo((()=>((e,t,n)=>{const r=e.date(void 0,n),a=e.endOfYear(r),s=e.endOfDay(r),{maxDaysInMonth:i,longestMonth:o}=vv(e,r).reduce(((t,n)=>{const r=e.getDaysInMonth(n);return r>t.maxDaysInMonth?{maxDaysInMonth:r,longestMonth:n}:t}),{maxDaysInMonth:0,longestMonth:null});return{year:t=>{let{format:r}=t;return{minimum:0,maximum:Wv(e,n,r)?9999:99}},month:()=>({minimum:1,maximum:e.getMonth(a)+1}),day:t=>{let{currentDate:n}=t;return{minimum:1,maximum:null!=n&&e.isValid(n)?e.getDaysInMonth(n):i,longestMonth:o}},weekDay:t=>{let{format:r,contentType:a}=t;if("digit"===a){const t=$v(e,n,r).map(Number);return{minimum:Math.min(...t),maximum:Math.max(...t)}}return{minimum:1,maximum:7}},hours:n=>{let{format:a}=n;const i=e.getHours(s);return Mv(e.formatByString(e.endOfDay(r),a),t)!==i.toString()?{minimum:1,maximum:Number(Mv(e.formatByString(e.startOfDay(r),a),t))}:{minimum:0,maximum:i}},minutes:()=>({minimum:0,maximum:e.getMinutes(s)}),seconds:()=>({minimum:0,maximum:e.getSeconds(s)}),meridiem:()=>({minimum:0,maximum:1}),empty:()=>({minimum:0,maximum:0})}})(n,T,k)),[n,T,k]),C=t.useCallback((function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return o.getSectionsFromValue(n,e,t,(e=>AS({utils:n,timezone:k,localeText:r,localizedDigits:T,format:m,date:e,formatDensity:g,shouldRespectLeadingZeros:v,enableAccessibleFieldDOMStructure:w,isRtl:s})))}),[o,m,r,T,s,v,n,g,k,w]),[A,E]=t.useState((()=>{const e=C(S);jv();const t={sections:e,value:S,referenceValue:i.emptyValue,tempValueStrAndroid:null},r=(e=>Math.max(...e.map((e=>Cv[e.type]??1))))(e),a=i.getInitialReferenceValue({referenceDate:p,value:S,utils:n,props:c,granularity:r,timezone:k});return(0,oo.A)({},t,{referenceValue:a})})),[_,$]=Rk({controlled:y,default:null,name:"useField",state:"selectedSections"}),R=e=>{$(e),b?.(e)},D=t.useMemo((()=>qv(_,A.sections)),[_,A.sections]),M="all"===D?0:D,F=e=>{let{value:t,referenceValue:r,sections:s}=e;if(E((e=>(0,oo.A)({},e,{sections:s,value:t,referenceValue:r,tempValueStrAndroid:null}))),i.areValuesEqual(n,A.value,t))return;const o={validationError:u({adapter:a,value:t,props:(0,oo.A)({},c,{value:t,timezone:k})})};I(t,o)},O=(e,t)=>{const n=[...A.sections];return n[e]=(0,oo.A)({},n[e],{value:t,modified:!0}),n};return t.useEffect((()=>{const e=C(A.value);jv(),E((t=>(0,oo.A)({},t,{sections:e})))}),[m,n.locale,s]),t.useEffect((()=>{let e;e=!i.areValuesEqual(n,A.value,S)||i.getTimezone(n,A.value)!==i.getTimezone(n,S),e&&E((e=>(0,oo.A)({},e,{value:S,referenceValue:o.updateReferenceValue(n,S,e.referenceValue),sections:C(S)})))}),[S]),{state:A,activeSectionIndex:M,parsedSelectedSections:D,setSelectedSections:R,clearValue:()=>{F({value:i.emptyValue,referenceValue:A.referenceValue,sections:C(i.emptyValue)})},clearActiveSection:()=>{if(null==M)return;const e=A.sections[M],t=o.getActiveDateManager(n,A,e),r=t.getSections(A.sections).filter((e=>""!==e.value)).length===(""===e.value?0:1),a=O(M,""),s=r?null:n.getInvalidDate(),i=t.getNewValuesFromNewActiveDate(s);F((0,oo.A)({},i,{sections:a}))},updateSectionValue:e=>{let{activeSection:t,newSectionValue:r,shouldGoToNextSection:a}=e;a&&M<A.sections.length-1&&R(M+1);const s=o.getActiveDateManager(n,A,t),i=O(M,r),l=s.getSections(i),u=((e,t,n)=>{const r=t.some((e=>"day"===e.type)),a=[],s=[];for(let l=0;l<t.length;l+=1){const e=t[l];r&&"weekDay"===e.type||(a.push(e.format),s.push(Bv(e,"non-input",n)))}const i=a.join(" "),o=s.join(" ");return e.parse(o,i)})(n,l,T);let c,d;if(null!=u&&n.isValid(u)){const e=Hv(n,k,u,l,s.referenceDate,!0);c=s.getNewValuesFromNewActiveDate(e),d=!0}else c=s.getNewValuesFromNewActiveDate(u),d=(null!=u&&!n.isValid(u))!==(null!=s.date&&!n.isValid(s.date));return d?F((0,oo.A)({},c,{sections:i})):E((e=>(0,oo.A)({},e,c,{sections:i,tempValueStrAndroid:null})))},updateValueFromValueStr:e=>{const t=o.parseValueStr(e,A.referenceValue,((e,t)=>{const a=n.parse(e,m);if(null==a||!n.isValid(a))return null;const i=AS({utils:n,timezone:k,localeText:r,localizedDigits:T,format:m,date:a,formatDensity:g,shouldRespectLeadingZeros:v,enableAccessibleFieldDOMStructure:w,isRtl:s});return Hv(n,k,a,i,t,!1)})),a=o.updateReferenceValue(n,t,A.referenceValue);F({value:t,referenceValue:a,sections:C(t,A.sections)})},setTempAndroidValueStr:e=>E((t=>(0,oo.A)({},t,{tempValueStrAndroid:e}))),getSectionsFromValue:C,sectionsValueBoundaries:N,localizedDigits:T,timezone:k}},_S=e=>null!=e.saveQuery,$S=e=>{let{sections:n,updateSectionValue:r,sectionsValueBoundaries:a,localizedDigits:s,setTempAndroidValueStr:i,timezone:o}=e;const l=rx(),[u,c]=t.useState(null),d=gk((()=>c(null)));t.useEffect((()=>{null!=u&&n[u.sectionIndex]?.type!==u.sectionType&&d()}),[n,u,d]),t.useEffect((()=>{if(null!=u){const e=setTimeout((()=>d()),5e3);return()=>{clearTimeout(e)}}return()=>{}}),[u,d]);const h=(e,t,r)=>{let{keyPressed:a,sectionIndex:s}=e;const i=a.toLowerCase(),o=n[s];if(null!=u&&(!r||r(u.value))&&u.sectionIndex===s){const e=`${u.value}${i}`,n=t(e,o);if(!_S(n))return c({sectionIndex:s,value:e,sectionType:o.type}),n}const l=t(i,o);return _S(l)&&!l.saveQuery?(d(),null):(c({sectionIndex:s,value:i,sectionType:o.type}),_S(l)?null:l)};return{applyCharacterEditing:gk((e=>{const t=n[e.sectionIndex],u=Ov(e.keyPressed,s)?(e=>{const t=(e,t)=>{const n=Mv(e,s),r=Number(n),i=a[t.type]({currentDate:null,format:t.format,contentType:t.contentType});if(r>i.maximum)return{saveQuery:!1};if(r<i.minimum)return{saveQuery:!0};const o=10*r>i.maximum||n.length===i.maximum.toString().length;return{sectionValue:Lv(l,r,i,s,t),shouldGoToNextSection:o}};return h(e,((e,n)=>{if("digit"===n.contentType||"digit-with-letter"===n.contentType)return t(e,n);if("month"===n.type){const r=Uv(l,o,"digit","month","MM"),a=t(e,{type:n.type,format:"MM",hasLeadingZerosInFormat:r,hasLeadingZerosInInput:!0,contentType:"digit",maxLength:2});if(_S(a))return a;const s=Vv(l,a.sectionValue,"MM",n.format);return(0,oo.A)({},a,{sectionValue:s})}if("weekDay"===n.type){const r=t(e,n);if(_S(r))return r;const a=$v(l,o,n.format)[Number(r.sectionValue)-1];return(0,oo.A)({},r,{sectionValue:a})}return{saveQuery:!1}}),(e=>Ov(e,s)))})((0,oo.A)({},e,{keyPressed:Fv(e.keyPressed,s)})):(e=>{const t=(e,t,n)=>{const r=t.filter((e=>e.toLowerCase().startsWith(n)));return 0===r.length?{saveQuery:!1}:{sectionValue:r[0],shouldGoToNextSection:1===r.length}},n=(e,n,r,a)=>{const s=e=>Rv(l,o,n.type,e);if("letter"===n.contentType)return t(n.format,s(n.format),e);if(r&&null!=a&&"letter"===_v(l,r).contentType){const n=s(r),i=t(0,n,e);return _S(i)?{saveQuery:!1}:(0,oo.A)({},i,{sectionValue:a(i.sectionValue,n)})}return{saveQuery:!1}};return h(e,((e,t)=>{switch(t.type){case"month":{const r=e=>Vv(l,e,l.formats.month,t.format);return n(e,t,l.formats.month,r)}case"weekDay":{const r=(e,t)=>t.indexOf(e).toString();return n(e,t,l.formats.weekday,r)}case"meridiem":return n(e,t);default:return{saveQuery:!1}}}))})(e);null!=u?r({activeSection:t,newSectionValue:u.sectionValue,shouldGoToNextSection:u.shouldGoToNextSection}):i(null)})),resetCharacterQuery:d}},RS=e=>{const{internalProps:{disabled:n,readOnly:r=!1},forwardedProps:{sectionListRef:a,onBlur:s,onClick:i,onFocus:o,onInput:l,onPaste:u,focused:c,autoFocus:d=!1},fieldValueManager:h,applyCharacterEditing:p,resetCharacterQuery:f,setSelectedSections:m,parsedSelectedSections:g,state:y,clearActiveSection:b,clearValue:v,updateSectionValue:x,updateValueFromValueStr:w,sectionOrder:k,areAllSectionsEmpty:S,sectionsValueBoundaries:I}=e,T=t.useRef(null),N=Nx(a,T),C=bx(),A=rx(),E=Wx(),[_,$]=t.useState(!1),R=t.useMemo((()=>({syncSelectionToDOM:()=>{if(!T.current)return;const e=document.getSelection();if(!e)return;if(null==g)return e.rangeCount>0&&T.current.getRoot().contains(e.getRangeAt(0).startContainer)&&e.removeAllRanges(),void(_&&T.current.getRoot().blur());if(!T.current.getRoot().contains(vk(document)))return;const t=new window.Range;let n;if("all"===g)n=T.current.getRoot();else{n="empty"===y.sections[g].type?T.current.getSectionContainer(g):T.current.getSectionContent(g)}t.selectNodeContents(n),n.focus(),e.removeAllRanges(),e.addRange(t)},getActiveSectionIndexFromDOM:()=>{const e=vk(document);return e&&T.current&&T.current.getRoot().contains(e)?T.current.getSectionIndexFromDOMElement(e):null},focusField:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(!T.current)return;const t=qv(e,y.sections);$(!0),T.current.getSectionContent(t).focus()},setSelectedSections:e=>{if(!T.current)return;const t=qv(e,y.sections);$(null!==("all"===t?0:t)),m(e)},isFieldFocused:()=>{const e=vk(document);return!!T.current&&T.current.getRoot().contains(e)}})),[g,m,y.sections,_]),D=gk((e=>{if(!T.current)return;const t=y.sections[e];T.current.getSectionContent(e).innerHTML=t.value||t.placeholder,R.syncSelectionToDOM()})),M=gk((function(e){if(!e.isDefaultPrevented()&&T.current){$(!0);for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];if(i?.(e,...n),"all"===g)setTimeout((()=>{const e=document.getSelection().getRangeAt(0).startOffset;if(0===e)return void m(k.startIndex);let t=0,n=0;for(;n<e&&t<y.sections.length;){const e=y.sections[t];t+=1,n+=`${e.startSeparator}${e.value||e.placeholder}${e.endSeparator}`.length}m(t-1)}));else if(_){T.current.getRoot().contains(e.target)||m(k.startIndex)}else $(!0),m(k.startIndex)}})),F=gk((e=>{if(l?.(e),!T.current||"all"!==g)return;const t=e.target.textContent??"";T.current.getRoot().innerHTML=y.sections.map((e=>`${e.startSeparator}${e.value||e.placeholder}${e.endSeparator}`)).join(""),R.syncSelectionToDOM(),0===t.length||10===t.charCodeAt(0)?(f(),v(),m("all")):t.length>1?w(t):p({keyPressed:t,sectionIndex:0})})),O=gk((e=>{if(u?.(e),r||"all"!==g)return void e.preventDefault();const t=e.clipboardData.getData("text");e.preventDefault(),f(),w(t)})),P=gk((function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(o?.(...t),_||!T.current)return;$(!0);null!=T.current.getSectionIndexFromDOMElement(vk(document))||m(k.startIndex)})),L=gk((function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];s?.(...t),setTimeout((()=>{if(!T.current)return;const e=vk(document);!T.current.getRoot().contains(e)&&($(!1),m(null))}))})),z=gk((e=>t=>{t.isDefaultPrevented()||m(e)})),B=gk((e=>{e.preventDefault()})),V=gk((e=>()=>{m(e)})),W=gk((e=>{if(e.preventDefault(),r||n||"number"!==typeof g)return;const t=y.sections[g],a=e.clipboardData.getData("text"),s=/^[a-zA-Z]+$/.test(a),i=/^[0-9]+$/.test(a),o=/^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(a);"letter"===t.contentType&&s||"digit"===t.contentType&&i||"digit-with-letter"===t.contentType&&o?(f(),x({activeSection:t,newSectionValue:a,shouldGoToNextSection:!0})):s||i||(f(),w(a))})),U=gk((e=>{e.preventDefault(),e.dataTransfer.dropEffect="none"})),j=gk((e=>{if(!T.current)return;const t=e.target,n=t.textContent??"",a=T.current.getSectionIndexFromDOMElement(t),s=y.sections[a];if(!r&&T.current){if(0===n.length){if(""===s.value)return void D(a);const t=e.nativeEvent.inputType;return"insertParagraph"===t||"insertLineBreak"===t?void D(a):(f(),void b())}p({keyPressed:n,sectionIndex:a}),D(a)}else D(a)}));mk((()=>{if(_&&T.current)if("all"===g)T.current.getRoot().focus();else if("number"===typeof g){const e=T.current.getSectionContent(g);e&&e.focus()}}),[g,_]);const G=t.useMemo((()=>y.sections.reduce(((e,t)=>(e[t.type]=I[t.type]({currentDate:null,contentType:t.contentType,format:t.format}),e)),{})),[I,y.sections]),H="all"===g,q=t.useMemo((()=>y.sections.map(((e,a)=>{const s=!H&&!n&&!r;return{container:{"data-sectionindex":a,onClick:z(a)},content:{tabIndex:H||a>0?-1:0,contentEditable:!H&&!n&&!r,role:"spinbutton",id:`${E}-${e.type}`,"aria-labelledby":`${E}-${e.type}`,"aria-readonly":r,"aria-valuenow":Yv(e,A),"aria-valuemin":G[e.type].minimum,"aria-valuemax":G[e.type].maximum,"aria-valuetext":e.value?Kv(e,A):C.empty,"aria-label":C[e.type],"aria-disabled":n,spellCheck:!s&&void 0,autoCapitalize:s?"off":void 0,autoCorrect:s?"off":void 0,[parseInt(t.version,10)>=17?"enterKeyHint":"enterkeyhint"]:s?"next":void 0,children:e.value||e.placeholder,onInput:j,onPaste:W,onFocus:V(a),onDragOver:U,onMouseUp:B,inputMode:"letter"===e.contentType?"text":"numeric"},before:{children:e.startSeparator},after:{children:e.endSeparator}}}))),[y.sections,V,W,U,j,z,B,n,r,H,C,A,G,E]),K=gk((e=>{w(e.target.value)})),Y=t.useMemo((()=>S?"":h.getV7HiddenInputValueFromSections(y.sections)),[S,y.sections,h]);return t.useEffect((()=>{if(null==T.current)throw new Error(["MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`","You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.","","If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:","","<DatePicker slots={{ textField: MyCustomTextField }} />","","Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element"].join("\n"));d&&T.current&&T.current.getSectionContent(k.startIndex).focus()}),[]),{interactions:R,returnedValue:{autoFocus:d,readOnly:r,focused:c??_,sectionListRef:N,onBlur:L,onClick:M,onFocus:P,onInput:F,onPaste:O,enableAccessibleFieldDOMStructure:!0,elements:q,tabIndex:0===g?-1:0,contentEditable:H,value:Y,onChange:K,areAllSectionsEmpty:S}}},DS=e=>e.replace(/[\u2066\u2067\u2068\u2069]/g,""),MS=e=>{const n=Fa(),r=t.useRef(),a=t.useRef(),{forwardedProps:{onFocus:s,onClick:i,onPaste:o,onBlur:l,inputRef:u,placeholder:c},internalProps:{readOnly:d=!1,disabled:h=!1},parsedSelectedSections:p,activeSectionIndex:f,state:m,fieldValueManager:g,valueManager:y,applyCharacterEditing:b,resetCharacterQuery:v,updateSectionValue:x,updateValueFromValueStr:w,clearActiveSection:k,clearValue:S,setTempAndroidValueStr:I,setSelectedSections:T,getSectionsFromValue:N,areAllSectionsEmpty:C,localizedDigits:A}=e,E=t.useRef(null),_=Nx(u,E),$=t.useMemo((()=>((e,t,n)=>{let r=0,a=n?1:0;const s=[];for(let i=0;i<e.length;i+=1){const o=e[i],l=Bv(o,n?"input-rtl":"input-ltr",t),u=`${o.startSeparator}${l}${o.endSeparator}`,c=DS(u).length,d=u.length,h=DS(l),p=a+(""===h?0:l.indexOf(h[0]))+o.startSeparator.length,f=p+h.length;s.push((0,oo.A)({},o,{start:r,end:r+c,startInInput:p,endInInput:f})),r+=c,a+=d}return s})(m.sections,A,n)),[m.sections,A,n]),R=t.useMemo((()=>({syncSelectionToDOM:()=>{if(!E.current)return;if(null==p)return void(E.current.scrollLeft&&(E.current.scrollLeft=0));if(E.current!==vk(document))return;const e=E.current.scrollTop;if("all"===p)E.current.select();else{const e=$[p],t="empty"===e.type?e.startInInput-e.startSeparator.length:e.startInInput,n="empty"===e.type?e.endInInput+e.endSeparator.length:e.endInInput;t===E.current.selectionStart&&n===E.current.selectionEnd||E.current===vk(document)&&E.current.setSelectionRange(t,n),clearTimeout(a.current),a.current=setTimeout((()=>{!E.current||E.current!==vk(document)||E.current.selectionStart!==E.current.selectionEnd||E.current.selectionStart===t&&E.current.selectionEnd===n||R.syncSelectionToDOM()}))}E.current.scrollTop=e},getActiveSectionIndexFromDOM:()=>{const e=E.current.selectionStart??0,t=E.current.selectionEnd??0;if(0===e&&0===t)return null;const n=e<=$[0].startInInput?1:$.findIndex((t=>t.startInInput-t.startSeparator.length>e));return-1===n?$.length-1:n-1},focusField:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;E.current?.focus(),T(e)},setSelectedSections:e=>T(e),isFieldFocused:()=>E.current===vk(document)})),[E,p,$,T]),D=()=>{const e=E.current.selectionStart??0;let t;t=e<=$[0].startInInput||e>=$[$.length-1].endInInput?1:$.findIndex((t=>t.startInInput-t.startSeparator.length>e));const n=-1===t?$.length-1:t-1;T(n)},M=gk((function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];s?.(...t);const a=E.current;clearTimeout(r.current),r.current=setTimeout((()=>{a&&a===E.current&&null==f&&(a.value.length&&Number(a.selectionEnd)-Number(a.selectionStart)===a.value.length?T("all"):D())}))})),F=gk((function(e){if(!e.isDefaultPrevented()){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];i?.(e,...n),D()}})),O=gk((e=>{if(o?.(e),e.preventDefault(),d||h)return;const t=e.clipboardData.getData("text");if("number"===typeof p){const e=m.sections[p],n=/^[a-zA-Z]+$/.test(t),r=/^[0-9]+$/.test(t),a=/^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(t);if("letter"===e.contentType&&n||"digit"===e.contentType&&r||"digit-with-letter"===e.contentType&&a)return v(),void x({activeSection:e,newSectionValue:t,shouldGoToNextSection:!0});if(n||r)return}v(),w(t)})),P=gk((function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];l?.(...t),T(null)})),L=gk((e=>{if(d)return;const t=e.target.value;if(""===t)return v(),void S();const r=e.nativeEvent.data,a=r&&r.length>1,s=a?r:t,i=DS(s);if(null==f||a)return void w(a?r:i);let o;if("all"===p&&1===i.length)o=i;else{const e=DS(g.getV6InputValueFromSections($,A,n));let t=-1,r=-1;for(let n=0;n<e.length;n+=1)-1===t&&e[n]!==i[n]&&(t=n),-1===r&&e[e.length-n-1]!==i[i.length-n-1]&&(r=n);const a=$[f];if(t<a.start||e.length-r-1>a.end)return;const s=i.length-e.length+a.end-DS(a.endSeparator||"").length;o=i.slice(a.start+DS(a.startSeparator||"").length,s)}if(0===o.length)return navigator.userAgent.toLowerCase().includes("android")&&I(s),v(),void k();b({keyPressed:o,sectionIndex:f})})),z=t.useMemo((()=>void 0!==c?c:g.getV6InputValueFromSections(N(y.emptyValue),A,n)),[c,g,N,y.emptyValue,A,n]),B=t.useMemo((()=>m.tempValueStrAndroid??g.getV6InputValueFromSections(m.sections,A,n)),[m.sections,g,m.tempValueStrAndroid,A,n]);t.useEffect((()=>(E.current&&E.current===vk(document)&&T("all"),()=>{clearTimeout(r.current),clearTimeout(a.current)})),[]);const V=t.useMemo((()=>null==f||"letter"===m.sections[f].contentType?"text":"numeric"),[f,m.sections]),W=E.current&&E.current===vk(document);return{interactions:R,returnedValue:{readOnly:d,onBlur:P,onClick:F,onFocus:M,onPaste:O,inputRef:_,enableAccessibleFieldDOMStructure:!1,placeholder:z,inputMode:V,autoComplete:"off",value:!W&&C?"":B,onChange:L}}},FS=["disablePast","disableFuture","minDate","maxDate","shouldDisableDate","shouldDisableMonth","shouldDisableYear"],OS=["disablePast","disableFuture","minTime","maxTime","shouldDisableTime","minutesStep","ampm","disableIgnoringDatePartForTimeValidation"],PS=["minDateTime","maxDateTime"],LS=[...FS,...OS,...PS],zS=e=>LS.reduce(((t,n)=>(e.hasOwnProperty(n)&&(t[n]=e[n]),t)),{}),BS=["value","defaultValue","referenceDate","format","formatDensity","onChange","timezone","onError","shouldRespectLeadingZeros","selectedSections","onSelectedSectionsChange","unstableFieldRef","enableAccessibleFieldDOMStructure","disabled","readOnly","dateSeparator"],VS=e=>{const n=(e=>{const t=rx(),n=ax();return(0,oo.A)({},e,{disablePast:e.disablePast??!1,disableFuture:e.disableFuture??!1,format:e.format??t.formats.keyboardDate,minDate:bv(t,e.minDate,n.minDate),maxDate:bv(t,e.maxDate,n.maxDate)})})(e),{forwardedProps:r,internalProps:a}=((e,t)=>{const n=(0,oo.A)({},e),r={},a=e=>{n.hasOwnProperty(e)&&(r[e]=n[e],delete n[e])};return BS.forEach(a),"date"===t?FS.forEach(a):"time"===t?OS.forEach(a):"date-time"===t&&(FS.forEach(a),OS.forEach(a),PS.forEach(a)),{forwardedProps:n,internalProps:r}})(n,"date");return(e=>{const n=rx(),{internalProps:r,internalProps:{unstableFieldRef:a,minutesStep:s,enableAccessibleFieldDOMStructure:i=!1,disabled:o=!1,readOnly:l=!1},forwardedProps:{onKeyDown:u,error:c,clearable:d,onClear:h},fieldValueManager:p,valueManager:f,validator:m}=e,g=Fa(),y=ES(e),{state:b,activeSectionIndex:v,parsedSelectedSections:x,setSelectedSections:w,clearValue:k,clearActiveSection:S,updateSectionValue:I,setTempAndroidValueStr:T,sectionsValueBoundaries:N,localizedDigits:C,timezone:A}=y,E=$S({sections:b.sections,updateSectionValue:I,sectionsValueBoundaries:N,localizedDigits:C,setTempAndroidValueStr:T,timezone:A}),{resetCharacterQuery:_}=E,$=f.areValuesEqual(n,b.value,f.emptyValue),R=i?RS:MS,D=t.useMemo((()=>((e,t)=>{const n={};if(!t)return e.forEach(((t,r)=>{const a=0===r?null:r-1,s=r===e.length-1?null:r+1;n[r]={leftIndex:a,rightIndex:s}})),{neighbors:n,startIndex:0,endIndex:e.length-1};const r={},a={};let s=0,i=0,o=e.length-1;for(;o>=0;){i=e.findIndex(((e,t)=>t>=s&&e.endSeparator?.includes(" ")&&" / "!==e.endSeparator)),-1===i&&(i=e.length-1);for(let e=i;e>=s;e-=1)a[e]=o,r[o]=e,o-=1;s=i+1}return e.forEach(((t,s)=>{const i=a[s],o=0===i?null:r[i-1],l=i===e.length-1?null:r[i+1];n[s]={leftIndex:o,rightIndex:l}})),{neighbors:n,startIndex:r[0],endIndex:r[e.length-1]}})(b.sections,g&&!i)),[b.sections,g,i]),{returnedValue:M,interactions:F}=R((0,oo.A)({},e,y,E,{areAllSectionsEmpty:$,sectionOrder:D})),O=gk((e=>{if(u?.(e),!o)switch(!0){case(e.ctrlKey||e.metaKey)&&"a"===e.key.toLowerCase()&&!e.shiftKey&&!e.altKey:e.preventDefault(),w("all");break;case"ArrowRight"===e.key:if(e.preventDefault(),null==x)w(D.startIndex);else if("all"===x)w(D.endIndex);else{const e=D.neighbors[x].rightIndex;null!==e&&w(e)}break;case"ArrowLeft"===e.key:if(e.preventDefault(),null==x)w(D.endIndex);else if("all"===x)w(D.startIndex);else{const e=D.neighbors[x].leftIndex;null!==e&&w(e)}break;case"Delete"===e.key:if(e.preventDefault(),l)break;null==x||"all"===x?k():S(),_();break;case["ArrowUp","ArrowDown","Home","End","PageUp","PageDown"].includes(e.key):{if(e.preventDefault(),l||null==v)break;const t=b.sections[v],r=p.getActiveDateManager(n,b,t),a=zv(n,A,t,e.key,N,C,r.date,{minutesStep:s});I({activeSection:t,newSectionValue:a,shouldGoToNextSection:!1});break}}}));mk((()=>{F.syncSelectionToDOM()}));const P=$k((0,oo.A)({},r,{value:b.value,timezone:A}),m,f.isSameError,f.defaultErrorState),L=t.useMemo((()=>void 0!==c?c:f.hasError(P)),[f,P,c]);t.useEffect((()=>{L||null!=v||_()}),[b.referenceValue,v,L]),t.useEffect((()=>{null!=b.tempValueStrAndroid&&null!=v&&(_(),S())}),[b.sections]),t.useImperativeHandle(a,(()=>({getSections:()=>b.sections,getActiveSectionIndex:F.getActiveSectionIndexFromDOM,setSelectedSections:F.setSelectedSections,focusField:F.focusField,isFieldFocused:F.isFieldFocused})));const z={onKeyDown:O,onClear:gk((function(e){e.preventDefault();for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];h?.(e,...n),k(),F.isFieldFocused()?w(D.startIndex):F.focusField(0)})),error:L,clearable:Boolean(d&&!$&&!l&&!o)},B={disabled:o,readOnly:l};return(0,oo.A)({},e.forwardedProps,z,B,M)})({forwardedProps:r,internalProps:a,valueManager:Qv,fieldValueManager:Zv,validator:Tx,valueType:"date"})},WS=["clearable","onClear","InputProps","sx","slots","slotProps"],US=["ownerState"];function jS(e){return dx("MuiPickersTextField",e)}hx("MuiPickersTextField",["root","focused","disabled","error","required"]);function GS(e){return dx("MuiPickersInputBase",e)}const HS=hx("MuiPickersInputBase",["root","focused","disabled","error","notchedOutline","sectionContent","sectionBefore","sectionAfter","adornedStart","adornedEnd","input"]);function qS(e){return dx("MuiPickersOutlinedInput",e)}const KS=(0,oo.A)({},HS,hx("MuiPickersOutlinedInput",["root","notchedOutline","input"])),YS=["children","className","label","notched","shrink"],XS=(0,Wn.Ay)("fieldset",{name:"MuiPickersOutlinedInput",slot:"NotchedOutline",overridesResolver:(e,t)=>t.notchedOutline})((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{textAlign:"left",position:"absolute",bottom:0,right:0,top:-5,left:0,margin:0,padding:"0 8px",pointerEvents:"none",borderRadius:"inherit",borderStyle:"solid",borderWidth:1,overflow:"hidden",minWidth:"0%",borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}})),QS=(0,Wn.Ay)("span")((e=>{let{theme:t}=e;return{fontFamily:t.typography.fontFamily,fontSize:"inherit"}})),ZS=(0,Wn.Ay)("legend")((e=>{let{theme:t}=e;return{float:"unset",width:"auto",overflow:"hidden",variants:[{props:{withLabel:!1},style:{padding:0,lineHeight:"11px",transition:t.transitions.create("width",{duration:150,easing:t.transitions.easing.easeOut})}},{props:{withLabel:!0},style:{display:"block",padding:0,height:11,fontSize:"0.75em",visibility:"hidden",maxWidth:.01,transition:t.transitions.create("max-width",{duration:50,easing:t.transitions.easing.easeOut}),whiteSpace:"nowrap","& > span":{paddingLeft:5,paddingRight:5,display:"inline-block",opacity:0,visibility:"visible"}}},{props:{withLabel:!0,notched:!0},style:{maxWidth:"100%",transition:t.transitions.create("max-width",{duration:100,easing:t.transitions.easing.easeOut,delay:50})}}]}}));function JS(e){const{className:t,label:n}=e,r=us(e,YS),a=null!=n&&""!==n,s=(0,oo.A)({},e,{withLabel:a});return(0,$n.jsx)(XS,(0,oo.A)({"aria-hidden":!0,className:t},r,{ownerState:s,children:(0,$n.jsx)(ZS,{ownerState:s,children:a?(0,$n.jsx)(QS,{children:n}):(0,$n.jsx)(QS,{className:"notranslate",children:"\u200b"})})}))}function eI(e){if("string"!==typeof e)throw new Error(function(e){let t="https://mui.com/production-error/?code="+e;for(let n=1;n<arguments.length;n+=1)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified MUI error #"+e+"; visit "+t+" for the full message."}(7));return e.charAt(0).toUpperCase()+e.slice(1)}const tI={border:0,clip:"rect(0 0 0 0)",height:"1px",margin:"-1px",overflow:"hidden",padding:0,position:"absolute",whiteSpace:"nowrap",width:"1px"};function nI(e){return dx("MuiPickersSectionList",e)}const rI=hx("MuiPickersSectionList",["root","section","sectionContent"]),aI=["slots","slotProps","elements","sectionListRef"],sI=(0,Wn.Ay)("div",{name:"MuiPickersSectionList",slot:"Root",overridesResolver:(e,t)=>t.root})({direction:"ltr /*! @noflip */",outline:"none"}),iI=(0,Wn.Ay)("span",{name:"MuiPickersSectionList",slot:"Section",overridesResolver:(e,t)=>t.section})({}),oI=(0,Wn.Ay)("span",{name:"MuiPickersSectionList",slot:"SectionSeparator",overridesResolver:(e,t)=>t.sectionSeparator})({whiteSpace:"pre"}),lI=(0,Wn.Ay)("span",{name:"MuiPickersSectionList",slot:"SectionContent",overridesResolver:(e,t)=>t.sectionContent})({outline:"none"});function uI(e){const{slots:t,slotProps:n,element:r,classes:a}=e,s=t?.section??iI,i=Dx({elementType:s,externalSlotProps:n?.section,externalForwardedProps:r.container,className:a.section,ownerState:{}}),o=t?.sectionContent??lI,l=Dx({elementType:o,externalSlotProps:n?.sectionContent,externalForwardedProps:r.content,additionalProps:{suppressContentEditableWarning:!0},className:a.sectionContent,ownerState:{}}),u=t?.sectionSeparator??oI,c=Dx({elementType:u,externalSlotProps:n?.sectionSeparator,externalForwardedProps:r.before,ownerState:{position:"before"}}),d=Dx({elementType:u,externalSlotProps:n?.sectionSeparator,externalForwardedProps:r.after,ownerState:{position:"after"}});return(0,$n.jsxs)(s,(0,oo.A)({},i,{children:[(0,$n.jsx)(u,(0,oo.A)({},c)),(0,$n.jsx)(o,(0,oo.A)({},l)),(0,$n.jsx)(u,(0,oo.A)({},d))]}))}const cI=t.forwardRef((function(e,n){const r=Hi({props:e,name:"MuiPickersSectionList"}),{slots:a,slotProps:s,elements:i,sectionListRef:o}=r,l=us(r,aI),u=(e=>{const{classes:t}=e;return ix({root:["root"],section:["section"],sectionContent:["sectionContent"]},nI,t)})(r),c=t.useRef(null),d=Nx(n,c),h=e=>{if(!c.current)throw new Error(`MUI X: Cannot call sectionListRef.${e} before the mount of the component.`);return c.current};t.useImperativeHandle(o,(()=>({getRoot:()=>h("getRoot"),getSectionContainer:e=>h("getSectionContainer").querySelector(`.${rI.section}[data-sectionindex="${e}"]`),getSectionContent:e=>h("getSectionContent").querySelector(`.${rI.section}[data-sectionindex="${e}"] .${rI.sectionContent}`),getSectionIndexFromDOMElement(e){const t=h("getSectionIndexFromDOMElement");if(null==e||!t.contains(e))return null;let n=null;return e.classList.contains(rI.section)?n=e:e.classList.contains(rI.sectionContent)&&(n=e.parentElement),null==n?null:Number(n.dataset.sectionindex)}})));const p=a?.root??sI,f=Dx({elementType:p,externalSlotProps:s?.root,externalForwardedProps:l,additionalProps:{ref:d,suppressContentEditableWarning:!0},className:u.root,ownerState:{}});return(0,$n.jsx)(p,(0,oo.A)({},f,{children:f.contentEditable?i.map((e=>{let{content:t,before:n,after:r}=e;return`${n.children}${t.children}${r.children}`})).join(""):(0,$n.jsx)(t.Fragment,{children:i.map(((e,t)=>(0,$n.jsx)(uI,{slots:a,slotProps:s,element:e,classes:u},t)))})}))})),dI=["elements","areAllSectionsEmpty","defaultValue","label","value","onChange","id","autoFocus","endAdornment","startAdornment","renderSuffix","slots","slotProps","contentEditable","tabIndex","onInput","onPaste","onKeyDown","fullWidth","name","readOnly","inputProps","inputRef","sectionListRef"],hI=(0,Wn.Ay)("div",{name:"MuiPickersInputBase",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;return(0,oo.A)({},t.typography.body1,{color:(t.vars||t).palette.text.primary,cursor:"text",padding:0,display:"flex",justifyContent:"flex-start",alignItems:"center",position:"relative",boxSizing:"border-box",letterSpacing:(n=.15/16,Math.round(1e5*n)/1e5)+"em",variants:[{props:{fullWidth:!0},style:{width:"100%"}}]});var n})),pI=(0,Wn.Ay)(sI,{name:"MuiPickersInputBase",slot:"SectionsContainer",overridesResolver:(e,t)=>t.sectionsContainer})((e=>{let{theme:t}=e;return{padding:"4px 0 5px",fontFamily:t.typography.fontFamily,fontSize:"inherit",lineHeight:"1.4375em",flexGrow:1,outline:"none",display:"flex",flexWrap:"nowrap",overflow:"hidden",letterSpacing:"inherit",width:"182px",variants:[{props:{isRtl:!0},style:{textAlign:"right /*! @noflip */"}},{props:{size:"small"},style:{paddingTop:1}},{props:{adornedStart:!1,focused:!1,filled:!1},style:{color:"currentColor",opacity:0}},{props:e=>{let{adornedStart:t,focused:n,filled:r,label:a}=e;return!t&&!n&&!r&&null==a},style:t.vars?{opacity:t.vars.opacity.inputPlaceholder}:{opacity:"light"===t.palette.mode?.42:.5}}]}})),fI=(0,Wn.Ay)(iI,{name:"MuiPickersInputBase",slot:"Section",overridesResolver:(e,t)=>t.section})((e=>{let{theme:t}=e;return{fontFamily:t.typography.fontFamily,fontSize:"inherit",letterSpacing:"inherit",lineHeight:"1.4375em",display:"flex"}})),mI=(0,Wn.Ay)(lI,{name:"MuiPickersInputBase",slot:"SectionContent",overridesResolver:(e,t)=>t.content})((e=>{let{theme:t}=e;return{fontFamily:t.typography.fontFamily,lineHeight:"1.4375em",letterSpacing:"inherit",width:"fit-content",outline:"none"}})),gI=(0,Wn.Ay)(oI,{name:"MuiPickersInputBase",slot:"Separator",overridesResolver:(e,t)=>t.separator})((()=>({whiteSpace:"pre",letterSpacing:"inherit"}))),yI=(0,Wn.Ay)("input",{name:"MuiPickersInputBase",slot:"Input",overridesResolver:(e,t)=>t.hiddenInput})((0,oo.A)({},tI)),bI=t.forwardRef((function(e,n){const r=Hi({props:e,name:"MuiPickersInputBase"}),{elements:a,areAllSectionsEmpty:s,value:i,onChange:o,id:l,endAdornment:u,startAdornment:c,renderSuffix:d,slots:h,slotProps:p,contentEditable:f,tabIndex:m,onInput:g,onPaste:y,onKeyDown:b,name:v,readOnly:x,inputProps:w,inputRef:k,sectionListRef:S}=r,I=us(r,dI),T=Nx(n,t.useRef(null)),N=Nx(w?.ref,k),C=Fa(),A=Er();if(!A)throw new Error("MUI X: PickersInputBase should always be used inside a PickersTextField component");t.useEffect((()=>{A&&A.setAdornedStart(Boolean(c))}),[A,c]),t.useEffect((()=>{A&&(s?A.onEmpty():A.onFilled())}),[A,s]);const E=(0,oo.A)({},r,A,{isRtl:C}),_=(e=>{const{focused:t,disabled:n,error:r,classes:a,fullWidth:s,readOnly:i,color:o,size:l,endAdornment:u,startAdornment:c}=e;return ix({root:["root",t&&!n&&"focused",n&&"disabled",i&&"readOnly",r&&"error",s&&"fullWidth",`color${eI(o)}`,"small"===l&&"inputSizeSmall",Boolean(c)&&"adornedStart",Boolean(u)&&"adornedEnd"],notchedOutline:["notchedOutline"],input:["input"],sectionsContainer:["sectionsContainer"],sectionContent:["sectionContent"],sectionBefore:["sectionBefore"],sectionAfter:["sectionAfter"]},GS,a)})(E),$=h?.root||hI,R=Dx({elementType:$,externalSlotProps:p?.root,externalForwardedProps:I,additionalProps:{"aria-invalid":A.error,ref:T},className:_.root,ownerState:E}),D=h?.input||pI;return(0,$n.jsxs)($,(0,oo.A)({},R,{children:[c,(0,$n.jsx)(cI,{sectionListRef:S,elements:a,contentEditable:f,tabIndex:m,className:_.sectionsContainer,onFocus:e=>{A.disabled?e.stopPropagation():A.onFocus?.(e)},onBlur:A.onBlur,onInput:g,onPaste:y,onKeyDown:b,slots:{root:D,section:fI,sectionContent:mI,sectionSeparator:gI},slotProps:{root:{ownerState:E},sectionContent:{className:HS.sectionContent},sectionSeparator:e=>{let{position:t}=e;return{className:"before"===t?HS.sectionBefore:HS.sectionAfter}}}}),u,d?d((0,oo.A)({},A)):null,(0,$n.jsx)(yI,(0,oo.A)({name:v,className:_.input,value:i,onChange:o,id:l,"aria-hidden":"true",tabIndex:-1,readOnly:x,required:A.required,disabled:A.disabled},w,{ref:N}))]}))})),vI=["label","autoFocus","ownerState","notched"],xI=(0,Wn.Ay)(hI,{name:"MuiPickersOutlinedInput",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;const n="light"===t.palette.mode?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{padding:"0 14px",borderRadius:(t.vars||t).shape.borderRadius,[`&:hover .${KS.notchedOutline}`]:{borderColor:(t.vars||t).palette.text.primary},"@media (hover: none)":{[`&:hover .${KS.notchedOutline}`]:{borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}},[`&.${KS.focused} .${KS.notchedOutline}`]:{borderStyle:"solid",borderWidth:2},[`&.${KS.disabled}`]:{[`& .${KS.notchedOutline}`]:{borderColor:(t.vars||t).palette.action.disabled},"*":{color:(t.vars||t).palette.action.disabled}},[`&.${KS.error} .${KS.notchedOutline}`]:{borderColor:(t.vars||t).palette.error.main},variants:Object.keys((t.vars??t).palette).filter((e=>(t.vars??t).palette[e]?.main??!1)).map((e=>({props:{color:e},style:{[`&.${KS.focused}:not(.${KS.error}) .${KS.notchedOutline}`]:{borderColor:(t.vars||t).palette[e].main}}})))}})),wI=(0,Wn.Ay)(pI,{name:"MuiPickersOutlinedInput",slot:"SectionsContainer",overridesResolver:(e,t)=>t.sectionsContainer})({padding:"16.5px 0",variants:[{props:{size:"small"},style:{padding:"8.5px 0"}}]}),kI=t.forwardRef((function(e,n){const r=Hi({props:e,name:"MuiPickersOutlinedInput"}),{label:a,ownerState:s,notched:i}=r,o=us(r,vI),l=Er(),u=(0,oo.A)({},r,s,l,{color:l?.color||"primary"}),c=(e=>{const{classes:t}=e,n=ix({root:["root"],notchedOutline:["notchedOutline"],input:["input"]},qS,t);return(0,oo.A)({},t,n)})(u);return(0,$n.jsx)(bI,(0,oo.A)({slots:{root:xI,input:wI},renderSuffix:e=>(0,$n.jsx)(JS,{shrink:Boolean(i||e.adornedStart||e.focused||e.filled),notched:Boolean(i||e.adornedStart||e.focused||e.filled),className:c.notchedOutline,label:null!=a&&""!==a&&l?.required?(0,$n.jsxs)(t.Fragment,{children:[a,"\u2009","*"]}):a,ownerState:u})},o,{label:a,classes:c,ref:n}))}));function SI(e){return dx("MuiPickersFilledInput",e)}kI.muiName="Input";const II=(0,oo.A)({},HS,hx("MuiPickersFilledInput",["root","underline","input"])),TI=["label","autoFocus","disableUnderline","ownerState"],NI=(0,Wn.Ay)(hI,{name:"MuiPickersFilledInput",slot:"Root",overridesResolver:(e,t)=>t.root,shouldForwardProp:e=>(0,pl.MC)(e)&&"disableUnderline"!==e})((e=>{let{theme:t}=e;const n="light"===t.palette.mode,r=n?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)",a=n?"rgba(0, 0, 0, 0.06)":"rgba(255, 255, 255, 0.09)",s=n?"rgba(0, 0, 0, 0.09)":"rgba(255, 255, 255, 0.13)",i=n?"rgba(0, 0, 0, 0.12)":"rgba(255, 255, 255, 0.12)";return{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a,borderTopLeftRadius:(t.vars||t).shape.borderRadius,borderTopRightRadius:(t.vars||t).shape.borderRadius,transition:t.transitions.create("background-color",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),"&:hover":{backgroundColor:t.vars?t.vars.palette.FilledInput.hoverBg:s,"@media (hover: none)":{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a}},[`&.${II.focused}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:a},[`&.${II.disabled}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.disabledBg:i},variants:[...Object.keys((t.vars??t).palette).filter((e=>(t.vars??t).palette[e].main)).map((e=>({props:{color:e,disableUnderline:!1},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[e]?.main}`}}}))),{props:{disableUnderline:!1},style:{"&::after":{left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${II.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${II.error}`]:{"&:before, &:after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`:r}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${II.disabled}, .${II.error}):before`]:{borderBottom:`1px solid ${(t.vars||t).palette.text.primary}`},[`&.${II.disabled}:before`]:{borderBottomStyle:"dotted"}}},{props:e=>{let{startAdornment:t}=e;return!!t},style:{paddingLeft:12}},{props:e=>{let{endAdornment:t}=e;return!!t},style:{paddingRight:12}}]}})),CI=(0,Wn.Ay)(pI,{name:"MuiPickersFilledInput",slot:"sectionsContainer",overridesResolver:(e,t)=>t.sectionsContainer})({paddingTop:25,paddingRight:12,paddingBottom:8,paddingLeft:12,variants:[{props:{size:"small"},style:{paddingTop:21,paddingBottom:4}},{props:e=>{let{startAdornment:t}=e;return!!t},style:{paddingLeft:0}},{props:e=>{let{endAdornment:t}=e;return!!t},style:{paddingRight:0}},{props:{hiddenLabel:!0},style:{paddingTop:16,paddingBottom:17}},{props:{hiddenLabel:!0,size:"small"},style:{paddingTop:8,paddingBottom:9}}]}),AI=t.forwardRef((function(e,t){const n=Hi({props:e,name:"MuiPickersFilledInput"}),{label:r,disableUnderline:a=!1,ownerState:s}=n,i=us(n,TI),o=Er(),l=(e=>{const{classes:t,disableUnderline:n}=e,r=ix({root:["root",!n&&"underline"],input:["input"]},SI,t);return(0,oo.A)({},t,r)})((0,oo.A)({},n,s,o,{color:o?.color||"primary"}));return(0,$n.jsx)(bI,(0,oo.A)({slots:{root:NI,input:CI},slotProps:{root:{disableUnderline:a}}},i,{label:r,classes:l,ref:t}))}));function EI(e){return dx("MuiPickersFilledInput",e)}AI.muiName="Input";const _I=(0,oo.A)({},HS,hx("MuiPickersInput",["root","input"])),$I=["label","autoFocus","disableUnderline","ownerState"],RI=(0,Wn.Ay)(hI,{name:"MuiPickersInput",slot:"Root",overridesResolver:(e,t)=>t.root})((e=>{let{theme:t}=e;let n="light"===t.palette.mode?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)";return t.vars&&(n=`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`),{"label + &":{marginTop:16},variants:[...Object.keys((t.vars??t).palette).filter((e=>(t.vars??t).palette[e].main)).map((e=>({props:{color:e},style:{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[e].main}`}}}))),{props:{disableUnderline:!1},style:{"&::after":{background:"red",left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${_I.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${_I.error}`]:{"&:before, &:after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${n}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${_I.disabled}, .${_I.error}):before`]:{borderBottom:`2px solid ${(t.vars||t).palette.text.primary}`,"@media (hover: none)":{borderBottom:`1px solid ${n}`}},[`&.${_I.disabled}:before`]:{borderBottomStyle:"dotted"}}}]}})),DI=t.forwardRef((function(e,t){const n=Hi({props:e,name:"MuiPickersInput"}),{label:r,disableUnderline:a=!1,ownerState:s}=n,i=us(n,$I),o=Er(),l=(e=>{const{classes:t,disableUnderline:n}=e,r=ix({root:["root",!n&&"underline"],input:["input"]},EI,t);return(0,oo.A)({},t,r)})((0,oo.A)({},n,s,o,{disableUnderline:a,color:o?.color||"primary"}));return(0,$n.jsx)(bI,(0,oo.A)({slots:{root:RI}},i,{label:r,classes:l,ref:t}))}));DI.muiName="Input";const MI=["onFocus","onBlur","className","color","disabled","error","variant","required","InputProps","inputProps","inputRef","sectionListRef","elements","areAllSectionsEmpty","onClick","onKeyDown","onKeyUp","onPaste","onInput","endAdornment","startAdornment","tabIndex","contentEditable","focused","value","onChange","fullWidth","id","name","helperText","FormHelperTextProps","label","InputLabelProps"],FI={standard:DI,filled:AI,outlined:kI},OI=(0,Wn.Ay)(Na,{name:"MuiPickersTextField",slot:"Root",overridesResolver:(e,t)=>t.root})({}),PI=t.forwardRef((function(e,n){const r=Hi({props:e,name:"MuiPickersTextField"}),{onFocus:a,onBlur:s,className:i,color:o="primary",disabled:l=!1,error:u=!1,variant:c="outlined",required:d=!1,InputProps:h,inputProps:p,inputRef:f,sectionListRef:m,elements:g,areAllSectionsEmpty:y,onClick:b,onKeyDown:v,onKeyUp:x,onPaste:w,onInput:k,endAdornment:S,startAdornment:I,tabIndex:T,contentEditable:N,focused:C,value:A,onChange:E,fullWidth:_,id:$,name:R,helperText:D,FormHelperTextProps:M,label:F,InputLabelProps:O}=r,P=us(r,MI),L=Nx(n,t.useRef(null)),z=Wx($),B=D&&z?`${z}-helper-text`:void 0,V=F&&z?`${z}-label`:void 0,W=(0,oo.A)({},r,{color:o,disabled:l,error:u,focused:C,required:d,variant:c}),U=(e=>{const{focused:t,disabled:n,classes:r,required:a}=e;return ix({root:["root",t&&!n&&"focused",n&&"disabled",a&&"required"]},jS,r)})(W),j=FI[c];return(0,$n.jsxs)(OI,(0,oo.A)({className:(0,vn.A)(U.root,i),ref:L,focused:C,onFocus:a,onBlur:s,disabled:l,variant:c,error:u,color:o,fullWidth:_,required:d,ownerState:W},P,{children:[(0,$n.jsx)(wa,(0,oo.A)({htmlFor:z,id:V},O,{children:F})),(0,$n.jsx)(j,(0,oo.A)({elements:g,areAllSectionsEmpty:y,onClick:b,onKeyDown:v,onKeyUp:x,onInput:k,onPaste:w,endAdornment:S,startAdornment:I,tabIndex:T,contentEditable:N,value:A,onChange:E,id:z,fullWidth:_,inputProps:p,inputRef:f,sectionListRef:m,label:F,name:R,role:"group","aria-labelledby":V},h)),D&&(0,$n.jsx)($a,(0,oo.A)({id:B},M,{children:D}))]}))})),LI=["enableAccessibleFieldDOMStructure"],zI=["InputProps","readOnly"],BI=["onPaste","onKeyDown","inputMode","readOnly","InputProps","inputProps","inputRef"],VI=["slots","slotProps","InputProps","inputProps"],WI=t.forwardRef((function(e,n){const r=Hi({props:e,name:"MuiDateField"}),{slots:a,slotProps:s,InputProps:i,inputProps:o}=r,l=us(r,VI),u=r,c=a?.textField??(e.enableAccessibleFieldDOMStructure?PI:ro),d=Dx({elementType:c,externalSlotProps:s?.textField,externalForwardedProps:l,additionalProps:{ref:n},ownerState:u});d.inputProps=(0,oo.A)({},o,d.inputProps),d.InputProps=(0,oo.A)({},i,d.InputProps);const h=(e=>{let{enableAccessibleFieldDOMStructure:t}=e,n=us(e,LI);if(t){const{InputProps:e,readOnly:t}=n,r=us(n,zI);return(0,oo.A)({},r,{InputProps:(0,oo.A)({},e??{},{readOnly:t})})}const{onPaste:r,onKeyDown:a,inputMode:s,readOnly:i,InputProps:o,inputProps:l,inputRef:u}=n,c=us(n,BI);return(0,oo.A)({},c,{InputProps:(0,oo.A)({},o??{},{readOnly:i}),inputProps:(0,oo.A)({},l??{},{inputMode:s,onPaste:r,onKeyDown:a,ref:u})})})(VS(d)),p=(e=>{const n=bx(),{clearable:r,onClear:a,InputProps:s,sx:i,slots:o,slotProps:l}=e,u=us(e,WS),c=o?.clearButton??Uo,d=us(Dx({elementType:c,externalSlotProps:l?.clearButton,ownerState:{},className:"clearButton",additionalProps:{title:n.fieldClearLabel}}),US),h=o?.clearIcon??TS,p=Dx({elementType:h,externalSlotProps:l?.clearIcon,ownerState:{}});return(0,oo.A)({},u,{InputProps:(0,oo.A)({},s,{endAdornment:(0,$n.jsxs)(t.Fragment,{children:[r&&(0,$n.jsx)(zx,{position:"end",sx:{marginRight:s?.endAdornment?-1:-1.5},children:(0,$n.jsx)(c,(0,oo.A)({},d,{onClick:a,children:(0,$n.jsx)(h,(0,oo.A)({fontSize:"small"},p))}))}),s?.endAdornment]})}),sx:[{"& .clearButton":{opacity:1},"@media (pointer: fine)":{"& .clearButton":{opacity:0},"&:hover, &:focus-within":{".clearButton":{opacity:1}}}},...Array.isArray(i)?i:[i]]})})((0,oo.A)({},h,{slots:a,slotProps:s}));return(0,$n.jsx)(c,(0,oo.A)({},p))})),UI=e=>{let{shouldDisableDate:n,shouldDisableMonth:r,shouldDisableYear:a,minDate:s,maxDate:i,disableFuture:o,disablePast:l,timezone:u}=e;const c=nx();return t.useCallback((e=>null!==Tx({adapter:c,value:e,props:{shouldDisableDate:n,shouldDisableMonth:r,shouldDisableYear:a,minDate:s,maxDate:i,disableFuture:o,disablePast:l,timezone:u}})),[c,n,r,a,s,i,o,l,u])},jI=e=>{const{value:n,referenceDate:r,disableFuture:a,disablePast:s,disableSwitchToMonthOnDayFocus:i=!1,maxDate:o,minDate:l,onMonthChange:u,reduceAnimations:c,shouldDisableDate:d,timezone:h}=e,p=rx(),f=t.useRef(((e,t,n)=>(r,a)=>{switch(a.type){case"changeMonth":return(0,oo.A)({},r,{slideDirection:a.direction,currentMonth:a.newMonth,isMonthSwitchingAnimating:!e});case"finishMonthSwitchingAnimation":return(0,oo.A)({},r,{isMonthSwitchingAnimating:!1});case"changeFocusedDay":{if(null!=r.focusedDay&&null!=a.focusedDay&&n.isSameDay(a.focusedDay,r.focusedDay))return r;const s=null!=a.focusedDay&&!t&&!n.isSameMonth(r.currentMonth,a.focusedDay);return(0,oo.A)({},r,{focusedDay:a.focusedDay,isMonthSwitchingAnimating:s&&!e&&!a.withoutMonthSwitchingAnimation,currentMonth:s?n.startOfMonth(a.focusedDay):r.currentMonth,slideDirection:null!=a.focusedDay&&n.isAfterDay(a.focusedDay,r.currentMonth)?"left":"right"})}default:throw new Error("missing support")}})(Boolean(c),i,p)).current,m=t.useMemo((()=>Qv.getInitialReferenceValue({value:n,utils:p,timezone:h,props:e,referenceDate:r,granularity:Cv.day})),[]),[g,y]=t.useReducer(f,{isMonthSwitchingAnimating:!1,focusedDay:m,currentMonth:p.startOfMonth(m),slideDirection:"left"}),b=t.useCallback((e=>{y((0,oo.A)({type:"changeMonth"},e)),u&&u(e.newMonth)}),[u]),v=t.useCallback((e=>{const t=e;p.isSameMonth(t,g.currentMonth)||b({newMonth:p.startOfMonth(t),direction:p.isAfterDay(t,g.currentMonth)?"left":"right"})}),[g.currentMonth,b,p]),x=UI({shouldDisableDate:d,minDate:l,maxDate:o,disableFuture:a,disablePast:s,timezone:h}),w=t.useCallback((()=>{y({type:"finishMonthSwitchingAnimation"})}),[]),k=gk(((e,t)=>{x(e)||y({type:"changeFocusedDay",focusedDay:e,withoutMonthSwitchingAnimation:t})}));return{referenceDate:m,calendarState:g,changeMonth:v,changeFocusedDay:k,isDateDisabled:x,onMonthSwitchingAnimationEnd:w,handleChangeMonth:b}},GI=e=>dx("MuiPickersFadeTransitionGroup",e),HI=(hx("MuiPickersFadeTransitionGroup",["root"]),(0,Wn.Ay)(fo,{name:"MuiPickersFadeTransitionGroup",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"block",position:"relative"}));function qI(e){const t=Hi({props:e,name:"MuiPickersFadeTransitionGroup"}),{children:n,className:r,reduceAnimations:a,transKey:s}=t,i=(e=>{const{classes:t}=e;return ix({root:["root"]},GI,t)})(t),o=jn();return a?n:(0,$n.jsx)(HI,{className:(0,vn.A)(i.root,r),children:(0,$n.jsx)(Bs,{appear:!1,mountOnEnter:!0,unmountOnExit:!0,timeout:{appear:o.transitions.duration.enteringScreen,enter:o.transitions.duration.enteringScreen,exit:0},children:n},s)})}function KI(e){return dx("MuiPickersDay",e)}const YI=hx("MuiPickersDay",["root","dayWithMargin","dayOutsideMonth","hiddenDaySpacingFiller","today","selected","disabled"]),XI=["autoFocus","className","day","disabled","disableHighlightToday","disableMargin","hidden","isAnimating","onClick","onDaySelect","onFocus","onBlur","onKeyDown","onMouseDown","onMouseEnter","outsideCurrentMonth","selected","showDaysOutsideCurrentMonth","children","today","isFirstVisibleCell","isLastVisibleCell"],QI=e=>{let{theme:t}=e;return(0,oo.A)({},t.typography.caption,{width:36,height:36,borderRadius:"50%",padding:0,backgroundColor:"transparent",transition:t.transitions.create("background-color",{duration:t.transitions.duration.short}),color:(t.vars||t).palette.text.primary,"@media (pointer: fine)":{"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Vn.X4)(t.palette.primary.main,t.palette.action.hoverOpacity)}},"&:focus":{backgroundColor:t.vars?`rgba(${t.vars.palette.primary.mainChannel} / ${t.vars.palette.action.focusOpacity})`:(0,Vn.X4)(t.palette.primary.main,t.palette.action.focusOpacity),[`&.${YI.selected}`]:{willChange:"background-color",backgroundColor:(t.vars||t).palette.primary.dark}},[`&.${YI.selected}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.main,fontWeight:t.typography.fontWeightMedium,"&:hover":{willChange:"background-color",backgroundColor:(t.vars||t).palette.primary.dark}},[`&.${YI.disabled}:not(.${YI.selected})`]:{color:(t.vars||t).palette.text.disabled},[`&.${YI.disabled}&.${YI.selected}`]:{opacity:.6},variants:[{props:{disableMargin:!1},style:{margin:"0 2px"}},{props:{outsideCurrentMonth:!0,showDaysOutsideCurrentMonth:!0},style:{color:(t.vars||t).palette.text.secondary}},{props:{disableHighlightToday:!1,today:!0},style:{[`&:not(.${YI.selected})`]:{border:`1px solid ${(t.vars||t).palette.text.secondary}`}}}]})},ZI=(e,t)=>{const{ownerState:n}=e;return[t.root,!n.disableMargin&&t.dayWithMargin,!n.disableHighlightToday&&n.today&&t.today,!n.outsideCurrentMonth&&n.showDaysOutsideCurrentMonth&&t.dayOutsideMonth,n.outsideCurrentMonth&&!n.showDaysOutsideCurrentMonth&&t.hiddenDaySpacingFiller]},JI=(0,Wn.Ay)(Co,{name:"MuiPickersDay",slot:"Root",overridesResolver:ZI})(QI),eT=(0,Wn.Ay)("div",{name:"MuiPickersDay",slot:"Root",overridesResolver:ZI})((e=>{let{theme:t}=e;return(0,oo.A)({},QI({theme:t}),{opacity:0,pointerEvents:"none"})})),tT=()=>{},nT=t.forwardRef((function(e,n){const r=Hi({props:e,name:"MuiPickersDay"}),{autoFocus:a=!1,className:s,day:i,disabled:o=!1,disableHighlightToday:l=!1,disableMargin:u=!1,isAnimating:c,onClick:d,onDaySelect:h,onFocus:p=tT,onBlur:f=tT,onKeyDown:m=tT,onMouseDown:g=tT,onMouseEnter:y=tT,outsideCurrentMonth:b,selected:v=!1,showDaysOutsideCurrentMonth:x=!1,children:w,today:k=!1}=r,S=us(r,XI),I=(0,oo.A)({},r,{autoFocus:a,disabled:o,disableHighlightToday:l,disableMargin:u,selected:v,showDaysOutsideCurrentMonth:x,today:k}),T=(e=>{const{selected:t,disableMargin:n,disableHighlightToday:r,today:a,disabled:s,outsideCurrentMonth:i,showDaysOutsideCurrentMonth:o,classes:l}=e,u=i&&!o;return ix({root:["root",t&&!u&&"selected",s&&"disabled",!n&&"dayWithMargin",!r&&a&&"today",i&&o&&"dayOutsideMonth",u&&"hiddenDaySpacingFiller"],hiddenDaySpacingFiller:["hiddenDaySpacingFiller"]},KI,l)})(I),N=rx(),C=t.useRef(null),A=Nx(C,n);mk((()=>{!a||o||c||b||C.current.focus()}),[a,o,c,b]);return b&&!x?(0,$n.jsx)(eT,{className:(0,vn.A)(T.root,T.hiddenDaySpacingFiller,s),ownerState:I,role:S.role}):(0,$n.jsx)(JI,(0,oo.A)({className:(0,vn.A)(T.root,s),ref:A,centerRipple:!0,disabled:o,tabIndex:v?0:-1,onKeyDown:e=>m(e,i),onFocus:e=>p(e,i),onBlur:e=>f(e,i),onMouseEnter:e=>y(e,i),onClick:e=>{o||h(i),b&&e.currentTarget.focus(),d&&d(e)},onMouseDown:e=>{g(e),b&&e.preventDefault()}},S,{ownerState:I,children:w||N.format(i,"dayOfMonth")}))})),rT=t.memo(nT);function aT(e,t){return e.replace(new RegExp("(^|\\s)"+t+"(?:\\s|$)","g"),"$1").replace(/\s+/g," ").replace(/^\s*|\s*$/g,"")}var sT=function(e,t){return e&&t&&t.split(" ").forEach((function(t){return r=t,void((n=e).classList?n.classList.remove(r):"string"===typeof n.className?n.className=aT(n.className,r):n.setAttribute("class",aT(n.className&&n.className.baseVal||"",r)));var n,r}))},iT=function(e){function n(){for(var t,n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];return(t=e.call.apply(e,[this].concat(r))||this).appliedClasses={appear:{},enter:{},exit:{}},t.onEnter=function(e,n){var r=t.resolveArguments(e,n),a=r[0],s=r[1];t.removeClasses(a,"exit"),t.addClass(a,s?"appear":"enter","base"),t.props.onEnter&&t.props.onEnter(e,n)},t.onEntering=function(e,n){var r=t.resolveArguments(e,n),a=r[0],s=r[1]?"appear":"enter";t.addClass(a,s,"active"),t.props.onEntering&&t.props.onEntering(e,n)},t.onEntered=function(e,n){var r=t.resolveArguments(e,n),a=r[0],s=r[1]?"appear":"enter";t.removeClasses(a,s),t.addClass(a,s,"done"),t.props.onEntered&&t.props.onEntered(e,n)},t.onExit=function(e){var n=t.resolveArguments(e)[0];t.removeClasses(n,"appear"),t.removeClasses(n,"enter"),t.addClass(n,"exit","base"),t.props.onExit&&t.props.onExit(e)},t.onExiting=function(e){var n=t.resolveArguments(e)[0];t.addClass(n,"exit","active"),t.props.onExiting&&t.props.onExiting(e)},t.onExited=function(e){var n=t.resolveArguments(e)[0];t.removeClasses(n,"exit"),t.addClass(n,"exit","done"),t.props.onExited&&t.props.onExited(e)},t.resolveArguments=function(e,n){return t.props.nodeRef?[t.props.nodeRef.current,e]:[e,n]},t.getClassNames=function(e){var n=t.props.classNames,r="string"===typeof n,a=r?""+(r&&n?n+"-":"")+e:n[e];return{baseClassName:a,activeClassName:r?a+"-active":n[e+"Active"],doneClassName:r?a+"-done":n[e+"Done"]}},t}ds(n,e);var r=n.prototype;return r.addClass=function(e,t,n){var r=this.getClassNames(t)[n+"ClassName"],a=this.getClassNames("enter").doneClassName;"appear"===t&&"done"===n&&a&&(r+=" "+a),"active"===n&&e&&fs(e),r&&(this.appliedClasses[t][n]=r,function(e,t){e&&t&&t.split(" ").forEach((function(t){return r=t,void((n=e).classList?n.classList.add(r):function(e,t){return e.classList?!!t&&e.classList.contains(t):-1!==(" "+(e.className.baseVal||e.className)+" ").indexOf(" "+t+" ")}(n,r)||("string"===typeof n.className?n.className=n.className+" "+r:n.setAttribute("class",(n.className&&n.className.baseVal||"")+" "+r)));var n,r}))}(e,r))},r.removeClasses=function(e,t){var n=this.appliedClasses[t],r=n.base,a=n.active,s=n.done;this.appliedClasses[t]={},r&&sT(e,r),a&&sT(e,a),s&&sT(e,s)},r.render=function(){var e=this.props,n=(e.classNames,us(e,["classNames"]));return t.createElement(ks,(0,oo.A)({},n,{onEnter:this.onEnter,onEntered:this.onEntered,onEntering:this.onEntering,onExit:this.onExit,onExiting:this.onExiting,onExited:this.onExited}))},n}(t.Component);iT.defaultProps={classNames:""},iT.propTypes={};const oT=iT,lT=e=>dx("MuiPickersSlideTransition",e),uT=hx("MuiPickersSlideTransition",["root","slideEnter-left","slideEnter-right","slideEnterActive","slideExit","slideExitActiveLeft-left","slideExitActiveLeft-right"]),cT=["children","className","reduceAnimations","slideDirection","transKey","classes"],dT=(0,Wn.Ay)(fo,{name:"MuiPickersSlideTransition",slot:"Root",overridesResolver:(e,t)=>[t.root,{[`.${uT["slideEnter-left"]}`]:t["slideEnter-left"]},{[`.${uT["slideEnter-right"]}`]:t["slideEnter-right"]},{[`.${uT.slideEnterActive}`]:t.slideEnterActive},{[`.${uT.slideExit}`]:t.slideExit},{[`.${uT["slideExitActiveLeft-left"]}`]:t["slideExitActiveLeft-left"]},{[`.${uT["slideExitActiveLeft-right"]}`]:t["slideExitActiveLeft-right"]}]})((e=>{let{theme:t}=e;const n=t.transitions.create("transform",{duration:t.transitions.duration.complex,easing:"cubic-bezier(0.35, 0.8, 0.4, 1)"});return{display:"block",position:"relative",overflowX:"hidden","& > *":{position:"absolute",top:0,right:0,left:0},[`& .${uT["slideEnter-left"]}`]:{willChange:"transform",transform:"translate(100%)",zIndex:1},[`& .${uT["slideEnter-right"]}`]:{willChange:"transform",transform:"translate(-100%)",zIndex:1},[`& .${uT.slideEnterActive}`]:{transform:"translate(0%)",transition:n},[`& .${uT.slideExit}`]:{transform:"translate(0%)"},[`& .${uT["slideExitActiveLeft-left"]}`]:{willChange:"transform",transform:"translate(-100%)",transition:n,zIndex:0},[`& .${uT["slideExitActiveLeft-right"]}`]:{willChange:"transform",transform:"translate(100%)",transition:n,zIndex:0}}}));const hT=e=>dx("MuiDayCalendar",e),pT=(hx("MuiDayCalendar",["root","header","weekDayLabel","loadingContainer","slideTransition","monthContainer","weekContainer","weekNumberLabel","weekNumber"]),["parentProps","day","focusableDay","selectedDays","isDateDisabled","currentMonthNumber","isViewFocused"]),fT=["ownerState"],mT=(0,Wn.Ay)("div",{name:"MuiDayCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({}),gT=(0,Wn.Ay)("div",{name:"MuiDayCalendar",slot:"Header",overridesResolver:(e,t)=>t.header})({display:"flex",justifyContent:"center",alignItems:"center"}),yT=(0,Wn.Ay)(mr,{name:"MuiDayCalendar",slot:"WeekDayLabel",overridesResolver:(e,t)=>t.weekDayLabel})((e=>{let{theme:t}=e;return{width:36,height:40,margin:"0 2px",textAlign:"center",display:"flex",justifyContent:"center",alignItems:"center",color:(t.vars||t).palette.text.secondary}})),bT=(0,Wn.Ay)(mr,{name:"MuiDayCalendar",slot:"WeekNumberLabel",overridesResolver:(e,t)=>t.weekNumberLabel})((e=>{let{theme:t}=e;return{width:36,height:40,margin:"0 2px",textAlign:"center",display:"flex",justifyContent:"center",alignItems:"center",color:t.palette.text.disabled}})),vT=(0,Wn.Ay)(mr,{name:"MuiDayCalendar",slot:"WeekNumber",overridesResolver:(e,t)=>t.weekNumber})((e=>{let{theme:t}=e;return(0,oo.A)({},t.typography.caption,{width:36,height:36,padding:0,margin:"0 2px",color:t.palette.text.disabled,fontSize:"0.75rem",alignItems:"center",justifyContent:"center",display:"inline-flex"})})),xT=(0,Wn.Ay)("div",{name:"MuiDayCalendar",slot:"LoadingContainer",overridesResolver:(e,t)=>t.loadingContainer})({display:"flex",justifyContent:"center",alignItems:"center",minHeight:240}),wT=(0,Wn.Ay)((function(e){const n=Hi({props:e,name:"MuiPickersSlideTransition"}),{children:r,className:a,reduceAnimations:s,transKey:i}=n,o=us(n,cT),l=(e=>{const{classes:t,slideDirection:n}=e;return ix({root:["root"],exit:["slideExit"],enterActive:["slideEnterActive"],enter:[`slideEnter-${n}`],exitActive:[`slideExitActiveLeft-${n}`]},lT,t)})(n),u=jn();if(s)return(0,$n.jsx)("div",{className:(0,vn.A)(l.root,a),children:r});const c={exit:l.exit,enterActive:l.enterActive,enter:l.enter,exitActive:l.exitActive};return(0,$n.jsx)(dT,{className:(0,vn.A)(l.root,a),childFactory:e=>t.cloneElement(e,{classNames:c}),role:"presentation",children:(0,$n.jsx)(oT,(0,oo.A)({mountOnEnter:!0,unmountOnExit:!0,timeout:u.transitions.duration.complex,classNames:c},o,{children:r}),i)})}),{name:"MuiDayCalendar",slot:"SlideTransition",overridesResolver:(e,t)=>t.slideTransition})({minHeight:240}),kT=(0,Wn.Ay)("div",{name:"MuiDayCalendar",slot:"MonthContainer",overridesResolver:(e,t)=>t.monthContainer})({overflow:"hidden"}),ST=(0,Wn.Ay)("div",{name:"MuiDayCalendar",slot:"WeekContainer",overridesResolver:(e,t)=>t.weekContainer})({margin:"2px 0",display:"flex",justifyContent:"center"});function IT(e){let{parentProps:n,day:r,focusableDay:a,selectedDays:s,isDateDisabled:i,currentMonthNumber:o,isViewFocused:l}=e,u=us(e,pT);const{disabled:c,disableHighlightToday:d,isMonthSwitchingAnimating:h,showDaysOutsideCurrentMonth:p,slots:f,slotProps:m,timezone:g}=n,y=rx(),b=sx(g),v=null!==a&&y.isSameDay(r,a),x=s.some((e=>y.isSameDay(e,r))),w=y.isSameDay(r,b),k=f?.day??rT,S=us(Dx({elementType:k,externalSlotProps:m?.day,additionalProps:(0,oo.A)({disableHighlightToday:d,showDaysOutsideCurrentMonth:p,role:"gridcell",isAnimating:h,"data-timestamp":y.toJsDate(r).valueOf()},u),ownerState:(0,oo.A)({},n,{day:r,selected:x})}),fT),I=t.useMemo((()=>c||i(r)),[c,i,r]),T=t.useMemo((()=>y.getMonth(r)!==o),[y,r,o]),N=t.useMemo((()=>{const e=y.startOfMonth(y.setMonth(r,o));return p?y.isSameDay(r,y.startOfWeek(e)):y.isSameDay(r,e)}),[o,r,p,y]),C=t.useMemo((()=>{const e=y.endOfMonth(y.setMonth(r,o));return p?y.isSameDay(r,y.endOfWeek(e)):y.isSameDay(r,e)}),[o,r,p,y]);return(0,$n.jsx)(k,(0,oo.A)({},S,{day:r,disabled:I,autoFocus:l&&v,today:w,outsideCurrentMonth:T,isFirstVisibleCell:N,isLastVisibleCell:C,selected:x,tabIndex:v?0:-1,"aria-selected":x,"aria-current":w?"date":void 0}))}function TT(e){const n=Hi({props:e,name:"MuiDayCalendar"}),r=rx(),{onFocusedDayChange:a,className:s,currentMonth:i,selectedDays:o,focusedDay:l,loading:u,onSelectedDaysChange:c,onMonthSwitchingAnimationEnd:d,readOnly:h,reduceAnimations:p,renderLoading:f=()=>(0,$n.jsx)("span",{children:"..."}),slideDirection:m,TransitionProps:g,disablePast:y,disableFuture:b,minDate:v,maxDate:x,shouldDisableDate:w,shouldDisableMonth:k,shouldDisableYear:S,dayOfWeekFormatter:I=e=>r.format(e,"weekdayShort").charAt(0).toUpperCase(),hasFocus:T,onFocusedViewChange:N,gridLabelId:C,displayWeekNumber:A,fixedWeekNumber:E,autoFocus:_,timezone:$}=n,R=sx($),D=(e=>{const{classes:t}=e;return ix({root:["root"],header:["header"],weekDayLabel:["weekDayLabel"],loadingContainer:["loadingContainer"],slideTransition:["slideTransition"],monthContainer:["monthContainer"],weekContainer:["weekContainer"],weekNumberLabel:["weekNumberLabel"],weekNumber:["weekNumber"]},hT,t)})(n),M=Fa(),F=UI({shouldDisableDate:w,shouldDisableMonth:k,shouldDisableYear:S,minDate:v,maxDate:x,disablePast:y,disableFuture:b,timezone:$}),O=bx(),[P,L]=Rk({name:"DayCalendar",state:"hasFocus",controlled:T,default:_??!1}),[z,B]=t.useState((()=>l||R)),V=gk((e=>{h||c(e)})),W=e=>{F(e)||(a(e),B(e),N?.(!0),L(!0))},U=gk(((e,t)=>{switch(e.key){case"ArrowUp":W(r.addDays(t,-7)),e.preventDefault();break;case"ArrowDown":W(r.addDays(t,7)),e.preventDefault();break;case"ArrowLeft":{const n=r.addDays(t,M?1:-1),a=r.addMonths(t,M?1:-1),s=yv({utils:r,date:n,minDate:M?n:r.startOfMonth(a),maxDate:M?r.endOfMonth(a):n,isDateDisabled:F,timezone:$});W(s||n),e.preventDefault();break}case"ArrowRight":{const n=r.addDays(t,M?-1:1),a=r.addMonths(t,M?-1:1),s=yv({utils:r,date:n,minDate:M?r.startOfMonth(a):n,maxDate:M?n:r.endOfMonth(a),isDateDisabled:F,timezone:$});W(s||n),e.preventDefault();break}case"Home":W(r.startOfWeek(t)),e.preventDefault();break;case"End":W(r.endOfWeek(t)),e.preventDefault();break;case"PageUp":W(r.addMonths(t,1)),e.preventDefault();break;case"PageDown":W(r.addMonths(t,-1)),e.preventDefault()}})),j=gk(((e,t)=>W(t))),G=gk(((e,t)=>{P&&r.isSameDay(z,t)&&N?.(!1)})),H=r.getMonth(i),q=r.getYear(i),K=t.useMemo((()=>o.filter((e=>!!e)).map((e=>r.startOfDay(e)))),[r,o]),Y=`${q}-${H}`,X=t.useMemo((()=>t.createRef()),[Y]),Q=t.useMemo((()=>{const e=r.startOfMonth(i),t=r.endOfMonth(i);return F(z)||r.isAfterDay(z,t)||r.isBeforeDay(z,e)?yv({utils:r,date:z,minDate:e,maxDate:t,disablePast:y,disableFuture:b,isDateDisabled:F,timezone:$}):z}),[i,b,y,z,F,r,$]),Z=t.useMemo((()=>{const e=r.setTimezone(i,$),t=r.getWeekArray(e);let n=r.addMonths(e,1);for(;E&&t.length<E;){const e=r.getWeekArray(n),a=r.isSameDay(t[t.length-1][0],e[0][0]);e.slice(a?1:0).forEach((e=>{t.length<E&&t.push(e)})),n=r.addMonths(n,1)}return t}),[i,E,r,$]);return(0,$n.jsxs)(mT,{role:"grid","aria-labelledby":C,className:D.root,children:[(0,$n.jsxs)(gT,{role:"row",className:D.header,children:[A&&(0,$n.jsx)(bT,{variant:"caption",role:"columnheader","aria-label":O.calendarWeekNumberHeaderLabel,className:D.weekNumberLabel,children:O.calendarWeekNumberHeaderText}),Iv(r,R).map(((e,t)=>(0,$n.jsx)(yT,{variant:"caption",role:"columnheader","aria-label":r.format(e,"weekday"),className:D.weekDayLabel,children:I(e)},t.toString())))]}),u?(0,$n.jsx)(xT,{className:D.loadingContainer,children:f()}):(0,$n.jsx)(wT,(0,oo.A)({transKey:Y,onExited:d,reduceAnimations:p,slideDirection:m,className:(0,vn.A)(s,D.slideTransition)},g,{nodeRef:X,children:(0,$n.jsx)(kT,{ref:X,role:"rowgroup",className:D.monthContainer,children:Z.map(((e,t)=>(0,$n.jsxs)(ST,{role:"row",className:D.weekContainer,"aria-rowindex":t+1,children:[A&&(0,$n.jsx)(vT,{className:D.weekNumber,role:"rowheader","aria-label":O.calendarWeekNumberAriaLabelText(r.getWeekNumber(e[0])),children:O.calendarWeekNumberText(r.getWeekNumber(e[0]))}),e.map(((e,t)=>(0,$n.jsx)(IT,{parentProps:n,day:e,selectedDays:K,focusableDay:Q,onKeyDown:U,onFocus:j,onBlur:G,onDaySelect:V,isDateDisabled:F,currentMonthNumber:H,isViewFocused:P,"aria-colindex":t+1},e.toString())))]},`week-${e[0]}`)))})}))]})}function NT(e){return dx("MuiPickersMonth",e)}const CT=hx("MuiPickersMonth",["root","monthButton","disabled","selected"]),AT=["autoFocus","className","children","disabled","selected","value","tabIndex","onClick","onKeyDown","onFocus","onBlur","aria-current","aria-label","monthsPerRow","slots","slotProps"],ET=(0,Wn.Ay)("div",{name:"MuiPickersMonth",slot:"Root",overridesResolver:(e,t)=>[t.root]})({display:"flex",alignItems:"center",justifyContent:"center",flexBasis:"33.3%",variants:[{props:{monthsPerRow:4},style:{flexBasis:"25%"}}]}),_T=(0,Wn.Ay)("button",{name:"MuiPickersMonth",slot:"MonthButton",overridesResolver:(e,t)=>[t.monthButton,{[`&.${CT.disabled}`]:t.disabled},{[`&.${CT.selected}`]:t.selected}]})((e=>{let{theme:t}=e;return(0,oo.A)({color:"unset",backgroundColor:"transparent",border:0,outline:0},t.typography.subtitle1,{margin:"8px 0",height:36,width:72,borderRadius:18,cursor:"pointer","&:focus":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Vn.X4)(t.palette.action.active,t.palette.action.hoverOpacity)},"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Vn.X4)(t.palette.action.active,t.palette.action.hoverOpacity)},"&:disabled":{cursor:"auto",pointerEvents:"none"},[`&.${CT.disabled}`]:{color:(t.vars||t).palette.text.secondary},[`&.${CT.selected}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.main,"&:focus, &:hover":{backgroundColor:(t.vars||t).palette.primary.dark}}})})),$T=t.memo((function(e){const n=Hi({props:e,name:"MuiPickersMonth"}),{autoFocus:r,className:a,children:s,disabled:i,selected:o,value:l,tabIndex:u,onClick:c,onKeyDown:d,onFocus:h,onBlur:p,"aria-current":f,"aria-label":m,slots:g,slotProps:y}=n,b=us(n,AT),v=t.useRef(null),x=(e=>{const{disabled:t,selected:n,classes:r}=e;return ix({root:["root"],monthButton:["monthButton",t&&"disabled",n&&"selected"]},NT,r)})(n);mk((()=>{r&&v.current?.focus()}),[r]);const w=g?.monthButton??_T,k=Dx({elementType:w,externalSlotProps:y?.monthButton,additionalProps:{children:s,disabled:i,tabIndex:u,ref:v,type:"button",role:"radio","aria-current":f,"aria-checked":o,"aria-label":m,onClick:e=>c(e,l),onKeyDown:e=>d(e,l),onFocus:e=>h(e,l),onBlur:e=>p(e,l)},ownerState:n,className:x.monthButton});return(0,$n.jsx)(ET,(0,oo.A)({className:(0,vn.A)(x.root,a),ownerState:n},b,{children:(0,$n.jsx)(w,(0,oo.A)({},k))}))}));function RT(e){return dx("MuiMonthCalendar",e)}hx("MuiMonthCalendar",["root"]);const DT=["className","value","defaultValue","referenceDate","disabled","disableFuture","disablePast","maxDate","minDate","onChange","shouldDisableMonth","readOnly","disableHighlightToday","autoFocus","onMonthFocus","hasFocus","onFocusedViewChange","monthsPerRow","timezone","gridLabelId","slots","slotProps"];const MT=(0,Wn.Ay)("div",{name:"MuiMonthCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",flexWrap:"wrap",alignContent:"stretch",padding:"0 4px",width:cS,boxSizing:"border-box"}),FT=t.forwardRef((function(e,n){const r=function(e,t){const n=rx(),r=ax(),a=Hi({props:e,name:t});return(0,oo.A)({disableFuture:!1,disablePast:!1},a,{minDate:bv(n,a.minDate,r.minDate),maxDate:bv(n,a.maxDate,r.maxDate)})}(e,"MuiMonthCalendar"),{className:a,value:s,defaultValue:i,referenceDate:o,disabled:l,disableFuture:u,disablePast:c,maxDate:d,minDate:h,onChange:p,shouldDisableMonth:f,readOnly:m,autoFocus:g=!1,onMonthFocus:y,hasFocus:b,onFocusedViewChange:v,monthsPerRow:x=3,timezone:w,gridLabelId:k,slots:S,slotProps:I}=r,T=us(r,DT),{value:N,handleValueChange:C,timezone:A}=Mk({name:"MonthCalendar",timezone:w,value:s,defaultValue:i,onChange:p,valueManager:Qv}),E=sx(A),_=Fa(),$=rx(),R=t.useMemo((()=>Qv.getInitialReferenceValue({value:N,utils:$,props:r,timezone:A,referenceDate:o,granularity:Cv.month})),[]),D=r,M=(e=>{const{classes:t}=e;return ix({root:["root"]},RT,t)})(D),F=t.useMemo((()=>$.getMonth(E)),[$,E]),O=t.useMemo((()=>null!=N?$.getMonth(N):null),[N,$]),[P,L]=t.useState((()=>O||$.getMonth(R))),[z,B]=Rk({name:"MonthCalendar",state:"hasFocus",controlled:b,default:g??!1}),V=gk((e=>{B(e),v&&v(e)})),W=t.useCallback((e=>{const t=$.startOfMonth(c&&$.isAfter(E,h)?E:h),n=$.startOfMonth(u&&$.isBefore(E,d)?E:d),r=$.startOfMonth(e);return!!$.isBefore(r,t)||(!!$.isAfter(r,n)||!!f&&f(r))}),[u,c,d,h,E,f,$]),U=gk(((e,t)=>{if(m)return;const n=$.setMonth(N??R,t);C(n)})),j=gk((e=>{W($.setMonth(N??R,e))||(L(e),V(!0),y&&y(e))}));t.useEffect((()=>{L((e=>null!==O&&e!==O?O:e))}),[O]);const G=gk(((e,t)=>{const n=12;switch(e.key){case"ArrowUp":j((n+t-3)%n),e.preventDefault();break;case"ArrowDown":j((n+t+3)%n),e.preventDefault();break;case"ArrowLeft":j((n+t+(_?1:-1))%n),e.preventDefault();break;case"ArrowRight":j((n+t+(_?-1:1))%n),e.preventDefault()}})),H=gk(((e,t)=>{j(t)})),q=gk(((e,t)=>{P===t&&V(!1)}));return(0,$n.jsx)(MT,(0,oo.A)({ref:n,className:(0,vn.A)(M.root,a),ownerState:D,role:"radiogroup","aria-labelledby":k},T,{children:vv($,N??R).map((e=>{const t=$.getMonth(e),n=$.format(e,"monthShort"),r=$.format(e,"month"),a=t===O,s=l||W(e);return(0,$n.jsx)($T,{selected:a,value:t,onClick:U,onKeyDown:G,autoFocus:z&&t===P,disabled:s,tabIndex:t!==P||s?-1:0,onFocus:H,onBlur:q,"aria-current":F===t?"date":void 0,"aria-label":r,monthsPerRow:x,slots:S,slotProps:I,children:n},n)}))}))}));function OT(e){return dx("MuiPickersYear",e)}const PT=hx("MuiPickersYear",["root","yearButton","selected","disabled"]),LT=["autoFocus","className","children","disabled","selected","value","tabIndex","onClick","onKeyDown","onFocus","onBlur","aria-current","yearsPerRow","slots","slotProps"],zT=(0,Wn.Ay)("div",{name:"MuiPickersYear",slot:"Root",overridesResolver:(e,t)=>[t.root]})({display:"flex",alignItems:"center",justifyContent:"center",flexBasis:"33.3%",variants:[{props:{yearsPerRow:4},style:{flexBasis:"25%"}}]}),BT=(0,Wn.Ay)("button",{name:"MuiPickersYear",slot:"YearButton",overridesResolver:(e,t)=>[t.yearButton,{[`&.${PT.disabled}`]:t.disabled},{[`&.${PT.selected}`]:t.selected}]})((e=>{let{theme:t}=e;return(0,oo.A)({color:"unset",backgroundColor:"transparent",border:0,outline:0},t.typography.subtitle1,{margin:"6px 0",height:36,width:72,borderRadius:18,cursor:"pointer","&:focus":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.focusOpacity})`:(0,Vn.X4)(t.palette.action.active,t.palette.action.focusOpacity)},"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:(0,Vn.X4)(t.palette.action.active,t.palette.action.hoverOpacity)},"&:disabled":{cursor:"auto",pointerEvents:"none"},[`&.${PT.disabled}`]:{color:(t.vars||t).palette.text.secondary},[`&.${PT.selected}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.main,"&:focus, &:hover":{backgroundColor:(t.vars||t).palette.primary.dark}}})})),VT=t.memo((function(e){const n=Hi({props:e,name:"MuiPickersYear"}),{autoFocus:r,className:a,children:s,disabled:i,selected:o,value:l,tabIndex:u,onClick:c,onKeyDown:d,onFocus:h,onBlur:p,"aria-current":f,slots:m,slotProps:g}=n,y=us(n,LT),b=t.useRef(null),v=(e=>{const{disabled:t,selected:n,classes:r}=e;return ix({root:["root"],yearButton:["yearButton",t&&"disabled",n&&"selected"]},OT,r)})(n);mk((()=>{r&&b.current?.focus()}),[r]);const x=m?.yearButton??BT,w=Dx({elementType:x,externalSlotProps:g?.yearButton,additionalProps:{children:s,disabled:i,tabIndex:u,ref:b,type:"button",role:"radio","aria-current":f,"aria-checked":o,onClick:e=>c(e,l),onKeyDown:e=>d(e,l),onFocus:e=>h(e,l),onBlur:e=>p(e,l)},ownerState:n,className:v.yearButton});return(0,$n.jsx)(zT,(0,oo.A)({className:(0,vn.A)(v.root,a),ownerState:n},y,{children:(0,$n.jsx)(x,(0,oo.A)({},w))}))}));function WT(e){return dx("MuiYearCalendar",e)}hx("MuiYearCalendar",["root"]);const UT=["autoFocus","className","value","defaultValue","referenceDate","disabled","disableFuture","disablePast","maxDate","minDate","onChange","readOnly","shouldDisableYear","disableHighlightToday","onYearFocus","hasFocus","onFocusedViewChange","yearsPerRow","timezone","gridLabelId","slots","slotProps"];const jT=(0,Wn.Ay)("div",{name:"MuiYearCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",flexDirection:"row",flexWrap:"wrap",overflowY:"auto",height:"100%",padding:"0 4px",width:cS,maxHeight:280,boxSizing:"border-box",position:"relative"}),GT=t.forwardRef((function(e,n){const r=function(e,t){const n=rx(),r=ax(),a=Hi({props:e,name:t});return(0,oo.A)({disablePast:!1,disableFuture:!1},a,{yearsPerRow:a.yearsPerRow??3,minDate:bv(n,a.minDate,r.minDate),maxDate:bv(n,a.maxDate,r.maxDate)})}(e,"MuiYearCalendar"),{autoFocus:a,className:s,value:i,defaultValue:o,referenceDate:l,disabled:u,disableFuture:c,disablePast:d,maxDate:h,minDate:p,onChange:f,readOnly:m,shouldDisableYear:g,onYearFocus:y,hasFocus:b,onFocusedViewChange:v,yearsPerRow:x,timezone:w,gridLabelId:k,slots:S,slotProps:I}=r,T=us(r,UT),{value:N,handleValueChange:C,timezone:A}=Mk({name:"YearCalendar",timezone:w,value:i,defaultValue:o,onChange:f,valueManager:Qv}),E=sx(A),_=Fa(),$=rx(),R=t.useMemo((()=>Qv.getInitialReferenceValue({value:N,utils:$,props:r,timezone:A,referenceDate:l,granularity:Cv.year})),[]),D=r,M=(e=>{const{classes:t}=e;return ix({root:["root"]},WT,t)})(D),F=t.useMemo((()=>$.getYear(E)),[$,E]),O=t.useMemo((()=>null!=N?$.getYear(N):null),[N,$]),[P,L]=t.useState((()=>O||$.getYear(R))),[z,B]=Rk({name:"YearCalendar",state:"hasFocus",controlled:b,default:a??!1}),V=gk((e=>{B(e),v&&v(e)})),W=t.useCallback((e=>{if(d&&$.isBeforeYear(e,E))return!0;if(c&&$.isAfterYear(e,E))return!0;if(p&&$.isBeforeYear(e,p))return!0;if(h&&$.isAfterYear(e,h))return!0;if(!g)return!1;const t=$.startOfYear(e);return g(t)}),[c,d,h,p,E,g,$]),U=gk(((e,t)=>{if(m)return;const n=$.setYear(N??R,t);C(n)})),j=gk((e=>{W($.setYear(N??R,e))||(L(e),V(!0),y?.(e))}));t.useEffect((()=>{L((e=>null!==O&&e!==O?O:e))}),[O]);const G=gk(((e,t)=>{switch(e.key){case"ArrowUp":j(t-x),e.preventDefault();break;case"ArrowDown":j(t+x),e.preventDefault();break;case"ArrowLeft":j(t+(_?1:-1)),e.preventDefault();break;case"ArrowRight":j(t+(_?-1:1)),e.preventDefault()}})),H=gk(((e,t)=>{j(t)})),q=gk(((e,t)=>{P===t&&V(!1)})),K=t.useRef(null),Y=Nx(n,K);return t.useEffect((()=>{if(a||null===K.current)return;const e=K.current.querySelector('[tabindex="0"]');if(!e)return;const t=e.offsetHeight,n=e.offsetTop,r=K.current.clientHeight,s=K.current.scrollTop,i=n+t;t>r||n<s||(K.current.scrollTop=i-r/2-t/2)}),[a]),(0,$n.jsx)(jT,(0,oo.A)({ref:Y,className:(0,vn.A)(M.root,s),ownerState:D,role:"radiogroup","aria-labelledby":k},T,{children:$.getYearRange([p,h]).map((e=>{const t=$.getYear(e),n=t===O,r=u||W(e);return(0,$n.jsx)(VT,{selected:n,value:t,onClick:U,onKeyDown:G,autoFocus:z&&t===P,disabled:r,tabIndex:t!==P||r?-1:0,onFocus:H,onBlur:q,"aria-current":F===t?"date":void 0,yearsPerRow:x,slots:S,slotProps:I,children:$.format(e,"year")},$.format(e,"year"))}))}))}));function HT(e){return dx("MuiPickersArrowSwitcher",e)}hx("MuiPickersArrowSwitcher",["root","spacer","button","previousIconButton","nextIconButton","leftArrowIcon","rightArrowIcon"]);const qT=["children","className","slots","slotProps","isNextDisabled","isNextHidden","onGoToNext","nextLabel","isPreviousDisabled","isPreviousHidden","onGoToPrevious","previousLabel","labelId"],KT=["ownerState"],YT=["ownerState"],XT=(0,Wn.Ay)("div",{name:"MuiPickersArrowSwitcher",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex"}),QT=(0,Wn.Ay)("div",{name:"MuiPickersArrowSwitcher",slot:"Spacer",overridesResolver:(e,t)=>t.spacer})((e=>{let{theme:t}=e;return{width:t.spacing(3)}})),ZT=(0,Wn.Ay)(Uo,{name:"MuiPickersArrowSwitcher",slot:"Button",overridesResolver:(e,t)=>t.button})({variants:[{props:{hidden:!0},style:{visibility:"hidden"}}]}),JT=t.forwardRef((function(e,t){const n=Fa(),r=Hi({props:e,name:"MuiPickersArrowSwitcher"}),{children:a,className:s,slots:i,slotProps:o,isNextDisabled:l,isNextHidden:u,onGoToNext:c,nextLabel:d,isPreviousDisabled:h,isPreviousHidden:p,onGoToPrevious:f,previousLabel:m,labelId:g}=r,y=us(r,qT),b=r,v=(e=>{const{classes:t}=e;return ix({root:["root"],spacer:["spacer"],button:["button"],previousIconButton:["previousIconButton"],nextIconButton:["nextIconButton"],leftArrowIcon:["leftArrowIcon"],rightArrowIcon:["rightArrowIcon"]},HT,t)})(b),x={isDisabled:l,isHidden:u,goTo:c,label:d},w={isDisabled:h,isHidden:p,goTo:f,label:m},k=i?.previousIconButton??ZT,S=Dx({elementType:k,externalSlotProps:o?.previousIconButton,additionalProps:{size:"medium",title:w.label,"aria-label":w.label,disabled:w.isDisabled,edge:"end",onClick:w.goTo},ownerState:(0,oo.A)({},b,{hidden:w.isHidden}),className:(0,vn.A)(v.button,v.previousIconButton)}),I=i?.nextIconButton??ZT,T=Dx({elementType:I,externalSlotProps:o?.nextIconButton,additionalProps:{size:"medium",title:x.label,"aria-label":x.label,disabled:x.isDisabled,edge:"start",onClick:x.goTo},ownerState:(0,oo.A)({},b,{hidden:x.isHidden}),className:(0,vn.A)(v.button,v.nextIconButton)}),N=i?.leftArrowIcon??kS,C=us(Dx({elementType:N,externalSlotProps:o?.leftArrowIcon,additionalProps:{fontSize:"inherit"},ownerState:b,className:v.leftArrowIcon}),KT),A=i?.rightArrowIcon??SS,E=us(Dx({elementType:A,externalSlotProps:o?.rightArrowIcon,additionalProps:{fontSize:"inherit"},ownerState:b,className:v.rightArrowIcon}),YT);return(0,$n.jsxs)(XT,(0,oo.A)({ref:t,className:(0,vn.A)(v.root,s),ownerState:b},y,{children:[(0,$n.jsx)(k,(0,oo.A)({},S,{children:n?(0,$n.jsx)(A,(0,oo.A)({},E)):(0,$n.jsx)(N,(0,oo.A)({},C))})),a?(0,$n.jsx)(mr,{variant:"subtitle1",component:"span",id:g,children:a}):(0,$n.jsx)(QT,{className:v.spacer,ownerState:b}),(0,$n.jsx)(I,(0,oo.A)({},T,{children:n?(0,$n.jsx)(N,(0,oo.A)({},C)):(0,$n.jsx)(A,(0,oo.A)({},E))}))]}))}));const eN=e=>dx("MuiPickersCalendarHeader",e),tN=hx("MuiPickersCalendarHeader",["root","labelContainer","label","switchViewButton","switchViewIcon"]),nN=["slots","slotProps","currentMonth","disabled","disableFuture","disablePast","maxDate","minDate","onMonthChange","onViewChange","view","reduceAnimations","views","labelId","className","timezone","format"],rN=["ownerState"],aN=(0,Wn.Ay)("div",{name:"MuiPickersCalendarHeader",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",alignItems:"center",marginTop:12,marginBottom:4,paddingLeft:24,paddingRight:12,maxHeight:40,minHeight:40}),sN=(0,Wn.Ay)("div",{name:"MuiPickersCalendarHeader",slot:"LabelContainer",overridesResolver:(e,t)=>t.labelContainer})((e=>{let{theme:t}=e;return(0,oo.A)({display:"flex",overflow:"hidden",alignItems:"center",cursor:"pointer",marginRight:"auto"},t.typography.body1,{fontWeight:t.typography.fontWeightMedium})})),iN=(0,Wn.Ay)("div",{name:"MuiPickersCalendarHeader",slot:"Label",overridesResolver:(e,t)=>t.label})({marginRight:6}),oN=(0,Wn.Ay)(Uo,{name:"MuiPickersCalendarHeader",slot:"SwitchViewButton",overridesResolver:(e,t)=>t.switchViewButton})({marginRight:"auto",variants:[{props:{view:"year"},style:{[`.${tN.switchViewIcon}`]:{transform:"rotate(180deg)"}}}]}),lN=(0,Wn.Ay)(wS,{name:"MuiPickersCalendarHeader",slot:"SwitchViewIcon",overridesResolver:(e,t)=>t.switchViewIcon})((e=>{let{theme:t}=e;return{willChange:"transform",transition:t.transitions.create("transform"),transform:"rotate(0deg)"}})),uN=t.forwardRef((function(e,n){const r=bx(),a=rx(),s=Hi({props:e,name:"MuiPickersCalendarHeader"}),{slots:i,slotProps:o,currentMonth:l,disabled:u,disableFuture:c,disablePast:d,maxDate:h,minDate:p,onMonthChange:f,onViewChange:m,view:g,reduceAnimations:y,views:b,labelId:v,className:x,timezone:w,format:k=`${a.formats.month} ${a.formats.year}`}=s,S=us(s,nN),I=s,T=(e=>{const{classes:t}=e;return ix({root:["root"],labelContainer:["labelContainer"],label:["label"],switchViewButton:["switchViewButton"],switchViewIcon:["switchViewIcon"]},eN,t)})(s),N=i?.switchViewButton??oN,C=Dx({elementType:N,externalSlotProps:o?.switchViewButton,additionalProps:{size:"small","aria-label":r.calendarViewSwitchingButtonAriaLabel(g)},ownerState:I,className:T.switchViewButton}),A=i?.switchViewIcon??lN,E=us(Dx({elementType:A,externalSlotProps:o?.switchViewIcon,ownerState:I,className:T.switchViewIcon}),rN),_=function(e,n){let{disableFuture:r,maxDate:a,timezone:s}=n;const i=rx();return t.useMemo((()=>{const t=i.date(void 0,s),n=i.startOfMonth(r&&i.isBefore(t,a)?t:a);return!i.isAfter(n,e)}),[r,a,e,i,s])}(l,{disableFuture:c,maxDate:h,timezone:w}),$=function(e,n){let{disablePast:r,minDate:a,timezone:s}=n;const i=rx();return t.useMemo((()=>{const t=i.date(void 0,s),n=i.startOfMonth(r&&i.isAfter(t,a)?t:a);return!i.isBefore(n,e)}),[r,a,e,i,s])}(l,{disablePast:d,minDate:p,timezone:w});if(1===b.length&&"year"===b[0])return null;const R=a.formatByString(l,k);return(0,$n.jsxs)(aN,(0,oo.A)({},S,{ownerState:I,className:(0,vn.A)(x,T.root),ref:n,children:[(0,$n.jsxs)(sN,{role:"presentation",onClick:()=>{if(1!==b.length&&m&&!u)if(2===b.length)m(b.find((e=>e!==g))||b[0]);else{const e=0!==b.indexOf(g)?0:1;m(b[e])}},ownerState:I,"aria-live":"polite",className:T.labelContainer,children:[(0,$n.jsx)(qI,{reduceAnimations:y,transKey:R,children:(0,$n.jsx)(iN,{id:v,ownerState:I,className:T.label,children:R})}),b.length>1&&!u&&(0,$n.jsx)(N,(0,oo.A)({},C,{children:(0,$n.jsx)(A,(0,oo.A)({},E))}))]}),(0,$n.jsx)(Bs,{in:"day"===g,children:(0,$n.jsx)(JT,{slots:i,slotProps:o,onGoToPrevious:()=>f(a.addMonths(l,-1),"right"),isPreviousDisabled:$,previousLabel:r.previousMonth,onGoToNext:()=>f(a.addMonths(l,1),"left"),isNextDisabled:_,nextLabel:r.nextMonth})})]}))})),cN=(0,Wn.Ay)("div")({overflow:"hidden",width:cS,maxHeight:336,display:"flex",flexDirection:"column",margin:"0 auto"}),dN=e=>dx("MuiDateCalendar",e),hN=(hx("MuiDateCalendar",["root","viewTransitionContainer"]),["autoFocus","onViewChange","value","defaultValue","referenceDate","disableFuture","disablePast","onChange","onYearChange","onMonthChange","reduceAnimations","shouldDisableDate","shouldDisableMonth","shouldDisableYear","view","views","openTo","className","disabled","readOnly","minDate","maxDate","disableHighlightToday","focusedView","onFocusedViewChange","showDaysOutsideCurrentMonth","fixedWeekNumber","dayOfWeekFormatter","slots","slotProps","loading","renderLoading","displayWeekNumber","yearsPerRow","monthsPerRow","timezone"]);const pN=(0,Wn.Ay)(cN,{name:"MuiDateCalendar",slot:"Root",overridesResolver:(e,t)=>t.root})({display:"flex",flexDirection:"column",height:336}),fN=(0,Wn.Ay)(qI,{name:"MuiDateCalendar",slot:"ViewTransitionContainer",overridesResolver:(e,t)=>t.viewTransitionContainer})({}),mN=t.forwardRef((function(e,n){const r=rx(),a=Wx(),s=function(e,t){const n=rx(),r=ax(),a=Tk(),s=Hi({props:e,name:t});return(0,oo.A)({},s,{loading:s.loading??!1,disablePast:s.disablePast??!1,disableFuture:s.disableFuture??!1,openTo:s.openTo??"day",views:s.views??["year","day"],reduceAnimations:s.reduceAnimations??a,renderLoading:s.renderLoading??(()=>(0,$n.jsx)("span",{children:"..."})),minDate:bv(n,s.minDate,r.minDate),maxDate:bv(n,s.maxDate,r.maxDate)})}(e,"MuiDateCalendar"),{autoFocus:i,onViewChange:o,value:l,defaultValue:u,referenceDate:c,disableFuture:d,disablePast:h,onChange:p,onYearChange:f,onMonthChange:m,reduceAnimations:g,shouldDisableDate:y,shouldDisableMonth:b,shouldDisableYear:v,view:x,views:w,openTo:k,className:S,disabled:I,readOnly:T,minDate:N,maxDate:C,disableHighlightToday:A,focusedView:E,onFocusedViewChange:_,showDaysOutsideCurrentMonth:$,fixedWeekNumber:R,dayOfWeekFormatter:D,slots:M,slotProps:F,loading:O,renderLoading:P,displayWeekNumber:L,yearsPerRow:z,monthsPerRow:B,timezone:V}=s,W=us(s,hN),{value:U,handleValueChange:j,timezone:G}=Mk({name:"DateCalendar",timezone:V,value:l,defaultValue:u,onChange:p,valueManager:Qv}),{view:H,setView:q,focusedView:K,setFocusedView:Y,goToNextView:X,setValueAndGoToNextView:Q}=Ok({view:x,views:w,openTo:k,onChange:j,onViewChange:o,autoFocus:i,focusedView:E,onFocusedViewChange:_}),{referenceDate:Z,calendarState:J,changeFocusedDay:ee,changeMonth:te,handleChangeMonth:ne,isDateDisabled:re,onMonthSwitchingAnimationEnd:ae}=jI({value:U,referenceDate:c,reduceAnimations:g,onMonthChange:m,minDate:N,maxDate:C,shouldDisableDate:y,disablePast:h,disableFuture:d,timezone:G}),se=I&&U||N,ie=I&&U||C,oe=`${a}-grid-label`,le=null!==K,ue=M?.calendarHeader??uN,ce=Dx({elementType:ue,externalSlotProps:F?.calendarHeader,additionalProps:{views:w,view:H,currentMonth:J.currentMonth,onViewChange:q,onMonthChange:(e,t)=>ne({newMonth:e,direction:t}),minDate:se,maxDate:ie,disabled:I,disablePast:h,disableFuture:d,reduceAnimations:g,timezone:G,labelId:oe},ownerState:s}),de=gk((e=>{const t=r.startOfMonth(e),n=r.endOfMonth(e),a=re(e)?yv({utils:r,date:e,minDate:r.isBefore(N,t)?t:N,maxDate:r.isAfter(C,n)?n:C,disablePast:h,disableFuture:d,isDateDisabled:re,timezone:G}):e;a?(Q(a,"finish"),m?.(t)):(X(),te(t)),ee(a,!0)})),he=gk((e=>{const t=r.startOfYear(e),n=r.endOfYear(e),a=re(e)?yv({utils:r,date:e,minDate:r.isBefore(N,t)?t:N,maxDate:r.isAfter(C,n)?n:C,disablePast:h,disableFuture:d,isDateDisabled:re,timezone:G}):e;a?(Q(a,"finish"),f?.(a)):(X(),te(t)),ee(a,!0)})),pe=gk((e=>j(e?gv(r,e,U??Z):e,"finish",H)));t.useEffect((()=>{null!=U&&r.isValid(U)&&te(U)}),[U]);const fe=s,me=(e=>{const{classes:t}=e;return ix({root:["root"],viewTransitionContainer:["viewTransitionContainer"]},dN,t)})(fe),ge={disablePast:h,disableFuture:d,maxDate:C,minDate:N},ye={disableHighlightToday:A,readOnly:T,disabled:I,timezone:G,gridLabelId:oe,slots:M,slotProps:F},be=t.useRef(H);t.useEffect((()=>{be.current!==H&&(K===be.current&&Y(H,!0),be.current=H)}),[K,Y,H]);const ve=t.useMemo((()=>[U]),[U]);return(0,$n.jsxs)(pN,(0,oo.A)({ref:n,className:(0,vn.A)(me.root,S),ownerState:fe},W,{children:[(0,$n.jsx)(ue,(0,oo.A)({},ce,{slots:M,slotProps:F})),(0,$n.jsx)(fN,{reduceAnimations:g,className:me.viewTransitionContainer,transKey:H,ownerState:fe,children:(0,$n.jsxs)("div",{children:["year"===H&&(0,$n.jsx)(GT,(0,oo.A)({},ge,ye,{value:U,onChange:he,shouldDisableYear:v,hasFocus:le,onFocusedViewChange:e=>Y("year",e),yearsPerRow:z,referenceDate:Z})),"month"===H&&(0,$n.jsx)(FT,(0,oo.A)({},ge,ye,{hasFocus:le,className:S,value:U,onChange:de,shouldDisableMonth:b,onFocusedViewChange:e=>Y("month",e),monthsPerRow:B,referenceDate:Z})),"day"===H&&(0,$n.jsx)(TT,(0,oo.A)({},J,ge,ye,{onMonthSwitchingAnimationEnd:ae,onFocusedDayChange:ee,reduceAnimations:g,selectedDays:ve,onSelectedDaysChange:pe,shouldDisableDate:y,shouldDisableMonth:b,shouldDisableYear:v,hasFocus:le,onFocusedViewChange:e=>Y("day",e),showDaysOutsideCurrentMonth:$,fixedWeekNumber:R,dayOfWeekFormatter:D,displayWeekNumber:L,loading:O,renderLoading:P}))]})})]}))})),gN=e=>{let{view:t,onViewChange:n,views:r,focusedView:a,onFocusedViewChange:s,value:i,defaultValue:o,referenceDate:l,onChange:u,className:c,classes:d,disableFuture:h,disablePast:p,minDate:f,maxDate:m,shouldDisableDate:g,shouldDisableMonth:y,shouldDisableYear:b,reduceAnimations:v,onMonthChange:x,monthsPerRow:w,onYearChange:k,yearsPerRow:S,slots:I,slotProps:T,loading:N,renderLoading:C,disableHighlightToday:A,readOnly:E,disabled:_,showDaysOutsideCurrentMonth:$,dayOfWeekFormatter:R,sx:D,autoFocus:M,fixedWeekNumber:F,displayWeekNumber:O,timezone:P}=e;return(0,$n.jsx)(mN,{view:t,onViewChange:n,views:r.filter(kv),focusedView:a&&kv(a)?a:null,onFocusedViewChange:s,value:i,defaultValue:o,referenceDate:l,onChange:u,className:c,classes:d,disableFuture:h,disablePast:p,minDate:f,maxDate:m,shouldDisableDate:g,shouldDisableMonth:y,shouldDisableYear:b,reduceAnimations:v,onMonthChange:x,monthsPerRow:w,onYearChange:k,yearsPerRow:S,slots:I,slotProps:T,loading:N,renderLoading:C,disableHighlightToday:A,readOnly:E,disabled:_,showDaysOutsideCurrentMonth:$,dayOfWeekFormatter:R,sx:D,autoFocus:M,fixedWeekNumber:F,displayWeekNumber:O,timezone:P})},yN=t.forwardRef((function(e,n){const r=bx(),a=rx(),s=Ix(e,"MuiDesktopDatePicker"),i=(0,oo.A)({day:gN,month:gN,year:gN},s.viewRenderers),o=(0,oo.A)({},s,{viewRenderers:i,format:Sv(a,s,!1),yearsPerRow:s.yearsPerRow??4,slots:(0,oo.A)({openPickerIcon:IS,field:WI},s.slots),slotProps:(0,oo.A)({},s.slotProps,{field:e=>(0,oo.A)({},pv(s.slotProps?.field,e),zS(s),{ref:n}),toolbar:(0,oo.A)({hidden:!0},s.slotProps?.toolbar)})}),{renderPicker:l}=(e=>{let{props:n,getOpenDialogAriaText:r}=e,a=us(e,bS);const{slots:s,slotProps:i,className:o,sx:l,format:u,formatDensity:c,enableAccessibleFieldDOMStructure:d,selectedSections:h,onSelectedSectionsChange:p,timezone:f,name:m,label:g,inputRef:y,readOnly:b,disabled:v,autoFocus:x,localeText:w,reduceAnimations:k}=n,S=rx(),I=t.useRef(null),T=t.useRef(null),N=Wx(),C=i?.toolbar?.hidden??!1,{open:A,actions:E,hasUIView:_,layoutProps:$,renderCurrentView:R,shouldRestoreFocus:D,fieldProps:M}=Vk((0,oo.A)({},a,{props:n,fieldRef:T,autoFocusView:!0,additionalViewProps:{},wrapperVariant:"desktop"})),F={open:A},O=s.inputAdornment??zx,P=us(Dx({elementType:O,externalSlotProps:i?.inputAdornment,additionalProps:{position:"end"},ownerState:n}),vS),L=s.openPickerButton??Uo,z=us(Dx({elementType:L,externalSlotProps:i?.openPickerButton,additionalProps:{disabled:v||b,onClick:A?E.onClose:E.onOpen,"aria-label":r(M.value,S),edge:P.position},ownerState:n}),xS),B=s.openPickerIcon,V=Dx({elementType:B,externalSlotProps:i?.openPickerIcon,ownerState:F}),W=s.field,U=Dx({elementType:W,externalSlotProps:i?.field,additionalProps:(0,oo.A)({},M,C&&{id:N},{readOnly:b,disabled:v,className:o,sx:l,format:u,formatDensity:c,enableAccessibleFieldDOMStructure:d,selectedSections:h,onSelectedSectionsChange:p,timezone:f,label:g,name:m,autoFocus:x&&!n.open,focused:!!A||void 0},y?{inputRef:y}:{}),ownerState:n});_&&(U.InputProps=(0,oo.A)({},U.InputProps,{ref:I},!n.disableOpenPicker&&{[`${P.position}Adornment`]:(0,$n.jsx)(O,(0,oo.A)({},P,{children:(0,$n.jsx)(L,(0,oo.A)({},z,{children:(0,$n.jsx)(B,(0,oo.A)({},V))}))}))}));const j=(0,oo.A)({textField:s.textField,clearIcon:s.clearIcon,clearButton:s.clearButton},U.slots),G=s.layout??yS;let H=N;C&&(H=g?`${N}-label`:void 0);const q=(0,oo.A)({},i,{toolbar:(0,oo.A)({},i?.toolbar,{titleId:N}),popper:(0,oo.A)({"aria-labelledby":H},i?.popper)}),K=Nx(T,U.unstableFieldRef);return{renderPicker:()=>(0,$n.jsxs)(iv,{localeText:w,children:[(0,$n.jsx)(W,(0,oo.A)({},U,{slots:j,slotProps:q,unstableFieldRef:K})),(0,$n.jsx)(_k,(0,oo.A)({role:"dialog",placement:"bottom-start",anchorEl:I.current},E,{open:A,slots:s,slotProps:q,shouldRestoreFocus:D,reduceAnimations:k,children:(0,$n.jsx)(G,(0,oo.A)({},$,q?.layout,{slots:s,slotProps:q,children:R()}))}))]})}})({props:o,valueManager:Qv,valueType:"date",getOpenDialogAriaText:o.localeText?.openDatePickerDialogue??r.openDatePickerDialogue,validator:Tx});return l()}));yN.propTypes={autoFocus:hv().bool,className:hv().string,closeOnSelect:hv().bool,dayOfWeekFormatter:hv().func,defaultValue:hv().object,disabled:hv().bool,disableFuture:hv().bool,disableHighlightToday:hv().bool,disableOpenPicker:hv().bool,disablePast:hv().bool,displayWeekNumber:hv().bool,enableAccessibleFieldDOMStructure:hv().any,fixedWeekNumber:hv().number,format:hv().string,formatDensity:hv().oneOf(["dense","spacious"]),inputRef:fv,label:hv().node,loading:hv().bool,localeText:hv().object,maxDate:hv().object,minDate:hv().object,monthsPerRow:hv().oneOf([3,4]),name:hv().string,onAccept:hv().func,onChange:hv().func,onClose:hv().func,onError:hv().func,onMonthChange:hv().func,onOpen:hv().func,onSelectedSectionsChange:hv().func,onViewChange:hv().func,onYearChange:hv().func,open:hv().bool,openTo:hv().oneOf(["day","month","year"]),orientation:hv().oneOf(["landscape","portrait"]),readOnly:hv().bool,reduceAnimations:hv().bool,referenceDate:hv().object,renderLoading:hv().func,selectedSections:hv().oneOfType([hv().oneOf(["all","day","empty","hours","meridiem","minutes","month","seconds","weekDay","year"]),hv().number]),shouldDisableDate:hv().func,shouldDisableMonth:hv().func,shouldDisableYear:hv().func,showDaysOutsideCurrentMonth:hv().bool,slotProps:hv().object,slots:hv().object,sx:hv().oneOfType([hv().arrayOf(hv().oneOfType([hv().func,hv().object,hv().bool])),hv().func,hv().object]),timezone:hv().string,value:hv().object,view:hv().oneOf(["day","month","year"]),viewRenderers:hv().shape({day:hv().func,month:hv().func,year:hv().func}),views:hv().arrayOf(hv().oneOf(["day","month","year"]).isRequired),yearsPerRow:hv().oneOf([3,4])};const bN=(0,Wn.Ay)(Cl)({[`& .${wl.container}`]:{outline:0},[`& .${wl.paper}`]:{outline:0,minWidth:cS}}),vN=(0,Wn.Ay)(Ml)({"&:first-of-type":{padding:0}});function xN(e){const{children:t,onDismiss:n,open:r,slots:a,slotProps:s}=e,i=a?.dialog??bN,o=a?.mobileTransition??Bs;return(0,$n.jsx)(i,(0,oo.A)({open:r,onClose:n},s?.dialog,{TransitionComponent:o,TransitionProps:s?.mobileTransition,PaperComponent:a?.mobilePaper,PaperProps:s?.mobilePaper,children:(0,$n.jsx)(vN,{children:t})}))}const wN=["props","getOpenDialogAriaText"],kN=t.forwardRef((function(e,n){const r=bx(),a=rx(),s=Ix(e,"MuiMobileDatePicker"),i=(0,oo.A)({day:gN,month:gN,year:gN},s.viewRenderers),o=(0,oo.A)({},s,{viewRenderers:i,format:Sv(a,s,!1),slots:(0,oo.A)({field:WI},s.slots),slotProps:(0,oo.A)({},s.slotProps,{field:e=>(0,oo.A)({},pv(s.slotProps?.field,e),zS(s),{ref:n}),toolbar:(0,oo.A)({hidden:!1},s.slotProps?.toolbar)})}),{renderPicker:l}=(e=>{let{props:n,getOpenDialogAriaText:r}=e,a=us(e,wN);const{slots:s,slotProps:i,className:o,sx:l,format:u,formatDensity:c,enableAccessibleFieldDOMStructure:d,selectedSections:h,onSelectedSectionsChange:p,timezone:f,name:m,label:g,inputRef:y,readOnly:b,disabled:v,localeText:x}=n,w=rx(),k=t.useRef(null),S=Wx(),I=i?.toolbar?.hidden??!1,{open:T,actions:N,layoutProps:C,renderCurrentView:A,fieldProps:E}=Vk((0,oo.A)({},a,{props:n,fieldRef:k,autoFocusView:!0,additionalViewProps:{},wrapperVariant:"mobile"})),_=s.field,$=Dx({elementType:_,externalSlotProps:i?.field,additionalProps:(0,oo.A)({},E,I&&{id:S},!(v||b)&&{onClick:N.onOpen,onKeyDown:(R=N.onOpen,e=>{"Enter"!==e.key&&" "!==e.key||(R(e),e.preventDefault(),e.stopPropagation()),D&&D(e)})},{readOnly:b??!0,disabled:v,className:o,sx:l,format:u,formatDensity:c,enableAccessibleFieldDOMStructure:d,selectedSections:h,onSelectedSectionsChange:p,timezone:f,label:g,name:m},y?{inputRef:y}:{}),ownerState:n});var R,D;$.inputProps=(0,oo.A)({},$.inputProps,{"aria-label":r(E.value,w)});const M=(0,oo.A)({textField:s.textField},$.slots),F=s.layout??yS;let O=S;I&&(O=g?`${S}-label`:void 0);const P=(0,oo.A)({},i,{toolbar:(0,oo.A)({},i?.toolbar,{titleId:S}),mobilePaper:(0,oo.A)({"aria-labelledby":O},i?.mobilePaper)}),L=Nx(k,$.unstableFieldRef);return{renderPicker:()=>(0,$n.jsxs)(iv,{localeText:x,children:[(0,$n.jsx)(_,(0,oo.A)({},$,{slots:M,slotProps:P,unstableFieldRef:L})),(0,$n.jsx)(xN,(0,oo.A)({},N,{open:T,slots:s,slotProps:P,children:(0,$n.jsx)(F,(0,oo.A)({},C,P?.layout,{slots:s,slotProps:P,children:A()}))}))]})}})({props:o,valueManager:Qv,valueType:"date",getOpenDialogAriaText:o.localeText?.openDatePickerDialogue??r.openDatePickerDialogue,validator:Tx});return l()}));kN.propTypes={autoFocus:hv().bool,className:hv().string,closeOnSelect:hv().bool,dayOfWeekFormatter:hv().func,defaultValue:hv().object,disabled:hv().bool,disableFuture:hv().bool,disableHighlightToday:hv().bool,disableOpenPicker:hv().bool,disablePast:hv().bool,displayWeekNumber:hv().bool,enableAccessibleFieldDOMStructure:hv().any,fixedWeekNumber:hv().number,format:hv().string,formatDensity:hv().oneOf(["dense","spacious"]),inputRef:fv,label:hv().node,loading:hv().bool,localeText:hv().object,maxDate:hv().object,minDate:hv().object,monthsPerRow:hv().oneOf([3,4]),name:hv().string,onAccept:hv().func,onChange:hv().func,onClose:hv().func,onError:hv().func,onMonthChange:hv().func,onOpen:hv().func,onSelectedSectionsChange:hv().func,onViewChange:hv().func,onYearChange:hv().func,open:hv().bool,openTo:hv().oneOf(["day","month","year"]),orientation:hv().oneOf(["landscape","portrait"]),readOnly:hv().bool,reduceAnimations:hv().bool,referenceDate:hv().object,renderLoading:hv().func,selectedSections:hv().oneOfType([hv().oneOf(["all","day","empty","hours","meridiem","minutes","month","seconds","weekDay","year"]),hv().number]),shouldDisableDate:hv().func,shouldDisableMonth:hv().func,shouldDisableYear:hv().func,showDaysOutsideCurrentMonth:hv().bool,slotProps:hv().object,slots:hv().object,sx:hv().oneOfType([hv().arrayOf(hv().oneOfType([hv().func,hv().object,hv().bool])),hv().func,hv().object]),timezone:hv().string,value:hv().object,view:hv().oneOf(["day","month","year"]),viewRenderers:hv().shape({day:hv().func,month:hv().func,year:hv().func}),views:hv().arrayOf(hv().oneOf(["day","month","year"]).isRequired),yearsPerRow:hv().oneOf([3,4])};const SN=["desktopModeMediaQuery"],IN=t.forwardRef((function(e,t){const n=Hi({props:e,name:"MuiDatePicker"}),{desktopModeMediaQuery:r=xk}=n,a=us(n,SN);return cv(r,{defaultMatches:!0})?(0,$n.jsx)(yN,(0,oo.A)({ref:t},a)):(0,$n.jsx)(kN,(0,oo.A)({ref:t},a))}));var TN=n(446),NN=n.n(TN),CN=n(6865),AN=n.n(CN),EN=n(8988),_N=n.n(EN),$N=n(4443),RN=n.n($N),DN=n(1525),MN=n.n(DN),FN=n(7076),ON=n.n(FN);NN().extend(RN()),NN().extend(AN()),NN().extend(MN()),NN().extend(ON());const PN={YY:"year",YYYY:{sectionType:"year",contentType:"digit",maxLength:4},M:{sectionType:"month",contentType:"digit",maxLength:2},MM:"month",MMM:{sectionType:"month",contentType:"letter"},MMMM:{sectionType:"month",contentType:"letter"},D:{sectionType:"day",contentType:"digit",maxLength:2},DD:"day",Do:{sectionType:"day",contentType:"digit-with-letter"},d:{sectionType:"weekDay",contentType:"digit",maxLength:2},dd:{sectionType:"weekDay",contentType:"letter"},ddd:{sectionType:"weekDay",contentType:"letter"},dddd:{sectionType:"weekDay",contentType:"letter"},A:"meridiem",a:"meridiem",H:{sectionType:"hours",contentType:"digit",maxLength:2},HH:"hours",h:{sectionType:"hours",contentType:"digit",maxLength:2},hh:"hours",m:{sectionType:"minutes",contentType:"digit",maxLength:2},mm:"minutes",s:{sectionType:"seconds",contentType:"digit",maxLength:2},ss:"seconds"},LN={year:"YYYY",month:"MMMM",monthShort:"MMM",dayOfMonth:"D",dayOfMonthFull:"Do",weekday:"dddd",weekdayShort:"dd",hours24h:"HH",hours12h:"hh",meridiem:"A",minutes:"mm",seconds:"ss",fullDate:"ll",keyboardDate:"L",shortDate:"MMM D",normalDate:"D MMMM",normalDateWithWeekday:"ddd, MMM D",fullTime:"LT",fullTime12h:"hh:mm A",fullTime24h:"HH:mm",keyboardDateTime:"L LT",keyboardDateTime12h:"L hh:mm A",keyboardDateTime24h:"L HH:mm"},zN=["Missing UTC plugin","To be able to use UTC or timezones, you have to enable the `utc` plugin","Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-utc"].join("\n"),BN=["Missing timezone plugin","To be able to use timezones, you have to enable both the `utc` and the `timezone` plugin","Find more information on https://mui.com/x/react-date-pickers/timezone/#day-js-and-timezone"].join("\n");class VN{constructor(){var e=this;let{locale:t,formats:n}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};var r,a;this.isMUIAdapter=!0,this.isTimezoneCompatible=!0,this.lib="dayjs",this.dayjs=void 0,this.locale=void 0,this.formats=void 0,this.escapedCharacters={start:"[",end:"]"},this.formatTokenMap=PN,this.setLocaleToValue=e=>{const t=this.getCurrentLocaleCode();return t===e.locale()?e:e.locale(t)},this.hasUTCPlugin=()=>"undefined"!==typeof NN().utc,this.hasTimezonePlugin=()=>"undefined"!==typeof NN().tz,this.isSame=(e,t,n)=>{const r=this.setTimezone(t,this.getTimezone(e));return e.format(n)===r.format(n)},this.cleanTimezone=e=>{switch(e){case"default":return;case"system":return NN().tz.guess();default:return e}},this.createSystemDate=e=>{if(this.hasUTCPlugin()&&this.hasTimezonePlugin()){const t=NN().tz.guess();return"UTC"!==t?NN().tz(e,t):NN()(e)}return NN()(e)},this.createUTCDate=e=>{if(!this.hasUTCPlugin())throw new Error(zN);return NN().utc(e)},this.createTZDate=(e,t)=>{if(!this.hasUTCPlugin())throw new Error(zN);if(!this.hasTimezonePlugin())throw new Error(BN);const n=void 0!==e&&!e.endsWith("Z");return NN()(e).tz(this.cleanTimezone(t),n)},this.getLocaleFormats=()=>{const e=NN().Ls;let t=e[this.locale||"en"];return void 0===t&&(t=e.en),t.formats},this.adjustOffset=e=>{if(!this.hasTimezonePlugin())return e;const t=this.getTimezone(e);if("UTC"!==t){const n=e.tz(this.cleanTimezone(t),!0);if(n.$offset===(e.$offset??0))return e;e.$offset=n.$offset}return e},this.date=function(t){let n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default";return null===t?null:(n="UTC"===r?e.createUTCDate(t):"system"===r||"default"===r&&!e.hasTimezonePlugin()?e.createSystemDate(t):e.createTZDate(t,r),void 0===e.locale?n:n.locale(e.locale))},this.getInvalidDate=()=>NN()(new Date("Invalid date")),this.getTimezone=e=>{if(this.hasTimezonePlugin()){const t=e.$x?.$timezone;if(t)return t}return this.hasUTCPlugin()&&e.isUTC()?"UTC":"system"},this.setTimezone=(e,t)=>{if(this.getTimezone(e)===t)return e;if("UTC"===t){if(!this.hasUTCPlugin())throw new Error(zN);return e.utc()}if("system"===t)return e.local();if(!this.hasTimezonePlugin()){if("default"===t)return e;throw new Error(BN)}return NN().tz(e,this.cleanTimezone(t))},this.toJsDate=e=>e.toDate(),this.parse=(e,t)=>""===e?null:this.dayjs(e,t,this.locale,!0),this.getCurrentLocaleCode=()=>this.locale||"en",this.is12HourCycleInCurrentLocale=()=>/A|a/.test(this.getLocaleFormats().LT||""),this.expandFormat=e=>{const t=this.getLocaleFormats();return e.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,((e,n,r)=>{const a=r&&r.toUpperCase();return n||t[r]||t[a].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,((e,t,n)=>t||n.slice(1)))}))},this.isValid=e=>null!=e&&e.isValid(),this.format=(e,t)=>this.formatByString(e,this.formats[t]),this.formatByString=(e,t)=>this.dayjs(e).format(t),this.formatNumber=e=>e,this.isEqual=(e,t)=>null===e&&null===t||null!==e&&null!==t&&e.toDate().getTime()===t.toDate().getTime(),this.isSameYear=(e,t)=>this.isSame(e,t,"YYYY"),this.isSameMonth=(e,t)=>this.isSame(e,t,"YYYY-MM"),this.isSameDay=(e,t)=>this.isSame(e,t,"YYYY-MM-DD"),this.isSameHour=(e,t)=>e.isSame(t,"hour"),this.isAfter=(e,t)=>e>t,this.isAfterYear=(e,t)=>this.hasUTCPlugin()?!this.isSameYear(e,t)&&e.utc()>t.utc():e.isAfter(t,"year"),this.isAfterDay=(e,t)=>this.hasUTCPlugin()?!this.isSameDay(e,t)&&e.utc()>t.utc():e.isAfter(t,"day"),this.isBefore=(e,t)=>e<t,this.isBeforeYear=(e,t)=>this.hasUTCPlugin()?!this.isSameYear(e,t)&&e.utc()<t.utc():e.isBefore(t,"year"),this.isBeforeDay=(e,t)=>this.hasUTCPlugin()?!this.isSameDay(e,t)&&e.utc()<t.utc():e.isBefore(t,"day"),this.isWithinRange=(e,t)=>{let[n,r]=t;return e>=n&&e<=r},this.startOfYear=e=>this.adjustOffset(e.startOf("year")),this.startOfMonth=e=>this.adjustOffset(e.startOf("month")),this.startOfWeek=e=>this.adjustOffset(this.setLocaleToValue(e).startOf("week")),this.startOfDay=e=>this.adjustOffset(e.startOf("day")),this.endOfYear=e=>this.adjustOffset(e.endOf("year")),this.endOfMonth=e=>this.adjustOffset(e.endOf("month")),this.endOfWeek=e=>this.adjustOffset(this.setLocaleToValue(e).endOf("week")),this.endOfDay=e=>this.adjustOffset(e.endOf("day")),this.addYears=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"year"):e.add(t,"year")),this.addMonths=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"month"):e.add(t,"month")),this.addWeeks=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"week"):e.add(t,"week")),this.addDays=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"day"):e.add(t,"day")),this.addHours=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"hour"):e.add(t,"hour")),this.addMinutes=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"minute"):e.add(t,"minute")),this.addSeconds=(e,t)=>this.adjustOffset(t<0?e.subtract(Math.abs(t),"second"):e.add(t,"second")),this.getYear=e=>e.year(),this.getMonth=e=>e.month(),this.getDate=e=>e.date(),this.getHours=e=>e.hour(),this.getMinutes=e=>e.minute(),this.getSeconds=e=>e.second(),this.getMilliseconds=e=>e.millisecond(),this.setYear=(e,t)=>this.adjustOffset(e.set("year",t)),this.setMonth=(e,t)=>this.adjustOffset(e.set("month",t)),this.setDate=(e,t)=>this.adjustOffset(e.set("date",t)),this.setHours=(e,t)=>this.adjustOffset(e.set("hour",t)),this.setMinutes=(e,t)=>this.adjustOffset(e.set("minute",t)),this.setSeconds=(e,t)=>this.adjustOffset(e.set("second",t)),this.setMilliseconds=(e,t)=>this.adjustOffset(e.set("millisecond",t)),this.getDaysInMonth=e=>e.daysInMonth(),this.getWeekArray=e=>{const t=this.startOfWeek(this.startOfMonth(e)),n=this.endOfWeek(this.endOfMonth(e));let r=0,a=t;const s=[];for(;a<n;){const e=Math.floor(r/7);s[e]=s[e]||[],s[e].push(a),a=this.addDays(a,1),r+=1}return s},this.getWeekNumber=e=>e.week(),this.getYearRange=e=>{let[t,n]=e;const r=this.startOfYear(t),a=this.endOfYear(n),s=[];let i=r;for(;this.isBefore(i,a);)s.push(i),i=this.addYears(i,1);return s},this.dayjs=(r=NN(),(a=t)?function(){return r(...arguments).locale(a)}:r),this.locale=t,this.formats=(0,oo.A)({},LN,n),NN().extend(_N())}getDayOfWeek(e){return e.day()+1}}var WN=n(7029),UN=n.n(WN),jN="/index.js",GN=Object.defineProperty,HN=n(7291),qN=(e,t)=>{for(var n in t)GN(e,n,{get:t[n],enumerable:!0})};qN({},{Abs:()=>EA,Acos:()=>_A,Acosh:()=>$A,AdadeltaOptimizer:()=>xV,AdagradOptimizer:()=>wV,AdamOptimizer:()=>kV,AdamaxOptimizer:()=>SV,Add:()=>RA,AddN:()=>DA,All:()=>MA,Any:()=>FA,ArgMax:()=>OA,ArgMin:()=>PA,Asin:()=>LA,Asinh:()=>zA,Atan:()=>BA,Atan2:()=>WA,Atanh:()=>VA,AvgPool:()=>UA,AvgPool3D:()=>GA,AvgPool3DGrad:()=>HA,AvgPoolGrad:()=>jA,BackendWasm:()=>cme,BatchMatMul:()=>qA,BatchToSpaceND:()=>KA,Bincount:()=>YA,BitwiseAnd:()=>XA,BroadcastArgs:()=>ZA,BroadcastTo:()=>QA,Callback:()=>QJ,CallbackList:()=>FK,Cast:()=>JA,Ceil:()=>eE,ClipByValue:()=>tE,Complex:()=>nE,ComplexAbs:()=>rE,Concat:()=>aE,Conv2D:()=>sE,Conv2DBackpropFilter:()=>iE,Conv2DBackpropInput:()=>oE,Conv3D:()=>lE,Conv3DBackpropFilterV2:()=>uE,Conv3DBackpropInputV2:()=>cE,Cos:()=>dE,Cosh:()=>hE,CropAndResize:()=>mE,Cumprod:()=>pE,Cumsum:()=>fE,CustomCallback:()=>LK,DataStorage:()=>IC,DenseBincount:()=>gE,DepthToSpace:()=>yE,DepthwiseConv2dNative:()=>bE,DepthwiseConv2dNativeBackpropFilter:()=>vE,DepthwiseConv2dNativeBackpropInput:()=>xE,Diag:()=>wE,Dilation2D:()=>kE,Dilation2DBackpropFilter:()=>IE,Dilation2DBackpropInput:()=>SE,Draw:()=>TE,ENV:()=>NA,EarlyStopping:()=>e0,Einsum:()=>CE,Elu:()=>AE,EluGrad:()=>EE,Environment:()=>kA,Equal:()=>$E,Erf:()=>_E,Exp:()=>RE,ExpandDims:()=>DE,Expm1:()=>ME,FFT:()=>FE,Fill:()=>OE,FlipLeftRight:()=>PE,Floor:()=>LE,FloorDiv:()=>zE,FromPixels:()=>W$,FusedBatchNorm:()=>BE,FusedConv2D:()=>G$,FusedDepthwiseConv2D:()=>H$,GPGPUContext:()=>Jte,GatherNd:()=>WE,GatherV2:()=>VE,GraphModel:()=>W1,Greater:()=>UE,GreaterEqual:()=>jE,History:()=>PK,IFFT:()=>HE,Identity:()=>GE,Imag:()=>qE,InputSpec:()=>Pq,IsFinite:()=>KE,IsInf:()=>YE,IsNan:()=>XE,KernelBackend:()=>TC,LRN:()=>u_,LRNGrad:()=>c_,LayerVariable:()=>Mq,LayersModel:()=>zY,LeakyRelu:()=>QE,Less:()=>ZE,LessEqual:()=>JE,LinSpace:()=>e_,Log:()=>t_,Log1p:()=>n_,LogSoftmax:()=>o_,LogicalAnd:()=>r_,LogicalNot:()=>a_,LogicalOr:()=>s_,LogicalXor:()=>i_,LowerBound:()=>l_,MathBackendCPU:()=>o3,MathBackendWebGL:()=>kre,MatrixBandPart:()=>d_,Max:()=>h_,MaxPool:()=>f_,MaxPool3D:()=>g_,MaxPool3DGrad:()=>y_,MaxPoolGrad:()=>m_,MaxPoolWithArgmax:()=>b_,Maximum:()=>p_,Mean:()=>v_,Min:()=>x_,Minimum:()=>w_,MirrorPad:()=>k_,Mod:()=>S_,MomentumOptimizer:()=>TV,Multinomial:()=>I_,Multiply:()=>T_,Neg:()=>N_,NonMaxSuppressionV3:()=>A_,NonMaxSuppressionV4:()=>E_,NonMaxSuppressionV5:()=>__,NotEqual:()=>C_,OP_SCOPE_SUFFIX:()=>CD,OneHot:()=>R_,OnesLike:()=>$_,Optimizer:()=>vV,OptimizerConstructors:()=>_W,Pack:()=>D_,PadV2:()=>M_,Pool:()=>F_,Pow:()=>O_,Prelu:()=>P_,Prod:()=>L_,RMSPropOptimizer:()=>NV,RNN:()=>GX,RaggedGather:()=>z_,RaggedRange:()=>B_,RaggedTensorToTensor:()=>V_,Range:()=>W_,Rank:()=>qR,Real:()=>U_,RealDiv:()=>NE,Reciprocal:()=>j_,Reduction:()=>BB,Relu:()=>G_,Relu6:()=>Q_,Reshape:()=>H_,ResizeBilinear:()=>Y_,ResizeBilinearGrad:()=>X_,ResizeNearestNeighbor:()=>q_,ResizeNearestNeighborGrad:()=>K_,Reverse:()=>Z_,RotateWithOffset:()=>U$,Round:()=>J_,Rsqrt:()=>e$,SGDOptimizer:()=>IV,ScatterNd:()=>t$,SearchSorted:()=>r$,Select:()=>a$,Selu:()=>s$,Sequential:()=>UY,Sigmoid:()=>c$,Sign:()=>u$,Sin:()=>o$,Sinh:()=>l$,Slice:()=>i$,Softmax:()=>g$,Softplus:()=>d$,SpaceToBatchND:()=>f$,SparseFillEmptyRows:()=>y$,SparseReshape:()=>b$,SparseSegmentMean:()=>v$,SparseSegmentSum:()=>x$,SparseToDense:()=>w$,SplitV:()=>m$,Sqrt:()=>h$,Square:()=>S$,SquaredDifference:()=>k$,StaticRegexReplace:()=>I$,Step:()=>V$,StridedSlice:()=>T$,StringNGrams:()=>N$,StringSplit:()=>C$,StringToHashBucketFast:()=>A$,Sub:()=>E$,Sum:()=>p$,SymbolicTensor:()=>Lq,Tan:()=>_$,Tanh:()=>$$,Tensor:()=>jR,TensorBuffer:()=>VR,TensorScatterUpdate:()=>n$,Tile:()=>R$,TopK:()=>D$,Transform:()=>M$,Transpose:()=>F$,Unique:()=>O$,Unpack:()=>P$,UnsortedSegmentSum:()=>L$,UpperBound:()=>z$,Variable:()=>HR,ZerosLike:()=>B$,_FusedMatMul:()=>j$,abs:()=>oF,acos:()=>lF,acosh:()=>uF,add:()=>rF,addN:()=>cF,all:()=>dF,any:()=>hF,argMax:()=>pF,argMin:()=>fF,asin:()=>mF,asinh:()=>gF,atan:()=>yF,atan2:()=>bF,atanh:()=>vF,avgPool:()=>OF,avgPool3d:()=>PF,backend:()=>JD,backend_util:()=>FW,basicLSTMCell:()=>UF,batchNorm:()=>HF,batchNorm2d:()=>qF,batchNorm3d:()=>KF,batchNorm4d:()=>YF,batchToSpaceND:()=>jF,bincount:()=>XF,bitwiseAnd:()=>QF,booleanMaskAsync:()=>Vz,broadcastArgs:()=>ZF,broadcastTo:()=>JF,broadcast_util:()=>SO,browser:()=>QV,buffer:()=>JM,callbacks:()=>r0,cast:()=>eF,ceil:()=>eO,clipByValue:()=>nO,clone:()=>tF,complex:()=>ED,concat:()=>LF,concat1d:()=>rO,concat2d:()=>aO,concat3d:()=>sO,concat4d:()=>iO,constraints:()=>Jq,conv1d:()=>lO,conv2d:()=>oO,conv2dTranspose:()=>cO,conv3d:()=>dO,conv3dTranspose:()=>pO,copyRegisteredKernels:()=>aR,cos:()=>fO,cosh:()=>mO,cosineWindow:()=>Yz,cumprod:()=>gO,cumsum:()=>yO,customGrad:()=>TP,data:()=>H1,denseBincount:()=>bO,deprecationWarn:()=>PD,depthToSpace:()=>vO,depthwiseConv2d:()=>xO,deregisterOp:()=>o0,device_util:()=>yD,diag:()=>wO,dilation2d:()=>kO,disableDeprecationWarnings:()=>OD,dispose:()=>UD,disposeVariables:()=>LD,div:()=>sF,divNoNan:()=>_O,dot:()=>$O,dropout:()=>qz,einsum:()=>RO,elu:()=>DO,enableDebugMode:()=>FD,enableProdMode:()=>MD,enclosingPowerOfTwo:()=>Kz,engine:()=>zD,ensureShape:()=>MO,env:()=>IA,equal:()=>CO,erf:()=>FO,euclideanNorm:()=>JO,exp:()=>eP,expandDims:()=>tP,expm1:()=>nP,eye:()=>aP,fft:()=>cz,fill:()=>tO,findBackend:()=>XD,findBackendFactory:()=>QD,floor:()=>sP,floorDiv:()=>aF,forceHalfFloat:()=>Ire,fused:()=>Qz,gather:()=>iP,gatherND:()=>Hz,gather_util:()=>oW,getBackend:()=>KD,getGradient:()=>Z$,getKernel:()=>Q$,getKernelsForBackend:()=>J$,getThreadsCount:()=>Ime,gpgpu_util:()=>_te,grad:()=>xP,grads:()=>wP,greater:()=>oP,greaterEqual:()=>lP,ifft:()=>dz,imag:()=>uP,image:()=>oV,inTopKAsync:()=>Xz,initializers:()=>fK,input:()=>HY,io:()=>AV,irfft:()=>hz,isFinite:()=>cP,isInf:()=>dP,isNaN:()=>hP,keep:()=>jD,kernel_impls:()=>VU,layers:()=>$K,leakyRelu:()=>pP,less:()=>fP,lessEqual:()=>mP,linalg:()=>lV,linspace:()=>gP,loadGraphModel:()=>U1,loadGraphModelSync:()=>j1,loadLayersModel:()=>WY,localResponseNormalization:()=>yP,log:()=>bP,log1p:()=>vP,logSigmoid:()=>EP,logSoftmax:()=>$P,logSumExp:()=>RP,logicalAnd:()=>DP,logicalNot:()=>MP,logicalOr:()=>FP,logicalXor:()=>OP,losses:()=>uV,lowerBound:()=>zP,matMul:()=>zF,math:()=>YV,max:()=>jO,maxPool:()=>BP,maxPool3d:()=>VP,maxPoolWithArgmax:()=>WP,maximum:()=>UP,mean:()=>jP,memory:()=>BD,meshgrid:()=>qP,metrics:()=>_J,min:()=>GO,minimum:()=>KP,mirrorPad:()=>YP,mod:()=>XP,model:()=>jY,models:()=>HJ,moments:()=>QP,movingAverage:()=>Uz,mul:()=>iF,multiRNNCell:()=>ZP,multinomial:()=>JP,neg:()=>CP,nextFrame:()=>DW,norm:()=>ZO,notEqual:()=>eL,oneHot:()=>tL,ones:()=>HP,onesLike:()=>nL,op:()=>AD,outerProduct:()=>rL,pad:()=>aL,pad1d:()=>sL,pad2d:()=>iL,pad3d:()=>oL,pad4d:()=>lL,pool:()=>cL,pow:()=>HO,prelu:()=>dL,print:()=>nF,prod:()=>hL,profile:()=>VD,raggedGather:()=>pL,raggedRange:()=>fL,raggedTensorToTensor:()=>mL,rand:()=>gL,randomGamma:()=>OL,randomNormal:()=>PL,randomStandardNormal:()=>LL,randomUniform:()=>zL,randomUniformInt:()=>BL,range:()=>VL,ready:()=>qD,real:()=>WL,reciprocal:()=>UL,registerBackend:()=>ZD,registerCallbackConstructor:()=>qY,registerGradient:()=>tR,registerKernel:()=>eR,registerOp:()=>s0,regularizers:()=>qJ,relu:()=>jL,relu6:()=>GL,removeBackend:()=>YD,reshape:()=>FF,reverse:()=>HL,reverse1d:()=>qL,reverse2d:()=>KL,reverse3d:()=>YL,reverse4d:()=>XL,rfft:()=>fz,round:()=>QL,rsqrt:()=>ZL,scalar:()=>qO,scatterND:()=>jz,scatter_util:()=>Cz,searchSorted:()=>LP,selu:()=>JL,separableConv2d:()=>ez,sequential:()=>GY,serialization:()=>hV,setBackend:()=>HD,setPlatform:()=>eM,setThreadsCount:()=>Sme,setWasmPath:()=>vme,setWasmPaths:()=>xme,setWebGLContext:()=>K9,setdiff1dAsync:()=>tz,shared:()=>l3,sigmoid:()=>BF,sign:()=>nz,signal:()=>iV,sin:()=>rz,sinh:()=>az,slice:()=>VF,slice1d:()=>sz,slice2d:()=>iz,slice3d:()=>oz,slice4d:()=>lz,slice_util:()=>uW,softmax:()=>uz,softplus:()=>AP,spaceToBatchND:()=>uL,sparse:()=>cV,sparseToDense:()=>Gz,spectral:()=>sV,split:()=>pz,sqrt:()=>KO,square:()=>YO,squaredDifference:()=>mz,squeeze:()=>gz,stack:()=>yz,step:()=>bz,stridedSlice:()=>vz,string:()=>dV,sub:()=>_P,sum:()=>XO,sumOutType:()=>nD,tan:()=>xz,tanh:()=>WF,tensor:()=>$D,tensor1d:()=>wz,tensor2d:()=>kz,tensor3d:()=>Sz,tensor4d:()=>Iz,tensor5d:()=>Tz,tensor6d:()=>Nz,tensorScatterUpdate:()=>$z,tensor_util:()=>JR,test_util:()=>bL,tidy:()=>WD,tile:()=>rP,time:()=>GD,topk:()=>Rz,train:()=>$W,transpose:()=>Wz,truncatedNormal:()=>Dz,unique:()=>Mz,unregisterGradient:()=>rR,unregisterKernel:()=>nR,unsortedSegmentSum:()=>Fz,unstack:()=>Oz,upcastType:()=>tD,upperBound:()=>Pz,util:()=>iR,valueAndGrad:()=>kP,valueAndGrads:()=>SP,variable:()=>Lz,variableGrads:()=>IP,version:()=>Cme,version_converter:()=>G1,version_core:()=>EW,version_cpu:()=>F5,version_layers:()=>xY,version_wasm:()=>Tme,version_webgl:()=>Sre,webgl:()=>Tre,webgl_util:()=>W9,where:()=>AO,whereAsync:()=>Bz,zeros:()=>GP,zerosLike:()=>EO});var KN=Object.create,YN=Object.defineProperty,XN=Object.getOwnPropertyDescriptor,QN=Object.getOwnPropertyNames,ZN=Object.getPrototypeOf,JN=Object.prototype.hasOwnProperty,eC=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),tC=(e,t)=>{for(var n in t)YN(e,n,{get:t[n],enumerable:!0})},nC=(e,t,n)=>(n=null!=e?KN(ZN(e)):{},((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of QN(t))!JN.call(e,a)&&a!==n&&YN(e,a,{get:()=>t[a],enumerable:!(r=XN(t,a))||r.enumerable});return e})(!t&&e&&e.__esModule?n:YN(n,"default",{value:e,enumerable:!0}),e)),rC=eC(((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(Kc){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var s={},i={};function o(e,t){var n,r,a;return t?(a=0<=(e>>>=0)&&e<256)&&(r=i[e])?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(i[e]=n),n):(a=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=u(e,e<0?-1:0,!1),a&&(s[e]=n),n)}function l(e,t){if(isNaN(e))return t?b:y;if(t){if(e<0)return b;if(e>=f)return S}else{if(e<=-m)return I;if(e+1>=m)return k}return e<0?l(-e,t).neg():u(e%p|0,e/p|0,t)}function u(e,t,n){return new r(e,t,n)}r.fromInt=o,r.fromNumber=l,r.fromBits=u;var c=Math.pow;function d(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return y;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return d(e.substring(1),t,n).neg();for(var a=l(c(n,8)),s=y,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),u=parseInt(e.substring(i,i+o),n);if(o<8){var h=l(c(n,o));s=s.mul(h).add(l(u))}else s=(s=s.mul(a)).add(l(u))}return s.unsigned=t,s}function h(e,t){return"number"==typeof e?l(e,t):"string"==typeof e?d(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=d,r.fromValue=h;var p=4294967296,f=p*p,m=f/2,g=o(1<<24),y=o(0);r.ZERO=y;var b=o(0,!0);r.UZERO=b;var v=o(1);r.ONE=v;var x=o(1,!0);r.UONE=x;var w=o(-1);r.NEG_ONE=w;var k=u(-1,2147483647,!1);r.MAX_VALUE=k;var S=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=S;var I=u(0,-2147483648,!1);r.MIN_VALUE=I;var T=r.prototype;T.toInt=function(){return this.unsigned?this.low>>>0:this.low},T.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},T.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(I)){var t=l(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=l(c(e,6),this.unsigned),s=this,i="";;){var o=s.div(a),u=(s.sub(o.mul(a)).toInt()>>>0).toString(e);if((s=o).isZero())return u+i;for(;u.length<6;)u="0"+u;i=""+u+i}},T.getHighBits=function(){return this.high},T.getHighBitsUnsigned=function(){return this.high>>>0},T.getLowBits=function(){return this.low},T.getLowBitsUnsigned=function(){return this.low>>>0},T.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},T.isZero=function(){return 0===this.high&&0===this.low},T.eqz=T.isZero,T.isNegative=function(){return!this.unsigned&&this.high<0},T.isPositive=function(){return this.unsigned||this.high>=0},T.isOdd=function(){return 1===(1&this.low)},T.isEven=function(){return 0===(1&this.low)},T.equals=function(e){return a(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},T.eq=T.equals,T.notEquals=function(e){return!this.eq(e)},T.neq=T.notEquals,T.ne=T.notEquals,T.lessThan=function(e){return this.comp(e)<0},T.lt=T.lessThan,T.lessThanOrEqual=function(e){return this.comp(e)<=0},T.lte=T.lessThanOrEqual,T.le=T.lessThanOrEqual,T.greaterThan=function(e){return this.comp(e)>0},T.gt=T.greaterThan,T.greaterThanOrEqual=function(e){return this.comp(e)>=0},T.gte=T.greaterThanOrEqual,T.ge=T.greaterThanOrEqual,T.compare=function(e){if(a(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},T.comp=T.compare,T.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(v)},T.neg=T.negate,T.add=function(e){a(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,d+=(p+=r+l)>>>16,c+=(d+=n+o)>>>16,c+=t+i,u((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},T.subtract=function(e){return a(e)||(e=h(e)),this.add(e.neg())},T.sub=T.subtract,T.multiply=function(e){if(this.isZero())return y;if(a(e)||(e=h(e)),n)return u(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return y;if(this.eq(I))return e.isOdd()?I:y;if(e.eq(I))return this.isOdd()?I:y;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return l(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,r=65535&this.high,s=this.low>>>16,i=65535&this.low,o=e.high>>>16,c=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,m=0,b=0,v=0;return b+=(v+=i*p)>>>16,m+=(b+=s*p)>>>16,b&=65535,m+=(b+=i*d)>>>16,f+=(m+=r*p)>>>16,m&=65535,f+=(m+=s*d)>>>16,m&=65535,f+=(m+=i*c)>>>16,f+=t*p+r*d+s*c+i*o,u((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(m&=65535),this.unsigned)},T.mul=T.multiply,T.divide=function(e){if(a(e)||(e=h(e)),e.isZero())throw Error("division by zero");var t,r,s;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:y;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return x;s=b}else{if(this.eq(I))return e.eq(v)||e.eq(w)?I:e.eq(I)?v:(t=this.shr(1).div(e).shl(1)).eq(y)?e.isNegative()?v:w:(r=this.sub(e.mul(t)),s=t.add(r.div(e)));if(e.eq(I))return this.unsigned?b:y;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=y}for(r=this;r.gte(e);){t=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(t)/Math.LN2),o=i<=48?1:c(2,i-48),d=l(t),p=d.mul(e);p.isNegative()||p.gt(r);)p=(d=l(t-=o,this.unsigned)).mul(e);d.isZero()&&(d=v),s=s.add(d),r=r.sub(p)}return s},T.div=T.divide,T.modulo=function(e){return a(e)||(e=h(e)),n?u((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},T.mod=T.modulo,T.rem=T.modulo,T.not=function(){return u(~this.low,~this.high,this.unsigned)},T.and=function(e){return a(e)||(e=h(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},T.or=function(e){return a(e)||(e=h(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},T.xor=function(e){return a(e)||(e=h(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},T.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},T.shl=T.shiftLeft,T.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},T.shr=T.shiftRight,T.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},T.shru=T.shiftRightUnsigned,T.shr_u=T.shiftRightUnsigned,T.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},T.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},T.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},T.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},T.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}})),aC=eC((()=>{})),sC=eC((()=>{})),iC=eC(((e,t)=>{!function(e,t,n){function r(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new r(e),s=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),oC=eC(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),lC=eC(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),uC=eC(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&(s.x&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),cC=eC(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},function(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,a=0==(n=o[127&s]^=r+i)?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&(s.X&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),dC=eC(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),hC=eC((()=>{})),pC=eC(((e,t)=>{!function(e,r,a){var s,i=256,o="random",l=a.pow(i,6),u=a.pow(2,52),c=2*u,d=i-1;function h(t,n,d){var h=[],b=g(m((n=1==n?{entropy:!0}:n||{}).entropy?[t,y(r)]:null==t?function(){try{var t;return s&&(t=s.randomBytes)?t=t(i):(t=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(t)),y(t)}catch(h){var n=e.navigator,a=n&&n.plugins;return[+new Date,e,a,e.screen,y(r)]}}():t,3),h),v=new p(h),x=function(){for(var e=v.g(6),t=l,n=0;e<u;)e=(e+n)*i,t*=i,n=v.g(1);for(;e>=c;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|v.g(4)},x.quick=function(){return v.g(4)/4294967296},x.double=x,g(y(v.S),r),(n.pass||d||function(e,t,n,r){return r&&(r.S&&f(r,v),e.state=function(){return f(v,{})}),n?(a[o]=e,t):e})(x,b,"global"in n?n.global:this==a,n.state)}function p(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);a<i;)o[a]=a++;for(a=0;a<i;a++)o[a]=o[s=d&s+e[a%n]+(t=o[a])],o[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,o=r.S;e--;)t=o[a=d&a+1],n=n*i+o[d&(o[a]=o[s=d&s+t])+(o[s]=t)];return r.i=a,r.j=s,n})(i)}function f(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function m(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(m(e[n],t-1))}catch(Qc){}return r.length?r:"string"==a?e:e+"\0"}function g(e,t){for(var n,r=e+"",a=0;a<r.length;)t[d&a]=d&(n^=19*t[d&a])+r.charCodeAt(a++);return y(t)}function y(e){return String.fromCharCode.apply(0,e)}if(g(a.random(),r),"object"==typeof t&&t.exports){t.exports=h;try{s=hC()}catch(eqe){}}else"function"==typeof define&&n.amdO?define((function(){return h})):a["seed"+o]=h}("undefined"!=typeof self?self:e,[],Math)})),fC=eC(((e,t)=>{var n=iC(),r=oC(),a=lC(),s=uC(),i=cC(),o=dC(),l=pC();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l})),mC=eC((()=>{})),gC=eC((()=>{})),yC=eC((()=>{})),bC=eC((()=>{})),vC=eC((()=>{})),xC=eC((()=>{})),wC=eC(((e,t)=>{var r=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||jN,function(t){function r(){return $.buffer!=F&&j($.buffer),P}function a(){return $.buffer!=F&&j($.buffer),L}function s(){return $.buffer!=F&&j($.buffer),z}function i(){return $.buffer!=F&&j($.buffer),B}var o,l,u,c="undefined"!=typeof(t=t||{})?t:{};c.ready=new Promise((function(e,t){o=e,l=t})),"undefined"!=typeof process&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d,h,p,f=Object.assign({},c),m=[],g=(e,t)=>{throw t},y="object"==typeof window,b="function"==typeof importScripts,v="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,x=c.ENVIRONMENT_IS_PTHREAD||!1,w="";function k(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var S=gC(),I=yC();let e;w=b?I.dirname(w)+"/":"//",d=(e,t)=>(e=oe(e)?new URL(e):I.normalize(e),S.readFileSync(e,t?void 0:"utf8")),p=e=>{var t=d(e,!0);return t.buffer||(t=new Uint8Array(t)),t},h=(e,t,n)=>{e=oe(e)?new URL(e):I.normalize(e),S.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),m=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ce))throw e})),process.on("unhandledRejection",(function(e){throw e})),g=(e,t)=>{if(X())throw process.exitCode=e,t;(function(e){e instanceof ce||A("exiting due to exception: "+e)})(t),process.exit(e)},c.inspect=function(){return"[Emscripten Module object]"};try{e=bC()}catch(Ze){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Ze}n.g.Worker=e.Worker}else(y||b)&&(b?w=self.location.href:"undefined"!=typeof document&&document.currentScript&&(w=document.currentScript.src),"undefined"!=typeof e&&e&&(w=e),w=0!==w.indexOf("blob:")?w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):"",v||(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},b&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),h=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}),e=>document.title=e);v&&"undefined"==typeof performance&&(n.g.performance=vC().performance);var T=console.log.bind(console),N=console.warn.bind(console);v&&(T=e=>S.writeSync(1,e+"\n"),N=e=>S.writeSync(2,e+"\n"));var C=c.print||T,A=c.printErr||N;Object.assign(c,f),f=null,c.arguments&&(m=c.arguments),c.thisProgram&&c.thisProgram,c.quit&&(g=c.quit);var E;Atomics.load,Atomics.store,Atomics.compareExchange;c.wasmBinary&&(E=c.wasmBinary);var _=c.noExitRuntime||!0;"object"!=typeof WebAssembly&&re("no native wasm support detected");var $,R,D,M=!1;var F,O,P,L,z,B,V="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function W(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&V)return V.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,a):e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if((i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function U(e,t){return(e>>>=0)?W(r(),e,t):""}function j(e){F=e,c.HEAP8=O=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=L=new Int32Array(e),c.HEAPU8=P=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=z=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=B=new Float64Array(e)}x&&(F=c.buffer);var G=c.INITIAL_MEMORY||16777216;if(x)$=c.wasmMemory,F=c.buffer;else if(c.wasmMemory)$=c.wasmMemory;else if(!(($=new WebAssembly.Memory({initial:G/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw A("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&A("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");$&&(F=$.buffer),G=F.byteLength,j(F);var H,q=[],K=[],Y=[];function X(){return _}function Q(){!x&&ge(K)}function Z(e){q.unshift(e)}function J(e){Y.unshift(e)}var ee=0,te=null,ne=null;function re(e){c.onAbort&&c.onAbort(e),A(e="Aborted("+e+")"),M=!0,D=1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw l(t),t}var ae,se="data:application/octet-stream;base64,";function ie(e){return e.startsWith(se)}function oe(e){return e.startsWith("file://")}function le(e){try{if(e==ae&&E)return new Uint8Array(E);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(Ze){re(Ze)}}ie(ae="tfjs-backend-wasm-threaded-simd.wasm")||(ae=k(ae));var ue={};function ce(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function de(e){var t=me.pthreads[e];(function(e,t){e||re(t)})(t),me.returnWorkerToPool(t)}function he(e){var t=me.getNewWorker();if(!t)return 6;me.runningWorkers.push(t),me.pthreads[e.pthread_ptr]=t,t.pthread_ptr=e.pthread_ptr;var n={cmd:"run",start_routine:e.startRoutine,arg:e.arg,pthread_ptr:e.pthread_ptr};return t.runPthread=()=>{v&&t.ref(),t.postMessage(n,e.transferList),delete t.runPthread},t.loaded&&t.runPthread(),0}function pe(e){if(x)return Ie(1,1,e);D=e,X()||(me.terminateAllThreads(),c.onExit&&c.onExit(e),M=!0),g(e,new ce(e))}var fe=function(e,t){if(D=e,!t&&x)throw ye(e),"unwind";pe(e)};var me={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?me.initWorker():me.initMainThread()},initMainThread:function(){for(var e=8;e--;)me.allocateUnusedWorker()},initWorker:function(){_=!1},setExitStatus:function(e){D=e},terminateAllThreads:function(){for(var e of Object.values(me.pthreads))me.returnWorkerToPool(e);for(var e of me.unusedWorkers)e.terminate();me.unusedWorkers=[]},returnWorkerToPool:function(e){var t=e.pthread_ptr;delete me.pthreads[t],me.unusedWorkers.push(e),me.runningWorkers.splice(me.runningWorkers.indexOf(e),1),e.pthread_ptr=0,v&&e.unref(),je(t)},receiveObjectTransfer:function(e){},threadInitTLS:function(){me.tlsInitFunctions.forEach((e=>e()))},loadWasmModuleToWorker:function(t,n){t.onmessage=e=>{var r=e.data,a=r.cmd;if(t.pthread_ptr&&(me.currentProxiedOperationCallerThread=t.pthread_ptr),r.targetThread&&r.targetThread!=Be()){var s=me.pthreads[r.targetThread];return s?s.postMessage(r,r.transferList):A('Internal error! Worker sent a message "'+a+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(me.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===a?ke(r.queue):"spawnThread"===a?he(r):"cleanupThread"===a?de(r.thread):"killThread"===a?function(e){var t=me.pthreads[e];delete me.pthreads[e],t.terminate(),je(e),me.runningWorkers.splice(me.runningWorkers.indexOf(t),1),t.pthread_ptr=0}(r.thread):"cancelThread"===a?function(e){me.pthreads[e].postMessage({cmd:"cancel"})}(r.thread):"loaded"===a?(t.loaded=!0,v&&t.unref(),n&&n(t),t.runPthread&&t.runPthread()):"print"===a?C("Thread "+r.threadId+": "+r.text):"printErr"===a?A("Thread "+r.threadId+": "+r.text):"alert"===a?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?t.postMessage(r):"callHandler"===a?c[r.handler](...r.args):a&&A("worker sent an unknown command "+a),me.currentProxiedOperationCallerThread=void 0},t.onerror=e=>{throw A("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},v&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){})));var r=[];for(var a of["onExit","onAbort","print","printErr"])c.hasOwnProperty(a)&&r.push(a);t.postMessage({cmd:"load",handlers:r,urlOrBlob:c.mainScriptUrlOrBlob||e,wasmMemory:$,wasmModule:R})},allocateUnusedWorker:function(){var e,t=k("tfjs-backend-wasm-threaded-simd.worker.js");e=new Worker(t),me.unusedWorkers.push(e)},getNewWorker:function(){return 0==me.unusedWorkers.length&&(me.allocateUnusedWorker(),me.loadWasmModuleToWorker(me.unusedWorkers[0])),me.unusedWorkers.pop()}};function ge(e){for(;e.length>0;)e.shift()(c)}function ye(e){if(x)return Ie(2,0,e);try{fe(e)}catch(Ze){!function(e){if(e instanceof ce||"unwind"==e)return D;g(1,e)}(Ze)}}c.PThread=me,c.establishStackSpace=function(){var e=Be(),t=a()[e+52>>>2],n=a()[e+56>>>2];He(t,t-n),Ke(t)};var be=[];function ve(e,t,n,r){return x?Ie(3,1,e,t,n,r):xe(e,t,n,r)}function xe(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return A("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];if(x&&0===a.length)return ve(e,t,n,r);var s={startRoutine:n,pthread_ptr:e,arg:r,transferList:a};return x?(s.cmd="spawnThread",postMessage(s,a),0):he(s)}c.invokeEntryPoint=function(e,t){var n=function(e){var t=be[e];return t||(e>=be.length&&(be.length=e+1),be[e]=t=H.get(e)),t}(e)(t);X()?me.setExitStatus(n):Ge(n)};var we;function ke(e){Atomics.store(a(),e>>2,1),Be()&&Ue(e),Atomics.compareExchange(a(),e>>2,1,0)}function Se(e){Se.shown||(Se.shown={}),Se.shown[e]||(Se.shown[e]=1,v&&(e="warning: "+e),A(e))}function Ie(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=qe(),n=e();return Ke(t),n}((()=>{for(var a=n,s=Ye(8*a),o=s>>3,l=0;l<n;l++){var u=r[2+l];i()[o+l>>>0]=u}return We(e,a,s,t)}))}c.executeNotifiedProxyingQueue=ke,we=v?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.timeOrigin+performance.now();var Te=[];function Ne(e){try{return $.grow(e-F.byteLength+65535>>>16),j($.buffer),1}catch(Ze){}}function Ce(e){return x?Ie(4,1,e):52}function Ae(e,t,n,r,a){return x?Ie(5,1,e,t,n,r,a):70}var Ee=[null,[],[]];function _e(e,t){var n=Ee[e];0===t||10===t?((1===e?C:A)(W(n,0)),n.length=0):n.push(t)}function $e(e,t,n,a){if(x)return Ie(6,1,e,t,n,a);for(var i=0,o=0;o<n;o++){var l=s()[t>>>2],u=s()[t+4>>>2];t+=8;for(var c=0;c<u;c++)_e(e,r()[l+c>>>0]);i+=u}return s()[a>>>2]=i,0}function Re(e){return c["_"+e]}function De(e,t){($.buffer!=F&&j($.buffer),O).set(e,t>>>0)}function Me(e,t,n,a,s){var i={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);(function(e,t,n){(function(e,t,n,r){if(!(r>0))return 0;for(var a=n>>>=0,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),o<=127){if(n>=s)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=s)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=s)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0})(e,r(),t,n)})(e,t=Ye(n),n)}return t},array:e=>{var t=Ye(e.length);return De(e,t),t}};var o=Re(e),l=[],u=0;if(a)for(var c=0;c<a.length;c++){var d=i[n[c]];d?(0===u&&(u=qe()),l[c]=d(a[c])):l[c]=a[c]}var h,p=o.apply(null,l);return h=p,0!==u&&Ke(u),p=function(e){return"string"===t?U(e):"boolean"===t?!!e:e}(h),p}me.init();var Fe,Oe,Pe,Le=[null,pe,ye,ve,Ce,Ae,$e],ze={__emscripten_init_main_thread_js:function(e){Ve(e,!b,1,!y),me.threadInitTLS()},__emscripten_thread_cleanup:function(e){x?postMessage({cmd:"cleanupThread",thread:e}):de(e)},__pthread_create_js:xe,_emscripten_default_pthread_stack_size:function(){return 65536},_emscripten_get_now_is_monotonic:function(){return true},_emscripten_notify_task_queue:function(e,t,n,r){if(e==t)setTimeout((()=>ke(r)));else if(x)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{var a=me.pthreads[e];if(!a)return;a.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},_emscripten_set_offscreencanvas_size:function(e,t,n){return-1},abort:function(){re("")},emscripten_check_blocking_allowed:function(){v||b||Se("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function(){return Date.now()},emscripten_get_heap_max:function(){return 4294901760},emscripten_get_now:we,emscripten_memcpy_big:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_num_logical_cores:function(){return v?xC().cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(e,t,n){Te.length=t;for(var r=n>>3,a=0;a<t;a++)Te[a]=i()[r+a>>>0];return(e<0?ue[-e-1]:Le[e]).apply(null,Te)},emscripten_resize_heap:function(e){var t=r().length;if((e>>>=0)<=t)return!1;var n,a,s=4294901760;if(e>s)return!1;for(var i=1;i<=4;i*=2){var o=t*(1+.2/i);if(o=Math.min(o,e+100663296),Ne(Math.min(s,(n=Math.max(e,o))+((a=65536)-n%a)%a)))return!0}return!1},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},exit:fe,fd_close:Ce,fd_seek:Ae,fd_write:$e,memory:$||c.wasmMemory},Be=(function(){var e={env:ze,wasi_snapshot_preview1:ze};function t(e,t){var n=e.exports;if(c.asm=n,function(e){me.tlsInitFunctions.push(e)}(c.asm._emscripten_tls_init),H=c.asm.__indirect_function_table,function(e){K.unshift(e)}(c.asm.__wasm_call_ctors),R=t,!x){var r=me.unusedWorkers.length;me.unusedWorkers.forEach((function(e){me.loadWasmModuleToWorker(e,(function(){--r||function(){if(ee--,c.monitorRunDependencies&&c.monitorRunDependencies(ee),0==ee&&(null!==te&&(clearInterval(te),te=null),ne)){var e=ne;ne=null,e()}}()}))}))}}function n(e){t(e.instance,e.module)}function r(t){return function(){if(!E&&(y||b)){if("function"==typeof fetch&&!oe(ae))return fetch(ae,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+ae+"'";return e.arrayBuffer()})).catch((function(){return le(ae)}));if(h)return new Promise((function(e,t){h(ae,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return le(ae)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){A("failed to asynchronously prepare wasm: "+e),re(e)}))}if(x||(ee++,c.monitorRunDependencies&&c.monitorRunDependencies(ee)),c.instantiateWasm)try{return c.instantiateWasm(e,t)}catch(a){A("Module.instantiateWasm callback failed with error: "+a),l(a)}(E||"function"!=typeof WebAssembly.instantiateStreaming||ie(ae)||oe(ae)||v||"function"!=typeof fetch?r(n):fetch(ae,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return A("wasm streaming compile failed: "+e),A("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(l)}(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Acos=function(){return(c._Acos=c.asm.Acos).apply(null,arguments)},c._Acosh=function(){return(c._Acosh=c.asm.Acosh).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._ArgMin=function(){return(c._ArgMin=c.asm.ArgMin).apply(null,arguments)},c._Asin=function(){return(c._Asin=c.asm.Asin).apply(null,arguments)},c._Asinh=function(){return(c._Asinh=c.asm.Asinh).apply(null,arguments)},c._Atan=function(){return(c._Atan=c.asm.Atan).apply(null,arguments)},c._Atan2=function(){return(c._Atan2=c.asm.Atan2).apply(null,arguments)},c._Atanh=function(){return(c._Atanh=c.asm.Atanh).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._AvgPool3D=function(){return(c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},c._AvgPool3DGrad=function(){return(c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},c._AvgPoolGrad=function(){return(c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Bincount=function(){return(c._Bincount=c.asm.Bincount).apply(null,arguments)},c._BitwiseAnd=function(){return(c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Conv3D=function(){return(c._Conv3D=c.asm.Conv3D).apply(null,arguments)},c._Conv3DBackpropFilterV2=function(){return(c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},c._Conv3DBackpropInputV2=function(){return(c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DenseBincount=function(){return(c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Diag=function(){return(c._Diag=c.asm.Diag).apply(null,arguments)},c._Dilation2D=function(){return(c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},c._Dilation2DBackpropFilter=function(){return(c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},c._Dilation2DBackpropInput=function(){return(c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._EluGrad=function(){return(c._EluGrad=c.asm.EluGrad).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Erf=function(){return(c._Erf=c.asm.Erf).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._Expm1=function(){return(c._Expm1=c.asm.Expm1).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._IsFinite=function(){return(c._IsFinite=c.asm.IsFinite).apply(null,arguments)},c._IsInf=function(){return(c._IsInf=c.asm.IsInf).apply(null,arguments)},c._IsNan=function(){return(c._IsNan=c.asm.IsNan).apply(null,arguments)},c._LRN=function(){return(c._LRN=c.asm.LRN).apply(null,arguments)},c._LRNGrad=function(){return(c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._LinSpace=function(){return(c._LinSpace=c.asm.LinSpace).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._Log1p=function(){return(c._Log1p=c.asm.Log1p).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._MaxPool3D=function(){return(c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},c._MaxPool3DGrad=function(){return(c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},c._MaxPoolGrad=function(){return(c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},c._MaxPoolWithArgmax=function(){return(c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Mod=function(){return(c._Mod=c.asm.Mod).apply(null,arguments)},c._Multinomial=function(){return(c._Multinomial=c.asm.Multinomial).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Reciprocal=function(){return(c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeBilinearGrad=function(){return(c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._ResizeNearestNeighborGrad=function(){return(c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SearchSorted=function(){return(c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Selu=function(){return(c._Selu=c.asm.Selu).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sign=function(){return(c._Sign=c.asm.Sign).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Sinh=function(){return(c._Sinh=c.asm.Sinh).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._Softplus=function(){return(c._Softplus=c.asm.Softplus).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._SparseToDense=function(){return(c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._TensorScatterUpdate=function(){return(c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)},c._pthread_self=function(){return(Be=c._pthread_self=c.asm.pthread_self).apply(null,arguments)}),Ve=(c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)},c.__emscripten_thread_init=function(){return(Ve=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)}),We=(c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)},c._emscripten_run_in_main_runtime_thread_js=function(){return(We=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),Ue=(c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},c.__emscripten_proxy_execute_task_queue=function(){return(Ue=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),je=c.__emscripten_thread_free_data=function(){return(je=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},Ge=c.__emscripten_thread_exit=function(){return(Ge=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},He=c._emscripten_stack_set_limits=function(){return(He=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},qe=c.stackSave=function(){return(qe=c.stackSave=c.asm.stackSave).apply(null,arguments)},Ke=c.stackRestore=function(){return(Ke=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},Ye=c.stackAlloc=function(){return(Ye=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)};function Xe(e){if(e=e||m,!(ee>0)){if(x)return o(c),Q(),void startWorker(c);(function(){if(c.preRun)for("function"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)Z(c.preRun.shift());ge(q)})(),ee>0||(c.setStatus?(c.setStatus("Running..."),setTimeout((function(){setTimeout((function(){c.setStatus("")}),1),t()}),1)):t())}function t(){Fe||(Fe=!0,c.calledRun=!0,!M&&(Q(),o(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),function(){if(!x){if(c.postRun)for("function"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;)J(c.postRun.shift());ge(Y)}}()))}}if(c.keepRuntimeAlive=X,c.wasmMemory=$,c.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?Re(e):function(){return Me(e,t,n,arguments)}},c.ExitStatus=ce,c.PThread=me,ne=function e(){Fe||Xe(),Fe||(ne=e)},c.preInit)for("function"==typeof c.preInit&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();if(Xe(),u&&(Oe={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!u.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!u.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)Pe=WasmBackendModule;else{if("undefined"==typeof t)throw new Error("Could not find wasm module in post.js");Pe=t}if(Oe){var Qe=Pe._dispose;Pe._dispose=function(){Qe(),Oe.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Oe.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&n.amdO?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=r)})),kC=eC(((e,t)=>{t.exports.wasmWorkerContents='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'})),SC=eC(((e,t)=>{var r=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||jN,function(t){var n,r,a,s="undefined"!=typeof(t=t||{})?t:{};s.ready=new Promise((function(e,t){n=e,r=t})),"undefined"!=typeof process&&process.listeners&&(a={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i,o,l,u=Object.assign({},s),c=[],d="object"==typeof window,h="function"==typeof importScripts,p="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,f="";if(p){var m=gC(),g=yC();f=h?g.dirname(f)+"/":"//",i=(e,t)=>(e=U(e)?new URL(e):g.normalize(e),m.readFileSync(e,t?void 0:"utf8")),l=e=>{var t=i(e,!0);return t.buffer||(t=new Uint8Array(t)),t},o=(e,t,n)=>{e=U(e)?new URL(e):g.normalize(e),m.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),c=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof G))throw e})),process.on("unhandledRejection",(function(e){throw e})),s.inspect=function(){return"[Emscripten Module object]"}}else(d||h)&&(h?f=self.location.href:"undefined"!=typeof document&&document.currentScript&&(f=document.currentScript.src),e&&(f=e),f=0!==f.indexOf("blob:")?f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},h&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)},e=>document.title=e);var y=s.print||console.log.bind(console),b=s.printErr||console.warn.bind(console);Object.assign(s,u),u=null,s.arguments&&(c=s.arguments),s.thisProgram&&s.thisProgram,s.quit&&s.quit;var v;s.wasmBinary&&(v=s.wasmBinary);var x=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&z("no native wasm support detected");var w,k=!1;var S,I,T,N,C="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function A(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&C)return C.decode(e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if((i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++])<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function E(e,t){return(e>>>=0)?A(T,e,t):""}function _(e){S=e,s.HEAP8=I=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=new Int32Array(e),s.HEAPU8=T=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=N=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=new Float64Array(e)}s.INITIAL_MEMORY;var $=[],R=[],D=[];function M(e){$.unshift(e)}function F(e){D.unshift(e)}var O=0,P=null,L=null;function z(e){s.onAbort&&s.onAbort(e),b(e="Aborted("+e+")"),k=!0,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw r(t),t}var B,V="data:application/octet-stream;base64,";function W(e){return e.startsWith(V)}function U(e){return e.startsWith("file://")}function j(e){try{if(e==B&&v)return new Uint8Array(v);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(t){z(t)}}function G(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function H(e){for(;e.length>0;)e.shift()(s)}function q(e){try{return w.grow(e-S.byteLength+65535>>>16),_(w.buffer),1}catch(t){}}W(B="tfjs-backend-wasm.wasm")||(B=function(e){return s.locateFile?s.locateFile(e,f):f+e}(B));var K=[null,[],[]];function Y(e,t){var n=K[e];0===t||10===t?((1===e?y:b)(A(n,0)),n.length=0):n.push(t)}function X(e){return s["_"+e]}function Q(e,t,n,r,a){var s={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);(function(e,t,n){(function(e,t,n,r){if(!(r>0))return 0;for(var a=n>>>=0,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),o<=127){if(n>=s)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=s)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=s)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0})(e,T,t,n)})(e,t=ae(n),n)}return t},array:e=>{var t=ae(e.length);return function(e,t){I.set(e,t>>>0)}(e,t),t}};var i=X(e),o=[],l=0;if(r)for(var u=0;u<r.length;u++){var c=s[n[u]];c?(0===l&&(l=ne()),o[u]=c(r[u])):o[u]=r[u]}var d,h=i.apply(null,o);return d=h,0!==l&&re(l),h=function(e){return"string"===t?E(e):"boolean"===t?!!e:e}(d),h}var Z,J,ee,te={abort:function(){z("")},emscripten_get_heap_max:function(){return 4294901760},emscripten_memcpy_big:function(e,t,n){T.copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_resize_heap:function(e){var t,n,r=T.length,a=4294901760;if((e>>>=0)>a)return!1;for(var s=1;s<=4;s*=2){var i=r*(1+.2/s);if(i=Math.min(i,e+100663296),q(Math.min(a,(t=Math.max(e,i))+((n=65536)-t%n)%n)))return!0}return!1},fd_close:function(e){return 52},fd_seek:function(e,t,n,r,a){return 70},fd_write:function(e,t,n,r){for(var a=0,s=0;s<n;s++){var i=N[t>>>2],o=N[t+4>>>2];t+=8;for(var l=0;l<o;l++)Y(e,T[i+l>>>0]);a+=o}return N[r>>>2]=a,0}},ne=(function(){var e={env:te,wasi_snapshot_preview1:te};function t(e,t){var n=e.exports;s.asm=n,_((w=s.asm.memory).buffer),s.asm.__indirect_function_table,function(e){R.unshift(e)}(s.asm.__wasm_call_ctors),function(){if(O--,s.monitorRunDependencies&&s.monitorRunDependencies(O),0==O&&(null!==P&&(clearInterval(P),P=null),L)){var e=L;L=null,e()}}()}function n(e){t(e.instance)}function a(t){return function(){if(!v&&(d||h)){if("function"==typeof fetch&&!U(B))return fetch(B,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+B+"'";return e.arrayBuffer()})).catch((function(){return j(B)}));if(o)return new Promise((function(e,t){o(B,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return j(B)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){b("failed to asynchronously prepare wasm: "+e),z(e)}))}if(O++,s.monitorRunDependencies&&s.monitorRunDependencies(O),s.instantiateWasm)try{return s.instantiateWasm(e,t)}catch(i){b("Module.instantiateWasm callback failed with error: "+i),r(i)}(v||"function"!=typeof WebAssembly.instantiateStreaming||W(B)||U(B)||p||"function"!=typeof fetch?a(n):fetch(B,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return b("wasm streaming compile failed: "+e),b("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(r)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)},s.stackSave=function(){return(ne=s.stackSave=s.asm.stackSave).apply(null,arguments)}),re=s.stackRestore=function(){return(re=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},ae=s.stackAlloc=function(){return(ae=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)};function se(e){function t(){Z||(Z=!0,s.calledRun=!0,!k&&(H(R),n(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),function(){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;)F(s.postRun.shift());H(D)}()))}e=e||c,O>0||(function(){if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)M(s.preRun.shift());H($)}(),O>0)||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),t()}),1)):t())}if(s.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?X(e):function(){return Q(e,t,n,arguments)}},L=function e(){Z||se(),Z||(L=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();if(se(),a&&(J={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!a.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!a.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof t)ee=t;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");ee=WasmBackendModuleThreadedSimd}if(J){var ie=ee._dispose;ee._dispose=function(){ie(),J.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),J.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&n.amdO?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModule=r)})),IC=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},TC=class{refCount(e){return NC("refCount")}incRef(e){return NC("incRef")}timerAvailable(){return!0}time(e){return NC("time")}read(e){return NC("read")}readSync(e){return NC("readSync")}readToGPU(e,t){return NC("readToGPU")}numDataIds(){return NC("numDataIds")}disposeData(e,t){return NC("disposeData")}write(e,t,n){return NC("write")}move(e,t,n,r,a){return NC("move")}createTensorFromGPUData(e,t,n){return NC("createTensorFromGPUData")}memory(){return NC("memory")}floatPrecision(){return NC("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return NC("dispose")}};function NC(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function CC(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,$C(e,t,n)}function AC(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,$C(e,n,r),$C(t,n,r)}function EC(e,t,n){return Math.max(e,Math.min(t,n))}function _C(e){return e%2===0?e:e+1}function $C(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function RC(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function DC(e,t){let n=Math.random();return t*n+(1-n)*e}function MC(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function FC(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function OC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";FC(VC(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function PC(e){FC(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function LC(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function zC(e){return 0===e.length}function BC(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function VC(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function WC(e){return e%1===0}function UC(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function jC(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function GC(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return CC(t),t}function HC(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function qC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((a,s)=>{let i=0,o=()=>{if(e())return void a();i++;let l=t(i);null!=n&&i>=n?s():null!=r?r(o,l):setTimeout(o,l)};o()}))}function KC(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function YC(e,t){let n=t.length;return FC((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),FC(e.every((e=>WC(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function XC(e,t){let n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:YC(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function QC(e,t){return ZC(e,t)}function ZC(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function JC(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function eA(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function tA(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function nA(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function rA(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function aA(e){return"string"==typeof e||e instanceof String}function sA(e){return"boolean"==typeof e}function iA(e){return"number"==typeof e}function oA(e){return Array.isArray(e)?oA(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":iA(e)?"float32":aA(e)?"string":sA(e)?"bool":"float32"}function lA(e){return!!(e&&e.constructor&&e.call&&e.apply)}function uA(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function cA(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function dA(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=new Array;if(1===t.length){let s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{let s=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=dA(e+t*o,i,n,r)}return a}function hA(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];let r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return dA(0,e,t,n)}function pA(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function fA(e,t){let n=mA(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function mA(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function gA(e,t){let n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return hA(e,new Float32Array(n));if("int32"===t)return hA(e,new Int32Array(n));if("bool"===t)return hA(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function yA(e){e.forEach((t=>{FC(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function bA(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function vA(e,t,n){if(0===t)return[];if(1===t)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function xA(e){return e&&e.then&&"function"==typeof e.then}var wA="tfjsflags",kA=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=SA,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(IA().getBool("IS_TEST")||IA().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];IA().getBool("IS_TEST")||IA().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(xA(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"==typeof this.global||"undefined"==typeof this.global.location||"undefined"==typeof this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);wA in e&&e[wA].split(",").forEach((e=>{let[t,n]=e.split(":");this.urlFlags[t]=function(e,t){let n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}};function SA(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),a=1;a<n;a++)r[a-1]=arguments[a];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function IA(){return NA}var TA,NA=null;function CA(){if(null==TA){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}TA=e}return TA}function AA(e,t){let n=function(){let e=CA();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var EA="Abs",_A="Acos",$A="Acosh",RA="Add",DA="AddN",MA="All",FA="Any",OA="ArgMax",PA="ArgMin",LA="Asin",zA="Asinh",BA="Atan",VA="Atanh",WA="Atan2",UA="AvgPool",jA="AvgPoolGrad",GA="AvgPool3D",HA="AvgPool3DGrad",qA="BatchMatMul",KA="BatchToSpaceND",YA="Bincount",XA="BitwiseAnd",QA="BroadcastTo",ZA="BroadcastArgs",JA="Cast",eE="Ceil",tE="ClipByValue",nE="Complex",rE="ComplexAbs",aE="Concat",sE="Conv2D",iE="Conv2DBackpropFilter",oE="Conv2DBackpropInput",lE="Conv3D",uE="Conv3DBackpropFilterV2",cE="Conv3DBackpropInputV2",dE="Cos",hE="Cosh",pE="Cumprod",fE="Cumsum",mE="CropAndResize",gE="DenseBincount",yE="DepthToSpace",bE="DepthwiseConv2dNative",vE="DepthwiseConv2dNativeBackpropFilter",xE="DepthwiseConv2dNativeBackpropInput",wE="Diag",kE="Dilation2D",SE="Dilation2DBackpropInput",IE="Dilation2DBackpropFilter",TE="Draw",NE="RealDiv",CE="Einsum",AE="Elu",EE="EluGrad",_E="Erf",$E="Equal",RE="Exp",DE="ExpandDims",ME="Expm1",FE="FFT",OE="Fill",PE="FlipLeftRight",LE="Floor",zE="FloorDiv",BE="FusedBatchNorm",VE="GatherV2",WE="GatherNd",UE="Greater",jE="GreaterEqual",GE="Identity",HE="IFFT",qE="Imag",KE="IsFinite",YE="IsInf",XE="IsNan",QE="LeakyRelu",ZE="Less",JE="LessEqual",e_="LinSpace",t_="Log",n_="Log1p",r_="LogicalAnd",a_="LogicalNot",s_="LogicalOr",i_="LogicalXor",o_="LogSoftmax",l_="LowerBound",u_="LRN",c_="LRNGrad",d_="MatrixBandPart",h_="Max",p_="Maximum",f_="MaxPool",m_="MaxPoolGrad",g_="MaxPool3D",y_="MaxPool3DGrad",b_="MaxPoolWithArgmax",v_="Mean",x_="Min",w_="Minimum",k_="MirrorPad",S_="Mod",I_="Multinomial",T_="Multiply",N_="Neg",C_="NotEqual",A_="NonMaxSuppressionV3",E_="NonMaxSuppressionV4",__="NonMaxSuppressionV5",$_="OnesLike",R_="OneHot",D_="Pack",M_="PadV2",F_="Pool",O_="Pow",P_="Prelu",L_="Prod",z_="RaggedGather",B_="RaggedRange",V_="RaggedTensorToTensor",W_="Range",U_="Real",j_="Reciprocal",G_="Relu",H_="Reshape",q_="ResizeNearestNeighbor",K_="ResizeNearestNeighborGrad",Y_="ResizeBilinear",X_="ResizeBilinearGrad",Q_="Relu6",Z_="Reverse",J_="Round",e$="Rsqrt",t$="ScatterNd",n$="TensorScatterUpdate",r$="SearchSorted",a$="Select",s$="Selu",i$="Slice",o$="Sin",l$="Sinh",u$="Sign",c$="Sigmoid",d$="Softplus",h$="Sqrt",p$="Sum",f$="SpaceToBatchND",m$="SplitV",g$="Softmax",y$="SparseFillEmptyRows",b$="SparseReshape",v$="SparseSegmentMean",x$="SparseSegmentSum",w$="SparseToDense",k$="SquaredDifference",S$="Square",I$="StaticRegexReplace",T$="StridedSlice",N$="StringNGrams",C$="StringSplit",A$="StringToHashBucketFast",E$="Sub",_$="Tan",$$="Tanh",R$="Tile",D$="TopK",M$="Transform",F$="Transpose",O$="Unique",P$="Unpack",L$="UnsortedSegmentSum",z$="UpperBound",B$="ZerosLike",V$="Step",W$="FromPixels",U$="RotateWithOffset",j$="_FusedMatMul",G$="FusedConv2D",H$="FusedDepthwiseConv2D";function q$(){IA().getBool("IS_TEST")||IA().getBool("PROD")||console.warn(...arguments)}function K$(){IA().getBool("IS_TEST")||IA().getBool("PROD")||console.log(...arguments)}var Y$=AA("kernelRegistry",(()=>new Map)),X$=AA("gradRegistry",(()=>new Map));function Q$(e,t){let n=sR(e,t);return Y$.get(n)}function Z$(e){return X$.get(e)}function J$(e){let t=Y$.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function eR(e){let{kernelName:t,backendName:n}=e,r=sR(t,n);Y$.has(r)&&q$(`The kernel '${t}' for backend '${n}' is already registered`),Y$.set(r,e)}function tR(e){let{kernelName:t}=e;X$.has(t)&&IA().getBool("DEBUG")&&q$(`Overriding the gradient for '${t}'`),X$.set(t,e)}function nR(e,t){let n=sR(e,t);if(!Y$.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Y$.delete(n)}function rR(e){if(!X$.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);X$.delete(e)}function aR(e,t){J$(e).forEach((e=>{eR(Object.assign({},e,{backendName:t}))}))}function sR(e,t){return`${t}_${e}`}var iR={};function oR(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}tC(iR,{arraysEqual:()=>VC,arraysEqualWithNull:()=>BC,assert:()=>FC,assertNonNegativeIntegerDimensions:()=>yA,assertNonNull:()=>PC,assertShapesMatch:()=>OC,bytesFromStringArray:()=>rA,bytesPerElement:()=>nA,checkConversionForErrors:()=>JC,clamp:()=>EC,computeStrides:()=>cA,convertBackendValuesAndArrayBuffer:()=>pA,createScalarValue:()=>kR,createShuffledIndices:()=>GC,decodeString:()=>CR,distSquared:()=>MC,encodeString:()=>NR,fetch:()=>TR,fingerPrint64:()=>wR,flatten:()=>ER,getArrayFromDType:()=>ZC,getTypedArrayFromDType:()=>QC,hasEncodingLoss:()=>tA,hexToLong:()=>cR,indexToLoc:()=>vA,inferDtype:()=>oA,inferFromImplicitShape:()=>KC,isBoolean:()=>sA,isFunction:()=>lA,isInt:()=>WC,isNumber:()=>iA,isPromise:()=>xA,isScalarShape:()=>zC,isString:()=>aA,isTypedArray:()=>AR,isValidDtype:()=>eA,locToIndex:()=>bA,makeOnesTypedArray:()=>fA,makeZerosNestedTypedArray:()=>gA,makeZerosTypedArray:()=>mA,nearestDivisor:()=>uA,nearestLargerEven:()=>_C,now:()=>IR,parseAxisParam:()=>YC,randUniform:()=>DC,repeatedTry:()=>qC,rightPad:()=>HC,shuffle:()=>CC,shuffleCombo:()=>AC,sizeFromShape:()=>LC,sizeToSquarishShape:()=>jC,squeezeShape:()=>XC,sum:()=>RC,swap:()=>$C,tanh:()=>UC,toNestedArray:()=>hA,toTypedArray:()=>SR});var lR=nC(rC()),uR=lR.default||lR;function cR(e){return uR.fromString(e,!0,16)}var dR=cR("c3a5c85c97cb3127"),hR=cR("b492b66fbe98f273"),pR=cR("9ae16a3b2f90404f");function fR(e){return e.xor(e.shru(47))}function mR(e,t,n){let r=e.slice(t,t+n);return uR.fromBytes(Array.from(r),!0,!0)}function gR(e,t){return mR(e,t,8)}function yR(e,t){return mR(e,t,4)}function bR(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function vR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:cR("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function xR(e,t,n,r){return function(e,t,n,r,a,s){a=a.add(e),s=bR(s.add(a).add(r),21);let i=a;return a=(a=a.add(t)).add(n),s=s.add(bR(a,44)),[a.add(r),s.add(i)]}(gR(e,t),gR(e,t+8),gR(e,t+16),gR(e,t+24),n,r)}function wR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=uR.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){let n=pR.add(2*t),r=gR(e,0).add(pR),a=gR(e,t-8);return vR(bR(a,37).mul(n).add(r),bR(r,25).add(a).mul(n),n)}if(t>=4){let n=pR.add(2*t);return vR(yR(e,0).shl(3).add(t),yR(e,t-4),n)}if(t>0){let n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return fR(pR.mul(n).xor(dR.mul(r))).mul(pR)}return pR}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=pR.add(2*t),r=gR(e,0).mul(hR),a=gR(e,8),s=gR(e,t-8).mul(n),i=gR(e,t-16).mul(pR);return vR(bR(r.add(a),43).add(bR(s,30)).add(i),r.add(bR(a.add(pR),18)).add(s),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length,n=pR.add(2*t),r=gR(e,0).mul(pR),a=gR(e,8),s=gR(e,t-8).mul(n),i=gR(e,t-16).mul(pR),o=bR(r.add(a),43).add(bR(s,30)).add(i),l=vR(o,r.add(bR(a.add(pR),18)).add(s),n),u=gR(e,16).mul(n),c=gR(e,24),d=o.add(gR(e,t-32)).mul(n),h=l.add(gR(e,t-24)).mul(n);return vR(bR(u.add(c),43).add(bR(d,30)).add(h),u.add(bR(c.add(r),18)).add(d),n)}(e,t);let r=n,a=n.mul(hR).add(113),s=fR(a.mul(pR).add(113)).mul(pR),i=[uR.UZERO,uR.UZERO],o=[uR.UZERO,uR.UZERO];r=r.mul(pR).add(gR(e,0));let l=0,u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=bR(r.add(a).add(i[0]).add(gR(e,l+8)),37).mul(hR),a=bR(a.add(i[1]).add(gR(e,l+48)),42).mul(hR),r=r.xor(o[1]),a=a.add(i[0]).add(gR(e,l+40)),s=bR(s.add(o[0]),33).mul(hR),i=xR(e,l,i[1].mul(hR),r.add(o[0])),o=xR(e,l+32,s.add(o[1]),a.add(gR(e,l+16))),[s,r]=[r,s],l+=64}while(l!==u);let d=hR.add(s.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=bR(r.add(a).add(i[0]).add(gR(e,l+8)),37).mul(d),a=bR(a.add(i[1]).add(gR(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(gR(e,l+40))),s=bR(s.add(o[0]),33).mul(d),i=xR(e,l,i[1].mul(d),r.add(o[0])),o=xR(e,l+32,s.add(o[1]),a.add(gR(e,l+16))),[s,r]=[r,s],vR(vR(i[0],o[0],d).add(fR(a).mul(dR)).add(s),vR(i[1],o[1],d).add(r),d)}function kR(e,t){return"string"===t?NR(e):SR([e],t)}function SR(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ER(e)),IA().getBool("DEBUG")&&JC(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function IR(){return IA().platform.now()}function TR(e,t){return IA().platform.fetch(e,t)}function NR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",IA().platform.encode(e,t)}function CR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",IA().platform.decode(e,t)}function AR(e){return null!=IA().platform.isTypedArray?IA().platform.isTypedArray(e):oR(e)}function ER(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||xA(e)||null==e||AR(e)&&n)t.push(e);else if(Array.isArray(e)||AR(e))for(let r=0;r<e.length;++r)ER(e[r],t,n);else{let r=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)ER(e[a],t,n)}return t}var _R=class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new RR)}profileKernel(e,t,n){let r,a,s=()=>{r=n()},i=IR();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let e of r)e.dataSync();a=Promise.resolve({kernelMs:IR()-i})}if(IA().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let t=r[o];t.data().then((n=>{$R(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}};function $R(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){let t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}var RR=class{logKernelProfile(e,t,n,r,a,s){let i="number"==typeof r?HC(`${r}ms`,9):r.error,o=HC(e,25),l=t.rank,u=t.size,c=HC(t.shape.toString(),14),d="";for(let h in a){let e=a[h];if(null!=e){let n=e.shape||t.shape,r=n.length;d+=`${h}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};var DR=20,MR=3,FR=7;function OR(e,t,n,r){let a=cA(t),s=function(e,t,n,r){let a=LC(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l="complex64"===n?BR(e):e;if(o>1)for(let u=0;u<a/s;u++){let e=u*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],PR(l[e+t],0,n).length)}return i}(e,t,n,a),i=t.length,o=zR(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function PR(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(FR))} + ${parseFloat(e[1].toFixed(FR))}j`:aA(e)?`'${e}'`:"bool"===n?LR(e):parseFloat(e.toFixed(FR)).toString(),HC(r,t)}function LR(e){return 0===e?"false":"true"}function zR(e,t,n,r,a){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[PR(BR(e)[0],0,n)]}return"bool"===n?[LR(e[0])]:[e[0].toString()]}if(1===l){if(o>DR){let t=MR*i,r=Array.from(e.slice(0,t)),s=Array.from(e.slice((o-MR)*i,o*i));return"complex64"===n&&(r=BR(r),s=BR(s)),["["+r.map(((e,t)=>PR(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>PR(e,a[o-MR+t],n))).join(", ")+"]"]}return["["+("complex64"===n?BR(e):Array.from(e)).map(((e,t)=>PR(e,a[t],n))).join(", ")+"]"]}let u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>DR){for(let t=0;t<MR;t++){let r=t*d,s=r+d;h.push(...zR(e.slice(r,s),u,n,c,a,!1))}h.push("...");for(let t=o-MR;t<o;t++){let r=t*d,s=r+d;h.push(...zR(e.slice(r,s),u,n,c,a,t===o-1))}}else for(let m=0;m<o;m++){let t=m*d,r=t+d;h.push(...zR(e.slice(t,r),u,n,c,a,m===o-1))}let p=2===l?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(s?"":f),h}function BR(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var VR=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=LC(e),null!=n){let e=n.length;FC(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ZC(t,this.size),this.strides=cA(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),FC(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));let a=this.locToIndex(n);this.values[a]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(let s of t){if(s<0||s>=this.shape[r]){let e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let a=t[t.length-1];for(let s=0;s<t.length-1;++s)a+=this.strides[s]*t[s];return this.values[a]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return WR().makeTensor(this.values,this.shape,this.dtype)}},WR=null,UR=null;var jR=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=LC(e),this.strides=cA(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return UR.buffer(this.shape,this.dtype,e)}bufferSync(){return UR.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return hA(this.shape,e,"complex64"===this.dtype)}arraySync(){return hA(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=WR().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map((e=>CR(e)))}catch(gye){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),WR().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=WR().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>CR(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await WR().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),WR().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return UR.print(this,e)}clone(){return this.throwIfDisposed(),UR.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return OR(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),UR.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),WR().makeVariable(this,e,t,n)}};function GR(){return AA("Tensor",(()=>jR))}Object.defineProperty(jR,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),GR();var HR=class extends jR{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!VC(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);WR().disposeTensor(this),this.dataId=e.dataId,WR().incRef(this,null)}dispose(){WR().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(HR,Symbol.hasInstance,{value:e=>e instanceof jR&&null!=e.assign&&e.assign instanceof Function});var qR,KR,YR,XR,QR,ZR,JR={};tC(JR,{assertTypesMatch:()=>iD,getTensorsInContainer:()=>lD,isTensorInList:()=>oD,makeTypesMatch:()=>sD}),(KR=qR||(qR={})).R0="R0",KR.R1="R1",KR.R2="R2",KR.R3="R3",KR.R4="R4",KR.R5="R5",KR.R6="R6",function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(YR||(YR={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(XR||(XR={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(QR||(QR={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(ZR||(ZR={}));var eD={float32:QR,int32:YR,bool:XR,complex64:ZR};function tD(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return eD[e][t]}function nD(e){return tD(e,"int32")}function rD(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function aD(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function sD(e,t){if(e.dtype===t.dtype)return[e,t];let n=tD(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function iD(e,t){FC(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function oD(e,t){return t.some((t=>t.id===e.id))}function lD(e){let t=[];return uD(e,t,new Set),t}function uD(e,t,n){if(null==e)return;if(e instanceof jR)return void t.push(e);if(!function(e){return Array.isArray(e)||"object"==typeof e}(e))return;let r=e;for(let a in r){let e=r[a];n.has(e)||(n.add(e),uD(e,t,n))}}function cD(e){return null!=e.kernelName}var dD=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},hD=class e{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new dD}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(q$(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new _R(this.backendInstance),!0}setupRegisteredKernels(){J$(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){J$(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(!n||n instanceof TC||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,q$(`Initialization of backend ${e} failed`),q$(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return q$(`Initialization of backend ${e} failed`),q$(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(gge){throw t(),gge}}nextTensorId(){return e.nextTensorId++}nextVariableId(){return e.nextVariableId++}clone(e){let t=fD.runKernel(GE,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{let t={x:e},n={dtype:"float32"};return fD.runKernel(JA,t,n)}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==Q$(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n,r=[],a=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let o,l=cD(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(cD(e)){let{kernelName:t,inputs:s,attrs:i}=e;null==this.backendName&&this.backend;let l=Q$(t,this.backendName);FC(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),n=()=>{let e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:i,backend:this.backend});let n=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let u=n.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){let e=this.getTensorsForGradient(t,s,u);r=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,s=e=>{a&&(r=e.map((e=>this.keep(this.clone(e)))))};n=()=>{let e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));let n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}let u,{inputs:c,attrs:d}=e,h=cD(e)?null:e.backwardsFunc;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(u=this.profiler.profileKernel(l,c,(()=>n())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(u),t=u.outputs):t=n()})),a&&this.addTapeNode(l,c,t,h,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((e=>null!=c[e]?c[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:u.timeMs,extraInfo:u.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){let r=Z$(e);if(null!=r){let e,a=r.inputsToSave||[],s=r.outputsToSave||[];r.saveAllInputs?(FC(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),e=Object.keys(t).map((e=>t[e]))):e=a.map((e=>t[e]));let i=n.filter(((e,t)=>s[t]));return e.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&aA(e[0])&&(a=e.map((e=>NR(e))));let s=r.write(a,t,n),i=new jR(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){let e=this.state.tensorInfo.get(s),t=rA(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){let a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:a}=e,s=new jR(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));let a=new HR(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*nA(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof HR||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*nA(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=Z$(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){let e=n[t],r=mA(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=lD(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){let e=this.state.activeScope.track[a];!e.kept&&!n.has(e.id)&&e.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{!e.kept&&e.scopeId===r.id&&this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(FC(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));FC(a instanceof jR,(()=>"The result y returned by f() must be a tensor."));let s=function(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let n=e[l],s=n.inputs;for(let e in s){let i=s[e],o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[n.id]=!0;break}if(o)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(let e in n)s[n[e].id]=!0,i[t.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let t=e[l];if(a[t.id]&&i[t.id]){let e={};for(let a in t.inputs){let n=t.inputs[a];r[n.id]&&(e[a]=n)}let n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{let e={};e[a.id]=null==n?function(e){let t=fA(LC(e),"float32");return fD.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach((t=>{let n=e[t.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);let a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let i=s.inputs[t];if(!VC(a.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{let t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}(e,s,(e=>this.tidy(e)),mD);let r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(let t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){var t=this;return FC(lA(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];FC(r.every((e=>e instanceof jR)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));let s,i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(s=e(...r,n),FC(s.value instanceof jR,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),FC(lA(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(e,t)=>{let n=s.gradFunc(e,t),a=Array.isArray(n)?n:[n];FC(a.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),FC(a.every((e=>e instanceof jR)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));let i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=IR(),n=await this.backend.time(e);return n.wallMs=IR()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new dD;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function pD(){let e=CA();if(null==e._tfengine){let t=new kA(e);e._tfengine=new hD(t)}return function(e){NA=e}(e._tfengine.ENV),function(e){WR=e}((()=>e._tfengine)),e._tfengine}hD.nextTensorId=0,hD.nextVariableId=0;var fD=pD();function mD(e,t){let n={a:e,b:t};return fD.runKernel(RA,n)}var gD,yD={};function bD(e){gD=e}function vD(e){if(void 0!==gD)return gD;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function xD(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}tC(yD,{isBrowser:()=>xD,isMobile:()=>vD,mockIsMobile:()=>bD});var wD=IA();function kD(e,t){let n=e;if(AR(e))return"string"===t?[]:[e.length];if(rD(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(aD(e))return[e.buffer.size/(null==t?4:nA(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||AR(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&IA().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&SD(e,r,[]),r}function SD(e,t,n){if(n=n||[],!Array.isArray(e)&&!AR(e))return void FC(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));FC(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),FC(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));let r=t.slice(1);for(let a=0;a<e.length;++a)SD(e[a],r,n.concat(a))}function ID(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function TD(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof GR())return ID(r,e.dtype,t,n),e;let a=oA(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),ID(r,a,t,n),null==e||!AR(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let s=kD(e,a);!AR(e)&&!Array.isArray(e)&&(e=[e]);let i="string"!==a?SR(e,a):ER(e,[],!0);return fD.makeTensor(i,s,a)}function ND(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>TD(e,`${t}[${a}]`,n,r)))}wD.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),wD.registerFlag("IS_BROWSER",(()=>xD())),wD.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&"undefined"!=typeof process.versions&&"undefined"!=typeof process.versions.node)),wD.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),wD.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),wD.registerFlag("PROD",(()=>!1)),wD.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>wD.getBool("DEBUG"))),wD.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),wD.registerFlag("IS_TEST",(()=>!1)),wD.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>wD.getBool("DEBUG"))),wD.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),wD.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),wD.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));var CD="__op";function AD(e){let t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=CD;let a=function(){fD.startScope(n);try{let e=r(...arguments);return xA(e)&&console.error("Cannot return a Promise inside of tidy."),fD.endScope(e),e}catch(e){throw fD.endScope(null),e}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}var ED=AD({complex_:function(e,t){let n=TD(e,"real","complex"),r=TD(t,"imag","complex");OC(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return fD.runKernel(nE,a)}});function _D(e,t,n,r){if(null==r)r=oA(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(aD(e)||rD(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return fD.backend.createTensorFromGPUData(e,t||n,r)}if(!AR(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){yA(t);let e=LC(t),r=LC(n);FC(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){let e=n[a],r=a!==n.length-1||e!==LC(t.slice(a));FC(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return!AR(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e="string"!==r?SR(e,r):ER(e,[],!0),fD.makeTensor(e,t,r)}function $D(e,t,n){return _D(e,t,kD(e,n),n)}var RD={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},DD=class e{static join(t){return new e(t).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),0===(e=e.map((e=>AR(e)?e.buffer:e))).length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){let r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);let n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);let r=new ArrayBuffer(t-e),a=new Uint8Array(r),s=0;for(let i=n;i<this.shards.length;i++){let n=this.shards[i],r=e+s-n.start,o=s,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(a.set(u,o),s+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;let n=function(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,s=t(e[a]);if(0===s)return a;s<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}};function MD(){IA().set("PROD",!0)}function FD(){IA().set("DEBUG",!0)}function OD(){IA().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function PD(e){IA().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function LD(){fD.disposeVariables()}function zD(){return fD}function BD(){return fD.memory()}function VD(e){return fD.profile(e)}function WD(e,t){return fD.tidy(e,t)}function UD(e){lD(e).forEach((e=>e.dispose()))}function jD(e){return fD.keep(e)}function GD(e){return fD.time(e)}function HD(e){return fD.setBackend(e)}function qD(){return fD.ready()}function KD(){return fD.backendName}function YD(e){fD.removeBackend(e)}function XD(e){return fD.findBackend(e)}function QD(e){return fD.findBackendFactory(e)}function ZD(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return fD.registerBackend(e,t,n)}function JD(){return fD.backend}function eM(e,t){IA().setPlatform(e,t)}!function(e){e}(PD);var tM=4;async function nM(e,t){let n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<a.length;++s){let i=a[s],o=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);let l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise((async e=>{let t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+tM*t.length,r=new Uint8Array(n),a=0;for(let s=0;s<t.length;s++){let e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=tM,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:uM(await Promise.all(r)),specs:n}}function rM(e,t){let n=new DD(e),r={},a=0;for(let s of t){let e=aM(s,((e,t)=>n.slice(a+e,a+t)));r[s.name]=iM(s,n.slice(a,a+e)),a+=e}return r}function aM(e,t){let n,r=LC(e.shape);if("quantization"in e){let t=e.quantization;n=RD[t.dtype]}else{if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=tM+new Uint32Array(t(e,e+tM))[0];return e}n=RD[e.dtype]}return r*n}async function sM(e,t){let n,r=LC(e.shape);if("quantization"in e){let t=e.quantization;n=RD[t.dtype]}else{if("string"===e.dtype){let e=0;for(let n=0;n<r;n++)e+=tM+new Uint32Array(await t(e,e+tM))[0];return e}n=RD[e.dtype]}return r*n}function iM(e,t){let n,r=e.name,a=e.dtype,s=e.shape,i=LC(s),o=0;if("quantization"in e){let s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${a}.`)}let l=RD[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===a)if("uint8"===s.dtype||"uint16"===s.dtype){n=new Float32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);n=function(){let e=function(){let e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){let a=r[i],o=e[n[a>>10]+(1023&a)]+t[a>>10];s[i]=o}return new Float32Array(a)}}()(u)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${r}': ${a}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);n=new Int32Array(u.length);for(let e=0;e<u.length;e++){let t=u[e];n[e]=Math.round(t*s.scale+s.min)}}o+=i*l}else if("string"===a){let r=LC(e.shape);n=[];for(let e=0;e<r;e++){let e=new Uint32Array(t.slice(o,o+tM))[0];o+=tM;let r=new Uint8Array(t.slice(o,o+e));n.push(r),o+=e}}else{let e=RD[a];if("float32"===a)n=new Float32Array(t);else if("int32"===a)n=new Int32Array(t);else{if("bool"!==a){if("complex64"===a){n=new Float32Array(t);let e=new Float32Array(n.length/2),r=new Float32Array(n.length/2);for(let t=0;t<e.length;t++)e[t]=n[2*t],r[t]=n[2*t+1];let a=$D(e,s,"float32"),i=$D(r,s,"float32"),o=ED(a,i);return a.dispose(),i.dispose(),o}throw new Error(`Unsupported dtype in weight '${r}': ${a}`)}n=new Uint8Array(t)}o+=i*e}return $D(n,s,a)}async function oM(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:t,value:a}=await e.read();if(t&&null==a){let e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}let s=new Uint8Array(r.length+a.byteLength);s.set(r,0),s.set(new Uint8Array(a),r.length),r=s}return r.buffer}async function lM(e,t){let n={},r=e.getReader(),a=new ArrayBuffer(0);for(let s of t){let e=await sM(s,(async(e,t)=>(a=await oM(r,a,t),a.slice(e,t))));a=await oM(r,a,e);let t=a.slice(0,e);a=a.slice(e);let i=iM(s,t);if(n[s.name]=i,"webgpu"===KD()){let e=JD();"uploadToGPU"in e&&LC(i.shape)>=IA().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function uM(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));let r=new Uint8Array(t),a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}var cM="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function dM(e){return cM?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function hM(e){return DD.join(e)}function pM(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function fM(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function mM(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function gM(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),mM(e,n,r)}function yM(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:dM(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:dM(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new DD(e.weightData).byteLength}}function bM(e){let t=[];for(let n of e)t.push(...n.weights);return t}var vM=class e{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==e.instance&&(e.instance=new e),e.instance}static registerSaveRouter(t){e.getInstance().saveRouters.push(t)}static registerLoadRouter(t){e.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return e.getHandlers(t,"save")}static getLoadHandlers(t,n){return e.getHandlers(t,"load",n)}static getHandlers(t,n,r){let a=[];return("load"===n?e.getInstance().loadRouters:e.getInstance().saveRouters).forEach((e=>{let n=e(t,r);null!==n&&a.push(n)})),a}},xM=e=>vM.registerSaveRouter(e),wM=e=>vM.registerLoadRouter(e),kM=e=>vM.getSaveHandlers(e),SM=(e,t)=>vM.getLoadHandlers(e,t),IM="tensorflowjs",TM="models_store",NM="model_info_store";function CM(){if(!IA().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function AM(e){let t=e.result;t.createObjectStore(TM,{keyPath:"modelPath"}),t.createObjectStore(NM,{keyPath:"modelPath"})}var EM=class{constructor(e){if(this.indexedDB=CM(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{let r=this.indexedDB.open(IM,1);r.onupgradeneeded=()=>AM(r),r.onsuccess=()=>{let a=r.result;if(null==t){let t=a.transaction(TM,"readonly"),r=t.objectStore(TM).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=DD.join(t.weightData);let r,i,o=yM(t),l=a.transaction(NM,"readwrite"),u=l.objectStore(NM);try{r=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(s){return n(s)}r.onsuccess=()=>{i=a.transaction(TM,"readwrite");let r,s=i.objectStore(TM);try{r=s.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(c){return n(c)}r.onsuccess=()=>e({modelArtifactsInfo:o}),r.onerror=e=>{u=l.objectStore(NM);let t=u.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(r.error)),t.onerror=e=>(a.close(),n(r.error))}},r.onerror=e=>(a.close(),n(r.error)),l.oncomplete=()=>{null==i?a.close():i.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}};EM.URL_SCHEME="indexeddb://";var _M=e=>IA().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(EM.URL_SCHEME)?function(e){return new EM(e)}(e.slice(EM.URL_SCHEME.length)):null;vM.registerSaveRouter(_M),vM.registerLoadRouter(_M);var $M="/",RM="tensorflowjs_models",DM="info",MM="model_topology",FM="weight_specs",OM="weight_data",PM="model_metadata";function LM(e){return{info:[RM,e,DM].join($M),topology:[RM,e,MM].join($M),weightSpecs:[RM,e,FM].join($M),weightData:[RM,e,OM].join($M),modelMetadata:[RM,e,PM].join($M)}}function zM(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function BM(e){let t=e.split($M);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join($M)}var VM=class{constructor(e){if(!IA().getBool("IS_BROWSER")||"undefined"==typeof window||"undefined"==typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=LM(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=yM(e),s=DD.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(cM)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(s));let t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw zM(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(cM){let t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(s),t}};VM.URL_SCHEME="localstorage://";var WM=e=>IA().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(VM.URL_SCHEME)?function(e){return new VM(e)}(e.slice(VM.URL_SCHEME.length)):null;vM.registerSaveRouter(WM),vM.registerLoadRouter(WM);var UM="://",jM=class e{constructor(){this.managers={}}static getInstance(){return null==e.instance&&(e.instance=new e),e.instance}static registerManager(t,n){FC(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith(UM)&&(t=t.slice(0,t.indexOf(UM))),FC(t.length>0,(()=>"scheme must not be an empty string."));let r=e.getInstance();FC(null==r.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),r.managers[t]=n}static getManager(t){let n=e.getInstance().managers[t];if(null==n)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(e.getInstance().managers)}};function GM(e){if(-1===e.indexOf(UM))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${jM.getSchemes().join(",")}`);return{scheme:e.split(UM)[0],path:e.split(UM)[1]}}async function HM(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];FC(e!==t,(()=>`Old path and new path are the same: '${e}'`));let r=vM.getLoadHandlers(e);FC(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),FC(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));let a=r[0],s=vM.getSaveHandlers(t);FC(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),FC(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));let i=s[0],o=GM(e).scheme,l=GM(e).path,u=o===GM(e).scheme,c=await a.load();n&&u&&await jM.getManager(o).removeModel(l);let d=await i.save(c);return n&&!u&&await jM.getManager(o).removeModel(l),d.modelArtifactsInfo}async function qM(){let e=jM.getSchemes(),t={};for(let n of e){let e=await jM.getManager(n).listModels();for(let r in e){t[n+UM+r]=e[r]}}return t}async function KM(e){let t=GM(e);return jM.getManager(t.scheme).removeModel(t.path)}async function YM(e,t){return HM(e,t,!1)}async function XM(e,t){return HM(e,t,!0)}if(IA().get("IS_BROWSER")){IA().setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&IA().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return oR(e)}});try{jM.registerManager(VM.URL_SCHEME,new class{constructor(){FC(IA().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),FC("undefined"==typeof window||"undefined"!=typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){let e={},t=RM+$M,n=$M+DM;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);a.startsWith(t)&&a.endsWith(n)&&(e[BM(a)]=JSON.parse(this.LS.getItem(a)))}return e}async removeModel(e){let t=LM(e=function(e){return e.startsWith(VM.URL_SCHEME)?e.slice(VM.URL_SCHEME.length):e}(e));if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return zM(t),n}})}catch(KR){}try{jM.registerManager(EM.URL_SCHEME,new class{constructor(){this.indexedDB=CM()}async listModels(){return new Promise(((e,t)=>{let n=this.indexedDB.open(IM,1);n.onupgradeneeded=()=>AM(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(NM,"readonly"),s=a.objectStore(NM).getAll();s.onsuccess=()=>{let t={};for(let e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){return e=function(e){return e.startsWith(EM.URL_SCHEME)?e.slice(EM.URL_SCHEME.length):e}(e),new Promise(((t,n)=>{let r=this.indexedDB.open(IM,1);r.onupgradeneeded=()=>AM(r),r.onsuccess=()=>{let a,s=r.result,i=s.transaction(NM,"readwrite"),o=i.objectStore(NM),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=o.delete(e),i=()=>{a=s.transaction(TM,"readwrite");let r=a.objectStore(TM).delete(e);r.onsuccess=()=>t(l.result.modelArtifactsInfo),r.onerror=e=>n(l.error)};r.onsuccess=i,r.onerror=e=>(i(),s.close(),n(l.error))}},l.onerror=e=>(s.close(),n(l.error)),i.oncomplete=()=>{null==a?s.close():a.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}})}catch(KR){}}var QM,ZM=()=>aC();function JM(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",yA(e),new VR(e,t,n)}IA().get("IS_NODE")&&!IA().get("IS_BROWSER")&&IA().setPlatform("node",new class{constructor(){this.util=sC(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=IA().global.fetch?IA().global.fetch(e,t):(null==QM&&(QM=ZM()),QM(e,t))}now(){let e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});var eF=AD({cast_:function(e,t){let n=TD(e,"x","cast");if(!eA(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return fD.runKernel(JA,r,a)}});var tF=AD({clone_:function(e){let t={x:TD(e,"x","clone","string_or_numeric")};return fD.runKernel(GE,t)}});function nF(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}pD(),function(e){UR=e}({buffer:JM,cast:eF,clone:tF,print:nF});var rF=AD({add_:function(e,t){let n=TD(e,"a","add"),r=TD(t,"b","add");[n,r]=sD(n,r);let a={a:n,b:r};return fD.runKernel(RA,a)}});var aF=AD({floorDiv_:function(e,t){let n=TD(e,"a","floorDiv"),r=TD(t,"b","floorDiv");[n,r]=sD(n,r);let a={a:n,b:r};return fD.runKernel(zE,a)}});var sF=AD({div_:function(e,t){let n=TD(e,"a","div"),r=TD(t,"b","div");if([n,r]=sD(n,r),"int32"===n.dtype&&"int32"===r.dtype)return aF(n,r);let a={a:n,b:r};return fD.runKernel(NE,a,{})}});var iF=AD({mul_:function(e,t){let n=TD(e,"a","mul"),r=TD(t,"b","mul");[n,r]=sD(n,r);let a={a:n,b:r};return fD.runKernel(T_,a)}});var oF=AD({abs_:function(e){let t=TD(e,"x","abs");if("complex64"===t.dtype){let e={x:t};return fD.runKernel(rE,e)}{let e={x:t};return fD.runKernel(EA,e)}}});var lF=AD({acos_:function(e){let t={x:TD(e,"x","acos")};return fD.runKernel(_A,t)}});var uF=AD({acosh_:function(e){let t={x:TD(e,"x","acosh")};return fD.runKernel($A,t)}});var cF=AD({addN_:function(e){FC(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),FC(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));let t=e.map(((e,t)=>TD(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!VC(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));let r=t;return fD.runKernel(DA,r)}});var dF=AD({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:TD(e,"x","all","bool")},a={axis:t,keepDims:n};return fD.runKernel(MA,r,a)}});var hF=AD({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:TD(e,"x","any","bool")},a={axis:t,keepDims:n};return fD.runKernel(FA,r,a)}});var pF=AD({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:TD(e,"x","argMax")},r={axis:t};return fD.runKernel(OA,n,r)}});var fF=AD({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:TD(e,"x","argMin")},r={axis:t};return fD.runKernel(PA,n,r)}});var mF=AD({asin_:function(e){let t={x:TD(e,"x","asin")};return fD.runKernel(LA,t)}});var gF=AD({asinh_:function(e){let t={x:TD(e,"x","asinh")};return fD.runKernel(zA,t)}});var yF=AD({atan_:function(e){let t={x:TD(e,"x","atan")};return fD.runKernel(BA,t)}});var bF=AD({atan2_:function(e,t){let n=TD(e,"a","atan2"),r=TD(t,"b","atan2");[n,r]=sD(n,r);let a={a:n,b:r};return fD.runKernel(WA,a)}});var vF=AD({atanh_:function(e){let t={x:TD(e,"x","atanh")};return fD.runKernel(VA,t)}});function xF(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return SF(e,[...t,e[3]],n,s,r,null,null,DF(a))}function wF(e,t,n,r,a,s){let i,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",[l,u]=NF(t);if("channelsLast"===o)i=[l,u,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);i=[l,u,e[1],e[1]]}return SF(e,i,n,r,a,s,!1,o)}function kF(e,t,n,r,a,s){let i,o,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC",[u,c,d]=CF(t);if("NDHWC"===l)o="channelsLast",i=[u,c,d,e[4],e[4]];else{if("NCDHW"!==l)throw new Error(`Unknown dataFormat ${l}`);o="channelsFirst",i=[u,c,d,e[1],e[1]]}return IF(e,i,n,r,a,!1,o,s)}function SF(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,c]=e}let h,[p,f,,m]=t,[g,y]=NF(n),[b,v]=NF(r),x=AF(p,b),w=AF(f,v),{padInfo:k,outHeight:S,outWidth:I}=function(e,t,n,r,a,s,i,o,l){let u,c,d;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};let a=function(e,t,n,r,a){null==r&&(r=TF(e,t,n));let s=e[0],i=e[1],o=EF((s-t+2*r)/n+1,a),l=EF((i-t+2*r)/n+1,a);return[o,l]}([t,n],s,r,e,o);c=a[0],d=a[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/a);let e=Math.max(0,(c-1)*r+s-t),o=Math.max(0,(d-1)*a+i-n),l=Math.floor(e/2),h=e-l,p=Math.floor(o/2);u={top:l,bottom:h,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/r),d=Math.ceil((n-i+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{let h="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=EF((t-s+h+p)/r+1,o),d=EF((n-i+f+m)/a+1,o)}}return{padInfo:u,outHeight:c,outWidth:d}}(a,u,c,g,y,x,w,s,o),T=i?m*d:m;return"channelsFirst"===o?h=[l,T,S,I]:"channelsLast"===o&&(h=[l,S,I,T]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:S,outWidth:I,outChannels:T,padInfo:k,strideHeight:g,strideWidth:y,filterHeight:p,filterWidth:f,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:b,dilationWidth:v,inShape:e,outShape:h,filterShape:t}}function IF(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=e}let p,[f,m,g,,y]=t,[b,v,x]=CF(n),[w,k,S]=CF(r),I=AF(f,w),T=AF(m,k),N=AF(g,S),{padInfo:C,outDepth:A,outHeight:E,outWidth:_}=function(e,t,n,r,a,s,i,o,l,u,c){let d,h,p,f;if("valid"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};let m=function(e,t,n,r,a,s){null==a&&(a=TF(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*a>=t[o]&&(i[o]=EF((e[o]-t[o]+2*a)/r[o]+1,s));return i}([t,n,r,1],[o,l,u],1,[a,s,i],e,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(t/a),p=Math.ceil(n/s),f=Math.ceil(r/i);let e=(h-1)*a+o-t,c=(p-1)*s+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),v=c-b,x=Math.floor(m/2);d={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(a,u,c,d,b,v,x,I,T,N,o),$=s?y*h:y;return"channelsFirst"===i?p=[l,$,A,E,_]:"channelsLast"===i&&(p=[l,A,E,_,$]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:A,outHeight:E,outWidth:_,outChannels:$,padInfo:C,strideDepth:b,strideHeight:v,strideWidth:x,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:I,effectiveFilterHeight:T,effectiveFilterWidth:N,dilationDepth:w,dilationHeight:k,dilationWidth:S,inShape:e,outShape:p,filterShape:t}}function TF(e,t,n){let r=AF(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function NF(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function CF(e){return"number"==typeof e?[e,e,e]:e}function AF(e,t){return t<=1?e:e+(e-1)*(t-1)}function EF(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function _F(e){let[t,n,r]=NF(e);return 1===t&&1===n&&1===r}function $F(e,t){return _F(e)||_F(t)}function RF(e){return NF(e).every((e=>e>0))}function DF(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function MF(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)FC(WC(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{FC(WC(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}var FF=AD({reshape_:function(e,t){let n={x:TD(e,"x","reshape","string_or_numeric")},r={shape:t};return fD.runKernel(H_,n,r)}});var OF=AD({avgPool_:function(e,t,n,r,a){let s=TD(e,"x","avgPool","float32");FC($F(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=s,o=!1;3===s.rank&&(o=!0,i=FF(s,[1,s.shape[0],s.shape[1],s.shape[2]])),FC(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),MF("avgPool",r,a);let l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=fD.runKernel(UA,l,u);return c=eF(c,s.dtype),o?FF(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var PF=AD({avgPool3d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC",i=TD(e,"x","avgPool3d","float32"),o=i,l=!1;4===i.rank&&(l=!0,o=FF(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),FC(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),FC("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),FC("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),MF("avgPool3d",r,a);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=fD.runKernel(GA,u,c);return d=eF(d,o.dtype),l?FF(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var LF=AD({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;FC(e.length>=1,(()=>"Pass at least one tensor to concat"));let n=ND(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return tF(n[0]);let r=n,a={axis:t};return fD.runKernel(aE,r,a)}});var zF=AD({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=TD(e,"a","matMul"),s=TD(t,"b","matMul");[a,s]=sD(a,s);let i={a:a,b:s},o={transposeA:n,transposeB:r};return fD.runKernel(qA,i,o)}});var BF=AD({sigmoid_:function(e){let t={x:TD(e,"x","sigmoid","float32")};return fD.runKernel(c$,t)}});var VF=AD({slice_:function(e,t,n){let r=TD(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return fD.runKernel(i$,a,s)}});var WF=AD({tanh_:function(e){let t={x:TD(e,"x","tanh","float32")};return fD.runKernel($$,t)}});var UF=AD({basicLSTMCell_:function(e,t,n,r,a,s){let i=TD(e,"forgetBias","basicLSTMCell"),o=TD(t,"lstmKernel","basicLSTMCell"),l=TD(n,"lstmBias","basicLSTMCell"),u=TD(r,"data","basicLSTMCell"),c=TD(a,"c","basicLSTMCell"),d=TD(s,"h","basicLSTMCell"),h=LF([u,d],1),p=zF(h,o),f=rF(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=VF(f,[0,0],y),v=VF(f,[0,g],y),x=VF(f,[0,2*g],y),w=VF(f,[0,3*g],y),k=rF(iF(BF(b),WF(v)),iF(c,BF(rF(i,x))));return[k,iF(WF(k),BF(w))]}});var jF=AD({batchToSpaceND_:function(e,t,n){let r=TD(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));FC(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),FC(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),FC(r.shape[0]%a===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));let s={x:r},i={blockShape:t,crops:n};return fD.runKernel(KA,s,i)}});function GF(e){let t;return t=0===e.rank||1===e.rank?FF(e,[1,1,1,e.size]):2===e.rank?FF(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?FF(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}var HF=AD({batchNorm_:function(e,t,n,r,a,s){null==s&&(s=.001);let i,o,l=TD(e,"x","batchNorm"),u=TD(t,"mean","batchNorm"),c=TD(n,"variance","batchNorm");null!=a&&(i=TD(a,"scale","batchNorm")),null!=r&&(o=TD(r,"offset","batchNorm")),FC(u.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),FC(null==o||u.rank===o.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),FC(null==i||u.rank===i.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let d={x:GF(l),scale:i,offset:o,mean:u,variance:c},h={varianceEpsilon:s},p=fD.runKernel(BE,d,h);return FF(p,l.shape)}});var qF=AD({batchNorm2d_:function(e,t,n,r,a,s){let i,o,l=TD(e,"x","batchNorm"),u=TD(t,"mean","batchNorm"),c=TD(n,"variance","batchNorm");return null!=a&&(i=TD(a,"scale","batchNorm")),null!=r&&(o=TD(r,"offset","batchNorm")),FC(2===l.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`)),FC(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`)),FC(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`)),null!=i&&FC(2===i.rank||1===i.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${i.rank}.`)),null!=o&&FC(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${o.rank}.`)),HF(l,u,c,o,i,s)}});var KF=AD({batchNorm3d_:function(e,t,n,r,a,s){let i,o,l=TD(e,"x","batchNorm"),u=TD(t,"mean","batchNorm"),c=TD(n,"variance","batchNorm");return null!=a&&(i=TD(a,"scale","batchNorm")),null!=r&&(o=TD(r,"offset","batchNorm")),FC(3===l.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`)),FC(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`)),FC(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`)),null!=i&&FC(3===i.rank||1===i.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${i.rank}.`)),null!=o&&FC(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${o.rank}.`)),HF(l,u,c,o,i,s)}});var YF=AD({batchNorm4d_:function(e,t,n,r,a,s){let i,o,l=TD(e,"x","batchNorm"),u=TD(t,"mean","batchNorm"),c=TD(n,"variance","batchNorm");return null!=a&&(i=TD(a,"scale","batchNorm")),null!=r&&(o=TD(r,"offset","batchNorm")),FC(4===l.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`)),FC(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`)),FC(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`)),null!=i&&FC(4===i.rank||1===i.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${i.rank}.`)),null!=o&&FC(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${o.rank}.`)),HF(l,u,c,o,i,s)}});var XF=AD({bincount_:function(e,t,n){let r=TD(e,"x","bincount"),a=TD(t,"weights","bincount");FC("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),FC(n>=0,(()=>`size must be non-negative, but got ${n}.`)),FC(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));let s={x:r,weights:a},i={size:n};return fD.runKernel(YA,s,i)}});var QF=AD({bitwiseAnd_:function(e,t){let n=TD(e,"x","bitwiseAnd"),r=TD(t,"y","bitwiseAnd");if(!VC(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let a={a:n,b:r};return fD.runKernel(XA,a)}});var ZF=AD({broadcastArgs_:function(e,t){let n=TD(e,"s0","broadcastArgs","int32"),r=TD(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return fD.runKernel(ZA,a)}});var JF=AD({broadcastTo_:function(e,t){let n=TD(e,"broadcastTo","x"),r=n.shape;if(yA(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=FF(n,e)}let a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return tF(n);let i={x:n},o={reps:s};return fD.runKernel(R$,i,o)}});var eO=AD({ceil_:function(e){let t={x:TD(e,"x","ceil","float32")};return fD.runKernel(eE,t)}});function tO(e,t,n){yA(e);let r={shape:e,value:t,dtype:n=n||oA(t)};return fD.runKernel(OE,{},r)}var nO=AD({clipByValue_:function(e,t,n){let r=TD(e,"x","clipByValue");if(FC(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return tO(r.shape,t,r.dtype);let a={x:r},s={clipValueMin:t,clipValueMax:n};return fD.runKernel(tE,a,s)}});var rO=AD({concat1d_:function(e){return LF(e,0)}});var aO=AD({concat2d_:function(e,t){return LF(e,t)}});var sO=AD({concat3d_:function(e,t){return LF(e,t)}});var iO=AD({concat4d_:function(e,t){return LF(e,t)}});var oO=AD({conv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=TD(e,"x","conv2d","float32"),l=TD(t,"filter","conv2d","float32"),u=o,c=!1;3===o.rank&&(c=!0,u=FF(o,[1,o.shape[0],o.shape[1],o.shape[2]])),FC(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),FC(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),MF("conv2d",r,i);let d="NHWC"===a?u.shape[3]:u.shape[1];FC(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),FC($F(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),FC(RF(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),FC(RF(n),(()=>"Error in conv2D: Strides should be larger than 0."));let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=fD.runKernel(sE,h,p);return c?FF(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var lO=AD({conv1d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0,o=TD(e,"x","conv1d"),l=TD(t,"filter","conv1d"),u=o,c=!1;2===o.rank&&(c=!0,u=FF(o,[1,o.shape[0],o.shape[1]])),FC(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),FC(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),MF("conv1d",r,i),FC(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),FC($F(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),FC(RF(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),FC(RF(n),(()=>"Error in conv1D: Stride should be larger than 0.")),FC("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));let d=FF(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=FF(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=oO(h,d,[1,n],r,"NHWC",[1,s],i);return FF(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});var uO=AD({conv2DBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;FC(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=FF(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),FC(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),FC(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),FC(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));let c="NHWC"===s?o[3]:o[1],d="NHWC"===s?l.shape[3]:l.shape[1];FC(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),FC(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),MF("conv2dDerInput",a,i);let h={dy:l,filter:n},p={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=fD.runKernel(oE,h,p);return u?FF(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var cO=AD({conv2dTranspose_:function(e,t,n,r,a,s){let i=TD(e,"x","conv2dTranspose"),o=TD(t,"filter","conv2dTranspose");return uO(n,i,o,r,a,"NHWC",s)}});var dO=AD({conv3d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1],i=TD(e,"x","conv3d"),o=TD(t,"filter","conv3d"),l=i,u=!1;4===i.rank&&(u=!0,l=FF(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),FC(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),FC(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),FC(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),FC($F(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),FC("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),FC(RF(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),FC(RF(n),(()=>"Error in conv3D: Strides should be larger than 0."));let c={x:l,filter:o},d={strides:n,pad:r,dataFormat:a,dilations:s},h=fD.runKernel(lE,c,d);return u?FF(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var hO=AD({conv3DBackpropInput_:function(e,t,n,r,a){FC(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=FF(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];FC(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),FC(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),FC(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),FC(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),FC(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));let c={dy:i,filter:n},d={pad:a,strides:r,inputShape:s},h=fD.runKernel(cE,c,d);return o?FF(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});var pO=AD({conv3dTranspose_:function(e,t,n,r,a){let s=TD(e,"x","conv3dTranspose"),i=TD(t,"filter","conv3dTranspose");return hO(n,s,i,r,a)}});var fO=AD({cos_:function(e){let t={x:TD(e,"x","cos","float32")};return fD.runKernel(dE,t)}});var mO=AD({cosh_:function(e){let t={x:TD(e,"x","cosh","float32")};return fD.runKernel(hE,t)}});var gO=AD({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={x:TD(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return fD.runKernel(pE,a,s)}});var yO=AD({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={x:TD(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return fD.runKernel(fE,a,s)}});var bO=AD({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=TD(e,"x","denseBincount"),s=TD(t,"weights","denseBincount");FC("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),FC(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),FC(n>=0,(()=>`size must be non-negative, but got ${n}.`)),FC(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));let i={x:a,weights:s},o={size:n,binaryOutput:r};return fD.runKernel(gE,i,o)}});var vO=AD({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC",r=TD(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];FC(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),FC(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),FC(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),FC(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));let o={x:r},l={blockSize:t,dataFormat:n};return fD.runKernel(yE,o,l)}});var xO=AD({depthwiseConv2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=TD(e,"x","depthwiseConv2d","float32"),l=TD(t,"filter","depthwiseConv2d","float32"),u=o,c=!1;3===o.rank&&(c=!0,u=FF(o,[1,o.shape[0],o.shape[1],o.shape[2]])),FC(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),FC(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));let d="NHWC"===a?u.shape[3]:u.shape[1];FC(d===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`)),MF("depthwiseConv2d",r,i);let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=fD.runKernel(bE,h,p);return c?FF(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});var wO=AD({diag_:function(e){let t={x:TD(e,"x","diag")};return fD.runKernel(wE,t)}});var kO=AD({dilation2d_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=TD(e,"x","dilation2d"),o=TD(t,"filter","dilation2d");FC(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),FC(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),FC("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=i,u=!1;3===i.rank&&(l=FF(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),FC(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));let c={x:l,filter:o},d={strides:n,pad:r,dilations:a},h=fD.runKernel(kE,c,d);return u?FF(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),SO={};function IO(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function TO(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function NO(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let s=e[e.length-a-1];null==s&&(s=1);let i=t[t.length-a-1];if(null==i&&(i=1),1===s)r[n-a-1]=i;else if(1===i)r[n-a-1]=s;else{if(s!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-a-1]=s}}return r}tC(SO,{assertAndGetBroadcastShape:()=>NO,getBroadcastDims:()=>IO,getReductionAxes:()=>TO});var CO=AD({equal_:function(e,t){let n=TD(e,"a","equal","string_or_numeric"),r=TD(t,"b","equal","string_or_numeric");[n,r]=sD(n,r),NO(n.shape,r.shape);let a={a:n,b:r};return fD.runKernel($E,a)}});var AO=AD({where_:function(e,t,n){let r=TD(t,"a","where"),a=TD(n,"b","where"),s=TD(e,"condition","where","bool"),i=NO(NO(s.shape,r.shape),a.shape),o={condition:JF(s,i),t:JF(r,i),e:JF(a,i)};return fD.runKernel(a$,o)}});var EO=AD({zerosLike_:function(e){let t={x:TD(e,"x","zerosLike")};return fD.runKernel(B$,t)}});var _O=AD({divNoNan_:function(e,t){let n=TD(e,"a","div"),r=TD(t,"b","div");[n,r]=sD(n,r);let a=sF(n,r),s=EO(a),i=CO(r,s);return AO(i,s,a)}});var $O=AD({dot_:function(e,t){let n=TD(e,"t1","dot"),r=TD(t,"t2","dot");FC((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));let a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(FC(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){let e=FF(n,[1,-1]),t=FF(r,[-1,1]),a=zF(e,t);return FF(a,[])}if(1===n.rank&&2===r.rank){let e=FF(n,[1,-1]),t=FF(r,[r.shape[0],r.shape[1]]),a=zF(e,t);return FF(a,[a.size])}if(2===n.rank&&1===r.rank){let e=FF(r,[-1,1]),t=zF(n,e);return FF(t,[t.size])}{let e=FF(r,[r.shape[0],r.shape[1]]);return zF(n,e)}}});var RO=AD({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];let a=n.map(((e,t)=>TD(e,`tensors${t}`,"einsum"))),s={equation:e};return fD.runKernel(CE,a,s)}});var DO=AD({elu_:function(e){let t={x:TD(e,"x","elu","float32")};return fD.runKernel(AE,t)}});var MO=AD({ensureShape_:function(e,t){let n=TD(e,"x","ensureShape","string_or_numeric");if(!BC(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});var FO=AD({erf_:function(e){let t=TD(e,"x","erf");FC("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=eF(t,"float32"));let n={x:t};return fD.runKernel(_E,n)}});function OO(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function PO(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function LO(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function zO(e,t){return PO(e,t.map((e=>1)),t)}function BO(e,t,n){FC(OO(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function VO(e,t){if(OO(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function WO(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function UO(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}var jO=AD({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:TD(e,"x","max")},a={reductionIndices:t,keepDims:n};return fD.runKernel(h_,r,a)}});var GO=AD({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:TD(e,"x","min")},a={axis:t,keepDims:n};return fD.runKernel(x_,r,a)}});var HO=AD({pow_:function(e,t){let n=TD(e,"base","pow"),r=TD(t,"exp","pow");[n,r]=sD(n,r);let a={a:n,b:r};return fD.runKernel(O_,a)}});function qO(e,t){if((AR(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&AR(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return _D(e,[],[],t)}var KO=AD({sqrt_:function(e){let t={x:TD(e,"x","sqrt","float32")};return fD.runKernel(h$,t)}});var YO=AD({square_:function(e){let t=TD(e,"x","square");return fD.runKernel("Square",{x:t},{})}});var XO=AD({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=TD(e,"x","sum");"bool"===r.dtype&&(r=eF(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return fD.runKernel(p$,a,s)}});function QO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return oF(e);if(1!==e.rank&&null===n)return QO(FF(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return XO(oF(e),n);if(t===1/0)return jO(oF(e),n);if(t===-1/0)return GO(oF(e),n);if("euclidean"===t||2===t)return KO(XO(HO(oF(e),qO(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return jO(XO(oF(e),n[0]),n[1]-1);if(t===1/0)return jO(XO(oF(e),n[1]),n[0]);if(t===-1/0)return GO(XO(oF(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return KO(XO(YO(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var ZO=AD({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=QO(e=TD(e,"x","norm"),t,n),s=a.shape;if(r){let t=YC(n,e.shape);s=zO(a.shape,t)}return FF(a,s)}});var JO=AD({euclideanNorm_:function(e){return ZO(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});var eP=AD({exp_:function(e){let t={x:TD(e,"x","exp")};return fD.runKernel(RE,t)}});var tP=AD({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=TD(e,"x","expandDims","string_or_numeric");FC(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));let r={input:n},a={dim:t};return fD.runKernel(DE,r,a)}});var nP=AD({expm1_:function(e){let t={x:TD(e,"x","expm1")};return fD.runKernel(ME,t)}});var rP=AD({tile_:function(e,t){let n=TD(e,"x","tile","string_or_numeric");FC(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));let r={x:n},a={reps:t};return fD.runKernel(R$,r,a)}});var aP=AD({eye_:function(e,t,n){null==t&&(t=e);let r=JM([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),a=e<=t?e:t;for(let i=0;i<a;++i)r.set(1,i,i);let s=FF(r.toTensor(),[e,t]);if(null==n)return s;if(1===n.length)return rP(tP(s,0),[n[0],1,1]);if(2===n.length)return rP(tP(tP(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return rP(tP(tP(tP(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var sP=AD({floor_:function(e){let t={x:TD(e,"x","floor","float32")};return fD.runKernel(LE,t)}});var iP=AD({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a={x:TD(e,"x","gather"),indices:TD(t,"indices","gather","int32")},s={axis:n,batchDims:r};return fD.runKernel(VE,a,s)}});var oP=AD({greater_:function(e,t){let n=TD(e,"a","greater","string_or_numeric"),r=TD(t,"b","greater","string_or_numeric");[n,r]=sD(n,r),NO(n.shape,r.shape);let a={a:n,b:r};return fD.runKernel(UE,a)}});var lP=AD({greaterEqual_:function(e,t){let n=TD(e,"a","greaterEqual","string_or_numeric"),r=TD(t,"b","greaterEqual","string_or_numeric");[n,r]=sD(n,r),NO(n.shape,r.shape);let a={a:n,b:r};return fD.runKernel(jE,a)}});var uP=AD({imag_:function(e){let t={input:TD(e,"input","imag")};return fD.runKernel(qE,t)}});var cP=AD({isFinite_:function(e){let t={x:TD(e,"x","isFinite")};return fD.runKernel(KE,t)}});var dP=AD({isInf_:function(e){let t={x:TD(e,"x","isInf")};return fD.runKernel(YE,t)}});var hP=AD({isNaN_:function(e){let t={x:TD(e,"x","isNaN")};return fD.runKernel(XE,t)}});var pP=AD({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2,n={x:TD(e,"x","leakyRelu")},r={alpha:t};return fD.runKernel(QE,n,r)}});var fP=AD({less_:function(e,t){let n=TD(e,"a","less","string_or_numeric"),r=TD(t,"b","less","string_or_numeric");[n,r]=sD(n,r),NO(n.shape,r.shape);let a={a:n,b:r};return fD.runKernel(ZE,a)}});var mP=AD({lessEqual_:function(e,t){let n=TD(e,"a","lessEqual","string_or_numeric"),r=TD(t,"b","lessEqual","string_or_numeric");[n,r]=sD(n,r),NO(n.shape,r.shape);let a={a:n,b:r};return fD.runKernel(JE,a)}});function gP(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return fD.runKernel(e_,{},r)}var yP=AD({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=TD(e,"x","localResponseNormalization");FC(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),FC(WC(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=s,o=!1;3===s.rank&&(o=!0,i=FF(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:a},c=fD.runKernel(u_,l,u);return o?FF(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var bP=AD({log_:function(e){let t={x:TD(e,"x","log","float32")};return fD.runKernel(t_,t)}});var vP=AD({log1p_:function(e){let t={x:TD(e,"x","log1p")};return fD.runKernel(n_,t)}});function xP(e){return FC(lA(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{let r=TD(t,"x","tf.grad","string_or_numeric"),a=null!=n?TD(n,"dy","tf.grad"):null;return fD.tidy((()=>{let{value:t,grads:n}=fD.gradients((()=>e(r)),[r],a);return null!=a&&OC(t.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),NP(n),n[0]}))}}function wP(e){return FC(lA(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{FC(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));let r=ND(t,"args","tf.grads","string_or_numeric"),a=null!=n?TD(n,"dy","tf.grads"):null;return fD.tidy((()=>{let{value:t,grads:n}=fD.gradients((()=>e(...r)),r,a);return null!=a&&OC(t.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),NP(n),n}))}}function kP(e){return FC(lA(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{FC(t instanceof jR,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),FC(null==n||n instanceof jR,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));let{grads:r,value:a}=fD.gradients((()=>e(t)),[t],n);return NP(r),{grad:r[0],value:a}}}function SP(e){return FC(lA(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{FC(Array.isArray(t)&&t.every((e=>e instanceof jR)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),FC(null==n||n instanceof jR,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));let r=fD.gradients((()=>e(...t)),t,n);return null!=n&&OC(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),NP(r.grads),r}}function IP(e,t){FC(lA(e),(()=>"The f passed in variableGrads(f) must be a function")),FC(null==t||Array.isArray(t)&&t.every((e=>e instanceof HR)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));let n=null!=t;if(!n){t=[];for(let e in fD.registeredVariables)t.push(fD.registeredVariables[e])}let r=n?t.filter((e=>!e.trainable)):null,a=t.length;FC((t=t.filter((e=>e.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));let{value:s,grads:i}=fD.gradients(e,t,null,!0);FC(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),FC(0===s.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`));let o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:s,grads:o}}function TP(e){return fD.customGrad(e)}function NP(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var CP=AD({neg_:function(e){let t={x:TD(e,"x","neg")};return fD.runKernel(N_,t)}});var AP=AD({softplus_:function(e){let t={x:TD(e,"x","softplus")};return fD.runKernel(d$,t)}});var EP=AD({logSigmoid_:function(e){let t=TD(e,"x","logSigmoid");return TP((e=>({value:CP(AP(CP(e))),gradFunc:t=>iF(t,BF(CP(e)))})))(t)}});var _P=AD({sub_:function(e,t){let n=TD(e,"a","sub"),r=TD(t,"b","sub");[n,r]=sD(n,r);let a={a:n,b:r};return fD.runKernel(E$,a)}});var $P=AD({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=TD(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return TP(((e,n)=>{let r=jO(e,t,!0),a=_P(e,r),s=_P(eF(a,"float32"),bP(XO(eP(a),t,!0)));return n([s]),{value:s,gradFunc:(e,n)=>{let[r]=n,a=eP(r);return _P(e,iF(XO(e,t,!0),a))}}}))(n)}});var RP=AD({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=TD(e,"x","logSumExp"),a=YC(t,r.shape),s=jO(r,a,!0),i=_P(r,s),o=eP(i),l=XO(o,a),u=bP(l),c=rF(FF(s,u.shape),u);if(n){let e=zO(c.shape,a);return FF(c,e)}return c}});var DP=AD({logicalAnd_:function(e,t){let n=TD(e,"a","logicalAnd","bool"),r=TD(t,"b","logicalAnd","bool");NO(n.shape,r.shape);let a={a:n,b:r};return fD.runKernel(r_,a)}});var MP=AD({logicalNot_:function(e){let t={x:TD(e,"x","logicalNot","bool")};return fD.runKernel(a_,t)}});var FP=AD({logicalOr_:function(e,t){let n=TD(e,"a","logicalOr","bool"),r=TD(t,"b","logicalOr","bool");NO(n.shape,r.shape);let a={a:n,b:r};return fD.runKernel(s_,a)}});var OP=AD({logicalXor_:function(e,t){let n=TD(e,"a","logicalXor","bool"),r=TD(t,"b","logicalXor","bool");return NO(n.shape,r.shape),DP(FP(e,t),MP(DP(e,t)))}}),PP=2147483648;var LP=AD({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left",r=TD(e,"sortedSequence","searchSorted"),a=TD(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=FF(r,[-1,s]),l=FF(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(LC(l.shape)>=PP)throw new Error(`values tensor size must less than ${PP}`);if(o.shape[1]>=PP)throw new Error(`trailing dim_size must less than ${PP} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},c={side:n};return fD.runKernel(r$,u,c)}});function zP(e,t){return LP(e,t,"left")}var BP=AD({maxPool_:function(e,t,n,r,a){let s=TD(e,"x","maxPool"),i=s,o=!1;3===s.rank&&(o=!0,i=FF(s,[1,s.shape[0],s.shape[1],s.shape[2]])),FC(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),FC($F(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),MF("maxPool",r,a);let l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},c=fD.runKernel(f_,l,u);return o?FF(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});var VP=AD({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC",i=TD(e,"x","maxPool3d"),o=i,l=!1;4===i.rank&&(l=!0,o=FF(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),FC(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),FC("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),MF("maxPool3d",r,a);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=fD.runKernel(g_,u,c);return l?FF(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});var WP=AD({maxPoolWithArgmax_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s={x:TD(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=fD.runKernel(b_,s,i);return{result:o[0],indexes:o[1]}}});var UP=AD({maximum_:function(e,t){let n=TD(e,"a","maximum"),r=TD(t,"b","maximum");[n,r]=sD(n,r),"bool"===n.dtype&&(n=eF(n,"int32"),r=eF(r,"int32")),NO(n.shape,r.shape);let a={a:n,b:r};return fD.runKernel(p_,a)}});var jP=AD({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r={x:TD(e,"x","mean")},a={axis:t,keepDims:n};return fD.runKernel(v_,r,a)}});function GP(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(yA(e),"complex64"===t){let t=GP(e,"float32"),n=GP(e,"float32");return ED(t,n)}let n=mA(LC(e),t);return fD.makeTensor(n,e,t)}function HP(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(yA(e),"complex64"===t){let t=HP(e,"float32"),n=GP(e,"float32");return ED(t,n)}let n=fA(LC(e),t);return fD.makeTensor(n,e,t)}function qP(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=TD(e,"x","meshgrid",e instanceof jR?e.dtype:"float32");if(void 0===t)return[r];let a=TD(t,"y","meshgrid",t instanceof jR?t.dtype:"float32"),s=LC(r.shape),i=LC(a.shape);return"xy"===n?(r=FF(r,[1,-1]),a=FF(a,[-1,1]),[zF(HP([i,1],r.dtype),r),zF(a,HP([1,s],a.dtype))]):(r=FF(r,[-1,1]),a=FF(a,[1,-1]),[zF(r,HP([1,i],r.dtype)),zF(HP([s,1],a.dtype),a)])}var KP=AD({minimum_:function(e,t){let n=TD(e,"a","minimum"),r=TD(t,"b","minimum");[n,r]=sD(n,r),"bool"===n.dtype&&(n=eF(n,"int32"),r=eF(r,"int32")),NO(n.shape,r.shape);let a={a:n,b:r};return fD.runKernel(w_,a)}});var YP=AD({mirrorPad_:function(e,t,n){FC("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));let r=TD(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");FC(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));let a="reflect"===n?1:0;for(let o=0;o<r.rank;o++)FC(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),FC(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`));let s={paddings:t,mode:n},i={x:r};return fD.runKernel(k_,i,s)}});var XP=AD({mod_:function(e,t){let n=TD(e,"a","mod"),r=TD(t,"b","mod");[n,r]=sD(n,r);let a={a:n,b:r};return fD.runKernel(S_,a)}});var QP=AD({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=YC(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=TD(e,"x","moments")).shape),r=jP(e,n,t),a=r.shape;t||(a=zO(r.shape,n));let s=YO(_P(eF(e,"float32"),FF(r,a)));return{mean:r,variance:jP(s,n,t)}}});var ZP=AD({multiRNNCell_:function(e,t,n,r){let a=TD(t,"data","multiRNNCell"),s=ND(n,"c","multiRNNCell"),i=ND(r,"h","multiRNNCell"),o=a,l=[];for(let d=0;d<e.length;d++){let t=e[d](o,s[d],i[d]);l.push(t[0]),l.push(t[1]),o=t[1]}let u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}});var JP=AD({multinomial_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=TD(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:1===i?FF(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=fD.runKernel(I_,o,l);return 1===i?FF(u,[u.size]):u}});var eL=AD({notEqual_:function(e,t){let n=TD(e,"a","notEqual","string_or_numeric"),r=TD(t,"b","notEqual","string_or_numeric");[n,r]=sD(n,r),NO(n.shape,r.shape);let a={a:n,b:r};return fD.runKernel(C_,a)}});var tL=AD({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:TD(e,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:n,offValue:r};return fD.runKernel(R_,s,i)}});var nL=AD({onesLike_:function(e){let t={x:TD(e,"x","onesLike")};return fD.runKernel($_,t)}});var rL=AD({outerProduct_:function(e,t){let n=TD(e,"v1","outerProduct"),r=TD(t,"v2","outerProduct");FC(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));let a=FF(n,[-1,1]),s=FF(r,[1,-1]);return zF(a,s)}});var aL=AD({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=TD(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return fD.runKernel(M_,s,a)}});var sL=AD({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return FC(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),aL(e,[t],n)}});var iL=AD({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return FC(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),aL(e,t,n)}});var oL=AD({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return FC(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),aL(e,t,n)}});var lL=AD({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return FC(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),aL(e,t,n)}});var uL=AD({spaceToBatchND_:function(e,t,n){let r=TD(e,"x","spaceToBatchND");FC(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),FC(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),FC(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));let a={x:r},s={blockShape:t,paddings:n};return fD.runKernel(f$,a,s)}});var cL=AD({pool_:function(e,t,n,r,a,s,i){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");let o=TD(e,"x","maxPool"),l=o,u=!1;3===o.rank&&(u=!0,l=FF(o,[1,o.shape[0],o.shape[1],o.shape[2]])),FC($F(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));let c,d=wF(l.shape,t,s,a,r),h=[d.dilationHeight,d.dilationWidth];c="same"===r?function(e,t){let n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),a=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],a[t]]))}([d.filterHeight,d.filterWidth],h):[[0,0],[0,0]];let p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){let r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),i=t.map(((e,t)=>(e-s[t]%e)%e)),o=a.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([d.inHeight,d.inWidth],h,c),g=p?r:"valid",y=p?l:uL(l,h,f),b=("avg"===n?()=>OF(y,t,s,g,i):()=>BP(y,t,s,g,i))(),v=p?b:jF(b,h,m);return u?FF(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});var dL=AD({prelu_:function(e,t){let n={x:TD(e,"x","prelu"),alpha:TD(t,"alpha","prelu")};return fD.runKernel(P_,n)}});var hL=AD({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=TD(e,"x","prod");"bool"===r.dtype&&(r=eF(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return fD.runKernel(L_,a,s)}});var pL=AD({raggedGather_:function(e,t,n,r){let a=e.map(((e,t)=>TD(e,`tensors${t}`,"raggedGather","int32"))),s={paramsNestedSplits:a,paramsDenseValues:TD(t,"paramsDenseValues","raggedGather"),indices:TD(n,"indices","raggedGather","int32")},i={outputRaggedRank:r},o=fD.runKernel(z_,s,i);return{outputNestedSplits:o.slice(0,o.length-1),outputDenseValues:o[o.length-1]}}});var fL=AD({raggedRange_:function(e,t,n){let r=TD(e,"starts","raggedRange"),a={starts:r,limits:TD(t,"limits","raggedRange",r.dtype),deltas:TD(n,"deltas","raggedRange",r.dtype)},s=fD.runKernel(B_,a);return{rtNestedSplits:s[0],rtDenseValues:s[1]}}});var mL=AD({raggedTensorToTensor_:function(e,t,n,r,a){let s=TD(e,"shape","raggedTensorToTensor","int32"),i=TD(t,"values","raggedTensorToTensor"),o={shape:s,values:i,defaultValue:TD(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>TD(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:a};return fD.runKernel(V_,o,l)}});var gL=AD({rand_:function(e,t,n){yA(e);let r=LC(e),a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let s=0;s<r;s++)a[s]=t();return fD.makeTensor(a,e,n)}}),yL=nC(fC()),bL={};tC(bL,{TEST_EPSILON_FLOAT16:()=>xL,createVideoElement:()=>$L,encodeStrings:()=>_L,expectArrayBuffersEqual:()=>EL,expectArraysClose:()=>wL,expectArraysEqual:()=>TL,expectNumbersClose:()=>NL,expectPromiseToFail:()=>IL,expectValuesInRange:()=>AL,play:()=>RL,testEpsilon:()=>kL});var vL=.001,xL=.1;function wL(e,t,n){return null==n&&(n=kL()),SL(e,t,((e,t)=>CL(e,t,n)))}function kL(){return 32===fD.backend.floatPrecision()?vL:xL}function SL(e,t,n){let r=!0;if((AR(e)||AR(t))&&(r=!1),AR(e)&&AR(t)&&(r=!0),r){let n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){let n=kD(e),r=kD(t);if(!VC(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}let a=AR(e)?e:ER(e),s=AR(t)?t:ER(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.\nActual:   ${a}.\nExpected: ${s}.`);for(let i=0;i<s.length;++i){let e=a[i],t=s[i];if(!n(e,t))throw new Error(`Arrays differ: actual[${i}] = ${e}, expected[${i}] = ${t}.\nActual:   ${a}.\nExpected: ${s}.`)}"undefined"!=typeof expect&&expect().nothing()}function IL(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!=typeof expect&&expect().nothing()}function TL(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return aA(e)||aA(e[0])||aA(t)||aA(t[0])?SL(e,n,((e,t)=>e==t)):SL(e,t,((e,t)=>CL(e,t,0)))}function NL(e,t,n){if(null==n&&(n=kL()),!CL(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function CL(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function AL(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function EL(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function _L(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?_L(n):e[t]=NR(n)}return e}function $L(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function RL(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}var DL=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let s=a||Math.random();this.random=yL.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},ML=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=yL.alea(a.toString()),this.randn=new DL(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}},FL=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=yL.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};var OL=AD({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;if(yA(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);let s=new ML(t,n,r,a),i=JM(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var PL=AD({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(yA(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);let s=new DL(t,n,r,!1,a),i=JM(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var LL=AD({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return PL(e,0,1,t,n)}});var zL=AD({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",a=arguments.length>4?arguments[4]:void 0;yA(e);let s=JM(e,r),i=new FL(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}});var BL=AD({randomUniformInt_:function(e,t,n,r){return zL(e,t,n,"int32",r)}});function VL(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return fD.runKernel(W_,{},a)}var WL=AD({real_:function(e){let t={input:TD(e,"input","real")};return fD.runKernel(U_,t)}});var UL=AD({reciprocal_:function(e){let t={x:TD(e,"x","reciprocal")};return fD.runKernel(j_,t)}});var jL=AD({relu_:function(e){let t={x:TD(e,"x","relu")};return fD.runKernel(G_,t)}});var GL=AD({relu6_:function(e){let t={x:TD(e,"x","relu6")};return fD.runKernel(Q_,t)}});var HL=AD({reverse_:function(e,t){let n={x:TD(e,"x","reverse")},r={dims:t};return fD.runKernel(Z_,n,r)}});var qL=AD({reverse1d_:function(e){let t=TD(e,"x","reverse");return FC(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),HL(t,0)}});var KL=AD({reverse2d_:function(e,t){let n=TD(e,"x","reverse");return FC(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),HL(n,t)}});var YL=AD({reverse3d_:function(e,t){let n=TD(e,"x","reverse");return FC(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),HL(n,t)}});var XL=AD({reverse4d_:function(e,t){let n=TD(e,"x","reverse");return FC(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),HL(n,t)}});var QL=AD({round_:function(e){let t={x:TD(e,"x","round")};return fD.runKernel(J_,t)}});var ZL=AD({rsqrt_:function(e){let t={x:TD(e,"x","rsqrt","float32")};return fD.runKernel(e$,t)}});var JL=AD({selu_:function(e){let t={x:TD(e,"x","selu")};return fD.runKernel(s$,t)}});var ez=AD({separableConv2d_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC",o=TD(e,"x","separableConv2d"),l=TD(t,"depthwiseFilter","separableConv2d"),u=TD(n,"pointwiseFilter","separableConv2d"),c=o,d=!1;if(3===o.rank&&(d=!0,c=FF(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");FC(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),FC(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),FC(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),FC(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),FC(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));let h=l.shape[2],p=l.shape[3];FC(u.shape[2]===h*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`));let f=xO(c,l,r,a,i,s),m=oO(f,u,1,"valid",i);return d?FF(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});var tz=async function(e,t){let n=TD(e,"x","setdiff1d"),r=TD(t,"y","setdiff1d");FC(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),FC(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),FC(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let c=0;c<a.length;c++)i.has(a[c])||o++;let l=new VR([o],n.dtype),u=new VR([o],"int32");for(let c=0,d=0;c<a.length;c++)i.has(a[c])||(l.values[d]=a[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]};var nz=AD({sign_:function(e){let t={x:TD(e,"x","sign")};return fD.runKernel(u$,t)}});var rz=AD({sin_:function(e){let t={x:TD(e,"x","sin","float32")};return fD.runKernel(o$,t)}});var az=AD({sinh_:function(e){let t={x:TD(e,"x","sinh")};return fD.runKernel(l$,t)}});var sz=AD({slice1d_:function(e,t,n){let r=TD(e,"x","slice1d");return FC(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),VF(r,[t],[n])}});var iz=AD({slice2d_:function(e,t,n){let r=TD(e,"x","slice2d");return FC(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),VF(r,t,n)}});var oz=AD({slice3d_:function(e,t,n){let r=TD(e,"x","slice3d");return FC(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),VF(r,t,n)}});var lz=AD({slice4d_:function(e,t,n){let r=TD(e,"x","slice4d");return FC(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),VF(r,t,n)}});var uz=AD({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=TD(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return fD.runKernel(g$,r,a)}});var cz=AD({fft_:function(e){FC("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));let t={input:e};return fD.runKernel(FE,t)}});var dz=AD({ifft_:function(e){FC("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));let t={input:e};return fD.runKernel(HE,t)}});var hz=AD({irfft_:function(e){let t,n=e.shape[e.shape.length-1],r=e.size/n;if(n<=2){let a=FF(e,[r,n]);t=dz(a)}else{let a=[r,2*(n-1)],s=FF(WL(e),[r,n]),i=FF(uP(e),[r,n]),o=HL(VF(s,[0,1],[r,n-2]),1),l=iF(HL(VF(i,[0,1],[r,n-2]),1),qO(-1)),u=LF([s,o],1),c=LF([i,l],1),d=FF(ED(u,c),[a[0],a[1]]);t=dz(d)}if(t=WL(t),3===e.rank&&0!==e.shape[0]){let n=t,r=e.shape[0];t=FF(t,[r,t.shape[0]/r,t.shape[1]]),n.dispose()}return t}});var pz=AD({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r={x:TD(e,"x","split")},a={numOrSizeSplits:t,axis:n};return fD.runKernel(m$,r,a)}});var fz=AD({rfft_:function(e,t){FC("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n,r=e.shape[e.shape.length-1],a=e.size/r;if(null!=t&&t<r){let a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,n=VF(e,a,s),r=t}else if(null!=t&&t>r){let a=e.shape.map((e=>e));a[e.shape.length-1]=t-r,n=LF([e,GP(a)],e.shape.length-1),r=t}else n=e;let s=EO(n),i=FF(ED(n,s),[a,r]),o=cz(i),l=Math.floor(r/2)+1,u=WL(o),c=uP(o),d=pz(u,[l,r-l],u.shape.length-1),h=pz(c,[l,r-l],c.shape.length-1),p=n.shape.slice();return p[n.shape.length-1]=l,FF(ED(d[0],h[0]),p)}});var mz=AD({squaredDifference_:function(e,t){let n=TD(e,"a","squaredDifference"),r=TD(t,"b","squaredDifference");[n,r]=sD(n,r),NO(n.shape,r.shape);let a={a:n,b:r};return fD.runKernel(k$,a,{})}});var gz=AD({squeeze_:function(e,t){let n=TD(e,"x","squeeze","string_or_numeric");return FF(n,XC(n.shape,t).newShape)}});var yz=AD({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=ND(e,"tensors","stack","string_or_numeric");FC(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&FC(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));let r=n,a={axis:t};return fD.runKernel(D_,r,a)}});var bz=AD({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n={x:TD(e,"x","step")},r={alpha:t};return fD.runKernel(V$,n,r)}});var vz=AD({stridedSlice_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,u={x:TD(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return fD.runKernel(T$,u,c)}});var xz=AD({tan_:function(e){let t={x:TD(e,"x","tan","float32")};return fD.runKernel(_$,t)}});function wz(e,t){PC(e);let n=kD(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return _D(e,null,n,t)}function kz(e,t,n){if(PC(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");let r=kD(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return _D(e,t,r,n)}function Sz(e,t,n){if(PC(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");let r=kD(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return _D(e,t,r,n)}function Iz(e,t,n){if(PC(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");let r=kD(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return _D(e,t,r,n)}function Tz(e,t,n){if(PC(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");let r=kD(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return _D(e,t,r,n)}function Nz(e,t,n){if(PC(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");let r=kD(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return _D(e,t=t||r,r,n)}var Cz={};function Az(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function Ez(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Az(n,t,e)}function _z(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let l=a;l<s;++l)i*=n[l];let o=a<1?1:a;return{sliceRank:a,numUpdates:LC(t.shape)/o,sliceSize:i,strides:[...cA(n.slice(0,a)),1],outputSize:LC(n)}}tC(Cz,{calculateShapes:()=>_z,validateInput:()=>Ez,validateUpdateShape:()=>Az});var $z=AD({tensorScatterUpdate_:function(e,t,n){let r=TD(e,"tensor","tensorScatterupdate"),a=TD(t,"indices","tensorScatterupdate","int32"),s=TD(n,"updates","tensorScatterupdate");if(Ez(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:a,updates:s};return fD.runKernel(n$,i,{})}});var Rz=AD({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=TD(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=fD.runKernel(D$,s,i);return{values:o,indices:l}}});var Dz=AD({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;if(yA(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");let s=new DL(t,n,r,!0,a),i=JM(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}});var Mz=AD({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=TD(e,"x","unique","string_or_numeric");FC(n.rank>0,(()=>"The input tensor must be at least 1D"));let r={x:n},a={axis:t},[s,i]=fD.runKernel(O$,r,a);return{values:s,indices:i}}});var Fz=AD({unsortedSegmentSum_:function(e,t,n){let r=TD(e,"x","unsortedSegmentSum"),a=TD(t,"segmentIds","unsortedSegmentSum","int32");FC(WC(n),(()=>"numSegments must be of dtype int"));let s={x:r,segmentIds:a},i={numSegments:n};return fD.runKernel(L$,s,i)}});var Oz=AD({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=TD(e,"x","unstack","string_or_numeric");FC(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));let r={value:n},a={axis:t};return fD.runKernel(P$,r,a)}});function Pz(e,t){return LP(e,t,"right")}function Lz(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return fD.makeVariable(e,t,n,r)}function zz(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let r=JM(e,"int32"),a=JM([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let t=r.indexToLoc(n[s]),i=s*e.length;a.values.set(t,i)}return a.toTensor()}var Bz=async function(e){let t=TD(e,"condition","whereAsync","bool"),n=await t.data(),r=zz(t.shape,n);return e!==t&&t.dispose(),r};var Vz=async function(e,t,n){let r=TD(e,"tensor","boolMask"),a=TD(t,"mask","boolMask","bool"),s=null==n?0:n,i=a.rank,o=r.shape;FC(i>0,(()=>"mask cannot be scalar")),OC(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];let u=o.slice(0,s).concat([l],o.slice(s+i)),c=FF(r,u),d=FF(a,[-1]),h=await Bz(d),p=gz(h,[1]),f=iP(c,p,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f};var Wz=AD({transpose_:function(e,t,n){let r=TD(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),FC(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{FC(e>=0&&e<r.rank,(()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`))})),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return"complex64"===r.dtype?WD((()=>{let e=WL(r),t=uP(r);return e=fD.runKernel(F$,{x:e},s),t=fD.runKernel(F$,{x:t},s),n&&(t=CP(t)),ED(e,t)})):fD.runKernel(F$,a,s)}});var Uz=AD({movingAverage_:function(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=TD(e,"v","movingAverage"),i=TD(t,"x","movingAverage"),o=TD(n,"decay","movingAverage");iD(s,i),FC(VC(s.shape,i.shape),(()=>"Shape mismatch in v and x"));let l=qO(1),u=_P(l,o),c=iF(_P(i,s),u);if(a){FC(null!=r,(()=>"When using zeroDebias: true, step is required."));let e=TD(r,"step","movingAverage");c=sF(c,_P(l,HO(o,e)))}return rF(s,c)}});var jz=AD({scatterND_:function(e,t,n){yA(n);let r=TD(e,"indices","scatterND","int32"),a=TD(t,"updates","scatterND");Ez(a,r,n);let s={indices:r,updates:a},i={shape:n};return fD.runKernel(t$,s,i)}});var Gz=AD({sparseToDense_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;yA(n);let a=TD(e,"sparseIndices","sparseToDense","int32"),s=TD(t,"sparseValues","sparseToDense","string_or_numeric"),i=TD(r,"defaultValue","sparseToDense",s.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(0!==t.rank&&(1!==t.rank||i!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return fD.runKernel(w$,o,l)}});var Hz=AD({gatherND_:function(e,t){let n=TD(t,"indices","gatherND","int32"),r={params:TD(e,"x","gatherND","string_or_numeric"),indices:n};return fD.runKernel(WE,r)}});var qz=AD({dropout_:function(e,t,n,r){let a=TD(e,"x","dropout");if(FC("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),FC(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof jR?a.clone():a;let s=function(e,t){if(null==t)return e.shape.slice();if(VC(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),i=1-t,o=sF(sP(rF(zL(s,0,1,"float32",r),i)),i);return iF(a,o)}});function Kz(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Yz(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return wz(a,"float32")}var Xz=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=TD(e,"predictions","inTopK"),a=TD(t,"targets","inTopK");FC(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),FC(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),OC(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];FC(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));let i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],c=QC("bool",l);for(let d=0;d<l;d++){let e=d*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),c[d]=0;for(let a=0;a<n;a++)if(r[a].index===o[d]){c[d]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),$D(c,a.shape,"bool")},Qz={};tC(Qz,{conv2d:()=>rB,depthwiseConv2d:()=>iB,matMul:()=>oB});var Zz=AD({conv2DBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=FF(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=FF(t,[1,t.shape[0],t.shape[1],t.shape[2]])),FC(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),FC(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),FC(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));let u="NHWC"===s?o.shape[3]:o.shape[1],c="NHWC"===s?l.shape[3]:l.shape[1];FC(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),FC(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),MF("conv2dDerFilter",a,i);let d={x:o,dy:l},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return fD.runKernel(iE,d,h)}});function Jz(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return iF(e,bz(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function eB(e,t){let n=t,r=TO(e.shape,t.shape);return r.length>0&&(n=XO(n,r)),FF(n,e.shape)}function tB(e,t,n,r){if("linear"===t)return e;if("relu"===t)return jL(e);if("elu"===t)return DO(e);if("relu6"===t)return GL(e);if("prelu"===t)return dL(e,n);if("leakyrelu"===t)return pP(e,r);if("sigmoid"===t)return BF(e);throw new Error(`Unknown fused activation ${t}.`)}var nB=(e,t)=>!(e>0)||"linear"===t;var rB=AD({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(u=u||"linear",!1===nB(fD.state.gradientDepth,u)){FC("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=oO(t,n,r,a,s,i,o);return null!=l&&(e=rF(e,l)),tB(e,u,c,d)}let h=TD(t,"x","conv2d","float32"),p=TD(n,"filter","conv2d","float32"),f=h,m=!1;3===h.rank&&(m=!0,f=FF(h,[1,h.shape[0],h.shape[1],h.shape[2]])),FC(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),FC(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),MF("fused conv2d",a,o);let g="NHWC"===s?f.shape[3]:f.shape[1];FC(p.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`)),FC($F(r,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`));let y,b,v=SF(f.shape,p.shape,r,i,a,o);if(null!=l&&(y=TD(l,"bias","fused conv2d"),[y]=sD(y,h),"NHWC"===s?NO(v.outShape,y.shape):(FC(y.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`)),FC(0===y.shape.length||y.shape[0]===v.outChannels||1===y.shape[0],(()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${v.outChannels})`)))),null!=c){let e=c.shape;if(FC(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)FC(1===e[0]||e[0]===v.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${v.outChannels}).`));else if(3===e.length)try{NO(e,v.outShape)}catch(Td){let n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${v.outShape}).`;throw Error(n)}b=TD(c,"prelu weights","fused conv2d")}let x=(e,t)=>{FC("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));let[n,o,l,c]=t,d=Jz(e,l,u);FC(_F(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));let h=[uO(o.shape,d,n,r,a),Zz(o,d,n.shape,r,a)];if(null!=c){let e=eB(c,d);h.push(e)}return h},w={x:f,filter:p,bias:y,preluActivationWeights:b},k={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};return null==l?TP(((e,t,n)=>{let r=fD.runKernel(G$,w,k);return n([t,e,r]),m&&(r=FF(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}))(f,p):TP(((e,t,n,r)=>{let a=fD.runKernel(G$,w,k);return r([t,e,a,n]),m&&(a=FF(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}))(f,p,y)}});var aB=AD({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=FF(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=FF(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return fD.runKernel(vE,u,c)}});var sB=AD({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,l=!1;3===t.rank&&(l=!0,o=FF(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},d=fD.runKernel(xE,u,c);return l?FF(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});var iB=AD({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:r,pad:a,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(!1===nB(fD.state.gradientDepth,u)){let e=xO(t,n,r,a,s,i,o);return null!=l&&(e=rF(e,l)),tB(e,u,c,d)}let h=TD(t,"x","depthwiseConv2d","float32"),p=TD(n,"filter","depthwiseConv2d","float32"),f=h,m=!1;3===h.rank&&(m=!0,f=FF(h,[1,h.shape[0],h.shape[1],h.shape[2]])),FC(4===f.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`)),FC(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),FC(f.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==i&&(i=[1,1]),FC($F(r,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`)),MF("fused depthwiseConv2d",a,o);let g,y,b=SF(f.shape,p.shape,r,i,a,o,!0);null!=l&&(g=TD(l,"bias","fused conv2d"),[g]=sD(g,h),NO(b.outShape,g.shape)),null!=c&&(y=TD(c,"prelu weights","fused depthwiseConv2d"));let v=(e,t)=>{FC(_F(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));let[n,s,l,c]=t,d=Jz(e,l,u),h=sB(s.shape,d,n,r,a,i,o),p=aB(s,d,n.shape,r,a,i,o);if(null!=c){return[h,p,eB(g,d)]}return[h,p]},x={x:f,filter:p,bias:g,preluActivationWeights:y},w={strides:r,pad:a,dataFormat:s,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};return null==l?TP(((e,t,n)=>{let r=fD.runKernel(H$,x,w);return n([t,e,r]),m&&(r=FF(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}))(f,p):TP(((e,t,n,r)=>{let a=fD.runKernel(H$,x,w);return r([t,e,a,n]),m&&(a=FF(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}))(f,p,g)}});var oB=AD({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:a=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}=e;if(!1===nB(fD.state.gradientDepth,i)){let e=zF(t,n,r,a);return null!=s&&(e=rF(e,s)),tB(e,i,o,l)}let u=TD(t,"a","fused matMul"),c=TD(n,"b","fused matMul");[u,c]=sD(u,c);let d=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=a?c.shape[c.rank-1]:c.shape[c.rank-2],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=a?c.shape[c.rank-2]:c.shape[c.rank-1],m=u.shape.slice(0,-2),g=c.shape.slice(0,-2),y=LC(m),b=LC(g);FC(d===h,(()=>`Error in fused matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${r} and transposeB=${a} must match.`));let v,x,w=NO(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),k=FF(u,r?[y,d,p]:[y,p,d]),S=FF(c,a?[b,f,h]:[b,h,f]);null!=s&&(v=TD(s,"bias","fused matMul"),[v]=sD(v,u),NO(w,v.shape)),null!=o&&(x=TD(o,"prelu weights","fused matMul"));let I=(e,t)=>{let n,o,[l,u,c,d]=t,h=Jz(FF(e,c.shape),c,i);if(r||a?!r&&a?(n=zF(h,u,!1,!1),o=zF(h,l,!0,!1)):r&&!a?(n=zF(u,h,!1,!0),o=zF(l,h,!1,!1)):(n=zF(u,h,!0,!0),o=zF(h,l,!0,!0)):(n=zF(h,u,!1,!0),o=zF(l,h,!0,!1)),null!=s){return[n,o,eB(d,h)]}return[n,o]},T={a:k,b:S,bias:v,preluActivationWeights:x},N={transposeA:r,transposeB:a,activation:i,leakyreluAlpha:l};return null==s?TP(((e,t,n)=>{let r=fD.runKernel(j$,T,N);return n([e,t,r]),{value:FF(r,w),gradFunc:I}}))(k,S):TP(((e,t,n,r)=>{let a=fD.runKernel(j$,T,N);return r([e,t,a,n]),{value:FF(a,w),gradFunc:I}}))(k,S,v)}});var lB=AD({hammingWindow_:function(e){return Yz(e,.54,.46)}});var uB=AD({hannWindow_:function(e){return Yz(e,.5,.5)}});var cB=AD({frame_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0,i=[];for(;s+t<=e.size;)i.push(VF(e,s,t)),s+=n;if(r)for(;s<e.size;){let r=s+t-e.size,o=LF([VF(e,s,t-r),tO([r],a)]);i.push(o),s+=n}return 0===i.length?kz([],[0,t]):FF(LF(i),[i.length,t])}});var dB=AD({stft_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:uB;null==r&&(r=Kz(t));let s=cB(e,t,n),i=iF(s,a(t));return fz(i,r)}});var hB=AD({cropAndResize_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=TD(e,"image","cropAndResize"),o=TD(t,"boxes","cropAndResize","float32"),l=TD(n,"boxInd","cropAndResize","int32"),u=o.shape[0];FC(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),FC(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),FC(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),FC(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),FC(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),FC("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));let c={image:i,boxes:o,boxInd:l},d={method:a,extrapolationValue:s,cropSize:r};return fD.runKernel(mE,c,d)}});var pB=AD({flipLeftRight_:function(e){let t=TD(e,"image","flipLeftRight","float32");FC(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));let n={image:t};return fD.runKernel(PE,n,{})}});var fB=AD({grayscaleToRGB_:function(e){let t=TD(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];FC(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),FC(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,rP(t,a)}});var mB=AD({rgbToGrayscale_:function(e){let t=TD(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];FC(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),FC(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));let a,s=t.dtype,i=eF(t,"float32"),o=wz([.2989,.587,.114]);switch(t.rank){case 2:a=RO("ij,j->i",i,o);break;case 3:a=RO("ijk,k->ij",i,o);break;case 4:a=RO("ijkl,l->ijk",i,o);break;case 5:a=RO("ijklm,m->ijkl",i,o);break;case 6:a=RO("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=tP(a,-1),eF(a,s)}});var gB=AD({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=TD(e,"image","rotateWithOffset","float32");FC(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));let s={image:a},i={radians:t,fillValue:n,center:r};return fD.runKernel(U$,s,i)}});function yB(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);let i=e.shape[0];return n=Math.min(n,i),FC(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),FC(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),FC(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),FC(1===t.rank,(()=>"scores must be a 1D tensor")),FC(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),FC(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}var bB=AD({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=TD(e,"boxes","nonMaxSuppression","float32"),i=TD(t,"scores","nonMaxSuppression","float32"),o=yB(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return fD.runKernel(A_,{boxes:s,scores:i},l)}});function vB(e,t,n){let r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}(e,t,n||xB)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function xB(e,t){return e>t?1:e<t?-1:0}function wB(e,t,n,r,a){return IB(e,t,n,r,a,0)}function kB(e,t,n,r,a,s){return IB(e,t,n,r,a,0,!1,s,!0)}function SB(e,t,n,r,a,s){return IB(e,t,n,r,a,s,!0)}function IB(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8],u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(CB);let c=s>0?-.5/s:0,d=[],h=[];for(;d.length<n&&u.length>0;){let t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<a)break;let o=!1;for(let l=d.length-1;l>=i;--l){let n=TB(e,s,d[l]);if(n>=r){o=!0;break}if(t.score=t.score*NB(r,c,n),t.score<=a)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(s),h.push(t.score)):t.score>a&&vB(u,t,CB))}let p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));let m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function TB(e,t,n){let r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),h=Math.max(a[1],a[3]),p=(o-s)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;let m=Math.max(s,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function NB(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function CB(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}var AB=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=TD(e,"boxes","nonMaxSuppressionAsync"),i=TD(t,"scores","nonMaxSuppressionAsync"),o=yB(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=wB(u,c,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),wz(d,"int32")};var EB=AD({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=TD(e,"boxes","nonMaxSuppression"),o=TD(t,"scores","nonMaxSuppression"),l=yB(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},d=fD.runKernel(__,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}});var _B=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=TD(e,"boxes","nonMaxSuppressionAsync"),o=TD(t,"scores","nonMaxSuppressionAsync"),l=yB(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=SB(c,d,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:wz(h,"int32"),selectedScores:wz(p)}};var $B=AD({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=TD(e,"boxes","nonMaxSuppression"),o=TD(t,"scores","nonMaxSuppression"),l=yB(i,o,n,r,a,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:s},d=fD.runKernel(E_,u,c);return{selectedIndices:d[0],validOutputs:d[1]}}});var RB=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=TD(e,"boxes","nonMaxSuppressionAsync"),o=TD(t,"scores","nonMaxSuppressionAsync"),l=yB(i,o,n,r,a,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=kB(h,p,u,c,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:wz(f,"int32"),validOutputs:qO(m,"int32")}};var DB=AD({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=TD(e,"images","resizeBilinear");FC(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),FC(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),FC(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=FF(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=fD.runKernel(Y_,o,l);return i?FF(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var MB=AD({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=TD(e,"images","resizeNearestNeighbor");FC(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),FC(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),FC("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),FC(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=FF(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=fD.runKernel(q_,o,l);return i?FF(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});var FB=AD({threshold_:function(e){let t,n,r,a,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,l=TD(e,"image","threshold"),u=l.shape[0]*l.shape[1],c=iF(wz([o]),255);if(FC(3===l.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`)),FC(3===l.shape[2]||1===l.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`)),FC("int32"===l.dtype||"float32"===l.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`)),FC("otsu"===s||"binary"===s,(()=>`Method must be binary or otsu, but was ${s}`)),3===l.shape[2]){[t,n,r]=pz(l,[1,1,1],-1);let e=iF(t,.2989),s=iF(n,.587),i=iF(r,.114);a=rF(rF(e,s),i)}else a=e;if("otsu"===s){c=function(e,t){let n,r,a,s,i,o,l=wz([-1]),u=wz([0]),c=wz([0]);for(let d=0;d<e.size-1;d++){n=VF(e,0,d+1),r=VF(e,d+1),i=sF(XO(n),t),o=sF(XO(r),t);let h=XO(iF(n,VL(0,n.size)));a=sF(h,XO(n));let p=tO(r.shape,n.size),f=rF(VL(0,r.size),p),m=iF(r,f);s=sF(XO(m),XO(r));let g=_P(a,s),y=_P(a,s),b=iF(i,o);c=iF(iF(b,g),y);let v=oP(c,u);u=AO(v,c,u),l=AO(v,wz([d]),l)}return l}(XF(eF(QL(a),"int32"),$D([]),256),u)}let d=i?mP(a,c):oP(a,c);return eF(iF(d,255),"int32")}});var OB=AD({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0,i=TD(e,"image","transform","float32"),o=TD(t,"transforms","transform","float32");FC(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),FC(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),FC(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));let l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return fD.runKernel(M$,l,u)}});var PB=AD({bandPart_:function(e,t,n){let r=TD(e,"a","bandPart");FC(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));let a,s,i=r.shape,[o,l]=r.shape.slice(-2);"number"==typeof t?(FC(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),FC(t<=o,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`)),a=TD(t<0?o:t,"numLower","bandPart")):(FC("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),a=AO(fP(t,0),o,KP(t,o))),"number"==typeof n?(FC(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),FC(n<=l,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${l}).`)),s=TD(n<0?l:n,"numUpper","bandPart")):(FC("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),s=AO(fP(n,0),l,KP(n,l)));let u=FF(VL(0,o,1,"int32"),[-1,1]),c=VL(0,l,1,"int32"),d=_P(u,c),h=DP(mP(d,a),lP(d,CP(s))),p=GP([o,l],r.dtype);return FF(yz(Oz(FF(r,[-1,o,l])).map((e=>AO(h,e,p)))),i)}});var LB=AD({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,FC(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));let n=e[0].shape[0];for(let t=1;t<e.length;++t)FC(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=pz(e,e.shape[0],0).map((e=>gz(e,[0])));FC(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));let n=[],r=e;for(let a=0;a<e.length;++a)n.push(fD.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){let r=iF(XO(iF(n[t],e)),n[t]);e=_P(e,r)}return sF(e,ZO(e,"euclidean"))})));return t?yz(n,0):n}});function zB(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return fD.tidy((()=>{FC(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));let n=e.shape[0],r=e.shape[1],a=aP(n),s=tF(e),i=kz([[1]],[1,1]),o=tF(i),l=n>=r?r:n;for(let e=0;e<l;++e){let t=s,l=o,u=a;[o,s,a]=fD.tidy((()=>{let t=VF(s,[e,e],[n-e,1]),l=ZO(t),u=VF(s,[e,e],[1,1]),c=AO(oP(u,0),kz([[-1]]),kz([[1]])),d=_P(u,iF(c,l)),h=sF(t,d);o=1===h.shape[0]?tF(i):LF([i,VF(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);let p=CP(sF(zF(c,d),l)),f=VF(s,[e,0],[n-e,r]),m=iF(p,o),g=Wz(o);if(0===e)s=_P(f,zF(m,zF(g,f)));else{let t=_P(f,zF(m,zF(g,f)));s=LF([VF(s,[0,0],[e,r]),t],0)}let y=Wz(m),b=VF(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=_P(b,zF(zF(b,o),y));else{let t=_P(b,zF(zF(b,o),y));a=LF([VF(a,[0,0],[n,e]),t],1)}return[o,s,a]})),UD([t,l,u])}return!t&&n>r&&(a=VF(a,[0,0],[n,r]),s=VF(s,[0,0],[r,r])),[a,s]}))}var BB,VB=AD({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(FC(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return zB(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=Oz(FF(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];return r.forEach((e=>{let[n,r]=zB(e,t);a.push(n),s.push(r)})),[FF(yz(a,0),e.shape),FF(yz(s,0),e.shape)]}}});!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(BB||(BB={}));var WB=AD({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:BB.SUM_BY_NONZERO_WEIGHTS,r=TD(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=TD(t,"weights","computeWeightedLoss"));let s=null==a?r:iF(r,a);if(n===BB.NONE)return s;if(n===BB.SUM)return XO(s);if(n===BB.MEAN){if(null==a)return jP(s);{let e=r.size/a.size,t=sF(XO(s),XO(a));return e>1?sF(t,qO(e)):t}}if(n===BB.SUM_BY_NONZERO_WEIGHTS){if(null==a)return sF(XO(s),qO(r.size));{let e=iF(a,HP(r.shape)),t=eF(XO(eL(e,qO(0))),"float32");return sF(XO(s),t)}}throw Error(`Unknown reduction: ${n}`)}});var UB=AD({absoluteDifference_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:BB.SUM_BY_NONZERO_WEIGHTS,a=TD(e,"labels","absoluteDifference"),s=TD(t,"predictions","absoluteDifference"),i=null;null!=n&&(i=TD(n,"weights","absoluteDifference")),OC(a.shape,s.shape,"Error in absoluteDifference: ");let o=oF(_P(a,s));return WB(o,i,r)}});var jB=AD({cosineDistance_:function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:BB.SUM_BY_NONZERO_WEIGHTS,s=TD(e,"labels","cosineDistance"),i=TD(t,"predictions","cosineDistance"),o=null;null!=r&&(o=TD(r,"weights","cosineDistance")),OC(s.shape,i.shape,"Error in cosineDistance: ");let l=qO(1),u=_P(l,XO(iF(s,i),n,!0));return WB(u,o,a)}});var GB=AD({hingeLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:BB.SUM_BY_NONZERO_WEIGHTS,a=TD(e,"labels","hingeLoss"),s=TD(t,"predictions","hingeLoss"),i=null;null!=n&&(i=TD(n,"weights","hingeLoss")),OC(a.shape,s.shape,"Error in hingeLoss: ");let o=qO(1);a=_P(iF(qO(2),a),o);let l=jL(_P(o,iF(a,s)));return WB(l,i,r)}});var HB=AD({huberLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:BB.SUM_BY_NONZERO_WEIGHTS,s=TD(e,"labels","huberLoss"),i=TD(t,"predictions","huberLoss"),o=null;null!=n&&(o=TD(n,"weights","huberLoss")),OC(s.shape,i.shape,"Error in huberLoss: ");let l=qO(r),u=oF(_P(i,s)),c=KP(u,l),d=_P(u,c),h=rF(iF(qO(.5),YO(c)),iF(l,d));return WB(h,o,a)}});var qB=AD({logLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:BB.SUM_BY_NONZERO_WEIGHTS,s=TD(e,"labels","logLoss"),i=TD(t,"predictions","logLoss"),o=null;null!=n&&(o=TD(n,"weights","logLoss")),OC(s.shape,i.shape,"Error in logLoss: ");let l=qO(1),u=qO(r),c=CP(iF(s,bP(rF(i,u)))),d=iF(_P(l,s),bP(rF(_P(l,i),u))),h=_P(c,d);return WB(h,o,a)}});var KB=AD({meanSquaredError_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:BB.SUM_BY_NONZERO_WEIGHTS,a=TD(e,"labels","meanSquaredError"),s=TD(t,"predictions","meanSquaredError"),i=null;null!=n&&(i=TD(n,"weights","meanSquaredError")),OC(a.shape,s.shape,"Error in meanSquaredError: ");let o=mz(a,s);return WB(o,i,r)}});var YB=AD({sigmoidCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:BB.SUM_BY_NONZERO_WEIGHTS,s=TD(e,"multiClassLabels","sigmoidCrossEntropy"),i=TD(t,"logits","sigmoidCrossEntropy"),o=null;if(null!=n&&(o=TD(n,"weights","sigmoidCrossEntropy")),OC(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let e=qO(r),t=qO(1),n=qO(.5);s=rF(iF(s,_P(t,e)),iF(n,e))}let l=function(e,t){let n=TD(e,"labels","sigmoidCrossEntropyWithLogits"),r=TD(t,"logits","sigmoidCrossEntropyWithLogits");OC(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=jL(r),s=iF(r,n),i=vP(eP(CP(oF(r))));return rF(_P(a,s),i)}(s,i);return WB(l,o,a)}});var XB=AD({softmaxCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:BB.SUM_BY_NONZERO_WEIGHTS,s=TD(e,"onehotLabels","softmaxCrossEntropy"),i=TD(t,"logits","softmaxCrossEntropy"),o=null;if(null!=n&&(o=TD(n,"weights","softmaxCrossEntropy")),OC(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let e=qO(r),t=qO(1),n=qO(s.shape[1]);s=rF(iF(s,_P(t,e)),sF(e,n))}let l=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return TP(((e,t,r)=>{let a=RP(t,[n],!0),s=_P(eF(t,"float32"),a);r([e,s]);let i=CP(iF(s,e));return{value:XO(i,[n]),gradFunc:(e,t)=>{let[r,a]=t,s=zO(e.shape,[n]);return[iF(FF(e,s),_P(eF(r,"float32"),eP(a))),iF(FF(e,s),_P(eP(a),eF(r,"float32")))]}}}))(e,t)}(s,i);return WB(l,o,a)}});var QB=AD({sparseFillEmptyRows_:function(e,t,n,r){let a=TD(e,"indices","sparseFillEmptyRows","int32"),s=TD(t,"values","sparseFillEmptyRows"),i=TD(n,"denseShape","sparseFillEmptyRows","int32"),o=TD(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},u=fD.runKernel(y$,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});var ZB=AD({sparseReshape_:function(e,t,n){let r=TD(e,"inputIndices","sparseReshape","int32"),a=TD(t,"inputShape","sparseReshape","int32"),s=TD(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=fD.runKernel(b$,i);return{outputIndices:o[0],outputShape:o[1]}}});var JB=AD({sparseSegmentMean_:function(e,t,n){let r=TD(e,"data","sparseSegmentMean"),a=TD(t,"indices","sparseSegmentMean","int32"),s=TD(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return fD.runKernel(v$,i)}});var eV=AD({sparseSegmentSum_:function(e,t,n){let r=TD(e,"data","sparseSegmentSum"),a=TD(t,"indices","sparseSegmentSum","int32"),s=TD(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return fD.runKernel(x$,i)}});var tV=AD({stringNGrams_:function(e,t,n,r,a,s,i,o){let l=TD(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=TD(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=fD.runKernel(N$,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}});var nV=AD({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=TD(e,"input","stringSplit","string"),a=TD(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=fD.runKernel(C$,i,s);return{indices:o[0],values:o[1],shape:o[2]}}});var rV=AD({stringToHashBucketFast_:function(e,t){let n=TD(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return fD.runKernel(A$,a,r)}});var aV=AD({staticRegexReplace_:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=TD(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:n,replaceGlobal:r};return fD.runKernel(I$,{x:a},s)}}),sV={fft:cz,ifft:dz,rfft:fz,irfft:hz},iV={hammingWindow:lB,hannWindow:uB,frame:cB,stft:dB},oV={flipLeftRight:pB,grayscaleToRGB:fB,resizeNearestNeighbor:MB,resizeBilinear:DB,rgbToGrayscale:mB,rotateWithOffset:gB,cropAndResize:hB,nonMaxSuppression:bB,nonMaxSuppressionAsync:AB,nonMaxSuppressionWithScore:EB,nonMaxSuppressionWithScoreAsync:_B,nonMaxSuppressionPadded:$B,nonMaxSuppressionPaddedAsync:RB,threshold:FB,transform:OB},lV={bandPart:PB,gramSchmidt:LB,qr:VB},uV={absoluteDifference:UB,computeWeightedLoss:WB,cosineDistance:jB,hingeLoss:GB,huberLoss:HB,logLoss:qB,meanSquaredError:KB,sigmoidCrossEntropy:YB,softmaxCrossEntropy:XB},cV={sparseFillEmptyRows:QB,sparseReshape:ZB,sparseSegmentMean:JB,sparseSegmentSum:eV},dV={stringNGrams:tV,stringSplit:nV,stringToHashBucketFast:rV,staticRegexReplace:aV},hV={};tC(hV,{Serializable:()=>mV,SerializationMap:()=>gV,getRegisteredName:()=>bV,registerClass:()=>yV});var pV=new Map,fV=new Map,mV=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},gV=class e{constructor(){this.classNameMap={}}static getMap(){return null==e.instance&&(e.instance=new e),e.instance}static register(t){e.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function yV(e,t,n){FC(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),FC("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),FC(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"==typeof t&&(t="Custom"),"undefined"==typeof n&&(n=e.className);let r=t+">"+n;return gV.register(e),pV.set(r,e),fV.set(e,r),e}function bV(e){return fV.has(e)?fV.get(e):e.className}var vV=class extends mV{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0,{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){let e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return UD(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return IP(e,t)}dispose(){null!=this.iterations_&&UD(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:qO(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(vV,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var xV=class extends vV{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=fD.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=fD.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:WD((()=>EO(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:WD((()=>EO(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;WD((()=>{let e=rF(iF(i,this.rho),iF(YO(s),1-this.rho)),t=iF(sF(KO(rF(o,this.epsilon)),KO(rF(i,this.epsilon))),s),n=rF(iF(o,this.rho),iF(YO(t),1-this.rho));i.assign(e),o.assign(n);let a=rF(iF(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(UD(this.accumulatedGrads.map((e=>e.variable))),UD(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){let t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},wV=class extends vV{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=fD.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:WD((()=>tO(r.shape,this.initialAccumulatorValue).variable(!1)))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[n].variable;WD((()=>{let e=rF(s,YO(a));s.assign(e);let t=rF(iF(sF(a,KO(rF(e,fD.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&UD(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},kV=class extends vV{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],WD((()=>{this.accBeta1=qO(t).variable(),this.accBeta2=qO(n).variable()})),null==r&&(this.epsilon=fD.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);WD((()=>{let n=_P(1,this.accBeta1),r=_P(1,this.accBeta2);t.forEach(((t,a)=>{let s=fD.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:WD((()=>EO(s).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:WD((()=>EO(s).variable(i)))});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,c=rF(iF(l,this.beta1),iF(o,1-this.beta1)),d=rF(iF(u,this.beta2),iF(YO(o),1-this.beta2)),h=sF(c,n),p=sF(d,r);l.assign(c),u.assign(d);let f=rF(iF(sF(h,rF(KO(p),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(iF(this.accBeta1,this.beta1)),this.accBeta2.assign(iF(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&UD(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&UD(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),WD((()=>{this.accBeta1.assign(HO(this.beta1,this.iterations_+1)),this.accBeta2.assign(HO(this.beta2,this.iterations_+1))}));let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},SV=class extends vV{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],WD((()=>{this.iteration=qO(0).variable(),this.accBeta1=qO(t).variable()})),null==r&&(this.epsilon=fD.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);WD((()=>{let n=_P(1,this.accBeta1),r=sF(-this.learningRate,rF(iF(this.iteration,this.decay),1));t.forEach(((t,a)=>{let s=fD.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:EO(s).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:EO(s).variable(i)});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,c=rF(iF(l,this.beta1),iF(o,1-this.beta1)),d=iF(u,this.beta2),h=oF(o),p=UP(d,h);l.assign(c),u.assign(p);let f=rF(iF(sF(r,n),sF(c,rF(p,this.epsilon))),s);s.assign(f)})),this.iteration.assign(rF(this.iteration,1)),this.accBeta1.assign(iF(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&UD(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&UD(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},IV=class extends vV{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let a=fD.registeredVariables[t];WD((()=>{let e=rF(iF(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=jD(qO(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},TV=class extends IV{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=qO(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=fD.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:WD((()=>EO(r).variable(!1)))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&WD((()=>{let e,t=rF(iF(this.m,a),s);e=this.useNesterov?rF(iF(this.c,rF(s,iF(t,this.m))),r):rF(iF(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&UD(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},NV=class extends vV{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=fD.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=fD.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:WD((()=>EO(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:WD((()=>EO(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:WD((()=>EO(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;WD((()=>{let e=rF(iF(i,this.decay),iF(YO(s),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,a=rF(iF(t,this.decay),iF(s,1-this.decay)),l=sF(iF(s,this.learningRate),KO(_P(e,rF(YO(a),this.epsilon)))),u=rF(iF(o,this.momentum),l);i.assign(e),t.assign(a),o.assign(u);let c=_P(r,u);r.assign(c)}else{let e=rF(iF(i,this.decay),iF(YO(s),1-this.decay)),t=rF(iF(o,this.momentum),sF(iF(s,this.learningRate),KO(rF(e,this.epsilon))));i.assign(e),o.assign(t);let n=_P(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&UD(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&UD(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&UD(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},CV=[xV,wV,kV,SV,TV,NV,IV];var AV={};tC(AV,{CompositeArrayBuffer:()=>DD,browserFiles:()=>RV,browserHTTPRequest:()=>VV,concatenateArrayBuffers:()=>hM,copyModel:()=>YM,decodeWeights:()=>rM,decodeWeightsStream:()=>lM,encodeWeights:()=>nM,fromMemory:()=>GV,fromMemorySync:()=>HV,getLoadHandlers:()=>SM,getModelArtifactsForJSON:()=>gM,getModelArtifactsForJSONSync:()=>mM,getModelArtifactsInfoForJSON:()=>yM,getSaveHandlers:()=>kM,getWeightSpecs:()=>bM,http:()=>BV,isHTTPScheme:()=>LV,listModels:()=>qM,loadWeights:()=>FV,moveModel:()=>XM,registerLoadRouter:()=>wM,registerSaveRouter:()=>xM,removeModel:()=>KM,weightsLoaderFactory:()=>OV,withSaveHandler:()=>qV,withSaveHandlerSync:()=>KV});function EV(e){return new Promise((e=>setTimeout(e))).then(e)}var _V=class e{constructor(t){if(!IA().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),(null==t||0===t.length)&&(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=DD.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=fM(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await EV((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await EV((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:yM(e)}}}};_V.URL_SCHEME="downloads://";var $V=class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});let s=gM(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{let a=new FileReader;a.onload=e=>{let t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map((e=>pM(e.name))),r={};for(let a of e)a.paths.forEach((e=>{let a=pM(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}};function RV(e){return new $V(e)}function DV(e,t,n,r){var a;FC(null!=(a=e)&&Array.isArray(a)&&a.length>0,(()=>"promises must be a none empty array")),function(e,t){FC(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),FC(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),FC(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((a=>(a.then((a=>{let i=n+ ++s/e.length*(r-n);return t(i),a})),a))))}async function MV(e,t){null==t&&(t={});let n=null==t.fetchFunc?IA().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await DV(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await DV(a,t.onProgress,.5,1)}async function FV(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return OV((e=>MV(e,{requestInit:r})))(e,t,n)}function OV(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0,a=t.map((()=>!1)),s={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{let l="quantization"in e?e.quantization.dtype:e.dtype,u=RD[l]*LC(e.shape),c=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){let e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{let t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));let c=await e(u),d={},h=0;return l.forEach((e=>{let n=t[e].paths.length,r=new DD(c.slice(h,h+n));s[e].forEach((e=>{let t=rM(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(let n in t)d[n]=t[n]})),h+=n})),d}}vM.registerSaveRouter((e=>IA().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(_V.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new _V(e)}(e.slice(_V.URL_SCHEME.length)):null));var PV=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(FC("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=IA().platform.fetch,FC(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&FC(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=fM(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){let n=DD.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:yM(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(gge){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}let n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return gM(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=bM(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;let r,a=null==t.fetchFunc?IA().platform.fetch:t.fetchFunc,s=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;s<e.length;){r||(r=(await a(e[s],t.requestInit,{isBinary:!0})).body.getReader());let{done:o,value:l}=await r.read();if(!o)return void n.enqueue(l);s++,r=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,s/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,s=[],i=[];for(let o of e)for(let e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):s.push(a+e+r);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e);return[bM(e),await MV(t,this.loadOptions)]}};function LV(e){return null!=e.match(PV.URL_SCHEME_REGEX)}PV.URL_SCHEME_REGEX=/^https?:\/\//;var zV=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>LV(e))):LV(e),n)return BV(e,t)}return null};function BV(e,t){return new PV(e,t)}function VV(e,t){return BV(e,t)}vM.registerSaveRouter(zV),vM.registerLoadRouter(zV);var WV=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},UV=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},jV=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function GV(e,t,n,r){return new jV(HV(...arguments))}function HV(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new WV(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new WV({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new WV({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function qV(e){return new UV(e)}function KV(e){return new UV(e)}var YV={};tC(YV,{confusionMatrix:()=>XV});var XV=AD({confusionMatrix_:function(e,t,n){let r=TD(e,"labels","confusionMatrix"),a=TD(t,"predictions","confusionMatrix");FC(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),FC(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),FC(1===a.rank,(()=>`Expected the rank of predictions to be 1, but got ${a.rank}`)),FC(r.shape[0]===a.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`)),FC(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));let s=tL(eF(r,"int32"),n),i=tL(eF(a,"int32"),n),o=Wz(s),l=zF(o,i);return eF(l,"int32")}}),QV={};tC(QV,{draw:()=>sW,fromPixels:()=>iW,fromPixelsAsync:()=>nW,toPixels:()=>aW});var ZV,JV=!1;function eW(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=Q$(W$,fD.backendName)){let n={pixels:e},r={numChannels:t};return fD.runKernel(W$,n,r)}let l,u,[c,d]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(i)l=e.getContext("2d").getImageData(0,0,c,d).data;else if(r||n)l=e.data;else if(s||a||o){if(null==ZV)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");ZV=new OffscreenCanvas(1,1).getContext("2d")}else ZV=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ZV.canvas.width=c,ZV.canvas.height=d,ZV.drawImage(e,0,0,c,d),l=ZV.getImageData(0,0,c,d).data}if(4===t)u=new Int32Array(l);else{let e=c*d;u=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)u[n*t+e]=l[4*n+e]}return Sz(u,[d,c,t],"int32")}function tW(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function nW(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,n=null;if(IA().getBool("WRAP_TO_IMAGEBITMAP")&&tW(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(gge){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return eW(n,t)}function rW(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function aW(e,t){let n=TD(e,"img","toPixels");if(!(e instanceof jR)){let e=n;n=eF(e,"int32"),e.dispose()}rW(n);let[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){let e=[0,0,0,255];for(let r=0;r<s;r++){let t=i[u*s+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===s?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[r]=t*o}let t=4*u;l[t+0]=Math.round(e[0]),l[t+1]=Math.round(e[1]),l[t+2]=Math.round(e[2]),l[t+3]=Math.round(e[3])}if(null!=t){JV||null!=Q$(TE,fD.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),JV=!0),t.width=a,t.height=r;let e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function sW(e,t,n){let r=TD(e,"img","draw");if(!(e instanceof jR)){let e=r;r=eF(e,"int32"),e.dispose()}rW(r),function(e){let t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);let a={image:r},s={canvas:t,options:n};fD.runKernel(TE,a,s)}var iW=AD({fromPixels_:eW}),oW={};function lW(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===LC(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let d=0;d<a.length-1;++d)i*=a[d];let o=e.shape,l=a.slice();l.pop();let u=1;for(let d=s;d<n;++d)u*=o[d],l.push(o[d]);let c=[...cA(e.shape).map((e=>e/u)),1].slice(0,s);return[l,i,u,c]}tC(oW,{prepareAndValidate:()=>lW});var uW={};tC(uW,{assertParamsValid:()=>hW,computeFlatOffset:()=>TW,computeOutShape:()=>fW,getNormalizedAxes:()=>bW,isSliceContinous:()=>IW,maskToAxes:()=>pW,parseSliceParams:()=>NW,sliceInfo:()=>CW,startForAxis:()=>kW,startIndicesWithElidedDims:()=>vW,stopForAxis:()=>SW,stopIndicesWithElidedDims:()=>xW,stridesForAxis:()=>wW,stridesWithElidedDims:()=>mW});var cW=-2,dW=-1;function hW(e,t,n){let r=e.shape.length;FC(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),FC(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)FC(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function pW(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function fW(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function mW(e,t,n,r){let a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[t]=1:(a.splice(t,0,1),a.pop());return a}function gW(e,t,n){return n<=e?n:n-(t-1)}function yW(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function bW(e,t,n,r,a,s,i,o,l){let u=e.length,c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){let l=t[0],u=n+1;c=vW(i,l,u,r,e),d=xW(o,l,u,a,e),h=mW(s,l,u,e)}else for(let p=0;p<u;p++)c[p]=kW(i,r,s,e,p,l),d[p]=SW(o,a,s,e,p,l),h[p]=wW(s,p,l);return{begin:c,end:d,strides:h}}function vW(e,t,n,r,a){let s=[...a],i=yW(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let a=gW(t,n,o),i=r[a];e&1<<a&&(i=0),s[o]=i}return s}function xW(e,t,n,r,a){let s=[...a],i=yW(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let a=gW(t,n,o),i=r[a];e&1<<a&&(i=Number.MAX_SAFE_INTEGER),s[o]=i}for(let o=0;o<s.length;o++){let e=a[o];s[o]<0&&(s[o]+=e),s[o]=EC(0,s[o],a[o])}return s}function wW(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function kW(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=EC(0,i,l-1),i}function SW(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=o>0?EC(0,i,l):EC(-1,i,l-1),i}function IW(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function TW(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function NW(e,t,n){let r,a,s=e.shape.length;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{FC(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(FC(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function CW(e,t,n,r,a,s,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&1<<b&o&&d.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);let h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(cW),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(dW),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(0===h.strides[b])throw Error(`strides[${b}] must be non-zero`);let t=!!(h.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}let r=[h.beginMask&1<<b,h.endMask&1<<b],a=[h.strides[b]>0?0:-1,h.strides[b]>0?n:n-1];if(t&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[b];let s=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(t){let e=h.begin[b]<0?n+h.begin[b]:h.begin[b];if(h.begin[b]=e,h.end[b]=h.begin[b]+1,e<0||e>=n)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=AW(h.begin[b],0,h.strides[b],n,r,a),h.end[b]=AW(h.end[b],1,h.strides[b],n,r,a);let e=1===h.strides[b]&&0===h.begin[b]&&h.end[b]===n;p=p&&e,f=f&&(0===b&&1===h.strides[b]||e)}else p=p&&1===h.strides[b]&&s,f=f&&(0===b&&1===h.strides[b]||s);let i,o=!1;if(h.beginValid&&h.endValid?(i=h.end[b]-h.begin[b],o=!0):t?(i=1,o=!0):s&&n>=0&&(i=h.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!=h.strides[b]<0?0:Math.trunc(i/h.strides[b])+(i%h.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){let e=h.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===cW&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>h.finalShapeGatherIndices[t]!==cW)),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function AW(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}var EW="4.16.0",_W=class{static sgd(e){return new IV(e)}static momentum(e,t){return new TV(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new NV(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new kV(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new xV(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new SV(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new wV(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},$W=_W,RW="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function DW(){return new Promise((e=>RW((()=>e()))))}var MW,FW={};function OW(e,t){let n=e[0].length;e.forEach(((e,t)=>{FC(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),FC(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));let r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)FC(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function PW(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function LW(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let s=n[a],i=r[r.length-n.length+a],o=r[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${s} but shape[${a+e}] = ${o}`)}else r[i]=s}return r}function zW(e){let t={FIRST_DIM_SIZE:MW.FIRST_DIM_SIZE,VALUE_ROWIDS:MW.VALUE_ROWIDS,ROW_LENGTHS:MW.ROW_LENGTHS,ROW_SPLITS:MW.ROW_SPLITS,ROW_LIMITS:MW.ROW_LIMITS,ROW_STARTS:MW.ROW_STARTS},n=[];for(let r of e){if(!(r in t))break;n.push(t[r])}return n}function BW(e){return 0===e.length?0:e[0]===MW.FIRST_DIM_SIZE?e.length-1:e.length}function VW(e,t){if(null==e||null==t)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}tC(FW,{ERF_A1:()=>JW,ERF_A2:()=>eU,ERF_A3:()=>tU,ERF_A4:()=>nU,ERF_A5:()=>rU,ERF_P:()=>ZW,PARALLELIZE_THRESHOLD:()=>WW,RowPartitionType:()=>MW,SELU_SCALE:()=>QW,SELU_SCALEALPHA:()=>XW,applyActivation:()=>tB,assertAndGetBroadcastShape:()=>NO,assertAxesAreInnerMostDims:()=>BO,assertParamsConsistent:()=>OW,assignToTypedArray:()=>uU,axesAreInnerMostDims:()=>OO,calculateShapes:()=>_z,checkEinsumDimSizes:()=>bU,checkPadOnDimRoundingMode:()=>MF,combineLocations:()=>PO,combineRaggedTensorToTensorShapes:()=>LW,complexWithEvenIndex:()=>iU,complexWithOddIndex:()=>oU,computeConv2DInfo:()=>SF,computeConv3DInfo:()=>IF,computeDefaultPad:()=>TF,computeDilation2DInfo:()=>xF,computeOptimalWindowSize:()=>UW,computeOutAndReduceShapes:()=>LO,computeOutShape:()=>PW,computePool2DInfo:()=>wF,computePool3DInfo:()=>kF,convertConv2DDataFormat:()=>DF,decodeEinsumEquation:()=>gU,eitherStridesOrDilationsAreOne:()=>$F,expandShapeToKeepDim:()=>zO,exponent:()=>dU,exponents:()=>cU,fromStringArrayToUint8:()=>BU,fromUint8ToStringArray:()=>zU,getAxesPermutation:()=>VO,getBroadcastDims:()=>IO,getComplexWithIndex:()=>lU,getEinsumComputePath:()=>vU,getEinsumPermutation:()=>yU,getFusedBiasGradient:()=>eB,getFusedDyActivation:()=>Jz,getImageCenter:()=>jW,getInnerMostAxes:()=>UO,getPermuted:()=>HW,getRaggedRank:()=>BW,getReductionAxes:()=>TO,getReshaped:()=>GW,getReshapedPermuted:()=>qW,getRowPartitionTypesHelper:()=>zW,getSliceBeginCoords:()=>KW,getSliceSize:()=>YW,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>SU,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>IU,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>TU,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>AU,getSparseReshapeInputOutputMismatchErrorMessage:()=>_U,getSparseReshapeInputOutputMultipleErrorMessage:()=>EU,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>NU,getSparseReshapeNegativeOutputDimErrorMessage:()=>CU,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>MU,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>$U,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>RU,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>DU,getUndoAxesPermutation:()=>WO,isIdentityPermutation:()=>xU,log:()=>K$,mergeRealAndImagArrays:()=>aU,prepareAndValidate:()=>lW,prepareSplitSize:()=>kU,segment_util:()=>FU,shouldFuse:()=>nB,slice_util:()=>uW,splitRealAndImagArrays:()=>sU,stridesOrDilationsArePositive:()=>RF,tupleValuesAreOne:()=>_F,upcastType:()=>tD,validateDefaultValueShape:()=>VW,validateInput:()=>Ez,validateUpdateShape:()=>Az,warn:()=>q$}),function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(MW||(MW={}));var WW=30;function UW(e){return e<=WW?e:uA(e,Math.floor(Math.sqrt(e)))}function jW(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function GW(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let n=t.length;for(let a=0;a<n;++a)r=r.concat([e[a+1]/t[a],t[a]]);r=r.concat(e.slice(n+1))}return r}function HW(e,t){let n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{let r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function qW(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function KW(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function YW(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var XW=1.7580993408473768,QW=1.0507009873554805,ZW=.3275911,JW=.254829592,eU=-.284496736,tU=1.421413741,nU=-1.453152027,rU=1.061405429;function aU(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function sU(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function iU(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function oU(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function lU(e,t){return{real:e[2*t],imag:e[2*t+1]}}function uU(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function cU(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function dU(e,t,n){let r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}var hU="->",pU=/->/g,fU=",",mU="...";function gU(e,t){let n=((e=e.replace(/\s/g,"")).length-e.replace(pU,"").length)/hU.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${hU}").`);let[r,a]=e.split(hU);FC(-1===r.indexOf(mU),(()=>`The ellipsis notation ("${mU}") is not supported yet.`));let s=r.split(fU),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let d=0;d<a.length;++d){let e=a[d];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<r.length;++d){let e=r[d];-1===o.indexOf(e)&&e!==fU&&o.push(e)}let l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let e=0;e<s[d].length;++e)l[d].push(o.indexOf(s[d][e]))}let u=o.length,c=[];for(let d=a.length;d<u;++d)c.push(d);return{allDims:o,summedDims:c,idDims:l}}function yU(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function bU(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:FC(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function vU(e,t){let n=e,r=[],a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);let s=[];for(let i=0;i<n.length;++i){let e=wU(t,n[i]);for(let t of e)-1===s.indexOf(t)&&(r[i].push(t),s.push(t))}return{path:n,steps:r}}function xU(e){return e.every(((e,t)=>e===t))}function wU(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}function kU(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"==typeof t)FC(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{FC(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));let a=t.indexOf(-1);if(-1!==a){let r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}FC(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function SU(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function IU(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function TU(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function NU(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function CU(e,t){return`size ${e} must be non-negative, not ${t}`}function AU(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function EU(e,t){return`Input to reshape is a SparseTensor with ${LC(e)}\n  dense values, but the requested shape requires a multiple of ${LC(t)}. inputShape=${e} outputShape= ${t}`}function _U(e,t){return`Input to reshape is a tensor with ${LC(e)} dense values, but the requested shape has ${LC(t)}. inputShape=${e} outputShape=${t}`}function $U(){return"segment ids must be >= 0"}function RU(){return"segment ids are not increasing"}function DU(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function MU(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var FU={};function OU(e,t){let n,r=!1;for(e<=WW?(n=e,r=!0):n=uA(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=uA(e,n+1);return n}function PU(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function LU(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let i=e.shape[n],o=[],l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<a;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function zU(e){try{return e.map((e=>CR(e)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function BU(e){return e.map((e=>NR(e)))}tC(FU,{collectGatherOpShapeInfo:()=>LU,computeOutShape:()=>PU,segOpComputeOptimalWindowSize:()=>OU});var VU={};tC(VU,{nonMaxSuppressionV3Impl:()=>wB,nonMaxSuppressionV4Impl:()=>kB,nonMaxSuppressionV5Impl:()=>SB,whereImpl:()=>zz}),function(){for(let e of CV)yV(e)}();var WU={kernelName:EA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(e,bz(eF(n,"float32"),-1))}}},UU={kernelName:_A,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=YO(eF(n,"float32")),r=KO(_P(qO(1),t));return CP(sF(e,r))}}}},jU={kernelName:$A,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=KO(_P(YO(eF(n,"float32")),1));return sF(e,t)}}}},GU={kernelName:RA,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=NO(n.shape,r.shape);return{a:()=>{let t=e,r=TO(n.shape,a);return r.length>0&&(t=XO(t,r)),FF(t,n.shape)},b:()=>{let t=e,n=TO(r.shape,a);return n.length>0&&(t=XO(t,n)),FF(t,r.shape)}}}},HU={kernelName:DA,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},qU={kernelName:OA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EO(n)}}},KU={kernelName:PA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EO(n)}}},YU={kernelName:LA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sF(e,KO(_P(qO(1),YO(eF(n,"float32")))))}}},XU={kernelName:zA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=KO(rF(qO(1),YO(eF(n,"float32"))));return sF(e,t)}}}},QU={kernelName:WA,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=NO(n.shape,r.shape);return{a:()=>{let t=rF(YO(n),YO(r)),s=iF(e,sF(r,t)),i=TO(n.shape,a);return i.length>0&&(s=XO(s,i)),FF(s,n.shape)},b:()=>{let t=rF(YO(n),YO(r)),s=CP(iF(e,sF(n,t))),i=TO(r.shape,a);return i.length>0&&(s=XO(s,i)),FF(s,r.shape)}}}},ZU={kernelName:BA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sF(e,rF(YO(eF(n,"float32")),1))}}},JU={kernelName:VA,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sF(e,_P(qO(1),YO(eF(n,"float32"))))}}};var ej=AD({avgPool3dGrad_:function(e,t,n,r,a,s){let i=TD(e,"dy","avgPool3dGrad"),o=TD(t,"input","avgPool3dGrad"),l=i,u=o,c=!1;4===o.rank&&(c=!0,l=FF(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=FF(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),FC(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),FC(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),MF("avgPool3dGrad",a,s);let d={dy:l,input:u},h={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=fD.runKernel(HA,d,h);return c?FF(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),tj={kernelName:GA,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>ej(e,r,a,s,i,o)}}};var nj=AD({avgPoolGrad_:function(e,t,n,r,a){let s=TD(e,"dy","avgPoolGrad"),i=TD(t,"input","avgPoolGrad");FC(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=FF(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=FF(s,[1,s.shape[0],s.shape[1],s.shape[2]])),FC(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),FC(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));let c={dy:l,input:o},d={filterSize:n,strides:r,pad:a},h=fD.runKernel(jA,c,d);return u?FF(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),rj={kernelName:UA,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>nj(e,r,a,s,i)}}},aj={kernelName:qA,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>zF(e,a,!1,!1),b:()=>zF(e,r,!0,!1)}:s&&!i?{a:()=>zF(a,e,!1,!0),b:()=>zF(r,e,!1,!1)}:{a:()=>zF(a,e,!0,!0),b:()=>zF(e,r,!0,!0)}:{a:()=>zF(e,a,!1,!0),b:()=>zF(r,e,!0,!1)}}},sj={kernelName:KA,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>uL(e,r,a)}}},ij={kernelName:QA,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>XO(e,o,!0)}}},oj={kernelName:JA,gradFunc:e=>({x:()=>e.clone()})},lj={kernelName:eE,gradFunc:e=>({x:()=>EO(e)})},uj={kernelName:tE,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>AO(DP(lP(r,a),mP(r,s)),e,EO(e))}}},cj={kernelName:rE,inputsToSave:["x"],gradFunc:WU.gradFunc},dj={kernelName:aE,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map((e=>e.shape)),{axis:a}=n,s=YC(a,t[0].shape)[0],i=r.map((e=>e[s]));return pz(e,i,s).map((e=>()=>e))}},hj={kernelName:sE,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return FC(_F(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>uO(r.shape,e,a,i,o,l),filter:()=>Zz(r,e,a.shape,i,o,l)}}},pj={kernelName:oE,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>oO(e,a,s,i,o,1,l),filter:()=>Zz(e,r,a.shape,s,i,o,l)}}};var fj=AD({conv3DBackpropFilter_:function(e,t,n,r,a){let s=e;4===e.rank&&(s=FF(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=FF(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),FC(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),FC(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),FC(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),FC(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),FC(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return fD.runKernel(uE,o,l)}}),mj={kernelName:lE,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;FC(_F(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));let[i,o]=t;return{x:()=>hO(i.shape,e,o,a,s),filter:()=>fj(i,e,o.shape,a,s)}}},gj={kernelName:dE,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(CP(rz(eF(n,"float32"))),e)}}},yj={kernelName:hE,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(az(eF(n,"float32")),e)}}},bj={kernelName:fE,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let t=VO([a],r.rank),n=yO(e,a,s,!i);return null!=t&&(n=Wz(n,t)),n}}}},vj={kernelName:bE,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;FC(_F(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));let[l,u]=t;return FC(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),FC(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),FC(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),FC($F(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),MF("depthwiseConv2d",s,i),{x:()=>sB(l.shape,e,u,a,s,o,i),filter:()=>aB(l,e,u.shape,a,s,o,i)}}},xj={kernelName:kE,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>fD.runKernel(SE,s,n),filter:()=>fD.runKernel(IE,i,n)}}},wj={kernelName:AE,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>fD.runKernel(EE,r)}}},kj={kernelName:_E,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=iF(eP(CP(YO(n))),2/Math.sqrt(Math.PI));return{x:()=>iF(e,r)}}},Sj={kernelName:RE,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(e,n)}}},Ij={kernelName:DE,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>FF(e,n.shape)}}},Tj={kernelName:ME,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(e,eP(n))}}},Nj={kernelName:LE,gradFunc:e=>({x:()=>EO(e)})},Cj={kernelName:zE,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=NO(n.shape,r.shape);return{a:()=>{let t=sF(e,eF(r,"float32")),s=TO(n.shape,a);return s.length>0?FF(XO(t,s),n.shape):t},b:()=>{let t=iF(e,eF(n,"float32")),s=TO(r.shape,a);s.length>0&&(t=FF(XO(t,s),r.shape));let i=YO(r);return CP(sF(t,eF(i,"float32")))}}}},Aj={kernelName:BE,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?qO(1):o,u=TO(s.shape,a.shape),c=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)c.push(a.shape[e]);c.push(1)}let d=_P(a,s),h=iF(e,l),p=ZL(rF(i,qO(r))),f=iF(iF(iF(p,p),p),qO(-.5));return{x:()=>1===s.rank?FF(iF(iF(e,rP(FF(p,[1,1,1,s.shape[0]]),c)),l),a.shape):FF(iF(iF(e,p),l),a.shape),mean:()=>{let e=iF(iF(p,qO(-1)),h);return 1===s.rank&&(e=XO(e,u)),FF(e,s.shape)},variance:()=>{let e=iF(iF(f,d),h);return 1===s.rank&&(e=XO(e,u)),FF(e,s.shape)},scale:()=>{let t=iF(d,p),n=iF(e,t);return 1===s.rank&&(n=XO(n,u)),FF(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=XO(t,u)),FF(t,s.shape)}}}},Ej={kernelName:VE,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s,batchDims:i}=n,o=YC(s,r.shape)[0],l=(e,t,n)=>()=>{let r=e.shape,a=t.size,i=r.slice(0,o),l=i.length,u=r.slice(s,r.length).slice(1),c=u.length,d=_j(0,l),h=_j(l+1,l+1+c),p=$j([i,[a],u]),f=FF(n,p),m=FF(t,[a]),g=$j([[l],d,h]),y=Wz(f,g),b=Fz(y,m,e.shape[o]),v=WO(g);return b=Wz(b,v),b};if(1===i){let t=r.shape[0],n=r.split(t,0);return{x:()=>yz(n.map(((t,n)=>l(t,a.slice(n,1),e.slice(n,1))()))).reshape(r.shape),indices:()=>a}}return{x:l(r,a,e),indices:()=>a}}};function _j(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function $j(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var Rj={kernelName:jE,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>EO(n),b:()=>EO(r)}}},Dj={kernelName:GE,gradFunc:e=>({x:()=>eF(e,"float32")})},Mj={kernelName:KE,gradFunc:e=>({x:()=>EO(e)})},Fj={kernelName:YE,gradFunc:e=>({x:()=>EO(e)})},Oj={kernelName:XE,gradFunc:e=>({x:()=>EO(e)})},Pj={kernelName:QE,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=oP(r,0);return{x:()=>AO(s,e,iF(e,a))}}},Lj={kernelName:n_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sF(e,rF(n,1))}}},zj={kernelName:t_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sF(e,eF(n,"float32"))}}},Bj={kernelName:o_,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let t=eP(r);return _P(e,iF(XO(e,a,!0),t))}}}};var Vj=AD({localResponseNormalizationBackprop_:function(e,t,n){let r={x:e,y:t,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return fD.runKernel(c_,r,a)}}),Wj={kernelName:u_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>Vj(r,a,e,s,i,o,l)}}};function Uj(e,t,n,r){return t.rank<n.rank&&(t=FF(t,zO(t.shape,r))),e.rank<n.rank&&(e=FF(e,zO(e.shape,r))),{x:()=>iF(e,eF(CO(n,t),e.dtype))}}var jj={kernelName:h_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=Uj(e,t[1],s,YC(a,s.shape));return{x:()=>i.x()}}},Gj={kernelName:p_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>iF(e,eF(lP(n,r),"float32")),b:()=>iF(e,eF(fP(n,r),"float32"))}}};var Hj=AD({maxPool3dGrad_:function(e,t,n,r,a,s,i){let o=TD(e,"dy","maxPool3dGrad"),l=TD(t,"input","maxPool3dGrad"),u=TD(n,"output","maxPool3dGrad"),c=o,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=FF(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=FF(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=FF(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),FC(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),FC(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),FC(5===h.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),MF("maxPool3dGrad",s,i);let f={dy:c,input:d,output:h},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=fD.runKernel(y_,f,m);return p?FF(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),qj={kernelName:g_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>Hj(e,r,a,s,i,o,l)}}};var Kj=AD({maxPoolGrad_:function(e,t,n,r,a,s,i){let o=TD(e,"dy","maxPoolGrad"),l=TD(t,"input","maxPoolGrad"),u=TD(n,"output","maxPoolGrad");FC(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),FC(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),FC(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),MF("maxPoolGrad",s,i);let c={dy:o,input:l,output:u},d={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return fD.runKernel(m_,c,d)}}),Yj={kernelName:f_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>Kj(e,r,a,s,i,o)}}},Xj={kernelName:v_,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=YC(a,r.shape),i=LC(LO(r.shape,s)[1]);return{x:()=>{let t=r.shape.slice();s.forEach((e=>{t[e]=1}));let n=FF(e,t);return sF(iF(n,HP(r.shape,"float32")),i)}}}},Qj={kernelName:x_,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=Uj(e,i,s,YC(a,s.shape));return{x:()=>o.x()}}},Zj={kernelName:w_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>iF(e,eF(mP(n,r),"float32")),b:()=>iF(e,eF(oP(n,r),"float32"))}}},Jj={kernelName:k_,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>VF(e,s,r.shape)}}},eG={kernelName:S_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=NO(n.shape,r.shape);return{a:()=>{let t=TO(n.shape,a);return t.length>0?FF(XO(e,t),n.shape):e},b:()=>{let t=iF(e,CP(sP(sF(n,r)))),s=TO(r.shape,a);return s.length>0?FF(XO(t,s),r.shape):t}}}},tG={kernelName:T_,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=NO(n.shape,r.shape);return{a:()=>{let t=iF(e,eF(r,"float32")),s=TO(n.shape,a);return s.length>0?FF(XO(t,s),n.shape):t},b:()=>{let t=iF(e,eF(n,"float32")),s=TO(r.shape,a);return s.length>0?FF(XO(t,s),r.shape):t}}}},nG={kernelName:N_,gradFunc:e=>({x:()=>CP(e)})},rG={kernelName:R_,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>GP(n.shape,"float32")}}},aG={kernelName:$_,gradFunc:e=>({x:()=>EO(e)})},sG={kernelName:D_,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return Oz(e,r).map((e=>()=>e))}},iG={kernelName:M_,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>VF(e,s,r.shape)}}},oG={kernelName:O_,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=NO(s.shape,i.shape);return{a:()=>{let t=eF(i,"float32"),n=iF(e,iF(t,HO(s,_P(t,qO(1))))),r=TO(s.shape,o);return r.length>0&&(n=XO(n,r)),FF(n,s.shape)},b:()=>{let t=oP(s,0),n=AO(t,bP(s),EO(s)),r=iF(e,iF(a,n)),l=TO(i.shape,o);return l.length>0&&(r=XO(r,l)),FF(r,i.shape)}}}},lG={kernelName:P_,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=oP(n,0);return{x:()=>AO(a,e,iF(e,r)),alpha:()=>{let t=AO(a,EO(e),iF(e,n)),s=TO(r.shape,e.shape);return s.length>0&&(t=XO(t,s)),FF(t,r.shape)}}}};function uG(e,t,n){let r=e.shape.length,a=r-n.length,s=FW.getAxesPermutation(n,r),i=e;null!=s&&(i=Wz(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){let r=e.shape.slice();r[n]=1;let a=FF(t,r),s=gO(e,n,!0,!1),i=gO(e,n,!0,!0),o=iF(s,i);return iF(a,o)}(i.reshape(o),t,a);if(u=u.reshape(i.shape),null!=s){let e=FW.getUndoAxesPermutation(s);u=Wz(u,e)}return u}var cG={kernelName:L_,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return s=null==a?r.shape.map(((e,t)=>t)):"number"==typeof a?[a]:a,{x:()=>uG(r,e,s)}}},dG={kernelName:NE,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=NO(n.shape,r.shape);return{a:()=>{let t=sF(e,eF(r,"float32")),s=TO(n.shape,a);return s.length>0?FF(XO(t,s),n.shape):t},b:()=>{let t=iF(e,eF(n,"float32")),s=TO(r.shape,a);s.length>0&&(t=FF(XO(t,s),r.shape));let i=YO(r);return CP(sF(t,eF(i,"float32")))}}}},hG={kernelName:j_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sF(e,CP(YO(n)))}}},pG={kernelName:Q_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=iF(mP(n,6),bz(n));return{x:()=>iF(e,eF(r,"float32"))}}},fG={kernelName:G_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(e,eF(bz(n),"float32"))}}},mG={kernelName:H_,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>FF(e,n.shape)}}},gG={kernelName:Y_,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>fD.runKernel(X_,a,n)}}},yG={kernelName:q_,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>fD.runKernel(K_,a,n)}}},bG={kernelName:Z_,gradFunc:(e,t,n)=>{let{dims:r}=n,a=YC(r,e.shape);return{x:()=>HL(e,a)}}},vG={kernelName:J_,gradFunc:e=>({x:()=>EO(e)})},xG={kernelName:e$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>CP(sF(e,iF(HO(n,1.5),2)))}}},wG={kernelName:a$,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>eF(EO(n),"float32"),t:()=>iF(e,eF(n,e.dtype)),e:()=>iF(e,eF(MP(n),e.dtype))}}},kG={kernelName:s$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=oP(n,qO(0)),r=qO(XW),a=qO(QW),s=iF(e,a),i=iF(iF(e,r),eP(eF(n,"float32")));return AO(t,s,i)}}}},SG={kernelName:c$,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(e,iF(n,_P(qO(1),n)))}}},IG={kernelName:u$,gradFunc:e=>({x:()=>EO(e)})},TG={kernelName:o$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(fO(eF(n,"float32")),e)}}},NG={kernelName:l$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(mO(eF(n,"float32")),e)}}},CG={kernelName:i$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=NW(r,a,s),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>aL(e,u)}}},AG={kernelName:g$,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=iF(e,r);return{logits:()=>_P(s,iF(XO(s,[a],true),r))}}},EG={kernelName:d$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(e,BF(n))}}},_G={kernelName:f$,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>jF(e,r,a)}}},$G={kernelName:m$,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>LF(e,r)}}},RG={kernelName:h$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sF(e,iF(KO(eF(n,"float32")),2))}}},DG={kernelName:S$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(e,iF(eF(n,"float32"),2))}}},MG={kernelName:k$,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=qO(2);return{a:()=>iF(e,iF(a,_P(n,r))),b:()=>iF(e,iF(a,_P(r,n)))}}},FG={kernelName:V$,gradFunc:e=>({x:()=>EO(e)})},OG={kernelName:E$,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=NO(n.shape,r.shape);return{a:()=>{let t=e,r=TO(n.shape,a);return r.length>0&&(t=XO(t,r)),FF(t,n.shape)},b:()=>{let t=e,n=TO(r.shape,a);return n.length>0&&(t=XO(t,n)),FF(CP(t),r.shape)}}}},PG={kernelName:p$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;YC(s,r.shape).forEach((e=>{a[e]=1}));let i=FF(e,a),o=iF(i,HP(r.shape,"float32"));return{x:()=>o}}},LG={kernelName:_$,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sF(e,YO(fO(n)))}}},zG={kernelName:$$,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>iF(_P(qO(1),YO(n)),e)}}},BG={kernelName:R$,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let t=EO(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=rF(t,VF(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=rF(t,VF(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=rF(t,VF(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=rF(t,VF(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},VG={kernelName:F$,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=WO(a);return{x:()=>Wz(e,s)}}},WG={kernelName:P$,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>yz(e,a)}}},UG={kernelName:L$,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>function(e,t){let n=UP(t,EO(t)),r=iP(e,n),a=lP(t,qO(0,"int32")),s=r.rank-a.rank;for(let o=0;o<s;++o)a=tP(a,o+1);a=DP(a,HP(r.shape,"bool"));let i=EO(r);return AO(a,r,i)}(e,n)}}};var jG={kernelName:B$,gradFunc:e=>({x:()=>EO(e)})},GG=[WU,UU,jU,GU,HU,qU,KU,YU,XU,QU,ZU,JU,tj,rj,aj,sj,ij,oj,lj,uj,cj,dj,pj,hj,mj,gj,yj,bj,vj,xj,dG,wj,kj,Sj,Ij,Tj,Cj,Nj,Aj,Ej,Rj,Dj,Mj,Fj,Oj,Pj,Lj,zj,Bj,Wj,jj,jj,Gj,qj,Yj,Xj,Qj,Zj,Jj,eG,tG,nG,rG,aG,sG,iG,iG,oG,lG,cG,hG,pG,fG,mG,gG,yG,bG,vG,xG,wG,kG,SG,IG,TG,NG,CG,AG,EG,_G,_G,$G,$G,RG,MG,DG,FG,OG,PG,LG,zG,BG,VG,WG,UG,jG];for(let n of GG)tR(n);GR().prototype.abs=function(){return this.throwIfDisposed(),oF(this)},GR().prototype.acos=function(){return this.throwIfDisposed(),lF(this)},GR().prototype.acosh=function(){return this.throwIfDisposed(),uF(this)},GR().prototype.add=function(e){return this.throwIfDisposed(),rF(this,e)},GR().prototype.all=function(e,t){return this.throwIfDisposed(),dF(this,e,t)},GR().prototype.any=function(e,t){return this.throwIfDisposed(),hF(this,e,t)},GR().prototype.argMax=function(e){return this.throwIfDisposed(),pF(this,e)},GR().prototype.argMin=function(e){return this.throwIfDisposed(),fF(this,e)},GR().prototype.asScalar=function(){return this.throwIfDisposed(),FC(1===this.size,(()=>"The array must have only 1 element.")),FF(this,[])},GR().prototype.asType=function(e){return this.throwIfDisposed(),eF(this,e)},GR().prototype.as1D=function(){return this.throwIfDisposed(),FF(this,[this.size])},GR().prototype.as2D=function(e,t){return this.throwIfDisposed(),FF(this,[e,t])},GR().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),FF(this,[e,t,n])},GR().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),FF(this,[e,t,n,r])},GR().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),FF(this,[e,t,n,r,a])},GR().prototype.asin=function(){return this.throwIfDisposed(),mF(this)},GR().prototype.asinh=function(){return this.throwIfDisposed(),gF(this)},GR().prototype.atan=function(){return this.throwIfDisposed(),yF(this)},GR().prototype.atan2=function(e){return this.throwIfDisposed(),bF(this,e)},GR().prototype.atanh=function(){return this.throwIfDisposed(),vF(this)},GR().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),OF(this,e,t,n,r)},GR().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),jF(this,e,t)},GR().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),HF(this,e,t,n,r,a)},GR().prototype.broadcastTo=function(e){return this.throwIfDisposed(),JF(this,e)},GR().prototype.cast=function(e){return this.throwIfDisposed(),eF(this,e)},GR().prototype.ceil=function(){return this.throwIfDisposed(),eO(this)},GR().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),nO(this,e,t)},GR().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof jR&&(e=[e]),LF([this,...e],t)},GR().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),lO(this,e,t,n,r,a,s)},GR().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),cO(this,e,t,n,r,a)},GR().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),oO(this,e,t,n,r,a,s)},GR().prototype.cos=function(){return this.throwIfDisposed(),fO(this)},GR().prototype.cosh=function(){return this.throwIfDisposed(),mO(this)},GR().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),gO(this,e,t,n)},GR().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),yO(this,e,t,n)},GR().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),vO(this,e,t)},GR().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),xO(this,e,t,n,r,a,s)},GR().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),kO(this,e,t,n,r,a)},GR().prototype.divNoNan=function(e){return this.throwIfDisposed(),_O(this,e)},GR().prototype.div=function(e){return this.throwIfDisposed(),sF(this,e)},GR().prototype.dot=function(e){return this.throwIfDisposed(),$O(this,e)},GR().prototype.elu=function(){return this.throwIfDisposed(),DO(this)},GR().prototype.equal=function(e){return this.throwIfDisposed(),CO(this,e)},GR().prototype.erf=function(){return this.throwIfDisposed(),FO(this)},GR().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),JO(this,e,t)},GR().prototype.exp=function(){return this.throwIfDisposed(),eP(this)},GR().prototype.expandDims=function(e){return this.throwIfDisposed(),tP(this,e)},GR().prototype.expm1=function(){return this.throwIfDisposed(),nP(this)},GR().prototype.fft=function(){return this.throwIfDisposed(),cz(this)},GR().prototype.flatten=function(){return this.throwIfDisposed(),FF(this,[this.size])},GR().prototype.floor=function(){return this.throwIfDisposed(),sP(this)},GR().prototype.floorDiv=function(e){return this.throwIfDisposed(),aF(this,e)},GR().prototype.gather=function(e,t,n){return this.throwIfDisposed(),iP(this,e,t,n)},GR().prototype.greaterEqual=function(e){return this.throwIfDisposed(),lP(this,e)},GR().prototype.greater=function(e){return this.throwIfDisposed(),oP(this,e)},GR().prototype.ifft=function(){return this.throwIfDisposed(),dz(this)},GR().prototype.irfft=function(){return this.throwIfDisposed(),hz(this)},GR().prototype.isFinite=function(){return this.throwIfDisposed(),cP(this)},GR().prototype.isInf=function(){return this.throwIfDisposed(),dP(this)},GR().prototype.isNaN=function(){return this.throwIfDisposed(),hP(this)},GR().prototype.leakyRelu=function(e){return this.throwIfDisposed(),pP(this,e)},GR().prototype.lessEqual=function(e){return this.throwIfDisposed(),mP(this,e)},GR().prototype.less=function(e){return this.throwIfDisposed(),fP(this,e)},GR().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),yP(this,e,t,n,r)},GR().prototype.logSigmoid=function(){return this.throwIfDisposed(),EP(this)},GR().prototype.logSoftmax=function(e){return this.throwIfDisposed(),$P(this,e)},GR().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),RP(this,e,t)},GR().prototype.log=function(){return this.throwIfDisposed(),bP(this)},GR().prototype.log1p=function(){return this.throwIfDisposed(),vP(this)},GR().prototype.logicalAnd=function(e){return this.throwIfDisposed(),DP(this,e)},GR().prototype.logicalNot=function(){return this.throwIfDisposed(),MP(this)},GR().prototype.logicalOr=function(e){return this.throwIfDisposed(),FP(this,e)},GR().prototype.logicalXor=function(e){return this.throwIfDisposed(),OP(this,e)},GR().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),zF(this,e,t,n)},GR().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),BP(this,e,t,n,r)},GR().prototype.max=function(e,t){return this.throwIfDisposed(),jO(this,e,t)},GR().prototype.maximum=function(e){return this.throwIfDisposed(),UP(this,e)},GR().prototype.mean=function(e,t){return this.throwIfDisposed(),jP(this,e,t)},GR().prototype.min=function(e,t){return this.throwIfDisposed(),GO(this,e,t)},GR().prototype.minimum=function(e){return this.throwIfDisposed(),KP(this,e)},GR().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),YP(this,e,t)},GR().prototype.mod=function(e){return this.throwIfDisposed(),XP(this,e)},GR().prototype.mul=function(e){return this.throwIfDisposed(),iF(this,e)},GR().prototype.neg=function(){return this.throwIfDisposed(),CP(this)},GR().prototype.norm=function(e,t,n){return this.throwIfDisposed(),ZO(this,e,t,n)},GR().prototype.notEqual=function(e){return this.throwIfDisposed(),eL(this,e)},GR().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),tL(this,e,t,n)},GR().prototype.onesLike=function(){return this.throwIfDisposed(),nL(this)},GR().prototype.pad=function(e,t){return this.throwIfDisposed(),aL(this,e,t)},GR().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),cL(this,e,t,n,r,a,s)},GR().prototype.pow=function(e){return this.throwIfDisposed(),HO(this,e)},GR().prototype.prelu=function(e){return this.throwIfDisposed(),dL(this,e)},GR().prototype.prod=function(e,t){return this.throwIfDisposed(),hL(this,e,t)},GR().prototype.reciprocal=function(){return this.throwIfDisposed(),UL(this)},GR().prototype.relu=function(){return this.throwIfDisposed(),jL(this)},GR().prototype.relu6=function(){return this.throwIfDisposed(),GL(this)},GR().prototype.reshapeAs=function(e){return this.throwIfDisposed(),FF(this,e.shape)},GR().prototype.reshape=function(e){return this.throwIfDisposed(),FF(this,e)},GR().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),DB(this,e,t,n)},GR().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),MB(this,e,t,n)},GR().prototype.reverse=function(e){return this.throwIfDisposed(),HL(this,e)},GR().prototype.rfft=function(){return this.throwIfDisposed(),fz(this)},GR().prototype.round=function(){return this.throwIfDisposed(),QL(this)},GR().prototype.rsqrt=function(){return this.throwIfDisposed(),ZL(this)},GR().prototype.selu=function(){return this.throwIfDisposed(),JL(this)},GR().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),ez(this,e,t,n,r,a,s)},GR().prototype.sigmoid=function(){return this.throwIfDisposed(),BF(this)},GR().prototype.sign=function(){return this.throwIfDisposed(),nz(this)},GR().prototype.sin=function(){return this.throwIfDisposed(),rz(this)},GR().prototype.sinh=function(){return this.throwIfDisposed(),az(this)},GR().prototype.slice=function(e,t){return this.throwIfDisposed(),VF(this,e,t)},GR().prototype.softmax=function(e){return this.throwIfDisposed(),uz(this,e)},GR().prototype.softplus=function(){return this.throwIfDisposed(),AP(this)},GR().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),uL(this,e,t)},GR().prototype.split=function(e,t){return this.throwIfDisposed(),pz(this,e,t)},GR().prototype.sqrt=function(){return this.throwIfDisposed(),KO(this)},GR().prototype.square=function(){return this.throwIfDisposed(),YO(this)},GR().prototype.squaredDifference=function(e){return this.throwIfDisposed(),mz(this,e)},GR().prototype.squeeze=function(e){return this.throwIfDisposed(),gz(this,e)},GR().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof jR?[this,e]:[this,...e];return yz(n,t)},GR().prototype.step=function(e){return this.throwIfDisposed(),bz(this,e)},GR().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),vz(this,e,t,n,r,a,s,i,o)},GR().prototype.sub=function(e){return this.throwIfDisposed(),_P(this,e)},GR().prototype.sum=function(e,t){return this.throwIfDisposed(),XO(this,e,t)},GR().prototype.tan=function(){return this.throwIfDisposed(),xz(this)},GR().prototype.tanh=function(){return this.throwIfDisposed(),WF(this)},GR().prototype.tile=function(e){return this.throwIfDisposed(),rP(this,e)},GR().prototype.toBool=function(){return this.throwIfDisposed(),eF(this,"bool")},GR().prototype.toFloat=function(){return this.throwIfDisposed(),eF(this,"float32")},GR().prototype.toInt=function(){return this.throwIfDisposed(),eF(this,"int32")},GR().prototype.topk=function(e,t){return this.throwIfDisposed(),Rz(this,e,t)},GR().prototype.transpose=function(e){return this.throwIfDisposed(),Wz(this,e)},GR().prototype.unique=function(e){return this.throwIfDisposed(),Mz(this,e)},GR().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Fz(this,e,t)},GR().prototype.unstack=function(e){return this.throwIfDisposed(),Oz(this,e)},GR().prototype.where=function(e,t){return this.throwIfDisposed(),AO(e,this,t)},GR().prototype.zerosLike=function(){return this.throwIfDisposed(),EO(this)};var HG=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},qG=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},KG=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},YG=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},XG=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},QG=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}};function ZG(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{let n=new Array(t);return n.fill(e),n}}function JG(e,t){if(!e)throw new XG(t)}function eH(e,t){let n=0;for(let r of e)r===t&&n++;return n}function tH(e){return 1===e.length?e[0]:e}function nH(e){return Array.isArray(e)?e:[e]}function rH(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function aH(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}var sH={};function iH(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function oH(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>oH(e)));else{let t=Object.keys(e);for(let n of t){let t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?oH(t):e[n]=t.value)}}}function lH(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"==typeof e){let a,s=e;if(s in n)a=n[s];else if(s in sH)a=sH[s];else if(a=t[s],null==a)throw new KG(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{let s=e;if(null==s.className||null==s.config)throw new KG(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);let i,o,l=s.className;if(l in n?[i,o]=n[l]:l in sH?[i,o]=sH.className:l in t&&([i,o]=t[l]),null==i)throw new KG(`Unknown ${r}: ${l}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=o){let e={};for(let n of Object.keys(sH))e[n]=sH[n];for(let a of Object.keys(n))e[a]=n[a];s.config.customObjects=e;let t=Object.assign({},sH);for(let a of Object.keys(n))sH[a]=n[a];oH(s.config);let r=o(i,s.config,n,a);return sH=Object.assign({},t),r}{let e=Object.assign({},sH);for(let r of Object.keys(n))sH[r]=n[r];let t=new i(s.config);return sH=Object.assign({},e),t}}}function uH(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function cH(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function dH(e){if(null==e)throw new KG(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function hH(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new KG(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function pH(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return JG(n>=0),JG(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function fH(e,t){Array.isArray(e)?(iR.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>fH(e,`element ${n+1} of ${t}`)))):iR.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${mH(e)}.`))}function mH(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>mH(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function gH(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var yH=0;function bH(){return yH++}var vH={};function xH(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in vH||(vH[e]=0),vH[e]+=1,e+vH[e].toString()}var wH=["channelsFirst","channelsLast"],kH=["nearest","bilinear"],SH=["valid","same","causal"],IH=["max","avg"],TH=["sum","mul","concat","ave"],NH=new Map;function CH(e){hH(wH,"DataFormat",e)}function AH(e){hH(SH,"PaddingMode",e)}function EH(e){hH(IH,"PoolMode",e)}var _H=[],$H="/";function RH(e,t){_H.push(e);try{let e=t();return _H.pop(),e}catch(gye){throw _H.pop(),gye}}function DH(e){if(!PH(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===_H.length?"":_H.join($H)+$H)+e}function MH(e){if(!PH(e))throw new Error("Not a valid tensor name: '"+e+"'");NH.has(e)||NH.set(e,0);let t=NH.get(e);if(NH.set(e,NH.get(e)+1),t>0){let n=`${e}_${t}`;return NH.set(n,1),n}return e}var FH,OH=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function PH(e){return!!e.match(OH)}function LH(e){return e===parseInt(e.toString(),10)}function zH(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function BH(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function VH(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function WH(e,t){if(t<e)throw new KG(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function UH(){return null==FH&&(FH=JD().epsilon()),FH}function jH(e,t){return eF(e,t)}function GH(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),FF(e,n)}function HH(e,t,n){return WD((()=>{switch(e.rank){case 1:return sz(e,t,n);case 2:return iz(e,[t,0],[n,e.shape[1]]);case 3:return oz(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return lz(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return VF(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return VF(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new KG(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function qH(e,t,n){return WD((()=>{switch(e.rank){case 1:return sz(e,t,n);case 2:return iz(e,[0,t],[e.shape[0],n]);case 3:return oz(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return lz(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new KG(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function KH(e,t,n,r){return WD((()=>{switch(e.rank){case 1:return sz(e,t,n);case 2:switch(r){case 1:return HH(e,t,n);case 2:return qH(e,t,n);default:throw new KG(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return HH(e,t,n);case 2:return oz(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return qH(e,t,n);default:throw new KG(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return HH(e,t,n);case 2:return lz(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return lz(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return qH(e,t,n);default:throw new KG(`The axis is not within the rank of the tensor ${r}`)}default:throw new KG(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function YH(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),LF(e,n)}function XH(e,t){switch(e.rank){case 1:return rO([e,t]);case 2:return aO([e,t],0);case 3:return sO([e,t],0);case 4:return iO([e,t],0);default:throw new KG(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function QH(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new KG(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return rP(e,t)}function ZH(e){return PL(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function JH(e,t,n,r){if(e.rank<2||t.rank<2)throw new YG(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new YG(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank)return Qz.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?nq(e.rank,r,"channelsLast"):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=FF(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=FF(Wz(t,c),[l,-1]);let d=[...a,...u];return FF(Qz.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?nq(e.rank,r,"channelsLast"):null,activation:n}),d)}}function eq(e,t,n){return WD((()=>(t=Array.isArray(t)?wz(t,"int32"):eF(t,"int32"),iP(e,t,n))))}function tq(e){return iF(e,e)}function nq(e,t,n){let r=t.shape;if(1!==t.rank&&t.rank!==e)throw new KG(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?FF(t,[1,r[0],1,1,1]):FF(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?FF(t,[1,1,1,1,r[0]]):FF(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?FF(t,[1,r[0],1,1]):FF(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?FF(t,[1,1,1,r[0]]):FF(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?FF(t,[1,r[0],1]):FF(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?FF(t,[1,1,r[0]]):FF(t,[1].concat(r))}else if(e<3)return t;throw new KG(`Unsupported input rank by biasAdd: ${t.rank}`)}function rq(e,t,n){return WD((()=>(null==n&&(n="channelsLast"),CH(n),rF(e,nq(e.rank,t,n)))))}function aq(e,t,n,r){return WD((()=>qz(e,t,n,r)))}function sq(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}var iq=["fanIn","fanOut","fanAvg"],oq=["normal","uniform","truncatedNormal"];var lq=class extends hV.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},uq=class extends lq{apply(e,t){return GP(e,t)}};uq.className="Zeros",hV.registerClass(uq);var cq=class extends lq{apply(e,t){return HP(e,t)}};cq.className="Ones",hV.registerClass(cq);var dq=class extends lq{constructor(e){if(super(),"object"!=typeof e)throw new KG(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new KG(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return WD((()=>iF(qO(this.value),HP(e,t))))}getConfig(){return{value:this.value}}};dq.className="Constant",hV.registerClass(dq);var hq=class extends lq{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return zL(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};hq.className="RandomUniform",hV.registerClass(hq);var pq=class extends lq{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new YG(`randomNormal does not support dType ${t}.`);return ZH(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};pq.className="RandomNormal",hV.registerClass(pq);var fq=class extends lq{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new YG(`truncatedNormal does not support dType ${t}.`);return Dz(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};fq.className="TruncatedNormal",hV.registerClass(fq);var mq=class extends lq{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return WD((()=>{if(2!==e.length||e[0]!==e[1])throw new KG("Identity matrix initializer can only be used for 2D square matrices.");return iF(this.gain,aP(e[0]))}))}getConfig(){return{gain:this.gain}}};mq.className="Identity",hV.registerClass(mq);var gq=class extends lq{constructor(e){if(super(),e.scale<0)throw new KG(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function(e){hH(iq,"FanMode",e)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function(e){hH(oq,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){let n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(CH(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){let r=zH(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){let r=zH(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{let r=zH(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],a=n[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){let n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new YG(`${this.getClassName()} does not support dType ${t}.`);return Dz(e,0,n,t,this.seed)}{let n=Math.sqrt(3*s);return zL(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};gq.className="VarianceScaling",hV.registerClass(gq);var yq=class extends gq{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return gq.className}};yq.className="GlorotUniform",hV.registerClass(yq);var bq=class extends gq{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return gq.className}};bq.className="GlorotNormal",hV.registerClass(bq);var vq=class extends gq{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return gq.className}};vq.className="HeNormal",hV.registerClass(vq);var xq=class extends gq{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return gq.className}};xq.className="HeUniform",hV.registerClass(xq);var wq=class extends gq{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return gq.className}};wq.className="LeCunNormal",hV.registerClass(wq);var kq=class extends gq{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return gq.className}};kq.className="LeCunUniform",hV.registerClass(kq);var Sq=class extends lq{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return WD((()=>{if(e.length<2)throw new YG("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);let n=iR.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let s=ZH([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=lV.qr(s,!1),o=i[0],l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=iF(o,l.sign()),n<r&&(o=o.transpose()),iF(qO(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}};Sq.className="Orthogonal",hV.registerClass(Sq);var Iq={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Tq(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return lH(e,hV.SerializationMap.getMap().classNameMap,t,"initializer")}function Nq(e){return iH(e)}function Cq(e){if("string"==typeof e){let t=e in Iq?Iq[e]:e;if("GlorotNormal"===t)return new bq;if("GlorotUniform"===t)return new yq;if("HeNormal"===t)return new vq;if("HeUniform"===t)return new xq;if("LeCunNormal"===t)return new wq;if("LeCunUniform"===t)return new kq;{let e={};return e.className=t,e.config={},Tq(e)}}return e instanceof lq?e:Tq(e)}function Aq(e){return Array.isArray(e)&&Array.isArray(e[0])}function Eq(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function _q(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new KG(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function $q(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new KG(`Expected exactly 1 Shape; got ${e.length}`)}return e}function Rq(e){let t=0;for(let n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}var Dq="Variable",Mq=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Dq,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=bH(),n=null==n?Dq:n,this.originalName=DH(n),this.name=MH(this.originalName),this.trainable_=r,this.constraint=a,this.val=Lz(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function Fq(e){return e.map((e=>e.read()))}function Oq(e){e.forEach((e=>{e[0].write(e[1])}))}var Pq=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Lq=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=bH(),null!=s&&(this.originalName=DH(s),this.name=MH(this.originalName)),this.rank=t.length}},zq=0,Bq=class{constructor(e,t){this.callArgs=t,this.id=zq++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},Vq=0,Wq=class extends hV.Serializable{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Vq++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let e=this.getClassName();t=rH(e)+"_"+xH(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new qG(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new KG(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return tH(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return tH(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new HG(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new HG(`Layer ${this.name} is not connected, no input to return.`);return tH(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new HG(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new HG(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return tH(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=nH(e);if(null==this.inputSpec||0===this.inputSpec.length)return;let n=nH(this.inputSpec);if(t.length!==n.length)throw new KG(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let e=t[r],a=n[r];if(null==a)continue;let s=e.rank;if(null!=a.ndim&&s!==a.ndim)throw new KG(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new KG(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new KG(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&e.dtype!==a.dtype)throw new KG(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${e.dtype}.`);if(a.axes){let t=e.shape;for(let e in a.axes){let n=Number(e),s=a.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=s&&-1===[s,null].indexOf(i))throw new KG(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){let n=a.shape[t],s=e.shape[t];if(null!=n&&null!=s&&n!==s)throw new KG(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=nH(e),r=function(e){let t=!0;for(let n of nH(e))if(!(n instanceof Lq)){t=!1;break}return t}(e),a=function(e){let t=!0;for(let n of nH(e))if(n instanceof Lq){t=!1;break}return t}(e);if(r===a)throw new KG("Arguments to apply() must be all SymbolicTensors or all Tensors");return RH(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of nH(e))t.push(n.shape);this.build(tH(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);let a=nH(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=tH(s),null!=this.activityRegularizer)throw new YG("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{let n,r=function(e){e=nH(e);let t=[];for(let n of e)t.push(n.shape);return tH(t)}(e),a=this.computeOutputShape(r),s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?r[0]:r),n=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,r)=>new Lq(s,n,this,nH(e),t,this.name,r))):new Lq(s,a,this,nH(e),t,this.name),this.addInboundNode(e,n,null,null,r,a,t),this._refCount++,null!=this.activityRegularizer)throw new YG("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new HG(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new HG(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new qG(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Rq(this.weights)}build(e){this.built=!0}getWeights(){return Fq(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){WD((()=>{let t=this.weights;if(t.length!==e.length)throw new KG(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let n=[],r=Fq(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!iR.arraysEqual(s.shape,o.shape))throw new KG(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}Oq(n)}))}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new KG(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():Cq("zeros"));let l=r.apply(t,n),u=new Mq(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=nH(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),a=nH(t),s=nH(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=s[i]}addInboundNode(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=nH(e);t=nH(t),n=nH(n),r=nH(r),a=Eq(a),s=Eq(s);let l=[],u=[],c=[];for(let d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new Bq({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function Uq(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{let e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{let t=[];for(let n=0;n<e.inboundLayers.length;n++){let r=Uq(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(let e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}var jq=class extends Wq{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:xH("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new KG("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new KG("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new KG("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new Lq(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new Bq({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new KG(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function Gq(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new KG("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new jq({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}jq.className="InputLayer",hV.registerClass(jq);var Hq=class e{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof e)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(let e of t)this.add(e.key,e.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new KG(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,n){if(null==e.dtype||e.dtype===n.dtype)return n;try{return eF(n,e.dtype)}catch(t){throw new KG(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Lq){if(null==this.id2Value[e.id])throw new KG(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{let t=this.name2Id[e];if(null==t)throw new KG(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Lq){if(null==this.id2Value[e.id])throw new KG(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{let t=this.name2Id[e];if(null==t)throw new KG(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&UD(this.id2Mask)}},qq=new QG,Kq=new QG;function Yq(e,t,n,r){let a=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(let f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let c,d=o.join(",")+"|"+t.names().sort().join(","),h=qq.get(d);if(null==h){let e=function(e,t){iR.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){let a=Qq(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:e,recipientMap:i}=Qq(s,t);for(let t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(let t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:Xq(r)}}(i,t);h=e.sorted,c=e.recipientCounts,qq.put(d,h),Kq.put(d,c)}c={},a||Object.assign(c,Kq.get(d));let p=new Hq(t);for(let f=0;f<h.length;++f){if(null!=r){let e=BD().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}let e=h[f],s=e.sourceLayer;if(s instanceof jq)continue;let i=[],u=[],d=[],m=!1;for(let n of e.inputs){let e=p.getValue(n),r=p.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),a||(c[n.name]--,0===c[n.name]&&!t.hasKey(n)&&-1===o.indexOf(n.name)&&!e.isDisposed&&!0!==n.sourceLayer.stateful&&d.push(e))}m&&((n=n||{}).mask=u[0]);let g=nH(s.apply(i,n)),y=null;s.supportsMasking&&(y=s.computeMask(i,u));let b=Zq(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);let e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}a||UD(d)}return p.disposeMasks(),s?l:l[0]}function Xq(e){let t={};for(let n in e)t[n]=e[n].size;return t}function Qq(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let e=s[s.length-1];if(n.has(e.name)){s.pop();continue}let t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(let t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),!n.has(t.name)&&s.push(t)}}return{sorted:r,recipientMap:a}}function Zq(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}IA().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=qq&&qq.setMaxEntries(e),null!=Kq&&Kq.setMaxEntries(e)}));var Jq={};function eK(e,t){return WD((()=>KO(XO(iF(e,e),t,!0))))}tC(Jq,{maxNorm:()=>cK,minMaxNorm:()=>pK,nonNeg:()=>hK,unitNorm:()=>dK});var tK=class extends hV.Serializable{getConfig(){return{}}},nK=class extends tK{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return WD((()=>{let t=eK(e,this.axis),n=nO(t,0,this.maxValue);return iF(e,sF(n,rF(UH(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};nK.className="MaxNorm",hV.registerClass(nK);var rK=class extends tK{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return WD((()=>sF(e,rF(UH(),eK(e,this.axis)))))}getConfig(){return{axis:this.axis}}};rK.className="UnitNorm",hV.registerClass(rK);var aK=class extends tK{apply(e){return jL(e)}};aK.className="NonNeg",hV.registerClass(aK);var sK=class extends tK{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return WD((()=>{let t=eK(e,this.axis),n=rF(iF(this.rate,nO(t,this.minValue,this.maxValue)),iF(1-this.rate,t));return iF(e,sF(n,rF(UH(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};sK.className="MinMaxNorm",hV.registerClass(sK);var iK={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function oK(e){return iH(e)}function lK(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return lH(e,hV.SerializationMap.getMap().classNameMap,t,"constraint")}function uK(e){if(null==e)return null;if("string"==typeof e){return lK({className:e in iK?iK[e]:e,config:{}})}return e instanceof tK?e:lK(e)}function cK(e){return new nK(e)}function dK(e){return new rK(e)}function hK(){return new aK}function pK(e){return new sK(e)}var fK={};function mK(){return new uq}function gK(){return new cq}function yK(e){return new dq(e)}function bK(e){return new hq(e)}function vK(e){return new pq(e)}function xK(e){return new fq(e)}function wK(e){return new mq(e)}function kK(e){return new gq(e)}function SK(e){return new yq(e)}function IK(e){return new bq(e)}function TK(e){return new vq(e)}function NK(e){return new xq(e)}function CK(e){return new wq(e)}function AK(e){return new kq(e)}function EK(e){return new Sq(e)}tC(fK,{constant:()=>yK,glorotNormal:()=>IK,glorotUniform:()=>SK,heNormal:()=>TK,heUniform:()=>NK,identity:()=>wK,leCunNormal:()=>CK,leCunUniform:()=>AK,ones:()=>gK,orthogonal:()=>EK,randomNormal:()=>vK,randomUniform:()=>bK,truncatedNormal:()=>xK,varianceScaling:()=>kK,zeros:()=>mK});var _K,$K={};async function RK(e){if(null==e)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if("number"!=typeof s){let e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){let a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];UD(r)}}function DK(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}tC($K,{Layer:()=>Wq,RNN:()=>GX,RNNCell:()=>HX,activation:()=>IZ,add:()=>DZ,alphaDropout:()=>SJ,average:()=>MZ,averagePooling1d:()=>UZ,averagePooling2d:()=>HZ,averagePooling3d:()=>YZ,avgPool1d:()=>jZ,avgPool2d:()=>qZ,avgPool3d:()=>XZ,avgPooling1d:()=>GZ,avgPooling2d:()=>KZ,avgPooling3d:()=>QZ,batchNormalization:()=>BZ,bidirectional:()=>mJ,categoryEncoding:()=>AJ,centerCrop:()=>NJ,concatenate:()=>FZ,conv1d:()=>mZ,conv2d:()=>gZ,conv2dTranspose:()=>yZ,conv3d:()=>bZ,conv3dTranspose:()=>vZ,convLstm2d:()=>dJ,convLstm2dCell:()=>hJ,cropping2D:()=>wZ,dense:()=>TZ,depthwiseConv2d:()=>SZ,dot:()=>zZ,dropout:()=>NZ,elu:()=>uZ,embedding:()=>RZ,flatten:()=>AZ,gaussianDropout:()=>kJ,gaussianNoise:()=>wJ,globalAveragePooling1d:()=>ZZ,globalAveragePooling2d:()=>JZ,globalMaxPool1d:()=>yJ,globalMaxPool2d:()=>bJ,globalMaxPooling1d:()=>eJ,globalMaxPooling2d:()=>tJ,gru:()=>sJ,gruCell:()=>iJ,input:()=>HY,inputLayer:()=>lZ,layerNormalization:()=>VZ,leakyReLU:()=>dZ,lstm:()=>oJ,lstmCell:()=>lJ,masking:()=>IJ,maxPool1d:()=>vJ,maxPool2d:()=>xJ,maxPooling1d:()=>nJ,maxPooling2d:()=>rJ,maxPooling3d:()=>aJ,maximum:()=>OZ,minimum:()=>PZ,multiply:()=>LZ,permute:()=>$Z,prelu:()=>hZ,randomWidth:()=>EJ,reLU:()=>cZ,repeatVector:()=>EZ,rescaling:()=>TJ,reshape:()=>_Z,resizing:()=>CJ,rnn:()=>pJ,separableConv2d:()=>xZ,simpleRNN:()=>uJ,simpleRNNCell:()=>cJ,softmax:()=>pZ,spatialDropout1d:()=>CZ,stackedRNNCells:()=>fJ,thresholdedReLU:()=>fZ,timeDistributed:()=>gJ,upSampling2d:()=>kZ,zeroPadding2d:()=>WZ}),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(_K||(_K={}));var MK=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},FK=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},OK=class extends MK{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let n=null==t.size?0:t.size;this.seen+=n;for(let r in t){let e=t[r];if("number"==typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;let a=WD((()=>rF(this.totals[r],iF(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?t[n]=this.totals[n]/this.seen:WD((()=>{let e=iF(sF(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),jD(t[n])})))}},PK=class extends MK{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(let n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let r=this.history[a];for(let s=0;s<r.length;++s)if("number"!=typeof r[s]){let i=r[s];e.push(i.data()),t.push(a),n.push(s)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},LK=class extends MK{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||DW,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");iR.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():iR.now();return function(){let s=null!=n?n():iR.now();return s-a<t||(a=s,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];null!=this.yield&&(await RK(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await RK(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];null!=this.epochEnd&&(await RK(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await RK(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];null!=this.batchEnd&&(await RK(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):iR.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await RK(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await RK(e),await this.trainEnd(e))}};function zK(e,t){return null==e&&(e={}),e instanceof MK?[e]:Array.isArray(e)&&e[0]instanceof MK?e:nH(e).map((e=>new LK(e,t)))}var BK=class e{constructor(){}static registerCallbackConstructor(t,n){iR.assert(t>=0&&Number.isInteger(t),(()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`)),e.checkForDuplicate(n),null==e.constructors[t]&&(e.constructors[t]=[]),e.constructors[t].push(n)}static checkForDuplicate(t){for(let n in e.constructors)e.constructors[+n].forEach((e=>{if(e===t)throw new KG("Duplicate callback constructor.")}))}static clear(){e.constructors={}}static createCallbacks(t){let n=[];for(let r in e.constructors){let a=+r;t>=a&&n.push(...e.constructors[a])}return n.map((e=>new e))}};function VK(e,t,n,r,a,s,i,o,l){let u=new PK,c=[new OK,...BK.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);let d=new FK(c);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function WK(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return lH(e,hV.SerializationMap.getMap().classNameMap,t,"layer",n)}function UK(e,t){return WD((()=>{"float32"!==e.dtype&&(e=eF(e,"float32"));let n=XO(tq(e),t,!0),r=tO(n.shape,UH()),a=KO(UP(n,r));return sF(e,a)}))}function jK(e,t){return WD((()=>jP(tq(_P(t,e)),-1)))}function GK(e,t){return WD((()=>jP(oF(_P(t,e)),-1)))}function HK(e,t){return WD((()=>{let n=_P(e,t),r=nO(oF(e),UH(),Number.MAX_VALUE),a=oF(sF(n,r));return iF(100,jP(a,-1))}))}function qK(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return WD((()=>{if(n)t=uz(t);else{let e=XO(t,t.shape.length-1,!0);t=sF(t,e)}return t=nO(t,UH(),1-UH()),CP(XO(iF(eF(e,"float32"),bP(t)),t.shape.length-1))}))}function KK(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return WD((()=>{let r=eF(sP(function(e){let t=[zH(e.shape)];return FF(e,t)}(e)),"int32"),a=(t=nO(t,UH(),1-UH())).shape;return qK(FF(tL(r,a[a.length-1]),a),t,n)}))}function YK(e,t){return WD((()=>{let n;return n=nO(t,UH(),1-UH()),n=bP(sF(n,_P(1,n))),jP(function(e,t){if(!iR.arraysEqual(e.shape,t.shape))throw new KG(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return WD((()=>{let n=jL(t),r=CP(oF(t));return rF(_P(n,iF(t,e)),vP(eP(r)))}))}(e,n),-1)}))}function XK(e,t){return WD((()=>{let n=UK(e,-1),r=UK(t,-1),a=iF(n,r);return CP(XO(a,-1))}))}BK.constructors={};var QK={meanSquaredError:jK,meanAbsoluteError:GK,meanAbsolutePercentageError:HK,meanSquaredLogarithmicError:function(e,t){return WD((()=>{let n=nO(t,UH(),Number.MAX_VALUE),r=bP(rF(1,n)),a=nO(e,UH(),Number.MAX_VALUE),s=bP(rF(1,a));return jP(tq(_P(r,s)),-1)}))},squaredHinge:function(e,t){return WD((()=>{let n=UP(0,_P(1,iF(e,t)));return jP(tq(n),-1)}))},hinge:function(e,t){return WD((()=>{let n=UP(0,_P(1,iF(e,t)));return jP(n,-1)}))},categoricalHinge:function(e,t){return WD((()=>{let n=XO(iF(e,t),-1),r=jO(iF(_P(1,e),t),-1);return UP(0,rF(1,_P(r,n)))}))},logcosh:function(e,t){return WD((()=>{let n=Math.log(2),r=_P(t,e),a=_P(rF(r,AP(iF(-2,r))),n);return jP(a,-1)}))},categoricalCrossentropy:qK,sparseCategoricalCrossentropy:KK,binaryCrossentropy:YK,kullbackLeiblerDivergence:function(e,t){return WD((()=>{let n=nO(e,UH(),1),r=nO(t,UH(),1);return XO(iF(e,bP(sF(n,r))),-1)}))},poisson:function(e,t){return WD((()=>{let n=bP(rF(UH(),t));return jP(_P(t,iF(e,n)),-1)}))},cosineProximity:XK};function ZK(e){if("string"==typeof e){if(e in QK)return QK[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new KG(t)}return e}function JK(e,t){return WD((()=>{let n=iF(.5,nL(t)),r=jH(oP(t,n),e.dtype);return jP(CO(e,r),-1)}))}function eY(e,t){return WD((()=>jH(CO(pF(e,-1),pF(t,-1)),"float32")))}function tY(e,t){return WD((()=>eF(XO(DP(CO(e,1),CO(t,1))),"float32")))}function nY(e,t){return WD((()=>{let n=tY(e,t),r=function(e,t){return WD((()=>eF(XO(DP(CO(e,0),CO(t,1))),"float32")))}(e,t),a=rF(n,r);return eF(AO(oP(a,0),sF(n,a),0),"float32")}))}function rY(e,t){return WD((()=>{let n=tY(e,t),r=function(e,t){return WD((()=>eF(XO(DP(CO(e,1),CO(t,0))),"float32")))}(e,t),a=rF(n,r);return eF(AO(oP(a,0),sF(n,a),0),"float32")}))}function aY(e,t){return YK(e,t)}function sY(e,t){return e.rank===t.rank&&(e=gz(e,[e.rank-1])),(t=pF(t,-1)).dtype!==e.dtype&&(t=eF(t,e.dtype)),eF(CO(e,t),"float32")}var iY=qK,oY=KK,lY={binaryAccuracy:JK,categoricalAccuracy:eY,precision:nY,categoricalCrossentropy:iY,sparseCategoricalCrossentropy:oY,mse:jK,MSE:jK,mae:GK,MAE:GK,mape:HK,MAPE:HK,cosine:XK};function uY(e){if("string"==typeof e&&e in lY)return lY[e];if("string"!=typeof e&&null!=e)return e;throw new KG(`Unknown metric ${e}`)}function cY(e){if(JG(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let n of Object.keys(QK))if(QK[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(lY))if(lY[n]===e){t=n;break}return void 0!==t?t:e.name}}function dY(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!hY(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function hY(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if("string"!=typeof n||!hY(e[n]))return!1;return!0}if(Array.isArray(e)){for(let t of e)if(!hY(t))return!1;return!0}return!1}{let t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function pY(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log,s=function(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let e=!1;for(let n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),i=["Layer (type)","Input Shape","Output shape","Param #"];if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){i.push("Receives inputs"),r=[];for(let t in e.nodesByDepth)r.push(...e.nodesByDepth[t])}a("_".repeat(t)),fY(i,n,a),a("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)s?mY(o[c],n,a):gY(o[c],n,r,a),a((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=function(e){let t;return t=null!=e.collectedTrainableWeights?Rq(e.collectedTrainableWeights):Rq(e.trainableWeights),t}(e),u=Rq(e.nonTrainableWeights);a(`Total params: ${l+u}`),a(`Trainable params: ${l}`),a(`Non-trainable params: ${u}`),a("_".repeat(t))}function fY(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function mY(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(s){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(s){r="multiple"}fY([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function gY(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(c){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(c){a="multiple"}let i=[];for(let d of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(d)))for(let e=0;e<d.inboundLayers.length;++e){let t=d.inboundLayers[e].name,n=d.nodeIndices[e],r=d.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}let o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];fY([`${o} (${l})`,s,a,e.countParams().toString(),u],t,r);for(let d=1;d<i.length;++d)fY(["","","","",i[d]],t,r)}function yY(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function bY(e,t){if(null===e)return null;if("string"==typeof e)return aH(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];yY(t,a,r)?n.push(r):n.push(bY(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{let e=aH(n);t[e]=bY(r,e)}}return t}}function vY(e,t){if(null==e)return null;if("string"==typeof e)return rH(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];yY(t,a,r)?n.push(r):n.push(vY(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n],a=rH(n);t[a]="name"!==n&&"className"!==n||"string"!=typeof r?vY(r,n):r}return t}}var xY="4.16.0",wY=class e extends Wq{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){let e=this.getClassName().toLowerCase();this.name=xH(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],cH(this.inputs).length!==this.inputs.length)throw new KG(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);cH(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let e of this.outputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(let e of this.inputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;JG(0===n,"input layer has >1 nodes"),JG(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let e=0;e<this.inputLayers.length;e++){let n=this.inputLayers[e];if(!(n instanceof jq))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${e} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(let e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));let n={},r={},a={},s={},i={},o=[],l=(t,n,r,a,s,u)=>{(null==a||null==s||null==u)&&(a=t.sourceLayer,s=t.nodeIndex,u=t.tensorIndex);let c=a.inboundNodes[s];if(-1!==r.indexOf(c))throw new qG(`The tensor ${t.name} at layer "${a.name}" is part of a cycle.`);if(-1!==n.indexOf(c))return;this.containerNodes.add(e.nodeKey(a,s)),a.id in i||(i[a.id]=Object.keys(i).length),-1===r.indexOf(c)&&r.push(c);let d=c.inboundLayers.length;for(let e=0;e<d;e++){let t=c.inputTensors[e],a=c.inboundLayers[e],s=c.nodeIndices[e],i=c.tensorIndices[e];l(t,n,r,a,s,i)}for(n.push(c);r.indexOf(c)>=0;)r.splice(r.indexOf(c),1);o.push(c)},u=[],c=[];for(let e of this.outputs)l(e,u,c);let d=o.slice().reverse();for(let e of d){r[e.id]=e,e.id in n||(n[e.id]=0);let t=n[e.id],i=null==a[e.outboundLayer.id]?0:a[e.outboundLayer.id];t=Math.max(t,i),a[e.outboundLayer.id]=t,s[e.outboundLayer.id]=e.outboundLayer,n[e.id]=t;for(let a=0;a<e.inboundLayers.length;a++){let s=e.inboundLayers[a],i=e.nodeIndices[a],o=s.inboundNodes[i],l=null==n[o.id]?0:n[o.id];n[o.id]=Math.max(t+1,l),r[o.id]=o}}let h={};for(let e in n){let t=n[e];t in h||(h[t]=[]),h[t].push(r[e])}let p={};for(let e in a){let t=a[e];t in p||(p[t]=[]),p[t].push(s[e])}let f=Object.keys(p).map((e=>parseInt(e,10))).sort(uH);this.layers=[];for(let b of f){let t=p[b];t.sort(((e,t)=>{let n=i[e.id],r=i[t.id];return n<r?-1:n>r?1:0}));for(let n of t)n instanceof e&&this.internalContainerRefs.push(n),this.layers.push(n)}this.layersByDepth=p,f=Object.keys(h).map((e=>parseInt(e,10))).sort(uH);let m=this.inputs.slice(),g=[];for(let e of f)for(let t of h[e]){let e=t.outboundLayer;if(null!=e){for(let n of t.inputTensors)if(-1===m.indexOf(n))throw new qG(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${g}`);for(let e of t.outputTensors)m.push(e);g.push(e.name)}}this.nodesByDepth=h;let y=this.layers.map((e=>e.name));for(let e of y){let t=y.filter((t=>t===e)).length;if(1!==t)throw new qG(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new Bq({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new KG("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n={},r=0,a=(e=>{let t=Object.keys(e);if(0===t.length)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);a&&this.parseWeights(e);for(let i of this.layers)for(let[e,t]of i.weights.entries()){let s=a?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[s])throw new KG(`Duplicate weight name: ${s}`);n[s]=t,r++}let s=[];for(let i in e){let r=i;if(null==n[i]){let e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])s.push([n[r],e[i]]);else if(t)throw new KG(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new KG(`${e.length} of ${r} weights are not set: ${e}`)}Oq(s)}parseWeights(e){for(let t in Object.keys(e)){let n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${xY}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=vY(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return WD((()=>{e=nH(e);let n=new Hq;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return Yq(this.outputs,n,t)}))}computeMask(e,t){return WD((()=>{let n;return e=nH(e),n=null==t?ZG(null,e.length):nH(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){let t=Eq(e);if(t.length!==this.inputLayers.length)throw new KG(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(uH);if(r.length>1)for(let i of r){let e=this.nodesByDepth[i];for(let t of e){let e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;let r=[];for(let i=0;i<t.inboundLayers.length;i++){let e=t.inboundLayers[i],a=t.nodeIndices[i],s=t.tensorIndices[i],o=n[`${e.name}_${a}_${s}`];r.push(o)}let a=Eq(e.computeOutputShape(tH(r))),s=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++){n[`${e.name}_${s}_${t}`]=a[t]}}}let a=[],s=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;s.push(r)}for(let i=0;i<s.length;i++){let e=s[i];JG(e in n),a.push(n[e])}return tH(a)}runInternalGraph(e,t){null==t&&(t=ZG(null,e.length));let n={};for(let o=0;o<this.inputs.length;++o){let r=this.inputs[o],a=e[o],s=t[o];n[r.id]=[a,s]}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(uH);for(let o of r){let e=this.nodesByDepth[o];for(let t of e){let e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,s=new Array;for(let t of r)t.id in n&&s.push(n[t.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){let[t,n]=s[0];null==u.mask&&(u.mask=n),o=nH(e.call(t,u)),l=nH(e.computeMask(t,n)),r=[t],i=[n]}else r=s.map((e=>e[0])),i=s.map((e=>e[1])),null==u.mask&&(u.mask=i),o=nH(e.call(r,u)),l=nH(e.computeMask(r,i));if(e.activityRegularizer)throw new YG("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){let t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}let a=[],s=[],i=[];for(let o of this.outputs){JG(o.id in n,`Could not compute output ${o.name} : ${o.id}`);let[e,t]=n[o.id];i.push(e.shape),a.push(e),s.push(t)}return[a,s,i]}buildNodeConversionMap(t){let n,r={};for(let a of this.layers){n=a instanceof e?1:0;for(let t=0;t<a.inboundNodes.length;t++){let s=e.nodeKey(a,t);this.containerNodes.has(s)&&(r[s]=n,n+=1)}}return r}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new KG("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(let n of this.layers)if(n.name===e)return n;throw new KG(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new KG(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return WD((()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let a=e.nodeKey(n,r);this.containerNodes.has(a)&&t.push(...n.calculateLosses())}return t}))}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let o of this.layers){let t=o.getClassName(),a=o.getConfig(),s=[];for(let r=0;r<o.inboundNodes.length;r++){let t=o.inboundNodes[r],a=e.nodeKey(o,r),l={};if(this.containerNodes.has(a)){if(t.callArgs)try{JSON.stringify(t.callArgs),l=t.callArgs}catch(i){console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${t.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),l={}}if(t.inboundLayers.length>0){let r=[];for(let a=0;a<t.inboundLayers.length;a++){let s=t.inboundLayers[a],i=t.nodeIndices[a],o=t.tensorIndices[a],u=n[e.nodeKey(s,i)];null==u&&(u=0),r.push([s.name,u,o,l])}s.push(r)}}}let l={};l.name=o.name,l.className=t,l.config=a,l.inboundNodes=s,r.push(l)}t.layers=r;let a=[];for(let o=0;o<this.inputLayers.length;o++){let t=this.inputLayers[o],r=this.inputLayersNodeIndices[o],s=e.nodeKey(t,r);if(!this.containerNodes.has(s))continue;let i=n[s];null==i&&(i=0);let l=this.inputLayersTensorIndices[o];a.push([t.name,i,l])}t.inputLayers=a;let s=[];for(let o=0;o<this.outputLayers.length;o++){let t=this.outputLayers[o],r=this.outputLayersNodeIndices[o],a=e.nodeKey(t,r);if(!this.containerNodes.has(a))continue;let i=n[a];null==i&&(i=0);let l=this.outputLayersTensorIndices[o];s.push([t.name,i,l])}return t.outputLayers=s,t}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={},a={};function s(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function i(e,t){let n,a=[];for(let i of t){let o=i[0],l=i[1],u=i[2];if(n=null==i[3]?{}:i[3],!(o in r))return void s(e,t);let c=r[o];if(c.inboundNodes.length<=l)return void s(e,t);let d=c.inboundNodes[l];a.push(d.outputTensors[u])}a.length>0&&e.apply(tH(a),n)}function o(e){let a=e.name,i=WK(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[a]=i,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new KG(`Corrupted configuration, expected array for nodeData: ${e}`);s(i,e)}))}let l=t.name,u=t.layers;for(let f of u)o(f);for(;!dH(a);)for(let e of u){let t=r[e.name];if(t.name in a){let e=a[t.name];delete a[t.name];for(let n of e)i(t,n)}}let c=[],d=[],h=t.inputLayers;for(let f of h){let e=f[0],t=f[1],n=f[2];JG(e in r);let a=r[e].inboundNodes[t].outputTensors;c.push(a[n])}let p=t.outputLayers;for(let f of p){let e=f[0],t=f[1],n=f[2];JG(e in r);let a=r[e].inboundNodes[t].outputTensors;d.push(a[n])}return new e({inputs:c,outputs:d,name:l})}get stateful(){if(this._stateful)throw new KG("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){WD((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}};function kY(e,t){return function(e,t,n){let r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function SY(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){let t=WD((()=>{if(1===e.shape.length)return tF(e);if(2===e.shape.length){if(e.shape[1]>1)return pF(e,1);if(1===e.shape[1])return FF(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());UD(t);let a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),wz(a,"float32")}return null}function IY(e,t){return iF(e,t)}function TY(e,t){let n,r,a=t;n=a.xs,r=a.ys,iR.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));let s=NY("input",e.inputNames,n),i=NY("output",e.outputNames,r),o=s[0].shape[0];iR.assert(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),iR.assert(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<s.length;l++)iR.assert(s[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)iR.assert(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:i}}function NY(e,t,n){if(n instanceof jR)return[n];if(Array.isArray(n))return iR.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{let r=[];for(let a of t){if(null==n[a])throw new KG(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function CY(e,t,n){let r=null!=n.batchesPerEpoch;if(iR.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),iR.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),iR.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),iR.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),iR.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a,s,i=null!=n.validationData;if(i)if(AY(n.validationData))iR.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{let e=function(e){if(3===e.length)throw new YG("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,s=e.ys}let o,l=e.makeTrainFunction(),u=e.getDedupedMetricsNames();o=i?u.slice().concat(u.map((e=>"val_"+e))):u.slice();let c=zK(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=VK(c,d,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,i,o);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let o={};await h.onEpochBegin(f);let c=0,d=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){let t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){let{xs:r,ys:a}=TY(e,t.value),s={};s.batch=d,s.size=r[0].shape[0],await h.onBatchBegin(d,s);let i=[];if(null!=n.classWeight){let t=kY(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await SY(a[e],null,t[e]))}let o=r.concat(a).concat(i),p=l(o);UD(o);for(let e=0;e<u.length;++e){let t=u[e],n=p[e];s[t]=n,jD(n)}await h.onBatchEnd(d,s),DK(s),d++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(i){let t;t=AY(n.validationData)?nH(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):nH(e.evaluate(a,s,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)o[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,o),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function AY(e){return"function"==typeof e.iterator}function EY(e){iR.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function _Y(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>HH(e,t,n-t))):HH(e,t,n-t)}function $Y(e,t){return WD((()=>null==e?null:Array.isArray(e)?e.map((e=>$Y(e,t))):eq(e,"int32"===t.dtype?t:eF(t,"int32"))))}function RY(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function DY(e){let t=[];e instanceof jR&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(1===r.rank)t.push(GH(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function MY(e,t){if(null==e)return;let n=[];if(t instanceof jR)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(let a in t){let e=t[a];n.push(e.id)}let r=[];if(e instanceof jR)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(let a in e){let t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function FY(e){return Array.isArray(e)}function OY(e){return!function(e){return e instanceof jR}(e)&&!FY(e)}function PY(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(FY(e)&&e.length>0)t=!0;else if(OY(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new KG(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(OY(e)){r=[];for(let n of t){if(null==e[n])throw new KG(`No data provided for "${n}". Need data for each key in: ${t}`);r.push(e[n])}}else if(FY(e)){if(e.length!==t.length)throw new KG(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);r=e}else{if(t.length>1)throw new KG(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);r=[e]}if(r=DY(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=r[i];if(e.shape.length!==n[i].length)throw new KG(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!a)continue;let r=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&r!==o)throw new KG(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return r}function LY(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new KG(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);r=e}else{if(t.length>1)throw new KG(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=r[i];if(e.shape.length!==n[i].length)throw new KG(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let r=0;r<n[i].length;++r){if(0===r&&!a)continue;let o=e.shape[r],l=n[i][r];if(null!=l&&l!==o)throw new KG(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}var zY=class extends wY{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new KG("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");pY(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){let t={Adagrad:()=>$W.adagrad(.01),Adadelta:()=>$W.adadelta(1,.95,UH()),Adam:()=>$W.adam(.001,.9,.999,UH()),Adamax:()=>$W.adamax(.002,.9,.999,UH(),0),RMSProp:()=>$W.rmsprop(.001,.9,0,UH()),SGD:()=>$W.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new KG(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof vV))throw new KG("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new KG(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map((e=>ZK(e)))}else{let n=ZK(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(let t in e.loss)if(-1===this.outputNames.indexOf(t))throw new KG(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(ZK(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],RH("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));let r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{let e=[];for(let r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};RH("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,s;for(let i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){let t,a=this.internalOutputShapes[e];1===a[a.length-1]||this.lossFunctions[e]===YK?-1!==["accuracy","acc"].indexOf(i)?r=JK:-1!==["crossentropy","ce"].indexOf(i)&&(r=aY):this.lossFunctions[e]===KK?-1!==["accuracy","acc"].indexOf(i)?r=sY:-1!==["crossentropy","ce"].indexOf(i)&&(r=oY):-1!==["accuracy","acc"].indexOf(i)?r=eY:-1!==["crossentropy","ce"].indexOf(i)&&(r=iY),-1!==["accuracy","acc"].indexOf(i)?t="acc":-1!==["crossentropy","ce"].indexOf(i)&&(t="ce"),s=r,n=""+t}else s=uY(i),n=""+cY(i);let t;RH(n,(()=>{t=s})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=null==n.batchSize?32:n.batchSize;EY(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let e=a[0].concat(a[1]);this.makeTestFunction();let t=this.testFunction;return tH(this.testLoop(t,e,r,n.verbose,n.steps))}finally{MY(a[0],e),MY(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){let r=null!=(n=n||{}).batches,a=e.testFunction,s=[];if(n.verbose>0)throw new YG("Verbose mode is not implemented yet.");iR.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));let i=function(e){return"function"==typeof e.next}(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let t=await i.next();if(s=WD((()=>{if(t.value){let{xs:n,ys:r}=TY(e,t.value),i=n.concat(r),u=WD((()=>a(i)));if(UD(i),0===l)for(let e=0;e<u.length;++e)s.push(qO(0));let c=i[0].shape[0];for(let e=0;e<u.length;++e){let t=u[e],n=s[e];s[e]=WD((()=>rF(s[e],iF(c,t)))),l>0&&UD(n)}UD(u),o+=c,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let e=s[u];s[u]=sF(s[u],o),UD(e)}return tH(s)}(this,e,t)}checkNumSamples(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new KG(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new KG(`Either the input data should have a defined shape, or ${a} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new KG("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new Hq;if(e instanceof jR&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new KG(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(let o of this.inputs){let t=e[o.name];if(null==t)throw new KG(`No value is provided for the model's input ${o.name}`);s.add(o,t)}let i=Yq(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=ZG(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){let i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){let n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new KG(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return WD((()=>{let r=this.checkNumSamples(e);if(n)throw new YG("Verbose predictLoop() is not implemented yet.");let a=RY(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t)WD((()=>{let n=a[t][0],r=a[t][1],s=_Y(e,n,r),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});let o=new Hq(i);return Yq(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)));return tH(s.map((e=>LF(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=DY(e);LY(n,this.inputNames,this.feedInputShapes,!1);try{let e=null==t.batchSize?32:t.batchSize;return EY(e),this.predictLoop(n,e)}finally{MY(n,e)}}predictOnBatch(e){LY(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new qG("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let r=[];for(let a=0;a<this.feedOutputShapes.length;++a){let e=this.feedOutputShapes[a];this.feedLossFns[a]===KK?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){let n=cH(e.map((e=>e.shape[0])));n.sort();let r=cH(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new KG(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new KG(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!iR.arraysEqual(n,r))throw new KG(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=PY(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=PY(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){let r=[jK,YK,qK];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(null!=i){if(i===qK&&1===s.shape[s.shape.length-1])throw new KG(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){let e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){let r=e[n],a=t[n];if(null!=a&&r!==a)throw new KG(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new KG(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0,[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){let e=kY(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await SY(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return WD((()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new YG("Verbose mode is not implemented yet.");if(null!=a)throw new YG("steps mode in testLoop() is not implemented yet");{let r=RY(s,n),a=wz(WH(0,s));for(let n=0;n<r.length;++n){let s=r[n][0],o=r[n][1],l=HH(a,s,o-s),u=$Y(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(qO(0));for(let e=0;e<c.length;++e){let t=c[e];i[e]=rF(i[e],iF(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=sF(i[e],s)}return i}))}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;if(eH(e,r)>1){a+=`_${eH(e.slice(0,n),r)}`}t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{let e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});let i,o=new Hq(e),l=Yq(this.outputs,o,{training:!0});for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],l[n]);null!=a[n]&&(e=IY(e,a[n]));let s=jP(e);t.push(s),i=0===n?e:rF(i,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{let t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=jP(t(r[a],l[a]))}jD(e),s.push(e)}return i=jP(i),this.calculateLosses().forEach((e=>{i=rF(i,e)})),i}),!0,i)].concat(s)}}makeTestFunction(){this.testFunction=e=>WD((()=>{let t,n=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});let i=new Hq(s),o=Yq(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){let r=this.lossFunctions[e],s=jP(r(a[e],o[e]));t=0===e?s:rF(t,s),n.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=jP(t(a[r],o[r]));n.push(s)}return n}))}async fit(e,t){let n,r,a,s,i,o,l,u,c,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{let h=null==d.batchSize?32:d.batchSize;EY(h);let p=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,!1,h);n=p[0],r=p[1],c=p[2];let f,m=!1;if(null!=d.validationData&&d.validationData.length>0){if(m=!0,2!==d.validationData.length)throw 3===d.validationData.length?new YG("validationData including sample weights is not supported yet."):new KG(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${d.validationData} is invalid.`);i=d.validationData[0],o=d.validationData[1];let e=await this.standardizeUserData(i,o,null,null,!0,h);l=e[0],u=e[1],f=l.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){m=!0;let e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];l=_Y(n,e,t),a=n,n=_Y(n,0,e),u=_Y(r,e,t),s=r,r=_Y(r,0,e),f=l.concat(u)}else null!=d.validationSteps&&(m=!0);let g=n.concat(r).concat(c);this.checkTrainableWeightsConsistency();let y,b,v=this.makeTrainFunction(),x=this.getDedupedMetricsNames();m?(this.makeTestFunction(),y=this.testFunction,b=x.slice().concat(x.map((e=>"val_"+e)))):(y=null,f=[],b=x.slice());let w=zK(d.callbacks,d.yieldEvery);return await this.fitLoop(v,g,x,h,d.epochs,d.verbose,w,y,f,d.shuffle,b,d.initialEpoch,null,null)}finally{this.isTraining=!1,MY(n,e),MY(r,t),MY(a,e),MY(s,t),MY(l,i),MY(u,o),null!=c&&UD(c)}}async fitLoop(e,t,n,r,a,s,i,o,l,u,c,d,h,p){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==h))throw new KG("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m,g=this.checkNumSamples(t,r,h,"steps_per_epoch");null!=g&&(m=WH(0,g)),null==s&&(s=1);let{callbackList:y,history:b}=VK(i,s,a,d,g,h,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=d;v<a;++v){await y.onEpochBegin(v);let a={};if(null!=h)throw new YG("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new YG("batch shuffling is not implemneted yet");u&&iR.shuffle(m);let s=wz(m),i=RY(g,r);for(let u=0;u<i.length;++u){let c={};if(await y.onBatchBegin(u,c),WD((()=>{let d=i[u][0],h=i[u][1],p=HH(s,d,h-d);c.batch=u,c.size=h-d;let m=$Y(t,p),g=e(m);for(let e=0;e<n.length;++e){let t=n[e],r=g[e];c[t]=r,jD(r)}if(u===i.length-1&&f){let e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){let r=n[t],s=e[t];jD(s),a["val_"+r]=s}}})),await y.onBatchEnd(u,c),DK(c),this.stopTraining_)break}s.dispose()}if(await y.onEpochEnd(v,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return CY(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let o of s){let e=await o.data();i.push(e[0])}return UD(s),MY(n[0],e),MY(n[1],t),tH(i)}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=BD().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-BD().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=rH(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>rH(e)))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=rH(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[rH(cY(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>rH(cY(e))));{let e={};for(let t in this.metrics)e[t]=rH(cY(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");let t,n,r=WK(bY(e.optimizer_config));if("string"==typeof e.loss)t=aH(e.loss);else if(Array.isArray(e.loss))t=e.loss.map((e=>aH(e)));else if(null!=e.loss){t={};for(let n in e.loss)t[n]=aH(e.loss[n])}if(Array.isArray(e.metrics))n=e.metrics.map((e=>aH(e)));else if(null!=e.metrics){n={};for(let t in e.metrics)n[t]=aH(e.metrics[t])}this.compile({loss:t,metrics:n,optimizer:r})}async save(e,t){if("string"==typeof e){let t=AV.getSaveHandlers(e);if(0===t.length)throw new KG(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new KG(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new KG("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await AV.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${xY}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();let e="optimizer",{data:t,specs:a}=await AV.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...a),n.data=AV.concatenateArrayBuffers([n.data,t])}return null!=this.userDefinedMetadata&&(dY(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){dY(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};zY.className="Model",hV.registerClass(zY);var BY=class extends zY{};async function VY(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);let r=WK(bY(n),t);if(null!=e.weightsManifest){let t=await AV.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map((e=>e.originalName))),n={};for(let e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),UD(t)}return r}async function WY(e,t){if(null==t&&(t={}),"string"==typeof e){let n=AV.getLoadHandlers(e,t);if(0===n.length)n.push(AV.browserHTTPRequest(e,t));else if(n.length>1)throw new KG(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return async function(e,t,n){if(null==n&&(n={}),null==e.load)throw new KG("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;null!=a.model_config&&(a=a.model_config);let s=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&s,o=WK(bY(a),t,i),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new KG("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:e,optimizerWeights:t}=function(e,t){let n=AV.decodeWeights(e,t),r={},a=[];return t.forEach((e=>{"optimizer"===e.group?a.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);o.loadWeights(e,s),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),UD(e),UD(t.map((e=>e.tensor)))}return o}(e,void 0,t)}BY.className="Functional",hV.registerClass(BY);var UY=class e extends zY{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:xH("sequential_"),null!=e.layers)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new KG(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n,r=t instanceof e||t instanceof zY;if(r){if(n=t,1!==n.outputs.length)throw new KG("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new KG("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new KG("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let e=Gq({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(r)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new KG(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new KG("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=Uq(this.outputs[0])}this.inboundNodes=[],new Bq({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ZG(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{let e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if($q(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new zY({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new qG("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new qG("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new qG("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new qG("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(t,n){let r,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s={};if(n instanceof Array){if(null==n[0].className||"Merge"===n[0].className)throw new KG("Legacy serialization format not supported yet.");r=n}else iR.assert(null!=n.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),r=n.layers,delete n.layers,s=n;let i=new t(s);if(!(i instanceof e))throw new YG(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let e of r){let t=WK(e,void 0,a);a&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new KG("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new KG("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};function jY(e){return new zY(e)}function GY(e){return new UY(e)}function HY(e){return Gq(e)}function qY(e,t){BK.registerCallbackConstructor(e,t)}UY.className="Sequential",hV.registerClass(UY);var KY=class extends hV.Serializable{getConfig(){return{}}},YY=class extends KY{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new YG(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return DO(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}};YY.className="elu",hV.registerClass(YY);var XY=class extends KY{apply(e){return JL(e)}};XY.className="selu",hV.registerClass(XY);var QY=class extends KY{apply(e){return jL(e)}};QY.className="relu",hV.registerClass(QY);var ZY=class extends KY{apply(e){return WD((()=>KP(6,jL(e))))}};ZY.className="relu6",hV.registerClass(ZY);var JY=class extends KY{apply(e){return e}};JY.className="linear",hV.registerClass(JY);var eX=class extends KY{apply(e){return BF(e)}};eX.className="sigmoid",hV.registerClass(eX);var tX=class extends KY{apply(e){return function(e){return WD((()=>{let t=rF(.5,iF(.2,e));return nO(t,0,1)}))}(e)}};tX.className="hardSigmoid",hV.registerClass(tX);var nX=class extends KY{apply(e){return AP(e)}};nX.className="softplus",hV.registerClass(nX);var rX=class extends KY{apply(e){return function(e){return WD((()=>sF(e,rF(oF(e),1))))}(e)}};rX.className="softsign",hV.registerClass(rX);var aX=class extends KY{apply(e){return WF(e)}};aX.className="tanh",hV.registerClass(aX);var sX=class extends KY{apply(e){return uz(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}};sX.className="softmax",hV.registerClass(sX);var iX=class extends KY{apply(e){return $P(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}};iX.className="logSoftmax",hV.registerClass(iX);var oX=class extends KY{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return WD((()=>iF(BF(iF(e,t)),e)))}};oX.className="swish",hV.registerClass(oX);var lX=class extends KY{apply(e){return WD((()=>iF(e,WF(AP(e)))))}};function uX(e){return e.getClassName()}function cX(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return lH(e,hV.SerializationMap.getMap().classNameMap,t,"activation")}function dX(e){if(null==e){let e={className:"linear",config:{}};return cX(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},cX(t)}return e instanceof KY?e:cX(e)}function hX(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}lX.className="mish",hV.registerClass(lX);var pX=class extends hV.Serializable{},fX=class extends pX{constructor(e){super(),hX(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return WD((()=>{let t=GP([1]);return this.hasL1&&(t=rF(t,XO(iF(this.l1,oF(e))))),this.hasL2&&(t=rF(t,XO(iF(this.l2,tq(e))))),FF(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};fX.className="L1L2",hV.registerClass(fX);var mX={l1l2:"L1L2"};function gX(e){return iH(e)}function yX(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return lH(e,hV.SerializationMap.getMap().classNameMap,t,"regularizer")}function bX(e){if(null==e)return null;if("string"==typeof e){return yX({className:e in mX?mX[e]:e,config:{}})}return e instanceof pX?e:yX(e)}var vX=class extends Wq{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=_q(e);let n=jL(e);return null!=this.maxValue&&(n=nO(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};vX.className="ReLU",hV.registerClass(vX);var xX=class extends Wq{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=_q(e);return pP(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};xX.className="LeakyReLU",hV.registerClass(xX);var wX=class extends Wq{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Cq(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=bX(e.alphaRegularizer),this.alphaConstraint=uK(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new KG(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){let t=(e=$q(e)).slice(1);if(null!=this.sharedAxes)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Pq({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=_q(e),dL(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Nq(this.alphaInitializer),alphaRegularizer:gX(this.alphaRegularizer),alphaConstraint:oK(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};wX.className="PReLU",hV.registerClass(wX);var kX=class extends Wq{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new YG(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=_q(e);return DO(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};kX.className="ELU",hV.registerClass(kX);var SX=class extends Wq{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let n=_q(e);return iF(n,eF(oP(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};SX.className="ThresholdedReLU",hV.registerClass(SX);var IX=class extends Wq{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new sX).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return WD((()=>{let n=_q(e),r=t.mask;if(null!=r){let e=iF(_P(HP(n.shape),eF(r,n.dtype)),qO(-1e9));n=rF(n,e)}return this.axis instanceof Array?this.axis.length>1?eP(_P(n,RP(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function TX(e,t,n){if("number"==typeof e)return ZG(e,t);if(e.length!==t)throw new KG(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!LH(a))throw new KG(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function NX(e,t,n,r){let a;return null==e?e:(a="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r))}function CX(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+VH([n-t,0]);else{if("same"!==r)throw new KG(`Unsupport padding mode: ${r}.`);e*=t}return e}function AX(e,t){return WD((()=>(CH(t),"channelsFirst"===t?Wz(e,[0,2,3,1]):e)))}function EX(e,t){return WD((()=>(CH(t),"channelsFirst"===t?Wz(e,[0,2,3,4,1]):e)))}function _X(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return WD((()=>{if(null==s&&(s="channelsLast"),CH(s),3!==e.rank&&4!==e.rank)throw new KG(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new KG(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=AX(e,s);if("causal"===a)throw new YG("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Qz.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=Wz(l,[0,3,1,2])),l}))}IX.className="Softmax",hV.registerClass(IX);var $X=class e extends Wq{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.verifyArgs(n),this.rank=t,fH(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new YG(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=TX(n.kernelSize,t,"kernelSize"),this.strides=TX(null==n.strides?1:n.strides,t,"strides"),this.padding=null==n.padding?"valid":n.padding,AH(this.padding),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,CH(this.dataFormat),this.activation=dX(n.activation),this.useBias=null==n.useBias||n.useBias,this.biasInitializer=Cq(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=uK(n.biasConstraint),this.biasRegularizer=bX(n.biasRegularizer),this.activityRegularizer=bX(n.activityRegularizer),this.dilationRate=TX(null==n.dilationRate?1:n.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new KG(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new KG(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new KG(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(JG("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!pH(e.kernelSize,"number",1,3))throw new KG(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:uX(this.activation),useBias:this.useBias,biasInitializer:Nq(this.biasInitializer),biasRegularizer:gX(this.biasRegularizer),activityRegularizer:gX(this.activityRegularizer),biasConstraint:oK(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},RX=class e extends $X{constructor(t,n){super(t,n),this.kernel=null,e.verifyArgs(n),this.filters=n.filters,fH(this.filters,"filters"),this.kernelInitializer=Cq(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=uK(n.kernelConstraint),this.kernelRegularizer=bX(n.kernelRegularizer)}build(e){e=$q(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new KG(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return WD((()=>{e=_q(e);let t,n=null==this.bias?null:this.bias.read(),r=gH(this.activation.getClassName());if(null!=r&&2===this.rank)t=_X(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return WD((()=>{if(null==s&&(s="channelsLast"),CH(s),3!==e.shape.length)throw new KG(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new KG(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new KG(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===s&&(e=Wz(e,[0,2,1])),"causal"===a)throw new YG("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=lO(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=rq(o,n)),o}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=_X(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new YG("convolutions greater than 3D are not implemented yet.");t=function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return WD((()=>{if(null==s&&(s="channelsLast"),CH(s),4!==e.rank&&5!==e.rank)throw new KG(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new KG(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=EX(e,s);if("causal"===a)throw new YG("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=dO(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=rq(o,n)),"channelsFirst"===s&&(o=Wz(o,[0,4,1,2,3])),o}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=$q(e);let t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){let e=NX(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:Nq(this.kernelInitializer),kernelRegularizer:gX(this.kernelRegularizer),kernelConstraint:oK(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new KG(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},DX=class e extends RX{constructor(t){super(2,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!pH(e.kernelSize,"number",1,2))throw new KG(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};DX.className="Conv2D",hV.registerClass(DX);var MX=class e extends RX{constructor(t){super(3,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new KG(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};MX.className="Conv3D",hV.registerClass(MX);var FX=class extends DX{constructor(e){if(super(e),this.inputSpec=[new Pq({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new KG(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=$q(e)).length)throw new KG("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new KG("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Pq({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return WD((()=>{let t=_q(e);if(4!==t.shape.length)throw new KG(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a=t.shape,s=a[0];"channelsFirst"===this.dataFormat?(n=2,r=3):(n=1,r=2);let i=a[n],o=a[r],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],h=[s,CX(i,c,l,this.padding),CX(o,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Wz(t,[0,2,3,1]));let p=cO(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=Wz(p,[0,3,1,2])),null!=this.bias&&(p=rq(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){let t,n,r,a=(e=$q(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return a[t]=this.filters,a[n]=CX(a[n],o,s,this.padding),a[r]=CX(a[r],l,i,this.padding),a}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};FX.className="Conv2DTranspose",hV.registerClass(FX);var OX=class extends MX{constructor(e){if(super(e),this.inputSpec=[new Pq({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new KG(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=$q(e)).length)throw new KG("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new KG("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Pq({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return WD((()=>{let t=_q(e);if(5!==t.shape.length)throw new KG(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a,s=t.shape,i=s[0];"channelsFirst"===this.dataFormat?(a=2,n=3,r=4):(a=1,n=2,r=3);let o=s[a],l=s[n],u=s[r],c=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[i,CX(o,p,c,this.padding),CX(l,f,d,this.padding),CX(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Wz(t,[0,2,3,4,1]));let y=pO(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=Wz(y,[0,4,1,2,3])),null!==this.bias&&(y=rq(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){let t,n,r,a,s=(e=$q(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3,a=4):(t=4,n=1,r=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return s[t]=this.filters,s[n]=CX(s[n],u,i,this.padding),s[r]=CX(s[r],c,o,this.padding),s[a]=CX(s[a],d,l,this.padding),s}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};OX.className="Conv3DTranspose",hV.registerClass(OX);var PX=class extends RX{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new KG("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new KG("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new KG(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Cq(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=bX(t.depthwiseRegularizer),this.depthwiseConstraint=uK(t.depthwiseConstraint),this.pointwiseInitializer=Cq(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=bX(t.pointwiseRegularizer),this.pointwiseConstraint=uK(t.pointwiseConstraint)}build(e){if((e=$q(e)).length<this.rank+2)throw new KG(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new KG(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new Pq({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return WD((()=>{let t;if(e=_q(e),1===this.rank)throw new YG("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Wz(e,[0,2,3,1])),t=ez(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=rq(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Wz(t,[0,3,1,2])),t}))}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Nq(this.depthwiseInitializer),e.pointwiseInitializer=Nq(this.pointwiseInitializer),e.depthwiseRegularizer=gX(this.depthwiseRegularizer),e.pointwiseRegularizer=gX(this.pointwiseRegularizer),e.depthwiseConstraint=oK(this.depthwiseConstraint),e.pointwiseConstraint=oK(this.pointwiseConstraint),e}};PX.className="SeparableConv";var LX=class extends PX{constructor(e){super(2,e)}};LX.className="SeparableConv2D",hV.registerClass(LX);var zX=class e extends RX{constructor(t){super(1,t),e.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!pH(e.kernelSize,"number",1,1))throw new KG(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};zX.className="Conv1D",hV.registerClass(zX);var BX=class extends Wq{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return WD((()=>{if(e=_q(e),"channelsLast"===this.dataFormat){let t=KH(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return KH(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=KH(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return KH(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};BX.className="Cropping2D",hV.registerClass(BX);var VX=class extends Wq{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,CH(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function(e){hH(kH,"InterpolationFormat",e)}(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{let t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return WD((()=>{let t=_q(e),n=t.shape;if("channelsFirst"===this.dataFormat){t=Wz(t,[0,2,3,1]);let e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?oV.resizeNearestNeighbor(t,[e,r]):oV.resizeBilinear(t,[e,r]);return Wz(a,[0,3,1,2])}{let e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?oV.resizeNearestNeighbor(t,[e,r]):oV.resizeBilinear(t,[e,r])}}))}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};VX.className="UpSampling2D",hV.registerClass(VX);var WX=class extends $X{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Cq(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=uK(e.depthwiseConstraint),this.depthwiseRegularizer=bX(e.depthwiseRegularizer)}build(e){if((e=$q(e)).length<4)throw new KG(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new KG(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return WD((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return WD((()=>{null==a&&(a="channelsLast"),CH(a);let i=AX(e,a);if(4!==e.rank)throw new KG(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new KG(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=xO(i,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(i=Wz(i,[0,3,1,2])),i}))}(e=_q(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=rq(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=$q(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=NX(t,this.kernelSize[0],this.padding,this.strides[0]),s=NX(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Nq(this.depthwiseInitializer),e.depthwiseRegularizer=gX(this.depthwiseRegularizer),e.depthwiseConstraint=oK(this.depthwiseRegularizer),e}};function UX(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new KG("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function jX(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return WD((()=>{let l=t.shape.length;if(l<3)throw new KG(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(WH(2,l));if(t=Wz(t,u),null!=s)throw new YG("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=eF(eF(a,"bool"),"float32"),a.rank===l-1&&(a=tP(a,-1)),a=Wz(a,u)),r&&(t=HL(t,0),null!=a&&(a=HL(a,0)));let c,d,h,p=[],f=n,m=t.shape[0],g=Oz(t);null!=a&&(d=Oz(a));for(let t=0;t<m;++t){let n=g[t],r=WD((()=>e(n,f)));if(null==a)c=r[0],f=r[1];else{let e=WD((()=>{let e=d[t],n=_P(nL(e),e),a=rF(iF(r[0],e),iF(f[0],n)),s=f.map(((t,a)=>rF(iF(r[1][a],e),iF(t,n))));return{output:a,newStates:s}}));c=e.output,f=e.newStates}o&&p.push(c)}return o&&(h=yz(p,1)),[c,h,f]}))}WX.className="DepthwiseConv2D",hV.registerClass(WX);var GX=class e extends Wq{constructor(e){let t;if(super(e),null==e.cell)throw new KG("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new JX({cells:e.cell}):e.cell,null==t.stateSize)throw new KG("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Pq({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return WH(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Aq(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){let r=[];for(let n of t)r.push([e[0],n]);return[n].concat(r)}return n}computeMask(e,t){return WD((()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;if(this.returnState){let t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new YG("Constants support is not implemented in RNN yet.");Aq(e)&&(e=e[0]);let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Pq({shape:[t,null,...n]});let r,a=[e[0]].concat(e.slice(2));if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!iR.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new KG(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((e=>new Pq({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];WD((()=>{if(!this.stateful)throw new HG("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(null==n)throw new KG("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>GP([n,e]))):this.states_=[GP([n,this.cell.stateSize])];else if(null==e)UD(this.states_),null!=this.keptStates&&(UD(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>GP([n,e]))):this.states_[0]=GP([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new KG(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):UD(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!iR.arraysEqual(r.shape,s))throw new KG(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>jD(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=UX(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(let e of n)this.stateSpec.push(new Pq({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof Lq){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return WD((()=>{let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;e=_q(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new KG(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:r},o=jX(((e,t)=>{let n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);let d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return WD((()=>{let t=GP(e.shape);return t=XO(t,[1,2]),t=GH(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?QH(t,[1,e]):t)):this.cell.stateSize>1?[QH(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===e.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=WK(t.cell,n);return new e(Object.assign(t,{cell:r}))}};GX.className="RNN",hV.registerClass(GX);var HX=class extends Wq{},qX=class extends HX{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,fH(this.units,"units"),this.activation=dX(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Cq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Cq(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Cq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=bX(e.kernelRegularizer),this.recurrentRegularizer=bX(e.recurrentRegularizer),this.biasRegularizer=bX(e.biasRegularizer),this.kernelConstraint=uK(e.kernelConstraint),this.recurrentConstraint=uK(e.recurrentConstraint),this.biasConstraint=uK(e.biasConstraint),this.dropout=BH([1,VH([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=BH([1,VH([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=$q(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return WD((()=>{if(2!==e.length)throw new KG(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=eQ({ones:()=>nL(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=eQ({ones:()=>nL(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;a=JH(null!=s?iF(e,s):e,this.kernel.read()),null!=this.bias&&(a=rq(a,this.bias.read())),null!=i&&(n=iF(n,i));let o=rF(a,JH(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:uX(this.activation),useBias:this.useBias,kernelInitializer:Nq(this.kernelInitializer),recurrentInitializer:Nq(this.recurrentInitializer),biasInitializer:Nq(this.biasInitializer),kernelRegularizer:gX(this.kernelRegularizer),recurrentRegularizer:gX(this.recurrentRegularizer),biasRegularizer:gX(this.biasRegularizer),activityRegularizer:gX(this.activityRegularizer),kernelConstraint:oK(this.kernelConstraint),recurrentConstraint:oK(this.recurrentConstraint),biasConstraint:oK(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};qX.className="SimpleRNNCell",hV.registerClass(qX);var KX=class extends GX{constructor(e){e.cell=new qX(e),super(e)}call(e,t){return WD((()=>{null!=this.cell.dropoutMask&&(UD(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(UD(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}};KX.className="SimpleRNN",hV.registerClass(KX);var YX=class extends HX{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new KG("GRUCell does not support reset_after parameter set to true.");this.units=e.units,fH(this.units,"units"),this.activation=dX(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=dX(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Cq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Cq(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Cq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=bX(e.kernelRegularizer),this.recurrentRegularizer=bX(e.recurrentRegularizer),this.biasRegularizer=bX(e.biasRegularizer),this.kernelConstraint=uK(e.kernelConstraint),this.recurrentConstraint=uK(e.recurrentConstraint),this.biasConstraint=uK(e.biasConstraint),this.dropout=BH([1,VH([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=BH([1,VH([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){let t=(e=$q(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return WD((()=>{if(2!==e.length)throw new KG(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=null!=t.training&&t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=eQ({ones:()=>nL(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=eQ({ones:()=>nL(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a,s,i,o=this.dropoutMask,l=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=iF(e,o[0]));let u=JH(e,this.kernel.read());this.useBias&&(u=rq(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=iF(r,l[0]));let c=this.recurrentKernel.read(),[d,h]=pz(c,[2*this.units,this.units],c.rank-1),p=JH(r,d),[f,m,g]=pz(u,3,u.rank-1),[y,b]=pz(p,2,p.rank-1);a=this.recurrentActivation.apply(rF(f,y)),s=this.recurrentActivation.apply(rF(m,b));let v=JH(iF(s,r),h);i=this.activation.apply(rF(g,v));let x=rF(iF(a,r),iF(rF(1,CP(a)),i));return[x,x]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:uX(this.activation),recurrentActivation:uX(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Nq(this.kernelInitializer),recurrentInitializer:Nq(this.recurrentInitializer),biasInitializer:Nq(this.biasInitializer),kernelRegularizer:gX(this.kernelRegularizer),recurrentRegularizer:gX(this.recurrentRegularizer),biasRegularizer:gX(this.biasRegularizer),activityRegularizer:gX(this.activityRegularizer),kernelConstraint:oK(this.kernelConstraint),recurrentConstraint:oK(this.recurrentConstraint),biasConstraint:oK(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};YX.className="GRUCell",hV.registerClass(YX);var XX=class extends GX{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new YX(e),super(e)}call(e,t){return WD((()=>{null!=this.cell.dropoutMask&&(UD(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(UD(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};XX.className="GRU",hV.registerClass(XX);var QX=class extends HX{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,fH(this.units,"units"),this.activation=dX(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=dX(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Cq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Cq(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Cq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=bX(e.kernelRegularizer),this.recurrentRegularizer=bX(e.recurrentRegularizer),this.biasRegularizer=bX(e.biasRegularizer),this.kernelConstraint=uK(e.kernelConstraint),this.recurrentConstraint=uK(e.recurrentConstraint),this.biasConstraint=uK(e.biasConstraint),this.dropout=BH([1,VH([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=BH([1,VH([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n,r=(e=$q(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,r=this.units;n=new(t=class extends lq{apply(t,n){let a=e.apply([r]),s=(new cq).apply([r]),i=e.apply([2*r]);return XH(XH(a,s),i)}},t.className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return WD((()=>{let n=null!=t.training&&t.training;if(3!==e.length)throw new KG(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=eQ({ones:()=>nL(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=eQ({ones:()=>nL(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s,i,o,l,u=this.dropoutMask,c=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=iF(e,u[0]));let d=JH(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=iF(r,c[0])),d=rF(d,JH(r,this.recurrentKernel.read())),this.useBias&&(d=rq(d,this.bias.read()));let[h,p,f,m]=pz(d,4,d.rank-1);s=this.recurrentActivation.apply(h),i=this.recurrentActivation.apply(p),o=rF(iF(i,a),iF(s,this.activation.apply(f))),l=this.recurrentActivation.apply(m);let g=iF(l,this.activation.apply(o));return[g,g,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:uX(this.activation),recurrentActivation:uX(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Nq(this.kernelInitializer),recurrentInitializer:Nq(this.recurrentInitializer),biasInitializer:Nq(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:gX(this.kernelRegularizer),recurrentRegularizer:gX(this.recurrentRegularizer),biasRegularizer:gX(this.biasRegularizer),activityRegularizer:gX(this.activityRegularizer),kernelConstraint:oK(this.kernelConstraint),recurrentConstraint:oK(this.recurrentConstraint),biasConstraint:oK(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};QX.className="LSTMCell",hV.registerClass(QX);var ZX=class extends GX{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new QX(e),super(e)}call(e,t){return WD((()=>{null!=this.cell.dropoutMask&&(UD(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(UD(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};ZX.className="LSTM",hV.registerClass(ZX);var JX=class extends HX{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return WD((()=>{let n=e.slice(1),r=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a,s=[];for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(let e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;Aq(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{RH(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){let e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=[];for(let a of t.cells)r.push(WK(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Fq(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}Oq(t)}};function eQ(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):aq(t(),n),o=()=>sq(i,t,r);return!a||a<=1?jD(o().clone()):Array(a).fill(void 0).map(o).map((e=>jD(e.clone())))}JX.className="StackedRNNCells",hV.registerClass(JX);var tQ=class extends GX{constructor(e){if(e.unroll)throw new YG("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new YG("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Pq({ndim:5})]}call(e,t){return WD((()=>{if(null!=this.cell.dropoutMask&&(UD(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(UD(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new KG("ConvRNN2D cell does not support constants");let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return WD((()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=GP([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];WD((()=>{if(!this.stateful)throw new HG("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new KG("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>GP(a))):this.states_=[GP(a)];else if(null==e)UD(this.states_),null!=this.keptStates&&(UD(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>GP(a))):this.states_[0]=GP(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new KG(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):UD(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],r=a;if(!iR.arraysEqual(n.shape,r))throw new KG(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>jD(e.clone())))}))}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=NX(l,r[0],a,s[0],i[0]),d=NX(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}};tQ.className="ConvRNN2D";var nQ=class extends QX{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,fH(this.filters,"filters"),this.kernelSize=TX(n,2,"kernelSize"),this.kernelSize.forEach((e=>fH(e,"kernelSize"))),this.strides=TX(r||1,2,"strides"),this.strides.forEach((e=>fH(e,"strides"))),this.padding=a||"valid",AH(this.padding),this.dataFormat=s||"channelsLast",CH(this.dataFormat),this.dilationRate=TX(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>fH(e,"dilationRate")))}build(e){var t;e=$q(e);let n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new KG(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,r=this.filters;e=new((t=class extends lq{apply(e,t){return YH([n.apply([r]),HP([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return WD((()=>{if(3!==e.length)throw new KG(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=eQ({ones:()=>nL(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?iF(t[n],e):e,l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),d=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=eQ({ones:()=>nL(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,p=o(a,h,0),f=o(a,h,1),m=o(a,h,2),g=o(a,h,3),[y,b,v,x]=pz(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?pz(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,v,S,this.padding),d=this.inputConv(d,x,I,this.padding);let[T,N,C,A]=pz(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,T),f=this.recurrentConv(f,N),m=this.recurrentConv(m,C),g=this.recurrentConv(g,A);let E=this.recurrentActivation.apply(rF(l,p)),_=this.recurrentActivation.apply(rF(u,f)),$=rF(iF(_,s),iF(E,this.activation.apply(rF(c,m)))),R=iF(this.recurrentActivation.apply(rF(d,g)),this.activation.apply($));return[R,R,$]}))}getConfig(){let e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let a=oO(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?rq(a,n,this.dataFormat):a}recurrentConv(e,t){return oO(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};nQ.className="ConvLSTM2DCell",hV.registerClass(nQ);var rQ=class extends tQ{constructor(e){let t=new nQ(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};rQ.className="ConvLSTM2D",hV.registerClass(rQ);var aQ=class extends Wq{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return WD((()=>{this.invokeCallHook(e,t);let n=_q(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,r=this.getNoiseShape(n);return sq((()=>aq(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};aQ.className="Dropout",hV.registerClass(aQ);var sQ=class extends aQ{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};sQ.className="SpatialDropout1D",hV.registerClass(sQ);var iQ=class extends Wq{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,fH(this.units,"units"),this.activation=dX(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Cq(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Cq(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=uK(e.kernelConstraint),this.biasConstraint=uK(e.biasConstraint),this.kernelRegularizer=bX(e.kernelRegularizer),this.biasRegularizer=bX(e.biasRegularizer),this.activityRegularizer=bX(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){let t=(e=$q(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){let t=(e=$q(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return WD((()=>{this.invokeCallHook(e,t);let n,r=_q(e),a=gH(this.activation.getClassName());return null!=a?n=JH(r,this.kernel.read(),a,this.bias?this.bias.read():null):(n=JH(r,this.kernel.read()),null!=this.bias&&(n=rq(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n}))}getConfig(){let e={units:this.units,activation:uX(this.activation),useBias:this.useBias,kernelInitializer:Nq(this.kernelInitializer),biasInitializer:Nq(this.biasInitializer),kernelRegularizer:gX(this.kernelRegularizer),biasRegularizer:gX(this.biasRegularizer),activityRegularizer:gX(this.activityRegularizer),kernelConstraint:oK(this.kernelConstraint),biasConstraint:oK(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};iQ.className="Dense",hV.registerClass(iQ);var oQ=class extends Wq{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=$q(e);for(let t of e.slice(1))if(null==t)throw new KG(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],zH(e,1)]}call(e,t){return WD((()=>{this.invokeCallHook(e,t);let n=_q(e);if("channelsFirst"===this.dataFormat&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=Wz(n,e)}return function(e){if(e.rank<=1)throw new KG(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],zH(e.shape,1)];return FF(e,t)}(n)}))}getConfig(){let e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};oQ.className="Flatten",hV.registerClass(oQ);var lQ=class extends Wq{constructor(e){super(e),this.supportsMasking=!0,this.activation=dX(e.activation)}call(e,t){return WD((()=>{this.invokeCallHook(e,t);let n=_q(e);return this.activation.apply(n)}))}getConfig(){let e={activation:uX(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};lQ.className="Activation",hV.registerClass(lQ);var uQ=class extends Wq{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return WD((()=>function(e,t){return WD((()=>{if(2!==e.shape.length)throw new KG(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return QH(GH(e,1),[1,t,1])}))}(e=_q(e),this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};uQ.className="RepeatVector",hV.registerClass(uQ);var cQ=class extends Wq{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let o=0;o<r.length;++o){let e=r[o];if(this.isUnknown(e)){if(null!==s)throw new KG("Can only specifiy one unknown dimension.");s=o}else a*=e}let i=zH(e);if(null!==s){if(0===a||i%a!==0)throw new KG(n);r[s]=i/a}else if(i!==a)throw new KG(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return WD((()=>{this.invokeCallHook(e,t);let n=_q(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return FF(n,a)}))}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};cQ.className="Reshape",hV.registerClass(cQ);var dQ=class extends Wq{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=WH(1,e.dims.length+1);if(!iR.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Pq({ndim:this.dims.length+1})]}computeOutputShape(e){let t=(e=$q(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return Wz(_q(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};dQ.className="Permute",hV.registerClass(dQ);var hQ=class extends Wq{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=_q(e);return hF(eL(n,this.maskValue),-1)}call(e,t){return WD((()=>{this.invokeCallHook(e,t);let n=_q(e),r=hF(eL(n,this.maskValue),-1,!0);return iF(n,eF(r,n.dtype))}))}};hQ.className="Masking",hV.registerClass(hQ);var pQ=class extends Wq{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(nH(e.inputLength))}this.inputDim=e.inputDim,fH(this.inputDim,"inputDim"),this.outputDim=e.outputDim,fH(this.outputDim,"outputDim"),this.embeddingsInitializer=Cq(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=bX(e.embeddingsRegularizer),this.activityRegularizer=bX(e.activityRegularizer),this.embeddingsConstraint=uK(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return WD((()=>this.maskZero?(e=_q(e),eL(e,EO(e))):null))}computeOutputShape(e){if(e=$q(e),null==this.inputLength)return[...e,this.outputDim];let t=nH(this.inputLength);if(t.length!==e.length-1)throw new KG(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new KG(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return WD((()=>{this.invokeCallHook(e,t);let n=_q(e);"int32"!==n.dtype&&(n=jH(n,"int32"));let r=eq(this.embeddings.read(),FF(n,[n.size]));return FF(r,$q(this.computeOutputShape(n.shape)))}))}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Nq(this.embeddingsInitializer),embeddingsRegularizer:gX(this.embeddingsRegularizer),activityRegularizer:gX(this.activityRegularizer),embeddingsConstraint:oK(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};pQ.className="Embedding",hV.registerClass(pQ);var fQ=class extends Wq{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new YG}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new KG("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[$q(e)]),e.length<2)throw new KG(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=cH(t),t.length>1)throw new KG(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){let t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}let r=e.map((e=>e.length));-1===e.indexOf(null)&&1===cH(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return WD((()=>{if(this.reshapeRequired){let t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){let r=VH(n);for(let n of e){let e=n.rank;for(let t=0;t<r-e;++t)n=GH(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(let s of e){let e=s.rank;if(null==e){let e=s.shape,r=e[0],a=e.slice(1).concat([r]),i=FF(s,[r].concat(zH(e.slice(1))));i=Wz(i,[1,0]),i=FF(i,a),t.push(i),n=!0}else if(e>1){let r=WH(1,e).concat([0]);t.push(Wz(s,r)),n=!0}else t.push(s)}let r=this.mergeFunction(t),a=r.rank;if(n)if(null==a){let e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=FF(Wz(FF(r,[-1,t]),[1,0]),n)}else if(a>1){let e=[a-1].concat(WH(0,a-1));r=Wz(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){let n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(let r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=cH(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return WD((()=>{if(null==t)return null;if(!Array.isArray(t))throw new KG("`mask` should be an Array");if(!Array.isArray(e))throw new KG("`inputs` should be an Array");if(t.length!==e.length)throw new KG(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:tP(e,0))))[0];for(let e=1;e<t.length-1;++e)n=DP(n,t[e]);return n}))}},mQ=class extends fQ{constructor(e){super(e)}mergeFunction(e){return WD((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=rF(t,e[n]);return t}))}};mQ.className="Add",hV.registerClass(mQ);var gQ=class extends fQ{constructor(e){super(e)}mergeFunction(e){return WD((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=iF(t,e[n]);return t}))}};gQ.className="Multiply",hV.registerClass(gQ);var yQ=class extends fQ{constructor(e){super(e)}mergeFunction(e){return WD((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=rF(t,e[n]);return iF(1/e.length,t)}))}};yQ.className="Average",hV.registerClass(yQ);var bQ=class extends fQ{constructor(e){super(e)}mergeFunction(e){return WD((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=UP(t,e[n]);return t}))}};bQ.className="Maximum",hV.registerClass(bQ);var vQ=class extends fQ{constructor(e){super(e)}mergeFunction(e){return WD((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=KP(t,e[n]);return t}))}};vQ.className="Minimum",hV.registerClass(vQ);var xQ=class extends fQ{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new KG("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(let r of e)if(null!=r){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let t=e[r].slice();t.splice(this.axis,1);let a=!1;for(let e of n)if(iR.arraysEqual(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new KG("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return WD((()=>YH(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new KG("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new KG("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new KG("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new KG(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return WD((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;let r=[];for(let s=0;s<e.length;++s)null==t[s]?r.push(eF(nL(e[s]),"bool")):t[s].rank<e[s].rank?r.push(tP(t[s],-1)):r.push(t[s]);let a=LF(r,this.axis);return dF(a,-1,!1)}))}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function wQ(e,t){for(;e<0;)e+=t;return e}xQ.className="Concatenate",hV.registerClass(xQ);var kQ=class extends fQ{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){iR.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new YG("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new KG(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new KG(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>wQ(t,e[n].shape.length))):[wQ(this.axes,n.shape.length),wQ(this.axes,r.shape.length)],this.normalize&&(n=UK(n,t[0]),r=UK(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new YG("batchDot is not implemented for tensors of 4D or higher rank yet");if(iR.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),iR.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new YG("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);let s=n;return WD((()=>{let n,i;if(r>a){n=r-a;let e=[];for(let t=0;t<n;++t)e.push(1);t=FF(t,t.shape.concat(e))}else if(a>r){n=a-r;let t=[];for(let e=0;e<n;++e)t.push(1);e=FF(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?XO(iF(e,t),s[0]):XO(iF(Wz(e,[1,0]),t),s[1]);else{let n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;i=zF(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;let t=[];for(let r=e;r<e+n;++r)t.push(r);i=gz(i,t)}return 1===i.shape.length&&(i=tP(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[wQ(this.axes,e.length),wQ(this.axes,t.length)],n}computeOutputShape(e){iR.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new YG("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};kQ.className="Dot",hV.registerClass(kQ);var SQ=class extends Wq{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return WD((()=>{this.invokeCallHook(e,t);let n=_q(e);return sq((()=>rF(ZH(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}};SQ.className="GaussianNoise",hV.registerClass(SQ);var IQ=class extends Wq{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return WD((()=>{this.invokeCallHook(e,t);let n=_q(e);return this.rate>0&&this.rate<1?sq((()=>{let e=Math.sqrt(this.rate/(1-this.rate));return iF(n,ZH(n.shape,1,e))}),(()=>n),t.training||!1):n}))}};IQ.className="GaussianDropout",hV.registerClass(IQ);var TQ=class extends Wq{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||_q(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return WD((()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return sq((()=>{let t=_q(e),r=-1.7580993408473766,a=lP(zL(n),this.rate);a=jH(a,"float32");let s=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-s*r*this.rate,o=rF(iF(t,a),iF(rF(a,-1),r));return rF(iF(o,s),i)}),(()=>_q(e)),t.training||!1)}return e}))}};function NQ(e,t,n,r,a){let s,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)s=qF(e,t,n,r,a,i);else if(3===e.rank)s=KF(e,t,n,r,a,i);else{if(4!==e.rank)throw new YG(`batchNormalization is not implemented for array of rank ${e.rank} yet`);s=YF(e,t,n,r,a,i)}return s}function CQ(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return iR.arraysEqual(r.slice().sort(),WH(0,e.rank-1))?function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return WD((()=>{let s=QP(e,r),i=s.mean,o=s.variance;return[NQ(e,i,o,n,t,a),i,o]}))}(e,t,n,r,a):function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return WD((()=>{let s=QP(e,r),i=s.mean,o=s.variance,l=[];for(let t of WH(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);let u=FF(i,l),c=FF(o,l),d=null==t?null:FF(t,l),h=null==n?null:FF(n,l);return[NQ(e,u,c,h,d,a),i,o]}))}(e,t,n,r,a)}TQ.className="AlphaDropout",hV.registerClass(TQ);var AQ=class extends Wq{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Cq(e.betaInitializer||"zeros"),this.gammaInitializer=Cq(e.gammaInitializer||"ones"),this.movingMeanInitializer=Cq(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Cq(e.movingVarianceInitializer||"ones"),this.betaConstraint=uK(e.betaConstraint),this.gammaConstraint=uK(e.gammaConstraint),this.betaRegularizer=bX(e.betaRegularizer),this.gammaRegularizer=bX(e.gammaRegularizer)}build(e){e=$q(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new KG(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Pq({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return WD((()=>{let n=null!=t.training&&t.training,r=_q(e),a=r.shape,s=a.length,i=WH(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=ZG(1,s);l[o]=a[o];let u=i.slice();u.sort();let c=!iR.arraysEqual(u,WH(0,s).slice(0,s-1));if(!n)return(()=>{if(c){let e=FF(this.movingMean.read(),l),t=FF(this.movingVariance.read(),l),n=this.center?FF(this.beta.read(),l):null,a=this.scale?FF(this.gamma.read(),l):null;return NQ(r,e,t,n,a,this.epsilon)}return NQ(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();let[d,h,p]=CQ(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{WD((()=>{let r=1-n,a=e.read(),s=iF(_P(a,t),r);e.write(_P(a,s))}))};return f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum),d}))}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Nq(this.betaInitializer),gammaInitializer:Nq(this.gammaInitializer),movingMeanInitializer:Nq(this.movingMeanInitializer),movingVarianceInitializer:Nq(this.movingVarianceInitializer),betaRegularizer:gX(this.betaRegularizer),gammaRegularizer:gX(this.gammaRegularizer),betaConstraint:oK(this.betaConstraint),gammaConstraint:oK(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};AQ.className="BatchNormalization",hV.registerClass(AQ);var EQ=class extends Wq{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Cq(e.betaInitializer||"zeros"),this.gammaInitializer=Cq(e.gammaInitializer||"ones"),this.betaRegularizer=bX(e.betaRegularizer),this.gammaRegularizer=bX(e.gammaRegularizer),this.supportsMasking=!0}build(e){let t=(e=$q(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==cH(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=_q(e),r=n.shape,a=r.length;return WD((()=>{let{mean:e,variance:t}=QP(n,this.axis,!0),s=ZG(1,a);for(let n of this.axis)s[n]=r[n];let i=e=>null!=e&&e.shape.length!==a?FF(e,s):e,o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null,u=[],c=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=rP(e,u),t=rP(t,u),null!=o&&(o=rP(o,c)),null!=l&&(l=rP(l,c)),NQ(n,e,t,l,o,this.epsilon)}))}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Nq(this.betaInitializer),gammaInitializer:Nq(this.gammaInitializer),betaRegularizer:gX(this.betaRegularizer),gammaRegularizer:gX(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};EQ.className="LayerNormalization",hV.registerClass(EQ);var _Q=class extends Wq{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new KG(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new KG(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new KG(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Pq({ndim:4})]}computeOutputShape(e){let t,n;return e=$q(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return WD((()=>function(e,t,n){return WD((()=>{if(4!==e.rank)throw new KG(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new KG("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new KG(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],aL(e,r)}))}(_q(e),this.padding,this.dataFormat)))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function $Q(e,t,n,r,a,s){return WD((()=>{CH(a),EH(s),AH(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=AX(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?BP(e,t,n,o):OF(e,t,n,o),"channelsFirst"===a&&(i=Wz(i,[0,3,1,2])),i}))}function RQ(e,t,n,r,a,s){return WD((()=>{CH(a),EH(s),AH(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=EX(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?VP(e,t,n,o):PF(e,t,n,o),"channelsFirst"===a&&(i=Wz(i,[0,4,1,2,3])),i}))}_Q.className="ZeroPadding2D",hV.registerClass(_Q);var DQ=class extends Wq{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new KG(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(fH(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new KG(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}fH(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,AH(this.padding),this.inputSpec=[new Pq({ndim:3})]}computeOutputShape(e){let t=NX((e=$q(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return WD((()=>{this.invokeCallHook(e,t),e=GH(_q(e),2);let n=this.poolingFunction(_q(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return gz(n,[2])}))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},MQ=class extends DQ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CH(a),AH(r),$Q(e,t,n,r,a,"max")}};MQ.className="MaxPooling1D",hV.registerClass(MQ);var FQ=class extends DQ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CH(a),AH(r),$Q(e,t,n,r,a,"avg")}};FQ.className="AveragePooling1D",hV.registerClass(FQ);var OQ=class extends Wq{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new KG(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];fH(this.poolSize,"poolSize"),fH(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,CH(this.dataFormat),AH(this.padding),this.inputSpec=[new Pq({ndim:4})]}computeOutputShape(e){e=$q(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=NX(t,this.poolSize[0],this.padding,this.strides[0]),n=NX(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return WD((()=>(this.invokeCallHook(e,t),this.poolingFunction(_q(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},PQ=class extends OQ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CH(a),AH(r),$Q(e,t,n,r,a,"max")}};PQ.className="MaxPooling2D",hV.registerClass(PQ);var LQ=class extends OQ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CH(a),AH(r),$Q(e,t,n,r,a,"avg")}};LQ.className="AveragePooling2D",hV.registerClass(LQ);var zQ=class extends Wq{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new KG(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];fH(this.poolSize,"poolSize"),fH(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,CH(this.dataFormat),AH(this.padding),this.inputSpec=[new Pq({ndim:5})]}computeOutputShape(e){e=$q(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=NX(t,this.poolSize[0],this.padding,this.strides[0]),n=NX(n,this.poolSize[1],this.padding,this.strides[1]),r=NX(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return WD((()=>(this.invokeCallHook(e,t),this.poolingFunction(_q(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},BQ=class extends zQ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CH(a),AH(r),RQ(e,t,n,r,a,"max")}};BQ.className="MaxPooling3D",hV.registerClass(BQ);var VQ=class extends zQ{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CH(a),AH(r),RQ(e,t,n,r,a,"avg")}};VQ.className="AveragePooling3D",hV.registerClass(VQ);var WQ=class extends Wq{constructor(e){super(e),this.inputSpec=[new Pq({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new YG}},UQ=class extends WQ{constructor(e){super(e||{})}call(e,t){return WD((()=>{let t=_q(e);return jP(t,1)}))}};UQ.className="GlobalAveragePooling1D",hV.registerClass(UQ);var jQ=class extends WQ{constructor(e){super(e||{})}call(e,t){return WD((()=>{let t=_q(e);return jO(t,1)}))}};jQ.className="GlobalMaxPooling1D",hV.registerClass(jQ);var GQ=class extends Wq{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,CH(this.dataFormat),this.inputSpec=[new Pq({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new YG}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},HQ=class extends GQ{call(e,t){return WD((()=>{let t=_q(e);return"channelsLast"===this.dataFormat?jP(t,[1,2]):jP(t,[2,3])}))}};HQ.className="GlobalAveragePooling2D",hV.registerClass(HQ);var qQ=class extends GQ{call(e,t){return WD((()=>{let t=_q(e);return"channelsLast"===this.dataFormat?jO(t,[1,2]):jO(t,[2,3])}))}};qQ.className="GlobalMaxPooling2D",hV.registerClass(qQ);var KQ=class extends Wq{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=WK(t.layer,n);delete t.layer;let a={layer:r};return Object.assign(a,t),new e(a)}},YQ=class extends KQ{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=$q(e)).length<3)throw new KG(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){let t=[(e=$q(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return WD((()=>jX(((e,n)=>[_q(this.layer.call(e,t)),[]]),e=_q(e),[],!1,null,null,!1,!0)[1]))}};YQ.className="TimeDistributed",hV.registerClass(YQ);var XQ=class extends KQ{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=WK(n),t.goBackwards=!0!==t.goBackwards;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=WK(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function(e){hH(TH,"BidirectionalMergeMode",e)}(this.mergeMode),e.weights)throw new YG("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState&&(r=a.slice(1)),t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):tH(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=UX(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);let s=[],i=[];if(null!=n){let e=n.length;if(e%2>0)throw new KG("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let r=n.map((e=>new Pq({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new YG("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof Lq;for(let l of s)if(l instanceof Lq!==o)throw new KG("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return WD((()=>{let n,r,a,s,i=t.initialState;if(null==i)n=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let a=i.slice(0,i.length/2),s=i.slice(i.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return this.returnState&&(Array.isArray(n)&&(a=n.slice(1).concat(r.slice(1))),n=n[0],r=r[0]),this.returnSequences&&(r=HL(r,1)),"concat"===this.mergeMode?s=YH([n,r]):"sum"===this.mergeMode?s=rF(n,r):"ave"===this.mergeMode?s=iF(.5,rF(n,r)):"mul"===this.mergeMode?s=iF(n,r):null==this.mergeMode&&(s=[n,r]),this.returnState?null==this.mergeMode?s.concat(a):[s].concat(a):s}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){RH(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),RH(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){let e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=WK(t.layer);if(delete t.layer,null!=t.numConstants)throw new YG("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};XQ.className="Bidirectional",hV.registerClass(XQ);var QQ=class extends Wq{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return WD((()=>("float32"!==(e=_q(e)).dtype&&(e=jH(e,"float32")),rF(iF(e,this.scale),this.offset))))}};QQ.className="Rescaling",hV.registerClass(QQ);var{resizeBilinear:ZQ,cropAndResize:JQ}=oV,eZ=class extends Wq{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return WD((()=>{let l,u=!1,c=[t/s,n/i,(r+t)/s,(a+n)/i],d=[];3===e.rank?(u=!0,l=yz([e])):l=e;for(let e=0;e<l.shape[0];e++)d.push(c);let h=$D(d,[d.length,4]),p=VL(0,d.length,1,"int32"),f=JQ(l,h,p,[r,a],"nearest");return jH(u?_q(Oz(f)):f,o)}))}upsize(e,t,n,r){return WD((()=>jH(ZQ(e,[t,n]),r)))}call(e,t){return WD((()=>{let t=_q(e),n=t.dtype,r=t.shape,a=r[r.length-3],s=r[r.length-2],i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let o=0;return s!==this.width&&(o=Math.floor((s-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,a,s,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=$q(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};eZ.className="CenterCrop",hV.registerClass(eZ);var tZ=class extends Wq{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=$q(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return WD((()=>{let n;if("int32"!==(e=_q(e)).dtype&&(e=jH(e,"int32")),"undefined"!=typeof t.countWeights){if("count"!==this.outputMode)throw new KG(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=_q(t.countWeights)}let r=jO(e),a=GO(e),s=oP(this.numTokens,r).bufferSync().get(0),i=lP(a,0).bufferSync().get(0);if(!s||!i)throw new KG(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let a=_q(e);if("int32"!==a.dtype&&(a=jH(a,"int32")),"int"===t)return a;let s=a.shape;if(0===a.rank&&(a=tP(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=tP(a,-1)),a.rank>2)throw new KG(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);let i,o=["multiHot","oneHot"].includes(t),l=a;if(i=bO(l,"undefined"!=typeof r&&"count"===t?r:[],n,o),"tfIdf"!==t)return i;if(r)return iF(i,r);throw new KG("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}};tZ.className="CategoryEncoding",hV.registerClass(tZ);var nZ=new Set(["bilinear","nearest"]),rZ=class extends Wq{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!nZ.has(e.interpolation))throw new KG(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){let t=(e=$q(e))[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return WD((()=>{let t=[this.height,this.width];if("bilinear"===this.interpolation)return oV.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return oV.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...nZ]} are supported`)}))}};rZ.className="Resizing",hV.registerClass(rZ);var aZ=class{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}};aZ.className="RandomSeed";var sZ=class extends Wq{constructor(e){super(e),this.randomGenerator=new aZ(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};sZ.className="BaseRandomLayer";var iZ=new Set(["bilinear","nearest"]),oZ=class extends sZ{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new KG(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new KG(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new KG(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!iZ.has(n))throw new KG(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=$q(e))[2];return[this.imgHeight,-1,t]}call(e,t){return WD((()=>{let t=_q(e);this.imgHeight=t.shape[t.shape.length-3];let n=t.shape[t.shape.length-2];this.widthFactor=zL([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);let a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return oV.resizeBilinear(e,a);case"nearest":return oV.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...iZ]} are supported`)}}))}};function lZ(e){return new jq(e)}function uZ(e){return new kX(e)}function cZ(e){return new vX(e)}function dZ(e){return new xX(e)}function hZ(e){return new wX(e)}function pZ(e){return new IX(e)}function fZ(e){return new SX(e)}function mZ(e){return new zX(e)}function gZ(e){return new DX(e)}function yZ(e){return new FX(e)}function bZ(e){return new MX(e)}function vZ(e){return new OX(e)}function xZ(e){return new LX(e)}function wZ(e){return new BX(e)}function kZ(e){return new VX(e)}function SZ(e){return new WX(e)}function IZ(e){return new lQ(e)}function TZ(e){return new iQ(e)}function NZ(e){return new aQ(e)}function CZ(e){return new sQ(e)}function AZ(e){return new oQ(e)}function EZ(e){return new uQ(e)}function _Z(e){return new cQ(e)}function $Z(e){return new dQ(e)}function RZ(e){return new pQ(e)}function DZ(e){return new mQ(e)}function MZ(e){return new yQ(e)}function FZ(e){return new xQ(e)}function OZ(e){return new bQ(e)}function PZ(e){return new vQ(e)}function LZ(e){return new gQ(e)}function zZ(e){return new kQ(e)}function BZ(e){return new AQ(e)}function VZ(e){return new EQ(e)}function WZ(e){return new _Q(e)}function UZ(e){return new FQ(e)}function jZ(e){return UZ(e)}function GZ(e){return UZ(e)}function HZ(e){return new LQ(e)}function qZ(e){return HZ(e)}function KZ(e){return HZ(e)}function YZ(e){return new VQ(e)}function XZ(e){return YZ(e)}function QZ(e){return YZ(e)}function ZZ(e){return new UQ(e)}function JZ(e){return new HQ(e)}function eJ(e){return new jQ(e)}function tJ(e){return new qQ(e)}function nJ(e){return new MQ(e)}function rJ(e){return new PQ(e)}function aJ(e){return new BQ(e)}function sJ(e){return new XX(e)}function iJ(e){return new YX(e)}function oJ(e){return new ZX(e)}function lJ(e){return new QX(e)}function uJ(e){return new KX(e)}function cJ(e){return new qX(e)}function dJ(e){return new rQ(e)}function hJ(e){return new nQ(e)}function pJ(e){return new GX(e)}function fJ(e){return new JX(e)}function mJ(e){return new XQ(e)}function gJ(e){return new YQ(e)}oZ.className="RandomWidth",hV.registerClass(oZ);var yJ=eJ,bJ=tJ,vJ=nJ,xJ=rJ;function wJ(e){return new SQ(e)}function kJ(e){return new IQ(e)}function SJ(e){return new TQ(e)}function IJ(e){return new hQ(e)}function TJ(e){return new QQ(e)}function NJ(e){return new eZ(e)}function CJ(e){return new rZ(e)}function AJ(e){return new tZ(e)}function EJ(e){return new oZ(e)}var _J={};function $J(e,t){return JK(e,t)}function RJ(e,t){return aY(e,t)}function DJ(e,t){return sY(e,t)}function MJ(e,t){return eY(e,t)}function FJ(e,t){return iY(e,t)}function OJ(e,t){return nY(e,t)}function PJ(e,t){return rY(e,t)}function LJ(e,t){return XK(e,t)}function zJ(e,t){return GK(e,t)}function BJ(e,t){return HK(e,t)}function VJ(e,t){return HK(e,t)}function WJ(e,t){return HK(e,t)}function UJ(e,t){return jK(e,t)}function jJ(e,t){return jK(e,t)}function GJ(e,t){return jK(e,t)}tC(_J,{MAPE:()=>VJ,MSE:()=>jJ,binaryAccuracy:()=>$J,binaryCrossentropy:()=>RJ,categoricalAccuracy:()=>MJ,categoricalCrossentropy:()=>FJ,cosineProximity:()=>LJ,mape:()=>WJ,meanAbsoluteError:()=>zJ,meanAbsolutePercentageError:()=>BJ,meanSquaredError:()=>UJ,mse:()=>GJ,precision:()=>OJ,recall:()=>PJ,sparseCategoricalAccuracy:()=>DJ});var HJ={};tC(HJ,{modelFromJSON:()=>VY});var qJ={};function KJ(e){return new fX(e)}function YJ(e){return function(e){return hX(e),new fX({l1:null!=e?e.l1:null,l2:0})}(e)}function XJ(e){return function(e){return hX(e),new fX({l2:null!=e?e.l2:null,l1:0})}(e)}tC(qJ,{l1:()=>YJ,l1l2:()=>KJ,l2:()=>XJ});var QJ=class extends MK{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof zY))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function ZJ(e,t){return e<t}function JJ(e,t){return e>t}var e0=class extends QJ{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new YG("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=ZJ:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=JJ:this.monitorFunc=ZJ,this.monitorFunc===ZJ&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===ZJ?1/0:-1/0}async onEpochEnd(e,t){await RK(t);let n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});let t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};var t0,n0,r0={earlyStopping:function(e){return new e0(e)}};IA().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(t0||(t0={})),function(e){let t;var n;(n=t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"}(n0||(n0={}));var a0={};function s0(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};a0[e]=n}function i0(e){return a0[e]}function o0(e){delete a0[e]}function l0(e,t,n,r,a){let s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){let e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===s.type)return u0(t.inputNames[o],n,r,a);if("tensors"===s.type){let s=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=s[t])||void 0===n?void 0:n.op)})).map((e=>u0(e,n,r,a)))}let l=u0(t.inputNames[o],n,r,a),u=l.dataSync();return"number"===s.type?u[0]:iR.toNestedArray(l.shape,u)}let i=t.attrParams[e];return i&&i.value}function u0(e,t,n,r){let[a,s]=p0(e,n);if(null!=r){let e=r.getHashTableHandleByName(a);if(null!=e)return e}let i=n.currentContextIds.find((e=>!!t[h0(a,e)]));return void 0!==i?t[h0(a,i)][s]:void 0}function c0(e,t,n){return t[h0(e,n.currentContextId)]}function d0(e,t){let[n,r,a]=p0(e,t);return[h0(n,t&&t.currentContextId),r,a]}function h0(e,t){return t?`${e}-${t}`:e}function p0(e,t){if(""===e)return["",0,void 0];let n=null!=t&&null!=t.parseNodeNameCache;if(n){let n=t.parseNodeNameCache.get(e);if(null!=n)return n}let r,a=e.split(":");if(1===a.length)r=[e,0,void 0];else{let e=a[0],t=3===a.length?a[1]:void 0;r=[e,Number(a[a.length-1]),t]}return n&&t.parseNodeNameCache.set(e,r),r}function f0(e,t,n){let r=l0("pad",e,t,n);if("explicit"===r){r=l0("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function m0(e){return e.kept?e:tF(e)}var g0={};tC(g0,{json:()=>y0});var y0=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],b0={};tC(b0,{json:()=>v0});var v0=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],x0={};tC(x0,{json:()=>w0});var w0=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],k0={};tC(k0,{json:()=>S0});var S0=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],I0={};tC(I0,{json:()=>T0});var T0=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],N0={};tC(N0,{json:()=>C0});var C0=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],A0={};tC(A0,{json:()=>E0});var E0=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],_0={};tC(_0,{json:()=>$0});var $0=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],R0={};tC(R0,{json:()=>D0});var D0=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],M0={};tC(M0,{json:()=>F0});var F0=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],O0={};tC(O0,{json:()=>P0});var P0=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],L0={};tC(L0,{json:()=>z0});var z0=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],B0={};tC(B0,{json:()=>V0});var V0=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],W0={};tC(W0,{json:()=>U0});var U0=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],j0={};tC(j0,{json:()=>G0});var G0=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],H0={};tC(H0,{json:()=>q0});var q0=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],K0={};tC(K0,{json:()=>Y0});var Y0=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],X0={};tC(X0,{json:()=>Q0});var Q0=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Z0={};tC(Z0,{json:()=>J0});var J0=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],e1=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[].concat(...[g0,b0,x0,k0,I0,N0,A0,_0,R0,M0,O0,L0,B0,W0,j0,H0,K0,X0,Z0].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.node,r=[],a=[],s=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):(null==t.input||0===t.input.length)&&s.push(e[t.name]),e)),{}),o=[],l=[],u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach((e=>{let t=i[e];t.inputNames.forEach(((e,n)=>{let[r,,a]=d0(e),s=i[r];if(null!=s.outputs){let e=s.outputs.indexOf(a);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{let t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{let[t]=d0(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{let[t]=d0(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));let p={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:h};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){let t=i0(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{let r,a=n.type;switch(n.type){case"string":r=n1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=n1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=h1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=h1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=a1(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=a1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=d1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=d1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=r1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=r1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=f1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=f1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=c1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=c1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=p1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=p1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=o1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=o1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=l1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=l1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=i1(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=i1(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){let t=e.nodeDef,n=[],r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));let a=[],s=[];e.signature.inputArg.forEach((e=>{let[t]=d0(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:s1(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,a.push(n),r[t]=n})),Object.keys(r).forEach((e=>{let t=r[e];t.inputNames.forEach(((e,n)=>{let[a,,s]=d0(e),i=r[a];if(null!=i.outputs){let e=i.outputs.indexOf(s);if(-1!==e){let r=`${a}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));let i=e.ret;e.signature.outputArg.forEach((e=>{let[t,n]=d0(i[e.name]),a=r[t];null!=a&&(a.defaultOutput=n,s.push(a))}));let o=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:s,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function t1(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){let t=IA().global;if("undefined"!=typeof t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function n1(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e[t];return null!=a?t1(a.s,r):n}function r1(e,t,n){let r=e[t];return r?r.b:n}function a1(e,t,n){let r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function s1(e){switch("string"==typeof e&&(e=t0[e]),e){case t0.DT_FLOAT:case t0.DT_HALF:return"float32";case t0.DT_INT32:case t0.DT_INT64:case t0.DT_INT8:case t0.DT_UINT8:return"int32";case t0.DT_BOOL:return"bool";case t0.DT_DOUBLE:return"float32";case t0.DT_STRING:return"string";case t0.DT_COMPLEX64:case t0.DT_COMPLEX128:return"complex64";default:return null}}function i1(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function o1(e,t,n){let r=e[t];return r&&r.type?s1(r.type):n}function l1(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>s1(e))):n}function u1(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function c1(e,t,n){let r=e[t];return r&&r.shape?u1(r.shape):n}function d1(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function h1(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>t1(e,r))):n}function p1(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>u1(e))):n}function f1(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var m1=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return u0(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(null!=n.tensor)return u0(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return a1(this.node.rawAttrs,e,t);if(null!=n.s)return n1(this.node.rawAttrs,e,t);if(null!=n.b)return r1(this.node.rawAttrs,e,t);if(null!=n.shape)return c1(this.node.rawAttrs,e,t);if(null!=n.type)return o1(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return d1(this.node.rawAttrs,e,t);if(null!=n.list.s)return h1(this.node.rawAttrs,e,t);if(null!=n.list.shape)return p1(this.node.rawAttrs,e,t);if(null!=n.list.b)return f1(this.node.rawAttrs,e,t);if(null!=n.list.type)return l1(this.node.rawAttrs,e,t)}return t}},g1={};tC(g1,{OP_SCOPE_SUFFIX:()=>CD,abs:()=>oF,acos:()=>lF,acosh:()=>uF,add:()=>rF,addN:()=>cF,all:()=>dF,any:()=>hF,argMax:()=>pF,argMin:()=>fF,asin:()=>mF,asinh:()=>gF,atan:()=>yF,atan2:()=>bF,atanh:()=>vF,avgPool:()=>OF,avgPool3d:()=>PF,basicLSTMCell:()=>UF,batchNorm:()=>HF,batchNorm2d:()=>qF,batchNorm3d:()=>KF,batchNorm4d:()=>YF,batchToSpaceND:()=>jF,bincount:()=>XF,bitwiseAnd:()=>QF,booleanMaskAsync:()=>Vz,broadcastArgs:()=>ZF,broadcastTo:()=>JF,buffer:()=>JM,cast:()=>eF,ceil:()=>eO,clipByValue:()=>nO,clone:()=>tF,complex:()=>ED,concat:()=>LF,concat1d:()=>rO,concat2d:()=>aO,concat3d:()=>sO,concat4d:()=>iO,conv1d:()=>lO,conv2d:()=>oO,conv2dTranspose:()=>cO,conv3d:()=>dO,conv3dTranspose:()=>pO,cos:()=>fO,cosh:()=>mO,cosineWindow:()=>Yz,cumprod:()=>gO,cumsum:()=>yO,denseBincount:()=>bO,depthToSpace:()=>vO,depthwiseConv2d:()=>xO,diag:()=>wO,dilation2d:()=>kO,div:()=>sF,divNoNan:()=>_O,dot:()=>$O,dropout:()=>qz,einsum:()=>RO,elu:()=>DO,enclosingPowerOfTwo:()=>Kz,ensureShape:()=>MO,equal:()=>CO,erf:()=>FO,euclideanNorm:()=>JO,exp:()=>eP,expandDims:()=>tP,expm1:()=>nP,eye:()=>aP,fft:()=>cz,fill:()=>tO,floor:()=>sP,floorDiv:()=>aF,fused:()=>Qz,gather:()=>iP,gatherND:()=>Hz,greater:()=>oP,greaterEqual:()=>lP,ifft:()=>dz,imag:()=>uP,image:()=>oV,inTopKAsync:()=>Xz,irfft:()=>hz,isFinite:()=>cP,isInf:()=>dP,isNaN:()=>hP,leakyRelu:()=>pP,less:()=>fP,lessEqual:()=>mP,linalg:()=>lV,linspace:()=>gP,localResponseNormalization:()=>yP,log:()=>bP,log1p:()=>vP,logSigmoid:()=>EP,logSoftmax:()=>$P,logSumExp:()=>RP,logicalAnd:()=>DP,logicalNot:()=>MP,logicalOr:()=>FP,logicalXor:()=>OP,losses:()=>uV,lowerBound:()=>zP,matMul:()=>zF,max:()=>jO,maxPool:()=>BP,maxPool3d:()=>VP,maxPoolWithArgmax:()=>WP,maximum:()=>UP,mean:()=>jP,meshgrid:()=>qP,min:()=>GO,minimum:()=>KP,mirrorPad:()=>YP,mod:()=>XP,moments:()=>QP,movingAverage:()=>Uz,mul:()=>iF,multiRNNCell:()=>ZP,multinomial:()=>JP,neg:()=>CP,norm:()=>ZO,notEqual:()=>eL,oneHot:()=>tL,ones:()=>HP,onesLike:()=>nL,op:()=>AD,outerProduct:()=>rL,pad:()=>aL,pad1d:()=>sL,pad2d:()=>iL,pad3d:()=>oL,pad4d:()=>lL,pool:()=>cL,pow:()=>HO,prelu:()=>dL,print:()=>nF,prod:()=>hL,raggedGather:()=>pL,raggedRange:()=>fL,raggedTensorToTensor:()=>mL,rand:()=>gL,randomGamma:()=>OL,randomNormal:()=>PL,randomStandardNormal:()=>LL,randomUniform:()=>zL,randomUniformInt:()=>BL,range:()=>VL,real:()=>WL,reciprocal:()=>UL,relu:()=>jL,relu6:()=>GL,reshape:()=>FF,reverse:()=>HL,reverse1d:()=>qL,reverse2d:()=>KL,reverse3d:()=>YL,reverse4d:()=>XL,rfft:()=>fz,round:()=>QL,rsqrt:()=>ZL,scalar:()=>qO,scatterND:()=>jz,searchSorted:()=>LP,selu:()=>JL,separableConv2d:()=>ez,setdiff1dAsync:()=>tz,sigmoid:()=>BF,sign:()=>nz,signal:()=>iV,sin:()=>rz,sinh:()=>az,slice:()=>VF,slice1d:()=>sz,slice2d:()=>iz,slice3d:()=>oz,slice4d:()=>lz,softmax:()=>uz,softplus:()=>AP,spaceToBatchND:()=>uL,sparse:()=>cV,sparseToDense:()=>Gz,spectral:()=>sV,split:()=>pz,sqrt:()=>KO,square:()=>YO,squaredDifference:()=>mz,squeeze:()=>gz,stack:()=>yz,step:()=>bz,stridedSlice:()=>vz,string:()=>dV,sub:()=>_P,sum:()=>XO,tan:()=>xz,tanh:()=>WF,tensor:()=>$D,tensor1d:()=>wz,tensor2d:()=>kz,tensor3d:()=>Sz,tensor4d:()=>Iz,tensor5d:()=>Tz,tensor6d:()=>Nz,tensorScatterUpdate:()=>$z,tile:()=>rP,topk:()=>Rz,transpose:()=>Wz,truncatedNormal:()=>Dz,unique:()=>Mz,unsortedSegmentSum:()=>Fz,unstack:()=>Oz,upperBound:()=>Pz,variable:()=>Lz,where:()=>AO,whereAsync:()=>Bz,zeros:()=>GP,zerosLike:()=>EO});function y1(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!=typeof e&&"number"!=typeof t){iR.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){let a=e[r],s=t[r];iR.assert(a<0||s<0||a===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function b1(e){return!("number"==typeof e||e.some((e=>e<0)))}function v1(e,t,n){let r=x1(e,n),a=!b1(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=x1(e.shape,r)})),!b1(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function x1(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var w1=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=qO(0),jD(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),y1(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,jD(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return $D([],[0].concat(this.elementShape));let n=this.readMany(e);return y1(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),yz(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return $D([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return y1(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),LF(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Oz(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=0===n?0:t.size/n,s=[];WD((()=>{t=FF(t,[1,n,a]);for(let n=0;n<e.length;++n){let i=[0,0===n?0:r[n-1],0],o=[1,e[n],a];s[n]=FF(VF(t,i,o),this.elementShape)}return s}));let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},k1=class e{get id(){return this.idTensor.id}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);y1(t,e.shape,"TensorList shape mismatch: "),jD(e)})),this.idTensor=qO(0),this.maxNumElements=r,jD(this.idTensor)}copy(){return new e([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.id))&&t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);y1(e,this.elementShape,"TensorList shape mismatch: ");let r=v1(this.elementShape,this.tensors,e);return WD((()=>{let e=this.tensors.map((e=>FF(e,r)));return yz(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");let n=v1(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,y1(r.shape,e,"TensorList shape mismatch: "),FF(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(y1(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");jD(e),this.tensors.push(e)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new e([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let e=0;e<Math.min(this.tensors.length,t);++e)n.tensors[e]=this.tensors[e];return n}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);y1(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=v1(this.elementShape,this.tensors,t);return FF(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);y1(this.elementShape,t.shape,"TensorList shape mismatch: "),jD(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);y1(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=v1(this.elementShape,this.tensors,n);return 0===e.length?$D([],[0].concat(r)):WD((()=>{let t=e.map((e=>FF(this.tensors[e],r)));return yz(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);y1(this.elementShape,t,"TensorList shape mismatch: ");let n=v1(this.elementShape,this.tensors,t);return 0===this.size()?$D([],[0].concat(n)):WD((()=>{let e=this.tensors.map((e=>FF(e,n)));return LF(e,0)}))}};var S1=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=l0("thenBranch",e,t,n),a=l0("elseBranch",e,t,n),s=l0("cond",e,t,n),i=l0("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=l0("body",e,t,n),a=l0("cond",e,t,n),s=l0("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map((e=>e.id)),l=await i[0].data();i.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&e.dispose()}));let u=s;for(;l[0];){let e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let t=u.map((e=>e.id));e.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}));let s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}))}return u}case"LoopCond":return[m0(l0("pred",e,t,n))];case"Switch":{let r=l0("pred",e,t,n),a=l0("data",e,t,n);return a.kept||(a=m0(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find((e=>void 0!==u0(e,t,n)));if(r){return[m0(u0(r,t,n))]}return}case"Enter":{let r=l0("frameName",e,t,n),a=l0("tensor",e,t,n);return n.enterFrame(r),[m0(a)]}case"Exit":{let r=l0("tensor",e,t,n);return n.exitFrame(),[m0(r)]}case"NextIteration":{let r=l0("tensor",e,t,n);return n.nextIteration(),[m0(r)]}case"TensorArrayV3":{let r=l0("size",e,t,n),a=l0("dtype",e,t,n),s=l0("elementShape",e,t,n),i=l0("dynamicSize",e,t,n),o=l0("clearAfterRead",e,t,n),l=l0("identicalElementShapes",e,t,n),u=l0("name",e,t,n),c=new w1(u,a,r,s,l,i,o);return n.addTensorArray(c),[c.idTensor,qO(1)]}case"TensorArrayWriteV3":{let r=l0("tensorArrayId",e,t,n),a=l0("index",e,t,n),s=l0("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=l0("tensorArrayId",e,t,n),a=l0("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=l0("tensorArrayId",e,t,n),a=l0("indices",e,t,n),s=l0("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=l0("tensorArrayId",e,t,n),a=l0("indices",e,t,n),s=l0("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=l0("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=l0("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=l0("tensorArrayId",e,t,n),a=l0("tensor",e,t,n),s=l0("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=l0("tensorArrayId",e,t,n);return[qO(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{let r=l0("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=l0("tensorListId",e,t,n),a=l0("index",e,t,n),s=l0("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=l0("tensorListId",e,t,n),a=l0("index",e,t,n),s=l0("elementShape",e,t,n),i=l0("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=l0("indices",e,t,n),a=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new k1([],n,e.dtype,r),i=Oz(e,0);return t.forEach(((e,t)=>{s.setItem(e,i[t])})),s}(l0("tensor",e,t,n),r,l0("elementShape",e,t,n),l0("numElements",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r,a=l0("elementShape",e,t,n),s=l0("elementDType",e,t,n);r="TensorListReserve"===e.op?"numElements":"maxNumElements";let i=l0(r,e,t,n),o=function(e,t,n,r){return new k1([],e,t,r)}(a,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{let r=l0("tensorListId",e,t,n),a=l0("indices",e,t,n),s=l0("elementShape",e,t,n),i=l0("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=l0("tensorListId",e,t,n),a=l0("elementShape",e,t,n),s=l0("elementDType",e,t,n),i=l0("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=function(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);y1(e.shape.slice(1),t,"TensorList shape mismatch: ");let a=Oz(e);return new k1(a,t,r)}(l0("tensor",e,t,n),l0("elementShape",e,t,n),l0("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=l0("tensorListId",e,t,n),a=n.getTensorList(r.id),s=l0("dtype",e,t,n),i=l0("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=l0("tensorListId",e,t,n),a=l0("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=l0("tensorListId",e,t,n),a=l0("elementShape",e,t,n),s=l0("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=l0("tensor",e,t,n),a=l0("elementShape",e,t,n),s=function(e,t,n){let r=0,a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);let s=x1(e.shape.slice(1),n),i=0===r?0:e.size/r,o=WD((()=>{let n=[];e=FF(e,[1,r,i]);for(let r=0;r<t.length;++r){let o=[0,0===r?0:a[r-1],0],l=[1,t[r],i];n[r]=FF(VF(e,o,l),s)}return e.dispose(),n})),l=new k1([],n,e.dtype,t.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(r,l0("lengths",e,t,n),a);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{let r=l0("tensorListId",e,t,n);return[qO(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{let r=l0("tensorListId",e,t,n),a=l0("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function I1(e,t,n){let[r,a]=l0("fusedOps",e,t,n),s="biasadd"===r,i=!s,o="prelu"===a,l="fusedbatchnorm"===r,u=l0("numArgs",e,t,n);if(s){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=l0("strides",e,t,n),d=f0(e,t,n),h=l0("dataFormat",e,t,n).toUpperCase(),p=l0("dilations",e,t,n),[f,m]=l0("args",e,t,n);return i&&(m=f,f=void 0),{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:l0("leakyreluAlpha",e,t,n)}}function T1(e,t,n){return{boxes:l0("boxes",e,t,n),scores:l0("scores",e,t,n),maxOutputSize:l0("maxOutputSize",e,t,n),iouThreshold:l0("iouThreshold",e,t,n),scoreThreshold:l0("scoreThreshold",e,t,n),softNmsSigma:l0("softNmsSigma",e,t,n)}}var N1=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=qO(0),this.tensorMap=new Map,jD(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return qO(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),WD((()=>{let e=Oz(t),r=n.length,a=e.length;iR.assert(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){let r=n[t],a=e[t];jD(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return WD((()=>{let e=[];for(let r=0;r<n.length;r++){let a=n[r],s=this.findWithDefault(a,t);e.push(s)}return yz(e)}))}findWithDefault(e,t){let n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};function C1(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:WD,s=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(l0("a",e,t,n),l0("b",e,t,n))];case"AddN":return[r.addN(l0("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(l0("a",e,t,n),l0("b",e,t,n))];case"Mul":return[r.mul(l0("a",e,t,n),l0("b",e,t,n))];case"RealDiv":case"Div":return[r.div(l0("a",e,t,n),l0("b",e,t,n))];case"DivNoNan":return[r.divNoNan(l0("a",e,t,n),l0("b",e,t,n))];case"FloorDiv":return[r.floorDiv(l0("a",e,t,n),l0("b",e,t,n))];case"Sub":return[r.sub(l0("a",e,t,n),l0("b",e,t,n))];case"Minimum":return[r.minimum(l0("a",e,t,n),l0("b",e,t,n))];case"Maximum":return[r.maximum(l0("a",e,t,n),l0("b",e,t,n))];case"Pow":return[r.pow(l0("a",e,t,n),l0("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(l0("a",e,t,n),l0("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"basic_math":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(l0("x",e,t,n))];case"Acos":return[r.acos(l0("x",e,t,n))];case"Acosh":return[r.acosh(l0("x",e,t,n))];case"Asin":return[r.asin(l0("x",e,t,n))];case"Asinh":return[r.asinh(l0("x",e,t,n))];case"Atan":return[r.atan(l0("x",e,t,n))];case"Atan2":return[r.atan2(l0("x",e,t,n),l0("y",e,t,n))];case"Atanh":return[r.atanh(l0("x",e,t,n))];case"Ceil":return[r.ceil(l0("x",e,t,n))];case"Complex":return[r.complex(l0("real",e,t,n),l0("imag",e,t,n))];case"Cos":return[r.cos(l0("x",e,t,n))];case"Cosh":return[r.cosh(l0("x",e,t,n))];case"Elu":return[r.elu(l0("x",e,t,n))];case"Erf":return[r.erf(l0("x",e,t,n))];case"Exp":return[r.exp(l0("x",e,t,n))];case"Expm1":return[r.expm1(l0("x",e,t,n))];case"Floor":return[r.floor(l0("x",e,t,n))];case"Log":return[r.log(l0("x",e,t,n))];case"Log1p":return[r.log1p(l0("x",e,t,n))];case"Imag":return[r.imag(l0("x",e,t,n))];case"Neg":return[r.neg(l0("x",e,t,n))];case"Reciprocal":return[r.reciprocal(l0("x",e,t,n))];case"Real":return[r.real(l0("x",e,t,n))];case"Relu":return[r.relu(l0("x",e,t,n))];case"Round":return[r.round(l0("x",e,t,n))];case"Selu":return[r.selu(l0("x",e,t,n))];case"Sigmoid":return[r.sigmoid(l0("x",e,t,n))];case"Sin":return[r.sin(l0("x",e,t,n))];case"Sign":return[r.sign(l0("x",e,t,n))];case"Sinh":return[r.sinh(l0("x",e,t,n))];case"Softplus":return[r.softplus(l0("x",e,t,n))];case"Sqrt":return[r.sqrt(l0("x",e,t,n))];case"Square":return[r.square(l0("x",e,t,n))];case"Tanh":return[r.tanh(l0("x",e,t,n))];case"Tan":return[r.tan(l0("x",e,t,n))];case"ClipByValue":return[r.clipByValue(l0("x",e,t,n),l0("clipValueMin",e,t,n),l0("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(l0("x",e,t,n))];case"Rsqrt":return[r.rsqrt(u0(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(l0("x",e,t,n),l0("alpha",e,t,n))];case"Prelu":return[r.prelu(l0("x",e,t,n),l0("alpha",e,t,n))];case"IsNan":return[r.isNaN(u0(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(u0(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(u0(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"control":return S1(e,t,n);case"convolution":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"Conv1D":{let a=l0("stride",e,t,n),s=l0("pad",e,t,n),i=l0("dataFormat",e,t,n).toUpperCase(),o=l0("dilation",e,t,n);return[r.conv1d(l0("x",e,t,n),l0("filter",e,t,n),a,s,i,o)]}case"Conv2D":{let a=l0("strides",e,t,n),s=f0(e,t,n),i=l0("dataFormat",e,t,n).toUpperCase(),o=l0("dilations",e,t,n);return[r.conv2d(l0("x",e,t,n),l0("filter",e,t,n),[a[1],a[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=I1(e,t,n);return[r.fused.conv2d({x:l0("x",e,t,n),filter:l0("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:s,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=I1(e,t,n);return[r.fused.depthwiseConv2d({x:l0("x",e,t,n),filter:l0("filter",e,t,n),strides:[a[1],a[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=l0("outputShape",e,t,n),s=l0("strides",e,t,n),i=f0(e,t,n);return[r.conv2dTranspose(l0("x",e,t,n),l0("filter",e,t,n),a,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=l0("strides",e,t,n),s=f0(e,t,n),i=l0("dilations",e,t,n),o=l0("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(l0("input",e,t,n),l0("filter",e,t,n),[a[1],a[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let a=l0("strides",e,t,n),s=l0("pad",e,t,n),i=l0("dataFormat",e,t,n).toUpperCase(),o=l0("dilations",e,t,n);return[r.conv3d(l0("x",e,t,n),l0("filter",e,t,n),[a[1],a[2],a[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let a=l0("strides",e,t,n),s=l0("pad",e,t,n),i=l0("kernelSize",e,t,n);return[r.avgPool(l0("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPool":{let a=l0("strides",e,t,n),s=l0("pad",e,t,n),i=l0("kernelSize",e,t,n);return[r.maxPool(l0("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{let a=l0("strides",e,t,n),s=l0("pad",e,t,n),i=l0("kernelSize",e,t,n),o=l0("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(l0("x",e,t,n),[i[1],i[2]],[a[1],a[2]],s,o);return[l,u]}case"AvgPool3D":{let a=l0("strides",e,t,n),s=l0("pad",e,t,n),i=l0("kernelSize",e,t,n);return[r.avgPool3d(l0("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{let a=l0("strides",e,t,n),s=l0("pad",e,t,n),i=l0("kernelSize",e,t,n);return[r.maxPool3d(l0("x",e,t,n),[i[1],i[2],i[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{let a=l0("strides",e,t,n),s=l0("pad",e,t,n),i=l0("dilations",e,t,n),o=a[1],l=a[2],u=i[1],c=i[2];return[r.dilation2d(l0("x",e,t,n),l0("filter",e,t,n),[o,l],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"creation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"Fill":{let a=l0("shape",e,t,n),s=l0("dtype",e,t,n),i=l0("value",e,t,n);return[r.fill(a,i,s)]}case"LinSpace":{let a=l0("start",e,t,n),s=l0("stop",e,t,n),i=l0("num",e,t,n);return[r.linspace(a,s,i)]}case"Multinomial":{let a=l0("logits",e,t,n),s=l0("numSamples",e,t,n),i=l0("seed",e,t,n);return[r.multinomial(a,s,i)]}case"OneHot":{let a=l0("indices",e,t,n),s=l0("depth",e,t,n),i=l0("onValue",e,t,n),o=l0("offValue",e,t,n),l=l0("dtype",e,t,n);return[r.oneHot(a,s,i,o,l)]}case"Ones":return[r.ones(l0("shape",e,t,n),l0("dtype",e,t,n))];case"OnesLike":return[r.onesLike(l0("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(l0("shape",e,t,n),l0("dtype",e,t,n),l0("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(l0("shape",e,t,n),l0("minval",e,t,n),l0("maxval",e,t,n),l0("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(l0("shape",e,t,n),l0("minval",e,t,n),l0("maxval",e,t,n),l0("seed",e,t,n))];case"Range":{let a=l0("start",e,t,n),s=l0("stop",e,t,n),i=l0("step",e,t,n);return[r.range(a,s,i,l0("dtype",e,t,n))]}case"TruncatedNormal":{let a=l0("shape",e,t,n),s=l0("mean",e,t,n),i=l0("stdDev",e,t,n),o=l0("seed",e,t,n);return[r.truncatedNormal(a,s,i,l0("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(l0("shape",e,t,n),l0("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(l0("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"dynamic":return async function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:g1;switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=T1(e,t,n),c=await a.image.nonMaxSuppressionWithScoreAsync(r,s,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=T1(e,t,n),u=l0("padToMaxOutputSize",e,t,n),c=await a.image.nonMaxSuppressionPaddedAsync(r,s,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=T1(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,s,i,o,l)]}case"Where":{let r=a.cast(l0("condition",e,t,n),"bool"),s=[await a.whereAsync(r)];return r.dispose(),s}case"ListDiff":return a.setdiff1dAsync(l0("x",e,t,n),l0("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n);case"evaluation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"LowerBound":{let a=l0("sortedSequence",e,t,n),s=l0("values",e,t,n);return[r.lowerBound(a,s)]}case"TopKV2":{let a=l0("x",e,t,n),s=l0("k",e,t,n),i=l0("sorted",e,t,n),o=r.topk(a,s,i);return[o.values,o.indices]}case"UpperBound":{let a=l0("sortedSequence",e,t,n),s=l0("values",e,t,n);return[r.upperBound(a,s)]}case"Unique":{let a=l0("x",e,t,n),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{let a=l0("x",e,t,n),s=l0("axis",e,t,n),i=r.unique(a,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"image":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"ResizeBilinear":{let a=l0("images",e,t,n),s=l0("size",e,t,n),i=l0("alignCorners",e,t,n),o=l0("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let a=l0("images",e,t,n),s=l0("size",e,t,n),i=l0("alignCorners",e,t,n),o=l0("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],i,o)]}case"CropAndResize":{let a=l0("image",e,t,n),s=l0("boxes",e,t,n),i=l0("boxInd",e,t,n),o=l0("cropSize",e,t,n),l=l0("method",e,t,n),u=l0("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,s,i,o,l,u)]}case"ImageProjectiveTransformV3":{let a=l0("images",e,t,n),s=l0("transforms",e,t,n),i=l0("outputShape",e,t,n),o=l0("fillValue",e,t,n),l=l0("interpolation",e,t,n),u=l0("fillMode",e,t,n);return[r.image.transform(a,s,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"graph":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=l0("default",e,t,n);return[u0(e.name,t,n)||a];case"Placeholder":return[u0(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[m0(l0("x",e,t,n))];case"IdentityN":return l0("x",e,t,n).map((e=>m0(e)));case"Shape":return[r.tensor1d(l0("x",e,t,n).shape,"int32")];case"ShapeN":return l0("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(l0("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(l0("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let s=l0("x",e,t,n),i=l0("data",e,t,n),o=l0("message",e,t,n),l=l0("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"logical":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"Equal":return[r.equal(l0("a",e,t,n),l0("b",e,t,n))];case"NotEqual":return[r.notEqual(l0("a",e,t,n),l0("b",e,t,n))];case"Greater":return[r.greater(l0("a",e,t,n),l0("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(l0("a",e,t,n),l0("b",e,t,n))];case"Less":return[r.less(l0("a",e,t,n),l0("b",e,t,n))];case"LessEqual":return[r.lessEqual(l0("a",e,t,n),l0("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(l0("a",e,t,n),l0("b",e,t,n))];case"LogicalNot":return[r.logicalNot(l0("a",e,t,n))];case"LogicalOr":return[r.logicalOr(l0("a",e,t,n),l0("b",e,t,n))];case"Select":case"SelectV2":return[r.where(l0("condition",e,t,n),l0("a",e,t,n),l0("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(l0("a",e,t,n),l0("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"matrices":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(l0("a",e,t,n),l0("b",e,t,n),l0("transposeA",e,t,n),l0("transposeB",e,t,n))];case"Einsum":return[r.einsum(l0("equation",e,t,n),...l0("tensors",e,t,n))];case"Transpose":return[r.transpose(l0("x",e,t,n),l0("perm",e,t,n))];case"_FusedMatMul":let[a,s]=l0("fusedOps",e,t,n),i="biasadd"===a,o="prelu"===s,l=l0("numArgs",e,t,n),u=l0("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,d]=l0("args",e,t,n);return[r.fused.matMul({a:l0("a",e,t,n),b:l0("b",e,t,n),transposeA:l0("transposeA",e,t,n),transposeB:l0("transposeB",e,t,n),bias:c,activation:s,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(l0("a",e,t,n),l0("numLower",e,t,n),l0("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"normalization":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(l0("x",e,t,n),l0("axis",e,t,n),l0("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(l0("x",e,t,n),l0("mean",e,t,n),l0("variance",e,t,n),l0("offset",e,t,n),l0("scale",e,t,n),l0("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(l0("x",e,t,n),l0("radius",e,t,n),l0("bias",e,t,n),l0("alpha",e,t,n),l0("beta",e,t,n))];case"Softmax":return[r.softmax(l0("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(l0("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"ragged":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(l0("paramsNestedSplits",e,t,n),l0("paramsDenseValues",e,t,n),l0("indices",e,t,n),l0("outputRaggedRank",e,t,n));return a.concat(s)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(l0("starts",e,t,n),l0("limits",e,t,n),l0("splits",e,t,n));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(l0("shape",e,t,n),l0("values",e,t,n),l0("defaultValue",e,t,n),l0("rowPartitionTensors",e,t,n),l0("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"reduction":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"Max":{let a=l0("axis",e,t,n),s=l0("keepDims",e,t,n);return[r.max(l0("x",e,t,n),a,s)]}case"Mean":{let a=l0("axis",e,t,n),s=l0("keepDims",e,t,n);return[r.mean(l0("x",e,t,n),a,s)]}case"Min":{let a=l0("axis",e,t,n),s=l0("keepDims",e,t,n);return[r.min(l0("x",e,t,n),a,s)]}case"Sum":{let a=l0("axis",e,t,n),s=l0("keepDims",e,t,n);return[r.sum(l0("x",e,t,n),a,s)]}case"All":{let a=l0("axis",e,t,n),s=l0("keepDims",e,t,n);return[r.all(l0("x",e,t,n),a,s)]}case"Any":{let a=l0("axis",e,t,n),s=l0("keepDims",e,t,n);return[r.any(l0("x",e,t,n),a,s)]}case"ArgMax":{let a=l0("axis",e,t,n);return[r.argMax(l0("x",e,t,n),a)]}case"ArgMin":{let a=l0("axis",e,t,n);return[r.argMin(l0("x",e,t,n),a)]}case"Prod":{let a=l0("axis",e,t,n),s=l0("keepDims",e,t,n);return[r.prod(l0("x",e,t,n),a,s)]}case"Cumprod":{let a=l0("axis",e,t,n),s=l0("exclusive",e,t,n),i=l0("reverse",e,t,n);return[r.cumprod(l0("x",e,t,n),a,s,i)]}case"Cumsum":{let a=l0("axis",e,t,n),s=l0("exclusive",e,t,n),i=l0("reverse",e,t,n);return[r.cumsum(l0("x",e,t,n),a,s,i)]}case"Bincount":let a=l0("x",e,t,n),s=l0("weights",e,t,n),i=l0("size",e,t,n);return[r.bincount(a,s,i)];case"DenseBincount":{let a=l0("x",e,t,n),s=l0("weights",e,t,n),i=l0("size",e,t,n),o=l0("binaryOutput",e,t,n);return[r.denseBincount(a,s,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"slice_join":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"ConcatV2":case"Concat":{let a=l0("n",e,t,n),s=l0("axis",e,t,n),i=l0("tensors",e,t,n);return i=i.slice(0,a),[r.concat(i,s)]}case"Gather":{let a=l0("x",e,t,n),s=l0("indices",e,t,n);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{let a=l0("axis",e,t,n),s=l0("batchDims",e,t,n),i=l0("x",e,t,n),o=l0("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),a,s)]}case"Reverse":{let a=l0("dims",e,t,n),s=[];for(let e=0;e<a.length;e++)a[e]&&s.push(e);let i=l0("x",e,t,n);return[r.reverse(i,s)]}case"ReverseV2":{let a=l0("axis",e,t,n),s=l0("x",e,t,n);return[r.reverse(s,a)]}case"Slice":{let a=l0("begin",e,t,n),s=l0("size",e,t,n);return[r.slice(l0("x",e,t,n),a,s)]}case"StridedSlice":{let a=l0("begin",e,t,n),s=l0("end",e,t,n),i=l0("strides",e,t,n),o=l0("beginMask",e,t,n),l=l0("endMask",e,t,n),u=l0("ellipsisMask",e,t,n),c=l0("newAxisMask",e,t,n),d=l0("shrinkAxisMask",e,t,n),h=l0("x",e,t,n);return[r.stridedSlice(h,a,s,i,o,l,u,c,d)]}case"Pack":return WD((()=>{let a=l0("axis",e,t,n),s=l0("tensors",e,t,n),i=s[0].shape,o=r.squeeze(s[0]).shape,l=s.map((e=>{let t=iR.arraysEqual(e.shape,i);if(!t&&!iR.arraysEqual(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,a)]}));case"Unpack":{let a=l0("axis",e,t,n),s=l0("tensor",e,t,n);return r.unstack(s,a)}case"Tile":{let a=l0("reps",e,t,n);return[r.tile(l0("x",e,t,n),a)]}case"Split":case"SplitV":{let a=l0("axis",e,t,n),s=l0("numOrSizeSplits",e,t,n),i=l0("x",e,t,n);return r.split(i,s,a)}case"ScatterNd":{let a=l0("indices",e,t,n),s=l0("values",e,t,n),i=l0("shape",e,t,n);return[r.scatterND(a,s,i)]}case"GatherNd":{let a=l0("x",e,t,n),s=l0("indices",e,t,n);return[r.gatherND(a,s)]}case"SparseToDense":{let a=l0("sparseIndices",e,t,n),s=l0("outputShape",e,t,n),i=l0("sparseValues",e,t,n),o=l0("defaultValue",e,t,n);return[r.sparseToDense(a,i,s,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let a=l0("indices",e,t,n),s=l0("values",e,t,n),i=l0("tensor",e,t,n);return[r.tensorScatterUpdate(i,a,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"sparse":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(l0("indices",e,t,n),l0("values",e,t,n),l0("denseShape",e,t,n),l0("defaultValue",e,t,n));return[a,s,i,o]}case"SparseReshape":{let{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(l0("inputIndices",e,t,n),l0("inputShape",e,t,n),l0("newShape",e,t,n));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(l0("data",e,t,n),l0("indices",e,t,n),l0("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(l0("data",e,t,n),l0("indices",e,t,n),l0("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"spectral":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"FFT":return[r.fft(l0("x",e,t,n))];case"IFFT":return[r.ifft(l0("x",e,t,n))];case"RFFT":return[r.rfft(l0("x",e,t,n))];case"IRFFT":return[r.irfft(l0("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"string":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(l0("input",e,t,n),l0("pattern",e,t,n),l0("rewrite",e,t,n),l0("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(l0("data",e,t,n),l0("dataSplits",e,t,n),l0("separator",e,t,n),l0("nGramWidths",e,t,n),l0("leftPad",e,t,n),l0("rightPad",e,t,n),l0("padWidth",e,t,n),l0("preserveShortSequences",e,t,n));return[a,s]}case"StringSplit":{let{indices:a,values:s,shape:i}=r.string.stringSplit(l0("input",e,t,n),l0("delimiter",e,t,n),l0("skipEmpty",e,t,n));return[a,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(l0("input",e,t,n),l0("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"transformation":return a((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g1;switch(e.op){case"Cast":return[r.cast(l0("x",e,t,n),l0("dtype",e,t,n))];case"ExpandDims":{let a=l0("axis",e,t,n);return[r.expandDims(l0("x",e,t,n),a)]}case"Squeeze":{let a=l0("axis",e,t,n);return[r.squeeze(l0("x",e,t,n),a)]}case"Reshape":return[r.reshape(l0("x",e,t,n),l0("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(l0("x",e,t,n),l0("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(l0("x",e,t,n),l0("padding",e,t,n),l0("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(l0("x",e,t,n),l0("padding",e,t,n),l0("constantValue",e,t,n))];case"SpaceToBatchND":{let a=l0("blockShape",e,t,n),s=l0("paddings",e,t,n);return[r.spaceToBatchND(l0("x",e,t,n),a,s)]}case"BatchToSpaceND":{let a=l0("blockShape",e,t,n),s=l0("crops",e,t,n);return[r.batchToSpaceND(l0("x",e,t,n),a,s)]}case"DepthToSpace":{let a=l0("blockSize",e,t,n),s=l0("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(l0("x",e,t,n),a,s)]}case"BroadcastTo":return[r.broadcastTo(l0("x",e,t,n),l0("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(l0("s0",e,t,n),l0("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(null!=a)return[a];{let a=l0("keyDType",e,t,n),s=l0("valueDType",e,t,n),i=new N1(a,s);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=l0("tableHandle",e,t,n,r),s=l0("keys",e,t,n),i=l0("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=l0("tableHandle",e,t,n,r),s=l0("keys",e,t,n),i=l0("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=l0("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":let s=i0(e.op);if(s&&s.customExecutor)return s.customExecutor(new m1(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return iR.isPromise(s)?s.then((e=>[].concat(e))):[].concat(s)}var A1=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function E1(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map((e=>p0(e)[0])));r=r||[];let c=new Set(r.map((e=>p0(e.name)[0]))),d=[...t];for(;d.length>0;){let e=d.pop();if((F1(e)||O1(e)||P1(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&!u.has(e.name)&&!c.has(e.name)){if(0===e.inputs.length){s.push(e.name);continue}e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))}))}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function _1(e,t){let{usedNodes:n,inputs:r}=t,a=Object.keys(r).map((e=>p0(e)[0])).map((t=>e.nodes[t])),s=e.initNodes||[],i=e=>n.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}let l=o([...a,...e.weights,...s]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map((e=>[e.name,e]))),d={};for(let m of u){d[m.name]=d[m.name]||0;for(let e of m.children)i(e)||(d[e.name]=Number.POSITIVE_INFINITY),d[e.name]=(d[e.name]||0)+1}let h=Object.entries(d).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...h];for(;h.length>0;){let e=h.pop(),t=c.get(e);for(let n of t.children.filter(i))0===--d[n.name]&&(p.push(n.name),h.push(n.name))}let f=function(e,t){let n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),a=new Set(r);for(;r.length>0;){let e=r.pop(),t=n.get(e);for(let s of t.children)!n.has(s.name)||a.has(s.name)||(a.add(s.name),r.push(s.name))}return e.filter((e=>a.has(e.name)))}(p.map((e=>c.get(e))),l);return function(e,t){let n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),a=e=>r.has("string"==typeof e?e:e.name),s=new Set(e.map((e=>e.name))),i=e=>s.has("string"==typeof e?e:e.name);for(let o of e){for(let e of o.children.filter(i)){if(!n.has(e.name))throw new $1(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new $1(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!a(o))for(let e of o.inputs){if(!n.has(e.name))throw new $1(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new $1(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}var $1=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};var R1=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),D1=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),M1=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function F1(e){return R1.has(e.op)}function O1(e){return D1.has(e.op)}function P1(e){return M1.has(e.op)}var L1=class e{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((n=>{this._functionExecutorMap[n]=new e(t.functions[n],this)}))}getCompilationKey(e,t){let n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){let n=E1(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){let n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}let i=_1(this.graph,n),o=function(e){let t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>F1(e)?n:t)),a=e=>{let n=r[t.get(e.name)];return null==n?-1:n},s=e.map(((e,t)=>e.children.map(a).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){let t=s[o];if(t===n)continue;let r=e[o],a=e[t];i.has(a.name)||i.set(a.name,[]),i.get(a.name).push(r)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;let t=e.clone();return jD(t),t}cloneTensorList(e){return e?e.map((e=>this.cloneAndKeepTensor(e))):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map((e=>this.graph.nodes[p0(e)[0]])),a=t.map((e=>p0(e)[0])),s=new Set(a),i=a.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);let o=this.getCompilationKey(r,i),l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=IA().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let u={},c={};return WD((()=>{let n=new A1(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{let[a,s]=p0(t,n),i=[];i[s]=e[t],r[a]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(i))}));let a=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(let e of i){if(r[e.name])continue;let t=C1(e,r,n,this._resourceManager);if(iR.isPromise(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,a,s,o.get(e.name))}return null==this.parent&&n.dispose(a),t.map((e=>u0(e,r,n)))}))}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,i){if(!F1(t)&&!s.has(e)){for(let r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(let e of t.inputs){if(F1(e))continue;let t=c0(e.name,n,r);if(null!=t)for(let e of t){if(!e||e.kept||a.has(e.id))continue;let t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,a,s){function i(e){return F1(e)||a.has(e.name)}if(!F1(e)&&null!=s)for(let o of s){if(i(o))continue;let e=c0(o.name,t,n);for(let t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=IA().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}let s=new A1(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let i=await this.executeWithControlFlow(e,s,t,n),o=t.map((e=>u0(e,i,s))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{e&&!e.isDisposed&&!c.has(e.id)&&e.dispose()}))})),null==this.parent&&s.dispose(c),o}async executeFunctionAsync(e,t,n){let r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let a=Object.keys(e),s=a.map((e=>this.graph.nodes[p0(e)[0]])),i=n.map((e=>p0(e)[0])),o=new Set(i),l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);let{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:h}=E1(e,l,this.weightMap,this._initNodes),p=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{let[n,r]=p0(t),a=[];a[r]=e[t],f[n]=a}));let m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){let e=this.processStack(s,p,t,f,y,g,o,m,u);await Promise.all(e)}null==d&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=l.filter((e=>!F1(e)&&!u0(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,a,s,i,o,l){let u=[];for(;t.length>0;){let e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&l0("isConstant",e.node,r,n)&&([c]=d0(e.node.name,n)),null==r[e.node.name]){let d=C1(e.node,r,n,this._resourceManager);c||([c]=d0(e.node.name,n));let h=n.currentContext;iR.isPromise(d)?u.push(d.then((u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=h,this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{let[i]=d0(e.name,n);a[i]||!s.has(e.name)||("Merge"===e.op?e.inputNames.some((e=>!!u0(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!u0(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{let n=e[t],[r]=p0(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){let e=a.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));iR.assert(t,(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&iR.assert(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;let r={};for(let a in e){let s=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[a];null!=s?r[s.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){let t=Object.keys(e).filter((e=>{let[t]=p0(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;let r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{let[t]=p0(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}},z1=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},B1="?tfjs-format=file",V1="model.json",W1=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:AV;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new z1}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return iR.isPromise(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");let t=await lM(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new L1(e1.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=e1.Instance.transformGraph(e.modelInitializer);this.initializer=new L1(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){let t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t={};return(e instanceof jR?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof jR)&&!Array.isArray(e)){let n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(let t in n){let r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var a,s,i;let o=null===(i=null===(s=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===s?void 0:s[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=t[n[r]];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&UD(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function U1(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:AV;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){return e.endsWith("/")||(e+="/"),`${e}${V1}${B1}`}(e));let r=new W1(e,t,n);return await r.load(),r}function j1(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");let a=AV.getWeightSpecs(n.weightsManifest),s=AV.getModelArtifactsForJSONSync(n,a,r);t=AV.fromMemorySync(s)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=AV.fromMemorySync(e)}let n=new W1(t);return n.load(),n}var G1="4.16.0",H1={};tC(H1,{CSVDataset:()=>L2,Dataset:()=>T2,FileDataSource:()=>Q2,TextLineDataset:()=>$2,URLDataSource:()=>Z2,array:()=>C2,csv:()=>J2,func:()=>e3,generator:()=>t3,microphone:()=>r3,version_data:()=>a3,webcam:()=>n3,zip:()=>A2});var q1=nC(fC()),K1=nC(fC());function Y1(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(e2(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let s in e){let i=Y1(e[s],t,n,r);a[s]=i}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function X1(e){return Q1(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z1)}function Q1(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set,r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(e2(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let s in r){let r=Q1(e.map((e=>e[s])),t,n);a[s]=r}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function Z1(e){return null===e?null:e2(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function J1(e,t){let n=new Map;Y1(e,t,n);for(let r of Array.from(n.keys())){let e=n.get(r);if(iR.isPromise(e)){let t=await e;n.set(r,t)}}return Y1(e,t,n)}function e2(e){let t=!1;if(IA().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=mC();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof jR)&&!(e instanceof Promise)&&!t)}function t2(e){return function(e,t){return Y1(e,t)}(e,n2)}function n2(e){return e instanceof jR?{value:e.clone(),recurse:!1}:e2(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var r2=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},a2=class e extends r2{constructor(){super(e.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};function s2(e){return new u2(e)}function i2(e){return new c2(e)}a2.INITIAL_CAPACITY=32;var o2,l2=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new y2(this,e)}filter(e){return new m2(this,e)}map(e){return new g2(this,e)}mapAsync(e){return new b2(this,e)}serialMapAsync(e){return new b2(this,e).serial()}flatmap(e){return new x2(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new f2(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Z1;return this.rowMajorBatch(e,t).map((e=>X1(e,n)))}concatenate(e,t){return new w2(s2([this,e]),t)}take(e){return e<0||null==e?this:new p2(this,e)}skip(e){return e<0||null==e?this:new h2(this,e)}prefetch(e){return new S2(this,e)}shuffle(e,t){return new I2(this,e,t)}serial(){return new d2(this)}},u2=class extends l2{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:t2(e),done:!1}}},c2=class extends l2{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(KR){throw KR.message=`Error thrown while iterating through a dataset: ${KR.message}`,KR}}},d2=class extends l2{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}},h2=class extends l2{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;UD(e.value)}return this.upstream.next()}},p2=class extends l2{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},f2=class extends l2{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},m2=class extends l2{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;UD(e.value)}}},g2=class extends l2{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=JR.getTensorsInContainer(e.value),n=this.transform(e.value),r=JR.getTensorsInContainer(n);for(let a of t)JR.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},y2=class extends l2{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(KR){if(!this.handler(KR))return{value:null,done:!0}}}},b2=class extends l2{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=JR.getTensorsInContainer(e.value),n=await this.transform(e.value),r=JR.getTensorsInContainer(n);for(let a of t)JR.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},v2=class extends l2{constructor(){super(),this.outputQueue=new a2,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},x2=class extends v2{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=JR.getTensorsInContainer(e.value),n=this.transform(e.value),r=JR.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)JR.isTensorInList(a,r)||a.dispose();return!0}},w2=class extends l2{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(o2||(o2={}));var k2=class extends l2{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o2.FAIL;super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;let r=await J1(this.iterators,(function(e){return e instanceof l2?{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}:{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case o2.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case o2.SHORTEST:return{value:null,done:!0};case o2.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},S2=class extends l2{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new r2(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},I2=class extends S2{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=K1.alea(n||iR.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},T2=class{constructor(){this.size=null}batch(e){let t,n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=this;return iR.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),t=this.size===1/0||null==this.size?this.size:n?Math.ceil(this.size/e):Math.floor(this.size/e),N2((async()=>(await r.iterator()).columnMajorBatch(e,n,E2)),t)}concatenate(e){let t,n=this;return t=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,N2((async()=>(await n.iterator()).concatenate(await e.iterator())),t)}filter(e){let t,n=this;return t=this.size===1/0?1/0:null,N2((async()=>(await n.iterator()).filter((t=>WD((()=>e(t)))))),t)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return N2((async()=>(await t.iterator()).map((t=>WD((()=>e(t)))))),this.size)}mapAsync(e){let t=this;return N2((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return N2((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){let t,n=this;return t=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,N2((async()=>function(e,t){return new w2(e,t)}(i2((async()=>({value:await n.iterator(),done:!1}))).take(e))),t)}skip(e){let t,n=this;return t=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,N2((async()=>(await n.iterator()).skip(e)),t)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=q1.alea(t||iR.now().toString());return N2((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){let t,n=this;return t=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,N2((async()=>(await n.iterator()).take(e)),t)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function N2(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends T2{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function C2(e){return N2((async()=>s2(e)),e.length)}function A2(e){if(!e2(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return N2((async()=>function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o2.FAIL;return new k2(e,t)}(await J1(e,(e=>{if(e instanceof T2)return{value:e.iterator(),recurse:!1};if(e2(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")})),o2.SHORTEST)),t)}function E2(e){if(null===e)return null;return function(e){return null==e||function(e){return null===e||"object"!=typeof e&&"function"!=typeof e}(e)||Array.isArray(e)||"object"==typeof e&&e instanceof jR||iR.isTypedArray(e)}(e[0])?{value:_2(e),recurse:!1}:{value:null,recurse:!0}}function _2(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof jR?yz(e):$D(e)}T2.MAX_BUFFER_SIZE=1e4;var $2=class extends T2{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}},R2='"',D2=Symbol("out"),M2=Symbol("field"),F2=Symbol("quote"),O2=Symbol("quoteafterquote"),P2=Symbol("quoteinquote"),L2=class extends T2{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&iR.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(iR.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(let r of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(r))throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new $2(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(iR.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||i){let o=t[a],l=null;if(""===o)if(i&&void 0!==i.default)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let e=Number(o);if(isNaN(e))l=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o)}else l=e}i&&i.isLabel?r[s]=l:n[s]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=[],r=0,a=e.length,s=D2;for(let i=0;i<a;i++)switch(s){case D2:switch(e.charAt(i)){case R2:r=i+1,s=F2;break;case this.delimiter:if(r=i+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=D2;break;default:s=M2,r=i}break;case M2:if(e.charAt(i)===this.delimiter)n.push(e.substring(r,i)),s=D2,r=i+1;break;case F2:if(e.charAt(i)===R2)s=O2;break;case O2:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),s=D2,r=i+1;break;case R2:s=F2;break;default:s=P2}break;case P2:if(e.charAt(i)===R2)s=F2}if(s===O2?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},z2=class e extends l2{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!IA().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new e(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise((r=>{let a=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(iR.sizeFromShape(t));return n.set(e,n.length-e.length),$D(n,t)}},B2=class e extends l2{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=wz([0],"int32"),this.webcamConfig.centerCrop){let e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,a=n+e,s=t+r;this.cropBox=kz([r,n,s,a],[1,4])}else this.cropBox=kz([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!IA().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new e(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&iR.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=QV.fromPixels(this.webcamVideoElement)}catch(gye){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(gye)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(gye){throw new Error(`Error thrown cropping the video: ${gye.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return WD((()=>{let t,n=tP(eF(e,"float32"),0);t=oV.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=t.shape;return FF(t,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},V2=class{},W2=class extends l2{split(e){return new U2(this,e)}},U2=class extends W2{constructor(e,t){super(),this.upstream=e,this.impl=new j2(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},j2=class extends v2{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},G2=class extends l2{decodeUTF8(){return new H2(this)}},H2=class extends W2{constructor(e){super(),this.upstream=e,this.impl=new q2(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},q2=class extends v2{constructor(e){if(super(),this.upstream=e,IA().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=mC();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e,t,n=await this.upstream.next();return!n.done&&(e=n.value,t=IA().get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(t),!0)}},K2=class extends G2{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.file=e,this.options=t,iR.assert(e instanceof Uint8Array||!!IA().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise(((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=n=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(a)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n})),done:!1}}};var Y2=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function X2(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var Q2=class extends V2{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.input=e,this.options=t}async iterator(){if(X2(this.input)&&IA().get("IS_NODE")){let e=gC();this.input=e.readFileSync(this.input.slice(7))}return new K2(this.input,this.options)}},Z2=class extends V2{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),this.url=e,this.fileOptions=t}async iterator(){return X2(this.url)?new Q2(this.url,this.fileOptions).iterator():async function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=arguments.length>2?arguments[2]:void 0;"string"==typeof e?t=e:(t=e.url,n=Y2(e));let s=await(a||iR.fetch)(t,n);if(s.ok){let e=new Uint8Array(await s.arrayBuffer());return new K2(e,r)}throw new Error(s.statusText)}(this.url,this.fileOptions)}};function J2(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new L2(new Z2(e),t)}function e3(e){let t=i2(e);return N2((async()=>t))}function t3(e){return N2((async()=>{let t=await e();return i2((()=>t.next()))}))}async function n3(e,t){return B2.create(e,t)}async function r3(e){return z2.create(e)}var a3="4.16.0";function s3(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&iR.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}var i3=VU.whereImpl,o3=class e extends TC{nextDataId(){return e.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new IC(this,zD())}write(e,t,n){this.firstUse&&(this.firstUse=!1,IA().get("IS_NODE")&&FW.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&iR.isString(n[0])){let a=n.map((e=>iR.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return FW.mergeRealAndImagArrays(e,t)}return iR.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>iR.decodeString(e)));return JM(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return JM(e.shape,e.dtype,t)}makeOutput(e,t,n){return zD().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=iR.now();return e(),{kernelMs:iR.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){s3([e],"where");let t=this.readSync(e.dataId);return i3(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};o3.nextDataId=0;var l3={};function u3(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}tC(l3,{addImpl:()=>I3,bincountImpl:()=>A3,bincountReduceImpl:()=>E3,bitwiseAndImpl:()=>_3,castImpl:()=>v3,ceilImpl:()=>O3,concatImpl:()=>z3,equalImpl:()=>B3,expImpl:()=>U3,expm1Impl:()=>H3,floorDivImpl:()=>Z3,floorImpl:()=>Y3,gatherNdImpl:()=>t4,gatherV2Impl:()=>n4,greaterEqualImpl:()=>i4,greaterImpl:()=>r4,lessEqualImpl:()=>h4,lessImpl:()=>u4,linSpaceImpl:()=>m4,logImpl:()=>g4,maxImpl:()=>v4,maximumImpl:()=>x4,minimumImpl:()=>S4,multiplyImpl:()=>N4,negImpl:()=>_4,notEqualImpl:()=>R4,prodImpl:()=>L4,raggedGatherImpl:()=>U4,raggedRangeImpl:()=>G4,raggedTensorToTensorImpl:()=>X4,rangeImpl:()=>Q4,rsqrtImpl:()=>Z4,scatterImpl:()=>t5,sigmoidImpl:()=>n5,simpleAbsImpl:()=>u3,sliceImpl:()=>s5,sparseFillEmptyRowsImpl:()=>l5,sparseReshapeImpl:()=>u5,sparseSegmentReductionImpl:()=>c5,sqrtImpl:()=>d5,squaredDifferenceImpl:()=>f5,staticRegexReplaceImpl:()=>y5,stridedSliceImpl:()=>x5,stringNGramsImpl:()=>k5,stringSplitImpl:()=>I5,stringToHashBucketFastImpl:()=>T5,subImpl:()=>N5,tileImpl:()=>_5,topKImpl:()=>D5,transposeImpl:()=>F4,uniqueImpl:()=>M5});var c3={kernelName:EA,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend;s3(t,"abs");let r=new Float32Array(iR.sizeFromShape(t.shape));return r=u3(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function d3(e){return(t,n,r,a,s)=>{let i=FW.assertAndGetBroadcastShape(t,n),o=i.length,l=iR.computeStrides(i),u=iR.sizeFromShape(i),c=iR.getTypedArrayFromDType(s,u),d=t.length,h=n.length,p=iR.computeStrides(t),f=iR.computeStrides(n),m=FW.getBroadcastDims(t,i),g=FW.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<c.length;++y){let t=iR.indexToLoc(y,o,l),n=t.slice(-d);m.forEach((e=>n[e]=0));let s=iR.locToIndex(n,d,p),i=t.slice(-h);g.forEach((e=>i[e]=0));let u=iR.locToIndex(i,h,f);c[y]=e(r[s],a[u])}return[c,i]}}function h3(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var p3={kernelName:nE,backendName:"cpu",kernelFunc:h3};function f3(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return h3({inputs:{real:f3(e,t,"float32"),imag:f3(e,t,"float32")},backend:e})}let r=iR.makeZerosTypedArray(iR.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function m3(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var g3={kernelName:GE,backendName:"cpu",kernelFunc:m3};function y3(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var b3={kernelName:U_,backendName:"cpu",kernelFunc:y3};function v3(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){let r=iR.toTypedArray([0],n),[a,s]=d3(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function x3(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return m3({inputs:{x:a},backend:n});let e=f3(n,a.shape,a.dtype),t=x3({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=h3({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=y3({inputs:{input:a},backend:n}),t=x3({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!iR.hasEncodingLoss(a.dtype,s)){let e=m3({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}let i=n.data.get(a.dataId).values,[o,l,u]=v3(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,u)}var w3={kernelName:JA,backendName:"cpu",kernelFunc:x3};function k3(e,t,n,r){return null==n?n=>{let{inputs:a,backend:s}=n,{a:i,b:o}=a,l=s;s3([i,o],e);let u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d="string"===i.dtype?FW.fromUint8ToStringArray(u):u,h="string"===i.dtype?FW.fromUint8ToStringArray(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:e=>{let{inputs:a,backend:s}=e,{a:i,b:o}=a,l=s;if("complex64"===i.dtype||"complex64"===o.dtype){let e=x3({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,s=l.data.get(r.dataId).values,u=l.data.get(a.dataId).values,c=x3({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=l.data.get(h.dataId).values,m=l.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,s,u,f,m),v=l.makeTensorInfo(b,"float32",g),x=l.makeTensorInfo(b,"float32",y),w=h3({inputs:{real:v,imag:x},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(x),w}{let e=l.data.get(i.dataId).values,n=l.data.get(o.dataId).values,a=r||i.dtype,[s,u]=t(i.shape,o.shape,e,n,a);return l.makeTensorInfo(u,a,s)}}}function S3(e){return(t,n,r,a,s,i)=>{let o=FW.assertAndGetBroadcastShape(t,n),l=iR.sizeFromShape(o),u=o.length,c=iR.computeStrides(o),d=iR.getTypedArrayFromDType("float32",l),h=iR.getTypedArrayFromDType("float32",l),p=FW.getBroadcastDims(t,o),f=FW.getBroadcastDims(n,o),m=FW.mergeRealAndImagArrays(r,a),g=FW.mergeRealAndImagArrays(s,i),y=t.length,b=iR.computeStrides(t),v=n.length,x=iR.computeStrides(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){let t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=r.real,h[w]=r.imag}else for(let w=0;w<d.length;w++){let t=iR.indexToLoc(w,u,c),n=t.slice(-y);p.forEach((e=>n[e]=0));let r=iR.locToIndex(n,y,b),a=t.slice(-v);f.forEach((e=>a[e]=0));let s=iR.locToIndex(a,v,x),i=e(m[2*r],m[2*r+1],g[2*s],g[2*s+1]);d[w]=i.real,h[w]=i.imag}return[d,h,o]}}var I3=d3(((e,t)=>e+t)),T3=S3(((e,t,n,r)=>({real:e+n,imag:t+r}))),N3=k3(RA,I3,T3),C3={kernelName:RA,backendName:"cpu",kernelFunc:N3};function A3(e,t,n,r,a){let s=iR.sizeFromShape(r),i=iR.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=s>0?t[o]:1)}return i}function E3(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=e.shape[0],s=e.shape[1],i=JM([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){let s=e.get(o,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}var _3=d3(((e,t)=>e&t)),$3=k3(XA,_3),R3={kernelName:XA,backendName:"cpu",kernelFunc:$3};function D3(e){return(t,n,r)=>{let a=iR.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function M3(e,t,n){return F3(e,D3(t),n)}function F3(e,t,n){return r=>{let{inputs:a,attrs:s,backend:i}=r,{x:o}=a;s3(o,e);let l,u=i,c=u.data.get(o.dataId).values;if("string"===o.dtype){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");l=FW.fromUint8ToStringArray(c)}else l=c;let d=n||o.dtype,h=t(l,d,s);return u.makeTensorInfo(o.shape,d,h)}}var O3=D3((e=>Math.ceil(e))),P3=F3(eE,O3),L3={kernelName:eE,backendName:"cpu",kernelFunc:P3};function z3(e,t,n,r){let a=iR.getArrayFromDType(n,iR.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{let n=iR.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{let s="string"===n?FW.fromUint8ToStringArray(e.vals):e.vals,i=0;for(let n=0;n<e.shape[0];++n){let o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]}))}return a}var B3=d3(((e,t)=>e===t?1:0)),V3=k3($E,B3,null,"bool"),W3={kernelName:$E,backendName:"cpu",kernelFunc:V3},U3=D3((e=>Math.exp(e))),j3=F3(RE,U3,"float32"),G3={kernelName:RE,backendName:"cpu",kernelFunc:j3},H3=D3((e=>Math.expm1(e))),q3=F3(ME,H3),K3={kernelName:ME,backendName:"cpu",kernelFunc:q3},Y3=D3((e=>Math.floor(e))),X3=F3(LE,Y3),Q3={kernelName:LE,backendName:"cpu",kernelFunc:X3},Z3=d3(((e,t)=>Math.floor(e/t))),J3=k3(zE,Z3,null,"int32"),e4={kernelName:zE,backendName:"cpu",kernelFunc:J3};function t4(e,t,n,r,a,s,i,o,l){let u=JM([r,s],n);for(let c=0;c<r;c++){let n=[],r=0;for(let t=0;t<a;t++){let s=e[c*a+t];r+=s*i[t],n.push(s)}if(r<0||r>=l/s)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<s;e++)u.values[c*s+e]=t.get(...t.indexToLoc(r*s+e))}return u}function n4(e,t,n){let r=JM(n,e.dtype);for(let a=0;a<r.size;++a){let n=r.indexToLoc(a).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];let l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}var r4=d3(((e,t)=>e>t?1:0)),a4=k3(UE,r4,null,"bool"),s4={kernelName:UE,backendName:"cpu",kernelFunc:a4},i4=d3(((e,t)=>e>=t?1:0)),o4=k3(jE,i4,null,"bool"),l4={kernelName:jE,backendName:"cpu",kernelFunc:o4},u4=d3(((e,t)=>e<t?1:0)),c4=k3(ZE,u4,null,"bool"),d4={kernelName:ZE,backendName:"cpu",kernelFunc:c4},h4=d3(((e,t)=>e<=t?1:0)),p4=k3(JE,h4,null,"bool"),f4={kernelName:JE,backendName:"cpu",kernelFunc:p4};function m4(e,t,n){let r=(t-e)/(n-1),a=iR.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}var g4=D3((e=>Math.log(e))),y4=F3(t_,g4),b4={kernelName:t_,backendName:"cpu",kernelFunc:y4};function v4(e,t,n,r){let a=iR.getTypedArrayFromDType(r,iR.sizeFromShape(n));for(let s=0;s<a.length;++s){let n=s*t,r=e[n];for(let a=0;a<t;++a){let t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[s]=r}return a}var x4=d3(((e,t)=>Math.max(e,t))),w4=k3(p_,x4),k4={kernelName:p_,backendName:"cpu",kernelFunc:w4},S4=d3(((e,t)=>Math.min(e,t))),I4=k3(w_,S4),T4={kernelName:w_,backendName:"cpu",kernelFunc:I4},N4=d3(((e,t)=>e*t)),C4=S3(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),A4=k3(T_,N4,C4),E4={kernelName:T_,backendName:"cpu",kernelFunc:A4};function _4(e,t,n){let r=iR.createScalarValue(-1,n);return N4([],t,r,e,n)}var $4={kernelName:N_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t;s3(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=_4(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}},R4=d3(((e,t)=>e!==t?1:0)),D4=k3(C_,R4,null,"bool"),M4={kernelName:C_,backendName:"cpu",kernelFunc:D4};function F4(e,t,n,r,a){let s=t.length,i=iR.sizeFromShape(t),o=iR.computeStrides(t),l=iR.computeStrides(a),u=iR.getTypedArrayFromDType(n,iR.sizeFromShape(a));for(let c=0;c<i;++c){let t=iR.indexToLoc(c,s,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[iR.locToIndex(n,s,l)]=e[c]}return u}function O4(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;s3(a,"transpose");let i=a.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=a.shape[s[u]];let l=F4(r.data.get(a.dataId).values,a.shape,a.dtype,s,o);return{dataId:r.write(l,o,a.dtype),shape:o,dtype:a.dtype}}var P4={kernelName:F$,backendName:"cpu",kernelFunc:O4};function L4(e,t,n,r){let[a,s]=FW.computeOutAndReduceShapes(e,r),i=tD(t,"int32"),o=iR.makeZerosTypedArray(iR.sizeFromShape(a),i),l=iR.sizeFromShape(s);for(let u=0;u<o.length;++u){let e=u*l,t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:a,outDtype:i}}var z4={kernelName:L_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;s3(a,"prod");let o=a.shape.length,l=iR.parseAxisParam(s,a.shape),u=FW.getAxesPermutation(l,o),c=l,d=a,h=[];null!=u&&(d=O4({inputs:{x:a},backend:n,attrs:{perm:u}}),h.push(d),c=FW.getInnerMostAxes(c.length,o));let p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=L4(d.shape,d.dtype,p,c),y=m;return i&&(y=FW.expandShapeToKeepDim(m,l)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function B4(e,t,n,r){let a=[],s=0,i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){let a=n[e],s=e+t.length-1;if(s>=0){let e=o[s],t=e[e.length-1]-a[r];for(let n=r;n<i;++n)o[s].push(a[n+1]+t)}r=a[r],i=a[i]}i!==r&&(a.push([r,i]),s+=i-r)}return{outSplits:o,valueSlices:a,numValues:s}}function V4(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function W4(e,t,n,r,a){let s=t.slice();s[0]=a;let i=iR.getArrayFromDType(n,iR.sizeFromShape(s)),o=e.length;return function(e,t,n,r,a,s){let i=V4(t,2)[1],o=V4(s,2)[1],l=0;for(let u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)a[l*o+n]=e[t*i+n];++l}}(e,t,r,0===o?0:o/t[0],i,s),[i,s]}function U4(e,t,n,r,a,s,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){let a=iR.indexToLoc(r,t.length,iR.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(s,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");let l=r[0],{outSplits:u,valueSlices:c,numValues:d}=B4(s,i,e,l),h=function(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=iR.getArrayFromDType("int32",r);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(u),p=W4(n,r,a,c,d);return[h,p[0],p[1]]}var j4=2147483647;function G4(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=0===t.length,l=0===a.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(a[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");let d=0===c.length?1:c[0],h=iR.getArrayFromDType("int32",d+1);h[0]=0;for(let g=0;g<d;++g){let t,n=o?e[0]:e[g],a=l?r[0]:r[g],i=u?s[0]:s[g];if(0===i)throw new Error("Requires delta != 0");if(i>0&&a<n||i<0&&a>n)t=0;else if(t=Math.ceil(Math.abs((a-n)/i)),t>j4)throw new Error(`Requires ((limit - start) / delta) <= ${j4}`);h[g+1]=h[g]+t}let p=h[d],f=iR.getArrayFromDType(n,p),m=0;for(let g=0;g<d;++g){let t=h[g+1]-h[g],n=o?e[0]:e[g],r=u?s[0]:s[g];for(let e=0;e<t;++e)f[m++]=n,n+=r}return[h,f]}var H4=FW.RowPartitionType,q4=class e{constructor(e,t,n,r,a,s,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=FW.getRowPartitionTypesHelper(u),this.raggedRank=FW.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===H4.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===H4.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case H4.VALUE_ROWIDS:return e.getMaxWidthValueRowID(n);case H4.ROW_SPLITS:return e.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${H4[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){let t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){let t=e[s];t!==r&&(r=t,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Y4(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;FW.validateDefaultValueShape(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=FW.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let s=1;s<=this.raggedRank;++s)a[s]<0&&(a[s]=this.getMaxWidth(s));return a}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),a=[],s=0;for(let i=0;i<r;++i,s+=t)a.push(s);for(let i=r;i<e;++i)a.push(-1);return iR.assert(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){let a=e.length,s=[];for(let i=0;i<a-1;++i){let a=e[i+1]-e[i],o=Math.min(r,a),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)s.push(l),l+=n;for(let e=0;e<a-o;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){let a=e.length,s=[];if(0===a)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let u=1;u<a;++u){let a=e[u];if(a===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}s.push(l)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){let a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case H4.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case H4.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${H4[s]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case H4.FIRST_DIM_SIZE:return e[0];case H4.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case H4.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${H4[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];let r=Y4(t,!1),a=iR.getArrayFromDType(this.valuesDType,iR.sizeFromShape(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)s=this.calculateOutputIndex(e-1,s,n[e],t[e]);this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;let a=this.values,s=n,i=r.slice();i=i.slice(e+1);let o=iR.sizeFromShape(i),l=t.length,u=this.defaultValue;if(u.length!==o&&1!==u.length){let e=this.defaultValueShape;WD((()=>{let t=FF(u,e);u=JF(t,i).dataSync()}))}let c=0,d=0,h=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==h){if(d<h){let e=a.subarray(c*o);K4(s.subarray(d*o),e,(h-d)*o)}if(p>=l){let t=n.length;e=Math.floor(t/o)}if(e>h)if(1===this.defaultValue.length)s.subarray(h*o,e*o).fill(this.defaultValue[0]),h=e;else for(;e>h;){K4(s.slice(h*o),u,o),++h}e<0?(c=p+1,d=h):(c=p,d=h,h=d+1)}else++h}}};function K4(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function Y4(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function X4(e,t,n,r,a,s,i,o,l,u){return new q4(e,t,n,r,a,s,i,o,l,u).compute()}function Q4(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return iR.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((t-e)/n)),s=iR.makeZerosTypedArray(a,r);t<e&&1===n&&(n=-1),s[0]=e;for(let i=1;i<s.length;i++)s[i]=s[i-1]+n;return s}var Z4=D3((e=>1/Math.sqrt(e))),J4=F3(e$,Z4),e5={kernelName:e$,backendName:"cpu",kernelFunc:J4};function t5(e,t,n,r,a,s,i,o,l,u){let c=[r/a,a],d=e.values,h=t.values;if(0===r)return JM(n,t.dtype);let p=l instanceof VR?l:JM(c,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let f=0;f<s;f++){let e=[],s=0;for(let t=0;t<i;t++){let n=d[f*i+t];e.push(n),s+=n*o[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?p.values[s*a+n]+=h[f*a+n]:p.values[s*a+n]=0===t.rank?h[0]:h[f*a+n]}return p}var n5=D3((e=>1/(1+Math.exp(-e)))),r5=M3(c$,(e=>1/(1+Math.exp(-e)))),a5={kernelName:c$,backendName:"cpu",kernelFunc:r5};function s5(e,t,n,r,a){let s=uW.isSliceContinous(r,t,n),i=iR.sizeFromShape(n),o=iR.computeStrides(r);if(s){let n=uW.computeFlatOffset(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}let l=JM(r,a,"string"===a?FW.fromUint8ToStringArray(e):e),u=JM(n,a);for(let c=0;c<u.size;++c){let e=u.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===a?FW.fromStringArrayToUint8(u.values):u.values}function i5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;s3(a,"slice");let[o,l]=uW.parseSliceParams(a,s,i);uW.assertParamsValid(a,o,l);let u=s5(n.data.get(a.dataId).values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var o5={kernelName:i$,backendName:"cpu",kernelFunc:i5};function l5(e,t,n,r,a,s,i){let o=t[0],l=s[0],u=new Array(l),c=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(FW.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[iR.getArrayFromDType(n,0),[0,d],iR.getArrayFromDType(a,0),u,c]}let h=!0,p=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let t=e[g*d];if(t<0)throw new Error(FW.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,t));if(t>=l)throw new Error(FW.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,t,l));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<l;++g){let e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){let t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,d],n,u,c]}{let t=f[l-1],s=iR.getArrayFromDType(n,t*d),h=iR.getArrayFromDType(a,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){let t=e[n*d],a=p[t],i=(0===t?0:f[t-1])+a;p[t]++;for(let r=0;r<d;++r)s[i*d+r]=e[n*d+r];h[i]=r[n],c[n]=i}for(let e=0;e<l;++e)if(0===p[e]){let t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;h[t]=i}return[s,[t,d],h,u,c]}}function u5(e,t,n,r,a){let s=iR.sizeFromShape(r),i=t[0],o=a.length,l=[],u=1,c=-1;for(let m=0;m<o;++m){let e=a[m];if(-1===e){if(-1!==c)throw new Error(FW.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,m));c=m,l.push(1)}else{if(e<0)throw new Error(FW.getSparseReshapeNegativeOutputDimErrorMessage(m,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error(FW.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(s/u);if(u*e!==s)throw new Error(FW.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=e}if(iR.sizeFromShape(l)!==s)throw new Error(FW.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}let p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}let f=iR.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],l]}function c5(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?a[o-1]+1:0;if(c<0)throw new Error(FW.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=c;let h=d.reduce(((e,t)=>e*t),1),p=iR.getArrayFromDType(n,h);if(0===o)return c>0&&p.fill(i),[p,d];if(c<=0)throw new Error(FW.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let t=0;if(m<o){if(t=a[m],y===t){++m;continue}if(y>=t)throw new Error(FW.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=c)throw new Error(FW.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,c));y>g&&p.fill(i,g*u,y*u);for(let n=f;n<m;++n){let t=r[n];if(t<0||t>=l[0])throw new Error(FW.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,r[n],l[0]));for(let n=0;n<u;n++)p[y*u+n]+=e[t*u+n]}if(s)for(let e=0;e<u;e++)p[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<c&&p.fill(i,g*u,c*u),[p,d]}var d5=D3((e=>Math.sqrt(e))),h5=M3(h$,(e=>Math.sqrt(e))),p5={kernelName:h$,backendName:"cpu",kernelFunc:h5},f5=d3(((e,t)=>{let n=e-t;return n*n})),m5=k3(k$,f5),g5={kernelName:k$,backendName:"cpu",kernelFunc:m5},y5=D3(((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),b5=F3(I$,y5),v5={kernelName:I$,backendName:"cpu",kernelFunc:b5};function x5(e,t,n,r){let a=JM(e,t.dtype);for(let s=0;s<a.size;s++){let e=a.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}var w5=class{constructor(e,t,n,r,a,s){this.separator=iR.encodeString(e),this.nGramWidths=t,this.leftPad=iR.encodeString(n),this.rightPad=iR.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),c=s-(l+u),d=t+(l>0?0:i-o),h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length,h+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(h);let p=n[r+i],f=0,m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}let a=r-1,s=iR.getArrayFromDType("int32",r);if(0===n||0===r){let e=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[e,s]}s[0]=0;for(let o=1;o<=a;++o){let e=t[o]-t[o-1],n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[o]=s[o-1]+n}let i=new Array(s[a]);for(let o=0;o<a;++o){let n=t[o],r=s[o];if(this.nGramWidths.forEach((a=>{let s=t[o+1]-t[o],l=this.getNumNGrams(s,a);this.createNGrams(e,n,i,r,l,a),r+=l})),this.preserveShort&&r===s[o]){let a=t[o+1]-t[o];if(0===a)continue;let s=a+2*this.padWidth;this.createNGrams(e,n,i,r,1,s)}}return[i,s]}};function k5(e,t,n,r,a,s,i,o){return new w5(n,r,a,s,i,o).compute(e,t)}function S5(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],s=e.indexOf(a);for(;-1!==s;){let t=e.subarray(0,s);(!n||0!==t.length)&&r.push(t),s=(e=e.subarray(s+1)).indexOf(a)}return void((!n||0!==e.length)&&r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){let t=e.subarray(a,s);(!n||0!==t.length)&&r.push(t),a=s+1}}function I5(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let h=0;h<r;++h){let r=a.length;S5(e[h],t,n,a);let l=a.length-r;o[h]=l,s+=l,i=Math.max(i,l)}let l=iR.getArrayFromDType("int32",2*s),u=new Array(s),c=[r,i],d=0;for(let h=0;h<r;++h)for(let e=0;e<o[h];++e)l[2*d]=h,l[2*d+1]=e,u[d]=a[d],++d;return[l,u,c]}function T5(e,t){let n=iR.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=iR.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var N5=d3(((e,t)=>e-t)),C5=S3(((e,t,n,r)=>({real:e-n,imag:t-r}))),A5=k3(E$,N5,C5),E5={kernelName:E$,backendName:"cpu",kernelFunc:A5};function _5(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=JM(n,e.dtype);for(let a=0;a<r.values.length;++a){let t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];let s=e.locToIndex(n);r.values[a]=e.values[s]}return r}var $5=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function R5(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){let a=r-n+1,s=t-n+1,i=Math.log(a),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(a-o)/a)*Math.sign(s-a/2);R5(e,t,Math.max(n,Math.floor(t-s*o/a+l)),Math.min(r,Math.floor(t+(a-s)*o/a+l)))}let a=e[t],s=n,i=r;for(iR.swap(e,n,t),$5(e[r],a)>0&&iR.swap(e,n,r);s<i;){for(iR.swap(e,s,i),s++,i--;$5(e[s],a)<0;)s+=1;for(;$5(e[i],a)>0;)i-=1}0===$5(e[n],a)?iR.swap(e,n,i):(i+=1,iR.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function D5(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=iR.getTypedArrayFromDType(n,i*r),u=iR.getTypedArrayFromDType("int32",i*r);for(let d=0;d<i;d++){let t=d*o,n=e.subarray(t,t+o),s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(R5(s,r),s=s.slice(0,r)),a&&s.sort($5);let i=d*r,c=l.subarray(i,i+r),h=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=s[e].value,h[e]=s[e].index}let c=t.slice();return c[c.length-1]=r,[JM(c,n,l),JM(c,"int32",u)]}function M5(e,t,n,r){let a=iR.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];let i=new Map,o=new Int32Array(n[a]),l=new VR(s,r,e),u=[],c=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let t;if(c)t=e[f].toString();else{let e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(l.get(t,f,n));t=e.join(",")}let n=i.get(t);if(null!=n)o[f]=n;else{let e=i.size;i.set(t,e),o[f]=e,u.push(f)}}let d=s.slice();d[1]=i.size;let h=new VR(d,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)h.set(l.get(n,e,r),n,t,r)}));let p=n.slice();return p[a]=d[1],{outputValues:h.values,outputShape:p,indices:o}}var F5="4.16.0";ZD("cpu",(()=>new o3),1);var O5=M3(AE,(e=>e>=0?e:Math.exp(e)-1)),P5={kernelName:AE,backendName:"cpu",kernelFunc:O5};function L5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;s3([a],"leakyRelu");let i=iR.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=iR.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}var z5={kernelName:QE,backendName:"cpu",kernelFunc:L5},B5=d3(((e,t)=>e<0?t*e:e));function V5(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;s3([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=B5(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var W5={kernelName:P_,backendName:"cpu",kernelFunc:V5},U5=M3(G_,(e=>Math.max(0,e))),j5={kernelName:G_,backendName:"cpu",kernelFunc:U5},G5=M3(Q_,(e=>Math.min(Math.max(0,e),6))),H5={kernelName:Q_,backendName:"cpu",kernelFunc:G5};function q5(e,t,n,r,a){if("linear"===n)return m3({inputs:{x:t},backend:e});if("relu"===n)return U5({inputs:{x:t},backend:e});if("elu"===n)return O5({inputs:{x:t},backend:e});if("relu6"===n)return G5({inputs:{x:t},backend:e});if("prelu"===n)return V5({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return L5({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return r5({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function K5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=iR.sizeFromShape(a.shape),o=iR.inferFromImplicitShape(s,i),l=iR.sizeFromShape(o);iR.assert(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){let e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var Y5={kernelName:H_,backendName:"cpu",kernelFunc:K5};function X5(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;s3([a,s],"matMul");let l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=iR.sizeFromShape(f),y=iR.sizeFromShape(m),b=SO.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);iR.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let v=o?[y,p,d]:[y,d,p],x=K5({inputs:{x:a},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=K5({inputs:{x:s},backend:n,attrs:{shape:v}}),k=i?x.shape[1]:x.shape[2],S=i?x.shape[2]:x.shape[1],I=o?w.shape[1]:w.shape[2],T=Math.max(g,y),N=n.data.get(x.dataId).values,C=n.data.get(w.dataId).values,A=iR.computeStrides(x.shape),E=iR.computeStrides(w.shape),[_,$,R]=i?[A[0],1,A[1]]:[A[0],A[1],1],[D,M,F]=o?[1,E[1],E[0]]:[E[1],1,E[0]],O=S*I,P=JM([T,S,I],x.dtype),L=P.values,z=n.blockSize;for(let B=0;B<T;B++){let e=B%g,t=B%y;for(let n=0;n<S;n+=z){let r=Math.min(n+z,S);for(let a=0;a<I;a+=z){let s=Math.min(a+z,I);for(let i=0;i<k;i+=z){let o=Math.min(i+z,k);for(let l=n;l<r;l++)for(let n=a;n<s;n++){let r=0;for(let a=i;a<o;a++){r+=N[e*_+l*$+a*R]*C[a*D+n*M+t*F]}L[B*O+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,P.dtype,P.values)}var Q5={kernelName:qA,backendName:"cpu",kernelFunc:X5};var Z5={kernelName:j$,backendName:"cpu",kernelFunc:function(e){let t,n,r,{inputs:a,backend:s,attrs:i}=e,{a:o,b:l,bias:u,preluActivationWeights:c}=a,{transposeA:d,transposeB:h,activation:p,leakyreluAlpha:f}=i,m=[];t=X5({inputs:{a:o,b:l},attrs:{transposeA:d,transposeB:h},backend:s}),u&&(n=N3({inputs:{a:t,b:u},backend:s}),m.push(t),t=n),p&&(r=q5(s,t,p,c,f),m.push(t),t=r);for(let g of m)s.disposeIntermediateTensorInfo(g);return t}},J5=M3(_A,(e=>Math.acos(e))),e6={kernelName:_A,backendName:"cpu",kernelFunc:J5},t6=M3($A,(e=>Math.acosh(e))),n6={kernelName:$A,backendName:"cpu",kernelFunc:t6};var r6={kernelName:DA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,r=t;s3(t,"addN");let a=r.map((e=>n.data.get(e.dataId).values)),s=JM(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){let e=a[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};var a6={kernelName:MA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;s3(a,"all");let o=iR.parseAxisParam(s,a.shape),l=o,u=FW.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=O4({inputs:{x:a},backend:n,attrs:{perm:u}}),l=FW.getInnerMostAxes(l.length,a.shape.length)),FW.assertAxesAreInnerMostDims("all",l,c.shape.length);let[d,h]=FW.computeOutAndReduceShapes(c.shape,l),p=iR.sizeFromShape(h),f=iR.makeZerosTypedArray(iR.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*p,t=m[e];for(let n=0;n<p;++n){let r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let e=K5({inputs:{x:g},backend:n,attrs:{shape:FW.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var s6={kernelName:FA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;s3(a,"any");let o=iR.parseAxisParam(s,a.shape),l=o,u=FW.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=O4({inputs:{x:a},backend:n,attrs:{perm:u}}),l=FW.getInnerMostAxes(l.length,a.shape.length)),FW.assertAxesAreInnerMostDims("any",l,c.shape.length);let[d,h]=FW.computeOutAndReduceShapes(c.shape,l),p=iR.sizeFromShape(h),f=iR.makeZerosTypedArray(iR.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*p,t=m[e];for(let n=0;n<p;++n){let r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let e=K5({inputs:{x:g},backend:n,attrs:{shape:FW.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var i6={kernelName:OA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;s3(a,"argMax");let i=iR.parseAxisParam(s,a.shape),o=FW.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=O4({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=FW.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],FW.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,d]=FW.computeOutAndReduceShapes(l.shape,i),h=iR.sizeFromShape(c),p=iR.makeZerosTypedArray(h,"int32"),f=iR.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a>t&&(t=a,n=r)}p[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}};var o6={kernelName:PA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;s3(a,"argMin");let i=iR.parseAxisParam(s,a.shape),o=FW.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=O4({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=FW.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],FW.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,d]=FW.computeOutAndReduceShapes(l.shape,i),h=iR.sizeFromShape(c),p=iR.makeZerosTypedArray(h,"int32"),f=iR.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a<t&&(t=a,n=r)}p[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}},l6=M3(LA,(e=>Math.asin(e))),u6={kernelName:LA,backendName:"cpu",kernelFunc:l6},c6=M3(zA,(e=>Math.asinh(e))),d6={kernelName:zA,backendName:"cpu",kernelFunc:c6},h6=M3(BA,(e=>Math.atan(e))),p6={kernelName:BA,backendName:"cpu",kernelFunc:h6},f6=d3(((e,t)=>Math.atan2(e,t))),m6=k3(WA,f6),g6={kernelName:WA,backendName:"cpu",kernelFunc:m6},y6=M3(VA,(e=>Math.atanh(e))),b6={kernelName:VA,backendName:"cpu",kernelFunc:y6};function v6(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,c=a.effectiveFilterHeight,d=a.effectiveFilterWidth,h=a.padInfo.top,p=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=JM(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let x=0;x<a.batchSize;++x){let t=x*y,n=x*r[0];for(let m=0;m<a.inChannels;++m)for(let y=0;y<a.outHeight;++y){let x=y*i-h,w=Math.max(0,x),k=Math.min(a.inHeight,c+x),S=t+y*b;for(let t=0;t<a.outWidth;++t){let i=t*o-p,c=Math.max(0,i),h=Math.min(a.inWidth,d+i),y=f,b=0,x=0;for(let t=w;t<k;t+=l){let a=n+t*r[1];for(let t=c;t<h;t+=u){let n=e[a+t*r[2]+m];"max"===s&&n>y?y=n:"avg"===s&&(b+=n,x++)}if(isNaN(y))break}g[S+t*v+m]="avg"===s?b/x:y}}}return m}function x6(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=JM(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=JM(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){let n=t*o-p,y=n;for(;y<0;)y+=u;let b=Math.min(r.inHeight,d+n);for(let o=0;o<r.outWidth;++o){let d=o*l-f,p=d;for(;p<0;)p+=c;let v=Math.min(r.inWidth,h+d),x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=u){let i=t-n;for(let n=p;n<v;n+=c){let o=n-d,l=m.get(g,t,n,e);l>x&&(x=l,w=a?s?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*h+o)}}i.set(w,g,t,o,e)}}return i}function w6(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,c=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=JM(a.outShape,n),x=v.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let T=0;T<a.batchSize;++T){let t=T*w,n=T*r[0];for(let v=0;v<a.inChannels;++v)for(let w=0;w<a.outDepth;++w){let T=w*i-m,N=T;for(;N<0;)N+=u;let C=Math.min(a.inDepth,h+T),A=t+w*k;for(let t=0;t<a.outHeight;++t){let i=t*o-g,h=i;for(;h<0;)h+=c;let m=Math.min(a.inHeight,p+i),w=A+t*S;for(let t=0;t<a.outWidth;++t){let i=t*l-y,o=i;for(;o<0;)o+=d;let p=Math.min(a.inWidth,f+i),g=w+t*I,k=b,S=0,T=0;for(let t=N;t<C;t+=u){let a=n+t*r[1];for(let t=h;t<m;t+=c){let n=a+t*r[2];for(let t=o;t<p;t+=d){let a=e[n+t*r[3]+v];if("max"===s&&a>k?k=a:"avg"===s&&(S+=a,T++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===s?S/Math.max(T,1):k}}}}return v}var k6={kernelName:UA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;s3(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;iR.assert(FW.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u,c=FW.computePool2DInfo(a.shape,s,i,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&iR.arraysEqual(c.inShape,c.outShape))u=m3({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=iR.computeStrides(a.shape),r=v6(e,a.shape,a.dtype,t,c,"avg");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};var S6={kernelName:GA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;s3(a,"avgPool3d");let c=FW.computePool3DInfo(a.shape,s,i,1,o,l,u),d=w6(n.data.get(a.dataId).values,a.shape,a.dtype,iR.computeStrides(a.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};var I6={kernelName:HA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;s3([a,s],"avgPool3DGrad");let c=FW.computePool3DInfo(s.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=x-1-c.padInfo.front,I=k-1-c.padInfo.left,T=w-1-c.padInfo.top,N=JM(s.shape,"float32"),C=1/(f*m*g),A=n.bufferSync(a);for(let E=0;E<c.batchSize;++E)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){let a=t-S,s=n-T,i=r-I,o=0;for(let t=0;t<x;t+=y){let n=(a+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){let r=(s+t)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){let a=(i+t)/p;a<0||a>=c.outWidth||Math.floor(a)!==a||(o+=A.get(E,n,r,a,e))}}}N.set(o*C,E,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};var T6={kernelName:jA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;s3([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=FW.computePool2DInfo(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=JM(i.shape,"float32"),k=1/(p*f),S=n.data.get(a.dataId).values,I=JM(a.shape,"float32",S);for(let T=0;T<c.batchSize;++T)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){let r=t-x,a=n-v,s=0;for(let t=0;t<y;t+=m){let n=(r+t)/d;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){let r=(a+t)/h;r<0||r>=c.outWidth||Math.floor(r)!==r||(s+=I.get(T,n,r,e))}}w.set(s*k,T,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};var N6={kernelName:BE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;iR.assert(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),iR.assert(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),iR.assert(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),s3([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);let c=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,v=d.length,x=0,w=0,k=0,S=0;for(let I=0;I<c.length;++I)m[I]=f[x++]+(c[I]-d[w++])*p[k++]/Math.sqrt(h[S++]+u),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,m)}};var C6={kernelName:KA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;s3([a],"batchToSpaceND");let o=s.reduce(((e,t)=>e*t)),l=FW.getReshaped(a.shape,s,o),u=FW.getPermuted(l.length,s.length),c=FW.getReshapedPermuted(a.shape,s,o),d=FW.getSliceBeginCoords(i,s.length),h=FW.getSliceSize(c,i,s.length),p=K5({inputs:{x:a},backend:n,attrs:{shape:l}}),f=O4({inputs:{x:p},backend:n,attrs:{perm:u}}),m=K5({inputs:{x:f},backend:n,attrs:{shape:c}}),g=i5({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};var A6={kernelName:YA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=A3(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}};var E6={kernelName:ZA,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=FW.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},_6=M3(tE,((e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),$6={kernelName:tE,backendName:"cpu",kernelFunc:_6},R6={kernelName:rE,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(iR.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function D6(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var M6={kernelName:qE,backendName:"cpu",kernelFunc:D6};function F6(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=iR.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));FW.assertParamsConsistent(i,s);let o=FW.computeOutShape(t.map((e=>e.shape)),s);if(0===iR.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>iR.sizeFromShape(e.shape)>0));if(1===l.length)return m3({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){let e=l.map((e=>y3({inputs:{input:e},backend:n}))),t=l.map((e=>D6({inputs:{input:e},backend:n}))),r=F6({inputs:e,backend:n,attrs:{axis:s}}),a=F6({inputs:t,backend:n,attrs:{axis:s}}),i=h3({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}let u=l.map((e=>{let t=[-1,iR.sizeFromShape(e.shape.slice(s))];return K5({inputs:{x:e},backend:n,attrs:{shape:t}})})),c=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=FW.computeOutShape(u.map((e=>e.shape)),1);let d=1===u[0].shape[0],h=z3(c,o,t[0].dtype,d),p=FW.computeOutShape(l.map((e=>e.shape)),s),f=n.makeTensorInfo(p,t[0].dtype,h);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var O6={kernelName:aE,backendName:"cpu",kernelFunc:F6};function P6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;s3([a,s],"conv2d");let d=FW.convertConv2DDataFormat(l),h=FW.computeConv2DInfo(a.shape,s.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new VR(h.outShape,a.dtype),w=iR.computeStrides(a.shape),k=iR.computeStrides(s.shape),S=w[0],I=v?w[1]:w[2],T=v?w[2]:1,N=v?1:w[1],C=x.strides[0],A=v?x.strides[1]:x.strides[2],E=v?x.strides[2]:1,_=v?1:x.strides[1],$=n.data.get(a.dataId).values,R=n.data.get(s.dataId).values,D=x.values;for(let M=0;M<h.batchSize;++M){let e=M*S,t=M*C;for(let n=0;n<h.outHeight;++n){let r=t+n*A,a=n*h.strideHeight-b;for(let t=0;t<p;++t){let n=a+t*m;if(n<0||n>=h.inHeight)continue;let s=t*k[0],i=e+n*I;for(let e=0;e<h.outWidth;++e){let t=r+e*E,n=e*h.strideWidth-y;for(let e=0;e<f;++e){let r=n+e*g;if(r<0||r>=h.inWidth)continue;let a=i+r*T,o=s+e*k[1];for(let e=0;e<h.inChannels;++e){let n=$[a+e*N];for(let e=0;e<h.outChannels;++e)D[t+e*_]+=n*R[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,D)}var L6={kernelName:sE,backendName:"cpu",kernelFunc:P6};var z6={kernelName:iE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;s3([a,s],"conv2dBackpropFilter");let d=FW.convertConv2DDataFormat(l),h=FW.computeConv2DInfo(a.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new VR(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=new VR(a.shape,a.dtype,w),I=new VR(s.shape,s.dtype,k);for(let T=0;T<m;++T){let e=Math.max(0,Math.ceil((x-T)/p)),t=Math.min(h.outHeight,(h.inHeight+x-T)/p);for(let n=0;n<g;++n){let r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(h.outWidth,(h.inWidth+v-n)/f);for(let s=0;s<h.inChannels;++s)for(let i=0;i<h.outChannels;++i){let o=0;for(let l=0;l<h.batchSize;++l)for(let u=e;u<t;++u){let e=T+u*p-x;for(let t=r;t<a;++t){let r=n+t*f-v;o+=y?S.get(l,e,r,s)*I.get(l,u,t,i):S.get(l,s,e,r)*I.get(l,i,u,t)}}b.set(o,T,n,s,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var B6={kernelName:oE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;s3([a,s],"conv2dBackpropInput");let d=iR.computeStrides(s.shape),h=iR.computeStrides(a.shape),p=FW.convertConv2DDataFormat(u),f=FW.computeConv2DInfo(i,s.shape,o,1,l,c,!1,p),m=new VR(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[v,x,w]=d,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:T,inHeight:N,inWidth:C,outChannels:A,outHeight:E,outWidth:_,strideHeight:$,strideWidth:R}=f;p=f.dataFormat;let D=S-1-f.padInfo.top,M=I-1-f.padInfo.left,F="channelsLast"===p,O=m.strides[0],P=F?m.strides[1]:m.strides[2],L=F?m.strides[2]:1,z=F?1:m.strides[1],B=h[0],V=F?h[1]:h[2],W=F?h[2]:1,U=F?1:h[1];for(let j=0;j<k;++j)for(let e=0;e<T;++e)for(let t=0;t<N;++t){let n=t-D,r=Math.max(0,Math.ceil(n/$)),a=Math.min(E,(S+n)/$);for(let s=0;s<C;++s){let i=s-M,o=Math.max(0,Math.ceil(i/R)),l=Math.min(_,(I+i)/R),u=0;for(let t=r;t<a;++t){let r=t*$-n;for(let n=o;n<l;++n){let a=B*j+V*t+W*n,s=v*(S-1-r)+x*(I-1-(n*R-i))+w*e;for(let e=0;e<A;++e){u+=y[a+U*e]*b[s+e]}}}g[O*j+P*t+L*s+z*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};var V6={kernelName:lE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;s3([a,s],"conv3d");let u=FW.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new VR(u.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=x.values,I=iR.computeStrides(a.shape),T=iR.computeStrides(s.shape);for(let N=0;N<u.batchSize;++N){let e=N*I[0],t=N*x.strides[0];for(let n=0;n<u.outDepth;++n){let r=t+n*x.strides[1],a=n*u.strideDepth-y;for(let t=0;t<c;++t){let n=a+t*p;if(n<0||n>=u.inDepth)continue;let s=t*T[0],i=e+n*I[1];for(let e=0;e<u.outHeight;++e){let t=r+e*x.strides[2],n=e*u.strideHeight-v;for(let e=0;e<d;++e){let r=n+e*f;if(r<0||r>=u.inHeight)continue;let a=s+e*T[1],o=i+r*I[2];for(let e=0;e<u.outWidth;++e){let n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<h;++e){let t=r+e*m;if(t<0||t>=u.inWidth)continue;let s=a+e*T[2],i=o+t*u.inChannels,l=s;for(let e=0;e<u.inChannels;++e){let t=w[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};var W6={kernelName:uE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;s3([a,s],"conv3dBackpropFilterV2");let u=iR.computeStrides(a.shape),c=iR.computeStrides(s.shape),d=FW.computeConv3DInfo(a.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new VR(d.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,I=n.data.get(s.dataId).values,[T,N,C,A]=c,E=n.data.get(a.dataId).values,[_,$,R,D]=u,M=d.padInfo.front,F=d.padInfo.left,O=d.padInfo.top;for(let P=0;P<m;++P){let e=Math.max(0,Math.ceil((M-P)/h)),t=Math.min(d.outDepth,(d.inDepth+M-P)/h),n=P*x;for(let r=0;r<g;++r){let a=Math.max(0,Math.ceil((O-r)/p)),s=Math.min(d.outHeight,(d.inHeight+O-r)/p),i=r*w+n;for(let n=0;n<y;++n){let o=Math.max(0,Math.ceil((F-n)/f)),l=Math.min(d.outWidth,(d.inWidth+F-n)/f),u=n*k+i;for(let i=0;i<d.inChannels;++i){let c=i*S+u;for(let u=0;u<d.outChannels;++u){let m=0;for(let c=0;c<d.batchSize;++c){let d=c*_,g=c*T;for(let c=e;c<t;++c){let e=(P+c*h-M)*$+d,t=c*N+g;for(let c=a;c<s;++c){let a=(r+c*p-O)*R+e,s=c*C+t;for(let e=o;e<l;++e){let t=e*A+s;m+=E[(n+e*f-F)*D+a+i]*I[t+u]}}}}v[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};var U6={kernelName:cE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;s3([a],"conv3dBackpropInputV2");let u=iR.computeStrides(a.shape),c=iR.computeStrides(s.shape),d=FW.computeConv3DInfo(l,s.shape,o,1,i),h=new VR(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(a.dataId).values,[v,x,w,k]=u,S=n.data.get(s.dataId).values,[I,T,N,C]=c,{batchSize:A,filterDepth:E,filterHeight:_,filterWidth:$,inChannels:R,inDepth:D,inHeight:M,inWidth:F,outChannels:O,outDepth:P,outHeight:L,outWidth:z,strideDepth:B,strideHeight:V,strideWidth:W}=d,U=E-1-d.padInfo.front,j=_-1-d.padInfo.top,G=$-1-d.padInfo.left;for(let H=0;H<A;++H)for(let e=0;e<R;++e)for(let t=0;t<D;++t){let n=t-U,r=Math.max(0,Math.ceil(n/B)),a=Math.min(P,(E+n)/B);for(let s=0;s<M;++s){let i=s-j,o=Math.max(0,Math.ceil(i/V)),l=Math.min(L,(_+i)/V);for(let u=0;u<F;++u){let c=u-G,d=Math.max(0,Math.ceil(c/W)),h=Math.min(z,($+c)/W),A=0;for(let t=r;t<a;++t){let r=t*B-n;for(let n=o;n<l;++n){let a=n*V-i;for(let s=d;s<h;++s){let i=v*H+x*t+w*n+k*s,o=I*(E-1-r)+T*(_-1-a)+N*($-1-(s*W-c))+C*e;for(let e=0;e<O;++e){A+=b[i+e]*S[o+e]}}}}p[f*H+m*t+g*s+y*u+e]=A}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},j6=M3(dE,(e=>Math.cos(e))),G6={kernelName:dE,backendName:"cpu",kernelFunc:j6},H6=M3(hE,(e=>Math.cosh(e))),q6={kernelName:hE,backendName:"cpu",kernelFunc:H6};var K6={kernelName:mE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=a.shape,f=s.shape[0],[m,g]=o,y=JM([f,m,g,p],"float32"),b=n.data.get(s.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,w=iR.computeStrides(a.shape),k=iR.computeStrides(y.shape);for(let S=0;S<f;S++){let e=4*S,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],s=v[S];if(s>=c)continue;let i=m>1?(r-t)*(d-1)/(m-1):0,o=g>1?(a-n)*(h-1)/(g-1):0;for(let c=0;c<m;c++){let e=m>1?t*(d-1)+c*i:.5*(t+r)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){let n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}else if("bilinear"===l){let t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){let l=g>1?n*(h-1)+e*o:.5*(n+a)*(h-1);if(l<0||l>h-1){for(let t=0;t<p;t++){let n=t+e*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}let d=Math.floor(l),f=Math.ceil(l),m=l-d;for(let n=0;n<p;n++){let a=n+d*w[2]+t*w[1]+s*w[0],o=x[a];a=n+f*w[2]+t*w[1]+s*w[0];let l=x[a];a=n+d*w[2]+r*w[1]+s*w[0];let u=x[a];a=n+f*w[2]+r*w[1]+s*w[0];let h=o+(l-o)*m,p=u+(x[a]-u)*m;a=n+e*k[2]+c*k[1]+S*k[0],y.values[a]=h+(p-h)*i}}}else for(let t=0;t<g;++t){let r=g>1?n*(h-1)+t*o:.5*(n+a)*(h-1);if(r<0||r>h-1){for(let e=0;e<p;e++){let n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}let i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++){let n=e+i*w[2]+l*w[1]+s*w[0],r=e+t*k[2]+c*k[1]+S*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};var Y6={kernelName:pE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;s3(a,"cumprod");let l=FW.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=O4({inputs:{x:a},backend:n,attrs:{perm:l}}));let c=FW.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=tD(u.dtype,"int32"),h=iR.makeOnesTypedArray(iR.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)h[t]=i?1:p[t];else{let n=m(y,e-1);h[t]=i?p[n]*h[n]:p[t]*h[n]}}let g=n.makeTensorInfo(u.shape,d,h);if(null!=l){let e=O4({inputs:{x:g},backend:n,attrs:{perm:FW.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};var X6={kernelName:fE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;s3(a,"cumsum");let l=FW.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=O4({inputs:{x:a},backend:n,attrs:{perm:l}}));let c=FW.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=tD(u.dtype,"int32"),h=iR.makeZerosTypedArray(iR.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)h[t]=i?0:p[t];else{let n=m(y,e-1);h[t]=i?p[n]+h[n]:p[t]+h[n]}}let g=n.makeTensorInfo(u.shape,d,h);if(null!=l){let e=O4({inputs:{x:g},backend:n,attrs:{perm:FW.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};var Q6={kernelName:gE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=A3(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){let e=E3(n.bufferSync(a),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};var Z6={kernelName:yE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;iR.assert("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));let o=a.shape[0],l=a.shape[1],u=a.shape[2],c=a.shape[3],d=l*s,h=u*s,p=c/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*d*h*p),g=0;for(let y=0;y<o;++y)for(let e=0;e<d;++e){let t=Math.floor(e/s),n=e%s;for(let e=0;e<h;++e){let r=Math.floor(e/s),a=(n*s+e%s)*p;for(let e=0;e<p;++e){let n=e+a+c*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,d,h,p],a.dtype,m)}};function J6(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;s3([a,s],"depthwiseConv2DNative");let c=iR.computeStrides(a.shape),d=iR.computeStrides(s.shape),h=l;null==h&&(h=[1,1]),iR.assert(FW.eitherStridesOrDilationsAreOne(i,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`));let p=FW.computeConv2DInfo(a.shape,s.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new VR(p.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,T=k.values;for(let N=0;N<p.batchSize;++N){let e=N*c[0],t=N*k.strides[0];for(let n=0;n<p.outHeight;++n){let r=t+n*k.strides[1],a=n*p.strideHeight-x;for(let t=0;t<f;++t){let n=a+t*g;if(n<0||n>=p.inHeight)continue;let s=t*d[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){let t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){let r=n+e*y;if(r<0||r>=p.inWidth)continue;let a=s+e*d[1],o=i+r*p.inChannels,l=t,u=a;for(let e=0;e<p.inChannels;++e){let t=S[o+e];for(let e=0;e<w;++e)T[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var e8={kernelName:bE,backendName:"cpu",kernelFunc:J6};var t8={kernelName:vE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;s3([a,s],"depthwiseConv2dNativeBackpropFilter");let d=FW.computeConv2DInfo(a.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new VR(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,x=n.data.get(a.dataId).values,w=new VR(a.shape,a.dtype,x),k=n.data.get(s.dataId).values,S=new VR(s.shape,s.dtype,k);for(let I=0;I<f;++I){let e=Math.max(0,Math.ceil((b-I)/h)),t=Math.min(d.outHeight,(d.inHeight+b-I)/h);for(let n=0;n<m;++n){let r=Math.max(0,Math.ceil((y-n)/p)),a=Math.min(d.outWidth,(d.inWidth+y-n)/p);for(let s=0;s<d.outChannels;++s){let i=Math.trunc(s/v),o=s%v,l=0;for(let u=0;u<d.batchSize;++u)for(let o=e;o<t;++o){let e=I+o*h-b;for(let t=r;t<a;++t){let r=n+t*p-y;l+=w.get(u,e,r,i)*S.get(u,o,t,s)}}g.set(l,I,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};var n8={kernelName:xE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;s3([a,s],"depthwiseConv2DNativeBackpropInput");let d=iR.computeStrides(a.shape),h=iR.computeStrides(s.shape),p=FW.computeConv2DInfo(c,s.shape,i,o,l,u,!0),f=new VR(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(a.dataId).values,[x,w,k]=d,S=n.data.get(s.dataId).values,[I,T,N]=h,{batchSize:C,filterHeight:A,filterWidth:E,inChannels:_,inHeight:$,inWidth:R,outChannels:D,outHeight:M,outWidth:F,strideHeight:O,strideWidth:P}=p,L=A-1-p.padInfo.top,z=E-1-p.padInfo.left,B=D/_;for(let V=0;V<C;++V)for(let e=0;e<_;++e)for(let t=0;t<$;++t){let n=t-L,r=Math.max(0,Math.ceil(n/O)),a=Math.min(M,(A+n)/O);for(let s=0;s<R;++s){let i=s-z,o=Math.max(0,Math.ceil(i/P)),l=Math.min(F,(E+i)/P),u=0;for(let t=r;t<a;++t){let r=t*O-n;for(let n=o;n<l;++n){let a=x*V+w*t+k*n,s=I*(A-1-r)+T*(E-1-(n*P-i))+N*e;for(let t=0;t<B;++t){u+=v[a+(e*B+t)]*S[s+t]}}}m[g*V+y*t+b*s+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};var r8={kernelName:wE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=iR.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=JM([a,a],r.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*a+u]=s[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},a8={kernelName:kE,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=n,c=u.data.get(a.dataId).values,d=a.shape.length,h=u.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:T,dilationWidth:N,outShape:C}=FW.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),A=iR.sizeFromShape(C),E=C.length,_=iR.getArrayFromDType(a.dtype,A);for(let $=0;$<f;++$)for(let e=0;e<b;++e){let t=e*w-x.top;for(let n=0;n<v;++n){let r=n*k-x.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){let n=t+e*T;if(n>=0&&n<m)for(let t=0;t<I;++t){let l=r+t*N;if(l>=0&&l<g){let r=iR.locToIndex([$,n,l,i],d,iR.computeStrides(a.shape)),u=iR.locToIndex([e,t,i],p,iR.computeStrides(s.shape)),f=c[r]+h[u];f>o&&(o=f)}}}_[iR.locToIndex([$,e,n,i],E,iR.computeStrides(C))]=o}}}return{dataId:u.write(iR.toTypedArray(_,a.dtype),C,a.dtype),shape:C,dtype:a.dtype}}},s8={kernelName:IE,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=iR.toNestedArray(a.shape,c.data.get(a.dataId).values),h=iR.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:T,outShape:N}=FW.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u);iR.assert(i.rank===N.length,(()=>`Error in ${IE}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));let C=iR.toNestedArray(N,c.data.get(i.dataId).values),A=iR.makeZerosNestedTypedArray(s.shape,s.dtype);for(let E=0;E<p;++E)for(let e=0;e<y;++e){let t=e*x-v.top;for(let n=0;n<b;++n){let r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){let n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){let l=r+t*T;if(l>=0&&l<m){let r=d[E][n][l][a]+h[e][t][a];r>s&&(s=r,i=e,o=t)}}}A[i][o][a]+=C[E][e][n][a]}}}return{dataId:c.write(iR.toTypedArray(A,a.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},i8={kernelName:SE,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=iR.toNestedArray(a.shape,c.data.get(a.dataId).values),h=iR.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:T,outShape:N}=FW.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u);iR.assert(i.rank===N.length,(()=>`Error in ${SE}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));let C=iR.toNestedArray(N,c.data.get(i.dataId).values),A=iR.makeZerosNestedTypedArray(a.shape,a.dtype);for(let E=0;E<p;++E)for(let e=0;e<y;++e){let t=e*x-v.top;for(let n=0;n<b;++n){let r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<k;++e){let n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){let l=r+t*T;if(l>=0&&l<m){let r=d[E][n][l][a]+h[e][t][a];r>s&&(s=r,i=n,o=l)}}}A[E][i][o][a]+=C[E][e][n][a]}}}return{dataId:c.write(iR.toTypedArray(A,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};var o8={kernelName:TE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null==l?void 0:l.alpha)||1,c=(null==o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let d=s.getContext(c,(null==o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);let[h,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(p*h*4);for(let v=0;v<h*p;++v){let e=[0,0,0,255*u];for(let n=0;n<f;n++){let t=m[v*f+n];if("float32"===a.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===a.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}let t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}s.width=p,s.height=h;let b=new ImageData(y,p,h);return d.putImageData(b,0,0),a}};function l8(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a;s3(s,"sum"),t="bool"===s.dtype?x3({inputs:{x:s},backend:r,attrs:{dtype:"int32"}}):m3({inputs:{x:s},backend:r});let l=t.shape.length,u=iR.parseAxisParam(i,t.shape),c=FW.getAxesPermutation(u,l),d=u,h=t;null!=c&&(h=O4({inputs:{x:t},backend:r,attrs:{perm:c}}),d=FW.getInnerMostAxes(d.length,l)),FW.assertAxesAreInnerMostDims("sum",d,h.shape.length);let[p,f]=FW.computeOutAndReduceShapes(h.shape,d),m=f3(r,p,FW.upcastType(h.dtype,"int32")),g=iR.sizeFromShape(f),y=r.data.get(m.dataId).values,b=r.data.get(h.dataId).values;for(let v=0;v<y.length;++v){let e=v*g,t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(o){let e=m;m=K5({inputs:{x:m},backend:r,attrs:{shape:FW.expandShapeToKeepDim(m.shape,u)}}),r.disposeIntermediateTensorInfo(e)}return r.disposeIntermediateTensorInfo(t),null!=c&&r.disposeIntermediateTensorInfo(h),m}var u8={kernelName:p$,backendName:"cpu",kernelFunc:l8};var c8={kernelName:CE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=FW.decodeEinsumEquation(a,s.length);FW.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=FW.getEinsumComputePath(o,l),d=c.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let e of c[m]){let t,{permutationIndices:r,expandDims:a}=FW.getEinsumPermutation(p,l[e]);FW.isIdentityPermutation(r)?t=s[e]:(t=O4({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);iR.arraysEqual(t.shape,i)||(t=K5({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===h?h=t:(h=A4({inputs:{a:t,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=l8({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};var d8={kernelName:EE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;s3([r,a],"eluGrad");let s=new Float32Array(iR.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let e=i[l];s[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",s)}},h8=FW.ERF_P,p8=FW.ERF_A1,f8=FW.ERF_A2,m8=FW.ERF_A3,g8=FW.ERF_A4,y8=FW.ERF_A5,b8=M3(_E,(e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+h8*n);return t*(1-((((y8*r+g8)*r+m8)*r+f8)*r+p8)*r*Math.exp(-n*n))})),v8={kernelName:_E,backendName:"cpu",kernelFunc:b8};function x8(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(iR.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),K5({inputs:{x:a},backend:n,attrs:{shape:o}})}var w8={kernelName:DE,backendName:"cpu",kernelFunc:x8},k8=d3(((e,t)=>e/t)),S8=k3(NE,k8),I8={kernelName:NE,backendName:"cpu",kernelFunc:S8};function T8(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],c=iR.sizeFromShape(u),d=iR.getTypedArrayFromDType("float32",c),h=iR.getTypedArrayFromDType("float32",c);for(let g=0;g<a;g++){let e=i5({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=i5({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=h3({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=N8(a,t,n),c=FW.mergeRealAndImagArrays(i,u);for(let t=0;t<s;t++){let e=FW.getComplexWithIndex(c,t);d[g*s+t]=e.real,h[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}let p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=h3({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function N8(e,t,n){let r=iR.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(function(e){return 0===(e&e-1)}(r)){let a=C8(s,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),s=n.makeTensorInfo([],"float32",iR.createScalarValue(r,"float32")),i=m3({inputs:{x:s},backend:n}),l=I8.kernelFunc({inputs:{a:e,b:s},backend:n}),u=I8.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return a}{let e=function(e,t,n){let r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){let o=FW.exponent(a*r,t,n),l=FW.getComplexWithIndex(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),FW.assignToTypedArray(r,s,i,a)}return r}(FW.mergeRealAndImagArrays(s,i),r,t);return FW.splitRealAndImagArrays(e)}}function C8(e,t,n,r,a){if(1===n)return{real:e,imag:t};let s=FW.mergeRealAndImagArrays(e,t),i=n/2,o=FW.complexWithEvenIndex(s),l=o.real,u=o.imag,c=[l.length],d=a.makeTensorInfo(c,"float32",l),h=a.makeTensorInfo(c,"float32",u),p=h3({inputs:{real:d,imag:h},backend:a}),f=FW.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),v=a.makeTensorInfo(y,"float32",g),x=h3({inputs:{real:b,imag:v},backend:a}),w=C8(l,u,i,r,a),k=w.real,S=w.imag,I=[k.length],T=a.makeTensorInfo(I,"float32",k),N=a.makeTensorInfo(I,"float32",S),C=h3({inputs:{real:T,imag:N},backend:a}),A=C8(m,g,i,r,a),E=A.real,_=A.imag,$=[E.length],R=a.makeTensorInfo($,"float32",E),D=a.makeTensorInfo($,"float32",_),M=h3({inputs:{real:R,imag:D},backend:a}),F=FW.exponents(n,r),O=[F.real.length],P=a.makeTensorInfo(O,"float32",F.real),L=a.makeTensorInfo(O,"float32",F.imag),z=h3({inputs:{real:P,imag:L},backend:a}),B=A4({inputs:{a:z,b:M},backend:a}),V=N3({inputs:{a:C,b:B},backend:a}),W=A5({inputs:{a:C,b:B},backend:a}),U=y3({inputs:{input:V},backend:a}),j=y3({inputs:{input:W},backend:a}),G=D6({inputs:{input:V},backend:a}),H=D6({inputs:{input:W},backend:a}),q=F6({inputs:[U,j],backend:a,attrs:{axis:0}}),K=F6({inputs:[G,H],backend:a,attrs:{axis:0}}),Y=a.data.get(q.dataId).values,X=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:Y,imag:X}}var A8={kernelName:FE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=iR.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=K5({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=T8(i,!1,n),l=K5({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function E8(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||iR.inferDtype(a),o=iR.getArrayFromDType(i,iR.sizeFromShape(r));return function(e,t){e.fill(t)}(o,a),t.makeTensorInfo(r,i,o)}var _8={kernelName:OE,backendName:"cpu",kernelFunc:E8};var $8={kernelName:PE,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,s=r,i=iR.getTypedArrayFromDType(a.dtype,iR.sizeFromShape(a.shape)),[o,l,u,c]=a.shape,d=s.data.get(a.dataId).values;for(let h=0;h<o;h++){let e=h*u*l*c;for(let t=0;t<l;t++){let n=t*(u*c);for(let t=0;t<u;t++){let r=t*c;for(let a=0;a<c;a++){let s=Math.round(u-t-1),o=e+n+r+a,l=d[o];if(s>=0&&s<u){l=d[e+n+s*c+a]}i[o]=l}}}}return{dataId:s.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};var R8={kernelName:G$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=P6({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){let e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){let e=K5({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=N3({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=N3({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){let e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){let e=K5({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=q5(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=q5(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};var D8={kernelName:H$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=J6({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){let e=m;m=N3({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){let e=m;m=q5(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};var M8={kernelName:WE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=iR.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,u,c,d]=FW.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);let h=t4(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,o,c,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,h.values)}};var F8={kernelName:VE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;s3([a,s],"gatherV2");let l=iR.parseAxisParam(i,a.shape)[0],u=n.data.get(s.dataId).values,c=a.shape[l];for(let v=0;v<u.length;++v){let e=u[v];iR.assert(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let d=o;null==o&&(d=0);let h=iR.sizeFromShape(s.shape),p=FW.segment_util.collectGatherOpShapeInfo(a,s,l,d),f=K5({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=K5({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=n4(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}};var O8={kernelName:HE,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=iR.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=K5({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=T8(i,!0,n),l=K5({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},P8=M3(KE,(e=>Number.isFinite(e)?1:0),"bool"),L8={kernelName:KE,backendName:"cpu",kernelFunc:P8},z8=M3(YE,(e=>Math.abs(e)===1/0?1:0),"bool"),B8={kernelName:YE,backendName:"cpu",kernelFunc:z8},V8=M3(XE,(e=>Number.isNaN(e)?1:0),"bool"),W8={kernelName:XE,backendName:"cpu",kernelFunc:V8};var U8={kernelName:e_,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=m4(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},j8=M3(n_,(e=>Math.log1p(e))),G8={kernelName:n_,backendName:"cpu",kernelFunc:j8},H8=d3(((e,t)=>e&&t)),q8=k3(r_,H8,null,"bool"),K8={kernelName:r_,backendName:"cpu",kernelFunc:q8},Y8=M3(a_,(e=>e?0:1),"bool"),X8={kernelName:a_,backendName:"cpu",kernelFunc:Y8},Q8=d3(((e,t)=>e||t)),Z8=k3(s_,Q8,null,"bool"),J8={kernelName:s_,backendName:"cpu",kernelFunc:Z8};var e7={kernelName:u_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;s3(a,"LRN");let u=a.shape[3],c=u-1,d=n.data.get(a.dataId).values,h=iR.sizeFromShape(a.shape),p=new Float32Array(h);function f(e){let t=e%u,n=e-t+Math.max(0,t-s),r=e-t+Math.min(t+s,c),a=0;for(;n<=r;n++){let e=d[n];a+=e*e}return a}for(let m=0;m<h;m++){let e=f(m),t=d[m]*Math.pow(i+o*e,-l);p[m]=t}return n.makeTensorInfo(a.shape,a.dtype,p)}};var t7={kernelName:c_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;s3(i,"LRNGrad");let d=iR.sizeFromShape(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){let e=b%h,t=b-e+Math.max(0,e-o),n=b-e+Math.min(h,e+o+1),r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*c*f[a]*m[b]/r;b===a&&(e+=Math.pow(r,-c)),e*=p[b],g[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,g)}};function n7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,u=l.length,c=iR.parseAxisParam(s,l),d=c,h=FW.getAxesPermutation(d,u),p=o.data.get(a.dataId).values;if(null!=h){let e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];p=F4(p,l,a.dtype,h,e),d=FW.getInnerMostAxes(d.length,u),l=e}s3(a,"max"),FW.assertAxesAreInnerMostDims("max",d,u);let[f,m]=FW.computeOutAndReduceShapes(l,d),g=v4(p,iR.sizeFromShape(m),f,a.dtype),y=o.write(g,f,a.dtype),b=f;return i&&(b=FW.expandShapeToKeepDim(f,c)),{dataId:y,shape:b,dtype:a.dtype}}var r7={kernelName:h_,backendName:"cpu",kernelFunc:n7};var a7={kernelName:f_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;s3(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;iR.assert(FW.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u,c=FW.computePool2DInfo(a.shape,s,i,1,o,l);if(1===c.filterWidth&&1===c.filterHeight&&iR.arraysEqual(c.inShape,c.outShape))u=m3({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=iR.computeStrides(a.shape),r=v6(e,a.shape,a.dtype,t,c,"max");u=n.makeTensorInfo(c.outShape,a.dtype,r.values)}return u}};var s7={kernelName:g_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;s3(a,"maxPool3d");let c=FW.computePool3DInfo(a.shape,s,i,1,o,l,u),d=w6(n.data.get(a.dataId).values,a.shape,a.dtype,iR.computeStrides(a.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};var i7={kernelName:y_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;s3([a,s],"maxPool3DGrad");let c=FW.computePool3DInfo(s.shape,i,o,1,l,u),d=function(e,t){let n=JM(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-h,v=b;for(;v<0;)v+=i;let x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){let u=r*a-p,h=u;for(;h<0;)h+=o;let w=Math.min(t.inHeight,c+u);for(let a=0;a<t.outWidth;++a){let p=a*s-f,k=p;for(;k<0;)k+=l;let S=Math.min(t.inWidth,d+p),I=Number.NEGATIVE_INFINITY,T=-1;for(let t=v;t<x;t+=i){let n=t-b;for(let r=h;r<w;r+=o){let a=r-u;for(let s=k;s<S;s+=l){let i=s-p,o=e.get(m,t,r,s,g);o>=I&&(I=o,T=n*c*d+a*c+i)}}}n.set(T,m,y,r,a,g)}}}return n}(n.bufferSync(s),c),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=x-1-c.padInfo.left,S=v-1-c.padInfo.top,I=JM(s.shape,"float32"),T=n.bufferSync(a);for(let N=0;N<c.batchSize;++N)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){let a=t-w,s=n-S,i=r-k,o=0;for(let t=0;t<b;t+=m){let n=(a+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){let a=(s+r)/p;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let s=0;s<x;s+=y){let l=(i+s)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;let u=b*v*x-1-d.get(N,n,a,l,e)===t*v*x+r*x+s?1:0;0!==u&&(o+=T.get(N,n,a,l,e)*u)}}}I.set(o,N,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};var o7={kernelName:m_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;s3([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=FW.computePool2DInfo(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=JM(h.outShape,o.dtype,x6(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,k=v-1-h.padInfo.top,S=JM(o.shape,"float32"),I=n.data.get(a.dataId).values,T=JM(a.shape,"float32",I);for(let N=0;N<h.batchSize;++N)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){let r=t-k,a=n-w,s=0;for(let t=0;t<v;t+=y){let n=(r+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){let i=(a+r)/g;if(i<0||i>=h.outWidth||Math.floor(i)!==i)continue;let o=v*x-1-f.get(N,n,i,e)===t*x+r?1:0;0!==o&&(s+=T.get(N,n,i,e)*o)}}S.set(s,N,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};var l7={kernelName:b_,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;s3(a,"MaxPoolWithArgmax");let c=u.data.get(a.dataId).values,d=FW.computePool2DInfo(a.shape,s,i,[1,1],o),[h,p]=function(e,t,n,r,a){let s=v6(e,0,n,iR.computeStrides(t),a,"max"),i=x6(e,t,n,a,!0,r);return[s.values,i.values]}(c,a.shape,a.dtype,l,d),f=u.write(h,d.outShape,a.dtype),m=u.write(p,d.outShape,a.dtype);return[{dataId:f,shape:d.outShape,dtype:a.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};var u7={kernelName:v_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=iR.parseAxisParam(s,a.shape),l=FW.computeOutAndReduceShapes(a.shape,o)[1],u=iR.sizeFromShape(l),c=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(d);let h=x3({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});c.push(h);let p=S8({inputs:{a:h,b:d},backend:n});c.push(p);let f=l8({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:i}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};var c7={kernelName:x_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;s3(a,"min");let o=iR.parseAxisParam(s,a.shape),l=o,u=FW.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=O4({inputs:{x:a},backend:n,attrs:{perm:u}}),l=FW.getInnerMostAxes(l.length,a.shape.length)),FW.assertAxesAreInnerMostDims("min",l,c.shape.length);let[d,h]=FW.computeOutAndReduceShapes(c.shape,l),p=iR.sizeFromShape(h),f=iR.makeZerosTypedArray(iR.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*p,t=m[e];for(let n=0;n<p;++n){let r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let e=K5({inputs:{x:g},backend:n,attrs:{shape:FW.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};var d7={kernelName:k_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;s3(a,"mirrorPad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),c="reflect"===i?0:1,d=n.data.get(a.dataId).values,h=a.shape.length,p=iR.computeStrides(a.shape),f=iR.sizeFromShape(o),m=o.length,g=iR.computeStrides(o),y=iR.getTypedArrayFromDType(a.dtype,f);for(let b=0;b<f;b++){let e=iR.indexToLoc(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));let t=iR.locToIndex(e,h,p);y[b]=d[t]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}},h7=d3(((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),p7=k3(S_,h7),f7={kernelName:S_,backendName:"cpu",kernelFunc:p7},m7=nC(fC());function g7(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=iR.parseAxisParam([o],a.shape),u=n7({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=FW.expandShapeToKeepDim(u.shape,l),d=K5({inputs:{x:u},backend:n,attrs:{shape:c}}),h=A5({inputs:{a:a,b:d},backend:n}),p=j3({inputs:{x:h},backend:n}),f=l8({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=K5({inputs:{x:f},backend:n,attrs:{shape:c}}),g=S8({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var y7={kernelName:g$,backendName:"cpu",kernelFunc:g7};var b7={kernelName:I_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;s3(a,"multinomial");let l=o?a:g7({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,s],p=iR.makeZerosTypedArray(iR.sizeFromShape(h),"int32");for(let f=0;f<u;++f){let e=f*c,t=new Float32Array(c-1);t[0]=d[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+d[e+a];let n=m7.alea(i.toString()),r=f*s;for(let a=0;a<s;++a){let e=n();p[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+a]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}},v7=VU.nonMaxSuppressionV3Impl;var x7={kernelName:A_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;s3(a,"NonMaxSuppression");let u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d}=v7(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},w7=VU.nonMaxSuppressionV4Impl;var k7={kernelName:E_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;s3(a,"NonMaxSuppressionPadded");let c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=w7(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},S7=VU.nonMaxSuppressionV5Impl;var I7={kernelName:__,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;s3(a,"NonMaxSuppressionWithScore");let c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=S7(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};var T7={kernelName:R_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;s3(a,"oneHot");let u=iR.sizeFromShape(a.shape),c=new Float32Array(u*i);c.fill(l);let d=n.data.get(a.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...a.shape,i],s,c)}};function N7(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){let e=y3({inputs:{input:r},backend:n}),t=N7({inputs:{x:e},backend:n}),a=D6({inputs:{input:r},backend:n}),s=N7({inputs:{x:a},backend:n}),i=h3({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return E8({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var C7={kernelName:B$,backendName:"cpu",kernelFunc:N7};var A7={kernelName:$_,backendName:"cpu",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){let t=y3({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=D6({inputs:{input:a},backend:r}),i=N7({inputs:{x:s},backend:r}),o=h3({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return E8({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function E7(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return x8({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{iR.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),iR.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=x8({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=F6({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}var _7={kernelName:D_,backendName:"cpu",kernelFunc:E7};var $7={kernelName:M_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;s3(a,"pad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,c=iR.sizeFromShape(a.shape),d=a.shape.length,h=iR.computeStrides(a.shape),p=iR.sizeFromShape(o),f=o.length,m=iR.computeStrides(o),g=iR.getTypedArrayFromDType(a.dtype,p);0!==i&&g.fill(i);for(let y=0;y<c;y++){let e=iR.indexToLoc(y,d,h).map(((e,t)=>e+l[t]));g[iR.locToIndex(e,f,m)]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},R7=d3(((e,t)=>Math.pow(e,t))),D7=k3(O_,R7),M7={kernelName:O_,backendName:"cpu",kernelFunc:D7};var F7={kernelName:z_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.data.get(e.dataId).values)),u=a.map((e=>e.shape)),c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=U4(l,u,c,s.shape,s.dtype,d,i.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};var O7={kernelName:B_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=G4(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var P7={kernelName:V_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,h=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=X4(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}};var L7={kernelName:W_,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=Q4(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}},z7=M3(j_,(e=>1/e)),B7={kernelName:j_,backendName:"cpu",kernelFunc:z7};var V7={kernelName:Y_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;s3(a,"resizeBilinear");let l=iR.computeStrides(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(iR.sizeFromShape([d,u,c,f])),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=0,x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<d;k++)for(let e=0;e<u;e++){let t;t=i?x*(e+.5)-.5:x*e;let n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(h-1,Math.ceil(t)),s=k*l[0]+n*l[1],o=k*l[0]+a*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;let n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(p-1,Math.ceil(t)),c=s+n*l[2],d=o+n*l[2],h=s+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){let t=m[c+e],n=m[d+e],s=t+(m[h+e]-t)*a,i=s+(n+(m[y+e]-n)*a-s)*r;g[v++]=i}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}};var W7={kernelName:X_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;s3([s,a],"resizeBilinearGrad");let o=iR.computeStrides(a.shape),[l,u,c,d]=a.shape,[,h,p]=s.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(s.dataId).values,x=0;for(let w=0;w<l;w++){let e=w*o[0];for(let t=0;t<h;t++){let n=t*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=e+r*o[1],i=e+a*o[1],l=n-r,h=1-l;for(let e=0;e<p;e++){let t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),a=t-n,u=1-a,p=s+n*o[2],m=s+r*o[2],g=i+n*o[2],y=i+r*o[2],w=h*u,k=h*a,S=l*u,I=l*a;for(let e=0;e<d;e++){let t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*I}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}};var U7={kernelName:q_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;s3(a,"resizeNearestNeighbor");let l=iR.computeStrides(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(d*u*c*f),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1],w=0;for(let k=0;k<d;k++){let e=k*l[0];for(let t=0;t<u;t++){let n=i?v*(t+.5):v*t,r=Math.min(h-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));let a=e+r*l[1];for(let e=0;e<c;e++){let t=i?x*(e+.5):x*e,n=Math.min(p-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));let r=a+n*l[2];for(let e=0;e<f;e++){let t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([d,u,c,f],a.dtype,g)}};var j7={kernelName:K_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;s3([s,a],"resizeNearestNeighborGrad");let o=iR.computeStrides(a.shape),l=iR.computeStrides(s.shape),[u,c,d,h]=a.shape,[,p,f]=s.shape,m=new Float32Array(u*c*d*h),g=n.data.get(s.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let T=0;T<u;T++){let e=T*o[0];for(let t=0;t<c;t++){let n=e+t*o[1],r=Math.floor(t*w),a=Math.floor(r-S/2);for(let s=0;s<d;s++){let r=n+s*o[2],u=Math.floor(s*k),y=Math.floor(u-I/2);for(let n=0;n<h;n++){let o=0;for(let r=0;r<S;r++){let u=r+a;if(u<0||u>=p)continue;let h=e+u*l[1],m=u*v;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){let t=e+y;if(t<0||t>=f)continue;let r=h+t*l[2],a=t*x;s===Math.min(d-1,i?Math.round(a):Math.floor(a))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}};var G7={kernelName:Z_,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;s3(a,"reverse");let i=a.shape.length,o=iR.parseAxisParam(s,a.shape);if(0===i)return m3({inputs:{x:a},backend:n});let l=new VR(a.shape,a.dtype),u=n.bufferSync(a);for(let c=0;c<l.size;c++){let e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},H7={kernelName:U$,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=iR.getTypedArrayFromDType(a.dtype,iR.sizeFromShape(a.shape)),[c,d,h,p]=a.shape,[f,m]=FW.getImageCenter(o,d,h),g=Math.sin(s),y=Math.cos(s),b=l.data.get(a.dataId).values;for(let v=0;v<c;v++){let e=v*h*d*p;for(let t=0;t<d;t++){let n=t*(h*p);for(let r=0;r<h;r++){let a=r*p;for(let s=0;s<p;s++){let o=[c,t,r,s],l=o[2],v=o[1],x=(l-f)*y-(v-m)*g,w=(l-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=i;if("number"!=typeof i&&(k=3===s?255:i[s]),x>=0&&x<h&&w>=0&&w<d){k=b[e+w*(h*p)+x*p+s]}u[e+n+a+s]=k}}}}return{dataId:l.write(u,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},q7=M3(J_,(e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),K7={kernelName:J_,backendName:"cpu",kernelFunc:q7};var Y7={kernelName:t$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=FW.calculateShapes(s,a,i),h=t5(n.bufferSync(a),n.bufferSync(s),i,d,u,l,o,c,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function X7(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function Q7(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}var Z7={kernelName:r$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=function(e,t,n,r,a,s){let i=iR.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?X7(n,t[e+l]):Q7(n,t[e+l])}return i}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",o)}};var J7={kernelName:a$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;s3([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=tD(a.dtype,s.dtype),d=iR.makeZerosTypedArray(iR.sizeFromShape(a.shape),c),h=0,p=0===i||i>1||1===a.shape.length?1:iR.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(a.shape,c,d)}},e9=FW.SELU_SCALEALPHA,t9=FW.SELU_SCALE,n9=M3(s$,(e=>e>=0?t9*e:e9*(Math.exp(e)-1))),r9={kernelName:s$,backendName:"cpu",kernelFunc:n9},a9=M3(u$,(e=>e<0?-1:e>0?1:0)),s9={kernelName:u$,backendName:"cpu",kernelFunc:a9},i9=M3(o$,(e=>Math.sin(e))),o9={kernelName:o$,backendName:"cpu",kernelFunc:i9},l9=M3(l$,(e=>Math.sinh(e))),u9={kernelName:l$,backendName:"cpu",kernelFunc:l9},c9=Math.log(1.1920928955078125e-7)+2,d9=M3(d$,(e=>{let t,n=e>-c9,r=e<c9,a=Math.exp(e);return t=r?a:n?e:Math.log(1+a),t})),h9={kernelName:d$,backendName:"cpu",kernelFunc:d9};var p9={kernelName:f$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;s3([a],"spaceToBatchND");let o=iR.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=$7.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=FW.getReshaped(u.shape,s,o,!1),d=FW.getPermuted(c.length,s.length,!1),h=FW.getReshapedPermuted(u.shape,s,o,!1),p=K5({inputs:{x:u},backend:n,attrs:{shape:c}}),f=O4({inputs:{x:p},backend:n,attrs:{perm:d}}),m=K5({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};var f9={kernelName:y$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=l5(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var m9={kernelName:b$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,d]=u5(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var g9={kernelName:v$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=c5(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};var y9={kernelName:x$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=c5(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};var b9={kernelName:w$,backendName:"cpu",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{sparseIndices:s,sparseValues:i,defaultValue:o}=n,{outputShape:l}=a,{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=FW.calculateShapes(i,s,l),f=!1,m=r.bufferSync(s);switch(i.dtype){case"bool":t=t5(m,r.bufferSync(i),l,p,d,c,u,h,!!r.data.get(o.dataId).values[0],f);break;case"float32":case"int32":t=t5(m,r.bufferSync(i),l,p,d,c,u,h,r.data.get(o.dataId).values[0],f);break;case"string":t=t5(m,r.bufferSync(i),l,p,d,c,u,h,iR.decodeString(r.data.get(o.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return r.makeTensorInfo(l,t.dtype,t.values)}};var v9={kernelName:m$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=iR.parseAxisParam(i,a.shape)[0],l=FW.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{let t=[...c];t[o]=e;let r=i5({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},x9={kernelName:S$,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e,{x:r}=t,a=n;s3(r,"square");let s=a.data.get(r.dataId).values,i=new Float32Array(s.length);for(let o=0;o<s.length;++o){let e=s[o];i[o]=e*e}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},w9=M3(V$,((e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),k9={kernelName:V$,backendName:"cpu",kernelFunc:w9};var S9={kernelName:T$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;s3(a,"stridedSlice");let p,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=uW.sliceInfo(a.shape,s,i,o,l,u,c,d,h);if(g)p=K5({inputs:{x:a},backend:n,attrs:{shape:m}});else if(y||b){iR.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));let e=uW.computeOutShape(v,x,w),t=i5({inputs:{x:a},backend:n,attrs:{begin:v,size:e}});p=K5({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{let e=x5(f,n.bufferSync(a),w,v);p=n.makeTensorInfo(m,e.dtype,e.values)}return p}};var I9={kernelName:N$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=k5(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var T9={kernelName:C$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=I5(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var N9={kernelName:A$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=T5(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",i)}},C9=M3(_$,(e=>Math.tan(e))),A9={kernelName:_$,backendName:"cpu",kernelFunc:C9},E9=M3($$,(e=>Math.tanh(e)));var _9={kernelName:n$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=FW.calculateShapes(s,a,r.shape),d=n.bufferSync(a),h=n.bufferSync(s),p=n.bufferSync(r),f=t5(d,h,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};var $9={kernelName:R$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;s3(a,"tile");let i=_5(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}};var R9={kernelName:D$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;s3(a,"topk");let o=n.data.get(a.dataId).values,[l,u]=D5(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};var D9={kernelName:M$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=[c,f,m,p],y=iR.computeStrides(a.shape),b=y[0],v=y[1],x=y[2],w=iR.computeStrides(g),k=w[0],S=w[1],I=w[2],T=iR.getTypedArrayFromDType(a.dtype,iR.sizeFromShape(g));T.fill(l);let N=r.data.get(a.dataId).values,C=r.data.get(s.dataId).values;for(let A=0;A<c;++A){let e=1===s.shape[0]?C:C.subarray(8*A,8*A+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let a,s=e[6]*n+e[7]*t+1;if(0===s)continue;let u=(e[0]*n+e[1]*t+e[2])/s,c=(e[3]*n+e[4]*t+e[5])/s,p=M9(u,h,o),f=M9(c,d,o);switch(i){case"nearest":a=O9(N,d,h,b,v,x,A,f,p,r,l);break;case"bilinear":a=P9(N,d,h,b,v,x,A,f,p,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}T[A*k+t*S+n*I+r]=a}return r.makeTensorInfo(g,a.dtype,T)}return{dataId:r.write(T,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function M9(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{let e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return iR.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{let e=t-1;n-=t*Math.trunc(n/e)}return iR.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return iR.clamp(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function F9(e,t,n,r,a,s,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*a+l*s+u]:c}function O9(e,t,n,r,a,s,i,o,l,u,c){return F9(e,t,n,r,a,s,i,Math.round(o),Math.round(l),u,c)}function P9(e,t,n,r,a,s,i,o,l,u,c){let d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1;return(p-o)*((f-l)*F9(e,t,n,r,a,s,i,d,h,u,c)+(l-h)*F9(e,t,n,r,a,s,i,d,f,u,c))+(o-d)*((f-l)*F9(e,t,n,r,a,s,i,p,h,u,c)+(l-h)*F9(e,t,n,r,a,s,i,p,f,u,c))}var L9={kernelName:O$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;s3(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=M5(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};var z9={kernelName:P$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),u=0;for(let p=0;p<i;p++)p!==s&&(l[u++]=a.shape[p]);let c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let h=new Array(o);for(let p=0;p<h.length;p++){c[s]=p;let e=i5({inputs:{x:a},backend:n,attrs:{begin:c,size:d}});h[p]=K5({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return h}};var B9={kernelName:L$,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;s3(a,"unsortedSegmentSum");let o=[],l=[],u=a.shape.length-s.shape.length,c=s;for(let h=0;h<u;++h){let e=x8({inputs:{input:c},backend:n,attrs:{dim:h+1}});c=e,l.push(e)}for(let h=0;h<i;++h){let e=iR.createScalarValue(h,"int32"),t=n.makeTensorInfo([],"int32",e),r=V3({inputs:{a:t,b:c},backend:n}),s=x3({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=A4({inputs:{a:s,b:a},backend:n}),u=l8({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(s),l.push(i),l.push(u)}let d=E7({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},V9=[Z5,c3,e6,n6,C3,r6,a6,s6,i6,o6,u6,d6,p6,g6,b6,k6,S6,I6,T6,Q5,N6,C6,A6,R3,E6,w3,L3,$6,p3,R6,O6,L6,z6,B6,V6,W6,U6,G6,q6,K6,Y6,X6,Q6,Z6,e8,t8,n8,r8,a8,s8,i8,o8,c8,P5,d8,W3,v8,G3,w8,K3,A8,_8,$8,Q3,e4,R8,D8,M8,F8,s4,l4,g3,O8,M6,L8,B8,W8,z5,d4,f4,U8,b4,G8,K8,X8,J8,e7,t7,r7,k4,a7,s7,i7,o7,l7,u7,c7,T4,d7,f7,b7,E4,$4,x7,k7,I7,M4,T7,A7,_7,$7,M7,W5,z4,F7,O7,P7,L7,b3,I8,B7,j5,H5,Y5,V7,W7,U7,j7,G7,H7,K7,e5,Y7,Z7,J7,r9,a5,s9,o9,u9,o5,y7,h9,p9,f9,m9,g9,y9,b9,v9,p5,x9,g5,v5,k9,S9,I9,T9,N9,E5,u8,A9,{kernelName:$$,backendName:"cpu",kernelFunc:E9},_9,$9,R9,D9,P4,L9,z9,B9,C7];for(let n of V9)eR(n);var W9={};tC(W9,{assertNotComplex:()=>Qee,bindCanvasToFramebuffer:()=>Cee,bindColorTextureToFramebuffer:()=>Aee,bindTextureToProgramUniformSampler:()=>Nee,bindTextureUnit:()=>kee,bindVertexBufferToProgramAttribute:()=>wee,callAndCheck:()=>eee,canBeRepresented:()=>ree,createFragmentShader:()=>oee,createFramebuffer:()=>xee,createProgram:()=>hee,createStaticIndexBuffer:()=>gee,createStaticVertexBuffer:()=>mee,createTexture:()=>bee,createVertexShader:()=>iee,getBatchDim:()=>Mee,getExtensionOrThrow:()=>see,getFramebufferErrorMessage:()=>$ee,getMaxTexturesInShader:()=>Uee,getNumChannels:()=>yee,getProgramUniformLocation:()=>Tee,getProgramUniformLocationOrThrow:()=>Iee,getRowsCols:()=>Fee,getShapeAs3D:()=>Oee,getTextureShapeFromLogicalShape:()=>Pee,getWebGLDisjointQueryTimerVersion:()=>jee,getWebGLErrorMessage:()=>aee,getWebGLMaxTextureSize:()=>Bee,hasExtension:()=>Gee,isCapableOfRenderingToFloatTexture:()=>qee,isDownloadFloatTextureEnabled:()=>Kee,isReshapeFree:()=>zee,isWebGLFenceEnabled:()=>Xee,isWebGLVersionEnabled:()=>Hee,linkProgram:()=>pee,logShaderSourceAndInfoLog:()=>dee,resetMaxTextureSize:()=>Vee,resetMaxTexturesInShader:()=>Wee,unbindColorTextureFromFramebuffer:()=>Eee,unbindTextureUnit:()=>See,validateFramebuffer:()=>_ee,validateProgram:()=>fee,validateTextureSize:()=>vee});var U9,j9,G9,H9={},q9={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function K9(e,t){H9[e]=t}function Y9(e,t){if(!(e in H9)||null!=t){let n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=null==t?function(e){if(!IA().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete H9[e]}),!1),IA().getBool("SOFTWARE_WEBGL_ENABLED")&&(q9.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",q9)||n.getContext("experimental-webgl",q9):n.getContext("webgl2",q9)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;H9[e]=n}let n=H9[e];return null==n||n.isContextLost()?(delete H9[e],Y9(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),H9[e])}function X9(e,t){return[t,e]}function Q9(e){let t=iR.sizeFromShape(e),n=Math.ceil(t/4);return iR.sizeToSquarishShape(n)}function Z9(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function J9(e,t){let n,r,a,s,i,o,l,u,c,d,h=e;return 2===IA().getNumber("WEBGL_VERSION")?(n=h.R32F,r=h.R16F,a=h.RGBA16F,s=h.RGBA32F,i=h.RED,l=4,u=1,c=h.HALF_FLOAT,d=h.FLOAT,o=h.RGBA8):(n=e.RGBA,r=e.RGBA,a=e.RGBA,s=h.RGBA,i=e.RGBA,l=4,u=4,c=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,o=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:o,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:c,textureTypeFloat:d}}function eee(e,t){let n=t();return IA().getBool("DEBUG")&&function(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+aee(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(U9||(U9={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(j9||(j9={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(G9||(G9={}));var tee=5.96e-8,nee=65504;function ree(e){return!!(IA().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||tee<Math.abs(e)&&Math.abs(e)<nee)}function aee(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function see(e,t){return Ree(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function iee(e,t){let n=Ree(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(eee(e,(()=>e.shaderSource(n,t))),eee(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function oee(e,t){let n=Ree(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(eee(e,(()=>e.shaderSource(n,t))),eee(e,(()=>e.compileShader(n))),IA().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw dee(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var lee,uee,cee=/ERROR: [0-9]+:([0-9]+):/g;function dee(e,t){let n=cee.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);let r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map(((e,t)=>iR.rightPad((t+1).toString(),s)+e)),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${iR.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function hee(e){return Ree(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function pee(e,t){if(eee(e,(()=>e.linkProgram(t))),!IA().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function fee(e,t){if(eee(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function mee(e,t){let n=Ree(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return eee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),eee(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function gee(e,t){let n=Ree(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return eee(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),eee(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function yee(){return 2===IA().getNumber("WEBGL_VERSION")?1:4}function bee(e){return Ree(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function vee(e,t){let n=IA().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){throw new Error("Requested texture size "+`[${e}x${t}]`+" is invalid.")}if(e>n||t>n){throw new Error("Requested texture size "+`[${e}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}function xee(e){return Ree(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function wee(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return-1!==o&&(eee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),eee(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i))),eee(e,(()=>e.enableVertexAttribArray(o))),!0)}function kee(e,t,n){Dee(e,n),eee(e,(()=>e.activeTexture(e.TEXTURE0+n))),eee(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function See(e,t){Dee(e,t),eee(e,(()=>e.activeTexture(e.TEXTURE0+t))),eee(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Iee(e,t,n){return Ree(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function Tee(e,t,n){return e.getUniformLocation(t,n)}function Nee(e,t,n,r){eee(e,(()=>kee(e,t,r))),eee(e,(()=>e.uniform1i(n,r)))}function Cee(e){eee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),eee(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),eee(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function Aee(e,t,n){eee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),eee(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function Eee(e,t){eee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),eee(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function _ee(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+$ee(e,t))}function $ee(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Ree(e,t,n){let r=eee(e,(()=>t()));if(null==r)throw new Error(n);return r}function Dee(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function Mee(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return iR.sizeFromShape(e.slice(0,e.length-t))}function Fee(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Oee(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[Mee(e),...Fee(e)]),t}function Pee(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=IA().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=IA().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&IA().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?iR.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length&&(e=iR.squeezeShape(e).newShape);let a=iR.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);let i=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){let t=Mee(e),n=2,r=2;e.length&&([n,r]=Fee(e)),a=t*(n/2)*(r/2),s=iR.sizeToSquarishShape(a).map((e=>2*e))}else s=iR.sizeToSquarishShape(a);return s}function Lee(e){return e%2===0}function zee(e,t){if(e=e.slice(-2),t=t.slice(-2),iR.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||Lee(n)&&Lee(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&Lee(e[0])&&Lee(t[0])}function Bee(e){if(null==lee){let t=Y9(e);lee=t.getParameter(t.MAX_TEXTURE_SIZE)}return lee}function Vee(){lee=null}function Wee(){uee=null}function Uee(e){if(null==uee){let t=Y9(e);uee=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,uee)}function jee(e){if(0===e)return 0;let t,n=Y9(e);return t=Gee(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:Gee(n,"EXT_disjoint_timer_query")?1:0,t}function Gee(e,t){return null!=e.getExtension(t)}function Hee(e){try{if(null!=Y9(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function qee(e){if(0===e)return!1;let t=Y9(e);if(1===e){if(!Gee(t,"OES_texture_float"))return!1}else if(!Gee(t,"EXT_color_buffer_float"))return!1;return Yee(t)}function Kee(e){if(0===e)return!1;let t=Y9(e);if(1!==e){if(Gee(t,"EXT_color_buffer_float"))return Yee(t);let e="EXT_color_buffer_half_float";if(Gee(t,e)){let n=t.getExtension(e);return function(e,t){let n=J9(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(a),s}(t,n)}return!1}return!(!Gee(t,"OES_texture_float")||!Gee(t,"WEBGL_color_buffer_float"))&&Yee(t)}function Yee(e){let t=J9(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function Xee(e){return 2===e&&null!=Y9(e).fenceSync}function Qee(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&iR.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var Zee=IA();function Jee(){let e,t,n,r,a,s,i,o,l,u;return 2===IA().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=IA().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function ete(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=iR.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${t}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function tte(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=iR.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / outShapeStrides[${a}]`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function nte(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",r=function(e,t){let n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${r[a]}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}function rte(e){let t=iR.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Zee.registerFlag("HAS_WEBGL",(()=>Zee.getNumber("WEBGL_VERSION")>0)),Zee.registerFlag("WEBGL_VERSION",(()=>Hee(2)?2:Hee(1)?1:0)),Zee.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),Zee.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===Zee.get("WEBGL_VERSION"))),Zee.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),Zee.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),Zee.registerFlag("WEBGL_PACK",(()=>Zee.getBool("HAS_WEBGL"))),Zee.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>Zee.getBool("WEBGL_PACK"))),Zee.registerFlag("WEBGL_PACK_CLIP",(()=>Zee.getBool("WEBGL_PACK"))),Zee.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>Zee.getBool("WEBGL_PACK"))),Zee.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>Zee.getBool("WEBGL_PACK"))),Zee.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>Zee.getBool("WEBGL_PACK"))),Zee.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>Zee.getBool("WEBGL_PACK"))),Zee.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>Zee.getBool("WEBGL_PACK"))),Zee.registerFlag("WEBGL_PACK_REDUCE",(()=>Zee.getBool("WEBGL_PACK"))),Zee.registerFlag("WEBGL_LAZILY_UNPACK",(()=>Zee.getBool("WEBGL_PACK"))),Zee.registerFlag("WEBGL_CONV_IM2COL",(()=>Zee.getBool("WEBGL_PACK"))),Zee.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>Zee.getBool("WEBGL_PACK"))),Zee.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>Bee(Zee.getNumber("WEBGL_VERSION")))),Zee.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>Uee(Zee.getNumber("WEBGL_VERSION")))),Zee.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{let e=Zee.getNumber("WEBGL_VERSION");return 0===e?0:jee(e)})),Zee.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>Zee.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!yD.isMobile())),Zee.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>qee(Zee.getNumber("WEBGL_VERSION")))),Zee.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!Zee.getBool("WEBGL_FORCE_F16_TEXTURES")&&Zee.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),Zee.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>Kee(Zee.getNumber("WEBGL_VERSION")))),Zee.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>Xee(Zee.getNumber("WEBGL_VERSION")))),Zee.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>Zee.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),Zee.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),Zee.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>yD.isMobile()?1:-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),Zee.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),Zee.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),Zee.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),Zee.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),Zee.registerFlag("WEBGL_EXP_CONV",(()=>!1)),Zee.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>Zee.getBool("IS_TEST"))),Zee.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),Zee.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),Zee.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),Zee.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var ate="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:ste}=FW;function ite(e,t,n){let r=[];if(e.forEach((e=>{let t=iR.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){let{uniformShape:t}=yte(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));let a,s,i=r.join("\n"),o=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?lte(e,r):ote(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(a+=n?function(e,t){let n,r=e.name,a=r.charAt(0).toUpperCase()+r.slice(1),s="get"+a+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=ste(e.shapeInfo.logicalShape,t.logicalShape),u=gte(o),c=o-i,d=["x","y","z","w","u","v"];n=0===i?"":o<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${d[e+c]} = 0;`)).join("\n");let h="";h=o<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+c]}`)).join(", ");let p="return outputValue;",f=1===iR.sizeFromShape(e.shapeInfo.logicalShape),m=1===iR.sizeFromShape(t.logicalShape);if(1!==i||f||m){if(f&&!m)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){let e=i-2,t=i-1;l.indexOf(e)>-1&&l.indexOf(t)>-1?p="return vec4(outputValue.x);":l.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${n}\n      vec4 outputValue = get${a}(${h});\n      ${p}\n    }\n  `}(e,t):function(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&iR.arraysEqual(i,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let u,c=gte(l),d=ste(e.shapeInfo.logicalShape,t.logicalShape),h=l-o,p=["x","y","z","w","u","v"];u=0===o?"":l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${p[e+h]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+h]}`)).join(", "),`\n    float ${a}() {\n      ${c} coords = getOutputCoords();\n      ${u}\n      return get${r}(${f});\n    }\n  `}(e,t)),a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),l=t.texShape,u=Jee(),c=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u),d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${ute}\n    ${cte}\n    ${dte}\n  `}(u);return t.isPacked?(a=function(e,t,n){switch(e.length){case 0:return pte();case 1:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(iR.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;let a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,l,n.enableShapeUniforms),s=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(a=function(e,t,n){switch(e.length){case 0:return pte();case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return iR.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${tte(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;let r=ete(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${tte(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let r=ete(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){let n=ete(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){let n=ete(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,l,n.enableShapeUniforms),s=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),n.packedInputs&&(d+=hte),[d,c,s,i,a,o,n.userCode].join("\n")}function ote(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let i=fte(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${mte(e)}\n      }\n    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=fte(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&iR.arraysEqual(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;let e=s[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}let{newShape:i,keptDims:o}=iR.squeezeShape(n),l=i;if(l.length<n.length){let n=["row","col"];return`\n      ${ote(bte(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${vte(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${mte(e)}\n      }\n    `;let u=s[0],c=s[1],d=fte(r);return 1===c?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=iR.squeezeShape(n),u=o;if(u.length<n.length){let n=["row","col","depth"];return`\n        ${ote(bte(e,u),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${vte(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${mte(e)}\n      }\n    `;let c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;let f=fte(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=iR.squeezeShape(n);if(l.length<n.length){let n=["row","col","depth","depth2"];return`\n      ${ote(bte(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${vte(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${mte(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===s&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;let y=fte(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=iR.squeezeShape(t);if(l.length<t.length){let t=["row","col","depth","depth2","depth3"];return`\n      ${ote(bte(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${vte(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${a})) +\n          depth3;\n        ${mte(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let f=fte(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=iR.squeezeShape(t);if(a.length<t.length){let t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${ote(bte(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${vte(t,s)});\n      }\n    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${mte(e)}\n      }\n    `;let d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let m=fte(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function lte(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Jee();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=Jee();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=Jee();if(null!=s&&iR.arraysEqual(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){let r=[1,2],s=["b","row","col"];return`\n        ${lte(bte(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${vte(s,r)});\n        }\n      `}let o=Jee();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;let l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=Jee();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(s[i-1]/2),h=d*Math.ceil(s[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=s[i-m-1],f=`b${m} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}var ute="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",cte="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",dte="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",hte="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function pte(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function fte(e){return`offset${e}`}function mte(e){let t=e.name,n=iR.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function gte(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function yte(e,t,n){let{newShape:r,keptDims:a}=iR.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!iR.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function bte(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function vte(e,t){return t.map((t=>e[t])).join(", ")}function xte(e,t,n){let r,a,s,i=[],o=[],l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===IA().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let d of t.variableNames){let r={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,`${d}Shape`,c),r.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),i.push(r)}if(t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",c),s=e.getUniformLocation(n,"outShapeStrides",c),a=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(let d of t.customUniforms)o.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:i,customUniformLocations:o,infLoc:l,nanLoc:u,outShapeLocation:r,outShapeStridesLocation:s,outTexShapeLocation:a}}function wte(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{let r=e.logicalShape,a=t[n],s=a.shape;if(!iR.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;let i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!iR.arraysEqual(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function kte(e){return IA().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var Ste=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=U9.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Jee();this.outputShape=e,this.enableShapeUniforms=kte(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?tte(["r","c","d"],e):ete(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},Ite=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=U9.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Jee();this.outputShape=e,this.enableShapeUniforms=kte(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?tte(["r","c","d"],e):ete(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},Tte=class{constructor(e){this.variableNames=["A"],this.outTexUsage=j9.DOWNLOAD;let t=Jee();this.outputShape=e,this.userCode=`\n      ${ate}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},Nte=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=j9.DOWNLOAD;let t=Jee();this.outputShape=e,this.userCode=`\n      ${ate}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},Cte={R:0,G:1,B:2,A:3},Ate=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=Jee();this.outputShape=e,this.enableShapeUniforms=kte(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){let e=n[i];s+=`\n          if(offset == ${i}) {\n            result = values[${Cte[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":rte(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${s}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}},Ete=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Jee();this.outputShape=e,this.enableShapeUniforms=kte(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){let a=2*s+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":rte(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}},_te={};function $te(e){let t=Jee();return iee(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function Rte(e){return mee(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function Dte(e){return gee(e,new Uint16Array([0,1,2,2,1,3]))}function Mte(e,t,n,r,a,s){vee(t,n);let i=bee(e),o=e.TEXTURE_2D;return eee(e,(()=>e.bindTexture(o,i))),eee(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),eee(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),eee(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),eee(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===IA().getNumber("WEBGL_VERSION")?eee(e,(()=>e.texImage2D(o,0,r,t,n,0,a,s,null))):eee(e,(()=>e.texStorage2D(o,1,r,t,n))),eee(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function Fte(e){return e.internalFormatFloat}function Ote(e,t,n,r){let[a,s]=X9(t,n);return Mte(e,a,s,Fte(r),r.textureFormatFloat,e.FLOAT)}function Pte(e){return e.internalFormatHalfFloat}function Lte(e,t,n,r){let[a,s]=X9(t,n);return Mte(e,a,s,Pte(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function zte(e){return e.downloadTextureFormat}function Bte(e,t,n,r){let[a,s]=X9(t,n);return Mte(e,a,s,zte(r),e.RGBA,e.UNSIGNED_BYTE)}function Vte(e){return e.internalFormatPackedFloat}function Wte(e,t,n,r){let[a,s]=Z9(t,n);return Mte(e,a,s,Vte(r),e.RGBA,e.FLOAT)}function Ute(e){return e.internalFormatPackedHalfFloat}function jte(e,t,n,r){let[a,s]=Z9(t,n);return Mte(e,a,s,Ute(r),e.RGBA,r.textureTypeHalfFloat)}function Gte(e,t,n){return eee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),wee(e,t,"clipSpacePos",n,3,20,0)&&wee(e,t,"uv",n,2,20,12)}function Hte(e,t,n,r,a,s){let i,o,l;eee(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===IA().getNumber("WEBGL_VERSION")?eee(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):eee(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),eee(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function qte(e,t,n){eee(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===IA().getNumber("WEBGL_VERSION")?eee(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):eee(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===IA().getNumber("WEBGL_VERSION")?eee(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):eee(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),eee(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Kte(e,t,n,r){let a=e.createBuffer();eee(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));let s=16*t*n;return eee(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),eee(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),eee(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}function Yte(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function Xte(e,t,n,r){let[a,s]=X9(t,n),i=new Uint8Array(function(e,t){return e*t}(t*n,4));return eee(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}function Qte(e,t,n,r,a,s,i,o){let l=e,u=new Float32Array(function(e,t){let[n,r]=Z9(e,t);return n*r*4}(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function Zte(e,t,n){let r=new Float32Array(t*n*4);return eee(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}tC(_te,{bindVertexProgramAttributeStreams:()=>Gte,createBufferFromOutputTexture:()=>Kte,createFloat16MatrixTexture:()=>Lte,createFloat16PackedMatrixTexture:()=>jte,createFloat32MatrixTexture:()=>Ote,createIndexBuffer:()=>Dte,createPackedMatrixTexture:()=>Wte,createUnsignedBytesMatrixTexture:()=>Bte,createVertexBuffer:()=>Rte,createVertexShader:()=>$te,downloadByteEncodedFloatMatrixFromOutputTexture:()=>Xte,downloadFloat32MatrixFromBuffer:()=>Yte,downloadMatrixFromPackedOutputTexture:()=>Zte,downloadPackedMatrixFromBuffer:()=>Qte,getInternalFormatForFloat16MatrixTexture:()=>Pte,getInternalFormatForFloat16PackedMatrixTexture:()=>Ute,getInternalFormatForFloat32MatrixTexture:()=>Fte,getInternalFormatForPackedMatrixTexture:()=>Vte,getInternalFormatForUnsignedBytesMatrixTexture:()=>zte,uploadDenseMatrixToTexture:()=>Hte,uploadPixelDataToTexture:()=>qte});var Jte=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=IA().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,K9(t,e)):this.gl=Y9(t),e=this.gl,2===IA().getNumber("WEBGL_VERSION")){let t=e;this.createVertexArray=()=>eee(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>eee(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>eee(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>eee(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){let t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>eee(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>eee(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>eee(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>eee(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===IA().getNumber("WEBGL_VERSION")){let e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=see(this.gl,e),Gee(this.gl,t))this.textureHalfFloatExtension=see(this.gl,t);else if(IA().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Gee(this.gl,r))this.colorBufferHalfFloatExtension=see(this.gl,r);else if(IA().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Gee(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Gee(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=Rte(this.gl),this.indexBuffer=Dte(this.gl),this.framebuffer=xee(this.gl),this.textureConfig=J9(this.gl,this.textureHalfFloatExtension)}get debug(){return IA().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;eee(e,(()=>e.finish())),eee(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),eee(e,(()=>e.deleteFramebuffer(this.framebuffer))),eee(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),eee(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),eee(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Ote(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Lte(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Bte(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),qte(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),Hte(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),jte(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Wte(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Eee(this.gl,this.framebuffer),this.outputTexture=null),eee(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>Xte(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return Qte(this.gl,e,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Yte(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=Kte(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(IA().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>Zte(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=$te(t));let n=hee(t);eee(t,(()=>t.attachShader(n,this.vertexShader))),eee(t,(()=>t.attachShader(n,e))),pee(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&fee(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;eee(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),Gte(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(eee(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&fee(this.gl,this.program),eee(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?Iee(this.gl,e,t):Tee(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),eee(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),Nee(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=Z9(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&fee(this.gl,this.program),_ee(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}eee(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),eee(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=see(this.gl,2===IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await iR.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){let e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in IA().platform&&(n=IA().platform.setTimeoutCustom.bind(IA().platform)),iR.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Aee(this.gl,e,this.framebuffer),this.debug&&_ee(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Aee(this.gl,this.outputTexture,this.framebuffer),this.debug&&_ee(this.gl)):Eee(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;Aee(r,e,this.framebuffer),this.debug&&_ee(r),this.outputTexture=e,eee(r,(()=>r.viewport(0,0,t,n))),eee(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),eee(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}};var{addImpl:ene,bincountImpl:tne,bincountReduceImpl:nne,bitwiseAndImpl:rne,castImpl:ane,ceilImpl:sne,concatImpl:ine,equalImpl:one,expImpl:lne,expm1Impl:une,floorImpl:cne,gatherNdImpl:dne,gatherV2Impl:hne,greaterImpl:pne,greaterEqualImpl:fne,lessImpl:mne,lessEqualImpl:gne,linSpaceImpl:yne,logImpl:bne,maxImpl:vne,maximumImpl:xne,minimumImpl:wne,multiplyImpl:kne,negImpl:Sne,notEqualImpl:Ine,prodImpl:Tne,raggedGatherImpl:Nne,raggedRangeImpl:Cne,raggedTensorToTensorImpl:Ane,rangeImpl:Ene,rsqrtImpl:_ne,scatterImpl:$ne,sigmoidImpl:Rne,simpleAbsImpl:Dne,sliceImpl:Mne,sparseFillEmptyRowsImpl:Fne,sparseReshapeImpl:One,sparseSegmentReductionImpl:Pne,sqrtImpl:Lne,staticRegexReplaceImpl:zne,stridedSliceImpl:Bne,stringNGramsImpl:Vne,stringSplitImpl:Wne,stringToHashBucketFastImpl:Une,subImpl:jne,tileImpl:Gne,topKImpl:Hne,transposeImpl:qne,uniqueImpl:Kne}=l3;function Yne(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function Xne(e,t){return 1===t?[e]:Yne(e,t)}var Qne=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=kte(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{let e=Xne("rc",this.rank),t=gte(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}},Zne=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=kte(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2===1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${function(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?nte(["r","c","d"],"inputShape"):ete(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":rte(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};var Jne=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=tre(t,n),a=nre(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s,i=ere(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}return r===G9.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===G9.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===G9.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===G9.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===G9.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(s),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),s}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;let a=tre(n,r),s=nre(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=ere(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=IA().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(let e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function ere(e,t,n,r,a){let s,i=function(e,t){switch(e){case G9.PACKED_2X2_FLOAT32:return Vte(t);case G9.PACKED_2X2_FLOAT16:return Ute(t);case G9.UNPACKED_FLOAT32:return Fte(t);case G9.UNPACKED_FLOAT16:return Pte(t);case G9.PACKED_4X1_UNSIGNED_BYTE:return zte(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);if(a){let[t,n]=Z9(e[0],e[1]);s=t*n}else{let[t,n]=X9(e[0],e[1]);s=t*n}let o=function(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,i);return s*o}function tre(e,t){if(e===j9.UPLOAD)return G9.PACKED_2X2_FLOAT32;if(e===j9.RENDER||null==e)return function(e){return IA().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?G9.PACKED_2X2_FLOAT32:G9.UNPACKED_FLOAT32:e?G9.PACKED_2X2_FLOAT16:G9.UNPACKED_FLOAT16}(t);if(e===j9.DOWNLOAD||e===j9.PIXELS)return G9.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function nre(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var rre=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=kte(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},are="if (isnan(x)) return x;",sre="return x;",ire="return abs(x);",ore="return (x >= 0.0) ? x : (exp(x) - 1.0);",lre=are+"\n  return (x < 0.0) ? 0.0 : x;\n",ure=are+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",cre="return x;",dre="return 1.0 / (1.0 + exp(-1.0 * x));",hre="return x;",pre="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",fre="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",mre="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",gre="return 1.0 / (1.0 + exp(-1.0 * x));",yre=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=kte(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},bre=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=kte(this.outputShape.length);let t=e.length,n=Xne("rc",t),r=gte(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}},vre=VU.whereImpl,xre={};var wre=IA().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");var kre=class e extends TC{nextDataId(){return e.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!IA().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof Jte)t=e;else{let n=Y9(IA().getNumber("WEBGL_VERSION"),e);t=new Jte(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=Y9(IA().getNumber("WEBGL_VERSION"));t=new Jte(e),this.binaryCache=function(e){return e in xre||(xre[e]={}),xre[e]}(IA().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Jne(this.gpgpu),this.numMBBeforeWarning=null==IA().global.screen?1024:IA().global.screen.height*IA().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new IC(this,zD())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,s){let i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];let l=Oee(t),u=new Ate(l,!1,s),c=this.runWebGLProgram(u,[i],n,[[r,a]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((IA().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||IA().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:j9.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if(IA().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:j9.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new yre(i,cre):new rre(i,cre);let n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;let l,u,c=null!=this.activeTimers;if(c&&(l=iR.now()),"complex64"===r){let e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);u=FW.mergeRealAndImagArrays(e,t)}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=iR.now()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}let t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=a){let t;t=o?new yre(r,cre):new rre(r,cre);let n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(IA().getBool("DEBUG")&&!IA().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===IA().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==s&&IA().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);let t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...Q9(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){let e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),t=e[0],n=e[1];u=FW.mergeRealAndImagArrays(t,n)}else if(null==c)u=this.getValuesFromTexture(e);else{let e=iR.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){let e=this.gpgpu.gl;eee(e,(()=>e.deleteBuffer(c)))}let d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&zD().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new yre(a,cre):new rre(a,cre);let r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(e,t.customTexShape),c=zD().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>iR.decodeString(e)));return JM(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return JM(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let n=e[t];if(!ree(n))throw IA().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=iR.sizeFromShape(t);if(IA().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...Q9(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}let s=IA().getBool("WEBGL_PACK")&&!0===r,i=s?Oee(t):t,o=s?new Nte(i):new Tte(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let a=iR.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=iR.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(a);i.kernelMs=iR.sum(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:iR.now(),endMs:null}}endTimer(e){return IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=iR.now(),e)}async getQueryTime(e){if(IA().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:wre;return IA().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&iR.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){FW.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return vre(e.shape,t)}packedUnaryOp(e,t,n){let r=new yre(e.shape,t),a=this.compileAndRun(r,[e],n);return zD().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=Dne(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(IA().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ire,e.dtype);let t=new rre(e.shape,ire),n=this.compileAndRun(t,[e]);return zD().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&iR.isString(n[0])){let a=n.map((e=>iR.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return zD().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new bre(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new Qne(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let n=[Mee(e.shape),...Fee(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[Mee(t),...Fee(t)],s=new Zne(a,n),i=[n],o=this.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){let e=iR.sizeFromShape(a),n=t[0]*t[1]*4;iR.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}let i,o=Oee(a);i=r?new Ite(o):new Ste(o);let l=[null!=t?t:Q9(o)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0,i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===U9.DENSE){let t=null!=s?s:Q9(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===iR.sizeFromShape(i.shape))return o.values=iR.getTypedArrayFromDType(i.dtype,0),i;let l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&iR.sizeFromShape(t.shape)<=IA().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!zee(n.shape,t.shape)){let e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);let c,d={shape:i.shape,texData:o,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach((t=>{let a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=yte(e.packedInputs,t.shape,s),u="",c="",d="";if(1===o.length&&e.packedInputs){let e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){let e=iR.computeStrides(o);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;let h=t.shape.length,p=2===o.length&&iR.arraysEqual(t.shape,s),f=1===iR.sizeFromShape(t.shape),m=FW.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&iR.arraysEqual(s,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${h}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${d}_${y}_${a}`}else{let e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${IA().getNumber("WEBGL_VERSION")}`,s}(e,u,d),p=this.getAndSaveBinary(h,(()=>function(e,t,n,r){let a=n.map(((e,n)=>{let r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=ite(a,i,t),l=oee(e.gl,o),u=e.createProgram(l);return IA().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},xte(e,t,u)))}(this.gpgpu,e,u,d))),f=null!=this.activeTimers;f&&(c=this.startTimer()),IA().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(wte(t.inShapeInfos,n),wte([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===IA().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let r=n[l],{uniform:a,offset:s,shape:i,texShape:o}=t.variablesLocations[l];if(i){let{uniformShape:n}=yte(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=a){if(r.isUniform){if(iR.sizeFromShape(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}continue}null!=r.texData.slice&&null!=s&&e.gl.uniform1i(s,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){let n=iR.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){let n=t.program.customUniforms[l],r=t.customUniformLocations[l],s=a[l];if("float"===n.type)e.gl.uniform1fv(r,s);else if("vec2"===n.type)e.gl.uniform2fv(r,s);else if("vec3"===n.type)e.gl.uniform3fv(r,s);else if("vec4"===n.type)e.gl.uniform4fv(r,s);else if("int"===n.type)e.gl.uniform1iv(r,s);else if("ivec2"===n.type)e.gl.uniform2iv(r,s);else if("ivec3"===n.type)e.gl.uniform3iv(r,s);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,s)}}e.executeProgram()}(this.gpgpu,p,u,d,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),f&&(c=this.endTimer(c),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(c)}));let m=IA().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){let e=iR.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!IA().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){let e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(IA().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=WD((()=>{if(!IA().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=IA().getBool("DEBUG");IA().set("DEBUG",!1);let t=this.abs(qO(1e-8)).dataSync()[0];if(IA().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;let l,u=null!=this.activeTimers;u&&(l=iR.now());let c=t.texShape;if(null==c&&(c=Pee(n,o),t.texShape=c),null!=a){let e,s=Oee(n),i=c[1],d=c[0],h=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(o||!h)&&([i,d]=Z9(c[0],c[1])),e=o?new Ete(s,h):new Ate(s,h);let p=h?[d,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=h?j9.PIXELS:j9.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,a);let g=[[d,i]],y=this.runWebGLProgram(e,[f],r,g,!0),b=this.texData.get(y.dataId);t.texShape=b.texShape,t.isPacked=b.isPacked,t.usage=b.usage,IA().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=b.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=iR.now()-l)}else{let e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*iR.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await DW(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(dee(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=xte(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:r,height:a,width:s,channels:i}=e,o=zD().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=o.writeTexture(r,t,n,a,s,i);return zD().makeTensorFromDataId(l,t,n,o)}};kre.nextDataId=0;var Sre="4.16.0";function Ire(){IA().set("WEBGL_FORCE_F16_TEXTURES",!0)}yD.isBrowser()&&ZD("webgl",(()=>new kre),2);var Tre={forceHalfFloat:Ire},Nre="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",Cre=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=FW.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=kte(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},Are="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",Ere=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=FW.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=kte(a);let s="";if(r)if(0===a||1===iR.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${gte(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let e=Xne("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}};function _re(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var $re={kernelName:GE,backendName:"webgl",kernelFunc:_re};function Rre(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=_re({inputs:{x:r},backend:n}),l=_re({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var Dre={kernelName:nE,backendName:"webgl",kernelFunc:Rre},Mre="return (a < 0.) ? b * a : a;",Fre="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var Ore={kernelName:QE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",iR.createScalarValue(s,"float32")),o=IA().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ere(Fre,a.shape,i.shape):new Cre(Mre,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},Pre="return (a < 0.) ? b * a : a;",Lre="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var zre={kernelName:P_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=IA().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ere(Lre,r.shape,a.shape):new Cre(Pre,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},Bre="if (isnan(x)) return x;";function Vre(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=e;return e=>{let s,{inputs:i,backend:o}=e,{x:l}=i,u=o,c=a||l.dtype;if(u.shouldExecuteOnCPU([l])&&null!=r){let e=u.texData.get(l.dataId),t=r(e.values,c);return u.makeTensorInfo(l.shape,c,t)}return s=IA().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new yre(l.shape,n):new rre(l.shape,t),u.runWebGLProgram(s,[l],c)}}function Wre(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:s,dtype:i}=e;return e=>{let{inputs:o,backend:l}=e,{a:u,b:c}=o,d=l;if(a&&"complex64"===u.dtype){let e=d.texData.get(u.dataId),n=d.texData.get(c.dataId),[r,a]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{let[n,r]=e,a={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:r.dataId,dtype:r.dtype,shape:c.shape},i=new Cre(t,u.shape,c.shape);return d.runWebGLProgram(i,[a,s],tD(n.dtype,r.dtype))})),s=Rre({inputs:{real:r,imag:a},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(a),s}let h,p=i||tD(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=s){let e=d.texData.get(u.dataId).values,t=d.texData.get(c.dataId).values,n="string"===u.dtype?FW.fromUint8ToStringArray(e):e,r="string"===u.dtype?FW.fromUint8ToStringArray(t):t,[a,i]=s(u.shape,c.shape,n,r,p),o=d.makeTensorInfo(i,p);return d.texData.get(o.dataId).values=a,o}return h=IA().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new Ere(n,u.shape,c.shape,r):new Cre(t,u.shape,c.shape),d.runWebGLProgram(h,[u,c],p)}}function Ure(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?hre:sre;if("relu"===e)return t?fre:lre;if("elu"===e)return t?pre:ore;if("relu6"===e)return t?mre:ure;if("prelu"===e)return t?Lre:Pre;if("leakyrelu"===e)return t?Fre:Mre;if("sigmoid"===e)return t?gre:dre;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var jre=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=kte(this.outputShape.length);let u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},Gre={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},Hre=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=FW.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},qre="return a * b;";function Kre(e){let t,{inputs:n,backend:r}=e,{a:a,b:s}=n,i=FW.upcastType(a.dtype,s.dtype);if("complex64"===a.dtype){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),n=new Hre(Gre.REAL,a.shape,s.shape),i=new Hre(Gre.IMAG,a.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=r.runWebGLProgram(n,o,"float32"),u=r.runWebGLProgram(i,o,"float32"),c=Rre({inputs:{real:l,imag:u},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(u),c}if(r.shouldExecuteOnCPU([a,s])){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),[n,o]=kne(a.shape,s.shape,e.values,t.values,i),l=r.makeTensorInfo(o,i);return r.texData.get(l.dataId).values=n,l}return t=IA().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ere(qre,a.shape,s.shape):new Cre(qre,a.shape,s.shape),r.runWebGLProgram(t,[a,s],i)}var Yre={kernelName:T_,backendName:"webgl",kernelFunc:Kre};function Xre(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=iR.sizeFromShape(a.shape),l=iR.inferFromImplicitShape(s,o),u=iR.sizeFromShape(l);iR.assert(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));let c=i.texData.get(a.dataId);return!c.isPacked||zee(a.shape,l)||null!==c.texture&&zee(c.shape,l)?(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){let r=[Mee(e.shape),...Fee(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[Mee(t),...Fee(t)],i=new Zne(s,r),o=[r],l=n.runWebGLProgram(i,[a],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(a,l,i)}var Qre={kernelName:H_,backendName:"webgl",kernelFunc:Xre},Zre=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=4*Math.floor(n/4),o=n%4,l="sumValue += dot(values, ones);";if(null!=t){let e=1/t;l=`sumValue += dot(values * ${iR.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},Jre=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");let u=4*Math.floor(n/4),c=n%4,d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function eae(e,t,n,r){let a=function(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],r=FW.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape),s=e;for(let i=0;i<a.length;i++){let o,l,{inSize:u,windowSize:c,outSize:d}=a[i];o="mean"===n?0===i?new Zre({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:d},u):new Zre({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:d}):new Jre({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:d},n),l=s,s=r.runWebGLProgram(o,[s],t),l.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(l)}return s}var tae=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let r=gte(this.rank),a=function(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}};var nae=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=gte(this.rank),a=Yne("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function rae(e,t,n){let r=IA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new nae(e.shape,t):new tae(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function aae(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return function(e,t,n,r){let a=t,s=e.shape.length,i=iR.parseAxisParam(a,e.shape),o=i,l=FW.getAxesPermutation(o,s),u=null!=l,c=e;u&&(c=rae(e,l,r),o=FW.getInnerMostAxes(o.length,s)),FW.assertAxesAreInnerMostDims("sum",o,s);let[d,h]=FW.computeOutAndReduceShapes(c.shape,o),p=d;n&&(p=FW.expandShapeToKeepDim(d,i));let f=iR.sizeFromShape(h),m=Xre({inputs:{x:c},attrs:{shape:[iR.sizeFromShape(e.shape)/f,f]},backend:r}),g=eae(m,nD(e.dtype),"sum",r),y=Xre({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),y}(a,s,i,n)}var sae={kernelName:p$,backendName:"webgl",kernelFunc:aae};function iae(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{perm:i}=a,o=r,l=s.shape.length,u=new Array(l);for(let c=0;c<u.length;c++)u[c]=s.shape[i[c]];if(o.shouldExecuteOnCPU([s])){let e=o.texData.get(s.dataId).values,n=qne(e,s.shape,s.dtype,i,u);t=o.makeTensorInfo(u,s.dtype),o.texData.get(t.dataId).values=n}else t=rae(s,i,o);return t}var oae={kernelName:F$,backendName:"webgl",kernelFunc:iae},lae=1e3;function uae(e){let{a:t,b:n,transposeA:r,transposeB:a,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e,c=t.shape.length,d=n.shape.length,h=r?t.shape[c-2]:t.shape[c-1],p=a?n.shape[d-1]:n.shape[d-2],f=r?t.shape[c-1]:t.shape[c-2],m=a?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=iR.sizeFromShape(g),v=iR.sizeFromShape(y),x=SO.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);iR.assert(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${a} must match.`));let w,k=r?[b,h,f]:[b,f,h],S=a?[v,m,p]:[v,p,m],I=Xre({inputs:{x:t},backend:s,attrs:{shape:k}}),T=Xre({inputs:{x:n},backend:s,attrs:{shape:S}}),N=[I,T],C=Math.max(b,v),A=r?I.shape[1]:I.shape[2],E=null!=i,_=null!=o,$="leakyrelu"===u,R=null!=u?Ure(u,!0):null;if((1===f||1===m)&&A>lae&&!1===(E||_||$||null!=R)){let e=I,t=T;r&&(e=iae({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(e)),a&&(t=iae({inputs:{x:T},backend:s,attrs:{perm:[0,2,1]}}),N.push(t));let n=1===m,i=e;1!==m&&(i=Xre({inputs:{x:e},backend:s,attrs:{shape:[C,A,1]}}),N.push(i));let o=1===m?2:1,l=t;n&&(l=Xre({inputs:{x:t},backend:s,attrs:{shape:[C,1,A]}}),N.push(l));let u=Kre({inputs:{a:i,b:l},backend:s});w=aae({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),N.push(u)}else{let e=tD(t.dtype,n.dtype),u=new jre(k,S,[C,f,m],r,a,E,R,_,$),c=[I,T];if(null!=i&&c.push(i),_&&c.push(o),$){let e=s.makeTensorInfo([],"float32",iR.createScalarValue(l,"float32"));c.push(e),N.push(e)}w=s.runWebGLProgram(u,c,e)}let D=Xre({inputs:{x:w},backend:s,attrs:{shape:x}});N.push(w);for(let M of N)s.disposeIntermediateTensorInfo(M);return D}var cae={kernelName:j$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return uae({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},dae="return abs(x);";var hae={kernelName:EA,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=r.texData.get(a.dataId),t=Dne(e.values);return r.makeTensorInfo(a.shape,a.dtype,t)}return t=IA().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new yre(a.shape,dae):new rre(a.shape,dae),r.runWebGLProgram(t,[a],a.dtype)}},pae=Vre({opSnippet:are+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),fae={kernelName:_A,backendName:"webgl",kernelFunc:pae},mae=Vre({opSnippet:are+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),gae={kernelName:$A,backendName:"webgl",kernelFunc:mae},yae="return a + b;",bae=Wre({opSnippet:yae,packedOpSnippet:yae,supportsComplex:!0,cpuKernelImpl:ene}),vae={kernelName:RA,backendName:"webgl",kernelFunc:bae},xae=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}},wae=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}};var kae={kernelName:DA,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,a=n;if(1===a.length)return _re({inputs:{x:a[0]},backend:r});if(a.length>IA().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),s=e({inputs:a.slice(t),backend:r});return e({inputs:[n,s],backend:r})}let s=a.map((e=>e.dtype)).reduce(((e,t)=>tD(e,t))),i=a.map((e=>e.shape)),o=IA().getBool("WEBGL_PACK")?new wae(a[0].shape,i):new xae(a[0].shape,i);return r.runWebGLProgram(o,a,s)}};var Sae={kernelName:MA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=iR.parseAxisParam(s,a.shape),u=l,c=FW.getAxesPermutation(u,o),d=a;null!=c&&(d=iae({inputs:{x:a},backend:n,attrs:{perm:c}}),u=FW.getInnerMostAxes(u.length,o)),FW.assertAxesAreInnerMostDims("all",u,o);let h,[p,f]=FW.computeOutAndReduceShapes(d.shape,u),m=Xre({inputs:{x:d},backend:n,attrs:{shape:[-1,iR.sizeFromShape(f)]}}),g=eae(m,m.dtype,"all",n);if(i){h=Xre({inputs:{x:g},backend:n,attrs:{shape:FW.expandShapeToKeepDim(p,l)}})}else h=Xre({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),h}};var Iae={kernelName:FA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=iR.parseAxisParam(s,a.shape),u=l,c=FW.getAxesPermutation(u,o),d=a;null!=c&&(d=iae({inputs:{x:a},backend:n,attrs:{perm:c}}),u=FW.getInnerMostAxes(u.length,o)),FW.assertAxesAreInnerMostDims("any",u,o);let h,[p,f]=FW.computeOutAndReduceShapes(d.shape,u),m=Xre({inputs:{x:d},backend:n,attrs:{shape:[-1,iR.sizeFromShape(f)]}}),g=eae(m,m.dtype,"any",n);if(i){h=Xre({inputs:{x:g},backend:n,attrs:{shape:FW.expandShapeToKeepDim(p,l)}})}else h=Xre({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),h}},Tae=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},Nae=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,iR.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i,o,l=this.outputShape,u=l.length,c=gte(u),d=Xne("coords",u);if(1===s){o=u+1;let e=gte(o);i=`\n        ${e} sourceLocR = ${e}(${d.join()}, 0);\n        ++${d[u-1]};\n        ${e} sourceLocG = ${e}(${d.join()}, 0);\n        ++${d[u-2]};\n        ${e} sourceLocA = ${e}(${d.join()}, 0);\n        --${d[u-1]};\n        ${e} sourceLocB = ${e}(${d.join()}, 0);\n        --${d[u-2]};`}else o=u,i=`\n        ${c} sourceLocR = coords;\n        ++${d[u-1]};\n        ${c} sourceLocG = coords;\n        ++${d[u-2]};\n        ${c} sourceLocA = coords;\n        --${d[u-1]};\n        ${c} sourceLocB = coords;\n        --${d[u-2]};`;let h=["x","y","z","w","u","v"].slice(0,o),p="."+h[o-1],f=h.map((e=>"int "+e)),m=Xne("sourceLocR",o-1).concat("inIdx.r"),g=Xne("sourceLocG",o-1).concat("inIdx.g"),y=Xne("sourceLocB",o-1).concat("inIdx.b"),b=Xne("sourceLocA",o-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${d[u-1]} < ${l[u-1]-1};\n        bool hasNextRow = ${d[u-2]} < ${l[u-2]-1};\n        ${i}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function Cae(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);let i=FW.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new Tae(o,n,null==r),u=[t];null!=r&&u.push(r);let c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;let d=Cae(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function Aae(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=null!=r?r.shape:t.shape,s=a[a.length-1],i=FW.computeOptimalWindowSize(s),o=new Nae(a,i,n,null==r),l=null==r?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let r=Aae(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function Eae(e,t,n,r){let a=[n];if(FW.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!IA().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let n=[],s=e.texData.get(t.dataId),i=t;null!==s&&s.isPacked&&(i=e.unpackTensor(t),n.push(i));let[o,l]=FW.computeOutAndReduceShapes(i.shape,a),u=iR.sizeFromShape(l),c=Xre({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);let d=Cae(e,c,r);n.push(d);let h=Xre({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return Aae(e,t,r)}var _ae={kernelName:OA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=iR.parseAxisParam(s,a.shape),o=FW.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=iae({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=FW.getInnerMostAxes(i.length,l.shape.length)),FW.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=Eae(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};var $ae={kernelName:PA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=iR.parseAxisParam(s,a.shape),o=FW.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=iae({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=FW.getInnerMostAxes(i.length,l.shape.length)),FW.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=Eae(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},Rae=Vre({opSnippet:are+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Dae={kernelName:LA,backendName:"webgl",kernelFunc:Rae},Mae=Vre({opSnippet:are+"return log(x + sqrt(x * x + 1.0));"}),Fae={kernelName:zA,backendName:"webgl",kernelFunc:Mae},Oae=Vre({opSnippet:are+"\n  return atan(x);\n"}),Pae={kernelName:BA,backendName:"webgl",kernelFunc:Oae},Lae=Wre({opSnippet:Nre+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Are+"\n  return result;\n"}),zae={kernelName:WA,backendName:"webgl",kernelFunc:Lae},Bae=Vre({opSnippet:are+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Vae={kernelName:VA,backendName:"webgl",kernelFunc:Bae},Wae=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");let v=4*Math.floor(s/4),x=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}},Uae=class{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b="avg"===t,v="0.0";if(b||(v="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");let w=4*Math.floor(s/4),k=s%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}};var jae={kernelName:UA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Qee(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;iR.assert(FW.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u=FW.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&iR.arraysEqual(u.inShape,u.outShape))return _re({inputs:{x:a},backend:n});let c=new Wae(u,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}};var Gae={kernelName:GA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=FW.computePool3DInfo(a.shape,s,i,[1,1,1],o,l,u),d=new Uae(c,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}},Hae=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},qae=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var Kae={kernelName:HA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=FW.computePool3DInfo(i.shape,o,l,[1,1,1],u,c),h=new qae(d);return n.runWebGLProgram(h,[a],i.dtype)}};var Yae={kernelName:jA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;Qee([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=FW.computePool2DInfo(i.shape,o,l,1,u),d=new Hae(c);return n.runWebGLProgram(d,[a],i.dtype)}};var Xae={kernelName:qA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;return uae({a:a,b:s,transposeA:i,transposeB:o,backend:n})}},Qae=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],FW.assertAndGetBroadcastShape(e,t),FW.assertAndGetBroadcastShape(e,n);let i="0.0";null!=r&&(FW.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(FW.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},Zae=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],FW.assertAndGetBroadcastShape(e,t),FW.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";null!=r&&(FW.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(FW.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},Jae={kernelName:BE,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,mean:s,variance:i,offset:o,scale:l}=t;iR.assert(s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),iR.assert(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),iR.assert(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=r;null==u&&(u=.001);let c=[a,s,i],d=null;null!=o&&(d=o.shape,c.push(o));let h=null;null!=l&&(h=l.shape,c.push(l));let p=IA().getBool("WEBGL_PACK_NORMALIZATION")?new Zae(a.shape,s.shape,i.shape,d,h,u):new Qae(a.shape,s.shape,i.shape,d,h,u);return n.runWebGLProgram(p,c,c[0].dtype)}},ese=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=gte(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return tse.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);n=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${tse[t]} = start[${t}] + coords.${tse[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${n}\n        setOutput(getSource(${r}));\n      }\n    `}},tse=["x","y","z","w","u","v"];var nse=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=gte(this.rank),n=Xne("coords",this.rank),r=Xne("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}};function rse(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=uW.parseSliceParams(a,s,i);if(uW.assertParamsValid(a,o,l),0===iR.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){let e=n.texData.get(a.dataId),t=Mne(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}let{isPacked:u}=n.texData.get(a.dataId),c=uW.isSliceContinous(a.shape,o,l);if(u||!c){let e=IA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new nse(l):new ese(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=uW.computeFlatOffset(t,iR.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}(a,o,l,n)}var ase={kernelName:i$,backendName:"webgl",kernelFunc:rse},sse={kernelName:KA,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;iR.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=FW.getReshaped(a.shape,s,o),u=FW.getPermuted(l.length,s.length),c=FW.getReshapedPermuted(a.shape,s,o),d=FW.getSliceBeginCoords(i,s.length),h=FW.getSliceSize(c,i,s.length),p=[],f=Xre({inputs:{x:a},backend:n,attrs:{shape:l}}),m=iae({inputs:{x:f},backend:n,attrs:{perm:u}}),g=Xre({inputs:{x:m},backend:n,attrs:{shape:c}}),y=rse({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};var ise={kernelName:YA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=tne(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}};var ose={kernelName:XA,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{a:a,b:s}=n,i=IA().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=IA().getNumber("WEBGL_VERSION");if(r.shouldExecuteOnCPU([a,s])||1===o){let e=r.texData.get(a.dataId).values,t=r.texData.get(s.dataId).values,[n,i]=rne(a.shape,s.shape,e,t,a.dtype),o=r.makeTensorInfo(i,a.dtype);return r.texData.get(o.dataId).values=n,o}return t=i?new Ere("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,s.shape,!1):new Cre("\n  return float(int(a.r) & int(b.r));\n",a.shape,s.shape),r.runWebGLProgram(t,[a,s],a.dtype)}};var lse={kernelName:ZA,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=FW.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},use=Wre({opSnippet:"return float(a != b);",cpuKernelImpl:Ine,dtype:"bool"}),cse={kernelName:C_,backendName:"webgl",kernelFunc:use};function dse(e){let{inputs:t,backend:n}=e,{input:r}=t;return _re({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}var hse={kernelName:U_,backendName:"webgl",kernelFunc:dse},pse="return float(int(x));";var fse={kernelName:JA,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:i}=a;if("complex64"===i){if("complex64"===s.dtype)return _re({inputs:{x:s},backend:r});let t=GP(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=Rre({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){let t=dse({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!iR.hasEncodingLoss(s.dtype,i)){let e=_re({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([s])){let e=r.texData.get(s.dataId).values,[t,n,a]=ane(e,s.shape,s.dtype,i);return r.makeTensorInfo(t,n,a)}if("int32"===i)return function(e,t){let n=new rre(e.shape,pse),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===i){let e=r.makeTensorInfo([],"bool",iR.getTypedArrayFromDType("bool",1)),t=use({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},mse="return ceil(x);",gse=Vre({opSnippet:mse,packedOpSnippet:mse,cpuKernelImpl:sne}),yse={kernelName:eE,backendName:"webgl",kernelFunc:gse},bse=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}},vse=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}};var xse={kernelName:tE,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{clipValueMin:i,clipValueMax:o}=a;t=IA().getBool("WEBGL_PACK_CLIP")?new vse(s.shape):new bse(s.shape);let l=[[i],[o]];return r.runWebGLProgram(t,[s],s.dtype,l)}},wse=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}};function kse(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}var Sse={kernelName:rE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new wse(r.shape),i=[kse(r,a.complexTensorInfos.real),kse(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}},Ise=class{constructor(e){this.outputShape=[],this.outputShape=FW.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let e=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${e}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}},Tse=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=FW.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=gte(r),s=Xne("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],u=i.slice(-2),c=i.join(),d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){let e=o[f-1];d+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${Nse(i,l,e)}),\n            vec2(${Nse(u,l,e)}));\n        }`}let h=o.length,p=o[o.length-1];d+=`\n        return getChannel(\n          getT${h}(${Nse(i,l,p)}),\n          vec2(${Nse(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}};function Nse(e,t,n){let r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function Cse(e){let{inputs:t,backend:n}=e,{input:r}=t;return _re({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}var Ase={kernelName:qE,backendName:"webgl",kernelFunc:Cse};function Ese(e,t,n){let r=e[0].dtype;if("complex64"===r){let r=e.map((e=>dse({inputs:{input:e},backend:n}))),a=e.map((e=>Cse({inputs:{input:e},backend:n}))),s=Ese(r,t,n),i=Ese(a,t,n),o=Rre({inputs:{real:s,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){let a=e.map((e=>{let r=[-1,iR.sizeFromShape(e.shape.slice(t))];return Xre({inputs:{x:e},backend:n,attrs:{shape:r}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=FW.computeOutShape(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=ine(s,i,r,o),u=FW.computeOutShape(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}let s=e.filter((e=>iR.sizeFromShape(e.shape)>0)),i=IA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){let t=i?new rre(e[0].shape,cre):new yre(e[0].shape,cre);return n.runWebGLProgram(t,e,r)}let o=IA().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let e=[];for(let a=0;a<s.length;a+=o){let r=s.slice(a,a+o);e.push(Ese(r,t,n))}let r=Ese(e,t,n);for(let t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){let e=new Tse(s.map((e=>e.shape)),t);return n.runWebGLProgram(e,s,r)}let{tensors2D:l,outShape:u}=function(e,t,n){let r=FW.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>Xre({inputs:{x:e},attrs:{shape:[-1,iR.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}(s,t,n),c=new Ise(l.map((e=>e.shape))),d=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));let h=Xre({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function _se(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=iR.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));FW.assertParamsConsistent(i,s);let o=FW.computeOutShape(t.map((e=>e.shape)),s);if(0===iR.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter((e=>iR.sizeFromShape(e.shape)>0));return 1===l.length?_re({inputs:{x:l[0]},backend:n}):Ese(l,s,n)}var $se={kernelName:aE,backendName:"webgl",kernelFunc:_se},Rse=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1,v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}},Dse=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Mse=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=kte(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u,d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)d+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){let t=2*m;if(d+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,d+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){let e=s%2===0?iR.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,d+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):d+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(d+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(d+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(d+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}},Fse=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=kte(this.outputShape.length);let{dataFormat:n}=t,r=Jee(),a="channelsLast"===n,s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}};function Ose(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Pse(e){let t,{x:n,filter:r,convInfo:a,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e,c=n.shape,d=s.texData.get(n.dataId),h=a.inChannels,p=c[0]*c[1]*c[2],f=a.outChannels,m="channelsLast"===a.dataFormat,g=!1,y=[];if(null!=o){let e=Ose(o.shape,m);null!=e&&(o=Xre({inputs:{x:o},backend:s,attrs:{shape:e}}),y.push(o))}if(null!=i){let e=Ose(i.shape,m);null!=e&&(i=Xre({inputs:{x:i},backend:s,attrs:{shape:e}}),y.push(i))}if((1!==p&&1!==f||!(h>lae))&&d.isPacked&&m&&null!=d.texture&&c[2]%2!==0&&iR.arraysEqual(d.shape.slice(-3),c.slice(-3))){let e=c[0]*c[1]*(c[2]+1),h={dataId:n.dataId,shape:[1,e,a.inChannels],dtype:n.dtype},p=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,iR.assert(zee(d.shape,h.shape),(()=>`packed reshape ${d.shape} to ${h.shape} isn't free`));let f=Xre({inputs:{x:r},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}});y.push(f);let m=uae({a:h,b:f,backend:s,transposeA:false,transposeB:g,bias:i,activation:u,preluActivationWeights:o,leakyreluAlpha:l}),b=s.texData.get(m.dataId);iR.assert(b.isPacked,(()=>"batchMatMul result is expected to be packed")),d.shape=p,b.shape=a.outShape,t=_re({inputs:{x:m},backend:s}),t.shape=a.outShape,y.push(m)}else{let e=a.outHeight*a.outWidth,c=Xre({inputs:{x:n},backend:s,attrs:{shape:m?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),d=Xre({inputs:{x:r},backend:s,attrs:{shape:[1,a.inChannels,a.outChannels]}}),h=uae({a:m?c:d,b:m?d:c,transposeA:!m,transposeB:g,backend:s,bias:i,activation:u,preluActivationWeights:o,leakyreluAlpha:l});t=Xre({inputs:{x:h},backend:s,attrs:{shape:a.outShape}}),y.push(c),y.push(d),y.push(h)}for(let b of y)s.disposeIntermediateTensorInfo(b);return t}function Lse(e){let{x:t,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e,{filterWidth:u,filterHeight:c,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=u*c*d,y=p*h,b=[r.batchSize,g,y],v=[];if(null!=i){let e=Ose(i.shape,m);null!=e&&(i=Xre({inputs:{x:i},backend:a,attrs:{shape:e}}),v.push(i))}if(null!=s){let e=Ose(s.shape,m);null!=e&&(s=Xre({inputs:{x:s},backend:a,attrs:{shape:e}}),v.push(s))}let x=Xre({inputs:{x:n},backend:a,attrs:{shape:[1,g,iR.sizeFromShape(n.shape)/g]}});v.push(x);let w=new Fse(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(w,[t],"float32",k),I=Xre({inputs:{x:S},backend:a,attrs:{shape:b}});v.push(S),v.push(I);let T=null!=s,N=null!=i,C="leakyrelu"===l,A=l?Ure(l,!0):null,E=new jre(m?I.shape:x.shape,m?x.shape:I.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,T,A,N,C),_=m?[I,x]:[x,I];if(s&&_.push(s),N&&_.push(i),C){let e=a.makeTensorInfo([],"float32",iR.createScalarValue(o,"float32"));_.push(e),v.push(e)}let $=a.runWebGLProgram(E,_,"float32"),R=Xre({inputs:{x:$},backend:a,attrs:{shape:r.outShape}});v.push($);for(let D of v)a.disposeIntermediateTensorInfo(D);return R}var zse={kernelName:sE,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:d}=a,h=FW.convertConv2DDataFormat(u),p=FW.computeConv2DInfo(s.shape,i.shape,o,c,l,d,!1,h);if(1!==p.filterHeight||1!==p.filterWidth||1!==p.dilationHeight||1!==p.dilationWidth||1!==p.strideHeight||1!==p.strideWidth||"SAME"!==p.padInfo.type&&"VALID"!==p.padInfo.type)if(p.strideWidth<=2&&"channelsLast"===h&&IA().getBool("WEBGL_EXP_CONV")){let e=new Mse(p),n=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];t=r.runWebGLProgram(e,[s,i],"float32",n)}else if(IA().getBool("WEBGL_CONV_IM2COL"))t=Lse({x:s,filter:i,convInfo:p,backend:r});else{let e=new Rse(p);t=r.runWebGLProgram(e,[s,i],"float32")}else t=Pse({x:s,filter:i,convInfo:p,backend:r});let f=Xre({inputs:{x:t},backend:r,attrs:{shape:p.outShape}});return r.disposeIntermediateTensorInfo(t),f}},Bse=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Vse=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Wse=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},Use=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var jse={kernelName:iE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=FW.convertConv2DDataFormat(l),h=FW.computeConv2DInfo(a.shape,c,i,1,o,u,!1,d),p=new Bse(h);return n.runWebGLProgram(p,[a,s],"float32")}},Gse=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=kte(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}};var Hse={kernelName:oE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=FW.convertConv2DDataFormat(u),h=FW.computeConv2DInfo(i,s.shape,o,1,l,c,!1,d);if(IA().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){let e=[[h.strideHeight,h.strideWidth]],t=new Gse(h);return n.runWebGLProgram(t,[a,s],"float32",e)}{let e=new Vse(h);return n.runWebGLProgram(e,[a,s],"float32")}}};var qse={kernelName:lE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=FW.computeConv3DInfo(a.shape,s.shape,i,l,o),c=new Dse(u);return n.runWebGLProgram(c,[a,s],"float32")}};var Kse={kernelName:uE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=FW.computeConv3DInfo(a.shape,l,i,1,o),c=new Wse(u);return n.runWebGLProgram(c,[a,s],"float32")}};var Yse,Xse={kernelName:cE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=FW.computeConv3DInfo(l,s.shape,o,1,i),c=new Use(u);return n.runWebGLProgram(c,[a,s],"float32")}},Qse=Vre({opSnippet:Bre+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${Are}\n  return result;\n`}),Zse={kernelName:dE,backendName:"webgl",kernelFunc:Qse},Jse=Vre({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),eie={kernelName:hE,backendName:"webgl",kernelFunc:Jse},tie=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];let h="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,x]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},nie={kernelName:mE,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new tie(a.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[a,s,i],"float32")}};!function(e){e.Prod="*",e.Sum="+"}(Yse||(Yse={}));var rie=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===Yse.Prod?"1.0":"0.0",i=n?s:`getX(${aie(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${gte(a)} coords = getOutputCoords();\n        int end = ${sie(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${sie(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${aie(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function aie(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function sie(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function iie(e,t,n,r,a,s){let i=t.shape.length,o=FW.getAxesPermutation([r],i),l=t;null!=o&&(l=iae({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=FW.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let c=l.shape[u],d=_re({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){let t=new rie(e,l.shape,!1,s),r=[[h]],a=d;d=n.runWebGLProgram(t,[d],d.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){let t=new rie(e,l.shape,a,s),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){let e=iae({inputs:{x:d},backend:n,attrs:{perm:FW.getUndoAxesPermutation(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}var oie={kernelName:pE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return iie(Yse.Prod,a,n,s,i,o)}};var lie={kernelName:fE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return iie(Yse.Sum,a,n,s,i,o)}};var uie={kernelName:gE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=tne(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(s),r=nne(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},cie=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};var die={kernelName:yE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,c=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d=new cie("NHWC"===i?[o,l,u,c]:[o,c,l,u],s,i);return n.runWebGLProgram(d,[a],a.dtype)}},hie=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=kte(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}},pie=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=kte(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c,h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)h+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){let e=2*g;if(h+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,h+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){let t=i%2===0?iR.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,h+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):h+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(h+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(h+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(h+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}};var fie={kernelName:bE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r,c=l;null==c&&(c=[1,1]),iR.assert(FW.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));let d,h=FW.computeConv2DInfo(a.shape,s.shape,i,c,o,u,!0);d=IA().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new pie(h):new hie(h);let p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[a,s],"float32",p)}},mie=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},gie=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var yie={kernelName:vE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=FW.computeConv2DInfo(a.shape,c,i,o,l,u,!0),h=new mie(d);return n.runWebGLProgram(h,[a,s],"float32")}};var bie={kernelName:xE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=FW.computeConv2DInfo(c,s.shape,i,o,l,u,!0),h=new gie(d);return n.runWebGLProgram(h,[a,s],"float32")}},vie=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}};var xie={kernelName:wE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=iR.sizeFromShape(r.shape),i=Xre({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new vie(s),l=n.runWebGLProgram(o,[i],i.dtype),u=Xre({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}},wie=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}};var kie={kernelName:kE,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dilations:u}=a,c=FW.computeDilation2DInfo(s.shape,i.shape,o,l,"NHWC",u),d=new wie(c);t=r.runWebGLProgram(d,[s,i],"float32");let h=Xre({inputs:{x:t},backend:r,attrs:{shape:c.outShape}});return r.disposeIntermediateTensorInfo(t),h}};var Sie={kernelName:CE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=FW.decodeEinsumEquation(a,s.length);FW.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=FW.getEinsumComputePath(o,l),d=c.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let e of c[m]){let t,{permutationIndices:r,expandDims:a}=FW.getEinsumPermutation(p,l[e]);FW.isIdentityPermutation(r)?t=s[e]:(t=iae({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);iR.arraysEqual(t.shape,i)||(t=Xre({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===h?h=t:(h=Kre({inputs:{a:t,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=aae({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},Iie=Vre({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),Tie={kernelName:AE,backendName:"webgl",kernelFunc:Iie},Nie={kernelName:EE,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=IA().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ere("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new Cre("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},Cie=Wre({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:one}),Aie={kernelName:$E,backendName:"webgl",kernelFunc:Cie},Eie=Vre({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${FW.ERF_P};\n  float a1 = ${FW.ERF_A1};\n  float a2 = ${FW.ERF_A2};\n  float a3 = ${FW.ERF_A3};\n  float a4 = ${FW.ERF_A4};\n  float a5 = ${FW.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),_ie={kernelName:_E,backendName:"webgl",kernelFunc:Eie},$ie=Vre({opSnippet:Bre+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:lne,dtype:"float32"}),Rie={kernelName:RE,backendName:"webgl",kernelFunc:$ie};function Die(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(iR.assert(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),Xre({inputs:{x:s},backend:r,attrs:{shape:o}})}var Mie={kernelName:DE,backendName:"webgl",kernelFunc:Die},Fie="return exp(x) - 1.0;",Oie=Vre({opSnippet:Fie,packedOpSnippet:Fie,cpuKernelImpl:une}),Pie={kernelName:ME,backendName:"webgl",kernelFunc:Oie},Lie=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a,s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${r}.0`:"1.0";if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function zie(e,t,n){let r=n.texData.get(e.dataId),a=iR.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=Xre({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),o=i.shape,l=new Lie("real",o,t),u=new Lie("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(l,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),p=Rre({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);let f=Xre({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}var Bie={kernelName:FE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return zie(r,!1,n)}},Vie=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};function Wie(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||iR.inferDtype(a),"string"===s){let e=iR.getArrayFromDType(s,iR.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{let e=new Vie(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}var Uie,jie={kernelName:OE,backendName:"webgl",kernelFunc:Wie},Gie=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},Hie={kernelName:PE,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{image:r}=t,a=n,s=new Gie(r.shape);return a.runWebGLProgram(s,[r],r.dtype)}},qie="return floor(x);",Kie=Vre({opSnippet:qie,packedOpSnippet:qie,cpuKernelImpl:cne}),Yie={kernelName:LE,backendName:"webgl",kernelFunc:Kie},Xie=Wre({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Qie={kernelName:zE,backendName:"webgl",kernelFunc:Xie},Zie=class{constructor(e){this.variableNames=["A"];let t=Jee(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},Jie=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=Jee(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},eoe={kernelName:W$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],c=[u,l],d=[u,l,s];if(o||i){let e=IA().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Uie||e!==toe)&&(toe=e,Uie=document.createElement("canvas").getContext("2d",{willReadFrequently:toe})),Uie.canvas.width=l,Uie.canvas.height=u,Uie.drawImage(a,0,0,l,u),a=Uie.canvas}let h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=j9.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);let p=IA().getBool("WEBGL_PACK")?new Jie(d):new Zie(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}},toe=IA().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");var noe={kernelName:G$,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=n,{strides:u,pad:c,dataFormat:d,dilations:h,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=a,g=FW.convertConv2DDataFormat(d),y=FW.computeConv2DInfo(s.shape,i.shape,u,h,c,p,!1,g),b=[],v=null!=o,x=null!=l,w="leakyrelu"===f,k=()=>{let e=[s,i],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=Xre({inputs:{x:e},backend:r,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(o,d)),x&&e.push(t(l,d)),w){let t=r.makeTensorInfo([],"float32",iR.createScalarValue(m,"float32"));e.push(t),b.push(t)}return e};if(1!==y.filterHeight||1!==y.filterWidth||1!==y.dilationHeight||1!==y.dilationWidth||1!==y.strideHeight||1!==y.strideWidth||"SAME"!==y.padInfo.type&&"VALID"!==y.padInfo.type)if(y.strideWidth<=2&&"channelsLast"===g&&IA().getBool("WEBGL_EXP_CONV")){let e=f?Ure(f,!0):null,n=new Mse(y,v,e,x,w),a=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],s=k();t=r.runWebGLProgram(n,s,"float32",a)}else if(IA().getBool("WEBGL_CONV_IM2COL"))t=Lse({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{let e=f?Ure(f,!1):null,n=new Rse(y,v,e,x,w),a=k();t=r.runWebGLProgram(n,a,"float32")}else t=Pse({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});let S=Xre({inputs:{x:t},backend:r,attrs:{shape:y.outShape}});return b.push(t),b.forEach((e=>r.disposeIntermediateTensorInfo(e))),S}};var roe={kernelName:H$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[],m=c;null==m&&(m=[1,1]),iR.assert(FW.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));let g,y=FW.computeConv2DInfo(a.shape,s.shape,l,m,u,d,!0),b=IA().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,v=h?Ure(h,b):null,x=[a,s],w=null!=i,k=null!=o,S="leakyrelu"===h;if(w&&x.push(i),k&&x.push(o),S){let e=n.makeTensorInfo([],"float32",iR.createScalarValue(p,"float32"));x.push(e),f.push(e)}g=b?new pie(y,w,v,k,S):new hie(y,w,v,k,S);let I=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],T=n.runWebGLProgram(g,x,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),T}},aoe=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=gte(n.length),s="\n    int index;";for(let i=0;i<this.sliceDim;i++)s+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}};var soe={kernelName:WE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=iR.sizeFromShape(r.shape),[l,u,c,d]=FW.prepareAndValidate(r,a),h=Xre({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),p=Xre({inputs:{x:r},backend:n,attrs:{shape:[iR.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){let e=n.readSync(a.dataId),t=n.bufferSync(r),s=dne(e,t,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}let f=new aoe(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=Xre({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}},ioe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=gte(this.rank),r=function(e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}};function ooe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=iR.parseAxisParam(i,a.shape)[0];if(IA().get("DEBUG")){let e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){let r=e[n];iR.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}let u=FW.segment_util.collectGatherOpShapeInfo(a,s,l,o),c=iR.sizeFromShape(s.shape),d=[],h=Xre({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=Xre({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);let f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){let e=n.bufferSync(p),t=n.bufferSync(h),r=hne(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}let m=new ioe(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);let y=Xre({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}var loe={kernelName:VE,backendName:"webgl",kernelFunc:ooe},uoe=Wre({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:pne,dtype:"bool"}),coe={kernelName:UE,backendName:"webgl",kernelFunc:uoe},doe=Wre({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:fne}),hoe={kernelName:jE,backendName:"webgl",kernelFunc:doe};var poe={kernelName:HE,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return zie(r,!0,n)}},foe=Vre({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),moe={kernelName:KE,backendName:"webgl",kernelFunc:foe},goe=Vre({opSnippet:"return float(isinf(x));",dtype:"bool"}),yoe={kernelName:YE,backendName:"webgl",kernelFunc:goe},boe=Vre({opSnippet:"return float(isnan(x));",dtype:"bool"}),voe={kernelName:XE,backendName:"webgl",kernelFunc:boe},xoe=Wre({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:mne,dtype:"bool"}),woe={kernelName:ZE,backendName:"webgl",kernelFunc:xoe},koe=Wre({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:gne,dtype:"bool"}),Soe={kernelName:JE,backendName:"webgl",kernelFunc:koe};var Ioe={kernelName:e_,backendName:"webgl",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=yne(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},Toe=Vre({opSnippet:Bre+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:bne}),Noe={kernelName:t_,backendName:"webgl",kernelFunc:Toe},Coe=Vre({opSnippet:Bre+"\n  return log(1.0 + x);\n"}),Aoe={kernelName:n_,backendName:"webgl",kernelFunc:Coe},Eoe=Wre({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),_oe={kernelName:r_,backendName:"webgl",kernelFunc:Eoe},$oe=Vre({opSnippet:"return float(!(x >= 1.0));"}),Roe={kernelName:a_,backendName:"webgl",kernelFunc:$oe},Doe=Wre({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Moe={kernelName:s_,backendName:"webgl",kernelFunc:Doe},Foe=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}},Ooe=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}},Poe={kernelName:u_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=IA().getBool("WEBGL_PACK_NORMALIZATION")?new Ooe(a.shape,s,i,o,l):new Foe(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)}},Loe=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},zoe={kernelName:c_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new Loe(a.shape,o,l,u,c);return n.runWebGLProgram(d,[a,s,i],a.dtype)}};function Boe(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=iR.parseAxisParam(s,a.shape),u=l,c=FW.getAxesPermutation(u,o),d=null!=c,h=n.shouldExecuteOnCPU([a]),p=a;if(d){if(h){let e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=a.shape[c[n]];let r=qne(e,a.shape,a.dtype,c,t);p=n.makeTensorInfo(t,a.dtype),n.texData.get(p.dataId).values=r}else p=rae(a,c,n);u=FW.getInnerMostAxes(u.length,o)}FW.assertAxesAreInnerMostDims("max",u,o);let f,[m,g]=FW.computeOutAndReduceShapes(p.shape,u),y=m;if(i&&(y=FW.expandShapeToKeepDim(m,l)),h){let e=n.texData.get(p.dataId).values,t=vne(e,iR.sizeFromShape(g),y,a.dtype);f=n.makeTensorInfo(y,a.dtype),n.texData.get(f.dataId).values=t}else f=function(e,t,n,r){let a=iR.sizeFromShape(t),s=Xre({inputs:{x:e},attrs:{shape:[iR.sizeFromShape(e.shape)/a,a]},backend:r}),i=eae(s,e.dtype,"max",r),o=Xre({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(p,g,y,n);return d&&n.disposeIntermediateTensorInfo(p),f}var Voe={kernelName:h_,backendName:"webgl",kernelFunc:Boe},Woe=Wre({opSnippet:Nre+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Are+"\n  return result;\n",cpuKernelImpl:xne}),Uoe={kernelName:p_,backendName:"webgl",kernelFunc:Woe};var joe={kernelName:f_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;Qee(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;iR.assert(FW.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));let u=FW.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&iR.arraysEqual(u.inShape,u.outShape))return _re({inputs:{x:a},backend:n});let c=new Wae(u,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}};var Goe={kernelName:g_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=FW.computePool3DInfo(a.shape,s,i,[1,1,1],o,u,l),d=new Uae(c,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}},Hoe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},qoe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};var Koe={kernelName:y_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=FW.computePool3DInfo(i.shape,o,l,[1,1,1],u,c),h=new Uae(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new qoe(d),m=n.runWebGLProgram(f,[a,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};var Yoe={kernelName:m_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;Qee([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=FW.computePool2DInfo(o.shape,l,u,1,c,d),p=new Wae(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new Hoe(h),g=n.runWebGLProgram(m,[a,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};var Xoe={kernelName:b_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;iR.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));let c=[1,1];iR.assert(FW.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));let d=FW.computePool2DInfo(a.shape,s,i,c,o),[h,p]=function(e,t,n,r){let a=new Wae(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");return a=new Wae(n,"max",!0,!0,t),[s,r.runWebGLProgram(a,[e],"float32")]}(a,l,d,u);return[h,p]}};var Qoe={kernelName:v_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{keepDims:s,axis:i}=n,o=r,l=a.shape.length,u=iR.parseAxisParam(i,a.shape),c=u,d=FW.getAxesPermutation(c,l),h=null!=d,p=o.shouldExecuteOnCPU([a]),f=[],m=a;if(h){if(p){let e=o.texData.get(m.dataId).values,t=new Array(l);for(let r=0;r<t.length;r++)t[r]=a.shape[d[r]];let n=qne(e,a.shape,a.dtype,d,t);m=o.makeTensorInfo(t,a.dtype),o.texData.get(m.dataId).values=n}else m=rae(a,d,o);f.push(m),c=FW.getInnerMostAxes(c.length,l)}FW.assertAxesAreInnerMostDims("sum",c,l);let[g,y]=FW.computeOutAndReduceShapes(m.shape,c),b=g;s&&(b=FW.expandShapeToKeepDim(g,u));let v=function(e,t,n,r){let a=iR.sizeFromShape(t),s=Xre({inputs:{x:e},attrs:{shape:[iR.sizeFromShape(e.shape)/a,a]},backend:r}),i=eae(s,"float32","mean",r),o=Xre({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(m,y,b,o);for(let x of f)o.disposeIntermediateTensorInfo(x);return v}};var Zoe={kernelName:x_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=iR.parseAxisParam(s,a.shape),u=l,c=FW.getAxesPermutation(u,o),d=a;null!=c&&(d=iae({inputs:{x:a},backend:n,attrs:{perm:c}}),u=FW.getInnerMostAxes(u.length,a.shape.length)),FW.assertAxesAreInnerMostDims("min",u,o);let h,[p,f]=FW.computeOutAndReduceShapes(d.shape,u),m=Xre({inputs:{x:d},backend:n,attrs:{shape:[-1,iR.sizeFromShape(f)]}}),g=eae(m,m.dtype,"min",n);if(i){h=Xre({inputs:{x:g},backend:n,attrs:{shape:FW.expandShapeToKeepDim(p,l)}})}else h=Xre({inputs:{x:g},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(d),h}},Joe=Wre({opSnippet:Nre+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+Are+"\n  return result;\n",cpuKernelImpl:wne}),ele={kernelName:w_,backendName:"webgl",kernelFunc:Joe},tle=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=gte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}},nle=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=gte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=Xne("rc",r),l=Xne("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1,h="";if(1===r){let e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{let e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}},rle={kernelName:k_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r,o=IA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new nle(a.shape,s,i):new tle(a.shape,s,i);return n.runWebGLProgram(o,[a],a.dtype)}},ale=Wre({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+Are+"\n  return result;\n"}),sle={kernelName:S_,backendName:"webgl",kernelFunc:ale},ile=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},ole=Wre({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),lle={kernelName:NE,backendName:"webgl",kernelFunc:ole},ule="return a - b;",cle=Wre({opSnippet:ule,packedOpSnippet:ule,supportsComplex:!0,cpuKernelImpl:jne}),dle={kernelName:E$,backendName:"webgl",kernelFunc:cle};function hle(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=iR.parseAxisParam([s],a.shape),o=Boe({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=FW.expandShapeToKeepDim(o.shape,i),u=Xre({inputs:{x:o},backend:n,attrs:{shape:l}}),c=cle({inputs:{a:a,b:u},backend:n}),d=$ie({inputs:{x:c},backend:n}),h=aae({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=Xre({inputs:{x:h},backend:n,attrs:{shape:l}}),f=ole({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}var ple={kernelName:g$,backendName:"webgl",kernelFunc:hle};var fle={kernelName:I_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:hle({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new ile(u,c,s),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}},mle=are+"\n  return -x;\n";var gle={kernelName:N_,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])){let e=r.texData.get(a.dataId),[t,n]=Sne(e.values,a.shape,a.dtype);return r.makeTensorInfo(n,a.dtype,t)}return t=IA().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new yre(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new rre(a.shape,mle),r.runWebGLProgram(t,[a],a.dtype)}},yle=VU.nonMaxSuppressionV3Impl;var ble={kernelName:A_,backendName:"webgl",kernelFunc:function(e){FW.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=yle(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},vle=VU.nonMaxSuppressionV4Impl;var xle={kernelName:E_,backendName:"webgl",kernelFunc:function(e){FW.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:p}=vle(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},wle=VU.nonMaxSuppressionV5Impl;var kle={kernelName:__,backendName:"webgl",kernelFunc:function(e){FW.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=wle(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},Sle=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},Ile={kernelName:R_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=iR.sizeFromShape(a.shape),c=new Sle(u,i,o,l),d=Xre({inputs:{x:a},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],s);n.disposeIntermediateTensorInfo(d);let p=Xre({inputs:{x:h},backend:n,attrs:{shape:[...a.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function Tle(e){let{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){let e=dse({inputs:{input:r},backend:n}),t=Tle({inputs:{x:e},backend:n}),a=Cse({inputs:{input:r},backend:n}),s=Tle({inputs:{x:a},backend:n}),i=Rre({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return Wie({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var Nle={kernelName:B$,backendName:"webgl",kernelFunc:Tle};var Cle={kernelName:$_,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){let t=dse({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=Cse({inputs:{input:a},backend:r}),i=Tle({inputs:{x:s},backend:r}),o=Rre({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return Wie({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};var Ale={kernelName:D_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return Die({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{iR.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),iR.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=Die({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=_se({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},Ele=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=gte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}},_le=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=gte(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=Xne("rc",r),l=Xne("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${d[f]}\n        if (${h}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}},$le=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===iR.sizeFromShape(a.shape)){let e=s.map(((e,t)=>e[0]+a.shape[t]+e[1]));return Wie({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}let o=IA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _le(a.shape,s,i):new Ele(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},Rle={kernelName:M_,backendName:"webgl",kernelFunc:$le},Dle=Wre({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+Are+"\n  return result;\n"}),Mle={kernelName:O_,backendName:"webgl",kernelFunc:Dle};var Fle={kernelName:L_,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a,l=s.shape.length,u=[],c=iR.parseAxisParam(i,s.shape),d=c,h=FW.getAxesPermutation(d,l),p=s;if(null!=h&&(p=iae({inputs:{x:s},backend:r,attrs:{perm:h}}),d=FW.getInnerMostAxes(d.length,l),u.push(p)),FW.assertAxesAreInnerMostDims("prod",d,l),r.shouldExecuteOnCPU([p])){let e=r.texData.get(p.dataId).values,{outVals:n,outShape:a,outDtype:s}=Tne(p.shape,p.dtype,e,d);t=r.makeTensorInfo(a,s,n)}else{let[e,n]=FW.computeOutAndReduceShapes(p.shape,d),a=iR.sizeFromShape(n),i=Xre({inputs:{x:p},backend:r,attrs:{shape:[-1,a]}}),o=eae(i,nD(s.dtype),"prod",r);t=Xre({inputs:{x:o},backend:r,attrs:{shape:e}}),u.push(i),u.push(o)}if(o){u.push(t);let e=FW.expandShapeToKeepDim(t.shape,c);t=Xre({inputs:{x:t},backend:r,attrs:{shape:e}})}return u.forEach((e=>r.disposeIntermediateTensorInfo(e))),t}};var Ole={kernelName:z_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.readSync(e.dataId))),u=a.map((e=>e.shape)),c=n.readSync(s.dataId),d=n.readSync(i.dataId),[h,p,f]=Nne(l,u,c,s.shape,s.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};var Ple={kernelName:B_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=Cne(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var Lle={kernelName:V_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),d=n.readSync(i.dataId),h=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=Ane(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}},zle=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=Ene(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},Ble={kernelName:W_,backendName:"webgl",kernelFunc:zle},Vle=Vre({opSnippet:"return 1.0 / x;"}),Wle={kernelName:j_,backendName:"webgl",kernelFunc:Vle},Ule=Vre({opSnippet:are+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),jle={kernelName:G_,backendName:"webgl",kernelFunc:Ule},Gle=Vre({opSnippet:are+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Hle={kernelName:Q_,backendName:"webgl",kernelFunc:Gle},qle=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},Kle=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}};var Yle={kernelName:Y_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=IA().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Kle(a.shape,l,u,s,i):new qle(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],"float32")}},Xle=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};var Qle={kernelName:X_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new Xle(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}},Zle=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";u=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},Jle=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";u=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}};var eue={kernelName:q_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=IA().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Jle(a.shape,l,u,s,i):new Zle(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],a.dtype)}},tue=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};var nue={kernelName:K_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new tue(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}},rue=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);let r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=gte(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}},aue=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=Xne("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=gte(n);var o;function l(n){let r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o=r.slice(),l(o)};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",l(e)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}};var sue={kernelName:Z_,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=iR.parseAxisParam(s,a.shape);if(0===i)return _re({inputs:{x:a},backend:n});let l=IA().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aue(a.shape,o):new rue(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}},iue=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},oue={kernelName:U$,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=new iue(a.shape,i),[c,d]=FW.getImageCenter(o,a.shape[1],a.shape[2]),h=[[c,d,Math.sin(s),Math.cos(s)]];return l.runWebGLProgram(u,[a],a.dtype,h)}},lue=Vre({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),uue={kernelName:J_,backendName:"webgl",kernelFunc:lue},cue=Vre({opSnippet:"return inversesqrt(x);",cpuKernelImpl:_ne}),due={kernelName:e$,backendName:"webgl",kernelFunc:cue},hue=class{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let o=gte(a.length),l=gte(s.length),u="";1===n?u="i":2===n&&(u="i, j");let c=`getIndices(${u})`,d="";1===r?d="i":2===r&&(d="i, coords[1]");let h=`getUpdates(${d})`,p="";i&&(p="coords[0], coords[1]");let f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}},pue=class{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let o=gte(a.length),l=gte(s.length),u="";1===n?u="i":2===n&&(u="i, j");let c=`getIndices(${u})`,d="";1===r?d="i":2===r&&(d="i, coords[1]");let h=`getUpdates(${d})`,p="";i&&(p="coords[0], coords[1]");let f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${g};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}};var fue={kernelName:t$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=FW.calculateShapes(s,a,i),h=[d/u,u];if(0===d)return n.makeTensorInfo(i,a.dtype);let p,f=Xre({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),m=Xre({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));p=IA().getBool("WEBGL_PACK")?new pue(l,o,f.shape.length,m.shape.length,c,h):new hue(l,o,f.shape.length,m.shape.length,c,h);let y=n.runWebGLProgram(p,[m,f,g],m.dtype),b=Xre({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(g),b}},mue=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===IA().getNumber("WEBGL_VERSION")?"while (left < right) {":a,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}};var gue={kernelName:r$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new mue(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}},yue=class{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{let n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}let s=gte(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}};var bue={kernelName:a$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new yue(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],tD(a.dtype,s.dtype))}},vue=Vre({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${FW.SELU_SCALEALPHA};\n  float scale = ${FW.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),xue={kernelName:s$,backendName:"webgl",kernelFunc:vue},wue=Vre({opSnippet:Bre+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Rne}),kue={kernelName:c$,backendName:"webgl",kernelFunc:wue},Sue=Vre({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Iue={kernelName:u$,backendName:"webgl",kernelFunc:Sue},Tue=Vre({opSnippet:Bre+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${Are}\n  return result;\n`}),Nue={kernelName:o$,backendName:"webgl",kernelFunc:Tue},Cue=Vre({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),Aue={kernelName:l$,backendName:"webgl",kernelFunc:Cue},Eue=Vre({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),_ue={kernelName:d$,backendName:"webgl",kernelFunc:Eue},$ue={kernelName:f$,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;iR.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let u=[],c=$le({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=FW.getReshaped(c.shape,s,o,!1),h=FW.getPermuted(d.length,s.length,!1),p=FW.getReshapedPermuted(c.shape,s,o,!1),f=Xre({inputs:{x:c},backend:n,attrs:{shape:d}}),m=iae({inputs:{x:f},backend:n,attrs:{perm:h}}),g=Xre({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};var Rue={kernelName:y$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=Fne(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};var Due={kernelName:b$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,d]=One(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};var Mue={kernelName:v$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=Pne(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};var Fue={kernelName:x$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=Pne(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};var Oue={kernelName:w$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=FW.calculateShapes(s,a,o),p=!1;if("string"===s.dtype){let e=n.bufferSync(a),t=n.bufferSync(s),r=iR.decodeString(n.readSync(i.dataId)[0]),f=$ne(e,t,o,h,c,u,l,d,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}let f=new hue(u,l,a.shape.length,s.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=Xre({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};var Pue={kernelName:m$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=iR.parseAxisParam(i,a.shape)[0],l=FW.prepareSplitSize(a,s,o),u=a.shape.length,c=new Array(u).fill(0),d=a.shape.slice();return l.map((e=>{let t=[...d];t[o]=e;let r=rse({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},Lue="return sqrt(x);",zue=Vre({opSnippet:Lue,packedOpSnippet:Lue,cpuKernelImpl:Lne}),Bue={kernelName:h$,backendName:"webgl",kernelFunc:zue},Vue=Vre({opSnippet:"return x * x;"}),Wue={kernelName:S$,backendName:"webgl",kernelFunc:Vue},Uue="return (a - b) * (a - b);",jue=Wre({opSnippet:Uue,packedOpSnippet:Uue}),Gue={kernelName:k$,backendName:"webgl",kernelFunc:jue};var Hue={kernelName:I$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");let s=n.readSync(a.dataId),i=FW.fromUint8ToStringArray(s),o=zne(i,"string",r);return n.makeTensorInfo(a.shape,"string",o)}};var que={kernelName:V$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,s=are+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,i=new rre(a.shape,s);return r.runWebGLProgram(i,[a],a.dtype)}},Kue=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=gte(n.length),s=gte(n.length),i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}};var Yue={kernelName:T$,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{begin:i,end:o,strides:l,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=uW.sliceInfo(s.shape,i,o,l,u,c,d,h,p);if(g)t=Xre({inputs:{x:s},backend:r,attrs:{shape:m}});else if(y||b){iR.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=uW.computeOutShape(v,x,w),n=rse({inputs:{x:s},backend:r,attrs:{begin:v,size:e}});t=Xre({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeIntermediateTensorInfo(n)}else if(r.shouldExecuteOnCPU([s])){let e=r.readSync(s.dataId),n=JM(s.shape,s.dtype,e),a=Bne(f,n,w,v);t=r.makeTensorInfo(m,s.dtype,a.values)}else{let e=new Kue(v,w,f);t=r.runWebGLProgram(e,[s],s.dtype)}let k=Xre({inputs:{x:t},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(t),k}};var Xue={kernelName:N$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=Vne(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};var Que={kernelName:C$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=Wne(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};var Zue={kernelName:A$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=Une(i,a);return n.makeTensorInfo(s.shape,"int32",o)}},Jue=Vre({opSnippet:"return tan(x);"}),ece={kernelName:_$,backendName:"webgl",kernelFunc:Jue},tce=Vre({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),nce={kernelName:$$,backendName:"webgl",kernelFunc:tce};var rce={kernelName:n$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=FW.calculateShapes(i,s,a.shape),h=[d/u,u];if(0===d)return n.makeTensorInfo(a.shape,s.dtype);let p=Xre({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=Xre({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=Xre({inputs:{x:a},backend:n,attrs:{shape:h}}),g=new hue(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=Xre({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}},ace=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let r=gte(this.rank),a=function(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}};function sce(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){let e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>iR.decodeString(e))):e,r=JM(a.shape,a.dtype,t),i=Gne(r,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}let i=new ace(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var ice={kernelName:R$,backendName:"webgl",kernelFunc:sce},oce=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}},lce=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function uce(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function cce(e){let t=1;for(;t<e;)t*=2;return t}var dce={kernelName:D$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=IA().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=IA().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([a])||c<o||s>l){let e=n.readSync(a.dataId),[t,r]=Hne(e,u,a.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[a,Wie({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let d=n.texData.get(a.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(a):a,f=iR.sizeFromShape(u)/c,m=Xre({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&uce(n,p);let g=cce(s),y=cce(c),b=null,v=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{let a=v(),s=new oce(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(s,a,"int32",i),uce(n,o)};for(let T=1;T<g;T*=2){let e=2*T;for(let t=T;t>=1;t/=2)x(e,t,[f,y])}for(let T=y;T>g;T/=2){let e=v(),t=new lce([f,T/2]),r=[[c],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(t,e,"int32",r),uce(n,a);let s=g/2,i=2*s;for(let n=s;n>=1;n/=2)x(i,n,b.shape)}let w=b;b=rse({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),uce(n,w);let k=ooe({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});uce(n,m);let S=u.slice(0,-1);S.push(s),w=b,b=Xre({inputs:{x:b},attrs:{shape:S},backend:n}),uce(n,w);let I=k;return k=Xre({inputs:{x:k},attrs:{shape:S},backend:n}),uce(n,I),[k,b]}},hce=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i,o="nearest"===n?1:2;switch(r){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}};var pce={kernelName:M$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=new hce(d,h,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[a,s],"float32")}};var fce={kernelName:O$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;Qee(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=Kne(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};var mce={kernelName:P$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1),c=0;for(let m=0;m<o;m++)m!==s&&(u[c++]=i.shape[m]);let d=[],h=new Array(o).fill(0),p=i.shape.slice();p[s]=1;let f=new Array(l);for(let m=0;m<f.length;m++){h[s]=m;let e=rse({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),t=Xre({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}},gce=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ",c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}};var yce,bce,vce,xce={kernelName:L$,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],u=0,c=FW.getAxesPermutation([u],o),d=a;null!=c&&(d=iae({inputs:{x:a},backend:n,attrs:{perm:c}}),l.push(d),u=FW.getInnerMostAxes(1,o)[0]);let h=FW.segment_util.computeOutShape(d.shape,u,i),p=iR.sizeFromShape([d.shape[u]]),f=Xre({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);let m=nD(a.dtype),g=(e,t,r,a,s)=>{let i=e.shape[0],o=e.shape[1],u=FW.segment_util.segOpComputeOptimalWindowSize(o,s),c=new gce({windowSize:u,inSize:o,batchSize:i,numSegments:s},t),d=n.compileAndRun(c,[e,r],a);if(l.push(d),d.shape[1]===s)return d;let h=zle({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=sce({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});return l.push(h),l.push(p),g(d,t,p,a,s)},y=Xre({inputs:{x:g(f,"unsortedSegmentSum",s,m,i)},backend:n,attrs:{shape:h}}),b=y;if(null!=c){l.push(y);let e=FW.getUndoAxesPermutation(c);b=iae({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},wce=[cae,hae,fae,gae,vae,kae,Sae,Iae,_ae,$ae,Dae,Fae,Pae,zae,Vae,jae,Gae,Kae,Yae,Xae,Jae,sse,ise,ose,lse,fse,yse,xse,Dre,Sse,$se,zse,jse,Hse,qse,Kse,Xse,Zse,eie,nie,oie,lie,uie,die,fie,yie,bie,xie,kie,Sie,Tie,Nie,Aie,_ie,Rie,Mie,Pie,Bie,jie,Hie,Yie,Qie,eoe,noe,roe,soe,loe,coe,hoe,$re,poe,Ase,moe,yoe,voe,Ore,woe,Soe,Ioe,Noe,Aoe,_oe,Roe,Moe,Poe,zoe,Voe,Uoe,joe,Goe,Koe,Yoe,Xoe,Qoe,Zoe,ele,rle,sle,fle,Yre,gle,ble,xle,kle,cse,Ile,Cle,Ale,Rle,Mle,zre,Fle,Ole,Ple,Lle,Ble,hse,lle,Wle,jle,Hle,Qre,Yle,Qle,eue,nue,sue,oue,uue,due,fue,gue,bue,xue,kue,Iue,Nue,Aue,ase,ple,_ue,$ue,Rue,Due,Mue,Fue,Oue,Pue,Bue,Wue,Gue,Hue,que,Yue,Xue,Que,Zue,dle,sae,ece,nce,rce,ice,dce,pce,oae,fce,mce,xce,Nle];for(let n of wce)eR(n);!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(yce||(yce={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(bce||(bce={}));var kce={kernelName:j$,backendName:"wasm",setupFunc:function(e){vce=e.wasm.cwrap(j$,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,h=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=0;if(null!=i){let e=n.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}let m=null==o?0:n.dataIdMap.get(o.dataId).id,g=bce[c];if(null==g)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=u?s.shape[1]:s.shape[2],v=SO.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),x=n.makeOutput([...v,y,b],a.dtype),w=n.dataIdMap.get(x.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer),S=new Uint8Array(new Int32Array(s.shape).buffer);return vce(h,k,a.shape.length,p,S,s.shape.length,l,u,g,f,m,d||0,w),x}};function Sce(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){let{backend:r,inputs:{x:a}}=e,s=r.dataIdMap.get(a.dataId).id,i=r.makeOutput(a.shape,t||a.dtype),o=r.dataIdMap.get(i.dataId).id;return 0===iR.sizeFromShape(i.shape)||n(s,yce[a.dtype],o),i}}}var Ice=Sce(EA),Tce=Sce(_A),Nce=Sce($A);function Cce(e,t,n){let r;return{kernelName:e,backendName:"wasm",setupFunc:function(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:a}=e,{a:s,b:i}=a,o=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(i.dataId).id,u=null!=n?n:s.dtype,c=FW.assertAndGetBroadcastShape(s.shape,i.shape),d=t.makeOutput(c,u);if(0===iR.sizeFromShape(c))return d;let h=new Uint8Array(new Int32Array(s.shape).buffer),p=new Uint8Array(new Int32Array(i.shape).buffer),f=t.dataIdMap.get(d.dataId).id;return r(o,h,s.shape.length,l,p,i.shape.length,yce[s.dtype],f),d}}}var Ace,Ece=Cce(RA);var _ce={kernelName:DA,backendName:"wasm",setupFunc:function(e){Ace=e.wasm.cwrap(DA,null,["array","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===iR.sizeFromShape(r.shape))return r;let a=t.map((e=>n.dataIdMap.get(e.dataId).id)),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return Ace(s,a.length,yce[r.dtype],i),r}};function $ce(e){let{inputs:{x:t},backend:n}=e;if("string"===t.dtype)return $D(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var Rce,Dce={kernelName:GE,backendName:"wasm",kernelFunc:$ce};function Mce(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=function(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let a=0;a<r.length;++a){let e=-1;for(let t=0;t<r.length;++t)r[t]>=a&&(-1===e||r[e]>r[t])&&(e=t);r[e]=a}return[n,r]}(t.x.shape,r.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=function(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let e=$ce({inputs:t,backend:n});return e.shape=o,e}let u=n.makeOutput(o,l.dtype),c=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,h=new Uint8Array(new Int32Array(s).buffer),p=new Uint8Array(new Int32Array(l.shape).buffer);return Rce(c,p,l.shape.length,yce[l.dtype],d,h,s.length),u}var Fce,Oce={kernelName:F$,backendName:"wasm",kernelFunc:Mce,setupFunc:function(e){Rce=e.wasm.cwrap(F$,null,["number","array","number","number","number","array","number"])}};function Pce(e,t,n){let r=e.shape,a=e.shape.length,s=iR.parseAxisParam(t,r),i=s,o=FW.getAxesPermutation(i,a),l=null,u=!1;if(null!=o){let t=new Array(a);for(let e=0;e<t.length;e++)t[e]=r[o[e]];i=FW.getInnerMostAxes(i.length,a),l=Mce({inputs:{x:e},attrs:{perm:o},backend:n});let s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==s&&(u=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:u}}var Lce,zce={kernelName:MA,backendName:"wasm",setupFunc:function(e){Fce=e.wasm.cwrap(MA,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=Pce(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let p=l.shape.length;FW.assertAxesAreInnerMostDims("all",c,p);let[f,m]=FW.computeOutAndReduceShapes(l.shape,c),g=iR.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==iR.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;Fce(o,g,e)}if(h&&t.disposeData(u.dataId),s){let e=FW.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}};var Bce={kernelName:FA,backendName:"wasm",setupFunc:function(e){Lce=e.wasm.cwrap(FA,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=Pce(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let p=l.shape.length;FW.assertAxesAreInnerMostDims("any",c,p);let[f,m]=FW.computeOutAndReduceShapes(l.shape,c),g=iR.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==iR.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;Lce(o,g,e)}if(h&&t.disposeData(u.dataId),s){let e=FW.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}};function Vce(e){let t;return{kernelName:e,backendName:"wasm",setupFunc:function(n){t=n.wasm.cwrap(e,null,["number","number","number","number","number"])},kernelFunc:function(e){let{backend:n,inputs:r,attrs:a}=e,{axis:s}=a,{x:i}=r,o=n.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,inputWasTransposed:h}=Pce(i,s,n);if(h){let e=n.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e)}let p=u.shape.slice(0,-1),f=n.makeOutput(p,"int32"),m=n.dataIdMap.get(f.dataId).id,g=iR.sizeFromShape(f.shape),y=u.shape[d[0]];return t(l,yce[u.dtype],g,y,m),h&&n.disposeData(c.dataId),f}}}var Wce,Uce=Vce(OA),jce=Vce(PA),Gce=Sce(LA),Hce=Sce(zA),qce=Sce(BA),Kce=Cce(WA),Yce=Sce(VA);var Xce,Qce={kernelName:UA,backendName:"wasm",setupFunc:function(e){Wce=e.wasm.cwrap(UA,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=FW.computePool2DInfo(a.shape,i,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,b=c.strideWidth,v=c.inChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(1!==c.dilationWidth||1!==c.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let x=r.makeOutput(c.outShape,"float32"),w=r.dataIdMap.get(x.dataId).id;return Wce(s,a.shape[0],a.shape[1],a.shape[2],d,h,p,f,m,g,y,b,v,w),x}};var Zce,Jce={kernelName:GA,backendName:"wasm",setupFunc:function(e){Xce=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=FW.computePool3DInfo(a.shape,s,i,1,o,l,u),d=n.makeOutput(c.outShape,a.dtype);return Xce(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};var ede,tde={kernelName:HA,backendName:"wasm",setupFunc:function(e){Zce=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=FW.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return Zce(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),d}};var nde={kernelName:jA,backendName:"wasm",setupFunc:function(e){ede=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l}=r,u=FW.computePool2DInfo(s.shape,i,o,1,l),c=n.makeOutput(s.shape,s.dtype);return ede(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),c}};function rde(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=iR.sizeFromShape(r.shape),i=iR.inferFromImplicitShape(a,s);return iR.assert(s===iR.sizeFromShape(i),(()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var ade,sde={kernelName:H_,backendName:"wasm",kernelFunc:rde};var ide={kernelName:qA,backendName:"wasm",setupFunc:function(e){ade=e.wasm.cwrap(qA,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=iR.sizeFromShape(f),y=iR.sizeFromShape(m),b=SO.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);iR.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let v=o?[y,p,d]:[y,d,p],x=rde({inputs:{x:a},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=rde({inputs:{x:s},backend:n,attrs:{shape:v}}),k=n.dataIdMap.get(x.dataId).id,S=n.dataIdMap.get(w.dataId).id,I=i?x.shape[2]:x.shape[1],T=o?w.shape[1]:w.shape[2],N=Math.max(g,y),C=n.makeOutput([N,I,T],x.dtype),A=n.dataIdMap.get(C.dataId).id,E=new Uint8Array(new Int32Array(x.shape).buffer),_=new Uint8Array(new Int32Array(w.shape).buffer);return ade(k,E,x.shape.length,S,_,w.shape.length,i,o,A),n.disposeData(x.dataId),n.disposeData(w.dataId),C.shape=b,C}};function ode(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=uW.parseSliceParams(t,n,r),o=uW.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),u=a.makeOutput(i,t.dtype),c=iR.computeStrides(t.shape),d=a.dataIdMap.get(u.dataId);if(o){let e=uW.computeFlatOffset(s,c);return"string"===t.dtype?d.stringBytes=l.slice(e,e+iR.sizeFromShape(i)):a.typedArrayFromHeap(u).set(l.subarray(e,e+iR.sizeFromShape(i))),u}if("string"===t.dtype){let e=s5(l,s,i,t.shape,t.dtype);return d.stringBytes=e,u}let h=a.typedArrayFromHeap(u),p=t.shape.length;if(2===p)!function(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let u=i;u<l;u++){let r=u*t+o;n.set(e.subarray(r,r+a[1]),s),s+=a[1]}}(l,c[0],h,s,i);else if(3===p)!function(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],u=a[2],c=o+s[0],d=l+s[1];for(let h=o;h<c;h++)for(let a=l;a<d;a++){let o=h*t+a*n+u;r.set(e.subarray(o,o+s[2]),i),i+=s[2]}}(l,c[0],c[1],h,s,i);else if(4===p)!function(e,t,n,r,a,s,i){let o=0,l=s[0],u=s[1],c=s[2],d=l+i[0],h=u+i[1],p=c+i[2],f=s[3];for(let m=l;m<d;m++)for(let s=u;s<h;s++)for(let l=c;l<p;l++){let u=m*t+s*n+l*r+f;a.set(e.subarray(u,u+i[3]),o),o+=i[3]}}(l,c[0],c[1],c[2],h,s,i);else{let e=s5(l,s,i,t.shape,t.dtype);h.set(e)}return u}var lde={kernelName:i$,backendName:"wasm",kernelFunc:ode};var ude,cde={kernelName:KA,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce(((e,t)=>e*t)),l=FW.getReshaped(a.shape,s,o),u=FW.getPermuted(l.length,s.length),c=FW.getReshapedPermuted(a.shape,s,o),d=FW.getSliceBeginCoords(i,s.length),h=FW.getSliceSize(c,i,s.length),p=rde({inputs:{x:a},backend:n,attrs:{shape:l}}),f=Mce({inputs:{x:p},backend:n,attrs:{perm:u}}),m=rde({inputs:{x:f},backend:n,attrs:{shape:c}}),g=ode({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}};var dde={kernelName:YA,backendName:"wasm",setupFunc:function(e){ude=e.wasm.cwrap(YA,null,["number","number","boolean","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i}=r,o=0!==s.shape.reduce(((e,t)=>e*t),1),l=1===a.shape.length?[i]:[a.shape[0],i],u=t.makeOutput(l,s.dtype);function c(e){return t.dataIdMap.get(e.dataId).id}return ude(c(a),i,o,c(s),yce[s.dtype],c(u)),u}},hde=Cce(XA);var pde={kernelName:ZA,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(a),o=FW.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}};function fde(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var mde,gde={kernelName:JA,backendName:"wasm",kernelFunc:fde},yde=Sce(eE);var bde={kernelName:tE,backendName:"wasm",setupFunc:function(e){mde=e.wasm.cwrap(tE,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return mde(o,s,i,u),l}};function vde(e){let{inputs:t,backend:n}=e,r=iR.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map((e=>e.shape));FW.assertParamsConsistent(a,r);let s=FW.computeOutShape(t.map((e=>e.shape)),r),i=t.filter((e=>iR.sizeFromShape(e.shape)>0));if(1===i.length)return $ce({inputs:{x:i[0]},backend:n});let o=n.makeOutput(s,t[0].dtype);if(0===iR.sizeFromShape(s))return o;if("string"===i[0].dtype){let e=i.map((e=>{let t=[-1,iR.sizeFromShape(e.shape.slice(r))];return rde({inputs:{x:e},backend:n,attrs:{shape:t}})})),a=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));s=FW.computeOutShape(e.map((e=>e.shape)),1);let l=1===e[0].shape[0],u=z3(a,s,t[0].dtype,l),c=FW.computeOutShape(i.map((e=>e.shape)),r);return o.shape=c,n.dataIdMap.get(o.dataId).stringBytes=FW.fromStringArrayToUint8(u),e.forEach((e=>n.disposeData(e.dataId))),o}let l=iR.sizeFromShape(i[0].shape.slice(0,r)),u=0,c=i.map((e=>{let t=iR.sizeFromShape(e.shape.slice(r));return u+=t,t})),d=i.map((e=>n.typedArrayFromHeap(e))),h=n.typedArrayFromHeap(o);for(let p=0;p<l;p++){let e=p*u;for(let t=0;t<d.length;t++){let n=c[t],r=p*n,a=d[t].subarray(r,r+n);h.set(a,e),e+=n}}return o}var xde,wde={kernelName:aE,backendName:"wasm",kernelFunc:vde};var kde,Sde={kernelName:sE,backendName:"wasm",setupFunc:function(e){xde=e.wasm.cwrap(sE,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d,dataFormat:h}=n,p=FW.convertConv2DDataFormat(h),f=FW.computeConv2DInfo(a.shape,s.shape,l,u,c,d,!1,p),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,v=f.padInfo.bottom,x=f.padInfo.left,w=f.dilationHeight,k=f.dilationWidth,S=f.strideHeight,I=f.strideWidth,T=f.inChannels,N=f.outChannels,C="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let A=r.makeOutput(f.outShape,"float32"),E=r.dataIdMap.get(A.dataId).id;return xde(i,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,b,v,x,C,w,k,S,I,T,N,E),A}};var Ide,Tde={kernelName:oE,backendName:"wasm",setupFunc:function(e){kde=e.wasm.cwrap(oE,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:c}=r,d=FW.convertConv2DDataFormat(l),h=FW.computeConv2DInfo(c,s.shape,i,1,o,u,!1,d),{batchSize:p,filterHeight:f,filterWidth:m,inChannels:g,inHeight:y,inWidth:b,outChannels:v,outHeight:x,outWidth:w,strideHeight:k,strideWidth:S}=h,I=f-1-h.padInfo.top,T=m-1-h.padInfo.left,N="channelsLast"===h.dataFormat,C=iR.computeStrides(h.inShape),A=iR.computeStrides(a.shape),[E,_,$]=iR.computeStrides(s.shape),R=C[0],D=N?C[1]:C[2],M=N?C[2]:1,F=N?1:C[1],O=A[0],P=N?A[1]:A[2],L=N?A[2]:1,z=N?1:A[1],B=t.makeOutput(h.inShape,"float32"),V=t.dataIdMap.get(B.dataId).id,W=t.dataIdMap.get(a.dataId).id,U=t.dataIdMap.get(s.dataId).id;return kde(W,U,p,f,m,y,b,g,x,w,v,k,S,I,T,E,_,$,R,D,M,F,O,P,L,z,V),B}};var Nde,Cde={kernelName:lE,backendName:"wasm",setupFunc:function(e){Ide=e.wasm.cwrap(lE,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=FW.computeConv3DInfo(a.shape,s.shape,i,l,o),c=n.makeOutput(u.outShape,a.dtype);return Ide(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}};var Ade,Ede={kernelName:uE,backendName:"wasm",setupFunc:function(e){Nde=e.wasm.cwrap(uE,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=FW.computeConv3DInfo(a.shape,l,i,1,o),c=n.makeOutput(u.filterShape,s.dtype);return Nde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}};var _de,$de,Rde={kernelName:cE,backendName:"wasm",setupFunc:function(e){Ade=e.wasm.cwrap(cE,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==s.dtype)throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let u=FW.computeConv3DInfo(l,s.shape,o,1,i),c=n.makeOutput(u.inShape,a.dtype);return Ade(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}},Dde=Sce(dE),Mde=Sce(hE);!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(_de||(_de={}));var Fde,Ode={kernelName:mE,backendName:"wasm",setupFunc:function(e){$de=e.wasm.cwrap(mE,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{method:s,extrapolationValue:i,cropSize:o}=a,{image:l,boxes:u,boxInd:c}=r,d=u.shape[0],[h,p]=o,f=[d,h,p,l.shape[3]],m=n.dataIdMap.get(l.dataId);"float32"!==l.dtype&&(t=fde({backend:n,inputs:{x:l},attrs:{dtype:"float32"}}),m=n.dataIdMap.get(t.dataId));let g=m.id,y=n.dataIdMap.get(u.dataId).id,b=n.dataIdMap.get(c.dataId).id,v=n.makeOutput(f,"float32"),x=n.dataIdMap.get(v.dataId).id,w=new Uint8Array(new Int32Array(l.shape).buffer);return $de(g,y,b,d,w,h,p,_de[s],i,x),null!=t&&n.disposeData(t.dataId),v}};var Pde,Lde={kernelName:pE,backendName:"wasm",setupFunc:function(e){Fde=e.wasm.cwrap(pE,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;iR.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));let u=FW.getAxesPermutation([s],l),c=a;null!==u&&(c=Mce({inputs:{x:a},attrs:{perm:u},backend:n}));let d=FW.getInnerMostAxes(1,l)[0];FW.assertAxesAreInnerMostDims("cumprod",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;Fde(f,i?1:0,o?1:0,p,m,yce[a.dtype]);let g=h;if(null!==u){g=Mce({inputs:{x:h},attrs:{perm:FW.getUndoAxesPermutation(u)},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return g}};var zde,Bde={kernelName:fE,backendName:"wasm",setupFunc:function(e){Pde=e.wasm.cwrap(fE,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;iR.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));let u=FW.getAxesPermutation([s],l),c=a;null!==u&&(c=Mce({inputs:{x:a},attrs:{perm:u},backend:n}));let d=FW.getInnerMostAxes(1,l)[0];FW.assertAxesAreInnerMostDims("cumsum",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;Pde(f,i?1:0,o?1:0,p,m,yce[a.dtype]);let g=h;if(null!==u){g=Mce({inputs:{x:h},attrs:{perm:FW.getUndoAxesPermutation(u)},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return g}};var Vde,Wde={kernelName:gE,backendName:"wasm",setupFunc:function(e){zde=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:s}=n,{size:i,binaryOutput:o}=r,l=0!==s.shape.reduce(((e,t)=>e*t),1),u=1===a.shape.length?[i]:[a.shape[0],i],c=t.makeOutput(u,s.dtype);function d(e){return t.dataIdMap.get(e.dataId).id}return zde(d(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,i,l,d(s),yce[s.dtype],o,d(c)),c}};var Ude,jde={kernelName:yE,backendName:"wasm",setupFunc:function(e){Vde=e.wasm.cwrap(yE,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,c=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d="NHWC"===i?[o,l,u,c]:[o,c,l,u],h=t.makeOutput(d,"float32"),p=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(iR.computeStrides(a.shape)).buffer),m=new Uint8Array(new Int32Array(d).buffer),g=new Uint8Array(new Int32Array(iR.computeStrides(d)).buffer),y=t.dataIdMap.get(h.dataId).id;return Vde(p,s,"NHWC"===i?1:0,f,a.shape.length-1,m,g,d.length,y),h}};var Gde,Hde={kernelName:bE,backendName:"wasm",setupFunc:function(e){Ude=e.wasm.cwrap(bE,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d}=n,h=null==u?[1,1]:u,p=FW.computeConv2DInfo(a.shape,s.shape,l,h,c,d,!0),f=p.filterHeight,m=p.filterWidth,g=p.padInfo.top,y=p.padInfo.right,b=p.padInfo.bottom,v=p.padInfo.left,x=p.dilationHeight,w=p.dilationWidth,k=p.strideHeight,S=p.strideWidth,I=p.inChannels,T=p.outChannels,N="SAME"===p.padInfo.type?1:0;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(p.outShape,"float32"),A=r.dataIdMap.get(C.dataId).id;return Ude(i,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,b,v,N,x,w,k,S,I,T,A),C}};var qde,Kde={kernelName:wE,backendName:"wasm",setupFunc:function(e){Gde=e.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=iR.sizeFromShape(r.shape),s=n.makeOutput([...r.shape,...r.shape],r.dtype);return Gde(n.dataIdMap.get(r.dataId).id,yce[r.dtype],a,n.dataIdMap.get(s.dataId).id),s}};var Yde,Xde={kernelName:kE,backendName:"wasm",setupFunc:function(e){qde=e.wasm.cwrap(kE,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;if(a.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${s.dtype}`);let u=FW.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),c=n.makeOutput(u.outShape,a.dtype);return qde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,yce[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),c}};var Qde,Zde={kernelName:IE,backendName:"wasm",setupFunc:function(e){Yde=e.wasm.cwrap(IE,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let c=FW.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),d=n.makeOutput(s.shape,s.dtype);return Yde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,yce[a.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}};var Jde,ehe={kernelName:SE,backendName:"wasm",setupFunc:function(e){Qde=e.wasm.cwrap(SE,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(a.dtype!==s.dtype||a.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${s.dtype}, and ${i.dtype}`);let c=FW.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u),d=n.makeOutput(a.shape,a.dtype);return Qde(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,yce[a.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}},the=Sce(AE);var nhe={kernelName:EE,backendName:"wasm",setupFunc:function(e){Jde=e.wasm.cwrap(EE,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=n.makeOutput(a.shape,"float32"),i=e=>n.dataIdMap.get(e.dataId).id;return Jde(i(a),i(r),i(s)),s}},rhe=Cce($E,0,"bool"),ahe=Sce(_E),she=Sce(RE,"float32");function ihe(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(iR.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),rde({inputs:{x:a},backend:r,attrs:{shape:o}})}var ohe={kernelName:DE,backendName:"wasm",kernelFunc:ihe},lhe=Sce(ME,"float32");function uhe(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:a}}=e;a=a||iR.inferDtype(n);let s=r.makeOutput(t,a);return r.typedArrayFromHeap(s).fill(n),s}var che,dhe={kernelName:OE,backendName:"wasm",kernelFunc:uhe};var hhe,phe={kernelName:PE,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,u,c]=r.shape;return che(s,o,l,u,c,i),a},setupFunc:function(e){che=e.wasm.cwrap(PE,null,["number","number","number","number","number","number"])}},fhe=Sce(LE),mhe=Cce(zE);var ghe,yhe={kernelName:BE,backendName:"wasm",setupFunc:function(e){hhe=e.wasm.cwrap(BE,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:u}=n,c=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(o.dataId).id,p=null!=l?t.dataIdMap.get(l.dataId).id:0,f=null!=u?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(0===iR.sizeFromShape(s.shape))return m;let g=t.dataIdMap.get(m.dataId).id;return hhe(c,d,h,p,f,a,g),m}};var bhe,vhe={kernelName:G$,backendName:"wasm",setupFunc:function(e){ghe=e.wasm.cwrap(G$,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=FW.computeConv2DInfo(a.shape,s.shape,l,c,u,h),g=bce[p];if(null==g)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,v=m.outChannels,x=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==v)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${v})`);x=e.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,T=m.padInfo.bottom,N=m.padInfo.left,C=m.dilationHeight,A=m.dilationWidth,E=m.strideHeight,_=m.strideWidth,$=m.inChannels,R="SAME"===m.padInfo.type?1:0,D=m.batchSize,M=m.inHeight,F=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),P=r.dataIdMap.get(O.dataId).id,L=null==o?0:r.dataIdMap.get(o.dataId).id;return ghe(y,D,M,F,b,w,k,x,S,I,T,N,R,C,A,E,_,$,v,g,L,f||0,P),O}};var xhe,whe={kernelName:H$,backendName:"wasm",setupFunc:function(e){bhe=e.wasm.cwrap(H$,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=FW.computeConv2DInfo(a.shape,s.shape,l,c,u,h,!0),g=bce[p];if(null==g)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,v=m.outChannels,x=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==v)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${v})`);x=e.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,T=m.padInfo.bottom,N=m.padInfo.left,C=m.dilationHeight,A=m.dilationWidth,E=m.strideHeight,_=m.strideWidth,$=m.inChannels,R="SAME"===m.padInfo.type?1:0,D=m.batchSize,M=m.inHeight,F=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),P=r.dataIdMap.get(O.dataId).id,L=null==o?0:r.dataIdMap.get(o.dataId).id;return bhe(y,D,M,F,b,w,k,x,S,I,T,N,R,C,A,E,_,$,v,g,L,f||0,P),O}};var khe,She={kernelName:WE,backendName:"wasm",setupFunc:function(e){xhe=e.wasm.cwrap(WE,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=oW.prepareAndValidate(r,a),u=t.makeOutput(s,r.dtype);if(0===i)return u;let c=a.shape,d=c[c.length-1],h=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return xhe(h,yce[r.dtype],p,i,d,o,f,m),u}};var Ihe,The={kernelName:VE,backendName:"wasm",setupFunc:function(e){khe=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=iR.parseAxisParam(i,a.shape)[0],u=t.readSync(s.dataId),c=a.shape[l];for(let S=0;S<u.length;++S){let e=u[S];iR.assert(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let d=FW.segment_util.collectGatherOpShapeInfo(a,s,l,o),h=rde({inputs:{x:a},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),p=iR.sizeFromShape(s.shape),f=rde({inputs:{x:s},attrs:{shape:[d.batchSize,p/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize],g=t.makeOutput(m,a.dtype);if(0===iR.sizeFromShape(a.shape))return g;let y=h.shape.length-1,b=t.dataIdMap.get(h.dataId).id,v=t.dataIdMap.get(f.dataId).id,x=t.dataIdMap.get(g.dataId).id,w=new Uint8Array(new Int32Array(iR.computeStrides(h.shape)).buffer),k=new Uint8Array(new Int32Array(iR.computeStrides(m)).buffer);return khe(b,yce[a.dtype],w,y,v,d.batchSize,k,x),t.disposeData(h.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}},Nhe=Cce(UE,0,"bool"),Che=Cce(jE,0,"bool"),Ahe=Sce(KE,"bool"),Ehe=Sce(YE,"bool"),_he=Sce(XE,"bool");var $he,Rhe={kernelName:QE,backendName:"wasm",setupFunc:function(e){Ihe=e.wasm.cwrap(QE,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(0!==iR.sizeFromShape(t.shape)){let e=r.dataIdMap.get(s.dataId).id;Ihe(a,yce[t.dtype],n,e)}return s}},Dhe=Cce(ZE,0,"bool"),Mhe=Cce(JE,0,"bool");var Fhe,Ohe={kernelName:e_,backendName:"wasm",setupFunc:function(e){$he=e.wasm.cwrap(e_,null,["number","number","number","number"])},kernelFunc:function(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:s}=t,i=Math.floor(s),o=n.makeOutput([i],"float32");return $he(n.dataIdMap.get(o.dataId).id,r,a,i),o}},Phe=Sce(t_),Lhe=Sce(n_),zhe=Cce(r_,0,"bool"),Bhe=Sce(a_),Vhe=Cce(s_,0,"bool"),Whe=Cce(i_,0,"bool");var Uhe,jhe={kernelName:u_,backendName:"wasm",setupFunc:function(e){Fhe=e.wasm.cwrap(u_,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;if("float32"!==a.dtype)throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(a.shape,a.dtype);return Fhe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,a.shape[3],s,i,o,l),u}};var Ghe,Hhe={kernelName:c_,backendName:"wasm",setupFunc:function(e){Uhe=e.wasm.cwrap(c_,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;if("float32"!==a.dtype||"float32"!==s.dtype||"float32"!==i.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(a.shape,a.dtype);return Uhe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,l,u,c),d}};var qhe,Khe={kernelName:h_,backendName:"wasm",setupFunc:function(e){Ghe=e.wasm.cwrap(h_,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=Pce(i,a,t);if(h){l=u,o=t.dataIdMap.get(u.dataId).id}let p=l.shape.length;FW.assertAxesAreInnerMostDims("max",c,p);let[f,m]=FW.computeOutAndReduceShapes(l.shape,c),g=iR.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==iR.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;Ghe(o,yce[i.dtype],g,e)}if(h&&t.disposeData(u.dataId),s){let e=FW.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}},Yhe=Cce(p_);var Xhe,Qhe={kernelName:f_,backendName:"wasm",setupFunc:function(e){qhe=e.wasm.cwrap(f_,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;iR.assert("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=FW.computePool2DInfo(a.shape,i,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,b=c.dilationWidth,v=c.strideHeight,x=c.strideWidth,w=c.inChannels,k=c.outChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let S=r.makeOutput(c.outShape,"float32"),I=r.dataIdMap.get(S.dataId).id;return qhe(s,a.shape[0],a.shape[1],a.shape[2],d,h,p,f,m,g,y,b,v,x,w,k,I),S}};var Zhe,Jhe={kernelName:g_,backendName:"wasm",setupFunc:function(e){Xhe=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=FW.computePool3DInfo(a.shape,s,i,1,o,l,u),d=n.makeOutput(c.outShape,a.dtype);return Xhe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};var epe,tpe={kernelName:y_,backendName:"wasm",setupFunc:function(e){Zhe=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=FW.computePool3DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return Zhe(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}};var npe,rpe={kernelName:m_,backendName:"wasm",setupFunc:function(e){epe=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=FW.computePool2DInfo(s.shape,i,o,1,l,u),d=n.makeOutput(s.shape,s.dtype);return epe(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),d}};var ape,spe={kernelName:b_,backendName:"wasm",setupFunc:function(e){npe=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=r;iR.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));let u=[1,1];iR.assert(FW.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let c=FW.computePool2DInfo(a.shape,s,i,[1,1],o),d=n.makeOutput(c.outShape,a.dtype),h=n.makeOutput(c.outShape,"int32");return npe(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(h.dataId).id,yce[a.dtype],l,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[d,h]}};var ipe,ope={kernelName:v_,backendName:"wasm",setupFunc:function(e){ape=e.wasm.cwrap(v_,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Pce(i,a,t),f=d;if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=FW.getInnerMostAxes(f.length,u.shape.length))}FW.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=FW.computeOutAndReduceShapes(u.shape,f),y=iR.sizeFromShape(g),b=u;"float32"!==u.dtype&&(b=fde({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let v=t.makeOutput(m,"float32");if(0!==iR.sizeFromShape(u.shape)){let e=t.dataIdMap.get(v.dataId).id;ape(l,y,e)}if(p&&t.disposeData(c.dataId),s){let e=FW.expandShapeToKeepDim(v.shape,h);v.shape=e}return"float32"!==u.dtype&&t.disposeData(b.dataId),v}};var lpe,upe,cpe={kernelName:x_,backendName:"wasm",setupFunc:function(e){ipe=e.wasm.cwrap(x_,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Pce(i,a,t);if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e)}let f=u.shape.length;FW.assertAxesAreInnerMostDims("min",d,f);let[m,g]=FW.computeOutAndReduceShapes(u.shape,d),y=iR.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==iR.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;ipe(l,yce[i.dtype],y,e)}if(p&&t.disposeData(c.dataId),s){let e=FW.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},dpe=Cce(w_);!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(lpe||(lpe={}));var hpe,ppe={kernelName:k_,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1])),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),d=r.map((e=>e[1])),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return upe(i,u,t.shape.length,yce[t.dtype],h,p,lpe[a],l),o},setupFunc:function(e){upe=e.wasm.cwrap(k_,null,["number","array","number","number","array","array","number","number"])}};function fpe(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=iR.sizeFromShape(n.shape)/o;return 0===iR.sizeFromShape(s.shape)||hpe(a,i,o,l),s}var mpe,gpe={kernelName:g$,backendName:"wasm",setupFunc:function(e){hpe=e.wasm.cwrap(g$,null,["number","number","number","number"])},kernelFunc:fpe};var ype,bpe={kernelName:I_,backendName:"wasm",setupFunc:function(e){mpe=e.wasm.cwrap(I_,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;if("float32"!==a.dtype)throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=o?a:fpe({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[u,c]=l.shape,d=n.makeOutput([u,s],"int32");return mpe(n.dataIdMap.get(l.dataId).id,u,c,s,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(l.dataId),d}},vpe=Cce(S_),xpe=Cce(T_),wpe=Sce(N_);function kpe(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}var Spe,Ipe={kernelName:A_,backendName:"wasm",setupFunc:function(e){ype=e.wasm.cwrap(A_,"number",["number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(l.dataId).id,d=ype(u,c,s,a,i),{pSelectedIndices:h,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=kpe(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",h)}};var Tpe,Npe={kernelName:E_,backendName:"wasm",setupFunc:function(e){Spe=e.wasm.cwrap(E_,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=Spe(c,d,s,a,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=kpe(t,h);return t.wasm._free(m),[t.makeOutput([f],"int32",p),t.makeOutput([],"int32",g)]}};var Cpe,Ape={kernelName:__,backendName:"wasm",setupFunc:function(e){Tpe=e.wasm.cwrap(__,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=Tpe(c,d,s,a,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=kpe(t,h);return t.wasm._free(g),[t.makeOutput([f],"int32",p),t.makeOutput([f],"float32",m)]}},Epe=Cce(C_,0,"bool");var _pe={kernelName:R_,backendName:"wasm",setupFunc:function(e){Cpe=e.wasm.cwrap(R_,null,["number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=n.makeOutput([...a.shape,i],s),c=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(a.dataId).id;return Cpe(d,i,o,l,c),u}};var $pe={kernelName:$_,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}};var Rpe,Dpe={kernelName:D_,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return ihe({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{iR.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),iR.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=ihe({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=vde({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeData(e.dataId))),u}};var Mpe,Fpe={kernelName:M_,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===iR.sizeFromShape(t.shape))return uhe({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),d=r.map((e=>e[1])),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return Rpe(i,u,t.shape.length,yce[t.dtype],h,p,a,l),o},setupFunc:function(e){Rpe=e.wasm.cwrap(M_,null,["number","array","number","number","array","array","number","number"])}},Ope=Cce(O_);var Ppe,Lpe={kernelName:P_,backendName:"wasm",setupFunc:function(e){Mpe=e.wasm.cwrap(P_,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,u=l;"float32"!==l.dtype&&(u=fde({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let c=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return Mpe(o,i,d),"float32"!==l.dtype&&n.disposeData(u.dataId),c}};var zpe,Bpe={kernelName:L_,backendName:"wasm",setupFunc:function(e){Ppe=e.wasm.cwrap(L_,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Pce(i,a,t),f=d;if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=FW.getInnerMostAxes(f.length,u.shape.length))}FW.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=FW.computeOutAndReduceShapes(u.shape,f),y=iR.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==iR.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;Ppe(l,y,yce[b.dtype],e)}if(p&&t.disposeData(c.dataId),s){let e=FW.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},Vpe={kernelName:W_,backendName:"wasm",kernelFunc:e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=Q4(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l}},Wpe=Cce(NE),Upe=Sce(j_),jpe=Sce(G_),Gpe=Sce(Q_);var Hpe,qpe={kernelName:Y_,backendName:"wasm",setupFunc:function(e){zpe=e.wasm.cwrap(Y_,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{images:s}=r,{alignCorners:i,halfPixelCenters:o,size:l}=a,[u,c]=l,[d,h,p,f]=s.shape,m=[d,u,c,f],g=n.dataIdMap.get(s.dataId);"float32"!==g.dtype&&(t=fde({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),g=n.dataIdMap.get(t.dataId));let y=g.id,b=n.makeOutput(m,"float32");if(0===iR.sizeFromShape(s.shape))return b;let v=n.dataIdMap.get(b.dataId).id;return zpe(y,d,h,p,f,u,c,i?1:0,o?1:0,v),null!=t&&n.disposeData(t.dataId),b}};var Kpe,Ype={kernelName:X_,backendName:"wasm",setupFunc:function(e){Hpe=e.wasm.cwrap(X_,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:s,dy:i}=n,{alignCorners:o}=a,l=r.makeOutput(s.shape,"float32"),u=r.dataIdMap.get(s.dataId);return"float32"!==u.dtype&&(t=fde({backend:r,inputs:{x:s},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),Hpe(r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}};var Xpe,Qpe={kernelName:q_,backendName:"wasm",setupFunc:function(e){Kpe=e.wasm.cwrap(q_,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,[c,d,h,p]=a.shape,f=[c,l,u,p],m=t.makeOutput(f,"float32");if(0===iR.sizeFromShape(a.shape))return m;let g,y=t.dataIdMap.get(a.dataId);"float32"!==y.dtype&&(g=fde({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),y=t.dataIdMap.get(g.dataId));let b=y.id,v=t.dataIdMap.get(m.dataId).id;return Kpe(b,c,d,h,p,l,u,s?1:0,i?1:0,v),null!=g&&t.disposeData(g.dataId),m}};var Zpe,Jpe={kernelName:K_,backendName:"wasm",setupFunc:function(e){Xpe=e.wasm.cwrap(K_,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:s,dy:i}=n,{alignCorners:o}=a,l=r.makeOutput(s.shape,"float32"),u=r.dataIdMap.get(s.dataId);return"float32"!==u.dtype&&(t=fde({backend:r,inputs:{x:s},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),Xpe(r.dataIdMap.get(s.dataId).id,r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),o),null!=t&&r.disposeData(t.dataId),l}};var efe,tfe={kernelName:Z_,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=iR.parseAxisParam(s,a.shape);if(0===a.shape.length)return $ce({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(a.shape).buffer);Zpe(l,c,i.length,d,a.shape.length,u);let h=rde({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),h},setupFunc:function(e){Zpe=e.wasm.cwrap(Z_,null,["number","array","number","array","number","number"])}};var nfe,rfe={kernelName:U$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(l.dataId).id,[d,h,p,f]=a.shape,[m,g]=FW.getImageCenter(o,h,p),y="number"==typeof i?[i,i,i,0===i?0:255]:[...i,255],b=new Uint8Array(new Int32Array(y).buffer);return efe(u,d,h,p,f,s,m,g,b,y.length,c),l},setupFunc:function(e){efe=e.wasm.cwrap(U$,null,["number","number","number","number","number","number","number","number","array","number","number"])}},afe=Sce(J_),sfe=Sce(e$);var ife,ofe={kernelName:t$,backendName:"wasm",setupFunc:function(e){nfe=e.wasm.cwrap(t$,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(0===iR.sizeFromShape(i))return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Cz.calculateShapes(s,a,i),p=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return nfe(p,f,yce[s.dtype],l,u,c,m,h,g),o}};var lfe,ufe={kernelName:r$,backendName:"wasm",setupFunc:function(e){ife=e.wasm.cwrap(r$,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r;if(a.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${s.dtype}`);let o=n.makeOutput(s.shape,"int32");function l(e){return n.dataIdMap.get(e.dataId).id}return ife(l(a),l(s),a.shape[0],a.shape[1],s.shape[1],yce[a.dtype],"left"===i,l(o)),o}};var cfe,dfe={kernelName:a$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(a.shape,a.dtype),c=n.dataIdMap.get(u.dataId).id,d=r.shape.length,h=a.shape.length,p=0===d||d>1||1===h?1:iR.sizeFromShape(a.shape.slice(1));return lfe(i,o,l,p,c),u},setupFunc:function(e){lfe=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},hfe=Sce(s$);var pfe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){cfe=e.wasm.cwrap(c$,null,["number","number"])},kernelFunc:function(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return 0===iR.sizeFromShape(a.shape)||cfe(r,s),a}},ffe=Sce(u$),mfe=Sce(o$),gfe=Sce(l$),yfe=Sce(d$);var bfe,vfe={kernelName:f$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=iR.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=Fpe.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=FW.getReshaped(u.shape,s,o,!1),d=FW.getPermuted(c.length,s.length,!1),h=FW.getReshapedPermuted(u.shape,s,o,!1),p=rde({inputs:{x:u},backend:n,attrs:{shape:c}}),f=Mce({inputs:{x:p},backend:n,attrs:{perm:d}}),m=rde({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeData(u.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}};var xfe,wfe={kernelName:y$,backendName:"wasm",setupFunc:function(e){bfe=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r}=e,{indices:a,values:s,denseShape:i,defaultValue:o}=r,l=a.shape[0],u=a.shape[1],c=n.readSync(i.dataId)[0],d=[l+c,u],h=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(s.dataId).id,f=n.dataIdMap.get(o.dataId).id,m=n.makeOutput(d,a.dtype),g=n.dataIdMap.get(m.dataId).id,y=n.makeOutput(d.slice(0,1),s.dtype),b=n.dataIdMap.get(y.dataId).id,v=n.makeOutput([c],"bool"),x=n.dataIdMap.get(v.dataId).id,w=n.makeOutput([l],a.dtype),k=n.dataIdMap.get(w.dataId).id,S=n.makeOutput([4],"int32"),I=n.dataIdMap.get(S.dataId).id,T=bfe(h,p,yce[s.dtype],l,c,u,f,g,b,x,k,I),N=n.readSync(S.dataId);switch(N[0]){case 1:t=FW.getSparseFillEmptyRowsIndicesDenseShapeMismatch(N[1]);break;case 2:t=FW.getSparseFillEmptyRowsNegativeIndexErrorMessage(N[1],N[2]);break;case 3:t=FW.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(N[1],N[2],N[3]);break;default:t=""}if(n.disposeData(S.dataId),t)throw n.disposeData(m.dataId),n.disposeData(y.dataId),n.disposeData(v.dataId),n.disposeData(w.dataId),new Error(t);let C=m,A=y;return T!==d[0]&&(C=ode({inputs:{x:m},attrs:{begin:0,size:[T,u]},backend:n}),A=ode({inputs:{x:y},attrs:{begin:0,size:T},backend:n}),n.disposeData(m.dataId),n.disposeData(y.dataId)),[C,A,v,w]}};var kfe,Sfe={kernelName:b$,backendName:"wasm",setupFunc:function(e){xfe=e.wasm.cwrap(b$,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=r.shape[0],c=iR.sizeFromShape(s.shape),d=t.makeOutput([u,c],r.dtype),h=t.dataIdMap.get(d.dataId).id,p=t.makeOutput([c],s.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;xfe(i,o,l,u,h,f,g);let y,b=t.readSync(m.dataId);switch(b[0]){case 0:y=FW.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break;case 1:y=FW.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break;case 2:y=FW.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(p.dataId));y=FW.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(p.dataId));y=FW.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(d.dataId),t.disposeData(p.dataId),new Error(y);return[d,p]}};function Ife(e){kfe=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Tfe(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(FW.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=a.shape.slice();c[0]=u;let d=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(c,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;kfe(d,yce[a.dtype],a.shape[0],h,p,m,y,t,0);let b,v=n.readSync(g.dataId);switch(v[0]){case 0:b=FW.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:b=FW.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:b=FW.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v[1],v[2]);break;case 3:b=FW.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v[1],v[2],v[3]);break;default:b=""}if(n.disposeData(g.dataId),b)throw n.disposeData(f.dataId),new Error(b);return f}var Nfe={kernelName:v$,backendName:"wasm",setupFunc:Ife,kernelFunc:function(e){return Tfe(e,!0)}};var Cfe,Afe={kernelName:x$,backendName:"wasm",setupFunc:Ife,kernelFunc:function(e){return Tfe(e,!1)}};var Efe={kernelName:w$,backendName:"wasm",setupFunc:function(e){Cfe=e.wasm.cwrap(w$,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(0===iR.sizeFromShape(o))return l;let{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=FW.calculateShapes(s,a,o),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(h).buffer),b=t.dataIdMap.get(l.dataId).id;return Cfe(f,m,s.shape.length,g,yce[i.dtype],u,c,d,y,p,b),l}};var _fe,$fe={kernelName:m$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=iR.parseAxisParam(i,a.shape)[0],l=FW.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{let t=[...c];t[o]=e;let n=ode({inputs:{x:a},attrs:{begin:u,size:t},backend:r});return u[o]+=e,n}))}},Rfe=Sce(h$),Dfe=Sce(S$),Mfe=Cce(k$);var Ffe,Ofe={kernelName:V$,backendName:"wasm",setupFunc:function(e){_fe=e.wasm.cwrap(V$,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return _fe(i,a,yce[s.dtype],l),o}};var Pfe={kernelName:T$,backendName:"wasm",setupFunc:function(e){Ffe=e.wasm.cwrap(T$,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{x:s}=r,{begin:i,end:o,strides:l,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:p}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:v,end:x,strides:w}=uW.sliceInfo(s.shape,i,o,l,u,c,d,h,p);if(g)t=rde({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){iR.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=uW.computeOutShape(v,x,w),r=ode({inputs:{x:s},backend:n,attrs:{begin:v,size:e}});t=rde({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}else{let e=n.makeOutput(f,"float32"),r=n.dataIdMap.get(s.dataId).id,a=new Uint8Array(new Int32Array(iR.computeStrides(s.shape)).buffer),i=new Uint8Array(new Int32Array(v).buffer),o=new Uint8Array(new Int32Array(x).buffer),l=new Uint8Array(new Int32Array(w).buffer),u=new Uint8Array(new Int32Array(f).buffer),c=new Uint8Array(new Int32Array(iR.computeStrides(f)).buffer),d=n.dataIdMap.get(e.dataId).id;Ffe(r,a,s.shape.length,i,o,l,u,c,f.length,d),t=rde({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeData(e.dataId)}return t}};var Lfe={kernelName:N$,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:s}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:d}=r,h=t.readSync(a.dataId),p=t.readSync(s.dataId),[f,m]=k5(h,p,i,o,l,u,c,d),g=t.makeOutput([f.length],"string");t.dataIdMap.get(g.dataId).stringBytes=f;let y=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(y).set(m),[g,y]}};var zfe={kernelName:C$,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:s}=n,{skipEmpty:i}=r,o=t.readSync(a.dataId),l=t.readSync(s.dataId),[u,c,d]=I5(o,l[0],i),h=c.length,p=t.makeOutput([h,2],"int32");t.typedArrayFromHeap(p).set(u);let f=t.makeOutput([h],"string");t.dataIdMap.get(f.dataId).stringBytes=c;let m=t.makeOutput([2],"int32");return t.typedArrayFromHeap(m).set(d),[p,f,m]}};var Bfe,Vfe={kernelName:A$,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:s}=r,i=T5(t.readSync(a.dataId),s),o=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(o).set(i),o}},Wfe=Cce(E$);var Ufe,jfe={kernelName:p$,backendName:"wasm",setupFunc:function(e){Bfe=e.wasm.cwrap(p$,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Pce(i,a,t),f=d;if(p){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=FW.getInnerMostAxes(f.length,u.shape.length))}FW.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=FW.computeOutAndReduceShapes(u.shape,f),y=iR.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==iR.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;Bfe(l,y,yce[b.dtype],e)}if(p&&t.disposeData(c.dataId),s){let e=FW.expandShapeToKeepDim(b.shape,h);b.shape=e}return b}},Gfe=Sce(_$),Hfe=Sce($$);var qfe,Kfe={kernelName:n$,backendName:"wasm",setupFunc:function(e){Ufe=e.wasm.cwrap(n$,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=n,{}=r,o=t.makeOutput(a.shape,a.dtype);if(0===iR.sizeFromShape(a.shape))return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Cz.calculateShapes(i,s,a.shape),p=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),y=t.dataIdMap.get(o.dataId).id;return Ufe(p,f,yce[i.dtype],l,u,c,g,h,y,m),o}};var Yfe,Xfe={kernelName:R$,backendName:"wasm",setupFunc:function(e){qfe=e.wasm.cwrap(R$,null,["number","array","number","array","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let h=0;h<o.length;h++)o[h]=a.shape[h]*i[h];let l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,a.dtype),d=n.dataIdMap.get(c.dataId).id;return qfe(s,l,a.shape.length,u,o.length,yce[c.dtype],d),c}};var Qfe,Zfe={kernelName:D$,backendName:"wasm",setupFunc:function(e){Yfe=e.wasm.cwrap(D$,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=n.dataIdMap.get(a.dataId).id,l=new Uint8Array(new Int32Array(a.shape).buffer),u=a.shape.slice();u[u.length-1]=s;let c=n.makeOutput(u,a.dtype),d=n.dataIdMap.get(c.dataId).id,h=n.makeOutput(u,"int32"),p=n.dataIdMap.get(h.dataId).id;return Yfe(o,l,a.shape.length,yce[a.dtype],s,i,d,p),[c,h]}};var Jfe={kernelName:M$,backendName:"wasm",setupFunc:function(e){Qfe=e.wasm.cwrap(M$,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{image:s,transforms:i}=r,{interpolation:o,fillMode:l,fillValue:u,outputShape:c}=a,[d,h,p,f]=s.shape,[m,g]=null!=c?c:[h,p],y=[d,m,g,f],b=new Uint8Array(new Int32Array(iR.computeStrides(s.shape)).buffer),v=new Uint8Array(new Int32Array(iR.computeStrides(y)).buffer),x=n.makeOutput(y,s.dtype),w=n.dataIdMap.get(x.dataId).id,k=n.dataIdMap.get(s.dataId).id,S=n.dataIdMap.get(i.dataId).id,I="nearest"===o?1:2;switch(l){case"constant":default:t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4}return Qfe(k,S,i.shape[0]>1,d,m,g,f,p,h,b,s.shape.length-1,v,y.length-1,I,t,u,w),x}};var eme={kernelName:O$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t,{outputValues:i,outputShape:o,indices:l}=M5(r.readSync(s.dataId),a,s.shape,s.dtype);return[r.makeOutput(o,s.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}};var tme={kernelName:P$,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),u=0;for(let p=0;p<o;p++)p!==s&&(l[u++]=a.shape[p]);let c=new Array(i),d=new Array(o).fill(0),h=a.shape.slice();h[s]=1;for(let p=0;p<c.length;p++)d[s]=p,c[p]=ode({inputs:{x:a},attrs:{begin:d,size:h},backend:n});return c.map((e=>{let{dataId:t,dtype:n}=e;return{dataId:t,dtype:n,shape:l}}))}};var nme={kernelName:B$,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}},rme=[kce,Ice,Tce,Nce,Ece,_ce,zce,Bce,Uce,jce,Gce,Hce,qce,Kce,Yce,Qce,nde,Jce,tde,ide,cde,dde,hde,pde,gde,yde,bde,wde,Sde,Tde,Cde,Ede,Rde,Dde,Mde,Ode,Lde,Bde,Wde,jde,Hde,Kde,Xde,Zde,ehe,the,nhe,rhe,ahe,she,ohe,lhe,dhe,phe,fhe,mhe,yhe,vhe,whe,She,The,Nhe,Che,Dce,Ahe,Ehe,_he,Rhe,Dhe,Mhe,Ohe,Lhe,Phe,zhe,Bhe,Vhe,Whe,jhe,Hhe,Khe,Yhe,Qhe,Jhe,tpe,rpe,spe,ope,cpe,dpe,ppe,bpe,vpe,xpe,wpe,Ipe,Npe,Ape,Epe,_pe,$pe,Dpe,Fpe,Ope,Lpe,Bpe,Vpe,Wpe,Upe,jpe,Gpe,sde,qpe,Ype,Qpe,Jpe,tfe,rfe,afe,sfe,ofe,ufe,dfe,hfe,pfe,ffe,mfe,gfe,lde,gpe,yfe,vfe,wfe,Sfe,Nfe,Afe,Efe,$fe,Rfe,Dfe,Mfe,Ofe,Pfe,Lfe,zfe,Vfe,Wfe,jfe,Gfe,Hfe,Kfe,Xfe,Zfe,Jfe,Oce,eme,tme,nme];for(let n of rme)eR(n);var ame=IA();ame.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(KR){return!1}})),ame.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(ame.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(KR){return!1}}));var sme=nC(wC()),ime=nC(kC()),ome=nC(SC()),lme=sme.default||sme,ume=ome.default||ome,cme=class extends TC{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(wme),kme=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new IC(this,zD())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=iR.now();return e(),{kernelMs:iR.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if("string"===r){let i=t;return void this.dataIdMap.set(e,{id:s,stringBytes:i,shape:n,dtype:r,memoryOffset:null,refCount:a})}let i=iR.sizeFromShape(n),o=i*iR.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=i.length)?i.slice(t,n):i;t=t||0,n=n||iR.sizeFromShape(s);let o=iR.bytesPerElement(a);return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(r+t*o,r+n*o).buffer,a)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(null==n)a=this.write(null!=r?r:null,e,t);else{let r=this.dataIdNextNumber++;a={id:r},this.dataIdMap.set(a,{id:r,memoryOffset:n,shape:e,dtype:t,refCount:1});let s=iR.sizeFromShape(e);this.wasm.tfjs.registerTensor(r,s,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap(e){let{shape:t,dtype:n,dataId:r}=e,a=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(r),i=iR.sizeFromShape(t);switch(n){case"float32":return new Float32Array(a,s,i);case"int32":return new Int32Array(a,s,i);case"bool":return new Uint8Array(a,s,i);default:throw new Error(`Unknown dtype ${n}`)}}};function dme(e,t,n){if(null!=fme)return fme;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=gme&&null!=gme[r]?gme[r]:n+r}async function hme(){let[e,t]=await Promise.all([IA().getAsync("WASM_HAS_SIMD_SUPPORT"),IA().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{let a={locateFile:(n,r)=>{if(n.endsWith(".worker.js")){let e=ime.wasmWorkerContents.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?dme(e,t,null!=mme?mme:r):r+n}};bme&&(a.instantiateWasm=function(e){return(t,n)=>(iR.fetch(e,{credentials:"same-origin"}).then((r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then((e=>{WebAssembly.instantiate(e,t).then((e=>{n(e.instance,e.module)}))}))})),{})}(dme(e,t,null!=mme?mme:"")));let s,i=!1;a.onAbort=()=>{i||yme||(yme=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==fme?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+lme.toString()],{type:"text/javascript"}),s=lme(a)):s=ume(a),s.then((e=>{i=!0,yme=!1;e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},n({wasm:e})})).catch(r)}))}var pme=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],fme=null,mme=null,gme={},yme=!1,bme=!1;function vme(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(PD("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),yme)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");fme=e,bme=t}function xme(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(yme)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)mme=e;else{gme=e;let t=pme.filter((e=>null==gme[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}bme=t}var wme=-1,kme=-1;function Sme(e){wme=e}function Ime(){if(-1===kme)throw new Error("WASM backend not initialized.");return kme}var Tme="4.16.0";ZD("wasm",(async()=>{let{wasm:e}=await hme();return new cme(e)}),2);var Nme="4.16.0",Cme={tfjs:Nme,"tfjs-core":Nme,"tfjs-converter":"4.16.0","tfjs-backend-cpu":"4.16.0","tfjs-backend-webgl":"4.16.0","tfjs-backend-wasm":"4.16.0"};function Ame(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(e.beginPath(),t.slice(1).forEach(((n,r)=>{let{x:a,y:s}=n,i=t[r];e.moveTo(i.x,i.y),e.lineTo(a,s)})),n){let n=t[t.length-1],r=t[0];if(!n||!r)return;e.moveTo(n.x,n.y),e.lineTo(r.x,r.y)}e.stroke()}qN({},{AnchorPosition:()=>yge,DrawBox:()=>wge,DrawBoxOptions:()=>xge,DrawFaceLandmarks:()=>uye,DrawFaceLandmarksOptions:()=>lye,DrawTextField:()=>vge,DrawTextFieldOptions:()=>bge,drawContour:()=>Ame,drawDetections:()=>kge,drawFaceExpressions:()=>sye,drawFaceLandmarks:()=>cye});qN({},{computeReshapedDimensions:()=>zme,getCenterPoint:()=>Bme,isDimensions:()=>Lme,isEven:()=>Ome,isFloat:()=>Fme,isTensor:()=>_me,isTensor1D:()=>$me,isTensor2D:()=>Rme,isTensor3D:()=>Dme,isTensor4D:()=>Mme,isValidNumber:()=>Wme,isValidProbablitiy:()=>Ume,range:()=>Vme,round:()=>Pme});var Eme=class e{constructor(e,t){if(!Wme(e)||!Wme(t))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:t})}`);this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new e(1/this.width,1/this.height)}};function _me(e,t){return e instanceof jR&&e.shape.length===t}function $me(e){return _me(e,1)}function Rme(e){return _me(e,2)}function Dme(e){return _me(e,3)}function Mme(e){return _me(e,4)}function Fme(e){return e%1!==0}function Ome(e){return e%2===0}function Pme(e){let t=10**(arguments.length>1&&void 0!==arguments[1]?arguments[1]:2);return Math.floor(e*t)/t}function Lme(e){return e&&e.width&&e.height}function zme(e,t){let{width:n,height:r}=e,a=t/Math.max(r,n);return new Eme(Math.round(n*a),Math.round(r*a))}function Bme(e){return e.reduce(((e,t)=>e.add(t)),new jme(0,0)).div(new jme(e.length,e.length))}function Vme(e,t,n){return Array(e).fill(0).map(((e,r)=>t+r*n))}function Wme(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||0===e}function Ume(e){return Wme(e)&&e>=0&&e<=1}var jme=class e{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(t){return new e(this.x+t.x,this.y+t.y)}sub(t){return new e(this.x-t.x,this.y-t.y)}mul(t){return new e(this.x*t.x,this.y*t.y)}div(t){return new e(this.x/t.x,this.y/t.y)}abs(){return new e(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new e(Math.floor(this.x),Math.floor(this.y))}},Gme=class e{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every(Wme)}static assertIsValidBox(t,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!e.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t){let n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=t||{},a=[r.left,r.top,r.right,r.bottom].every(Wme),s=[r.x,r.y,r.width,r.height].every(Wme);if(!s&&!a)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[i,o,l,u]=s?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];e.assertIsValidBox({x:i,y:o,width:l,height:u},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new jme(this.left,this.top)}get topRight(){return new jme(this.right,this.top)}get bottomLeft(){return new jme(this.left,this.bottom)}get bottomRight(){return new jme(this.right,this.bottom)}round(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map((e=>Math.round(e)));return new e({x:t,y:n,width:r,height:a})}floor(){let[t,n,r,a]=[this.x,this.y,this.width,this.height].map((e=>Math.floor(e)));return new e({x:t,y:n,width:r,height:a})}toSquare(){let{x:t,y:n,width:r,height:a}=this,s=Math.abs(r-a);return r<a&&(t-=s/2,r+=s),a<r&&(n-=s/2,a+=s),new e({x:t,y:n,width:r,height:a})}rescale(t){let n=Lme(t)?t.width:t,r=Lme(t)?t.height:t;return new e({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,a,s,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new e({x:r,y:a,width:s,height:i})}clipAtImageBorders(t,n){let{x:r,y:a,right:s,bottom:i}=this,o=Math.max(r,0),l=Math.max(a,0),u=s-o,c=i-l,d=Math.min(u,t-o),h=Math.min(c,n-l);return new e({x:o,y:l,width:d,height:h}).floor()}shift(t,n){let{width:r,height:a}=this,s=this.x+t,i=this.y+n;return new e({x:s,y:i,width:r,height:a})}padAtBorders(e,t){let n=this.width+1,r=this.height+1,a=n,s=r,i=this.left,o=this.top,l=this.right,u=this.bottom;return l>t&&(a=-l+t+n,l=t),u>e&&(s=-u+e+r,u=e),i<1&&(s=2-i,i=1),o<1&&(s=2-o,o=1),{dy:1,edy:s,dx:1,edx:a,y:o,ey:u,x:i,ex:l,w:n,h:r}}calibrate(t){return new e({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},Hme=class extends Gme{constructor(e,t,n,r){super({left:e,top:t,right:n,bottom:r},arguments.length>4&&void 0!==arguments[4]&&arguments[4])}},qme=class e{constructor(e,t,n,r,a){this._imageDims=new Eme(a.width,a.height),this._score=e,this._classScore=t,this._className=n,this._box=new Gme(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Gme(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new e(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},Kme=class e extends qme{constructor(e,t,n){super(e,e,"",t,n)}forSize(t,n){let{score:r,relativeBox:a,imageDims:s}=super.forSize(t,n);return new e(r,a,s)}};function Yme(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left))*Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top));return n?r/(e.area+t.area-r):r/Math.min(e.area,t.area)}function Xme(e,t){return WD((()=>{let[n,r,a]=t,s=tO([...e.shape.slice(0,3),1],n,"float32"),i=tO([...e.shape.slice(0,3),1],r,"float32"),o=tO([...e.shape.slice(0,3),1],a,"float32"),l=LF([s,i,o],3);return _P(e,l)}))}function Qme(e){return 1/(1+Math.exp(-e))}var Zme,Jme=class extends Gme{constructor(e,t,n,r){super({x:e,y:t,width:n,height:r},arguments.length>4&&void 0!==arguments[4]&&arguments[4])}},ege=class{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new jme(0,0),{width:r,height:a}=t;this._imgDims=new Eme(r,a),this._shift=n,this._positions=e.map((e=>e.mul(new jme(r,a)).add(n)))}get shift(){return new jme(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map((e=>e.sub(this._shift).div(new jme(this.imageWidth,this.imageHeight))))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new jme(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(e){let n=e instanceof Kme?e.box.floor():new Gme(e);return this.shiftBy(n.x,n.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=e=>r.sub(e).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/.45),o=Bme(e),l=Math.floor(Math.max(0,o.x-.5*i)),u=Math.floor(Math.max(0,o.y-.43*i));return new Jme(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=function(e){let t=e.map((e=>e.x)),n=e.map((e=>e.y)),r=t.reduce(((e,t)=>t<e?t:e),1/0),a=n.reduce(((e,t)=>t<e?t:e),1/0),s=t.reduce(((e,t)=>e<t?t:e),0),i=n.reduce(((e,t)=>e<t?t:e),0);return new Hme(r,a,s,i)}(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},tge=class extends ege{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(Bme)}},nge=class{constructor(e,t){this._label=e,this._distance=t}get label(){return this._label}get distance(){return this._distance}toString(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return`${this.label}${e?` (${Pme(this.distance)})`:""}`}},rge=class e{constructor(e,t){if("string"!=typeof e)throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(t)||t.some((e=>!(e instanceof Float32Array))))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=e,this._descriptors=t}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map((e=>Array.from(e)))}}static fromJSON(t){let n=t.descriptors.map((e=>new Float32Array(e)));return new e(t.label,n)}};function age(e){return e.detection instanceof Kme}function sge(e,t){return{...e,detection:t}}function ige(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D:CanvasRenderingContext2D,Image:HTMLImageElement,ImageData:ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function oge(){return"object"==typeof n.g&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node}function lge(e){let t="";if(!e&&oge())try{e=HN("fs")}catch(n){t=n.toString()}return{readFile:e?t=>new Promise(((n,r)=>{e.readFile(t,((e,t)=>e?r(e):n(t)))})):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function uge(){let e=n.g.Canvas||n.g.HTMLCanvasElement,t=n.g.Image||n.g.HTMLImageElement,r=n.g.Video||n.g.HTMLVideoElement,a=n.g.fetch,s=lge();return{Canvas:e||class{},CanvasRenderingContext2D:n.g.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:n.g.ImageData||class{},Video:n.g.HTMLVideoElement||class{},createCanvasElement:()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},createImageElement:()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},createVideoElement:()=>{if(r)return new r;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},fetch:a,...s}}function cge(){return"object"==typeof window&&"undefined"!=typeof document&&"undefined"!=typeof HTMLImageElement&&"undefined"!=typeof HTMLCanvasElement&&"undefined"!=typeof HTMLVideoElement&&"undefined"!=typeof ImageData&&"undefined"!=typeof CanvasRenderingContext2D}function dge(e){Zme=e}function hge(){return cge()?dge(ige()):oge()?dge(uge()):null}var pge={getEnv:function(){if(!Zme)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Zme},setEnv:dge,initialize:hge,createBrowserEnv:ige,createFileSystem:lge,createNodejsEnv:uge,monkeyPatch:function(e){if(Zme||hge(),!Zme)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Zme.Canvas,Image:n=Zme.Image}=e;Zme.Canvas=t,Zme.Image=n,Zme.createCanvasElement=e.createCanvasElement||(()=>new t),Zme.createImageElement=e.createImageElement||(()=>new n),Zme.ImageData=e.ImageData||Zme.ImageData,Zme.Video=e.Video||Zme.Video,Zme.fetch=e.fetch||Zme.fetch,Zme.readFile=e.readFile||Zme.readFile},isBrowser:cge,isNodejs:oge};function fge(e){return pge.isNodejs()||"string"!=typeof e?e:document.getElementById(e)}function mge(e){let{Canvas:t,CanvasRenderingContext2D:n}=pge.getEnv();if(e instanceof n)return e;let r=fge(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d",{willReadFrequently:!0});if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}hge();var gge,yge=((gge=yge||{}).TOP_LEFT="TOP_LEFT",gge.TOP_RIGHT="TOP_RIGHT",gge.BOTTOM_LEFT="BOTTOM_LEFT",gge.BOTTOM_RIGHT="BOTTOM_RIGHT",gge),bge=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},vge=class e{constructor(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.text="string"==typeof t?[t]:t instanceof e?t.text:t,this.anchor=n,this.options=new bge(r)}measureWidth(e){let{padding:t}=this.options;return this.text.map((t=>e.measureText(t).width)).reduce(((e,t)=>e<t?t:e),0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,r="BOTTOM_RIGHT"===n||"TOP_RIGHT"===n,a="BOTTOM_LEFT"===n||"BOTTOM_RIGHT"===n,s=this.measureWidth(e),i=this.measureHeight(),o=r?this.anchor.x-s:this.anchor.x,l=a?this.anchor.y-i:this.anchor.y;if(t){let{width:e,height:n}=t;return{x:Math.max(Math.min(o,e-s),0),y:Math.max(Math.min(l,n-i),0)}}return{x:o,y:l}}draw(e){let t=fge(e),n=mge(t),{backgroundColor:r,fontColor:a,fontSize:s,fontStyle:i,padding:o}=this.options;n.font=`${s}px ${i}`;let l=this.measureWidth(n),u=this.measureHeight();n.fillStyle=r;let c=this.getUpperLeft(n,t);n.fillRect(c.x,c.y,l,u),n.fillStyle=a,this.text.forEach(((e,t)=>{let r=o+c.x,a=o+c.y+(t+1)*s;n.fillText(e,r,a)}))}},xge=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new bge({...s,...a})}},wge=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.box=new Gme(e),this.options=new xge(t)}draw(e){let t=mge(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new vge([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function kge(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof Kme?t.score:age(t)?t.detection.score:void 0,r=t instanceof Kme?t.box:age(t)?t.detection.box:new Gme(t),a=n?`${Pme(n)}`:void 0;new wge(r,{label:a}).draw(e)}))}function Sge(e){let{Image:t,Video:n}=pge.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function Ige(e){let{Image:t,Video:n}=pge.getEnv();return e instanceof t?new Eme(e.naturalWidth,e.naturalHeight):e instanceof n?new Eme(e.videoWidth,e.videoHeight):new Eme(e.width,e.height)}function Tge(e){let{width:t,height:n}=e,{createCanvasElement:r}=pge.getEnv(),a=r();return a.width=t,a.height=n,a}function Nge(e,t){let{ImageData:n}=pge.getEnv();if(!(e instanceof n)&&!Sge(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||Ige(e),s=Tge({width:r,height:a});return e instanceof n?mge(s).putImageData(e,0,0):mge(s).drawImage(e,0,0,r,a),s}function Cge(e){let{Image:t,Canvas:n,Video:r}=pge.getEnv();return e instanceof t||e instanceof n||e instanceof r}var Age=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach(((e,t)=>{if(Dme(e))return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape);if(Mme(e)){let n=e.shape[0];if(1!==n)throw new Error(`NetInput - tf.Tensor4D with batchSize ${n} passed, but not supported in input array`);return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape.slice(1))}let n=e instanceof pge.getEnv().Canvas?e:Nge(e);this._canvases[t]=n,this._inputDimensions[t]=[n.height,n.width,3]}))}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return Vme(this.batchSize,0,1).map(((e,t)=>this.getReshapedInputDimensions(t)))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if("number"!=typeof this.inputSize)throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");return zme({width:this.getInputWidth(e),height:this.getInputHeight(e)},this.inputSize)}toBatchTensor(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return this._inputSize=e,WD((()=>{let n=Vme(this.batchSize,0,1).map((n=>{let r=this.getInput(n);if(r instanceof jR){let n=Mme(r)?r:tP(r);return n=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return WD((()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=t=>{let n=e.shape.slice();return n[i]=t,tO(n,0,"float32")},l=o(s),u=a-l.shape[i],c=[t&&u?o(u):null,e,l].filter((e=>!!e)).map((e=>eF(e,"float32")));return LF(c,i)}))}(n,t),(n.shape[1]!==e||n.shape[2]!==e)&&(n=oV.resizeBilinear(n,[e,e],!1,!1)),n.as3D(e,e,3)}if(r instanceof pge.getEnv().Canvas)return QV.fromPixels(function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{Image:r,Canvas:a}=pge.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return Tge({width:1,height:1});let s=Ige(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,u=Tge({width:t,height:t}),c=e instanceof a?e:Nge(e),d=Math.abs(o-l)/2,h=n&&o<l?d:0,p=n&&l<o?d:0;return c.width>0&&c.height>0&&mge(u).drawImage(c,h,p,o,l),u}(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${n}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)}));return yz(n.map((e=>eF(e,"float32")))).as4D(this.batchSize,e,e,3)}))}};async function Ege(e){if(e instanceof Age)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=t=>Array.isArray(e)?` at input index ${t}:`:"",r=t.map(fge);return r.forEach(((e,r)=>{if(!Cge(e)&&!Dme(e)&&!Mme(e))throw"string"==typeof t[r]?new Error(`toNetInput -${n(r)} string passed, but could not resolve HTMLElement for element id ${t[r]}`):new Error(`toNetInput -${n(r)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(Mme(e)){let t=e.shape[0];if(1!==t)throw new Error(`toNetInput -${n(r)} tf.Tensor4D with batchSize ${t} passed, but not supported in input array`)}})),await Promise.all(r.map((e=>Cge(e)&&function(e){return new Promise(((t,n)=>{function r(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),n(e))}function a(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),t(e))}(e instanceof pge.getEnv().Canvas||Sge(e))&&t(null),e.addEventListener("load",a),e.addEventListener("error",r)}))}(e)))),new Age(r,Array.isArray(e))}async function _ge(e,t){let{Canvas:n}=pge.getEnv(),r=e;if(!(e instanceof n)){let t=await Ege(e);if(t.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let a=t.getInput(0);r=a instanceof n?a:await async function(e,t){let n=t||pge.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(Mme(e)?1:0),i=WD((()=>e.as3D(r,a,s).toInt()));return await QV.toPixels(i,n),i.dispose(),n}(a)}let a=mge(r);return t.map((e=>e instanceof Kme?e.forSize(r.width,r.height).box.floor():e)).map((e=>e.clipAtImageBorders(r.width,r.height))).map((e=>{let{x:t,y:n,width:r,height:s}=e,i=Tge({width:r,height:s});return r>0&&s>0&&mge(i).putImageData(a.getImageData(t,n,r,s),0,0),i}))}async function $ge(e,t){if(!Dme(e)&&!Mme(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(Mme(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return WD((()=>{let[n,r,a]=e.shape.slice(Mme(e)?1:0);return t.map((e=>e instanceof Kme?e.forSize(r,n).box:e)).map((e=>e.clipAtImageBorders(r,n))).filter((e=>e.width>0&&e.height>0)).map((t=>{let{x:s,y:i,width:o,height:l}=t;return oz(e.as3D(n,r,a),[i,s,0],[l,o,a])}))}))}async function Rge(e,t){let{fetch:n}=pge.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function Dge(e){let t=await Rge(e),n=await t.blob();if(!n.type.startsWith("image/"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return function(e){return new Promise(((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let r=new FileReader;r.onload=()=>{"string"!=typeof r.result&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let e=pge.getEnv().createImageElement();e.onload=()=>t(e),e.onerror=n,e.src=r.result},r.onerror=n,r.readAsDataURL(e)}))}(n)}function Mge(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if("/"===e)return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"",a=(e=e.replace(r,"")).split("/").filter((e=>e)),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:"/"===i?`/${s}`:`${i}/${s}`}}async function Fge(e,t){let{manifestUri:n,modelBaseUri:r}=Mge(e,t),a=await async function(e){return(await Rge(e)).json()}(n);return AV.loadWeights(a,r)}var Oge=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map((e=>{let{paramPath:t}=e;return{path:t,tensor:this.getParamFromPath(t)}}))}getTrainableParams(){return this.getParamList().filter((e=>e.tensor instanceof HR))}getFrozenParams(){return this.getParamList().filter((e=>!(e.tensor instanceof HR)))}variable(){this.getFrozenParams().forEach((e=>{let{path:t,tensor:n}=e;this.reassignParamFromPath(t,n.variable())}))}freeze(){this.getTrainableParams().forEach((e=>{let{path:t,tensor:n}=e,r=$D(n.dataSync());n.dispose(),this.reassignParamFromPath(t,r)}))}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.getParamList().forEach((t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()})),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map((e=>{let{tensor:t}=e;return Array.from(t.dataSync())})).reduce(((e,t)=>e.concat(t))))}async load(e){e instanceof Float32Array?this.extractWeights(e):await this.loadFromUri(e)}async loadFromUri(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await Fge(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=pge.getEnv(),{manifestUri:n,modelBaseUri:r}=Mge(e,this.getDefaultModelName()),a=AV.weightsLoaderFactory((e=>Promise.all(e.map((e=>t(e).then((e=>"string"==typeof e?Buffer.from(e):e.buffer))))))),s=JSON.parse((await t(n)).toString()),i=await a(s,r);this.loadFromWeightMap(i)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce(((t,n)=>{if(!t.nextObj.hasOwnProperty(n))throw new Error(`traversePropertyPath - object does not have property ${n}, for path ${e}`);return{obj:t.nextObj,objProp:n,nextObj:t.nextObj[n]}}),{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof jR))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function Pge(e,t,n){return WD((()=>{let r=ez(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=rF(r,t.bias),r}))}function Lge(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return WD((()=>{let r=jL(n?rF(oO(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):Pge(e,t.conv0,[2,2])),a=Pge(r,t.conv1,[1,1]),s=Pge(jL(rF(r,a)),t.conv2,[1,1]);return jL(rF(r,rF(a,s)))}))}function zge(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];return WD((()=>{let a=jL(n?rF(oO(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):Pge(e,t.conv0,r?[2,2]:[1,1])),s=Pge(a,t.conv1,[1,1]),i=Pge(jL(rF(a,s)),t.conv2,[1,1]),o=Pge(jL(rF(a,rF(s,i))),t.conv3,[1,1]);return jL(rF(a,rF(s,rF(i,o))))}))}function Bge(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"same",r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];return WD((()=>{let a=rF(oO(e,t.filters,[1,1],n),t.bias);return r?jL(a):a}))}function Vge(e,t){Object.keys(e).forEach((n=>{t.some((e=>e.originalPath===n))||e[n].dispose()}))}function Wge(e,t){return(n,r,a,s)=>{let i=Iz(e(n*r*a*a),[a,a,n,r]),o=wz(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function Uge(e,t){return(n,r,a)=>{let s=kz(e(n*r),[n,r]),i=wz(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var jge=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function Gge(e,t){return(n,r,a)=>{let s=Iz(e(9*n),[3,3,n,1]),i=Iz(e(n*r),[1,1,n,r]),o=wz(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new jge(s,i,o)}}function Hge(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new jge(n,r,a)}}function qge(e,t){return(n,r,a)=>{let s=e[n];if(!_me(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function Kge(e){let t=e;return{extractWeights:function(e){let n=t.slice(0,e);return t=t.slice(e),n},getRemainingWeights:function(){return t}}}function Yge(e,t){let n=Wge(e,t),r=Gge(e,t);function a(e,t,a){return{conv0:arguments.length>3&&void 0!==arguments[3]&&arguments[3]?n(e,t,3,`${a}/conv0`):r(e,t,`${a}/conv0`),conv1:r(t,t,`${a}/conv1`),conv2:r(t,t,`${a}/conv2`)}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:function(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],{conv0:i,conv1:o,conv2:l}=a(e,t,n,s);return{conv0:i,conv1:o,conv2:l,conv3:r(t,t,`${n}/conv3`)}}}}function Xge(e){return t=>({filters:e(`${t}/filters`,4),bias:e(`${t}/bias`,1)})}function Qge(e,t){let n=qge(e,t),r=Xge(n),a=Hge(n);return{extractDenseBlock3Params:function(e){return{conv0:arguments.length>1&&void 0!==arguments[1]&&arguments[1]?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`)}},extractDenseBlock4Params:function(e){return{conv0:arguments.length>1&&void 0!==arguments[1]&&arguments[1]?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`),conv3:a(`${e}/conv3`)}}}}var Zge=class extends Oge{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return WD((()=>{let n=zge(Xme(eF(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=zge(n,t.dense1),n=zge(n,t.dense2),n=zge(n,t.dense3),n=OF(n,[7,7],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await Ege(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock4Params:n}=Qge(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Vge(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Kge(e),{extractDenseBlock4Params:a}=Yge(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}(e)}};function Jge(e,t){return WD((()=>rF(zF(e,t.weights),t.bias)))}function eye(e){let t={},n={};return Object.keys(e).forEach((r=>{(r.startsWith("fc")?n:t)[r]=e[r]})),{featureExtractorMap:t,classifierMap:n}}var tye=class extends Oge{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return WD((()=>{let n=e instanceof Age?this.faceFeatureExtractor.forwardInput(e):e;return Jge(n.as2D(n.shape[0],-1),t.fc)}))}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=Kge(e),i=Uge(a,r)(t,n,"fc");if(0!==s().length)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=eye(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=qge(e,t),r={fc:(a="fc",{weights:n(`${a}/weights`,2),bias:n(`${a}/bias`,1)})};var a;return Vge(e,t),{params:r,paramMappings:t}}(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},nye=["neutral","happy","sad","angry","fearful","disgusted","surprised"],rye=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,7!==e.length)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);nye.forEach(((t,n)=>{this[t]=e[n]}))}asSortedArray(){return nye.map((e=>({expression:e,probability:this[e]}))).sort(((e,t)=>t.probability-e.probability))}};function aye(e,t){return{...e,expressions:t}}function sye(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,r=arguments.length>3?arguments[3]:void 0;(Array.isArray(t)?t:[t]).forEach((t=>{let a=t instanceof rye?t:function(e){return e.expressions instanceof rye}(t)?t.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let s=a.asSortedArray().filter((e=>e.probability>n)),i=age(t)?t.detection.box.bottomLeft:r||new jme(0,0);new vge(s.map((e=>`${e.expression} (${Pme(e.probability)})`)),i).draw(e)}))}function iye(e){return age(e)&&e.landmarks instanceof ege&&e.unshiftedLandmarks instanceof ege&&e.alignedRect instanceof Kme}function oye(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new Kme(e.detection.score,a.rescale(s.reverse()),s),o=function(e){let t=e=>180*e/Math.PI,n=(e,t)=>Math.sqrt((e.x-t.x)**2+(e.y-t.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0};if(!e||!e.positions||68!==e.positions.length)return r;let a=e.positions;return r.roll=((e,n)=>{let r=Math.hypot(n.x-e.x,n.y-e.y),a=n.y-e.y,s=Math.asin(a/r),i=t(s);return Math.floor(90-i)*(n.x-e.x<0?-1:1)})(a[27],a[66]),r.pitch=((e,r,a)=>{let s=n(e,a),i=new jme((e.x+a.x)/2,(e.y+a.y)/2),o=n(r,i),l=Math.atan(o/s);return Math.floor(t(l))*(i.y-r.y<0?-1:1)})(a[14],a[30],a[2]),r.yaw=((e,t,n)=>Math.floor(e.x-t.x)-Math.floor(t.x-n.x))(a[14],a[33],a[2]),r}(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var lye=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},uye=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.faceLandmarks=e,this.options=new lye(t)}draw(e){let t=mge(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof tge&&(t.strokeStyle=s,t.lineWidth=a,Ame(t,this.faceLandmarks.getJawOutline()),Ame(t,this.faceLandmarks.getLeftEyeBrow()),Ame(t,this.faceLandmarks.getRightEyeBrow()),Ame(t,this.faceLandmarks.getNose()),Ame(t,this.faceLandmarks.getLeftEye(),!0),Ame(t,this.faceLandmarks.getRightEye(),!0),Ame(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let e=e=>{t.beginPath(),t.arc(e.x,e.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(e)}}};function cye(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof ege?t:iye(t)?t.landmarks:void 0;if(!n)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new uye(n).draw(e)}))}function dye(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=Kge(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=function(e,t){let n=Wge(e,t),r=Gge(e,t);return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:function(e,t,a){return{separable_conv0:r(e,t,`${a}/separable_conv0`),separable_conv1:r(t,t,`${a}/separable_conv1`),expansion_conv:n(e,t,1,`${a}/expansion_conv`)}},extractMainBlockParams:function(e,t){return{separable_conv0:r(e,e,`${t}/separable_conv0`),separable_conv1:r(e,e,`${t}/separable_conv1`),separable_conv2:r(e,e,`${t}/separable_conv2`)}}}}(r,n),u={conv_in:s(3,32,3,"entry_flow/conv_in"),reduction_block_0:o(32,64,"entry_flow/reduction_block_0"),reduction_block_1:o(64,128,"entry_flow/reduction_block_1")},c={};Vme(t,0,1).forEach((e=>{c[`main_block_${e}`]=l(128,`middle_flow/main_block_${e}`)}));let d={reduction_block:o(128,256,"exit_flow/reduction_block"),separable_conv:i(256,512,"exit_flow/separable_conv")};if(0!==a().length)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:u,middle_flow:c,exit_flow:d}}}function hye(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=function(e,t){let n=qge(e,t),r=Xge(n),a=Hge(n);return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),expansion_conv:r(`${e}/expansion_conv`)}},extractMainBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),separable_conv2:a(`${e}/separable_conv2`)}}}}(e,n),o={conv_in:r("entry_flow/conv_in"),reduction_block_0:s("entry_flow/reduction_block_0"),reduction_block_1:s("entry_flow/reduction_block_1")},l={};Vme(t,0,1).forEach((e=>{l[`main_block_${e}`]=i(`middle_flow/main_block_${e}`)}));let u={reduction_block:s("exit_flow/reduction_block"),separable_conv:a("exit_flow/separable_conv")};return Vge(e,n),{params:{entry_flow:o,middle_flow:l,exit_flow:u},paramMappings:n}}function pye(e,t,n){return rF(oO(e,t.filters,n,"same"),t.bias)}function fye(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?jL(e):e;return n=Pge(n,t.separable_conv0,[1,1]),n=Pge(jL(n),t.separable_conv1,[1,1]),n=BP(n,[3,3],[2,2],"same"),n=rF(n,pye(e,t.expansion_conv,[2,2])),n}var mye=class extends Oge{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return WD((()=>{let n=Xme(eF(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),r=jL(pye(n,t.entry_flow.conv_in,[2,2]));return r=fye(r,t.entry_flow.reduction_block_0,!1),r=fye(r,t.entry_flow.reduction_block_1),Vme(this._numMainBlocks,0,1).forEach((e=>{r=function(e,t){let n=Pge(jL(e),t.separable_conv0,[1,1]);return n=Pge(jL(n),t.separable_conv1,[1,1]),n=Pge(jL(n),t.separable_conv2,[1,1]),n=rF(n,e),n}(r,t.middle_flow[`main_block_${e}`])})),r=fye(r,t.exit_flow.reduction_block),r=jL(Pge(r,t.exit_flow.separable_conv,[1,1])),r}))}async forward(e){return this.forwardInput(await Ege(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return hye(e,this._numMainBlocks)}extractParams(e){return dye(e,this._numMainBlocks)}};var gye,yye=((gye=yye||{}).FEMALE="female",gye.MALE="male",gye),bye=class extends tye{postProcess(e,t,n){let r=n.map((e=>{let{width:n,height:r}=e,a=t/Math.max(r,n);return{width:n*a,height:r*a}})),a=r.length;return WD((()=>{let n=(e,t)=>yz([tO([68],e,"float32"),tO([68],t,"float32")],1).as2D(1,136).as1D(),s=(e,t)=>{let{width:n,height:a}=r[e];return t(n,a)?Math.abs(n-a)/2:0};return e.mul(tO([a,136],t,"float32")).sub(yz(Array.from(Array(a),((e,t)=>n((e=>s(e,((e,t)=>e<t)))(t),(e=>s(e,((e,t)=>t<e)))(t)))))).div(yz(Array.from(Array(a),((e,t)=>n(r[t].width,r[t].height)))))}))}forwardInput(e){return WD((()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map((e=>{let[t,n]=e;return{height:t,width:n}})))}))}async forward(e){return this.forwardInput(await Ege(e))}async detectLandmarks(e){let t=await Ege(e),n=WD((()=>Oz(this.forwardInput(t)))),r=await Promise.all(n.map((async(e,n)=>{let r=Array.from(e.dataSync()),a=r.filter(((e,t)=>Ome(t))),s=r.filter(((e,t)=>!Ome(t)));return new tge(Array(68).fill(0).map(((e,t)=>new jme(a[t],s[t]))),{height:t.getInputHeight(n),width:t.getInputWidth(n)})})));return n.forEach((e=>e.dispose())),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},vye=class extends bye{constructor(){super("FaceLandmark68Net",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Zge)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};var xye=class extends Oge{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return WD((()=>{let n=Lge(Xme(eF(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=Lge(n,t.dense1),n=Lge(n,t.dense2),n=OF(n,[14,14],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await Ege(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock3Params:n}=Qge(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Vge(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Kge(e),{extractDenseBlock3Params:a}=Yge(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}(e)}};function wye(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"same",{filters:s,bias:i}=t.conv,o=oO(e,s,n,a);return o=rF(o,i),o=function(e,t){return rF(iF(e,t.weights),t.biases)}(o,t.scale),r?jL(o):o}function kye(e,t){return wye(e,t,[1,1],!1)}function Sye(e,t){return wye(e,t,[2,2],!0,"valid")}function Iye(e,t){function n(n,r,a,s){let i=function(t,n,r){let a=e(t),s=a.length/(n*r*r);if(Fme(s))throw new Error(`depth has to be an integer: ${s}, weights.length: ${a.length}, numFilters: ${n}, filterSize: ${r}`);return WD((()=>Wz(Iz(a,[n,s,r,r]),[2,3,1,0])))}(n,r,a),o=wz(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}function r(r,a,s,i){let o=n(r,a,s,`${i}/conv`),l=function(n,r){let a=wz(e(n)),s=wz(e(n));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/biases`}),{weights:a,biases:s}}(a,`${i}/scale`);return{conv:o,scale:l}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e,t,n,a){return{conv1:r((arguments.length>4&&void 0!==arguments[4]&&arguments[4]?.5:1)*e,t,n,`${a}/conv1`),conv2:r(e,t,n,`${a}/conv2`)}}}}function Tye(e,t){let n=qge(e,t);function r(e){let t=n(`${e}/conv/filters`,4),r=n(`${e}/conv/bias`,1),a=function(e){return{weights:n(`${e}/scale/weights`,1),biases:n(`${e}/scale/biases`,1)}}(e);return{conv:{filters:t,bias:r},scale:a}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e){return{conv1:r(`${e}/conv1`),conv2:r(`${e}/conv2`)}}}}function Nye(e,t){let n=function(e,t){return wye(e,t,[1,1],!0)}(e,t.conv1);return n=kye(n,t.conv2),n=rF(n,e),n=jL(n),n}function Cye(e,t){let n=Sye(e,t.conv1);n=kye(n,t.conv2);let r=OF(e,2,2,"valid"),a=GP(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let e=[...n.shape];e[1]=1;let t=GP(e);n=LF([n,t],1);let r=[...n.shape];r[2]=1;let a=GP(r);n=LF([n,a],2)}return r=s?LF([r,a],3):r,n=rF(r,n),n=jL(n),n}var Aye=class extends Oge{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return WD((()=>{let n=Sye(Xme(eF(e.toBatchTensor(150,!0),"float32"),[122.782,117.001,104.298]).div(255),t.conv32_down);n=BP(n,3,2,"valid"),n=Nye(n,t.conv32_1),n=Nye(n,t.conv32_2),n=Nye(n,t.conv32_3),n=Cye(n,t.conv64_down),n=Nye(n,t.conv64_1),n=Nye(n,t.conv64_2),n=Nye(n,t.conv64_3),n=Cye(n,t.conv128_down),n=Nye(n,t.conv128_1),n=Nye(n,t.conv128_2),n=Cye(n,t.conv256_down),n=Nye(n,t.conv256_1),n=Nye(n,t.conv256_2),n=Cye(n,t.conv256_down_out);let r=n.mean([1,2]);return zF(r,t.fc)}))}async forward(e){return this.forwardInput(await Ege(e))}async computeFaceDescriptor(e){var t;if(null!=(t=null==e?void 0:e.shape)&&t.some((e=>e<=0)))return new Float32Array(128);let n=await Ege(e),r=WD((()=>Oz(this.forwardInput(n)))),a=await Promise.all(r.map((e=>e.data())));return r.forEach((e=>e.dispose())),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=Tye(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),c=r("conv64_2"),d=r("conv64_3"),h=r("conv128_down"),p=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:v}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!Rme(v))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${v}`);let x={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:c,conv64_3:d,conv128_down:h,conv128_1:p,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:v};return Vge(e,t),{params:x,paramMappings:t}}(e)}extractParams(e){return function(e){let{extractWeights:t,getRemainingWeights:n}=Kge(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=Iye(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),u=s(9216,32,3,"conv32_3"),c=s(36864,64,3,"conv64_down",!0),d=s(36864,64,3,"conv64_1"),h=s(36864,64,3,"conv64_2"),p=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),v=s(589824,256,3,"conv256_2"),x=s(589824,256,3,"conv256_down_out"),w=WD((()=>Wz(kz(t(32768),[128,256]),[1,0])));if(r.push({paramPath:"fc"}),0!==n().length)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:c,conv64_1:d,conv64_2:h,conv64_3:p,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:v,conv256_down_out:x,fc:w},paramMappings:r}}(e)}};function Eye(e,t){return{...e,descriptor:t}}function _ye(e,t){return{...e,age:t}}function $ye(e,t,n){return{...e,gender:t,genderProbability:n}}function Rye(e,t){function n(n,r,a,s,i){let o=Iz(e(n*r*a*a),[a,a,n,r]),l=wz(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/${i?"batch_norm_offset":"bias"}`}),{filters:o,bias:l}}function r(e,t,r,a){let{filters:s,bias:i}=n(e,t,r,a,!0);return{filters:s,batch_norm_offset:i}}function a(n,a,s){let i=function(n,r){let a=Iz(e(9*n),[3,3,n,1]),s=wz(e(n)),i=wz(e(n)),o=wz(e(n)),l=wz(e(n));return t.push({paramPath:`${r}/filters`},{paramPath:`${r}/batch_norm_scale`},{paramPath:`${r}/batch_norm_offset`},{paramPath:`${r}/batch_norm_mean`},{paramPath:`${r}/batch_norm_variance`}),{filters:a,batch_norm_scale:s,batch_norm_offset:i,batch_norm_mean:o,batch_norm_variance:l}}(n,`${s}/depthwise_conv`);return{depthwise_conv:i,pointwise_conv:r(n,a,1,`${s}/pointwise_conv`)}}return{extractMobilenetV1Params:function(){return{conv_0:r(3,32,3,"mobilenetv1/conv_0"),conv_1:a(32,64,"mobilenetv1/conv_1"),conv_2:a(64,128,"mobilenetv1/conv_2"),conv_3:a(128,128,"mobilenetv1/conv_3"),conv_4:a(128,256,"mobilenetv1/conv_4"),conv_5:a(256,256,"mobilenetv1/conv_5"),conv_6:a(256,512,"mobilenetv1/conv_6"),conv_7:a(512,512,"mobilenetv1/conv_7"),conv_8:a(512,512,"mobilenetv1/conv_8"),conv_9:a(512,512,"mobilenetv1/conv_9"),conv_10:a(512,512,"mobilenetv1/conv_10"),conv_11:a(512,512,"mobilenetv1/conv_11"),conv_12:a(512,1024,"mobilenetv1/conv_12"),conv_13:a(1024,1024,"mobilenetv1/conv_13")}},extractPredictionLayerParams:function(){return{conv_0:r(1024,256,1,"prediction_layer/conv_0"),conv_1:r(256,512,3,"prediction_layer/conv_1"),conv_2:r(512,128,1,"prediction_layer/conv_2"),conv_3:r(128,256,3,"prediction_layer/conv_3"),conv_4:r(256,128,1,"prediction_layer/conv_4"),conv_5:r(128,256,3,"prediction_layer/conv_5"),conv_6:r(256,64,1,"prediction_layer/conv_6"),conv_7:r(64,128,3,"prediction_layer/conv_7"),box_predictor_0:{box_encoding_predictor:n(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),class_predictor:n(512,9,1,"prediction_layer/box_predictor_0/class_predictor")},box_predictor_1:{box_encoding_predictor:n(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),class_predictor:n(1024,18,1,"prediction_layer/box_predictor_1/class_predictor")},box_predictor_2:{box_encoding_predictor:n(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),class_predictor:n(512,18,1,"prediction_layer/box_predictor_2/class_predictor")},box_predictor_3:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_3/class_predictor")},box_predictor_4:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_4/class_predictor")},box_predictor_5:{box_encoding_predictor:n(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),class_predictor:n(128,18,1,"prediction_layer/box_predictor_5/class_predictor")}}}}}function Dye(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=function(e,t){let n=qge(e,t);function r(e,t,r){return{filters:n(`${e}/Conv2d_${t}_pointwise/weights`,4,`${r}/filters`),batch_norm_offset:n(`${e}/Conv2d_${t}_pointwise/convolution_bn_offset`,1,`${r}/batch_norm_offset`)}}function a(e){let t=`mobilenetv1/conv_${e}`,a=`MobilenetV1/Conv2d_${e}_depthwise`,s=`${t}/depthwise_conv`,i=`${t}/pointwise_conv`;return{depthwise_conv:{filters:n(`${a}/depthwise_weights`,4,`${s}/filters`),batch_norm_scale:n(`${a}/BatchNorm/gamma`,1,`${s}/batch_norm_scale`),batch_norm_offset:n(`${a}/BatchNorm/beta`,1,`${s}/batch_norm_offset`),batch_norm_mean:n(`${a}/BatchNorm/moving_mean`,1,`${s}/batch_norm_mean`),batch_norm_variance:n(`${a}/BatchNorm/moving_variance`,1,`${s}/batch_norm_variance`)},pointwise_conv:r("MobilenetV1",e,i)}}function s(e,t){return{filters:n(`${e}/weights`,4,`${t}/filters`),bias:n(`${e}/biases`,1,`${t}/bias`)}}function i(e){return{box_encoding_predictor:s(`Prediction/BoxPredictor_${e}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${e}/box_encoding_predictor`),class_predictor:s(`Prediction/BoxPredictor_${e}/ClassPredictor`,`prediction_layer/box_predictor_${e}/class_predictor`)}}return{extractMobilenetV1Params:function(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}},extractPredictionLayerParams:function(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:i(0),box_predictor_1:i(1),box_predictor_2:i(2),box_predictor_3:i(3),box_predictor_4:i(4),box_predictor_5:i(5)}}}}(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!Dme(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return Vge(e,t),{params:s,paramMappings:t}}function Mye(e,t,n){return WD((()=>{let r=oO(e,t.filters,n,"same");return r=rF(r,t.batch_norm_offset),nO(r,0,6)}))}var Fye=.0010000000474974513;function Oye(e,t){return WD((()=>{let n,r=Mye(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach(((e,t)=>{let a=t+1,s=function(e){return[2,4,6,12].some((t=>t===e))?[2,2]:[1,1]}(a);r=function(e,t,n){return WD((()=>{let r=xO(e,t.filters,n,"same");return r=HF(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,Fye),nO(r,0,6)}))}(r,e.depthwise_conv,s),r=Mye(r,e.pointwise_conv,[1,1]),11===a&&(n=r)})),null===n)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}}))}function Pye(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),c=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),h=(i-a)*(o-s),p=(c-l)*(d-u);if(h<=0||p<=0)return 0;let f=Math.max(a,l),m=Math.max(s,u),g=Math.min(i,c),y=Math.min(o,d),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(h+p-b)}function Lye(e,t){let{sizes:n,centers:r}=function(e){let t=Oz(Wz(e,[1,0])),n=[_P(t[2],t[0]),_P(t[3],t[1])];return{sizes:n,centers:[rF(t[0],sF(n[0],2)),rF(t[1],sF(n[1],2))]}}(e),a=Oz(Wz(t,[1,0])),s=sF(iF(eP(sF(a[2],5)),n[0]),2),i=rF(iF(sF(a[0],10),n[0]),r[0]),o=sF(iF(eP(sF(a[3],5)),n[1]),2),l=rF(iF(sF(a[1],10),n[1]),r[1]);return Wz(yz([_P(i,s),_P(l,o),rF(i,s),rF(l,o)]),[1,0])}function zye(e,t){return WD((()=>{let n=e.shape[0];return{boxPredictionEncoding:FF(Bge(e,t.box_encoding_predictor),[n,-1,1,4]),classPrediction:FF(Bge(e,t.class_predictor),[n,-1,3])}}))}var Bye=class{constructor(){let{minConfidence:e,maxResults:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,"number"!=typeof this._minConfidence||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if("number"!=typeof this._maxResults)throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},Vye=class extends Oge{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return WD((()=>{let n=eF(e.toBatchTensor(512,!1),"float32"),r=Oye(_P(sF(n,127.5),1),t.mobilenetv1),{boxPredictions:a,classPredictions:s}=function(e,t,n){return WD((()=>{let r=Mye(e,n.conv_0,[1,1]),a=Mye(r,n.conv_1,[2,2]),s=Mye(a,n.conv_2,[1,1]),i=Mye(s,n.conv_3,[2,2]),o=Mye(i,n.conv_4,[1,1]),l=Mye(o,n.conv_5,[2,2]),u=Mye(l,n.conv_6,[1,1]),c=Mye(u,n.conv_7,[2,2]),d=zye(t,n.box_predictor_0),h=zye(e,n.box_predictor_1),p=zye(a,n.box_predictor_2),f=zye(i,n.box_predictor_3),m=zye(l,n.box_predictor_4),g=zye(c,n.box_predictor_5);return{boxPredictions:LF([d.boxPredictionEncoding,h.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),classPredictions:LF([d.classPrediction,h.classPrediction,p.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1)}}))}(r.out,r.conv11,t.prediction_layer);return function(e,t,n){return WD((()=>{let r=e.shape[0],a=Lye(FF(rP(n.extra_dim,[r,1,1]),[-1,4]),FF(e,[-1,4]));a=FF(a,[r,a.shape[0]/r,4]);let s=BF(VF(t,[0,0,1],[-1,-1,-1])),i=VF(s,[0,0,0],[-1,-1,1]);return i=FF(i,[r,i.shape[1]]),{boxes:Oz(a),scores:Oz(i)}}))}(a,s,t.output_layer)}))}async forward(e){return this.forwardInput(await Ege(e))}async locateFaces(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{maxResults:n,minConfidence:r}=new Bye(t),a=await Ege(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let y=1;y<s.length;y++)s[y].dispose(),i[y].dispose();let u=Array.from(l.dataSync()),c=function(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map(((e,t)=>({score:e,boxIndex:t}))).filter((e=>e.score>a)).sort(((e,t)=>t.score-e.score)),l=e=>e<=r?1:0,u=[];return o.forEach((t=>{if(u.length>=i)return;let n=t.score;for(let r=u.length-1;r>=0;--r){let n=Pye(e,t.boxIndex,u[r]);if(0!==n&&(t.score*=l(n),t.score<=a))break}n===t.score&&u.push(t.boxIndex)})),u}(o,u,n,.5,r),d=a.getReshapedInputDimensions(0),h=a.inputSize,p=h/d.width,f=h/d.height,m=o.arraySync(),g=c.map((e=>{let[t,n]=[Math.max(0,m[e][0]),Math.min(1,m[e][2])].map((e=>e*f)),[r,s]=[Math.max(0,m[e][1]),Math.min(1,m[e][3])].map((e=>e*p));return new Kme(u[e],new Jme(r,t,s-r,n-t),{height:a.getInputHeight(0),width:a.getInputWidth(0)})}));return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return Dye(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Kge(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=Rye(n,t),i=a(),o=s(),l={extra_dim:Sz(n(20472),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}(e)}};var Wye=[new jme(.738768,.874946),new jme(2.42204,2.65704),new jme(4.30971,7.04493),new jme(10.246,4.59428),new jme(12.6868,11.8741)],Uye=[new jme(1.603231,2.094468),new jme(6.041143,7.080126),new jme(2.882459,3.518061),new jme(4.266906,5.178857),new jme(9.041765,10.66308)],jye=[117.001,114.697,97.404],Gye=e=>"number"==typeof e;function Hye(e){return WD((()=>{let t=iF(e,qO(.10000000149011612));return rF(jL(_P(e,t)),t)}))}function qye(e,t){return WD((()=>{let n=aL(e,[[0,0],[1,1],[1,1],[0,0]]);return n=oO(n,t.conv.filters,[1,1],"valid"),n=_P(n,t.bn.sub),n=iF(n,t.bn.truediv),n=rF(n,t.conv.bias),Hye(n)}))}function Kye(e,t){return WD((()=>{let n=aL(e,[[0,0],[1,1],[1,1],[0,0]]);return n=ez(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=rF(n,t.bias),Hye(n)}))}function Yye(e,t){let n=Wge(e,t);let r=Gge(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:function(r,a,s){let i=n(r,a,3,`${s}/conv`),o=function(n,r){let a=wz(e(n)),s=wz(e(n));return t.push({paramPath:`${r}/sub`},{paramPath:`${r}/truediv`}),{sub:a,truediv:s}}(a,`${s}/bn`);return{conv:i,bn:o}},extractSeparableConvParams:r}}function Xye(e,t){let n=qge(e,t);function r(e){return{filters:n(`${e}/filters`,4),bias:n(`${e}/bias`,1)}}return{extractConvParams:r,extractConvWithBatchNormParams:function(e){let t=r(`${e}/conv`),a=function(e){return{sub:n(`${e}/sub`,1),truediv:n(`${e}/truediv`,1)}}(`${e}/bn`);return{conv:t,bn:a}},extractSeparableConvParams:Hge(n)}}var Qye=class{constructor(){let{inputSize:e,scoreThreshold:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,"number"!=typeof this._inputSize||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if("number"!=typeof this._scoreThreshold||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},Zye=class e extends Oge{constructor(e){super("TinyYolov2"),function(e){if(!e)throw new Error(`invalid config: ${e}`);if("boolean"!=typeof e.withSeparableConvs)throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!Gye(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every((e=>"string"==typeof e)))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map((e=>e||{})).every((e=>Gye(e.x)&&Gye(e.y))))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||3!==e.meanRgb.length||!e.meanRgb.every(Gye)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=qye(e,t.conv0);return n=BP(n,[2,2],[2,2],"same"),n=qye(n,t.conv1),n=BP(n,[2,2],[2,2],"same"),n=qye(n,t.conv2),n=BP(n,[2,2],[2,2],"same"),n=qye(n,t.conv3),n=BP(n,[2,2],[2,2],"same"),n=qye(n,t.conv4),n=BP(n,[2,2],[2,2],"same"),n=qye(n,t.conv5),n=BP(n,[2,2],[1,1],"same"),n=qye(n,t.conv6),n=qye(n,t.conv7),Bge(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?Hye(Bge(e,t.conv0,"valid",!1)):Kye(e,t.conv0);return n=BP(n,[2,2],[2,2],"same"),n=Kye(n,t.conv1),n=BP(n,[2,2],[2,2],"same"),n=Kye(n,t.conv2),n=BP(n,[2,2],[2,2],"same"),n=Kye(n,t.conv3),n=BP(n,[2,2],[2,2],"same"),n=Kye(n,t.conv4),n=BP(n,[2,2],[2,2],"same"),n=Kye(n,t.conv5),n=BP(n,[2,2],[1,1],"same"),n=t.conv6?Kye(n,t.conv6):n,n=t.conv7?Kye(n,t.conv7):n,Bge(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return WD((()=>{let r=eF(e.toBatchTensor(t,!1),"float32");return r=this.config.meanRgb?Xme(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)}))}async forward(e,t){return this.forwardInput(await Ege(e),t)}async detect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{inputSize:n,scoreThreshold:r}=new Qye(t),a=await Ege(e),s=await this.forwardInput(a,n),i=WD((()=>Oz(s)[0].expandDims())),o={width:a.getInputWidth(0),height:a.getInputHeight(0)},l=await this.extractBoxes(i,a.getReshapedInputDimensions(0),r);s.dispose(),i.dispose();let u=l.map((e=>e.box)),c=l.map((e=>e.score)),d=l.map((e=>e.classScore)),h=l.map((e=>this.config.classes[e.label]));return function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=t.map(((e,t)=>({score:e,boxIndex:t}))).sort(((e,t)=>e.score-t.score)).map((e=>e.boxIndex)),s=[];for(;a.length>0;){let t=a.pop();s.push(t);let i=a,o=[];for(let n=0;n<i.length;n++){let a=i[n],s=e[t],l=e[a];o.push(Yme(s,l,r))}a=a.filter(((e,t)=>o[t]<=n))}return s}(u.map((e=>e.rescale(n))),c,this.config.iouThreshold,!0).map((e=>new qme(c[e],d[e],h[e],u[e],o)))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return function(e,t){let n,r=[],{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}=Xye(e,r);if(t.withSeparableConvs){let e=t.filterSizes&&t.filterSizes.length||9;n={conv0:t.isFirstLayerConv2d?a("conv0"):i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:e>7?i("conv6"):void 0,conv7:e>8?i("conv7"):void 0,conv8:a("conv8")}}else n={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:a("conv8")};return Vge(e,r),{params:n,paramMappings:r}}(e,this.config)}extractParams(t){let n=this.config.filterSizes||e.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(7!==r&&8!==r&&9!==r)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return function(e,t,n,r){let a,{extractWeights:s,getRemainingWeights:i}=Kge(e),o=[],{extractConvParams:l,extractConvWithBatchNormParams:u,extractSeparableConvParams:c}=Yye(s,o);if(t.withSeparableConvs){let[e,s,i,o,u,d,h,p,f]=r;a={conv0:t.isFirstLayerConv2d?l(e,s,3,"conv0"):c(e,s,"conv0"),conv1:c(s,i,"conv1"),conv2:c(i,o,"conv2"),conv3:c(o,u,"conv3"),conv4:c(u,d,"conv4"),conv5:c(d,h,"conv5"),conv6:p?c(h,p,"conv6"):void 0,conv7:f?c(p,f,"conv7"):void 0,conv8:l(f||p||h,5*n,1,"conv8")}}else{let[e,t,s,i,o,c,d,h,p]=r;a={conv0:u(e,t,"conv0"),conv1:u(t,s,"conv1"),conv2:u(s,i,"conv2"),conv3:u(i,o,"conv3"),conv4:u(o,c,"conv4"),conv5:u(c,d,"conv5"),conv6:u(d,h,"conv6"),conv7:u(h,p,"conv7"),conv8:l(p,5*n,1,"conv8")}}if(0!==i().length)throw new Error(`weights remaing after extract: ${i().length}`);return{params:a,paramMappings:o}}(t,this.config,this.boxEncodingSize,n)}async extractBoxes(e,t,n){let{width:r,height:a}=t,s=Math.max(r,a),i=s/r,o=s/a,l=e.shape[1],u=this.config.anchors.length,[c,d,h]=WD((()=>{let t=e.reshape([l,l,u,this.boxEncodingSize]);return[t.slice([0,0,0,0],[l,l,u,4]),t.slice([0,0,0,4],[l,l,u,1]),this.withClassScores?uz(t.slice([0,0,0,5],[l,l,u,this.config.classes.length]),3):qO(0)]})),p=[],f=await d.array(),m=await c.array();for(let g=0;g<l;g++)for(let e=0;e<l;e++)for(let t=0;t<u;t++){let r=Qme(f[g][e][t][0]);if(!n||r>n){let n=(e+Qme(m[g][e][t][0]))/l*i,a=(g+Qme(m[g][e][t][1]))/l*o,s=Math.exp(m[g][e][t][2])*this.config.anchors[t].x/l*i,u=Math.exp(m[g][e][t][3])*this.config.anchors[t].y/l*o,c=n-s/2,d=a-u/2,f={row:g,col:e,anchor:t},{classScore:y,label:b}=this.withClassScores?await this.extractPredictedClass(h,f):{classScore:1,label:0};p.push({box:new Hme(c,d,c+s,d+u),score:r,classScore:r*y,label:b,...f})}}return c.dispose(),d.dispose(),h.dispose(),p}async extractPredictedClass(e,t){let{row:n,col:r,anchor:a}=t,s=await e.array();return Array(this.config.classes.length).fill(0).map(((e,t)=>s[n][r][a][t])).map(((e,t)=>({classScore:e,label:t}))).reduce(((e,t)=>e.classScore>t.classScore?e:t))}};Zye.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var Jye=Zye,ebe=class extends Jye{constructor(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];super({withSeparableConvs:e,iouThreshold:.4,classes:["face"],...e?{anchors:Uye,meanRgb:jye}:{anchors:Wye,withClassScores:!0}})}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new Kme(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return this.withSeparableConvs?"tiny_yolov2_separable_conv_model":"tiny_yolov2_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}};var tbe=class extends Qye{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},nbe=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function rbe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:e=>{let{alignedRect:t}=e;return t},s=e.map((e=>iye(e)?a(e):e.detection)),i=r||(t instanceof jR?await $ge(t,s):await _ge(t,s)),o=await n(i);return i.forEach((e=>e instanceof jR&&e.dispose())),o}async function abe(e,t,n,r,a){return rbe([e],t,(async e=>n(e[0])),r,a)}var sbe=[new jme(1.603231,2.094468),new jme(6.041143,7.080126),new jme(2.882459,3.518061),new jme(4.266906,5.178857),new jme(9.041765,10.66308)],ibe=[117.001,114.697,97.404],obe=class extends Jye{constructor(){super({withSeparableConvs:!0,iouThreshold:.4,classes:["face"],anchors:sbe,meanRgb:ibe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]})}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new Kme(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},lbe={ssdMobilenetv1:new Vye,tinyFaceDetector:new obe,tinyYolov2:new ebe,faceLandmark68Net:new vye,faceLandmark68TinyNet:new class extends bye{constructor(){super("FaceLandmark68TinyNet",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new xye)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}},faceRecognitionNet:new Aye,faceExpressionNet:new class extends tye{constructor(){super("FaceExpressionNet",arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Zge)}forwardInput(e){return WD((()=>uz(this.runNet(e))))}async forward(e){return this.forwardInput(await Ege(e))}async predictExpressions(e){let t=await Ege(e),n=await this.forwardInput(t),r=await Promise.all(Oz(n).map((async e=>{let t=e.dataSync();return e.dispose(),t})));n.dispose();let a=r.map((e=>new rye(e)));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}},ageGenderNet:new class extends Oge{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new mye(2);super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return WD((()=>{let n=e instanceof Age?this.faceFeatureExtractor.forwardInput(e):e,r=OF(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1);return{age:Jge(r,t.fc.age).as1D(),gender:Jge(r,t.fc.gender)}}))}forwardInput(e){return WD((()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:uz(n)}}))}async forward(e){return this.forwardInput(await Ege(e))}async predictAgeAndGender(e){let t=await Ege(e),n=await this.forwardInput(t),r=Oz(n.age),a=Oz(n.gender),s=r.map(((e,t)=>({ageTensor:e,genderTensor:a[t]}))),i=await Promise.all(s.map((async e=>{let{ageTensor:t,genderTensor:n}=e,r=t.dataSync()[0],a=n.dataSync()[0],s=a>.5,i=s?"male":"female",o=s?a:1-a;return t.dispose(),n.dispose(),{age:r,gender:i,genderProbability:o}})));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Kge(e),a=Uge(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=eye(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=qge(e,t);function r(e){return{weights:n(`${e}/weights`,2),bias:n(`${e}/bias`,1)}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return Vge(e,t),{params:a,paramMappings:t}}(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}}},ube=class extends nbe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},cbe=class extends ube{async run(){let e=await this.parentTask,t=await rbe(e,this.input,(async e=>Promise.all(e.map((e=>lbe.faceExpressionNet.predictExpressions(e))))),this.extractedFaces);return e.map(((e,n)=>aye(e,t[n])))}withAgeAndGender(){return new mbe(this,this.input)}},dbe=class extends ube{async run(){let e=await this.parentTask;if(e)return aye(e,await abe(e,this.input,(e=>lbe.faceExpressionNet.predictExpressions(e)),this.extractedFaces))}withAgeAndGender(){return new gbe(this,this.input)}},hbe=class extends cbe{withAgeAndGender(){return new ybe(this,this.input)}withFaceDescriptors(){return new xbe(this,this.input)}},pbe=class extends dbe{withAgeAndGender(){return new bbe(this,this.input)}withFaceDescriptor(){return new wbe(this,this.input)}},fbe=class extends nbe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},mbe=class extends fbe{async run(){let e=await this.parentTask,t=await rbe(e,this.input,(async e=>Promise.all(e.map((e=>lbe.ageGenderNet.predictAgeAndGender(e))))),this.extractedFaces);return e.map(((e,n)=>{let{age:r,gender:a,genderProbability:s}=t[n];return _ye($ye(e,a,s),r)}))}withFaceExpressions(){return new cbe(this,this.input)}},gbe=class extends fbe{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await abe(e,this.input,(e=>lbe.ageGenderNet.predictAgeAndGender(e)),this.extractedFaces);return _ye($ye(e,n,r),t)}withFaceExpressions(){return new dbe(this,this.input)}},ybe=class extends mbe{withFaceExpressions(){return new hbe(this,this.input)}withFaceDescriptors(){return new xbe(this,this.input)}},bbe=class extends gbe{withFaceExpressions(){return new pbe(this,this.input)}withFaceDescriptor(){return new wbe(this,this.input)}},vbe=class extends nbe{constructor(e,t){super(),this.parentTask=e,this.input=t}},xbe=class extends vbe{async run(){let e=await this.parentTask;return(await rbe(e,this.input,(e=>Promise.all(e.map((e=>lbe.faceRecognitionNet.computeFaceDescriptor(e))))),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0})))).map(((t,n)=>Eye(e[n],t)))}withFaceExpressions(){return new hbe(this,this.input)}withAgeAndGender(){return new ybe(this,this.input)}},wbe=class extends vbe{async run(){let e=await this.parentTask;if(e)return Eye(e,await abe(e,this.input,(e=>lbe.faceRecognitionNet.computeFaceDescriptor(e)),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0}))))}withFaceExpressions(){return new pbe(this,this.input)}withAgeAndGender(){return new bbe(this,this.input)}},kbe=class extends nbe{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?lbe.faceLandmark68TinyNet:lbe.faceLandmark68Net}},Sbe=class extends kbe{async run(){let e=await this.parentTask,t=e.map((e=>e.detection)),n=this.input instanceof jR?await $ge(this.input,t):await _ge(this.input,t),r=await Promise.all(n.map((e=>this.landmarkNet.detectLandmarks(e))));return n.forEach((e=>e instanceof jR&&e.dispose())),e.filter(((e,t)=>r[t])).map(((e,t)=>oye(e,r[t])))}withFaceExpressions(){return new hbe(this,this.input)}withAgeAndGender(){return new ybe(this,this.input)}withFaceDescriptors(){return new xbe(this,this.input)}},Ibe=class extends kbe{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof jR?await $ge(this.input,[t]):await _ge(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach((e=>e instanceof jR&&e.dispose())),oye(e,r)}withFaceExpressions(){return new pbe(this,this.input)}withAgeAndGender(){return new bbe(this,this.input)}withFaceDescriptor(){return new wbe(this,this.input)}},Tbe=class extends nbe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Bye;super(),this.input=e,this.options=t}},Nbe=class extends Tbe{async run(){let e,{input:t,options:n}=this;if(n instanceof tbe)e=lbe.tinyFaceDetector.locateFaces(t,n);else if(n instanceof Bye)e=lbe.ssdMobilenetv1.locateFaces(t,n);else{if(!(n instanceof Qye))throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");e=lbe.tinyYolov2.locateFaces(t,n)}return e}runAndExtendWithFaceDetections(){return new Promise(((e,t)=>{this.run().then((t=>e(t.map((e=>sge({},e)))))).catch((e=>t(e)))}))}withFaceLandmarks(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return new Sbe(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new cbe(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new mbe(this.runAndExtendWithFaceDetections(),this.input)}},Cbe=class extends Tbe{async run(){let e=await new Nbe(this.input,this.options),t=e[0];return e.forEach((e=>{e.score>t.score&&(t=e)})),t}runAndExtendWithFaceDetection(){return new Promise((async e=>{let t=await this.run();e(t?sge({},t):void 0)}))}withFaceLandmarks(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return new Ibe(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new dbe(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new gbe(this.runAndExtendWithFaceDetection(),this.input)}};function Abe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Bye;return new Nbe(e,t)}var Ebe=class e{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.6;this._distanceThreshold=t;let n=Array.isArray(e)?e:[e];if(!n.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let r=1,a=()=>"person "+r++;this._labeledDescriptors=n.map((e=>{if(e instanceof rge)return e;if(e instanceof Float32Array)return new rge(a(),[e]);if(e.descriptor&&e.descriptor instanceof Float32Array)return new rge(a(),[e.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")}))}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(e,t){return t.map((t=>function(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),r=Array.from(t);return Math.sqrt(n.map(((e,t)=>e-r[t])).reduce(((e,t)=>e+t*t),0))}(t,e))).reduce(((e,t)=>e+t),0)/(t.length||1)}matchDescriptor(e){return this.labeledDescriptors.map((t=>{let{descriptors:n,label:r}=t;return new nge(r,this.computeMeanDistance(e,n))})).reduce(((e,t)=>e.distance<t.distance?e:t))}findBestMatch(e){let t=this.matchDescriptor(e);return t.distance<this._distanceThreshold?t:new nge("unknown",t.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map((e=>e.toJSON()))}}static fromJSON(t){let n=t.labeledDescriptors.map((e=>rge.fromJSON(e)));return new e(n,t.distanceThreshold)}};var _be=n(5879);function $be(e){return(0,Kn.Ay)("MuiCircularProgress",e)}(0,Fn.A)("MuiCircularProgress",["root","determinate","indeterminate","colorPrimary","colorSecondary","svg","circle","circleDeterminate","circleIndeterminate","circleDisableShrink"]);const Rbe=44,Dbe=ar`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`,Mbe=ar`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`,Fbe="string"!==typeof Dbe?rr`
        animation: ${Dbe} 1.4s linear infinite;
      `:null,Obe="string"!==typeof Mbe?rr`
        animation: ${Mbe} 1.4s ease-in-out infinite;
      `:null,Pbe=(0,Wn.Ay)("span",{name:"MuiCircularProgress",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[n.variant],t[`color${(0,lr.A)(n.color)}`]]}})((0,Gn.A)((e=>{let{theme:t}=e;return{display:"inline-block",variants:[{props:{variant:"determinate"},style:{transition:t.transitions.create("transform")}},{props:{variant:"indeterminate"},style:Fbe||{animation:`${Dbe} 1.4s linear infinite`}},...Object.entries(t.palette).filter((e=>{let[,t]=e;return t&&t.main})).map((e=>{let[n]=e;return{props:{color:n},style:{color:(t.vars||t).palette[n].main}}}))]}}))),Lbe=(0,Wn.Ay)("svg",{name:"MuiCircularProgress",slot:"Svg",overridesResolver:(e,t)=>t.svg})({display:"block"}),zbe=(0,Wn.Ay)("circle",{name:"MuiCircularProgress",slot:"Circle",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.circle,t[`circle${(0,lr.A)(n.variant)}`],n.disableShrink&&t.circleDisableShrink]}})((0,Gn.A)((e=>{let{theme:t}=e;return{stroke:"currentColor",variants:[{props:{variant:"determinate"},style:{transition:t.transitions.create("stroke-dashoffset")}},{props:{variant:"indeterminate"},style:{strokeDasharray:"80px, 200px",strokeDashoffset:0}},{props:e=>{let{ownerState:t}=e;return"indeterminate"===t.variant&&!t.disableShrink},style:Obe||{animation:`${Mbe} 1.4s ease-in-out infinite`}}]}}))),Bbe=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiCircularProgress"}),{className:r,color:a="primary",disableShrink:s=!1,size:i=40,style:o,thickness:l=3.6,value:u=0,variant:c="indeterminate",...d}=n,h={...n,color:a,disableShrink:s,size:i,thickness:l,value:u,variant:c},p=(e=>{const{classes:t,variant:n,color:r,disableShrink:a}=e,s={root:["root",n,`color${(0,lr.A)(r)}`],svg:["svg"],circle:["circle",`circle${(0,lr.A)(n)}`,a&&"circleDisableShrink"]};return(0,Bn.A)(s,$be,t)})(h),f={},m={},g={};if("determinate"===c){const e=2*Math.PI*((Rbe-l)/2);f.strokeDasharray=e.toFixed(3),g["aria-valuenow"]=Math.round(u),f.strokeDashoffset=`${((100-u)/100*e).toFixed(3)}px`,m.transform="rotate(-90deg)"}return(0,$n.jsx)(Pbe,{className:(0,vn.A)(p.root,r),style:{width:i,height:i,...m,...o},ownerState:h,ref:t,role:"progressbar",...g,...d,children:(0,$n.jsx)(Lbe,{className:p.svg,ownerState:h,viewBox:"22 22 44 44",children:(0,$n.jsx)(zbe,{className:p.circle,style:f,ownerState:h,cx:Rbe,cy:Rbe,r:(Rbe-l)/2,fill:"none",strokeWidth:l})})})})),Vbe=Bbe;function Wbe(e){return(0,Kn.Ay)("MuiLoadingButton",e)}const Ube=(0,Fn.A)("MuiLoadingButton",["root","label","loading","loadingIndicator","loadingIndicatorCenter","loadingIndicatorStart","loadingIndicatorEnd","endIconLoadingEnd","startIconLoadingStart"]),jbe=(0,Wn.Ay)(Po,{shouldForwardProp:e=>(e=>"ownerState"!==e&&"theme"!==e&&"sx"!==e&&"as"!==e&&"classes"!==e)(e)||"classes"===e,name:"MuiLoadingButton",slot:"Root",overridesResolver:(e,t)=>[t.root,t.startIconLoadingStart&&{[`& .${Ube.startIconLoadingStart}`]:t.startIconLoadingStart},t.endIconLoadingEnd&&{[`& .${Ube.endIconLoadingEnd}`]:t.endIconLoadingEnd}]})((0,Gn.A)((e=>{let{theme:t}=e;return{display:"inline-flex",[`& .${Ube.startIconLoadingStart}, & .${Ube.endIconLoadingEnd}`]:{transition:t.transitions.create(["opacity"],{duration:t.transitions.duration.short}),opacity:0},variants:[{props:{loadingPosition:"center"},style:{transition:t.transitions.create(["background-color","box-shadow","border-color"],{duration:t.transitions.duration.short}),[`&.${Ube.loading}`]:{color:"transparent"}}},{props:e=>{let{ownerState:t}=e;return"start"===t.loadingPosition&&t.fullWidth},style:{[`& .${Ube.startIconLoadingStart}, & .${Ube.endIconLoadingEnd}`]:{transition:t.transitions.create(["opacity"],{duration:t.transitions.duration.short}),opacity:0,marginRight:-8}}},{props:e=>{let{ownerState:t}=e;return"end"===t.loadingPosition&&t.fullWidth},style:{[`& .${Ube.startIconLoadingStart}, & .${Ube.endIconLoadingEnd}`]:{transition:t.transitions.create(["opacity"],{duration:t.transitions.duration.short}),opacity:0,marginLeft:-8}}}]}}))),Gbe=(0,Wn.Ay)("span",{name:"MuiLoadingButton",slot:"LoadingIndicator",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.loadingIndicator,t[`loadingIndicator${(0,lr.A)(n.loadingPosition)}`]]}})((0,Gn.A)((e=>{let{theme:t}=e;return{position:"absolute",visibility:"visible",display:"flex",variants:[{props:{loadingPosition:"start",size:"small"},style:{left:10}},{props:e=>{let{loadingPosition:t,ownerState:n}=e;return"start"===t&&"small"!==n.size},style:{left:14}},{props:{variant:"text",loadingPosition:"start"},style:{left:6}},{props:{loadingPosition:"center"},style:{left:"50%",transform:"translate(-50%)",color:(t.vars||t).palette.action.disabled}},{props:{loadingPosition:"end",size:"small"},style:{right:10}},{props:e=>{let{loadingPosition:t,ownerState:n}=e;return"end"===t&&"small"!==n.size},style:{right:14}},{props:{variant:"text",loadingPosition:"end"},style:{right:6}},{props:e=>{let{ownerState:t}=e;return"start"===t.loadingPosition&&t.fullWidth},style:{position:"relative",left:-10}},{props:e=>{let{ownerState:t}=e;return"end"===t.loadingPosition&&t.fullWidth},style:{position:"relative",right:-10}}]}}))),Hbe=(0,Wn.Ay)("span",{name:"MuiLoadingButton",slot:"Label",overridesResolver:(e,t)=>[t.label]})({display:"inherit",alignItems:"inherit",justifyContent:"inherit"}),qbe=t.forwardRef((function(e,n){const r=t.useContext(_o),a=(0,Ui.A)(r,e),s=(0,Hn.b)({props:a,name:"MuiLoadingButton"}),{children:i,disabled:o=!1,id:l,loading:u=!1,loadingIndicator:c,loadingPosition:d="center",variant:h="text",...p}=s,f=(0,_be.A)(l),m=c??(0,$n.jsx)(Vbe,{"aria-labelledby":f,color:"inherit",size:16}),g={...s,disabled:o,loading:u,loadingIndicator:m,loadingPosition:d,variant:h},y=(e=>{const{loading:t,loadingPosition:n,classes:r}=e,a=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;const r={};for(const a in e){const s=e[a];let i="";for(let e=0;e<s.length;e+=1){const r=s[e];r&&(i+=t(r)+" ",n&&n[r]&&(i+=n[r]+" "))}r[a]=i}return r}({root:["root",t&&"loading"],label:["label"],startIcon:[t&&`startIconLoading${(0,lr.A)(n)}`],endIcon:[t&&`endIconLoading${(0,lr.A)(n)}`],loadingIndicator:["loadingIndicator",t&&`loadingIndicator${(0,lr.A)(n)}`]},Wbe,r);return{...r,...a}})(g),b=u?(0,$n.jsx)(Gbe,{className:y.loadingIndicator,ownerState:g,children:m}):null;return(0,$n.jsxs)(jbe,{disabled:o||u,id:f,ref:n,...p,variant:h,classes:y,ownerState:g,children:["end"===g.loadingPosition?(0,$n.jsx)(Hbe,{className:y.label,children:i}):b,"end"===g.loadingPosition?b:(0,$n.jsx)(Hbe,{className:y.label,children:i})]})})),Kbe=qbe;const Ybe=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{autoHideDuration:n=null,disableWindowBlurListener:r=!1,onClose:a,open:s,resumeHideDuration:i}=e,o=ls();t.useEffect((()=>{if(s)return document.addEventListener("keydown",e),()=>{document.removeEventListener("keydown",e)};function e(e){e.defaultPrevented||"Escape"===e.key&&a?.(e,"escapeKeyDown")}}),[s,a]);const l=(0,js.A)(((e,t)=>{a?.(e,t)})),u=(0,js.A)((e=>{a&&null!=e&&o.start(e,(()=>{l(null,"timeout")}))}));t.useEffect((()=>(s&&u(n),o.clear)),[s,n,u,o]);const c=o.clear,d=t.useCallback((()=>{null!=n&&u(null!=i?i:.5*n)}),[n,i,u]),h=e=>t=>{const n=e.onFocus;n?.(t),c()},p=e=>t=>{const n=e.onMouseEnter;n?.(t),c()},f=e=>t=>{const n=e.onMouseLeave;n?.(t),d()};return t.useEffect((()=>{if(!r&&s)return window.addEventListener("focus",d),window.addEventListener("blur",c),()=>{window.removeEventListener("focus",d),window.removeEventListener("blur",c)}}),[r,s,d,c]),{getRootProps:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={...La(e),...La(t)};return{role:"presentation",...t,...n,onBlur:(r=n,e=>{const t=r.onBlur;t?.(e),d()}),onFocus:h(n),onMouseEnter:p(n),onMouseLeave:f(n)};var r},onClickAway:e=>{a?.(e,"clickaway")}}};function Xbe(e){return e.substring(2).toLowerCase()}function Qbe(e){const{children:n,disableReactTree:r=!1,mouseEvent:a="onClick",onClickAway:s,touchEvent:i="onTouchEnd"}=e,o=t.useRef(!1),l=t.useRef(null),u=t.useRef(!1),c=t.useRef(!1);t.useEffect((()=>(setTimeout((()=>{u.current=!0}),0),()=>{u.current=!1})),[]);const d=(0,br.A)(Ra(n),l),h=(0,js.A)((e=>{const t=c.current;c.current=!1;const n=(0,_s.A)(l.current);if(!u.current||!l.current||"clientX"in e&&function(e,t){return t.documentElement.clientWidth<e.clientX||t.documentElement.clientHeight<e.clientY}(e,n))return;if(o.current)return void(o.current=!1);let a;a=e.composedPath?e.composedPath().indexOf(l.current)>-1:!n.documentElement.contains(e.target)||l.current.contains(e.target),a||!r&&t||s(e)})),p=e=>t=>{c.current=!0;const r=n.props[e];r&&r(t)},f={ref:d};return!1!==i&&(f[i]=p(i)),t.useEffect((()=>{if(!1!==i){const e=Xbe(i),t=(0,_s.A)(l.current),n=()=>{o.current=!0};return t.addEventListener(e,h),t.addEventListener("touchmove",n),()=>{t.removeEventListener(e,h),t.removeEventListener("touchmove",n)}}}),[h,i]),!1!==a&&(f[a]=p(a)),t.useEffect((()=>{if(!1!==a){const e=Xbe(a),t=(0,_s.A)(l.current);return t.addEventListener(e,h),()=>{t.removeEventListener(e,h)}}}),[h,a]),(0,$n.jsx)(t.Fragment,{children:t.cloneElement(n,f)})}function Zbe(e){return(0,Kn.Ay)("MuiSnackbarContent",e)}(0,Fn.A)("MuiSnackbarContent",["root","message","action"]);const Jbe=(0,Wn.Ay)(Zn,{name:"MuiSnackbarContent",slot:"Root",overridesResolver:(e,t)=>t.root})((0,Gn.A)((e=>{let{theme:t}=e;const n="light"===t.palette.mode?.8:.98,r=(0,Vn.tL)(t.palette.background.default,n);return{...t.typography.body2,color:t.vars?t.vars.palette.SnackbarContent.color:t.palette.getContrastText(r),backgroundColor:t.vars?t.vars.palette.SnackbarContent.bg:r,display:"flex",alignItems:"center",flexWrap:"wrap",padding:"6px 16px",borderRadius:(t.vars||t).shape.borderRadius,flexGrow:1,[t.breakpoints.up("sm")]:{flexGrow:"initial",minWidth:288}}}))),eve=(0,Wn.Ay)("div",{name:"MuiSnackbarContent",slot:"Message",overridesResolver:(e,t)=>t.message})({padding:"8px 0"}),tve=(0,Wn.Ay)("div",{name:"MuiSnackbarContent",slot:"Action",overridesResolver:(e,t)=>t.action})({display:"flex",alignItems:"center",marginLeft:"auto",paddingLeft:16,marginRight:-8}),nve=t.forwardRef((function(e,t){const n=(0,Hn.b)({props:e,name:"MuiSnackbarContent"}),{action:r,className:a,message:s,role:i="alert",...o}=n,l=n,u=(e=>{const{classes:t}=e;return(0,Bn.A)({root:["root"],action:["action"],message:["message"]},Zbe,t)})(l);return(0,$n.jsxs)(Jbe,{role:i,square:!0,elevation:6,className:(0,vn.A)(u.root,a),ownerState:l,ref:t,...o,children:[(0,$n.jsx)(eve,{className:u.message,ownerState:l,children:s}),r?(0,$n.jsx)(tve,{className:u.action,ownerState:l,children:r}):null]})}));function rve(e){return(0,Kn.Ay)("MuiSnackbar",e)}(0,Fn.A)("MuiSnackbar",["root","anchorOriginTopCenter","anchorOriginBottomCenter","anchorOriginTopRight","anchorOriginBottomRight","anchorOriginTopLeft","anchorOriginBottomLeft"]);const ave=(0,Wn.Ay)("div",{name:"MuiSnackbar",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e;return[t.root,t[`anchorOrigin${(0,lr.A)(n.anchorOrigin.vertical)}${(0,lr.A)(n.anchorOrigin.horizontal)}`]]}})((0,Gn.A)((e=>{let{theme:t}=e;return{zIndex:(t.vars||t).zIndex.snackbar,position:"fixed",display:"flex",left:8,right:8,justifyContent:"center",alignItems:"center",variants:[{props:e=>{let{ownerState:t}=e;return"top"===t.anchorOrigin.vertical},style:{top:8,[t.breakpoints.up("sm")]:{top:24}}},{props:e=>{let{ownerState:t}=e;return"top"!==t.anchorOrigin.vertical},style:{bottom:8,[t.breakpoints.up("sm")]:{bottom:24}}},{props:e=>{let{ownerState:t}=e;return"left"===t.anchorOrigin.horizontal},style:{justifyContent:"flex-start",[t.breakpoints.up("sm")]:{left:24,right:"auto"}}},{props:e=>{let{ownerState:t}=e;return"right"===t.anchorOrigin.horizontal},style:{justifyContent:"flex-end",[t.breakpoints.up("sm")]:{right:24,left:"auto"}}},{props:e=>{let{ownerState:t}=e;return"center"===t.anchorOrigin.horizontal},style:{[t.breakpoints.up("sm")]:{left:"50%",right:"auto",transform:"translateX(-50%)"}}}]}}))),sve=t.forwardRef((function(e,n){const r=(0,Hn.b)({props:e,name:"MuiSnackbar"}),a=jn(),s={enter:a.transitions.duration.enteringScreen,exit:a.transitions.duration.leavingScreen},{action:i,anchorOrigin:{vertical:o,horizontal:l}={vertical:"bottom",horizontal:"left"},autoHideDuration:u=null,children:c,className:d,ClickAwayListenerProps:h,ContentProps:p,disableWindowBlurListener:f=!1,message:m,onBlur:g,onClose:y,onFocus:b,onMouseEnter:v,onMouseLeave:x,open:w,resumeHideDuration:k,TransitionComponent:S=Es,transitionDuration:I=s,TransitionProps:{onEnter:T,onExited:N,...C}={},...A}=r,E={...r,anchorOrigin:{vertical:o,horizontal:l},autoHideDuration:u,disableWindowBlurListener:f,TransitionComponent:S,transitionDuration:I},_=(e=>{const{classes:t,anchorOrigin:n}=e,r={root:["root",`anchorOrigin${(0,lr.A)(n.vertical)}${(0,lr.A)(n.horizontal)}`]};return(0,Bn.A)(r,rve,t)})(E),{getRootProps:$,onClickAway:R}=Ybe({...E}),[D,M]=t.useState(!0),F=Wa({elementType:ave,getSlotProps:$,externalForwardedProps:A,ownerState:E,additionalProps:{ref:n},className:[_.root,d]});return!w&&D?null:(0,$n.jsx)(Qbe,{onClickAway:R,...h,children:(0,$n.jsx)(ave,{...F,children:(0,$n.jsx)(S,{appear:!0,in:w,timeout:I,direction:"top"===o?"down":"up",onEnter:(e,t)=>{M(!1),T&&T(e,t)},onExited:e=>{M(!0),N&&N(e)},...C,children:c||(0,$n.jsx)(nve,{message:m,action:i,...p})})})})}));var ive=n(6111),ove=n.n(ive);const lve=[],uve=e=>{let{firstName:n,lastName:r,email:a,dateOfBirth:s,onBack:i}=e;const o=(0,t.useRef)(null),[l,u]=(0,t.useState)(0),[c,d]=(0,t.useState)(""),[h,p]=(0,t.useState)(!1),[f,m]=(0,t.useState)(!1),[g,y]=(0,t.useState)(!1),b=E(),v=Qt(),x=async()=>{p(!0);try{const e=((e,t,n,r)=>ove().AES.encrypt(e||"",`${t||""} ${n||""}`+r).toString())(a,n,r,s),t=((e,t,n,r)=>e.map((e=>ove().AES.encrypt(JSON.stringify(e),`${t||""} ${n||""}`+r).toString())))(lve,n,r,s),i={name:`${n||""} ${r||""}`,email:e,DOB:s||"",...t.reduce(((e,t,n)=>(e[`descriptors_${n}`]=t||[],e)),{})},o=await(async e=>await jb(lb(Kb,"users"),e))(i);b(Xe(o.id)),v("/loggedUser")}catch(KR){console.error("Error adding document: ",KR)}finally{p(!1)}};5===l&&(x(),u((e=>e+1)));const{current:w}=o,{video:k}=w||{};return(0,$n.jsxs)(zn,{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",padding:2,height:"100vh",bgcolor:"#f5f5f5",children:[(0,$n.jsxs)(Zn,{elevation:3,sx:{padding:4,borderRadius:4,maxWidth:900,width:"100%"},children:[(0,$n.jsx)(mr,{variant:"h5",gutterBottom:!0,textAlign:"center",children:"Capture Your Photo"}),(0,$n.jsx)(Po,{variant:"contained",color:"secondary",onClick:i,sx:{marginBottom:2,position:"absolute",left:20,top:20},children:"Back"}),(0,$n.jsxs)(zn,{display:"flex",flexDirection:{xs:"column",md:"row"},justifyContent:"center",gap:5,alignItems:"center",children:[(0,$n.jsx)(UN(),{audio:!1,ref:o,screenshotFormat:"image/jpeg",style:{borderRadius:10,width:"100%",maxWidth:650,height:"auto"}}),l<5&&(0,$n.jsxs)(zn,{display:"flex",flexDirection:"column",alignItems:"center",children:[(0,$n.jsx)(zn,{children:(0,$n.jsx)(zn,{component:"img",alt:"Face Snapshot Guide",src:`/auth-tfjs/snapshotGuide/face_${l+1}.jpg`,sx:{width:{xs:"80%",md:250},height:"auto",borderRadius:2,objectFit:"contain",boxShadow:2}})}),(0,$n.jsx)(Kbe,{variant:"contained",color:"primary",onClick:async()=>{try{m(!0);const e=o.current.getScreenshot(),t=new Image;t.src=e,await t.decode();const n=await function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Bye;return new Cbe(e,t)}(t,new tbe).withFaceLandmarks().withFaceDescriptor();n?(lve.push(Array.from(n.descriptor)),u((e=>e+1))):(y(!0),d("Please re-take the image "))}catch(e){y(!0),d("Please re-take the image Or Check camera and lighting")}finally{m(!1)}},disabled:l>4,sx:{marginTop:3,width:"100%"},loading:f,children:"Capture Photo"})]})]})]}),(0,$n.jsx)(sve,{open:g,autoHideDuration:3e3,onClose:()=>y(!1),anchorOrigin:{vertical:"top",horizontal:"center"},children:(0,$n.jsx)(tl,{variant:"filled",severity:"error",sx:{width:"30vw"},children:c})})]})},cve=()=>{const[e,n]=(0,t.useState)({firstName:"",lastName:"",email:"",dateOfBirth:null}),[r,a]=(0,t.useState)({firstName:"",lastName:"",email:"",dateOfBirth:""}),[s,i]=(0,t.useState)(null),[o,l]=(0,t.useState)(!1),u=Qt(),c=(t,r)=>{n({...e,[t]:r})},d=(0,t.useMemo)((()=>{switch(s){case"minDate":case"maxDate":return"Date of Birth cannot be in the future or an invalid range";case"invalidDate":return"Invalid date format";default:return""}}),[s]);var h;return o?(0,$n.jsx)(uve,{firstName:e.firstName,lastName:e.lastName,email:e.email,dateOfBirth:null===(h=e.dateOfBirth)||void 0===h?void 0:h.toISOString(),onBack:()=>l(!1)}):(0,$n.jsx)(zn,{display:"flex",justifyContent:"center",alignItems:"center",minHeight:"100vh",sx:{backgroundColor:"#f5f5f5"},children:(0,$n.jsxs)(ev,{variant:"outlined",sx:{width:"400px",p:2},children:[(0,$n.jsxs)(rv,{children:[(0,$n.jsx)(mr,{variant:"h5",component:"h2",gutterBottom:!0,align:"center",children:"Registration Form"}),(0,$n.jsxs)(zn,{component:"form",onSubmit:t=>{t.preventDefault(),(()=>{let t={...r};t.firstName=e.firstName?"":"First Name is required",t.lastName=e.lastName?"":"Last Name is required",t.email=/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e.email)?"":"Email is not valid",t.dateOfBirth=e.dateOfBirth?d:"Date of Birth is required",e.dateOfBirth&&NN()().diff(NN()(e.dateOfBirth),"year")<13&&(t.dateOfBirth="You must be at least 13 years old");return a(t),console.log(r),Object.values(t).every((e=>""===e))})()&&l(!0)},noValidate:!0,sx:{mt:2},children:[(0,$n.jsx)(ro,{label:"First Name",variant:"outlined",fullWidth:!0,value:e.firstName,onChange:e=>c("firstName",e.target.value),error:!!r.firstName,helperText:r.firstName,margin:"normal"}),(0,$n.jsx)(ro,{label:"Last Name",variant:"outlined",fullWidth:!0,value:e.lastName,onChange:e=>c("lastName",e.target.value),error:!!r.lastName,helperText:r.lastName,margin:"normal"}),(0,$n.jsx)(ro,{label:"Email",variant:"outlined",fullWidth:!0,value:e.email,onChange:e=>c("email",e.target.value),error:!!r.email,helperText:r.email,margin:"normal"}),(0,$n.jsx)(iv,{dateAdapter:VN,children:(0,$n.jsx)(IN,{label:"Date of Birth",value:e.dateOfBirth,onChange:e=>c("dateOfBirth",e),onError:e=>i(e),slotProps:{textField:{helperText:r.dateOfBirth||d,error:!!r.dateOfBirth||!!s}},sx:{mt:2,mb:1,width:1},minDate:NN()().subtract(100,"year"),maxDate:NN()()})}),(0,$n.jsx)(Po,{type:"submit",variant:"contained",fullWidth:!0,sx:{mt:2},children:"Submit"})]})]}),(0,$n.jsxs)(mr,{variant:"body2",textAlign:"center",children:["Already have an account \xa0",(0,$n.jsx)(ul,{component:"button",variant:"body2",onClick:()=>{u("/login")},children:"Click here to Login"})]})]})})},dve=()=>{const e=Qt();return(0,$n.jsx)(zn,{display:"flex",justifyContent:"center",alignItems:"center",minHeight:"100vh",bgcolor:"#f5f5f5",padding:3,children:(0,$n.jsxs)(Zn,{elevation:3,sx:{padding:4,borderRadius:2,maxWidth:500,textAlign:"center"},children:[(0,$n.jsx)(zl.A,{sx:{fontSize:80,color:"error.main",mb:2}}),(0,$n.jsx)(mr,{variant:"h4",gutterBottom:!0,children:"Oops! Something went wrong."}),(0,$n.jsx)(mr,{variant:"body1",paragraph:!0,children:"We couldn't find the information you were looking for. This might be due to an expired session or an invalid request."}),(0,$n.jsx)(Po,{variant:"contained",color:"primary",onClick:()=>e("/"),sx:{mt:2},children:"Go to Home Page"})]})})};var hve=n(5743),pve=n(9554),fve=n(7794),mve=n(803),gve=n(319);const yve={kernelName:pve.ljI,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)(e,(0,gve.P)((0,fve.w)(n,"float32"),-1))}}};var bve=n(4974),vve=n(1011),xve=n(1997),wve=n(191),kve=n(7738),Sve=n(7951);const Ive={kernelName:pve.Vvy,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,kve.E)((0,fve.w)(n,"float32")),r=(0,wve.R)((0,Sve.j)((0,xve.d)(1),t));return(0,vve.H)((0,bve.y)(e,r))}}}},Tve={kernelName:pve.PH8,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,wve.R)((0,Sve.j)((0,kve.E)((0,fve.w)(n,"float32")),1));return(0,bve.y)(e,t)}}}};var Nve=n(8805),Cve=n(5583),Ave=n(7382);const Eve={kernelName:pve.OMN,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Nve.assertAndGetBroadcastShape(n.shape,r.shape);return{a:()=>{let t=e;const r=Nve.getReductionAxes(n.shape,a);return r.length>0&&(t=(0,Ave.c)(t,r)),(0,Cve.t)(t,n.shape)},b:()=>{let t=e;const n=Nve.getReductionAxes(r.shape,a);return n.length>0&&(t=(0,Ave.c)(t,n)),(0,Cve.t)(t,r.shape)}}}},_ve={kernelName:pve.EkD,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}};var $ve=n(3290);const Rve={kernelName:pve.Jp_,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,$ve.P)(n)}}},Dve={kernelName:pve.p_m,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,$ve.P)(n)}}},Mve={kernelName:pve.QKF,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,bve.y)(e,(0,wve.R)((0,Sve.j)((0,xve.d)(1),(0,kve.E)((0,fve.w)(n,"float32")))))}}};var Fve=n(7242);const Ove={kernelName:pve.epO,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,wve.R)((0,Fve.W)((0,xve.d)(1),(0,kve.E)((0,fve.w)(n,"float32"))));return(0,bve.y)(e,t)}}}},Pve={kernelName:pve.lxb,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=(0,Nve.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,Fve.W)((0,kve.E)(n),(0,kve.E)(r));let s=(0,mve.l)(e,(0,bve.y)(r,t));const i=(0,Nve.getReductionAxes)(n.shape,a);return i.length>0&&(s=(0,Ave.c)(s,i)),(0,Cve.t)(s,n.shape)},b:()=>{const t=(0,Fve.W)((0,kve.E)(n),(0,kve.E)(r));let s=(0,vve.H)((0,mve.l)(e,(0,bve.y)(n,t)));const i=(0,Nve.getReductionAxes)(r.shape,a);return i.length>0&&(s=(0,Ave.c)(s,i)),(0,Cve.t)(s,r.shape)}}}},Lve={kernelName:pve.TyE,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,bve.y)(e,(0,Fve.W)((0,kve.E)((0,fve.w)(n,"float32")),1))}}},zve={kernelName:pve.zP9,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,bve.y)(e,(0,Sve.j)((0,xve.d)(1),(0,kve.E)((0,fve.w)(n,"float32"))))}}};var Bve=n(2164),Vve=n(4148),Wve=n(1426),Uve=n(7538),jve=n(7892);const Gve=(0,jve.op)({avgPool3dGrad_:function(e,t,n,r,a,s){const i=(0,Vve.YT)(e,"dy","avgPool3dGrad"),o=(0,Vve.YT)(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=(0,Cve.t)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=(0,Cve.t)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Wve.vA(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),Wve.vA(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),(0,Uve.s_)("avgPool3dGrad",a,s);const d={dy:l,input:u},h={filterSize:n,strides:r,pad:a,dimRoundingMode:s},p=Bve.T2.runKernel(pve.wwC,d,h);return c?(0,Cve.t)(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),Hve={kernelName:pve.cS,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>Gve(e,r,a,s,i,o)}}};const qve=(0,jve.op)({avgPoolGrad_:function(e,t,n,r,a){const s=(0,Vve.YT)(e,"dy","avgPoolGrad"),i=(0,Vve.YT)(t,"input","avgPoolGrad");Wve.vA(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=(0,Cve.t)(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=(0,Cve.t)(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Wve.vA(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),Wve.vA(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},d={filterSize:n,strides:r,pad:a},h=Bve.T2.runKernel(pve.VCH,c,d);return u?(0,Cve.t)(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Kve={kernelName:pve.ho8,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>qve(e,r,a,s,i)}}};var Yve=n(5162);const Xve={kernelName:pve.jAQ,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>(0,Yve.N)(e,a,!1,!1),b:()=>(0,Yve.N)(e,r,!0,!1)}:s&&!i?{a:()=>(0,Yve.N)(a,e,!1,!0),b:()=>(0,Yve.N)(r,e,!1,!1)}:{a:()=>(0,Yve.N)(a,e,!0,!0),b:()=>(0,Yve.N)(e,r,!0,!0)}:{a:()=>(0,Yve.N)(e,a,!1,!0),b:()=>(0,Yve.N)(r,e,!0,!1)}}};var Qve=n(3585);const Zve={kernelName:pve.Ik2,gradFunc:(e,t,n)=>{const{blockShape:r,crops:a}=n;return{x:()=>(0,Qve.e)(e,r,a)}}},Jve={kernelName:pve.LB5,gradFunc:(e,t,n)=>{const r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>(0,Ave.c)(e,o,!0)}}},exe={kernelName:pve.KXH,gradFunc:e=>({x:()=>e.clone()})},txe={kernelName:pve.QDP,gradFunc:e=>({x:()=>(0,$ve.P)(e)})};var nxe=n(9996),rxe=n(827),axe=n(5692),sxe=n(3986);const ixe={kernelName:pve.vaV,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>(0,sxe._)((0,axe.n)((0,nxe.D)(r,a),(0,rxe.I)(r,s)),e,(0,$ve.P)(e))}}},oxe={kernelName:pve.$zE,inputsToSave:["x"],gradFunc:yve.gradFunc};var lxe=n(5181);const uxe={kernelName:pve.$dB,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:a}=n,s=(0,Wve.Y6)(a,t[0].shape)[0],i=r.map((e=>e[s]));return(0,lxe.l)(e,i,s).map((e=>()=>e))}};var cxe=n(6927),dxe=n(1565);const hxe={kernelName:pve.p2J,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return Wve.vA(Uve.Dh(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>(0,dxe.v)(r.shape,e,a,i,o,l),filter:()=>(0,cxe.H)(r,e,a.shape,i,o,l)}}};var pxe=n(4969);const fxe={kernelName:pve.jfg,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>(0,pxe.X)(e,a,s,i,o,1,l),filter:()=>(0,cxe.H)(e,r,a.shape,s,i,o,l)}}};const mxe=(0,jve.op)({conv3DBackpropFilter_:function(e,t,n,r,a){let s=e;4===e.rank&&(s=(0,Cve.t)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=(0,Cve.t)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Wve.vA(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),Wve.vA(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),Wve.vA(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Wve.vA(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),Wve.vA(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return Bve.T2.runKernel(pve.iGz,o,l)}});var gxe=n(6410);const yxe={kernelName:pve.A1h,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:s}=n;Wve.vA((0,Uve.Dh)(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>(0,gxe.c)(i.shape,e,o,a,s),filter:()=>mxe(i,e,o.shape,a,s)}}};var bxe=n(9519);const vxe={kernelName:pve.Mn0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)((0,vve.H)((0,bxe.F)((0,fve.w)(n,"float32"))),e)}}};var xxe=n(8143);const wxe={kernelName:pve.MnK,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)((0,xxe.L)((0,fve.w)(n,"float32")),e)}}};var kxe=n(9235),Sxe=n(7167),Ixe=n(2154);const Txe={kernelName:pve.nY8,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{const t=(0,kxe.Em)([a],r.rank);let n=(0,Sxe.r)(e,a,s,!i);return null!=t&&(n=(0,Ixe.m)(n,t)),n}}}};var Nxe=n(7399),Cxe=n(261);const Axe={kernelName:pve.tGH,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Wve.vA(Uve.Dh(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=t;return Wve.vA(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),Wve.vA(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),Wve.vA(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Wve.vA(Uve.G0(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),Uve.s_("depthwiseConv2d",s,i),{x:()=>(0,Cxe.l)(l.shape,e,u,a,s,o,i),filter:()=>(0,Nxe.x)(l,e,u.shape,a,s,o,i)}}},Exe={kernelName:pve.jxD,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>Bve.T2.runKernel(pve.bP9,s,n),filter:()=>Bve.T2.runKernel(pve.pk0,i,n)}}},_xe={kernelName:pve.Pah,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>Bve.T2.runKernel(pve.rsH,r)}}};var $xe=n(5462);const Rxe={kernelName:pve._s9,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=(0,mve.l)((0,$xe.o)((0,vve.H)((0,kve.E)(n))),2/Math.sqrt(Math.PI));return{x:()=>(0,mve.l)(e,r)}}},Dxe={kernelName:pve.ox3,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)(e,n)}}},Mxe={kernelName:pve.ybN,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>(0,Cve.t)(e,n.shape)}}},Fxe={kernelName:pve.ybj,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)(e,(0,$xe.o)(n))}}},Oxe={kernelName:pve.ZgB,gradFunc:e=>({x:()=>(0,$ve.P)(e)})},Pxe={kernelName:pve.ElG,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=(0,Nve.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,bve.y)(e,(0,fve.w)(r,"float32")),s=(0,Nve.getReductionAxes)(n.shape,a);return s.length>0?(0,Cve.t)((0,Ave.c)(t,s),n.shape):t},b:()=>{let t=(0,mve.l)(e,(0,fve.w)(n,"float32"));const s=(0,Nve.getReductionAxes)(r.shape,a);s.length>0&&(t=(0,Cve.t)((0,Ave.c)(t,s),r.shape));const i=(0,kve.E)(r);return(0,vve.H)((0,bve.y)(t,(0,fve.w)(i,"float32")))}}}};var Lxe=n(6777),zxe=n(3017);const Bxe={kernelName:pve.i5R,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?(0,xve.d)(1):o,u=(0,Nve.getReductionAxes)(s.shape,a.shape),c=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)c.push(a.shape[e]);c.push(1)}const d=(0,Sve.j)(a,s),h=(0,mve.l)(e,l),p=(0,Lxe.Z)((0,Fve.W)(i,(0,xve.d)(r))),f=(0,mve.l)((0,mve.l)((0,mve.l)(p,p),p),(0,xve.d)(-.5));return{x:()=>1===s.rank?(0,Cve.t)((0,mve.l)((0,mve.l)(e,(0,zxe.V)((0,Cve.t)(p,[1,1,1,s.shape[0]]),c)),l),a.shape):(0,Cve.t)((0,mve.l)((0,mve.l)(e,p),l),a.shape),mean:()=>{let e=(0,mve.l)((0,mve.l)(p,(0,xve.d)(-1)),h);return 1===s.rank&&(e=(0,Ave.c)(e,u)),(0,Cve.t)(e,s.shape)},variance:()=>{let e=(0,mve.l)((0,mve.l)(f,d),h);return 1===s.rank&&(e=(0,Ave.c)(e,u)),(0,Cve.t)(e,s.shape)},scale:()=>{const t=(0,mve.l)(d,p);let n=(0,mve.l)(e,t);return 1===s.rank&&(n=(0,Ave.c)(n,u)),(0,Cve.t)(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=(0,Ave.c)(t,u)),(0,Cve.t)(t,s.shape)}}}};var Vxe=n(901),Wxe=n(5149);const Uxe={kernelName:pve.mxL,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,a]=t,{axis:s,batchDims:i}=n,o=(0,Wve.Y6)(s,r.shape)[0],l=(e,t,n)=>()=>{const r=e.shape,a=t.size,i=r.slice(0,o),l=i.length,u=r.slice(s,r.length).slice(1),c=u.length,d=jxe(0,l),h=jxe(l+1,l+1+c),p=Gxe([i,[a],u]),f=(0,Cve.t)(n,p),m=(0,Cve.t)(t,[a]),g=Gxe([[l],d,h]),y=(0,Ixe.m)(f,g);let b=(0,Wxe.z)(y,m,e.shape[o]);const v=(0,kxe.gx)(g);return b=(0,Ixe.m)(b,v),b};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>{const t=(0,Vxe.t)(n.map(((t,n)=>l(t,a.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)},indices:()=>a}}return{x:l(r,a,e),indices:()=>a}}};function jxe(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function Gxe(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const Hxe={kernelName:pve.lLS,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,$ve.P)(n),b:()=>(0,$ve.P)(r)}}},qxe={kernelName:pve.lzr,gradFunc:e=>({x:()=>(0,fve.w)(e,"float32")})},Kxe={kernelName:pve.gIW,gradFunc:e=>({x:()=>(0,$ve.P)(e)})},Yxe={kernelName:pve.E3$,gradFunc:e=>({x:()=>(0,$ve.P)(e)})},Xxe={kernelName:pve.iPs,gradFunc:e=>({x:()=>(0,$ve.P)(e)})};var Qxe=n(2759);const Zxe={kernelName:pve.X0$,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:a}=n,s=(0,Qxe.r)(r,0);return{x:()=>(0,sxe._)(s,e,(0,mve.l)(e,a))}}},Jxe={kernelName:pve.Cg$,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,bve.y)(e,(0,Fve.W)(n,1))}}},ewe={kernelName:pve.tG8,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,bve.y)(e,(0,fve.w)(n,"float32"))}}},twe={kernelName:pve.zfU,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;return{logits:()=>{const t=(0,$xe.o)(r);return(0,Sve.j)(e,(0,mve.l)((0,Ave.c)(e,a,!0),t))}}}};const nwe=(0,jve.op)({localResponseNormalizationBackprop_:function(e,t,n){const r={x:e,y:t,dy:n},a={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return Bve.T2.runKernel(pve.ToN,r,a)}}),rwe={kernelName:pve.jM4,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>nwe(r,a,e,s,i,o,l)}}};var awe=n(7457);function swe(e,t,n,r){return t.rank<n.rank&&(t=(0,Cve.t)(t,kxe.SM(t.shape,r))),e.rank<n.rank&&(e=(0,Cve.t)(e,kxe.SM(e.shape,r))),{x:()=>(0,mve.l)(e,(0,fve.w)((0,awe.L)(n,t),e.dtype))}}const iwe={kernelName:pve.VAI,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:a}=r,s=t[0],i=swe(e,t[1],s,Wve.Y6(a,s.shape));return{x:()=>i.x()}}};var owe=n(8320);const lwe={kernelName:pve.LDN,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,mve.l)(e,(0,fve.w)((0,nxe.D)(n,r),"float32")),b:()=>(0,mve.l)(e,(0,fve.w)((0,owe.M)(n,r),"float32"))}}};const uwe=(0,jve.op)({maxPool3dGrad_:function(e,t,n,r,a,s,i){const o=(0,Vve.YT)(e,"dy","maxPool3dGrad"),l=(0,Vve.YT)(t,"input","maxPool3dGrad"),u=(0,Vve.YT)(n,"output","maxPool3dGrad");let c=o,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=(0,Cve.t)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=(0,Cve.t)(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=(0,Cve.t)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Wve.vA(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),Wve.vA(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),Wve.vA(5===h.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),(0,Uve.s_)("maxPool3dGrad",s,i);const f={dy:c,input:d,output:h},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=Bve.T2.runKernel(pve.cHb,f,m);return p?(0,Cve.t)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),cwe={kernelName:pve.ySp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>uwe(e,r,a,s,i,o,l)}}};const dwe=(0,jve.op)({maxPoolGrad_:function(e,t,n,r,a,s,i){const o=(0,Vve.YT)(e,"dy","maxPoolGrad"),l=(0,Vve.YT)(t,"input","maxPoolGrad"),u=(0,Vve.YT)(n,"output","maxPoolGrad");Wve.vA(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),Wve.vA(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Wve.vA(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Uve.s_("maxPoolGrad",s,i);const c={dy:o,input:l,output:u},d={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return Bve.T2.runKernel(pve.RXX,c,d)}}),hwe={kernelName:pve.t3d,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>dwe(e,r,a,s,i,o)}}};var pwe=n(4616);const fwe={kernelName:pve.g5A,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n,s=Wve.Y6(a,r.shape),i=(0,kxe.lb)(r.shape,s)[1],o=Wve.Ze(i);return{x:()=>{const t=r.shape.slice();s.forEach((e=>{t[e]=1}));const n=(0,Cve.t)(e,t);return(0,bve.y)((0,mve.l)(n,(0,pwe.S)(r.shape,"float32")),o)}}}},mwe={kernelName:pve.lNG,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:a}=r,[s,i]=t,o=swe(e,i,s,Wve.Y6(a,s.shape));return{x:()=>o.x()}}},gwe={kernelName:pve.LG0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>(0,mve.l)(e,(0,fve.w)((0,rxe.I)(n,r),"float32")),b:()=>(0,mve.l)(e,(0,fve.w)((0,Qxe.r)(n,r),"float32"))}}};var ywe=n(463);const bwe={kernelName:pve.x7F,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>(0,ywe.d)(e,s,r.shape)}}};var vwe=n(8587);const xwe={kernelName:pve.BLA,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=(0,Nve.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,Nve.getReductionAxes)(n.shape,a);return t.length>0?(0,Cve.t)((0,Ave.c)(e,t),n.shape):e},b:()=>{const t=(0,mve.l)(e,(0,vve.H)((0,vwe.R)((0,bve.y)(n,r)))),s=(0,Nve.getReductionAxes)(r.shape,a);return s.length>0?(0,Cve.t)((0,Ave.c)(t,s),r.shape):t}}}},wwe={kernelName:pve.xu7,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=(0,Nve.assertAndGetBroadcastShape)(n.shape,r.shape);return{a:()=>{const t=(0,mve.l)(e,(0,fve.w)(r,"float32")),s=(0,Nve.getReductionAxes)(n.shape,a);return s.length>0?(0,Cve.t)((0,Ave.c)(t,s),n.shape):t},b:()=>{const t=(0,mve.l)(e,(0,fve.w)(n,"float32")),s=(0,Nve.getReductionAxes)(r.shape,a);return s.length>0?(0,Cve.t)((0,Ave.c)(t,s),r.shape):t}}}},kwe={kernelName:pve.l0G,gradFunc:e=>({x:()=>(0,vve.H)(e)})};var Swe=n(4218);const Iwe={kernelName:pve.urI,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>(0,Swe.U)(n.shape,"float32")}}},Twe={kernelName:pve.LWX,gradFunc:e=>({x:()=>(0,$ve.P)(e)})};var Nwe=n(3984);const Cwe={kernelName:pve.mM$,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return(0,Nwe.K)(e,r).map((e=>()=>e))}},Awe={kernelName:pve.ODT,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>(0,ywe.d)(e,s,r.shape)}}};var Ewe=n(5911),_we=n(7587);const $we={kernelName:pve.pyJ,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,a]=t,s=n,i=r,o=Nve.assertAndGetBroadcastShape(s.shape,i.shape);return{a:()=>{const t=(0,fve.w)(i,"float32");let n=(0,mve.l)(e,(0,mve.l)(t,(0,_we.n)(s,(0,Sve.j)(t,(0,xve.d)(1)))));const r=Nve.getReductionAxes(s.shape,o);return r.length>0&&(n=(0,Ave.c)(n,r)),(0,Cve.t)(n,s.shape)},b:()=>{const t=(0,Qxe.r)(s,0),n=(0,sxe._)(t,(0,Ewe.R)(s),(0,$ve.P)(s));let r=(0,mve.l)(e,(0,mve.l)(a,n));const l=Nve.getReductionAxes(i.shape,o);return l.length>0&&(r=(0,Ave.c)(r,l)),(0,Cve.t)(r,i.shape)}}}},Rwe={kernelName:pve.Ncv,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,a=(0,Qxe.r)(n,0);return{x:()=>(0,sxe._)(a,e,(0,mve.l)(e,r)),alpha:()=>{let t=(0,sxe._)(a,(0,$ve.P)(e),(0,mve.l)(e,n));const s=(0,Nve.getReductionAxes)(r.shape,e.shape);return s.length>0&&(t=(0,Ave.c)(t,s)),(0,Cve.t)(t,r.shape)}}}};var Dwe=n(3739);function Mwe(e,t,n){const r=e.shape.length,a=r-n.length,s=kxe.Em(n,r);let i=e;null!=s&&(i=(0,Ixe.m)(e,s));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const a=(0,Cve.t)(t,r),s=(0,Dwe.L)(e,n,!0,!1),i=(0,Dwe.L)(e,n,!0,!0),o=(0,mve.l)(s,i);return(0,mve.l)(a,o)}(i.reshape(o),t,a);if(u=u.reshape(i.shape),null!=s){const e=kxe.gx(s);u=(0,Ixe.m)(u,e)}return u}const Fwe={kernelName:pve.kdj,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:a}=n;let s=[];return s=void 0===a||null===a?r.shape.map(((e,t)=>t)):"number"===typeof a?[a]:a,{x:()=>Mwe(r,e,s)}}},Owe={kernelName:pve.sDr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Nve.assertAndGetBroadcastShape(n.shape,r.shape);return{a:()=>{const t=(0,bve.y)(e,(0,fve.w)(r,"float32")),s=Nve.getReductionAxes(n.shape,a);return s.length>0?(0,Cve.t)((0,Ave.c)(t,s),n.shape):t},b:()=>{let t=(0,mve.l)(e,(0,fve.w)(n,"float32"));const s=Nve.getReductionAxes(r.shape,a);s.length>0&&(t=(0,Cve.t)((0,Ave.c)(t,s),r.shape));const i=(0,kve.E)(r);return(0,vve.H)((0,bve.y)(t,(0,fve.w)(i,"float32")))}}}},Pwe={kernelName:pve.huO,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,bve.y)(e,(0,vve.H)((0,kve.E)(n)))}}},Lwe={kernelName:pve.P_L,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=(0,mve.l)((0,rxe.I)(n,6),(0,gve.P)(n));return{x:()=>(0,mve.l)(e,(0,fve.w)(r,"float32"))}}},zwe={kernelName:pve.fUj,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)(e,(0,fve.w)((0,gve.P)(n),"float32"))}}},Bwe={kernelName:pve.R23,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,Cve.t)(e,n.shape)}}},Vwe={kernelName:pve.hgw,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>Bve.T2.runKernel(pve.FCQ,a,n)}}},Wwe={kernelName:pve.jOE,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,a={dy:e,images:r};return{images:()=>Bve.T2.runKernel(pve.XQy,a,n)}}};var Uwe=n(7419);const jwe={kernelName:pve.D7i,gradFunc:(e,t,n)=>{const{dims:r}=n,a=(0,Wve.Y6)(r,e.shape);return{x:()=>(0,Uwe.B)(e,a)}}},Gwe={kernelName:pve.hVg,gradFunc:e=>({x:()=>(0,$ve.P)(e)})},Hwe={kernelName:pve.TOR,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,vve.H)((0,bve.y)(e,(0,mve.l)((0,_we.n)(n,1.5),2)))}}};var qwe=n(5344);const Kwe={kernelName:pve.l6P,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>(0,fve.w)((0,$ve.P)(n),"float32"),t:()=>(0,mve.l)(e,(0,fve.w)(n,e.dtype)),e:()=>(0,mve.l)(e,(0,fve.w)((0,qwe.N)(n),e.dtype))}}};var Ywe=n(3765);const Xwe={kernelName:pve.u$b,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=(0,Qxe.r)(n,(0,xve.d)(0)),r=(0,xve.d)(Ywe.j),a=(0,xve.d)(Ywe.X),s=(0,mve.l)(e,a),i=(0,mve.l)((0,mve.l)(e,r),(0,$xe.o)((0,fve.w)(n,"float32")));return(0,sxe._)(t,s,i)}}}},Qwe={kernelName:pve.vI1,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)(e,(0,mve.l)(n,(0,Sve.j)((0,xve.d)(1),n)))}}},Zwe={kernelName:pve.YVe,gradFunc:e=>({x:()=>(0,$ve.P)(e)})};var Jwe=n(5894);const eke={kernelName:pve.hql,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)((0,Jwe.g)((0,fve.w)(n,"float32")),e)}}};var tke=n(1164);const nke={kernelName:pve.J3C,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)((0,tke.y)((0,fve.w)(n,"float32")),e)}}};var rke=n(5048),ake=n(4642);const ske={kernelName:pve.JiE,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=(0,ake.parseSliceParams)(r,a,s),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>(0,rke.e)(e,u)}}},ike={kernelName:pve.rFG,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:a}=n,s=(0,mve.l)(e,r);return{logits:()=>(0,Sve.j)(s,(0,mve.l)((0,Ave.c)(s,[a],true),r))}}};var oke=n(4213);const lke={kernelName:pve.Fin,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)(e,(0,oke.r)(n))}}};var uke=n(2557);const cke={kernelName:pve.A8B,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:a}=n;return{x:()=>(0,uke.G)(e,r,a)}}};var dke=n(4429);const hke={kernelName:pve.Blb,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>(0,dke.x)(e,r)}}},pke={kernelName:pve.dFH,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,bve.y)(e,(0,mve.l)((0,wve.R)((0,fve.w)(n,"float32")),2))}}},fke={kernelName:pve.M6A,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)(e,(0,mve.l)((0,fve.w)(n,"float32"),2))}}},mke={kernelName:pve.Ddj,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=(0,xve.d)(2);return{a:()=>(0,mve.l)(e,(0,mve.l)(a,(0,Sve.j)(n,r))),b:()=>(0,mve.l)(e,(0,mve.l)(a,(0,Sve.j)(r,n)))}}},gke={kernelName:pve.pnw,gradFunc:e=>({x:()=>(0,$ve.P)(e)})},yke={kernelName:pve.PbM,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,a=Nve.assertAndGetBroadcastShape(n.shape,r.shape);return{a:()=>{let t=e;const r=Nve.getReductionAxes(n.shape,a);return r.length>0&&(t=(0,Ave.c)(t,r)),(0,Cve.t)(t,n.shape)},b:()=>{let t=e;const n=Nve.getReductionAxes(r.shape,a);return n.length>0&&(t=(0,Ave.c)(t,n)),(0,Cve.t)((0,vve.H)(t),r.shape)}}}},bke={kernelName:pve.WuN,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,a=r.shape.slice(),{axis:s}=n;(0,Wve.Y6)(s,r.shape).forEach((e=>{a[e]=1}));const i=(0,Cve.t)(e,a),o=(0,mve.l)(i,(0,pwe.S)(r.shape,"float32"));return{x:()=>o}}},vke={kernelName:pve.oFs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,bve.y)(e,(0,kve.E)((0,Jwe.g)(n)))}}},xke={kernelName:pve.iuW,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,mve.l)((0,Sve.j)((0,xve.d)(1),(0,kve.E)(n)),e)}}},wke={kernelName:pve.FAs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:a}=n;return{x:()=>{let t=(0,$ve.P)(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=(0,Fve.W)(t,(0,ywe.d)(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=(0,Fve.W)(t,(0,ywe.d)(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=(0,Fve.W)(t,(0,ywe.d)(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=(0,Fve.W)(t,(0,ywe.d)(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},kke={kernelName:pve.wx0,gradFunc:(e,t,n)=>{const r=n,{perm:a}=r,s=kxe.gx(a);return{x:()=>(0,Ixe.m)(e,s)}}},Ske={kernelName:pve.dXR,gradFunc:(e,t,n)=>{const r=n,{axis:a}=r;return{value:()=>(0,Vxe.t)(e,a)}}};var Ike=n(4023),Tke=n(6178),Nke=n(2131);const Cke={kernelName:pve.pPe,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=(0,Nke.P)(t,(0,$ve.P)(t)),r=(0,Tke.k)(e,n);let a=(0,nxe.D)(t,(0,xve.d)(0,"int32"));const s=r.rank-a.rank;for(let o=0;o<s;++o)a=(0,Ike.U)(a,o+1);a=(0,axe.n)(a,(0,pwe.S)(r.shape,"bool"));const i=(0,$ve.P)(r);return(0,sxe._)(a,r,i)}(e,n)}}};const Ake={kernelName:pve.xJ3,gradFunc:e=>({x:()=>(0,$ve.P)(e)})};var Eke=n(843);const _ke=[yve,Ive,Tve,Eve,_ve,Rve,Dve,Mve,Ove,Pve,Lve,zve,Hve,Kve,Xve,Zve,Jve,exe,txe,ixe,oxe,uxe,fxe,hxe,yxe,vxe,wxe,Txe,Axe,Exe,Owe,_xe,Rxe,Dxe,Mxe,Fxe,Pxe,Oxe,Bxe,Uxe,Hxe,qxe,Kxe,Yxe,Xxe,Zxe,Jxe,ewe,twe,rwe,iwe,iwe,lwe,cwe,hwe,fwe,mwe,gwe,bwe,xwe,wwe,kwe,Iwe,Twe,Cwe,Awe,Awe,$we,Rwe,Fwe,Pwe,Lwe,zwe,Bwe,Vwe,Wwe,jwe,Gwe,Hwe,Kwe,Xwe,Qwe,Zwe,eke,nke,ske,ike,lke,cke,cke,hke,hke,pke,mke,fke,gke,yke,bke,vke,xke,wke,kke,Ske,Cke,Ake];for(const n of _ke)(0,Eke.kr)(n);var $ke=n(3753),Rke=n(9494);(0,Rke.tp)().prototype.abs=function(){return this.throwIfDisposed(),(0,$ke.t)(this)};var Dke=n(4759);(0,Rke.tp)().prototype.acos=function(){return this.throwIfDisposed(),(0,Dke.H)(this)};var Mke=n(983);(0,Rke.tp)().prototype.acosh=function(){return this.throwIfDisposed(),(0,Mke.F)(this)},(0,Rke.tp)().prototype.add=function(e){return this.throwIfDisposed(),(0,Fve.W)(this,e)};var Fke=n(1802);(0,Rke.tp)().prototype.all=function(e,t){return this.throwIfDisposed(),(0,Fke.Q)(this,e,t)};var Oke=n(1819);(0,Rke.tp)().prototype.any=function(e,t){return this.throwIfDisposed(),(0,Oke.b)(this,e,t)};var Pke=n(3068);(0,Rke.tp)().prototype.argMax=function(e){return this.throwIfDisposed(),(0,Pke.F)(this,e)};var Lke=n(8482);(0,Rke.tp)().prototype.argMin=function(e){return this.throwIfDisposed(),(0,Lke.X)(this,e)},(0,Rke.tp)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,Wve.vA)(1===this.size,(()=>"The array must have only 1 element.")),(0,Cve.t)(this,[])},(0,Rke.tp)().prototype.asType=function(e){return this.throwIfDisposed(),(0,fve.w)(this,e)},(0,Rke.tp)().prototype.as1D=function(){return this.throwIfDisposed(),(0,Cve.t)(this,[this.size])},(0,Rke.tp)().prototype.as2D=function(e,t){return this.throwIfDisposed(),(0,Cve.t)(this,[e,t])},(0,Rke.tp)().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),(0,Cve.t)(this,[e,t,n])},(0,Rke.tp)().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),(0,Cve.t)(this,[e,t,n,r])},(0,Rke.tp)().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),(0,Cve.t)(this,[e,t,n,r,a])};var zke=n(3010);(0,Rke.tp)().prototype.asin=function(){return this.throwIfDisposed(),(0,zke.q)(this)};var Bke=n(6464);(0,Rke.tp)().prototype.asinh=function(){return this.throwIfDisposed(),(0,Bke.y)(this)};var Vke=n(7803);(0,Rke.tp)().prototype.atan=function(){return this.throwIfDisposed(),(0,Vke.r)(this)};var Wke=n(6349);(0,Rke.tp)().prototype.atan2=function(e){return this.throwIfDisposed(),(0,Wke.F)(this,e)};var Uke=n(8147);(0,Rke.tp)().prototype.atanh=function(){return this.throwIfDisposed(),(0,Uke.r)(this)};var jke=n(8650);(0,Rke.tp)().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),(0,jke.$)(this,e,t,n,r)},(0,Rke.tp)().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),(0,uke.G)(this,e,t)};var Gke=n(9618);(0,Rke.tp)().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),(0,Gke.$)(this,e,t,n,r,a)};var Hke=n(4920);(0,Rke.tp)().prototype.broadcastTo=function(e){return this.throwIfDisposed(),(0,Hke.h)(this,e)},(0,Rke.tp)().prototype.cast=function(e){return this.throwIfDisposed(),(0,fve.w)(this,e)};var qke=n(5396);(0,Rke.tp)().prototype.ceil=function(){return this.throwIfDisposed(),(0,qke.m)(this)};var Kke=n(3829);(0,Rke.tp)().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),(0,Kke.z)(this,e,t)},(0,Rke.tp)().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Rke.qY&&(e=[e]),(0,dke.x)([this,...e],t)};var Yke=n(9870);(0,Rke.tp)().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),(0,Yke.k)(this,e,t,n,r,a,s)};var Xke=n(1137);(0,Rke.tp)().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),(0,Xke.w)(this,e,t,n,r,a)},(0,Rke.tp)().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),(0,pxe.X)(this,e,t,n,r,a,s)},(0,Rke.tp)().prototype.cos=function(){return this.throwIfDisposed(),(0,Jwe.g)(this)},(0,Rke.tp)().prototype.cosh=function(){return this.throwIfDisposed(),(0,tke.y)(this)},(0,Rke.tp)().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),(0,Dwe.L)(this,e,t,n)},(0,Rke.tp)().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),(0,Sxe.r)(this,e,t,n)};var Qke=n(1719);(0,Rke.tp)().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),(0,Qke.R)(this,e,t)};var Zke=n(9899);(0,Rke.tp)().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),(0,Zke.G)(this,e,t,n,r,a,s)};var Jke=n(3789);(0,Rke.tp)().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),(0,Jke.X)(this,e,t,n,r,a)};var eSe=n(44);(0,Rke.tp)().prototype.divNoNan=function(e){return this.throwIfDisposed(),(0,eSe.e)(this,e)},(0,Rke.tp)().prototype.div=function(e){return this.throwIfDisposed(),(0,bve.y)(this,e)};var tSe=n(6434);(0,Rke.tp)().prototype.dot=function(e){return this.throwIfDisposed(),(0,tSe.O)(this,e)};var nSe=n(3645);(0,Rke.tp)().prototype.elu=function(){return this.throwIfDisposed(),(0,nSe.P)(this)},(0,Rke.tp)().prototype.equal=function(e){return this.throwIfDisposed(),(0,awe.L)(this,e)};var rSe=n(8810);(0,Rke.tp)().prototype.erf=function(){return this.throwIfDisposed(),(0,rSe.Y)(this)};var aSe=n(8826);(0,Rke.tp)().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),(0,aSe.p)(this,e,t)},(0,Rke.tp)().prototype.exp=function(){return this.throwIfDisposed(),(0,$xe.o)(this)},(0,Rke.tp)().prototype.expandDims=function(e){return this.throwIfDisposed(),(0,Ike.U)(this,e)};var sSe=n(2520);(0,Rke.tp)().prototype.expm1=function(){return this.throwIfDisposed(),(0,sSe.I)(this)};var iSe=n(3062);(0,Rke.tp)().prototype.fft=function(){return this.throwIfDisposed(),(0,iSe.h)(this)},(0,Rke.tp)().prototype.flatten=function(){return this.throwIfDisposed(),(0,Cve.t)(this,[this.size])},(0,Rke.tp)().prototype.floor=function(){return this.throwIfDisposed(),(0,vwe.R)(this)};var oSe=n(3612);(0,Rke.tp)().prototype.floorDiv=function(e){return this.throwIfDisposed(),(0,oSe.w)(this,e)},(0,Rke.tp)().prototype.gather=function(e,t,n){return this.throwIfDisposed(),(0,Tke.k)(this,e,t,n)},(0,Rke.tp)().prototype.greaterEqual=function(e){return this.throwIfDisposed(),(0,nxe.D)(this,e)},(0,Rke.tp)().prototype.greater=function(e){return this.throwIfDisposed(),(0,Qxe.r)(this,e)};var lSe=n(1405);(0,Rke.tp)().prototype.ifft=function(){return this.throwIfDisposed(),(0,lSe.K)(this)};var uSe=n(7307);(0,Rke.tp)().prototype.irfft=function(){return this.throwIfDisposed(),(0,uSe.g)(this)};var cSe=n(9027);(0,Rke.tp)().prototype.isFinite=function(){return this.throwIfDisposed(),(0,cSe.M)(this)};var dSe=n(6005);(0,Rke.tp)().prototype.isInf=function(){return this.throwIfDisposed(),(0,dSe.E)(this)};var hSe=n(3467);(0,Rke.tp)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,hSe.y)(this)};var pSe=n(8076);(0,Rke.tp)().prototype.leakyRelu=function(e){return this.throwIfDisposed(),(0,pSe.H)(this,e)},(0,Rke.tp)().prototype.lessEqual=function(e){return this.throwIfDisposed(),(0,rxe.I)(this,e)},(0,Rke.tp)().prototype.less=function(e){return this.throwIfDisposed(),(0,owe.M)(this,e)};var fSe=n(6584);(0,Rke.tp)().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),(0,fSe.K)(this,e,t,n,r)};var mSe=n(4824);(0,Rke.tp)().prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,mSe.n)(this)};var gSe=n(1194);(0,Rke.tp)().prototype.logSoftmax=function(e){return this.throwIfDisposed(),(0,gSe.H)(this,e)};var ySe=n(2175);(0,Rke.tp)().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),(0,ySe.V)(this,e,t)},(0,Rke.tp)().prototype.log=function(){return this.throwIfDisposed(),(0,Ewe.R)(this)};var bSe=n(1386);(0,Rke.tp)().prototype.log1p=function(){return this.throwIfDisposed(),(0,bSe.K)(this)},(0,Rke.tp)().prototype.logicalAnd=function(e){return this.throwIfDisposed(),(0,axe.n)(this,e)},(0,Rke.tp)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,qwe.N)(this)};var vSe=n(7920);(0,Rke.tp)().prototype.logicalOr=function(e){return this.throwIfDisposed(),(0,vSe.z)(this,e)};var xSe=n(3708);(0,Rke.tp)().prototype.logicalXor=function(e){return this.throwIfDisposed(),(0,xSe.r)(this,e)},(0,Rke.tp)().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),(0,Yve.N)(this,e,t,n)};var wSe=n(6044);(0,Rke.tp)().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),(0,wSe.j)(this,e,t,n,r)};var kSe=n(891);(0,Rke.tp)().prototype.max=function(e,t){return this.throwIfDisposed(),(0,kSe.T)(this,e,t)},(0,Rke.tp)().prototype.maximum=function(e){return this.throwIfDisposed(),(0,Nke.P)(this,e)};var SSe=n(3015);(0,Rke.tp)().prototype.mean=function(e,t){return this.throwIfDisposed(),(0,SSe.i)(this,e,t)};var ISe=n(1465);(0,Rke.tp)().prototype.min=function(e,t){return this.throwIfDisposed(),(0,ISe.j)(this,e,t)};var TSe=n(6561);(0,Rke.tp)().prototype.minimum=function(e){return this.throwIfDisposed(),(0,TSe.B)(this,e)};var NSe=n(4252);(0,Rke.tp)().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),(0,NSe.F)(this,e,t)};var CSe=n(3617);(0,Rke.tp)().prototype.mod=function(e){return this.throwIfDisposed(),(0,CSe.z)(this,e)},(0,Rke.tp)().prototype.mul=function(e){return this.throwIfDisposed(),(0,mve.l)(this,e)},(0,Rke.tp)().prototype.neg=function(){return this.throwIfDisposed(),(0,vve.H)(this)};var ASe=n(2155);(0,Rke.tp)().prototype.norm=function(e,t,n){return this.throwIfDisposed(),(0,ASe.x)(this,e,t,n)};var ESe=n(135);(0,Rke.tp)().prototype.notEqual=function(e){return this.throwIfDisposed(),(0,ESe.E)(this,e)};var _Se=n(9246);(0,Rke.tp)().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),(0,_Se.M)(this,e,t,n)};var $Se=n(4100);(0,Rke.tp)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,$Se.P)(this)},(0,Rke.tp)().prototype.pad=function(e,t){return this.throwIfDisposed(),(0,rke.e)(this,e,t)};var RSe=n(7751);(0,Rke.tp)().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),(0,RSe.d)(this,e,t,n,r,a,s)},(0,Rke.tp)().prototype.pow=function(e){return this.throwIfDisposed(),(0,_we.n)(this,e)};var DSe=n(9855);(0,Rke.tp)().prototype.prelu=function(e){return this.throwIfDisposed(),(0,DSe.N)(this,e)};var MSe=n(9556);(0,Rke.tp)().prototype.prod=function(e,t){return this.throwIfDisposed(),(0,MSe._)(this,e,t)};var FSe=n(6309);(0,Rke.tp)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,FSe.V)(this)};var OSe=n(5251);(0,Rke.tp)().prototype.relu=function(){return this.throwIfDisposed(),(0,OSe.V)(this)};var PSe=n(9721);(0,Rke.tp)().prototype.relu6=function(){return this.throwIfDisposed(),(0,PSe.j)(this)},(0,Rke.tp)().prototype.reshapeAs=function(e){return this.throwIfDisposed(),(0,Cve.t)(this,e.shape)},(0,Rke.tp)().prototype.reshape=function(e){return this.throwIfDisposed(),(0,Cve.t)(this,e)};var LSe=n(2214);(0,Rke.tp)().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),(0,LSe.v)(this,e,t,n)};var zSe=n(2823);(0,Rke.tp)().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),(0,zSe.b)(this,e,t,n)},(0,Rke.tp)().prototype.reverse=function(e){return this.throwIfDisposed(),(0,Uwe.B)(this,e)};var BSe=n(9486);(0,Rke.tp)().prototype.rfft=function(){return this.throwIfDisposed(),(0,BSe.z)(this)};var VSe=n(6509);(0,Rke.tp)().prototype.round=function(){return this.throwIfDisposed(),(0,VSe.L)(this)},(0,Rke.tp)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,Lxe.Z)(this)};var WSe=n(2022);(0,Rke.tp)().prototype.selu=function(){return this.throwIfDisposed(),(0,WSe.W)(this)};var USe=n(3117);(0,Rke.tp)().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),(0,USe.w)(this,e,t,n,r,a,s)},(0,Rke.tp)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,oke.r)(this)};var jSe=n(5740);(0,Rke.tp)().prototype.sign=function(){return this.throwIfDisposed(),(0,jSe._)(this)},(0,Rke.tp)().prototype.sin=function(){return this.throwIfDisposed(),(0,bxe.F)(this)},(0,Rke.tp)().prototype.sinh=function(){return this.throwIfDisposed(),(0,xxe.L)(this)},(0,Rke.tp)().prototype.slice=function(e,t){return this.throwIfDisposed(),(0,ywe.d)(this,e,t)};var GSe=n(6719);(0,Rke.tp)().prototype.softmax=function(e){return this.throwIfDisposed(),(0,GSe.V)(this,e)};var HSe=n(9973);(0,Rke.tp)().prototype.softplus=function(){return this.throwIfDisposed(),(0,HSe.l)(this)},(0,Rke.tp)().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),(0,Qve.e)(this,e,t)},(0,Rke.tp)().prototype.split=function(e,t){return this.throwIfDisposed(),(0,lxe.l)(this,e,t)},(0,Rke.tp)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,wve.R)(this)},(0,Rke.tp)().prototype.square=function(){return this.throwIfDisposed(),(0,kve.E)(this)};var qSe=n(208);(0,Rke.tp)().prototype.squaredDifference=function(e){return this.throwIfDisposed(),(0,qSe.P)(this,e)};var KSe=n(613);(0,Rke.tp)().prototype.squeeze=function(e){return this.throwIfDisposed(),(0,KSe.r)(this,e)},(0,Rke.tp)().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Rke.qY?[this,e]:[this,...e];return(0,Vxe.t)(n,t)},(0,Rke.tp)().prototype.step=function(e){return this.throwIfDisposed(),(0,gve.P)(this,e)};var YSe=n(1231);(0,Rke.tp)().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),(0,YSe.Y)(this,e,t,n,r,a,s,i,o)},(0,Rke.tp)().prototype.sub=function(e){return this.throwIfDisposed(),(0,Sve.j)(this,e)},(0,Rke.tp)().prototype.sum=function(e,t){return this.throwIfDisposed(),(0,Ave.c)(this,e,t)};var XSe=n(4894);(0,Rke.tp)().prototype.tan=function(){return this.throwIfDisposed(),(0,XSe.M)(this)};var QSe=n(6532);(0,Rke.tp)().prototype.tanh=function(){return this.throwIfDisposed(),(0,QSe.y)(this)},(0,Rke.tp)().prototype.tile=function(e){return this.throwIfDisposed(),(0,zxe.V)(this,e)},(0,Rke.tp)().prototype.toBool=function(){return this.throwIfDisposed(),(0,fve.w)(this,"bool")},(0,Rke.tp)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,fve.w)(this,"float32")},(0,Rke.tp)().prototype.toInt=function(){return this.throwIfDisposed(),(0,fve.w)(this,"int32")};var ZSe=n(2765);(0,Rke.tp)().prototype.topk=function(e,t){return this.throwIfDisposed(),(0,ZSe.r)(this,e,t)},(0,Rke.tp)().prototype.transpose=function(e){return this.throwIfDisposed(),(0,Ixe.m)(this,e)};var JSe=n(9694);(0,Rke.tp)().prototype.unique=function(e){return this.throwIfDisposed(),(0,JSe.A)(this,e)},(0,Rke.tp)().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),(0,Wxe.z)(this,e,t)},(0,Rke.tp)().prototype.unstack=function(e){return this.throwIfDisposed(),(0,Nwe.K)(this,e)},(0,Rke.tp)().prototype.where=function(e,t){return this.throwIfDisposed(),(0,sxe._)(e,this,t)},(0,Rke.tp)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,$ve.P)(this)};class eIe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,eIe.prototype)}}class tIe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,tIe.prototype)}}class nIe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,nIe.prototype)}}class rIe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,rIe.prototype)}}class aIe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,aIe.prototype)}}Error;class sIe{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function iIe(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function oIe(e,t){if(!e)throw new aIe(t)}function lIe(e,t){let n=0;for(const r of e)r===t&&n++;return n}function uIe(e){return 1===e.length?e[0]:e}function cIe(e){return Array.isArray(e)?e:[e]}function dIe(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function hIe(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let pIe={};function fIe(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function mIe(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>mIe(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?mIe(t):e[n]=t.value)}}}function gIe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const a=e;let s;if(a in n)s=n[a];else if(a in pIe)s=pIe[a];else if(s=t[a],null==s)throw new nIe(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return s}{const s=e;if(null==s.className||null==s.config)throw new nIe(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);const i=s.className;let o,l;if(i in n?[o,l]=n[i]:i in pIe?[o,l]=pIe.className:i in t&&([o,l]=t[i]),null==o)throw new nIe(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const n of Object.keys(pIe))e[n]=pIe[n];for(const a of Object.keys(n))e[a]=n[a];s.config.customObjects=e;const t=Object.assign({},pIe);for(const a of Object.keys(n))pIe[a]=n[a];mIe(s.config);const r=l(o,s.config,n,a);return pIe=Object.assign({},t),r}{const e=Object.assign({},pIe);for(const r of Object.keys(n))pIe[r]=n[r];const t=new o(s.config);return pIe=Object.assign({},e),t}}}function yIe(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function bIe(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function vIe(e){if(null==e)throw new nIe(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function xIe(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new nIe(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function wIe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return oIe(n>=0),oIe(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function kIe(e,t){Array.isArray(e)?(hve.util.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>kIe(e,`element ${n+1} of ${t}`)))):hve.util.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${SIe(e)}.`))}function SIe(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>SIe(e))).join(",")+"]":"string"===typeof e?`"${e}"`:`${e}`}function IIe(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let TIe=0;function NIe(){return TIe++}const CIe={};function AIe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in CIe||(CIe[e]=0),CIe[e]+=1,e+CIe[e].toString()}const EIe=["channelsFirst","channelsLast"],_Ie=["nearest","bilinear"],$Ie=["valid","same","causal"],RIe=["max","avg"],DIe=["sum","mul","concat","ave"],MIe=new Map;function FIe(e){xIe(EIe,"DataFormat",e)}function OIe(e){xIe($Ie,"PaddingMode",e)}function PIe(e){xIe(RIe,"PoolMode",e)}const LIe=[],zIe="/";function BIe(e,t){LIe.push(e);try{const e=t();return LIe.pop(),e}catch(KR){throw LIe.pop(),KR}}function VIe(e){if(!jIe(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===LIe.length?"":LIe.join(zIe)+zIe)+e}function WIe(e){if(!jIe(e))throw new Error("Not a valid tensor name: '"+e+"'");MIe.has(e)||MIe.set(e,0);const t=MIe.get(e);if(MIe.set(e,MIe.get(e)+1),t>0){const n=`${e}_${t}`;return MIe.set(n,1),n}return e}const UIe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function jIe(e){return!!e.match(UIe)}function GIe(e){return e===parseInt(e.toString(),10)}function HIe(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function qIe(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function KIe(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function YIe(e,t){if(t<e)throw new nIe(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let XIe;function QIe(){return null==XIe&&(XIe=(0,hve.backend)().epsilon()),XIe}function ZIe(e,t){return hve.cast(e,t)}function JIe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),hve.reshape(e,n)}function eTe(e,t,n){return(0,hve.tidy)((()=>{switch(e.rank){case 1:return hve.slice1d(e,t,n);case 2:return hve.slice2d(e,[t,0],[n,e.shape[1]]);case 3:return hve.slice3d(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return hve.slice4d(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return hve.slice(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return hve.slice(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new nIe(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function tTe(e,t,n){return(0,hve.tidy)((()=>{switch(e.rank){case 1:return hve.slice1d(e,t,n);case 2:return hve.slice2d(e,[0,t],[e.shape[0],n]);case 3:return hve.slice3d(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return hve.slice4d(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new nIe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function nTe(e,t,n,r){return(0,hve.tidy)((()=>{switch(e.rank){case 1:return hve.slice1d(e,t,n);case 2:switch(r){case 1:return eTe(e,t,n);case 2:return tTe(e,t,n);default:throw new nIe(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return eTe(e,t,n);case 2:return hve.slice3d(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return tTe(e,t,n);default:throw new nIe(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return eTe(e,t,n);case 2:return hve.slice4d(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return hve.slice4d(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return tTe(e,t,n);default:throw new nIe(`The axis is not within the rank of the tensor ${r}`)}default:throw new nIe(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function rTe(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),hve.concat(e,n)}function aTe(e,t){switch(e.rank){case 1:return hve.concat1d([e,t]);case 2:return hve.concat2d([e,t],0);case 3:return hve.concat3d([e,t],0);case 4:return hve.concat4d([e,t],0);default:throw new nIe(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function sTe(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new nIe(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return hve.tile(e,t)}function iTe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,a=arguments.length>4?arguments[4]:void 0;return hve.randomNormal(e,t,n,r,a)}function oTe(e,t,n,r){if(e.rank<2||t.rank<2)throw new rIe(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new rIe(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){const a=!1,s=!1;return hve.fused.matMul({a:e,b:t,transposeA:a,transposeB:s,bias:r?cTe(e.rank,r,"channelsLast"):null,activation:n})}{const a=e.shape.slice(),s=a.pop();e=hve.reshape(e,[-1,s]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=hve.reshape(hve.transpose(t,c),[l,-1]);const d=[...a,...u],h=!1,p=!1;return hve.reshape(hve.fused.matMul({a:e,b:t,transposeA:h,transposeB:p,bias:r?cTe(e.rank,r,"channelsLast"):null,activation:n}),d)}}function lTe(e,t,n){return(0,hve.tidy)((()=>(t=Array.isArray(t)?(0,hve.tensor1d)(t,"int32"):hve.cast(t,"int32"),hve.gather(e,t,n))))}function uTe(e){return hve.mul(e,e)}function cTe(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new nIe(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?hve.reshape(t,[1,r[0],1,1,1]):hve.reshape(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?hve.reshape(t,[1,1,1,1,r[0]]):hve.reshape(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?hve.reshape(t,[1,r[0],1,1]):hve.reshape(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?hve.reshape(t,[1,1,1,r[0]]):hve.reshape(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?hve.reshape(t,[1,r[0],1]):hve.reshape(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?hve.reshape(t,[1,1,r[0]]):hve.reshape(t,[1].concat(r))}else if(e<3)return t;throw new nIe(`Unsupported input rank by biasAdd: ${t.rank}`)}function dTe(e,t,n){return(0,hve.tidy)((()=>(null==n&&(n="channelsLast"),FIe(n),hve.add(e,cTe(e.rank,t,n)))))}function hTe(e,t,n,r){return(0,hve.tidy)((()=>hve.dropout(e,t,n,r)))}function pTe(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const fTe=["fanIn","fanOut","fanAvg"],mTe=["normal","uniform","truncatedNormal"];class gTe extends hve.serialization.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class yTe extends gTe{apply(e,t){return(0,hve.zeros)(e,t)}}yTe.className="Zeros",hve.serialization.registerClass(yTe);class bTe extends gTe{apply(e,t){return(0,hve.ones)(e,t)}}bTe.className="Ones",hve.serialization.registerClass(bTe);class vTe extends gTe{constructor(e){if(super(),"object"!==typeof e)throw new nIe(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new nIe(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return(0,hve.tidy)((()=>(0,hve.mul)((0,hve.scalar)(this.value),(0,hve.ones)(e,t))))}getConfig(){return{value:this.value}}}vTe.className="Constant",hve.serialization.registerClass(vTe);class xTe extends gTe{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return(0,hve.randomUniform)(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}xTe.className="RandomUniform",hve.serialization.registerClass(xTe);class wTe extends gTe{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new rIe(`randomNormal does not support dType ${t}.`);return iTe(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}wTe.className="RandomNormal",hve.serialization.registerClass(wTe);class kTe extends gTe{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new rIe(`truncatedNormal does not support dType ${t}.`);return(0,hve.truncatedNormal)(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}kTe.className="TruncatedNormal",hve.serialization.registerClass(kTe);class STe extends gTe{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return(0,hve.tidy)((()=>{if(2!==e.length||e[0]!==e[1])throw new nIe("Identity matrix initializer can only be used for 2D square matrices.");return(0,hve.mul)(this.gain,(0,hve.eye)(e[0]))}))}getConfig(){return{gain:this.gain}}}STe.className="Identity",hve.serialization.registerClass(STe);class ITe extends gTe{constructor(e){if(super(),e.scale<0)throw new nIe(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,xIe(fTe,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){xIe(mTe,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(FIe(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){const r=HIe(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){const r=HIe(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{const r=HIe(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],a=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new rIe(`${this.getClassName()} does not support dType ${t}.`);return(0,hve.truncatedNormal)(e,0,n,t,this.seed)}{const n=Math.sqrt(3*s);return(0,hve.randomUniform)(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}ITe.className="VarianceScaling",hve.serialization.registerClass(ITe);class TTe extends ITe{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ITe.className}}TTe.className="GlorotUniform",hve.serialization.registerClass(TTe);class NTe extends ITe{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ITe.className}}NTe.className="GlorotNormal",hve.serialization.registerClass(NTe);class CTe extends ITe{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ITe.className}}CTe.className="HeNormal",hve.serialization.registerClass(CTe);class ATe extends ITe{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ITe.className}}ATe.className="HeUniform",hve.serialization.registerClass(ATe);class ETe extends ITe{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ITe.className}}ETe.className="LeCunNormal",hve.serialization.registerClass(ETe);class _Te extends ITe{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ITe.className}}_Te.className="LeCunUniform",hve.serialization.registerClass(_Te);class $Te extends gTe{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return(0,hve.tidy)((()=>{if(e.length<2)throw new rIe("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=hve.util.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const s=iTe([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=hve.linalg.qr(s,!1);let o=i[0];const l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=(0,hve.mul)(o,l.sign()),n<r&&(o=o.transpose()),(0,hve.mul)((0,hve.scalar)(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}$Te.className="Orthogonal",hve.serialization.registerClass($Te);const RTe={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function DTe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return gIe(e,hve.serialization.SerializationMap.getMap().classNameMap,t,"initializer")}function MTe(e){return fIe(e)}function FTe(e){if("string"===typeof e){const t=e in RTe?RTe[e]:e;if("GlorotNormal"===t)return new NTe;if("GlorotUniform"===t)return new TTe;if("HeNormal"===t)return new CTe;if("HeUniform"===t)return new ATe;if("LeCunNormal"===t)return new ETe;if("LeCunUniform"===t)return new _Te;{const e={};return e.className=t,e.config={},DTe(e)}}return e instanceof gTe?e:DTe(e)}function OTe(e){return Array.isArray(e)&&Array.isArray(e[0])}function PTe(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function LTe(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new nIe(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function zTe(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new nIe(`Expected exactly 1 Shape; got ${e.length}`)}return e}function BTe(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const VTe="Variable";class WTe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:VTe,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=NIe(),n=null==n?VTe:n,this.originalName=VIe(n),this.name=WIe(this.originalName),this.trainable_=r,this.constraint=a,this.val=hve.variable(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function UTe(e){return e.map((e=>e.read()))}function jTe(e){e.forEach((e=>{e[0].write(e[1])}))}class GTe{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class HTe{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=NIe(),null!=s&&(this.originalName=VIe(s),this.name=WIe(this.originalName)),this.rank=t.length}}let qTe=0;class KTe{constructor(e,t){this.callArgs=t,this.id=qTe++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let YTe=0;class XTe extends hve.serialization.Serializable{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=YTe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=dIe(e)+"_"+AIe(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new tIe(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new nIe(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return uIe(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return uIe(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new eIe(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new eIe(`Layer ${this.name} is not connected, no input to return.`);return uIe(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new eIe(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new eIe(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return uIe(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=cIe(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=cIe(this.inputSpec);if(t.length!==n.length)throw new nIe(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const e=t[r],a=n[r];if(null==a)continue;const s=e.rank;if(null!=a.ndim&&s!==a.ndim)throw new nIe(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new nIe(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new nIe(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&e.dtype!==a.dtype)throw new nIe(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${e.dtype}.`);if(a.axes){const t=e.shape;for(const e in a.axes){const n=Number(e),s=a.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=s&&-1===[s,null].indexOf(i))throw new nIe(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${s} but got shape ${t}.`)}}if(null!=a.shape)for(let t=0;t<a.shape.length;++t){const n=a.shape[t],s=e.shape[t];if(null!=n&&null!=s&&n!==s)throw new nIe(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=cIe(e),r=function(e){let t=!0;for(const n of cIe(e))if(!(n instanceof HTe)){t=!1;break}return t}(e),a=function(e){let t=!0;for(const n of cIe(e))if(n instanceof HTe){t=!1;break}return t}(e);if(r===a)throw new nIe("Arguments to apply() must be all SymbolicTensors or all Tensors");return BIe(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of cIe(e))t.push(n.shape);this.build(uIe(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const a=cIe(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=uIe(s),null!=this.activityRegularizer)throw new rIe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=cIe(e);const t=[];for(const n of e)t.push(n.shape);return uIe(t)}(e),r=this.computeOutputShape(n);let a;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),a=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new HTe(s,n,this,cIe(e),t,this.name,r))):new HTe(s,r,this,cIe(e),t,this.name),this.addInboundNode(e,a,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new rIe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new eIe(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new eIe(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new tIe(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return BTe(this.weights)}build(e){this.built=!0}getWeights(){return UTe(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){(0,hve.tidy)((()=>{const t=this.weights;if(t.length!==e.length)throw new nIe(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=UTe(t);for(let a=0;a<r.length;++a){const s=r[a],i=t[a],o=e[a];if(!hve.util.arraysEqual(s.shape,o.shape))throw new nIe(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}jTe(n)}))}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new nIe(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():FTe("zeros"));const l=r.apply(t,n),u=new WTe(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=cIe(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),a=cIe(t),s=cIe(r);if(a.length!==s.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=s[i]}addInboundNode(e,t,n,r,a,s){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const o=cIe(e);t=cIe(t),n=cIe(n),r=cIe(r),a=PTe(a),s=PTe(s);const l=[],u=[],c=[];for(const d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new KTe({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function QTe(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=QTe(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class ZTe extends XTe{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:AIe("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new nIe("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new nIe("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new nIe("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new HTe(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new KTe({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new nIe(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}ZTe.className="InputLayer",hve.serialization.registerClass(ZTe);class JTe{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof JTe)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new nIe(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return(0,hve.cast)(t,e.dtype)}catch(n){throw new nIe(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof HTe){if(null==this.id2Value[e.id])throw new nIe(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new nIe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof HTe){if(null==this.id2Value[e.id])throw new nIe(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new nIe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&(0,hve.dispose)(this.id2Mask)}}const eNe=new sIe,tNe=new sIe;function nNe(e,t,n,r){const a=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(const f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let d,h=eNe.get(c);if(null==h){const e=function(e,t){hve.util.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const a=aNe(e[0],t);n=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of e){const{sorted:e,recipientMap:i}=aNe(s,t);for(const t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:rNe(r)}}(i,t);h=e.sorted,d=e.recipientCounts,eNe.put(c,h),tNe.put(c,d)}d={},a||Object.assign(d,tNe.get(c));const p=new JTe(t);for(let f=0;f<h.length;++f){if(null!=r){const e=(0,hve.memory)().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=h[f],s=e.sourceLayer;if(s instanceof ZTe)continue;const i=[],u=[],c=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),a||(d[n.name]--,0!==d[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&((n=n||{}).mask=u[0]);const g=cIe(s.apply(i,n));let y=null;s.supportsMasking&&(y=s.computeMask(i,u));const b=sNe(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);const e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}a||(0,hve.dispose)(c)}return p.disposeMasks(),s?l:l[0]}function rNe(e){const t={};for(const n in e)t[n]=e[n].size;return t}function aNe(e,t){const n=new Set,r=[],a={};for(const o of t.names())n.add(o);const s=[],i=[];for(s.push(e);s.length>0;){const e=s[s.length-1];if(n.has(e.name)){s.pop();continue}const t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(const t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),n.has(t.name)||s.push(t)}}return{sorted:r,recipientMap:a}}function sNe(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function iNe(e,t){return(0,hve.tidy)((()=>hve.sqrt(hve.sum(hve.mul(e,e),t,!0))))}(0,hve.env)().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=eNe&&eNe.setMaxEntries(e),null!=tNe&&tNe.setMaxEntries(e)}));class oNe extends hve.serialization.Serializable{getConfig(){return{}}}class lNe extends oNe{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,hve.tidy)((()=>{const t=iNe(e,this.axis),n=hve.clipByValue(t,0,this.maxValue);return hve.mul(e,hve.div(n,hve.add(QIe(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}lNe.className="MaxNorm",hve.serialization.registerClass(lNe);class uNe extends oNe{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,hve.tidy)((()=>hve.div(e,hve.add(QIe(),iNe(e,this.axis)))))}getConfig(){return{axis:this.axis}}}uNe.className="UnitNorm",hve.serialization.registerClass(uNe);class cNe extends oNe{apply(e){return hve.relu(e)}}cNe.className="NonNeg",hve.serialization.registerClass(cNe);class dNe extends oNe{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,hve.tidy)((()=>{const t=iNe(e,this.axis),n=hve.add(hve.mul(this.rate,hve.clipByValue(t,this.minValue,this.maxValue)),hve.mul(1-this.rate,t));return hve.mul(e,hve.div(n,hve.add(QIe(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}dNe.className="MinMaxNorm",hve.serialization.registerClass(dNe);const hNe={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function pNe(e){return fIe(e)}function fNe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return gIe(e,hve.serialization.SerializationMap.getMap().classNameMap,t,"constraint")}function mNe(e){if(null==e)return null;if("string"===typeof e){return fNe({className:e in hNe?hNe[e]:e,config:{}})}return e instanceof oNe?e:fNe(e)}async function gNe(e){if(null==e)return;const t=[],n=[],r=[];for(const a in e){const s=e[a];if("number"!==typeof s){const e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){const a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];(0,hve.dispose)(r)}}function yNe(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var bNe;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(bNe||(bNe={}));class vNe{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class xNe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class wNe extends vNe{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const r in t){const e=t[r];if("number"===typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;const a=(0,hve.tidy)((()=>(0,hve.add)(this.totals[r],(0,hve.mul)(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:(0,hve.tidy)((()=>{const e=(0,hve.mul)((0,hve.div)(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),(0,hve.keep)(t[n])})))}}class kNe extends vNe{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const a in this.history){const r=this.history[a];for(let s=0;s<r.length;++s)if("number"!==typeof r[s]){const i=r[s];e.push(i.data()),t.push(a),n.push(s)}}const r=await Promise.all(e);for(let a=0;a<r.length;++a){this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}}}class SNe extends vNe{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||hve.nextFrame,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");hve.util.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():hve.util.now();return function(){const s=null!=n?n():hve.util.now();return s-a<t||(a=s,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await gNe(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await gNe(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await gNe(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await gNe(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await gNe(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):hve.util.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await gNe(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await gNe(e),await this.trainEnd(e))}}function INe(e,t){if(null==e&&(e={}),e instanceof vNe)return[e];if(Array.isArray(e)&&e[0]instanceof vNe)return e;return cIe(e).map((e=>new SNe(e,t)))}class TNe{constructor(){}static registerCallbackConstructor(e,t){hve.util.assert(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),TNe.checkForDuplicate(t),null==TNe.constructors[e]&&(TNe.constructors[e]=[]),TNe.constructors[e].push(t)}static checkForDuplicate(e){for(const t in TNe.constructors){TNe.constructors[+t].forEach((t=>{if(t===e)throw new nIe("Duplicate callback constructor.")}))}}static clear(){TNe.constructors={}}static createCallbacks(e){const t=[];for(const n in TNe.constructors){const r=+n;e>=r&&t.push(...TNe.constructors[r])}return t.map((e=>new e))}}function NNe(e,t,n,r,a,s,i,o,l){const u=new kNe,c=[new wNe,...TNe.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const d=new xNe(c);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function CNe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return gIe(e,hve.serialization.SerializationMap.getMap().classNameMap,t,"layer",n)}function ANe(e,t){return(0,hve.tidy)((()=>{"float32"!==e.dtype&&(e=hve.cast(e,"float32"));const n=hve.sum(uTe(e),t,!0),r=hve.fill(n.shape,QIe()),a=hve.sqrt(hve.maximum(n,r));return hve.div(e,a)}))}function ENe(e,t){return(0,hve.tidy)((()=>hve.mean(uTe(hve.sub(t,e)),-1)))}function _Ne(e,t){return(0,hve.tidy)((()=>hve.mean(hve.abs(hve.sub(t,e)),-1)))}function $Ne(e,t){return(0,hve.tidy)((()=>{const n=hve.sub(e,t),r=hve.clipByValue(hve.abs(e),QIe(),Number.MAX_VALUE),a=hve.abs(hve.div(n,r));return hve.mul(100,hve.mean(a,-1))}))}function RNe(e,t){return(0,hve.tidy)((()=>{const n=hve.clipByValue(t,QIe(),Number.MAX_VALUE),r=hve.log(hve.add(1,n)),a=hve.clipByValue(e,QIe(),Number.MAX_VALUE),s=hve.log(hve.add(1,a));return hve.mean(uTe(hve.sub(r,s)),-1)}))}function DNe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return(0,hve.tidy)((()=>{if(n)t=hve.softmax(t);else{const e=hve.sum(t,t.shape.length-1,!0);t=hve.div(t,e)}return t=hve.clipByValue(t,QIe(),1-QIe()),hve.neg(hve.sum(hve.mul(hve.cast(e,"float32"),hve.log(t)),t.shape.length-1))}))}function MNe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return(0,hve.tidy)((()=>{const r=hve.cast(hve.floor(function(e){const t=[HIe(e.shape)];return hve.reshape(e,t)}(e)),"int32"),a=(t=hve.clipByValue(t,QIe(),1-QIe())).shape;return DNe(hve.reshape(hve.oneHot(r,a[a.length-1]),a),t,n)}))}function FNe(e,t){return(0,hve.tidy)((()=>{let n;return n=hve.clipByValue(t,QIe(),1-QIe()),n=hve.log(hve.div(n,hve.sub(1,n))),hve.mean(function(e,t){if(!hve.util.arraysEqual(e.shape,t.shape))throw new nIe(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return(0,hve.tidy)((()=>{const n=hve.relu(t),r=hve.neg(hve.abs(t));return hve.add(hve.sub(n,hve.mul(t,e)),hve.log1p(hve.exp(r)))}))}(e,n),-1)}))}function ONe(e,t){return(0,hve.tidy)((()=>{const n=hve.clipByValue(e,QIe(),1),r=hve.clipByValue(t,QIe(),1);return hve.sum(hve.mul(e,hve.log(hve.div(n,r))),-1)}))}function PNe(e,t){return(0,hve.tidy)((()=>{const n=ANe(e,-1),r=ANe(t,-1),a=hve.mul(n,r);return hve.neg(hve.sum(a,-1))}))}TNe.constructors={};const LNe={meanSquaredError:ENe,meanAbsoluteError:_Ne,meanAbsolutePercentageError:$Ne,meanSquaredLogarithmicError:RNe,squaredHinge:function(e,t){return(0,hve.tidy)((()=>{const n=hve.maximum(0,hve.sub(1,hve.mul(e,t)));return hve.mean(uTe(n),-1)}))},hinge:function(e,t){return(0,hve.tidy)((()=>{const n=hve.maximum(0,hve.sub(1,hve.mul(e,t)));return hve.mean(n,-1)}))},categoricalHinge:function(e,t){return(0,hve.tidy)((()=>{const n=hve.sum(hve.mul(e,t),-1),r=hve.max(hve.mul(hve.sub(1,e),t),-1);return hve.maximum(0,hve.add(1,hve.sub(r,n)))}))},logcosh:function(e,t){return(0,hve.tidy)((()=>{const n=Math.log(2),r=hve.sub(t,e),a=hve.sub(hve.add(r,hve.softplus(hve.mul(-2,r))),n);return hve.mean(a,-1)}))},categoricalCrossentropy:DNe,sparseCategoricalCrossentropy:MNe,binaryCrossentropy:FNe,kullbackLeiblerDivergence:ONe,poisson:function(e,t){return(0,hve.tidy)((()=>{const n=hve.log(hve.add(QIe(),t));return hve.mean(hve.sub(t,hve.mul(e,n)),-1)}))},cosineProximity:PNe};function zNe(e){if("string"===typeof e){if(e in LNe)return LNe[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new nIe(t)}return e}function BNe(e,t){return(0,hve.tidy)((()=>{const n=hve.mul(.5,hve.onesLike(t)),r=ZIe(hve.greater(t,n),e.dtype);return hve.mean(hve.equal(e,r),-1)}))}function VNe(e,t){return(0,hve.tidy)((()=>ZIe(hve.equal(hve.argMax(e,-1),hve.argMax(t,-1)),"float32")))}function WNe(e,t){return(0,hve.tidy)((()=>hve.cast(hve.sum(hve.logicalAnd(hve.equal(e,1),hve.equal(t,1))),"float32")))}function UNe(e,t){return FNe(e,t)}function jNe(e,t){return e.rank===t.rank&&(e=hve.squeeze(e,[e.rank-1])),(t=hve.argMax(t,-1)).dtype!==e.dtype&&(t=hve.cast(t,e.dtype)),hve.cast(hve.equal(e,t),"float32")}const GNe=DNe,HNe=MNe,qNe={binaryAccuracy:BNe,categoricalAccuracy:VNe,precision:function(e,t){return(0,hve.tidy)((()=>{const n=WNe(e,t),r=function(e,t){return(0,hve.tidy)((()=>hve.cast(hve.sum(hve.logicalAnd(hve.equal(e,0),hve.equal(t,1))),"float32")))}(e,t),a=hve.add(n,r);return hve.cast(hve.where(hve.greater(a,0),hve.div(n,a),0),"float32")}))},categoricalCrossentropy:GNe,sparseCategoricalCrossentropy:HNe,mse:ENe,MSE:ENe,mae:_Ne,MAE:_Ne,mape:$Ne,MAPE:$Ne,cosine:PNe};function KNe(e){if("string"===typeof e&&e in qNe)return qNe[e];if("string"!==typeof e&&null!=e)return e;throw new nIe(`Unknown metric ${e}`)}function YNe(e){if(oIe(null!==e,`Unknown LossOrMetricFn ${e}`),"string"===typeof e)return e;{let t;for(const n of Object.keys(LNe))if(LNe[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(qNe))if(qNe[n]===e){t=n;break}return void 0!==t?t:e.name}}const XNe=1048576;function QNe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!ZNe(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>XNe&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function ZNe(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!ZNe(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!ZNe(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function JNe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const a=function(e){let t=!0;const n=[],r=[];for(const a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(const a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(const a of e.layers){let e=!1;for(const n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),s=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(a?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!a){s.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),eCe(s,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)a?tCe(o[c],n,r):nCe(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;t=null!=e.collectedTrainableWeights?BTe(e.collectedTrainableWeights):BTe(e.trainableWeights);return t}(e),u=BTe(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function eCe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function tCe(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(s){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(s){r="multiple"}eCe([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function nCe(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(c){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(c){a="multiple"}const i=[];for(const d of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(d)))for(let e=0;e<d.inboundLayers.length;++e){const t=d.inboundLayers[e].name,n=d.nodeIndices[e],r=d.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}const o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];eCe([`${o} (${l})`,s,a,e.countParams().toString(),u],t,r);for(let d=1;d<i.length;++d)eCe(["","","","",i[d]],t,r)}function rCe(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function aCe(e,t){if(null===e)return null;if("string"===typeof e)return hIe(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];rCe(t,a,r)?n.push(r):n.push(aCe(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"===typeof r)t[n]=r;else{const e=hIe(n);t[e]=aCe(r,e)}}return t}}function sCe(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return dIe(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let a=0;a<r;++a){const r=e[a];rCe(t,a,r)?n.push(r):n.push(sCe(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],a=dIe(n);t[a]="name"!==n&&"className"!==n||"string"!==typeof r?sCe(r,n):r}return t}}const iCe="4.20.0";class oCe extends XTe{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=AIe(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],bIe(this.inputs).length!==this.inputs.length)throw new nIe(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);bIe(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;oIe(0===t,"input layer has >1 nodes"),oIe(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof ZTe))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},a={},s={},i=[],o=(e,t,n,r,a,l)=>{null!=r&&null!=a&&null!=l||(r=e.sourceLayer,a=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[a];if(-1!==n.indexOf(u))throw new tIe(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(oCe.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let s=0;s<c;s++){const e=u.inputTensors[s],r=u.inboundLayers[s],a=u.nodeIndices[s],i=u.tensorIndices[s];o(e,t,n,r,a,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const y of this.outputs)o(y,l,u);const c=i.slice().reverse();for(const y of c){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const s=null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id];e=Math.max(e,s),r[y.outboundLayer.id]=e,a[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){const a=y.inboundLayers[r],s=y.nodeIndices[r],i=a.inboundNodes[s],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const d={};for(const y in t){const e=t[y];e in d||(d[e]=[]),d[e].push(n[y])}const h={};for(const y in r){const e=r[y];e in h||(h[e]=[]),h[e].push(a[y])}let p=Object.keys(h).map((e=>parseInt(e,10))).sort(yIe);this.layers=[];for(const y of p){const e=h[y];e.sort(((e,t)=>{const n=s[e.id],r=s[t.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof oCe&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=h,p=Object.keys(d).map((e=>parseInt(e,10))).sort(yIe);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of d[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new tIe(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=d;const g=this.layers.map((e=>e.name));for(const y of g){const e=g.filter((e=>e===y)).length;if(1!==e)throw new tIe(`The name "${y}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new KTe({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new nIe("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const a=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);a&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const s=a?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[s])throw new nIe(`Duplicate weight name: ${s}`);n[s]=t,r++}const s=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])s.push([n[r],e[i]]);else if(t)throw new nIe(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new nIe(`${e.length} of ${r} weights are not set: ${e}`)}jTe(s)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],a=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");a!==t&&(e[a]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${iCe}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=sCe(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return(0,hve.tidy)((()=>{e=cIe(e);const n=new JTe;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return nNe(this.outputs,n,t)}))}computeMask(e,t){return(0,hve.tidy)((()=>{let n;return e=cIe(e),n=null==t?iIe(null,e.length):cIe(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=PTe(e);if(t.length!==this.inputLayers.length)throw new nIe(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(yIe);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const r=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],a=t.nodeIndices[i],s=t.tensorIndices[i],o=n[`${e.name}_${a}_${s}`];r.push(o)}const a=PTe(e.computeOutputShape(uIe(r))),s=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++){n[`${e.name}_${s}_${t}`]=a[t]}}}const a=[],s=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;s.push(r)}for(let i=0;i<s.length;i++){const e=s[i];oIe(e in n),a.push(n[e])}return uIe(a)}runInternalGraph(e,t){null==t&&(t=iIe(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const r=this.inputs[o],a=e[o],s=t[o];n[r.id]=[a,s]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(yIe);for(const o of r){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,s=new Array;for(const t of r)t.id in n&&s.push(n[t.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){const[t,n]=s[0];null==u.mask&&(u.mask=n),o=cIe(e.call(t,u)),l=cIe(e.computeMask(t,n)),r=[t],i=[n]}else r=s.map((e=>e[0])),i=s.map((e=>e[1])),null==u.mask&&(u.mask=i),o=cIe(e.call(r,u)),l=cIe(e.computeMask(r,i));if(e.activityRegularizer)throw new rIe("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){const t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}const a=[],s=[],i=[];for(const o of this.outputs){oIe(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];i.push(e.shape),a.push(e),s.push(t)}return[a,s,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof oCe?1:0;for(let e=0;e<r.inboundNodes.length;e++){const a=oCe.nodeKey(r,e);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new nIe("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new nIe(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new nIe(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return(0,hve.tidy)((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=oCe.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const i of this.layers){const e=i.getClassName(),r=i.getConfig(),a=[];for(let n=0;n<i.inboundNodes.length;n++){const e=i.inboundNodes[n],r=oCe.nodeKey(i,n);let o={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),o=e.callArgs}catch(s){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const a=e.inboundLayers[r],s=e.nodeIndices[r],i=e.tensorIndices[r];let l=t[oCe.nodeKey(a,s)];null==l&&(l=0),n.push([a.name,l,i,o])}a.push(n)}}}const o={};o.name=i.name,o.className=e,o.config=r,o.inboundNodes=a,n.push(o)}e.layers=n;const r=[];for(let i=0;i<this.inputLayers.length;i++){const e=this.inputLayers[i],n=this.inputLayersNodeIndices[i],a=oCe.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let s=t[a];null!==s&&void 0!==s||(s=0);const o=this.inputLayersTensorIndices[i];r.push([e.name,s,o])}e.inputLayers=r;const a=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],n=this.outputLayersNodeIndices[i],r=oCe.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let s=t[r];null!==s&&void 0!==s||(s=0);const o=this.outputLayersTensorIndices[i];a.push([e.name,s,o])}return e.outputLayers=a,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},a={};function s(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function i(e,t){const n=[];let a;for(const i of t){const o=i[0],l=i[1],u=i[2];if(a=null==i[3]?{}:i[3],!(o in r))return void s(e,t);const c=r[o];if(c.inboundNodes.length<=l)return void s(e,t);const d=c.inboundNodes[l];n.push(d.outputTensors[u])}n.length>0&&e.apply(uIe(n),a)}function o(e){const a=e.name,i=CNe(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[a]=i;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new nIe(`Corrupted configuration, expected array for nodeData: ${e}`);s(i,e)}))}const l=t.name,u=t.layers;for(const f of u)o(f);for(;!vIe(a);)for(const e of u){const t=r[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)i(t,n)}}const c=[],d=[],h=t.inputLayers;for(const f of h){const e=f[0],t=f[1],n=f[2];oIe(e in r);const a=r[e].inboundNodes[t].outputTensors;c.push(a[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];oIe(e in r);const a=r[e].inboundNodes[t].outputTensors;d.push(a[n])}return new e({inputs:c,outputs:d,name:l})}get stateful(){if(this._stateful)throw new nIe("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){(0,hve.tidy)((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function lCe(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function uCe(e,t){return lCe(e,t,"classWeight")}async function cCe(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=(0,hve.tidy)((()=>{if(1===e.shape.length)return(0,hve.clone)(e);if(2===e.shape.length){if(e.shape[1]>1){const t=1;return(0,hve.argMax)(e,t)}if(1===e.shape[1])return(0,hve.reshape)(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());(0,hve.dispose)(t);const a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),(0,hve.tensor1d)(a,"float32")}return null}function dCe(e,t){return(0,hve.mul)(e,t)}function hCe(e,t){let n,r;const a=t;n=a.xs,r=a.ys,hve.util.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const s=pCe("input",e.inputNames,n),i=pCe("output",e.outputNames,r),o=s[0].shape[0];hve.util.assert(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),hve.util.assert(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<s.length;l++)hve.util.assert(s[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)hve.util.assert(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:i}}function pCe(e,t,n){if(n instanceof hve.Tensor)return[n];if(Array.isArray(n))return hve.util.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const a of t){if(null==n[a])throw new nIe(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function fCe(e,t,n){const r=null!=n.batchesPerEpoch;if(hve.util.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),hve.util.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),hve.util.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),hve.util.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),hve.util.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const a=null!=n.validationData;let s,i;if(a)if(mCe(n.validationData))hve.util.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new rIe("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);s=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=a?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=INe(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=NNe(c,d,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,a,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const u={};await h.onEpochBegin(f);let c=0,d=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:a}=hCe(e,t.value),s={};s.batch=d,s.size=r[0].shape[0],await h.onBatchBegin(d,s);const i=[];if(null!=n.classWeight){const t=uCe(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await cCe(a[e],null,t[e]))}const u=r.concat(a).concat(i),p=o(u);hve.dispose(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];s[t]=n,hve.keep(n)}await h.onBatchEnd(d,s),yNe(s),d++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(a){let t;t=mCe(n.validationData)?cIe(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):cIe(e.evaluate(s,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,u),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function mCe(e){return"function"===typeof e.iterator}function gCe(e){hve.util.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function yCe(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>eTe(e,t,n-t))):eTe(e,t,n-t)}function bCe(e,t){return hve.tidy((()=>null==e?null:Array.isArray(e)?e.map((e=>bCe(e,t))):lTe(e,"int32"===t.dtype?t:hve.cast(t,"int32"))))}function vCe(e,t){const n=[];let r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function xCe(e){const t=[];e instanceof hve.Tensor&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(JIe(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function wCe(e,t){if(null==e)return;const n=[];if(t instanceof hve.Tensor)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const a in t){const e=t[a];n.push(e.id)}const r=[];if(e instanceof hve.Tensor)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const a in e){const t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function kCe(e){return Array.isArray(e)}function SCe(e){return!function(e){return e instanceof hve.Tensor}(e)&&!kCe(e)}function ICe(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(kCe(e)&&e.length>0)t=!0;else if(SCe(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new nIe(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(SCe(e)){r=[];for(const n of t){if(null==e[n])throw new nIe(`No data provided for "${n}". Need data for each key in: ${t}`);r.push(e[n])}}else if(kCe(e)){if(e.length!==t.length)throw new nIe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);r=e}else{if(t.length>1)throw new nIe(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);r=[e]}if(r=xCe(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new nIe(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!a)continue;const r=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&r!==o)throw new nIe(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return r}function TCe(e,t,n){let r,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new nIe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);r=e}else{if(t.length>1)throw new nIe(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new nIe(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let r=0;r<n[i].length;++r){if(0===r&&!a)continue;const o=e.shape[r],l=n[i][r];if(null!=l&&l!==o)throw new nIe(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class NCe extends oCe{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new nIe("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");JNe(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>hve.train.adagrad(.01),Adadelta:()=>hve.train.adadelta(1,.95,QIe()),Adam:()=>hve.train.adam(.001,.9,.999,QIe()),Adamax:()=>hve.train.adamax(.002,.9,.999,QIe(),0),RMSProp:()=>hve.train.rmsprop(.001,.9,0,QIe()),SGD:()=>hve.train.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new nIe(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof hve.Optimizer))throw new nIe("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new nIe(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>zNe(e)))}else{const n=zNe(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new nIe(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(zNe(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],BIe("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};BIe("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,s;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let a;1===t[t.length-1]||this.lossFunctions[e]===FNe?-1!==["accuracy","acc"].indexOf(i)?r=BNe:-1!==["crossentropy","ce"].indexOf(i)&&(r=UNe):this.lossFunctions[e]===MNe?-1!==["accuracy","acc"].indexOf(i)?r=jNe:-1!==["crossentropy","ce"].indexOf(i)&&(r=HNe):-1!==["accuracy","acc"].indexOf(i)?r=VNe:-1!==["crossentropy","ce"].indexOf(i)&&(r=GNe),-1!==["accuracy","acc"].indexOf(i)?a="acc":-1!==["crossentropy","ce"].indexOf(i)&&(a="ce"),s=r,n=""+a}else{const e=KNe(i);s=e,n=""+YNe(i)}let t;BIe(n,(()=>{t=s})),a(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;gCe(r);const a=this.standardizeUserDataXY(e,t,!0,r);try{const e=a[0].concat(a[1]);this.makeTestFunction();const t=this.testFunction;return uIe(this.testLoop(t,e,r,n.verbose,n.steps))}finally{wCe(a[0],e),wCe(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,a=e.testFunction;let s=[];if(n.verbose>0)throw new rIe("Verbose mode is not implemented yet.");hve.util.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i="function"===typeof t.next?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await i.next();if(s=hve.tidy((()=>{if(t.value){const{xs:n,ys:r}=hCe(e,t.value),i=n.concat(r),u=hve.tidy((()=>a(i)));if(hve.dispose(i),0===l)for(let e=0;e<u.length;++e)s.push((0,hve.scalar)(0));const c=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=s[e];s[e]=hve.tidy((()=>hve.add(s[e],hve.mul(c,t)))),l>0&&hve.dispose(n)}hve.dispose(u),o+=c,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){const e=s[u];s[u]=hve.div(s[u],o),hve.dispose(e)}return uIe(s)}(this,e,t)}checkNumSamples(e,t,n){let r,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new nIe(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new nIe(`Either the input data should have a defined shape, or ${a} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new nIe("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new JTe;if(e instanceof hve.Tensor&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new nIe(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new nIe(`No value is provided for the model's input ${o.name}`);s.add(o,t)}const i=nNe(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){const t=iIe(null,e.length);let n=e.length;for(const r of this.layers){const a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){const i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new nIe(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return hve.tidy((()=>{const r=this.checkNumSamples(e);if(n)throw new rIe("Verbose predictLoop() is not implemented yet.");const a=vCe(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t){hve.tidy((()=>{const n=a[t][0],r=a[t][1],s=yCe(e,n,r),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});const o=new JTe(i);return nNe(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)))}return uIe(s.map((e=>hve.concat(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=xCe(e);TCe(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return gCe(e),this.predictLoop(n,e)}finally{wCe(n,e)}}predictOnBatch(e){TCe(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new tIe("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const e=this.feedOutputShapes[a];this.feedLossFns[a]===MNe?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){const n=bIe(e.map((e=>e.shape[0])));n.sort();const r=bIe(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new nIe(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new nIe(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!hve.util.arraysEqual(n,r))throw new nIe(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=ICe(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=ICe(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){const r=[ENe,FNe,DNe];for(let a=0;a<e.length;++a){const s=e[a],i=t[a],o=n[a];if(null!=i){if(i===DNe&&1===s.shape[s.shape.length-1])throw new nIe(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],a=t[n];if(null!=a&&r!==a)throw new nIe(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new nIe(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r){let a=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=uCe(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await cCe(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4?arguments[4]:void 0;return hve.tidy((()=>{const s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new rIe("Verbose mode is not implemented yet.");if(null!=a)throw new rIe("steps mode in testLoop() is not implemented yet");{const r=vCe(s,n),a=(0,hve.tensor1d)(YIe(0,s));for(let n=0;n<r.length;++n){const s=r[n][0],o=r[n][1],l=eTe(a,s,o-s),u=bCe(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push((0,hve.scalar)(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=hve.add(i[e],hve.mul(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=hve.div(i[e],s)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let a=r;if(lIe(e,r)>1){a+=`_${lIe(e.slice(0,n),r)}`}t.push(a)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new JTe(e),o=nNe(this.outputs,i,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],o[n]);null!=a[n]&&(e=dCe(e,a[n]));const s=hve.mean(e);t.push(s),l=0===n?e:hve.add(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=hve.mean(t(r[a],o[a]))}hve.keep(e),s.push(e)}return l=hve.mean(l),this.calculateLosses().forEach((e=>{l=hve.add(l,e)})),l}),!0,i)].concat(s)}}makeTestFunction(){this.testFunction=e=>hve.tidy((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});const i=new JTe(s),o=nNe(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],s=hve.mean(r(a[e],o[e]));n=0===e?s:hve.add(n,s),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=hve.mean(n(a[r],o[r]));t.push(s)}return t}))}async fit(e,t){let n,r,a,s,i,o,l,u,c,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const h=null==d.batchSize?32:d.batchSize;gCe(h);const p=!1,f=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,p,h);n=f[0],r=f[1],c=f[2];let m,g=!1;if(null!=d.validationData&&d.validationData.length>0){if(g=!0,2!==d.validationData.length)throw 3===d.validationData.length?new rIe("validationData including sample weights is not supported yet."):new nIe(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${d.validationData} is invalid.`);i=d.validationData[0],o=d.validationData[1];const e=!0,t=await this.standardizeUserData(i,o,null,null,e,h);l=t[0],u=t[1],m=l.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];l=yCe(n,e,t),a=n,n=yCe(n,0,e),u=yCe(r,e,t),s=r,r=yCe(r,0,e),m=l.concat(u)}else null!=d.validationSteps&&(g=!0);const y=n.concat(r).concat(c);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let x,w;g?(this.makeTestFunction(),x=this.testFunction,w=v.slice().concat(v.map((e=>"val_"+e)))):(x=null,m=[],w=v.slice());const k=INe(d.callbacks,d.yieldEvery);return await this.fitLoop(b,y,v,h,d.epochs,d.verbose,k,x,m,d.shuffle,w,d.initialEpoch,null,null)}finally{this.isTraining=!1,wCe(n,e),wCe(r,t),wCe(a,e),wCe(s,t),wCe(l,i),wCe(u,o),null!=c&&hve.dispose(c)}}async fitLoop(e,t,n,r,a,s,i,o,l,u,c,d,h,p){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==h))throw new nIe("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,h,"steps_per_epoch");let g;null!=m&&(g=YIe(0,m)),null==s&&(s=1);const{callbackList:y,history:b}=NNe(i,s,a,d,m,h,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=d;v<a;++v){await y.onEpochBegin(v);const a={};if(null!=h)throw new rIe("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new rIe("batch shuffling is not implemneted yet");u&&hve.util.shuffle(g);const s=(0,hve.tensor1d)(g),i=vCe(m,r);for(let u=0;u<i.length;++u){const c={};if(await y.onBatchBegin(u,c),hve.tidy((()=>{const d=i[u][0],h=i[u][1],p=eTe(s,d,h-d);c.batch=u,c.size=h-d;const m=bCe(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];c[t]=r,hve.keep(r)}if(u===i.length-1&&f){const e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){const r=n[t],s=e[t];hve.keep(s),a["val_"+r]=s}}})),await y.onBatchEnd(u,c),yNe(c),this.stopTraining_)break}s.dispose()}if(await y.onEpochEnd(v,a),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return fCe(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(const o of s){const e=await o.data();i.push(e[0])}return hve.dispose(s),wCe(n[0],e),wCe(n[1],t),uIe(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=hve.memory().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-hve.memory().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=dIe(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>dIe(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=dIe(n[r])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[dIe(YNe(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>dIe(YNe(e))));{const e={};for(const t in this.metrics)e[t]=dIe(YNe(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=CNe(aCe(e.optimizer_config));let n,r;if("string"===typeof e.loss)n=hIe(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>hIe(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=hIe(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>hIe(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=hIe(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"===typeof e){const t=hve.io.getSaveHandlers(e);if(0===t.length)throw new nIe(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new nIe(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new nIe("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await hve.io.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${iCe}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:a}=await hve.io.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...a),n.data=hve.io.concatenateArrayBuffers([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;QNe(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){QNe(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}NCe.className="Model",hve.serialization.registerClass(NCe);class CCe extends NCe{}CCe.className="Functional",hve.serialization.registerClass(CCe);class ACe extends NCe{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:AIe("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new nIe(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof ACe||e instanceof NCe;let n;if(t){if(n=e,1!==n.outputs.length)throw new nIe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new nIe("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new nIe("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new nIe("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new ZTe({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new nIe(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new nIe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=QTe(this.outputs[0])}this.inboundNodes=[],new KTe({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:iIe(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(zTe(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new NCe({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new tIe("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new tIe("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new tIe("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new tIe("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new nIe("Legacy serialization format not supported yet.");n=t}else hve.util.assert(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,a=t;const s=new e(a);if(!(s instanceof ACe))throw new rIe(`Sequential.fromConfig called on non-Sequential input: ${s}`);for(const i of n){const e=CNe(i,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),s.add(e)}return s}set stopTraining(e){if(null==this.model)throw new nIe("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new nIe("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}ACe.className="Sequential",hve.serialization.registerClass(ACe);class ECe extends hve.serialization.Serializable{getConfig(){return{}}}class _Ce extends ECe{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new rIe(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return hve.elu(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}_Ce.className="elu",hve.serialization.registerClass(_Ce);class $Ce extends ECe{apply(e){return hve.selu(e)}}$Ce.className="selu",hve.serialization.registerClass($Ce);class RCe extends ECe{apply(e){return hve.relu(e)}}RCe.className="relu",hve.serialization.registerClass(RCe);class DCe extends ECe{apply(e){return(0,hve.tidy)((()=>hve.minimum(6,hve.relu(e))))}}DCe.className="relu6",hve.serialization.registerClass(DCe);class MCe extends ECe{apply(e){return e}}MCe.className="linear",hve.serialization.registerClass(MCe);class FCe extends ECe{apply(e){return hve.sigmoid(e)}}FCe.className="sigmoid",hve.serialization.registerClass(FCe);class OCe extends ECe{apply(e){return function(e){return(0,hve.tidy)((()=>{const t=hve.add(.5,hve.mul(.2,e));return hve.clipByValue(t,0,1)}))}(e)}}OCe.className="hardSigmoid",hve.serialization.registerClass(OCe);class PCe extends ECe{apply(e){return hve.softplus(e)}}PCe.className="softplus",hve.serialization.registerClass(PCe);class LCe extends ECe{apply(e){return function(e){return(0,hve.tidy)((()=>hve.div(e,hve.add(hve.abs(e),1))))}(e)}}LCe.className="softsign",hve.serialization.registerClass(LCe);class zCe extends ECe{apply(e){return hve.tanh(e)}}zCe.className="tanh",hve.serialization.registerClass(zCe);class BCe extends ECe{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return hve.softmax(e,t)}}BCe.className="softmax",hve.serialization.registerClass(BCe);class VCe extends ECe{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return hve.logSoftmax(e,t)}}VCe.className="logSoftmax",hve.serialization.registerClass(VCe);class WCe extends ECe{apply(e){return(0,hve.tidy)((()=>hve.tidy((()=>{const t=Math.sqrt(2),n=hve.mul(.5,hve.add(1,hve.erf(hve.div(e,t))));return hve.mul(e,n)}))))}}WCe.className="gelu",hve.serialization.registerClass(WCe);class UCe extends ECe{apply(e){return(0,hve.tidy)((()=>hve.mul(.5,hve.mul(e,hve.add(1,hve.tanh(hve.mul(hve.sqrt(hve.div(2,Math.PI)),hve.add(e,hve.mul(.044715,hve.pow(e,3))))))))))}}UCe.className="gelu_new",hve.serialization.registerClass(UCe);class jCe extends ECe{apply(e){return(0,hve.tidy)((()=>hve.mul(e,hve.tanh(hve.softplus(e)))))}}jCe.className="mish",hve.serialization.registerClass(jCe);class GCe extends ECe{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return(0,hve.tidy)((()=>hve.mul(hve.sigmoid(hve.mul(e,t)),e)))}}function HCe(e){return e.getClassName()}function qCe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return gIe(e,hve.serialization.SerializationMap.getMap().classNameMap,t,"activation")}function KCe(e){if(null==e){const e={className:"linear",config:{}};return qCe(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},qCe(t)}return e instanceof ECe?e:qCe(e)}function YCe(e){if(null!=e&&"object"!==typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}GCe.className="swish",hve.serialization.registerClass(GCe);class XCe extends hve.serialization.Serializable{}class QCe extends XCe{constructor(e){super(),YCe(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return(0,hve.tidy)((()=>{let t=(0,hve.zeros)([1]);return this.hasL1&&(t=(0,hve.add)(t,(0,hve.sum)(hve.mul(this.l1,(0,hve.abs)(e))))),this.hasL2&&(t=(0,hve.add)(t,(0,hve.sum)(hve.mul(this.l2,uTe(e))))),hve.reshape(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}QCe.className="L1L2",hve.serialization.registerClass(QCe);const ZCe={l1l2:"L1L2"};function JCe(e){return fIe(e)}function eAe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return gIe(e,hve.serialization.SerializationMap.getMap().classNameMap,t,"regularizer")}function tAe(e){if(null==e)return null;if("string"===typeof e){return eAe({className:e in ZCe?ZCe[e]:e,config:{}})}return e instanceof XCe?e:eAe(e)}class nAe extends XTe{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=LTe(e);let n=(0,hve.relu)(e);return null!=this.maxValue&&(n=(0,hve.clipByValue)(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}nAe.className="ReLU",hve.serialization.registerClass(nAe);class rAe extends XTe{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=LTe(e);return(0,hve.leakyRelu)(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}rAe.className="LeakyReLU",hve.serialization.registerClass(rAe);class aAe extends XTe{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=FTe(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=tAe(e.alphaRegularizer),this.alphaConstraint=mNe(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new nIe(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=zTe(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new GTe({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=LTe(e),(0,hve.prelu)(e,this.alpha.read())}getConfig(){const e={alphaInitializer:MTe(this.alphaInitializer),alphaRegularizer:JCe(this.alphaRegularizer),alphaConstraint:pNe(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}aAe.className="PReLU",hve.serialization.registerClass(aAe);class sAe extends XTe{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new rIe(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=LTe(e);return(0,hve.elu)(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}sAe.className="ELU",hve.serialization.registerClass(sAe);class iAe extends XTe{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=LTe(e);return(0,hve.mul)(n,(0,hve.cast)((0,hve.greater)(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}iAe.className="ThresholdedReLU",hve.serialization.registerClass(iAe);class oAe extends XTe{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new BCe).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return(0,hve.tidy)((()=>{let n=LTe(e);const r=t.mask;if(null!=r){const e=(0,hve.mul)((0,hve.sub)((0,hve.ones)(n.shape),(0,hve.cast)(r,n.dtype)),(0,hve.scalar)(-1e9));n=(0,hve.add)(n,e)}return this.axis instanceof Array?this.axis.length>1?(0,hve.exp)((0,hve.sub)(n,(0,hve.logSumExp)(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function lAe(e,t,n){if("number"===typeof e)return iIe(e,t);if(e.length!==t)throw new nIe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const a=e[r];if(!GIe(a))throw new nIe(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function uAe(e,t,n,r){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((a+r-1)/r)}function cAe(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+KIe([n-t,0]);else{if("same"!==r)throw new nIe(`Unsupport padding mode: ${r}.`);e*=t}return e}function dAe(e,t){return(0,hve.tidy)((()=>(FIe(t),"channelsFirst"===t?hve.transpose(e,[0,2,3,1]):e)))}function hAe(e,t){return(0,hve.tidy)((()=>(FIe(t),"channelsFirst"===t?hve.transpose(e,[0,2,3,4,1]):e)))}function pAe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return(0,hve.tidy)((()=>{if(null==s&&(s="channelsLast"),FIe(s),3!==e.shape.length)throw new nIe(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new nIe(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new nIe(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===s&&(e=hve.transpose(e,[0,2,1])),"causal"===a)throw new rIe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=hve.conv1d(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=dTe(o,n)),o}))}function fAe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return(0,hve.tidy)((()=>{if(null==s&&(s="channelsLast"),FIe(s),3!==e.rank&&4!==e.rank)throw new nIe(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new nIe(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=dAe(e,s);if("causal"===a)throw new rIe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=hve.fused.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=hve.transpose(l,[0,3,1,2])),l}))}function mAe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return(0,hve.tidy)((()=>{if(null==s&&(s="channelsLast"),FIe(s),4!==e.rank&&5!==e.rank)throw new nIe(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new nIe(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=hAe(e,s);if("causal"===a)throw new rIe("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=hve.conv3d(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=dTe(o,n)),"channelsFirst"===s&&(o=hve.transpose(o,[0,4,1,2,3])),o}))}oAe.className="Softmax",hve.serialization.registerClass(oAe);class gAe extends XTe{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",gAe.verifyArgs(t),this.rank=e,kIe(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new rIe(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=lAe(t.kernelSize,e,"kernelSize"),this.strides=lAe(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,OIe(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,FIe(this.dataFormat),this.activation=KCe(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=FTe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=mNe(t.biasConstraint),this.biasRegularizer=tAe(t.biasRegularizer),this.activityRegularizer=tAe(t.activityRegularizer),this.dilationRate=lAe(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new nIe(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new nIe(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new nIe(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(oIe("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!wIe(e.kernelSize,"number",1,3))throw new nIe(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:HCe(this.activation),useBias:this.useBias,biasInitializer:MTe(this.biasInitializer),biasRegularizer:JCe(this.biasRegularizer),activityRegularizer:JCe(this.activityRegularizer),biasConstraint:pNe(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class yAe extends gAe{constructor(e,t){super(e,t),this.kernel=null,yAe.verifyArgs(t),this.filters=t.filters,kIe(this.filters,"filters"),this.kernelInitializer=FTe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=mNe(t.kernelConstraint),this.kernelRegularizer=tAe(t.kernelRegularizer)}build(e){e=zTe(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new nIe(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return(0,hve.tidy)((()=>{let t;e=LTe(e);const n=null==this.bias?null:this.bias.read(),r=IIe(this.activation.getClassName());if(null!=r&&2===this.rank)t=fAe(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=pAe(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=fAe(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new rIe("convolutions greater than 3D are not implemented yet.");t=mAe(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=zTe(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){const e=uAe(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:MTe(this.kernelInitializer),kernelRegularizer:JCe(this.kernelRegularizer),kernelConstraint:pNe(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new nIe(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class bAe extends yAe{constructor(e){super(2,e),bAe.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!wIe(e.kernelSize,"number",1,2))throw new nIe(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}bAe.className="Conv2D",hve.serialization.registerClass(bAe);class vAe extends yAe{constructor(e){super(3,e),vAe.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new nIe(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}vAe.className="Conv3D",hve.serialization.registerClass(vAe);class xAe extends bAe{constructor(e){if(super(e),this.inputSpec=[new GTe({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new nIe(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=zTe(e)).length)throw new nIe("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new nIe("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new GTe({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return hve.tidy((()=>{let t=LTe(e);if(4!==t.shape.length)throw new nIe(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let a,s;"channelsFirst"===this.dataFormat?(a=2,s=3):(a=1,s=2);const i=n[a],o=n[s],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],h=[r,cAe(i,c,l,this.padding),cAe(o,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=hve.transpose(t,[0,2,3,1]));let p=hve.conv2dTranspose(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=hve.transpose(p,[0,3,1,2])),null!=this.bias&&(p=dTe(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=zTe(e)).slice();let n,r,a;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3):(n=3,r=1,a=2);const s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=cAe(t[r],o,s,this.padding),t[a]=cAe(t[a],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}xAe.className="Conv2DTranspose",hve.serialization.registerClass(xAe);class wAe extends vAe{constructor(e){if(super(e),this.inputSpec=[new GTe({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new nIe(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=zTe(e)).length)throw new nIe("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new nIe("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new GTe({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return hve.tidy((()=>{let t=LTe(e);if(5!==t.shape.length)throw new nIe(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let a,s,i;"channelsFirst"===this.dataFormat?(i=2,a=3,s=4):(i=1,a=2,s=3);const o=n[i],l=n[a],u=n[s],c=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,cAe(o,p,c,this.padding),cAe(l,f,d,this.padding),cAe(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=hve.transpose(t,[0,2,3,4,1]));let y=hve.conv3dTranspose(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=hve.transpose(y,[0,4,1,2,3])),null!==this.bias&&(y=dTe(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){const t=(e=zTe(e)).slice();let n,r,a,s;"channelsFirst"===this.dataFormat?(n=1,r=2,a=3,s=4):(n=4,r=1,a=2,s=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=cAe(t[r],u,i,this.padding),t[a]=cAe(t[a],c,o,this.padding),t[s]=cAe(t[s],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}wAe.className="Conv3DTranspose",hve.serialization.registerClass(wAe);class kAe extends yAe{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new nIe("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new nIe("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new nIe(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=FTe(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=tAe(t.depthwiseRegularizer),this.depthwiseConstraint=mNe(t.depthwiseConstraint),this.pointwiseInitializer=FTe(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=tAe(t.pointwiseRegularizer),this.pointwiseConstraint=mNe(t.pointwiseConstraint)}build(e){if((e=zTe(e)).length<this.rank+2)throw new nIe(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new nIe(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new GTe({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return(0,hve.tidy)((()=>{let t;if(e=LTe(e),1===this.rank)throw new rIe("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=hve.transpose(e,[0,2,3,1])),t=hve.separableConv2d(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=dTe(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=hve.transpose(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=MTe(this.depthwiseInitializer),e.pointwiseInitializer=MTe(this.pointwiseInitializer),e.depthwiseRegularizer=JCe(this.depthwiseRegularizer),e.pointwiseRegularizer=JCe(this.pointwiseRegularizer),e.depthwiseConstraint=pNe(this.depthwiseConstraint),e.pointwiseConstraint=pNe(this.pointwiseConstraint),e}}kAe.className="SeparableConv";class SAe extends kAe{constructor(e){super(2,e)}}SAe.className="SeparableConv2D",hve.serialization.registerClass(SAe);class IAe extends yAe{constructor(e){super(1,e),IAe.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!wIe(e.kernelSize,"number",1,1))throw new nIe(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}IAe.className="Conv1D",hve.serialization.registerClass(IAe);class TAe extends XTe{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return(0,hve.tidy)((()=>{if(e=LTe(e),"channelsLast"===this.dataFormat){const t=nTe(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return nTe(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=nTe(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return nTe(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}TAe.className="Cropping2D",hve.serialization.registerClass(TAe);class NAe extends XTe{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,FIe(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,xIe(_Ie,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return hve.tidy((()=>{let t=LTe(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=hve.transpose(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?hve.image.resizeNearestNeighbor(t,[e,r]):hve.image.resizeBilinear(t,[e,r]);return hve.transpose(a,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?hve.image.resizeNearestNeighbor(t,[e,r]):hve.image.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}NAe.className="UpSampling2D",hve.serialization.registerClass(NAe);class CAe extends gAe{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=FTe(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=mNe(e.depthwiseConstraint),this.depthwiseRegularizer=tAe(e.depthwiseRegularizer)}build(e){if((e=zTe(e)).length<4)throw new nIe(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new nIe(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,hve.tidy)((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return(0,hve.tidy)((()=>{null==a&&(a="channelsLast"),FIe(a);let i=dAe(e,a);if(4!==e.rank)throw new nIe(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new nIe(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=hve.depthwiseConv2d(i,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(i=hve.transpose(i,[0,3,1,2])),i}))}(e=LTe(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=dTe(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=zTe(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=uAe(t,this.kernelSize[0],this.padding,this.strides[0]),s=uAe(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=MTe(this.depthwiseInitializer),e.depthwiseRegularizer=JCe(this.depthwiseRegularizer),e.depthwiseConstraint=pNe(this.depthwiseRegularizer),e}}function AAe(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new nIe("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function EAe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return hve.tidy((()=>{const l=t.shape.length;if(l<3)throw new nIe(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(YIe(2,l));if(t=hve.transpose(t,u),null!=s)throw new rIe("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=hve.cast(hve.cast(a,"bool"),"float32"),a.rank===l-1&&(a=hve.expandDims(a,-1)),a=hve.transpose(a,u)),r&&(t=hve.reverse(t,0),null!=a&&(a=hve.reverse(a,0)));const c=[];let d,h=n;const p=t.shape[0],f=hve.unstack(t);let m,g;null!=a&&(m=hve.unstack(a));for(let t=0;t<p;++t){const n=f[t],r=hve.tidy((()=>e(n,h)));if(null==a)d=r[0],h=r[1];else{const e=hve.tidy((()=>{const e=m[t],n=hve.sub(hve.onesLike(e),e);return{output:hve.add(hve.mul(r[0],e),hve.mul(h[0],n)),newStates:h.map(((t,a)=>hve.add(hve.mul(r[1][a],e),hve.mul(t,n))))}}));d=e.output,h=e.newStates}o&&c.push(d)}if(o){const e=1;g=hve.stack(c,e)}return[d,g,h]}))}CAe.className="DepthwiseConv2D",hve.serialization.registerClass(CAe);class _Ae extends XTe{constructor(e){let t;if(super(e),null==e.cell)throw new nIe("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new LAe({cells:e.cell}):e.cell,null==t.stateSize)throw new nIe("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new GTe({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return YIe(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){OTe(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return hve.tidy((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new rIe("Constants support is not implemented in RNN yet.");OTe(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new GTe({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let a;if(this.cell.build(r),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!hve.util.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),a))throw new nIe(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map((e=>new GTe({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];(0,hve.tidy)((()=>{if(!this.stateful)throw new eIe("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new nIe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>hve.zeros([n,e]))):this.states_=[hve.zeros([n,this.cell.stateSize])];else if(null==e)hve.dispose(this.states_),null!=this.keptStates&&(hve.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>hve.zeros([n,e]))):this.states_[0]=hve.zeros([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new nIe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):hve.dispose(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!hve.util.arraysEqual(r.shape,s))throw new nIe(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>hve.keep(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=AAe(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new GTe({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length);if(s[0]instanceof HTe){const n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return(0,hve.tidy)((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let a=null==t?null:t.initialState;e=LTe(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new nIe(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=EAe(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return(0,hve.tidy)((()=>{let t=hve.zeros(e.shape);return t=hve.sum(t,[1,2]),t=JIe(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?sTe(t,[1,e]):t)):this.cell.stateSize>1?[sTe(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===_Ae.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=CNe(t.cell,n);return new e(Object.assign(t,{cell:r}))}}_Ae.className="RNN",hve.serialization.registerClass(_Ae);class $Ae extends XTe{}class RAe extends $Ae{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,kIe(this.units,"units"),this.activation=KCe(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=FTe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=FTe(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=FTe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=tAe(e.kernelRegularizer),this.recurrentRegularizer=tAe(e.recurrentRegularizer),this.biasRegularizer=tAe(e.biasRegularizer),this.kernelConstraint=mNe(e.kernelConstraint),this.recurrentConstraint=mNe(e.recurrentConstraint),this.biasConstraint=mNe(e.biasConstraint),this.dropout=qIe([1,KIe([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=qIe([1,KIe([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=zTe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,hve.tidy)((()=>{if(2!==e.length)throw new nIe(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zAe({ones:()=>hve.onesLike(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zAe({ones:()=>hve.onesLike(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=this.recurrentDropoutMask;a=oTe(null!=s?hve.mul(e,s):e,this.kernel.read()),null!=this.bias&&(a=dTe(a,this.bias.read())),null!=i&&(n=hve.mul(n,i));let o=hve.add(a,oTe(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:HCe(this.activation),useBias:this.useBias,kernelInitializer:MTe(this.kernelInitializer),recurrentInitializer:MTe(this.recurrentInitializer),biasInitializer:MTe(this.biasInitializer),kernelRegularizer:JCe(this.kernelRegularizer),recurrentRegularizer:JCe(this.recurrentRegularizer),biasRegularizer:JCe(this.biasRegularizer),activityRegularizer:JCe(this.activityRegularizer),kernelConstraint:pNe(this.kernelConstraint),recurrentConstraint:pNe(this.recurrentConstraint),biasConstraint:pNe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}RAe.className="SimpleRNNCell",hve.serialization.registerClass(RAe);class DAe extends _Ae{constructor(e){e.cell=new RAe(e),super(e)}call(e,t){return(0,hve.tidy)((()=>{null!=this.cell.dropoutMask&&(hve.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hve.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}}DAe.className="SimpleRNN",hve.serialization.registerClass(DAe);class MAe extends $Ae{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new nIe("GRUCell does not support reset_after parameter set to true.");this.units=e.units,kIe(this.units,"units"),this.activation=KCe(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=KCe(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=FTe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=FTe(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=FTe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=tAe(e.kernelRegularizer),this.recurrentRegularizer=tAe(e.recurrentRegularizer),this.biasRegularizer=tAe(e.biasRegularizer),this.kernelConstraint=mNe(e.kernelConstraint),this.recurrentConstraint=mNe(e.recurrentConstraint),this.biasConstraint=mNe(e.biasConstraint),this.dropout=qIe([1,KIe([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=qIe([1,KIe([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=zTe(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return(0,hve.tidy)((()=>{if(2!==e.length)throw new nIe(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zAe({ones:()=>hve.onesLike(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zAe({ones:()=>hve.onesLike(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,s=this.recurrentDropoutMask;let i,o,l;0<this.dropout&&this.dropout<1&&(e=hve.mul(e,a[0]));let u=oTe(e,this.kernel.read());this.useBias&&(u=dTe(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=hve.mul(r,s[0]));const c=this.recurrentKernel.read(),[d,h]=hve.split(c,[2*this.units,this.units],c.rank-1),p=oTe(r,d),[f,m,g]=hve.split(u,3,u.rank-1),[y,b]=hve.split(p,2,p.rank-1);i=this.recurrentActivation.apply(hve.add(f,y)),o=this.recurrentActivation.apply(hve.add(m,b));const v=oTe(hve.mul(o,r),h);l=this.activation.apply(hve.add(g,v));const x=hve.add(hve.mul(i,r),hve.mul(hve.add(1,hve.neg(i)),l));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:HCe(this.activation),recurrentActivation:HCe(this.recurrentActivation),useBias:this.useBias,kernelInitializer:MTe(this.kernelInitializer),recurrentInitializer:MTe(this.recurrentInitializer),biasInitializer:MTe(this.biasInitializer),kernelRegularizer:JCe(this.kernelRegularizer),recurrentRegularizer:JCe(this.recurrentRegularizer),biasRegularizer:JCe(this.biasRegularizer),activityRegularizer:JCe(this.activityRegularizer),kernelConstraint:pNe(this.kernelConstraint),recurrentConstraint:pNe(this.recurrentConstraint),biasConstraint:pNe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}MAe.className="GRUCell",hve.serialization.registerClass(MAe);class FAe extends _Ae{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new MAe(e),super(e)}call(e,t){return(0,hve.tidy)((()=>{null!=this.cell.dropoutMask&&(hve.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hve.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}FAe.className="GRU",hve.serialization.registerClass(FAe);class OAe extends $Ae{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,kIe(this.units,"units"),this.activation=KCe(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=KCe(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=FTe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=FTe(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=FTe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=tAe(e.kernelRegularizer),this.recurrentRegularizer=tAe(e.recurrentRegularizer),this.biasRegularizer=tAe(e.biasRegularizer),this.kernelConstraint=mNe(e.kernelConstraint),this.recurrentConstraint=mNe(e.recurrentConstraint),this.biasConstraint=mNe(e.biasConstraint),this.dropout=qIe([1,KIe([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=qIe([1,KIe([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=zTe(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new(t=class extends gTe{apply(t,r){const a=e.apply([n]),s=(new bTe).apply([n]),i=e.apply([2*n]);return aTe(aTe(a,s),i)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return(0,hve.tidy)((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new nIe(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zAe({ones:()=>hve.onesLike(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zAe({ones:()=>hve.onesLike(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(e=hve.mul(e,s[0]));let d=oTe(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=hve.mul(r,i[0])),d=hve.add(d,oTe(r,this.recurrentKernel.read())),this.useBias&&(d=dTe(d,this.bias.read()));const[h,p,f,m]=hve.split(d,4,d.rank-1);o=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=hve.add(hve.mul(l,a),hve.mul(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=hve.mul(c,this.activation.apply(u));return[g,g,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:HCe(this.activation),recurrentActivation:HCe(this.recurrentActivation),useBias:this.useBias,kernelInitializer:MTe(this.kernelInitializer),recurrentInitializer:MTe(this.recurrentInitializer),biasInitializer:MTe(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:JCe(this.kernelRegularizer),recurrentRegularizer:JCe(this.recurrentRegularizer),biasRegularizer:JCe(this.biasRegularizer),activityRegularizer:JCe(this.activityRegularizer),kernelConstraint:pNe(this.kernelConstraint),recurrentConstraint:pNe(this.recurrentConstraint),biasConstraint:pNe(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}OAe.className="LSTMCell",hve.serialization.registerClass(OAe);class PAe extends _Ae{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new OAe(e),super(e)}call(e,t){return(0,hve.tidy)((()=>{null!=this.cell.dropoutMask&&(hve.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hve.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}PAe.className="LSTM",hve.serialization.registerClass(PAe);class LAe extends $Ae{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return(0,hve.tidy)((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const a=[];let s;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],s=0===i?[e[0]].concat(n):[s[0]].concat(n),s=o.call(s,t),a.push(s.slice(1))}n=[];for(const e of a.slice().reverse())n.push(...e);return[s[0]].concat(n)}))}build(e){let t;OTe(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{BIe(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const a of t.cells)r.push(CNe(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return UTe(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}jTe(t)}}function zAe(e){const{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):hTe(t(),n),o=()=>pTe(i,t,r);if(!a||a<=1)return hve.keep(o().clone());return Array(a).fill(void 0).map(o).map((e=>hve.keep(e.clone())))}LAe.className="StackedRNNCells",hve.serialization.registerClass(LAe);var BAe=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n};class VAe extends _Ae{constructor(e){if(e.unroll)throw new rIe("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new rIe("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new GTe({ndim:5})]}call(e,t){return hve.tidy((()=>{if(null!=this.cell.dropoutMask&&(hve.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(hve.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new nIe("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return hve.tidy((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)],s=hve.zeros(a);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];hve.tidy((()=>{if(!this.stateful)throw new eIe("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new nIe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>hve.zeros(a))):this.states_=[hve.zeros(a)];else if(null==e)hve.dispose(this.states_),null!=this.keptStates&&(hve.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>hve.zeros(a))):this.states_[0]=hve.zeros(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new nIe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):hve.dispose(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=a;if(!hve.util.arraysEqual(n.shape,r))throw new nIe(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>hve.keep(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=uAe(l,r[0],a,s[0],i[0]),d=uAe(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}}VAe.className="ConvRNN2D";class WAe extends OAe{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,kIe(this.filters,"filters"),this.kernelSize=lAe(n,2,"kernelSize"),this.kernelSize.forEach((e=>kIe(e,"kernelSize"))),this.strides=lAe(r||1,2,"strides"),this.strides.forEach((e=>kIe(e,"strides"))),this.padding=a||"valid",OIe(this.padding),this.dataFormat=s||"channelsLast",FIe(this.dataFormat),this.dilationRate=lAe(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>kIe(e,"dilationRate")))}build(e){var t;e=zTe(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new nIe(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends gTe{apply(e,t){return rTe([n.apply([r]),hve.ones([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return hve.tidy((()=>{if(3!==e.length)throw new nIe(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],a=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=zAe({ones:()=>hve.onesLike(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?hve.mul(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),d=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=zAe({ones:()=>hve.onesLike(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let p=o(a,h,0),f=o(a,h,1),m=o(a,h,2),g=o(a,h,3);const[y,b,v,x]=hve.split(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?hve.split(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,v,S,this.padding),d=this.inputConv(d,x,I,this.padding);const[T,N,C,A]=hve.split(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,T),f=this.recurrentConv(f,N),m=this.recurrentConv(m,C),g=this.recurrentConv(g,A);const E=this.recurrentActivation.apply(hve.add(l,p)),_=this.recurrentActivation.apply(hve.add(u,f)),$=hve.add(hve.mul(_,s),hve.mul(E,this.activation.apply(hve.add(c,m)))),R=hve.mul(this.recurrentActivation.apply(hve.add(d,g)),this.activation.apply($));return[R,R,$]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=BAe(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const a=hve.conv2d(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?dTe(a,n,this.dataFormat):a}recurrentConv(e,t){return hve.conv2d(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}WAe.className="ConvLSTM2DCell",hve.serialization.registerClass(WAe);class UAe extends VAe{constructor(e){const t=new WAe(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}UAe.className="ConvLSTM2D",hve.serialization.registerClass(UAe);class jAe extends XTe{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return(0,hve.tidy)((()=>{this.invokeCallHook(e,t);const n=LTe(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return pTe((()=>hTe(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}jAe.className="Dropout",hve.serialization.registerClass(jAe);class GAe extends jAe{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}GAe.className="SpatialDropout1D",hve.serialization.registerClass(GAe);class HAe extends XTe{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,kIe(this.units,"units"),this.activation=KCe(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=FTe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=FTe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=mNe(e.kernelConstraint),this.biasConstraint=mNe(e.biasConstraint),this.kernelRegularizer=tAe(e.kernelRegularizer),this.biasRegularizer=tAe(e.biasRegularizer),this.activityRegularizer=tAe(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=zTe(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=zTe(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return(0,hve.tidy)((()=>{this.invokeCallHook(e,t);const n=LTe(e),r=IIe(this.activation.getClassName());let a;return null!=r?a=oTe(n,this.kernel.read(),r,this.bias?this.bias.read():null):(a=oTe(n,this.kernel.read()),null!=this.bias&&(a=dTe(a,this.bias.read())),null!=this.activation&&(a=this.activation.apply(a))),a}))}getConfig(){const e={units:this.units,activation:HCe(this.activation),useBias:this.useBias,kernelInitializer:MTe(this.kernelInitializer),biasInitializer:MTe(this.biasInitializer),kernelRegularizer:JCe(this.kernelRegularizer),biasRegularizer:JCe(this.biasRegularizer),activityRegularizer:JCe(this.activityRegularizer),kernelConstraint:pNe(this.kernelConstraint),biasConstraint:pNe(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}HAe.className="Dense",hve.serialization.registerClass(HAe);class qAe extends XTe{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=zTe(e);for(const t of e.slice(1))if(null==t)throw new nIe(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],HIe(e,1)]}call(e,t){return(0,hve.tidy)((()=>{this.invokeCallHook(e,t);let n=LTe(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=(0,hve.transpose)(n,e)}return function(e){if(e.rank<=1)throw new nIe(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],HIe(e.shape,1)];return hve.reshape(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}qAe.className="Flatten",hve.serialization.registerClass(qAe);class KAe extends XTe{constructor(e){super(e),this.supportsMasking=!0,this.activation=KCe(e.activation)}call(e,t){return(0,hve.tidy)((()=>{this.invokeCallHook(e,t);const n=LTe(e);return this.activation.apply(n)}))}getConfig(){const e={activation:HCe(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}KAe.className="Activation",hve.serialization.registerClass(KAe);class YAe extends XTe{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return(0,hve.tidy)((()=>function(e,t){return(0,hve.tidy)((()=>{if(2!==e.shape.length)throw new nIe(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return sTe(JIe(e,1),[1,t,1])}))}(e=LTe(e),this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}YAe.className="RepeatVector",hve.serialization.registerClass(YAe);class XAe extends XTe{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let a=1,s=null;for(let o=0;o<r.length;++o){const e=r[o];if(this.isUnknown(e)){if(null!==s)throw new nIe("Can only specifiy one unknown dimension.");s=o}else a*=e}const i=HIe(e);if(null!==s){if(0===a||i%a!==0)throw new nIe(n);r[s]=i/a}else if(i!==a)throw new nIe(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return(0,hve.tidy)((()=>{this.invokeCallHook(e,t);const n=LTe(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return(0,hve.reshape)(n,a)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}XAe.className="Reshape",hve.serialization.registerClass(XAe);class QAe extends XTe{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=YIe(1,e.dims.length+1);if(!hve.util.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new GTe({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=zTe(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return(0,hve.transpose)(LTe(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}QAe.className="Permute",hve.serialization.registerClass(QAe);class ZAe extends XTe{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=LTe(e);return(0,hve.any)((0,hve.notEqual)(n,this.maskValue),-1)}call(e,t){return(0,hve.tidy)((()=>{this.invokeCallHook(e,t);const n=LTe(e),r=(0,hve.any)((0,hve.notEqual)(n,this.maskValue),-1,!0);return(0,hve.mul)(n,(0,hve.cast)(r,n.dtype))}))}}ZAe.className="Masking",hve.serialization.registerClass(ZAe);class JAe extends XTe{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(cIe(e.inputLength))}this.inputDim=e.inputDim,kIe(this.inputDim,"inputDim"),this.outputDim=e.outputDim,kIe(this.outputDim,"outputDim"),this.embeddingsInitializer=FTe(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=tAe(e.embeddingsRegularizer),this.activityRegularizer=tAe(e.activityRegularizer),this.embeddingsConstraint=mNe(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return(0,hve.tidy)((()=>this.maskZero?(e=LTe(e),(0,hve.notEqual)(e,(0,hve.zerosLike)(e))):null))}computeOutputShape(e){if(e=zTe(e),null==this.inputLength)return[...e,this.outputDim];const t=cIe(this.inputLength);if(t.length!==e.length-1)throw new nIe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new nIe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return(0,hve.tidy)((()=>{this.invokeCallHook(e,t);let n=LTe(e);"int32"!==n.dtype&&(n=ZIe(n,"int32"));const r=lTe(this.embeddings.read(),(0,hve.reshape)(n,[n.size]));return(0,hve.reshape)(r,zTe(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:MTe(this.embeddingsInitializer),embeddingsRegularizer:JCe(this.embeddingsRegularizer),activityRegularizer:JCe(this.activityRegularizer),embeddingsConstraint:pNe(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}JAe.className="Embedding",hve.serialization.registerClass(JAe);class eEe extends XTe{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new rIe}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new nIe("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[zTe(e)]),e.length<2)throw new nIe(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=bIe(t),t.length>1)throw new nIe(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===bIe(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return(0,hve.tidy)((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=KIe(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=JIe(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const s of e){const e=s.rank;if(null==e){const e=s.shape,r=e[0],a=e.slice(1).concat([r]);let i=hve.reshape(s,[r].concat(HIe(e.slice(1))));i=hve.transpose(i,[1,0]),i=hve.reshape(i,a),t.push(i),n=!0}else if(e>1){const r=YIe(1,e).concat([0]);t.push(hve.transpose(s,r)),n=!0}else t.push(s)}let r=this.mergeFunction(t);const a=r.rank;if(n)if(null==a){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=hve.reshape(hve.transpose(hve.reshape(r,[-1,t]),[1,0]),n)}else if(a>1){const e=[a-1].concat(YIe(0,a-1));r=hve.transpose(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=bIe(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return hve.tidy((()=>{if(null==t)return null;if(!Array.isArray(t))throw new nIe("`mask` should be an Array");if(!Array.isArray(e))throw new nIe("`inputs` should be an Array");if(t.length!==e.length)throw new nIe(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:hve.expandDims(e,0))))[0];for(let e=1;e<t.length-1;++e)n=hve.logicalAnd(n,t[e]);return n}))}}class tEe extends eEe{constructor(e){super(e)}mergeFunction(e){return(0,hve.tidy)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=hve.add(t,e[n]);return t}))}}tEe.className="Add",hve.serialization.registerClass(tEe);class nEe extends eEe{constructor(e){super(e)}mergeFunction(e){return(0,hve.tidy)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=hve.mul(t,e[n]);return t}))}}nEe.className="Multiply",hve.serialization.registerClass(nEe);class rEe extends eEe{constructor(e){super(e)}mergeFunction(e){return(0,hve.tidy)((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=hve.add(t,e[n]);return hve.mul(1/e.length,t)}))}}rEe.className="Average",hve.serialization.registerClass(rEe);class aEe extends eEe{constructor(e){super(e)}mergeFunction(e){return(0,hve.tidy)((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=hve.maximum(t,e[n]);return t}))}}aEe.className="Maximum",hve.serialization.registerClass(aEe);class sEe extends eEe{constructor(e){super(e)}mergeFunction(e){return(0,hve.tidy)((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=hve.minimum(t,e[n]);return t}))}}sEe.className="Minimum",hve.serialization.registerClass(sEe);class iEe extends eEe{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new nIe("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let a=!1;for(const e of n)if(hve.util.arraysEqual(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new nIe("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return(0,hve.tidy)((()=>rTe(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new nIe("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new nIe("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new nIe("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new nIe(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return hve.tidy((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let s=0;s<e.length;++s)null==t[s]?r.push(hve.cast(hve.onesLike(e[s]),"bool")):t[s].rank<e[s].rank?r.push(hve.expandDims(t[s],-1)):r.push(t[s]);const a=hve.concat(r,this.axis);return hve.all(a,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function oEe(e,t){for(;e<0;)e+=t;return e}iEe.className="Concatenate",hve.serialization.registerClass(iEe);class lEe extends eEe{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){hve.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new rIe("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new nIe(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new nIe(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>oEe(t,e[n].shape.length))):[oEe(this.axes,n.shape.length),oEe(this.axes,r.shape.length)],this.normalize&&(n=ANe(n,t[0]),r=ANe(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new rIe("batchDot is not implemented for tensors of 4D or higher rank yet");if(hve.util.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),hve.util.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new rIe("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);const s=n;return hve.tidy((()=>{let n,i;if(r>a){n=r-a;const e=[];for(let t=0;t<n;++t)e.push(1);t=hve.reshape(t,t.shape.concat(e))}else if(a>r){n=a-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=hve.reshape(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?hve.sum(hve.mul(e,t),s[0]):hve.sum(hve.mul(hve.transpose(e,[1,0]),t),s[1]);else{const n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;i=hve.matMul(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=hve.squeeze(i,t)}return 1===i.shape.length&&(i=hve.expandDims(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[oEe(this.axes,e.length),oEe(this.axes,t.length)],n}computeOutputShape(e){hve.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new rIe("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}lEe.className="Dot",hve.serialization.registerClass(lEe);class uEe extends XTe{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return(0,hve.tidy)((()=>{this.invokeCallHook(e,t);const n=LTe(e);return pTe((()=>(0,hve.add)(iTe(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}uEe.className="GaussianNoise",hve.serialization.registerClass(uEe);class cEe extends XTe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return(0,hve.tidy)((()=>{this.invokeCallHook(e,t);const n=LTe(e);if(this.rate>0&&this.rate<1){return pTe((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return(0,hve.mul)(n,iTe(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}cEe.className="GaussianDropout",hve.serialization.registerClass(cEe);class dEe extends XTe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||LTe(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return(0,hve.tidy)((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=LTe(e),r=-1.7580993408473766;let a=(0,hve.greaterEqual)((0,hve.randomUniform)(n),this.rate);a=ZIe(a,"float32");const s=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-s*r*this.rate,o=(0,hve.add)((0,hve.mul)(t,a),(0,hve.mul)((0,hve.add)(a,-1),r));return(0,hve.add)((0,hve.mul)(o,s),i)};return pTe(r,(()=>LTe(e)),t.training||!1)}return e}))}}function hEe(e,t,n,r,a){let s,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)s=hve.batchNorm2d(e,t,n,r,a,i);else if(3===e.rank)s=hve.batchNorm3d(e,t,n,r,a,i);else{if(4!==e.rank)throw new rIe(`batchNormalization is not implemented for array of rank ${e.rank} yet`);s=hve.batchNorm4d(e,t,n,r,a,i)}return s}function pEe(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return hve.util.arraysEqual(r.slice().sort(),YIe(0,e.rank-1))?function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return(0,hve.tidy)((()=>{const s=hve.moments(e,r),i=s.mean,o=s.variance;return[hEe(e,i,o,n,t,a),i,o]}))}(e,t,n,r,a):function(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return(0,hve.tidy)((()=>{const s=hve.moments(e,r),i=s.mean,o=s.variance,l=[];for(const t of YIe(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=(0,hve.reshape)(i,l),c=(0,hve.reshape)(o,l),d=null==t?null:(0,hve.reshape)(t,l),h=null==n?null:(0,hve.reshape)(n,l);return[hEe(e,u,c,h,d,a),i,o]}))}(e,t,n,r,a)}dEe.className="AlphaDropout",hve.serialization.registerClass(dEe);class fEe extends XTe{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=FTe(e.betaInitializer||"zeros"),this.gammaInitializer=FTe(e.gammaInitializer||"ones"),this.movingMeanInitializer=FTe(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=FTe(e.movingVarianceInitializer||"ones"),this.betaConstraint=mNe(e.betaConstraint),this.gammaConstraint=mNe(e.gammaConstraint),this.betaRegularizer=tAe(e.betaRegularizer),this.gammaRegularizer=tAe(e.gammaRegularizer)}build(e){e=zTe(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new nIe(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new GTe({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return(0,hve.tidy)((()=>{const n=null!=t.training&&t.training,r=LTe(e),a=r.shape,s=a.length,i=YIe(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);const l=iIe(1,s);l[o]=a[o];const u=i.slice();u.sort();const c=!hve.util.arraysEqual(u,YIe(0,s).slice(0,s-1));if(!n)return(()=>{if(c){const e=(0,hve.reshape)(this.movingMean.read(),l),t=(0,hve.reshape)(this.movingVariance.read(),l),n=this.center?(0,hve.reshape)(this.beta.read(),l):null,a=this.scale?(0,hve.reshape)(this.gamma.read(),l):null;return hEe(r,e,t,n,a,this.epsilon)}return hEe(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,h,p]=pEe(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{hve.tidy((()=>{const r=1-n,a=e.read(),s=hve.mul(hve.sub(a,t),r);e.write(hve.sub(a,s))}))};return(()=>{f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:MTe(this.betaInitializer),gammaInitializer:MTe(this.gammaInitializer),movingMeanInitializer:MTe(this.movingMeanInitializer),movingVarianceInitializer:MTe(this.movingVarianceInitializer),betaRegularizer:JCe(this.betaRegularizer),gammaRegularizer:JCe(this.gammaRegularizer),betaConstraint:pNe(this.betaConstraint),gammaConstraint:pNe(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}fEe.className="BatchNormalization",hve.serialization.registerClass(fEe);class mEe extends XTe{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=FTe(e.betaInitializer||"zeros"),this.gammaInitializer=FTe(e.gammaInitializer||"ones"),this.betaRegularizer=tAe(e.betaRegularizer),this.gammaRegularizer=tAe(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=zTe(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==bIe(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=LTe(e),r=n.shape,a=r.length;return(0,hve.tidy)((()=>{let{mean:e,variance:t}=(0,hve.moments)(n,this.axis,!0);const s=iIe(1,a);for(const n of this.axis)s[n]=r[n];const i=e=>null!=e&&e.shape.length!==a?hve.reshape(e,s):e;let o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null;const u=[],c=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=hve.tile(e,u),t=hve.tile(t,u),null!=o&&(o=hve.tile(o,c)),null!=l&&(l=hve.tile(l,c)),hEe(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:MTe(this.betaInitializer),gammaInitializer:MTe(this.gammaInitializer),betaRegularizer:JCe(this.betaRegularizer),gammaRegularizer:JCe(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}mEe.className="LayerNormalization",hve.serialization.registerClass(mEe);class gEe extends XTe{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new nIe(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new nIe(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new nIe(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new GTe({ndim:4})]}computeOutputShape(e){let t,n;return e=zTe(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return(0,hve.tidy)((()=>function(e,t,n){return(0,hve.tidy)((()=>{if(4!==e.rank)throw new nIe(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new nIe("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new nIe(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],hve.pad(e,r)}))}(LTe(e),this.padding,this.dataFormat)))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function yEe(e,t,n,r,a,s){return(0,hve.tidy)((()=>{let i;FIe(a),PIe(s),OIe(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=dAe(e,a);const o="same"===r?"same":"valid";return i="max"===s?hve.maxPool(e,t,n,o):hve.avgPool(e,t,n,o),"channelsFirst"===a&&(i=hve.transpose(i,[0,3,1,2])),i}))}function bEe(e,t,n,r,a,s){return(0,hve.tidy)((()=>{let i;FIe(a),PIe(s),OIe(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==s&&(s="max"),e=hAe(e,a);const o="same"===r?"same":"valid";return i="max"===s?hve.maxPool3d(e,t,n,o):hve.avgPool3d(e,t,n,o),"channelsFirst"===a&&(i=hve.transpose(i,[0,4,1,2,3])),i}))}gEe.className="ZeroPadding2D",hve.serialization.registerClass(gEe);class vEe extends XTe{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new nIe(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(kIe(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new nIe(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}kIe(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,OIe(this.padding),this.inputSpec=[new GTe({ndim:3})]}computeOutputShape(e){const t=uAe((e=zTe(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return(0,hve.tidy)((()=>{this.invokeCallHook(e,t),e=JIe(LTe(e),2);const n=this.poolingFunction(LTe(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return hve.squeeze(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class xEe extends vEe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return FIe(a),OIe(r),yEe(e,t,n,r,a,"max")}}xEe.className="MaxPooling1D",hve.serialization.registerClass(xEe);class wEe extends vEe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return FIe(a),OIe(r),yEe(e,t,n,r,a,"avg")}}wEe.className="AveragePooling1D",hve.serialization.registerClass(wEe);class kEe extends XTe{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new nIe(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];kIe(this.poolSize,"poolSize"),kIe(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,FIe(this.dataFormat),OIe(this.padding),this.inputSpec=[new GTe({ndim:4})]}computeOutputShape(e){e=zTe(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=uAe(t,this.poolSize[0],this.padding,this.strides[0]),n=uAe(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return(0,hve.tidy)((()=>(this.invokeCallHook(e,t),this.poolingFunction(LTe(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class SEe extends kEe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return FIe(a),OIe(r),yEe(e,t,n,r,a,"max")}}SEe.className="MaxPooling2D",hve.serialization.registerClass(SEe);class IEe extends kEe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return FIe(a),OIe(r),yEe(e,t,n,r,a,"avg")}}IEe.className="AveragePooling2D",hve.serialization.registerClass(IEe);class TEe extends XTe{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new nIe(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];kIe(this.poolSize,"poolSize"),kIe(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,FIe(this.dataFormat),OIe(this.padding),this.inputSpec=[new GTe({ndim:5})]}computeOutputShape(e){e=zTe(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=uAe(t,this.poolSize[0],this.padding,this.strides[0]),n=uAe(n,this.poolSize[1],this.padding,this.strides[1]),r=uAe(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return(0,hve.tidy)((()=>(this.invokeCallHook(e,t),this.poolingFunction(LTe(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class NEe extends TEe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return FIe(a),OIe(r),bEe(e,t,n,r,a,"max")}}NEe.className="MaxPooling3D",hve.serialization.registerClass(NEe);class CEe extends TEe{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return FIe(a),OIe(r),bEe(e,t,n,r,a,"avg")}}CEe.className="AveragePooling3D",hve.serialization.registerClass(CEe);class AEe extends XTe{constructor(e){super(e),this.inputSpec=[new GTe({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new rIe}}class EEe extends AEe{constructor(e){super(e||{})}call(e,t){return(0,hve.tidy)((()=>{const t=LTe(e);return hve.mean(t,1)}))}}EEe.className="GlobalAveragePooling1D",hve.serialization.registerClass(EEe);class _Ee extends AEe{constructor(e){super(e||{})}call(e,t){return(0,hve.tidy)((()=>{const t=LTe(e);return hve.max(t,1)}))}}_Ee.className="GlobalMaxPooling1D",hve.serialization.registerClass(_Ee);class $Ee extends XTe{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,FIe(this.dataFormat),this.inputSpec=[new GTe({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new rIe}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class REe extends $Ee{call(e,t){return(0,hve.tidy)((()=>{const t=LTe(e);return"channelsLast"===this.dataFormat?hve.mean(t,[1,2]):hve.mean(t,[2,3])}))}}REe.className="GlobalAveragePooling2D",hve.serialization.registerClass(REe);class DEe extends $Ee{call(e,t){return(0,hve.tidy)((()=>{const t=LTe(e);return"channelsLast"===this.dataFormat?hve.max(t,[1,2]):hve.max(t,[2,3])}))}}DEe.className="GlobalMaxPooling2D",hve.serialization.registerClass(DEe);class MEe extends XTe{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=CNe(t.layer,n);delete t.layer;const a={layer:r};return Object.assign(a,t),new e(a)}}class FEe extends MEe{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=zTe(e)).length<3)throw new nIe(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=zTe(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return(0,hve.tidy)((()=>EAe(((e,n)=>[LTe(this.layer.call(e,t)),[]]),e=LTe(e),[],!1,null,null,!1,!0)[1]))}}FEe.className="TimeDistributed",hve.serialization.registerClass(FEe);class OEe extends MEe{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=CNe(n),t.goBackwards=!0!==t.goBackwards;const r={};var a;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=CNe(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,a=this.mergeMode,xIe(DIe,"BidirectionalMergeMode",a),e.weights)throw new rIe("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState?(r=a.slice(1),t=a[0]):t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):uIe(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const a=AAe(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const s=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new nIe("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);const r=n.map((e=>new GTe({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new rIe("Support for constants in Bidirectional layers is not implemented yet.");const o=s[0]instanceof HTe;for(const l of s)if(l instanceof HTe!==o)throw new nIe("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return(0,hve.tidy)((()=>{const n=t.initialState;let r,a,s,i;if(null==n)r=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{const s=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:s})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(s=r.slice(1).concat(a.slice(1))),r=r[0],a=a[0]),this.returnSequences&&(a=hve.reverse(a,1)),"concat"===this.mergeMode?i=rTe([r,a]):"sum"===this.mergeMode?i=hve.add(r,a):"ave"===this.mergeMode?i=hve.mul(.5,hve.add(r,a)):"mul"===this.mergeMode?i=hve.mul(r,a):null==this.mergeMode&&(i=[r,a]),this.returnState?null==this.mergeMode?i.concat(s):[i].concat(s):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){BIe(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),BIe(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=CNe(t.layer);if(delete t.layer,null!=t.numConstants)throw new rIe("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}OEe.className="Bidirectional",hve.serialization.registerClass(OEe);class PEe extends XTe{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return(0,hve.tidy)((()=>("float32"!==(e=LTe(e)).dtype&&(e=ZIe(e,"float32")),(0,hve.add)((0,hve.mul)(e,this.scale),this.offset))))}}PEe.className="Rescaling",hve.serialization.registerClass(PEe);const{resizeBilinear:LEe,cropAndResize:zEe}=hve.image;class BEe extends XTe{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,s,i,o){return(0,hve.tidy)((()=>{let l,u=!1;const c=[t/s,n/i,(r+t)/s,(a+n)/i],d=[];3===e.rank?(u=!0,l=(0,hve.stack)([e])):l=e;for(let e=0;e<l.shape[0];e++)d.push(c);const h=(0,hve.tensor)(d,[d.length,4]),p=(0,hve.range)(0,d.length,1,"int32"),f=zEe(l,h,p,[r,a],"nearest");return ZIe(u?LTe((0,hve.unstack)(f)):f,o)}))}upsize(e,t,n,r){return(0,hve.tidy)((()=>ZIe(LEe(e,[t,n]),r)))}call(e,t){return(0,hve.tidy)((()=>{const t=LTe(e),n=t.dtype,r=t.shape,a=r[r.length-3],s=r[r.length-2];let i=0;a!==this.height&&(i=Math.floor((a-this.height)/2));let o=0;return s!==this.width&&(o=Math.floor((s-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,a,s,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=zTe(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}BEe.className="CenterCrop",hve.serialization.registerClass(BEe);class VEe extends XTe{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=zTe(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return(0,hve.tidy)((()=>{let n;if("int32"!==(e=LTe(e)).dtype&&(e=ZIe(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new nIe(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=LTe(t.countWeights)}const r=(0,hve.max)(e),a=(0,hve.min)(e),s=(0,hve.greater)(this.numTokens,r).bufferSync().get(0),i=(0,hve.greaterEqual)(a,0).bufferSync().get(0);if(!s||!i)throw new nIe(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let a=LTe(e);if("int32"!==a.dtype&&(a=ZIe(a,"int32")),"int"===t)return a;const s=a.shape;if(0===a.rank&&(a=(0,hve.expandDims)(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=(0,hve.expandDims)(a,-1)),a.rank>2)throw new nIe(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);const i=["multiHot","oneHot"].includes(t),o=a;let l;if(l="undefined"!==typeof r&&"count"===t?(0,hve.denseBincount)(o,r,n,i):(0,hve.denseBincount)(o,[],n,i),"tfIdf"!==t)return l;if(r)return(0,hve.mul)(l,r);throw new nIe("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}VEe.className="CategoryEncoding",hve.serialization.registerClass(VEe);const WEe=new Set(["bilinear","nearest"]);class UEe extends XTe{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!WEe.has(e.interpolation))throw new nIe(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=zTe(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return(0,hve.tidy)((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return hve.image.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return hve.image.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...WEe]} are supported`)}))}}UEe.className="Resizing",hve.serialization.registerClass(UEe);class jEe{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}jEe.className="RandomSeed";class GEe extends XTe{constructor(e){super(e),this.randomGenerator=new jEe(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}GEe.className="BaseRandomLayer";const HEe=new Set(["bilinear","nearest"]);class qEe extends GEe{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new nIe(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new nIe(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new nIe(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!HEe.has(n))throw new nIe(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=zTe(e))[2];return[this.imgHeight,-1,t]}call(e,t){return(0,hve.tidy)((()=>{const t=LTe(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=(0,hve.randomUniform)([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return hve.image.resizeBilinear(e,a);case"nearest":return hve.image.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...HEe]} are supported`)}}))}}qEe.className="RandomWidth",hve.serialization.registerClass(qEe);var KEe,YEe=n(5452),XEe=n(4334);function QEe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(t_e(e)){const a=Array.isArray(e)?[]:{};r.add(e);for(const s in e){const i=QEe(e[s],t,n,r);a[s]=i}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function ZEe(e){return JEe(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:e_e)}function JEe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(t_e(r)){const a=Array.isArray(r)?[]:{};n.add(r);for(const s in r){const r=e.map((e=>e[s])),i=JEe(r,t,n);a[s]=i}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function e_e(e){return null===e?null:t_e(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function t_e(e){let t=!1;if(hve.env().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(551);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof hve.Tensor)&&!(e instanceof Promise)&&!t)}function n_e(e){return function(e,t){return QEe(e,t)}(e,r_e)}function r_e(e){return e instanceof hve.Tensor?{value:e.clone(),recurse:!1}:t_e(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class a_e{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class s_e extends a_e{constructor(){super(s_e.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function i_e(e){return new c_e(e)}function o_e(e,t){return new w_e(e,t)}s_e.INITIAL_CAPACITY=32;class l_e{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new y_e(this,e)}filter(e){return new m_e(this,e)}map(e){return new g_e(this,e)}mapAsync(e){return new b_e(this,e)}serialMapAsync(e){return new b_e(this,e).serial()}flatmap(e){return new x_e(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new f_e(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e_e;return this.rowMajorBatch(e,t).map((e=>ZEe(e,n)))}concatenate(e,t){return new w_e(new u_e([this,e]),t)}take(e){return e<0||null==e?this:new p_e(this,e)}skip(e){return e<0||null==e?this:new h_e(this,e)}prefetch(e){return new k_e(this,e)}shuffle(e,t){return new S_e(this,e,t)}serial(){return new d_e(this)}}class u_e extends l_e{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:n_e(e),done:!1}}}class c_e extends l_e{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(KR){throw KR.message=`Error thrown while iterating through a dataset: ${KR.message}`,KR}}}class d_e extends l_e{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class h_e extends l_e{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;hve.dispose(e.value)}return this.upstream.next()}}class p_e extends l_e{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class f_e extends l_e{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class m_e extends l_e{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;hve.dispose(e.value)}}}class g_e extends l_e{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=hve.tensor_util.getTensorsInContainer(e.value),n=this.transform(e.value),r=hve.tensor_util.getTensorsInContainer(n);for(const a of t)hve.tensor_util.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}}class y_e extends l_e{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(KR){if(!this.handler(KR))return{value:null,done:!0}}}}class b_e extends l_e{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=hve.tensor_util.getTensorsInContainer(e.value),n=await this.transform(e.value),r=hve.tensor_util.getTensorsInContainer(n);for(const a of t)hve.tensor_util.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}}class v_e extends l_e{constructor(){super(),this.outputQueue=new s_e,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class x_e extends v_e{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=hve.tensor_util.getTensorsInContainer(e.value),n=this.transform(e.value),r=hve.tensor_util.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(const a of t)hve.tensor_util.isTensorInList(a,r)||a.dispose();return!0}}class w_e extends l_e{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(KEe||(KEe={}));class k_e extends l_e{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new a_e(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class S_e extends k_e{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=XEe.alea(n||hve.util.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class I_e{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return hve.util.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),T_e((async()=>(await n.iterator()).columnMajorBatch(e,t,N_e)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,T_e((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,T_e((async()=>(await t.iterator()).filter((t=>hve.tidy((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return T_e((async()=>(await t.iterator()).map((t=>hve.tidy((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return T_e((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return T_e((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,T_e((async()=>o_e(i_e((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,T_e((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,a=XEe.alea(t||hve.util.now().toString());return T_e((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,T_e((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function T_e(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends I_e{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function N_e(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof hve.Tensor||hve.util.isTypedArray(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof hve.Tensor?hve.stack(e):hve.tensor(e)}(e),recurse:!1}}return{value:null,recurse:!0}}I_e.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function C_e(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&hve.util.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}const A_e=hve.kernel_impls.whereImpl;class E_e extends hve.KernelBackend{nextDataId(){return E_e.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new hve.DataStorage(this,(0,hve.engine)())}write(e,t,n){this.firstUse&&(this.firstUse=!1,(0,hve.env)().get("IS_NODE")&&hve.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&hve.util.isString(n[0])){const a=n.map((e=>hve.util.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){const e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return hve.backend_util.mergeRealAndImagArrays(e,t)}return hve.util.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>hve.util.decodeString(e)));return(0,hve.buffer)(e.shape,e.dtype,n)}catch(DP){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,hve.buffer)(e.shape,e.dtype,t)}makeOutput(e,t,n){return(0,hve.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=hve.util.now();e();return{kernelMs:hve.util.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){C_e([e],"where");const t=this.readSync(e.dataId);return A_e(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}E_e.nextDataId=0;function __e(e){return(t,n,r)=>{const a=hve.util.getArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function $_e(e,t,n){return R_e(e,__e(t),n)}function R_e(e,t,n){return r=>{let{inputs:a,attrs:s,backend:i}=r;const{x:o}=a;C_e(o,e);const l=i,u=l.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=hve.backend_util.fromUint8ToStringArray(u)}else c=u;const d=n||o.dtype,h=t(c,d,s);return l.makeTensorInfo(o.shape,d,h)}}(0,hve.registerBackend)("cpu",(()=>new E_e),1);const D_e=$_e(hve.Elu,(e=>e>=0?e:Math.exp(e)-1)),M_e={kernelName:hve.Elu,backendName:"cpu",kernelFunc:D_e};function F_e(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const O_e={kernelName:hve.Identity,backendName:"cpu",kernelFunc:F_e};function P_e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;C_e([a],"leakyRelu");const i=hve.util.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=hve.util.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}const L_e={kernelName:hve.LeakyRelu,backendName:"cpu",kernelFunc:P_e};function z_e(e){return(t,n,r,a,s)=>{const i=hve.backend_util.assertAndGetBroadcastShape(t,n),o=i.length,l=hve.util.computeStrides(i),u=hve.util.sizeFromShape(i),c=hve.util.getTypedArrayFromDType(s,u),d=t.length,h=n.length,p=hve.util.computeStrides(t),f=hve.util.computeStrides(n),m=hve.backend_util.getBroadcastDims(t,i),g=hve.backend_util.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<c.length;++y){const t=hve.util.indexToLoc(y,o,l),n=t.slice(-d);m.forEach((e=>n[e]=0));const s=hve.util.locToIndex(n,d,p),i=t.slice(-h);g.forEach((e=>i[e]=0));const u=hve.util.locToIndex(i,h,f);c[y]=e(r[s],a[u])}return[c,i]}}const B_e=z_e(((e,t)=>e<0?t*e:e));function V_e(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t;C_e([r,a],"prelu");const s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=B_e(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}const W_e={kernelName:hve.Prelu,backendName:"cpu",kernelFunc:V_e},U_e=$_e(hve.Relu,(e=>Math.max(0,e))),j_e={kernelName:hve.Relu,backendName:"cpu",kernelFunc:U_e},G_e=$_e(hve.Relu6,(e=>Math.min(Math.max(0,e),6))),H_e={kernelName:hve.Relu6,backendName:"cpu",kernelFunc:G_e},q_e=__e((e=>1/(1+Math.exp(-e)))),K_e=$_e(hve.Sigmoid,(e=>1/(1+Math.exp(-e)))),Y_e={kernelName:hve.Sigmoid,backendName:"cpu",kernelFunc:K_e};function X_e(e,t,n,r,a){if("linear"===n)return F_e({inputs:{x:t},backend:e});if("relu"===n)return U_e({inputs:{x:t},backend:e});if("elu"===n)return D_e({inputs:{x:t},backend:e});if("relu6"===n)return G_e({inputs:{x:t},backend:e});if("prelu"===n)return V_e({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return P_e({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return K_e({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Q_e(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}const Z_e={kernelName:hve.Complex,backendName:"cpu",kernelFunc:Q_e};function J_e(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return Q_e({inputs:{real:J_e(e,t,"float32"),imag:J_e(e,t,"float32")},backend:e})}const r=hve.util.makeZerosTypedArray(hve.util.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function e$e(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const t$e={kernelName:hve.Real,backendName:"cpu",kernelFunc:e$e};function n$e(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=hve.util.toTypedArray([0],n),[a,s]=z_e(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[s,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function r$e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return F_e({inputs:{x:a},backend:n});const e=J_e(n,a.shape,a.dtype),t=r$e({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=Q_e({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){const e=e$e({inputs:{input:a},backend:n}),t=r$e({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!hve.util.hasEncodingLoss(a.dtype,s)){const e=F_e({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}const i=n.data.get(a.dataId).values,[o,l,u]=n$e(i,a.shape,a.dtype,s);return n.makeTensorInfo(o,l,u)}const a$e={kernelName:hve.Cast,backendName:"cpu",kernelFunc:r$e};function s$e(e,t,n,r){return null==n?n=>{let{inputs:a,backend:s}=n;const{a:i,b:o}=a,l=s;C_e([i,o],e);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d="string"===i.dtype?hve.backend_util.fromUint8ToStringArray(u):u,h="string"===i.dtype?hve.backend_util.fromUint8ToStringArray(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:e=>{let{inputs:a,backend:s}=e;const{a:i,b:o}=a,l=s;if("complex64"===i.dtype||"complex64"===o.dtype){const e=r$e({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,s=l.data.get(r.dataId).values,u=l.data.get(a.dataId).values,c=r$e({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=l.data.get(h.dataId).values,m=l.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,s,u,f,m),v=l.makeTensorInfo(b,"float32",g),x=l.makeTensorInfo(b,"float32",y),w=Q_e({inputs:{real:v,imag:x},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(x),w}{const e=l.data.get(i.dataId).values,n=l.data.get(o.dataId).values,a=r||i.dtype,[s,u]=t(i.shape,o.shape,e,n,a);return l.makeTensorInfo(u,a,s)}}}function i$e(e){return(t,n,r,a,s,i)=>{const o=hve.backend_util.assertAndGetBroadcastShape(t,n),l=hve.util.sizeFromShape(o),u=o.length,c=hve.util.computeStrides(o),d=hve.util.getTypedArrayFromDType("float32",l),h=hve.util.getTypedArrayFromDType("float32",l),p=hve.backend_util.getBroadcastDims(t,o),f=hve.backend_util.getBroadcastDims(n,o),m=hve.backend_util.mergeRealAndImagArrays(r,a),g=hve.backend_util.mergeRealAndImagArrays(s,i),y=t.length,b=hve.util.computeStrides(t),v=n.length,x=hve.util.computeStrides(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=r.real,h[w]=r.imag}else for(let w=0;w<d.length;w++){const t=hve.util.indexToLoc(w,u,c),n=t.slice(-y);p.forEach((e=>n[e]=0));const r=hve.util.locToIndex(n,y,b),a=t.slice(-v);f.forEach((e=>a[e]=0));const s=hve.util.locToIndex(a,v,x),i=e(m[2*r],m[2*r+1],g[2*s],g[2*s+1]);d[w]=i.real,h[w]=i.imag}return[d,h,o]}}const o$e=z_e(((e,t)=>e+t)),l$e=i$e(((e,t,n,r)=>({real:e+n,imag:t+r}))),u$e=s$e(hve.Add,o$e,l$e),c$e={kernelName:hve.Add,backendName:"cpu",kernelFunc:u$e};function d$e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=hve.util.sizeFromShape(a.shape),o=hve.util.inferFromImplicitShape(s,i),l=hve.util.sizeFromShape(o);hve.util.assert(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);const u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}const h$e={kernelName:hve.Reshape,backendName:"cpu",kernelFunc:d$e};function p$e(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;C_e([a,s],"matMul");const l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-1]:a.shape[l-2],p=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=hve.util.sizeFromShape(f),y=hve.util.sizeFromShape(m),b=hve.broadcast_util.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([h,p]);hve.util.assert(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));const v=o?[y,p,d]:[y,d,p],x=d$e({inputs:{x:a},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=d$e({inputs:{x:s},backend:n,attrs:{shape:v}}),k=i?x.shape[1]:x.shape[2],S=i?x.shape[2]:x.shape[1],I=o?w.shape[1]:w.shape[2],T=Math.max(g,y),N=n.data.get(x.dataId).values,C=n.data.get(w.dataId).values,A=hve.util.computeStrides(x.shape),E=hve.util.computeStrides(w.shape),[_,$,R]=i?[A[0],1,A[1]]:[A[0],A[1],1],[D,M,F]=o?[1,E[1],E[0]]:[E[1],1,E[0]],O=S*I,P=(0,hve.buffer)([T,S,I],x.dtype),L=P.values,z=n.blockSize;for(let B=0;B<T;B++){const e=B%g,t=B%y;for(let n=0;n<S;n+=z){const r=Math.min(n+z,S);for(let a=0;a<I;a+=z){const s=Math.min(a+z,I);for(let i=0;i<k;i+=z){const o=Math.min(i+z,k);for(let l=n;l<r;l++)for(let n=a;n<s;n++){let r=0;for(let a=i;a<o;a++){r+=N[e*_+l*$+a*R]*C[a*D+n*M+t*F]}L[B*O+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,P.dtype,P.values)}const f$e={kernelName:hve.BatchMatMul,backendName:"cpu",kernelFunc:p$e};const m$e={kernelName:hve._FusedMatMul,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=p$e({inputs:{a:a,b:s},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=u$e({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=X_e(n,h,c,o,d),m.push(h),h=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return h}};function g$e(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const y$e={kernelName:hve.Abs,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;C_e(t,"abs");let r=new Float32Array(hve.util.sizeFromShape(t.shape));return r=g$e(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},b$e=$_e(hve.Acos,(e=>Math.acos(e))),v$e={kernelName:hve.Acos,backendName:"cpu",kernelFunc:b$e},x$e=$_e(hve.Acosh,(e=>Math.acosh(e))),w$e={kernelName:hve.Acosh,backendName:"cpu",kernelFunc:x$e};const k$e={kernelName:hve.AddN,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;C_e(t,"addN");const a=r.map((e=>n.data.get(e.dataId).values)),s=(0,hve.buffer)(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){const e=a[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function S$e(e,t,n,r,a){const s=t.length,i=hve.util.sizeFromShape(t),o=hve.util.computeStrides(t),l=hve.util.computeStrides(a),u=hve.util.getTypedArrayFromDType(n,hve.util.sizeFromShape(a));for(let c=0;c<i;++c){const t=hve.util.indexToLoc(c,s,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[hve.util.locToIndex(n,s,l)]=e[c]}return u}function I$e(e){const{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;C_e(a,"transpose");const i=a.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=a.shape[s[u]];const l=S$e(r.data.get(a.dataId).values,a.shape,a.dtype,s,o);return{dataId:r.write(l,o,a.dtype),shape:o,dtype:a.dtype}}const T$e={kernelName:hve.Transpose,backendName:"cpu",kernelFunc:I$e};const N$e={kernelName:hve.All,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;C_e(a,"all");const o=hve.util.parseAxisParam(s,a.shape);let l=o;const u=hve.backend_util.getAxesPermutation(l,a.shape.length);let c=a;null!=u&&(c=I$e({inputs:{x:a},backend:n,attrs:{perm:u}}),l=hve.backend_util.getInnerMostAxes(l.length,a.shape.length)),hve.backend_util.assertAxesAreInnerMostDims("all",l,c.shape.length);const[d,h]=hve.backend_util.computeOutAndReduceShapes(c.shape,l),p=hve.util.sizeFromShape(h),f=hve.util.makeZerosTypedArray(hve.util.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=d$e({inputs:{x:g},backend:n,attrs:{shape:hve.backend_util.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const C$e={kernelName:hve.Any,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;C_e(a,"any");const o=hve.util.parseAxisParam(s,a.shape);let l=o;const u=hve.backend_util.getAxesPermutation(l,a.shape.length);let c=a;null!=u&&(c=I$e({inputs:{x:a},backend:n,attrs:{perm:u}}),l=hve.backend_util.getInnerMostAxes(l.length,a.shape.length)),hve.backend_util.assertAxesAreInnerMostDims("any",l,c.shape.length);const[d,h]=hve.backend_util.computeOutAndReduceShapes(c.shape,l),p=hve.util.sizeFromShape(h),f=hve.util.makeZerosTypedArray(hve.util.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=d$e({inputs:{x:g},backend:n,attrs:{shape:hve.backend_util.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const A$e={kernelName:hve.ArgMax,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;C_e(a,"argMax");let i=hve.util.parseAxisParam(s,a.shape);const o=hve.backend_util.getAxesPermutation(i,a.shape.length);let l=a;const u=[];null!=o&&(l=I$e({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=hve.backend_util.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],hve.backend_util.assertAxesAreInnerMostDims("argMax",i,l.shape.length);const[c,d]=hve.backend_util.computeOutAndReduceShapes(l.shape,i),h=hve.util.sizeFromShape(c),p=hve.util.makeZerosTypedArray(h,"int32"),f=hve.util.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const e=g*f;let t=m[e],n=0;for(let r=0;r<f;++r){const a=m[e+r];a>t&&(t=a,n=r)}p[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}};const E$e={kernelName:hve.ArgMin,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;C_e(a,"argMin");let i=hve.util.parseAxisParam(s,a.shape);const o=hve.backend_util.getAxesPermutation(i,a.shape.length);let l=a;const u=[];null!=o&&(l=I$e({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=hve.backend_util.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],hve.backend_util.assertAxesAreInnerMostDims("argMin",i,l.shape.length);const[c,d]=hve.backend_util.computeOutAndReduceShapes(l.shape,i),h=hve.util.sizeFromShape(c),p=hve.util.makeZerosTypedArray(h,"int32"),f=hve.util.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const e=g*f;let t=m[e],n=0;for(let r=0;r<f;++r){const a=m[e+r];a<t&&(t=a,n=r)}p[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",p)}},_$e=$_e(hve.Asin,(e=>Math.asin(e))),$$e={kernelName:hve.Asin,backendName:"cpu",kernelFunc:_$e},R$e=$_e(hve.Asinh,(e=>Math.asinh(e))),D$e={kernelName:hve.Asinh,backendName:"cpu",kernelFunc:R$e},M$e=$_e(hve.Atan,(e=>Math.atan(e))),F$e={kernelName:hve.Atan,backendName:"cpu",kernelFunc:M$e},O$e=z_e(((e,t)=>Math.atan2(e,t))),P$e=s$e(hve.Atan2,O$e),L$e={kernelName:hve.Atan2,backendName:"cpu",kernelFunc:P$e},z$e=$_e(hve.Atanh,(e=>Math.atanh(e))),B$e={kernelName:hve.Atanh,backendName:"cpu",kernelFunc:z$e};function V$e(e,t,n,r,a,s){const i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,c=a.effectiveFilterHeight,d=a.effectiveFilterWidth,h=a.padInfo.top,p=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=(0,hve.buffer)(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let x=0;x<a.batchSize;++x){const t=x*y,n=x*r[0];for(let m=0;m<a.inChannels;++m)for(let y=0;y<a.outHeight;++y){const x=y*i-h,w=Math.max(0,x),k=Math.min(a.inHeight,c+x),S=t+y*b;for(let t=0;t<a.outWidth;++t){const i=t*o-p,c=Math.max(0,i),h=Math.min(a.inWidth,d+i);let y=f,b=0,x=0;for(let t=w;t<k;t+=l){const a=n+t*r[1];for(let t=c;t<h;t+=u){const n=e[a+t*r[2]+m];"max"===s&&n>y?y=n:"avg"===s&&(b+=n,x++)}if(isNaN(y))break}g[S+t*v+m]="avg"===s?b/x:y}}}return m}function W$e(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=(0,hve.buffer)(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=(0,hve.buffer)(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*o-p;let y=n;for(;y<0;)y+=u;const b=Math.min(r.inHeight,d+n);for(let o=0;o<r.outWidth;++o){const d=o*l-f;let p=d;for(;p<0;)p+=c;const v=Math.min(r.inWidth,h+d);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=u){const i=t-n;for(let n=p;n<v;n+=c){const o=n-d,l=m.get(g,t,n,e);l>x&&(x=l,w=a?s?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*h+o)}}i.set(w,g,t,o,e)}}return i}function U$e(e,t,n,r,a,s){const i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,c=a.dilationHeight,d=a.dilationWidth,h=a.effectiveFilterDepth,p=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=(0,hve.buffer)(a.outShape,n),x=v.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let T=0;T<a.batchSize;++T){const t=T*w,n=T*r[0];for(let v=0;v<a.inChannels;++v)for(let w=0;w<a.outDepth;++w){const T=w*i-m;let N=T;for(;N<0;)N+=u;const C=Math.min(a.inDepth,h+T),A=t+w*k;for(let t=0;t<a.outHeight;++t){const i=t*o-g;let h=i;for(;h<0;)h+=c;const m=Math.min(a.inHeight,p+i),w=A+t*S;for(let t=0;t<a.outWidth;++t){const i=t*l-y;let o=i;for(;o<0;)o+=d;const p=Math.min(a.inWidth,f+i),g=w+t*I;let k=b,S=0,T=0;for(let t=N;t<C;t+=u){const a=n+t*r[1];for(let t=h;t<m;t+=c){const n=a+t*r[2];for(let t=o;t<p;t+=d){const a=e[n+t*r[3]+v];if("max"===s&&a>k?k=a:"avg"===s&&(S+=a,T++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===s?S/Math.max(T,1):k}}}}return v}const j$e={kernelName:hve.AvgPool,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;C_e(a,"avgPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;hve.util.assert(hve.backend_util.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hve.backend_util.computePool2DInfo(a.shape,s,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&hve.util.arraysEqual(u.inShape,u.outShape))c=F_e({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=hve.util.computeStrides(a.shape),r=V$e(e,a.shape,a.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,a.dtype,r.values)}return c}};const G$e={kernelName:hve.AvgPool3D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;C_e(a,"avgPool3d");const c=hve.backend_util.computePool3DInfo(a.shape,s,i,1,o,l,u),d=U$e(n.data.get(a.dataId).values,a.shape,a.dtype,hve.util.computeStrides(a.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};const H$e={kernelName:hve.AvgPool3DGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;C_e([a,s],"avgPool3DGrad");const c=hve.backend_util.computePool3DInfo(s.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=x-1-c.padInfo.front,I=k-1-c.padInfo.left,T=w-1-c.padInfo.top,N=(0,hve.buffer)(s.shape,"float32"),C=1/(f*m*g),A=n.bufferSync(a);for(let E=0;E<c.batchSize;++E)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const a=t-S,s=n-T,i=r-I;let o=0;for(let t=0;t<x;t+=y){const n=(a+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const r=(s+t)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){const a=(i+t)/p;if(a<0||a>=c.outWidth||Math.floor(a)!==a)continue;o+=A.get(E,n,r,a,e)}}}N.set(o*C,E,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const q$e={kernelName:hve.AvgPoolGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;C_e([a,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=hve.backend_util.computePool2DInfo(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=(0,hve.buffer)(i.shape,"float32"),k=1/(p*f),S=n.data.get(a.dataId).values,I=(0,hve.buffer)(a.shape,"float32",S);for(let T=0;T<c.batchSize;++T)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const r=t-x,a=n-v;let s=0;for(let t=0;t<y;t+=m){const n=(r+t)/d;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const r=(a+t)/h;if(r<0||r>=c.outWidth||Math.floor(r)!==r)continue;s+=I.get(T,n,r,e)}}w.set(s*k,T,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const K$e={kernelName:hve.FusedBatchNorm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;hve.util.assert(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),hve.util.assert(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),hve.util.assert(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),C_e([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,v=d.length;let x=0,w=0,k=0,S=0;for(let I=0;I<c.length;++I)m[I]=f[x++]+(c[I]-d[w++])*p[k++]/Math.sqrt(h[S++]+u),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,m)}};function Y$e(e,t,n,r,a){const s=hve.slice_util.isSliceContinous(r,t,n),i=hve.util.sizeFromShape(n),o=hve.util.computeStrides(r);if(s){const n=hve.slice_util.computeFlatOffset(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}const l="string"===a?hve.backend_util.fromUint8ToStringArray(e):e,u=(0,hve.buffer)(r,a,l),c=(0,hve.buffer)(n,a);for(let d=0;d<c.size;++d){const e=c.indexToLoc(d),n=e.map(((e,n)=>e+t[n]));c.set(u.get(...n),...e)}return"string"===a?hve.backend_util.fromStringArrayToUint8(c.values):c.values}function X$e(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;C_e(a,"slice");const[o,l]=hve.slice_util.parseSliceParams(a,s,i);hve.slice_util.assertParamsValid(a,o,l);const u=Y$e(n.data.get(a.dataId).values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}const Q$e={kernelName:hve.Slice,backendName:"cpu",kernelFunc:X$e};const Z$e={kernelName:hve.BatchToSpaceND,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;C_e([a],"batchToSpaceND");const o=s.reduce(((e,t)=>e*t)),l=hve.backend_util.getReshaped(a.shape,s,o),u=hve.backend_util.getPermuted(l.length,s.length),c=hve.backend_util.getReshapedPermuted(a.shape,s,o),d=hve.backend_util.getSliceBeginCoords(i,s.length),h=hve.backend_util.getSliceSize(c,i,s.length),p=d$e({inputs:{x:a},backend:n,attrs:{shape:l}}),f=I$e({inputs:{x:p},backend:n,attrs:{perm:u}}),m=d$e({inputs:{x:f},backend:n,attrs:{shape:c}}),g=X$e({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function J$e(e,t,n,r,a){const s=hve.util.sizeFromShape(r),i=hve.util.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=s>0?t[o]:1)}return i}function eRe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=e.shape[0],s=e.shape[1],i=(0,hve.buffer)([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){const s=e.get(o,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}const tRe={kernelName:hve.Bincount,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=J$e(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,o)}},nRe=z_e(((e,t)=>e&t)),rRe=s$e(hve.BitwiseAnd,nRe),aRe={kernelName:hve.BitwiseAnd,backendName:"cpu",kernelFunc:rRe};const sRe={kernelName:hve.BroadcastArgs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=hve.backend_util.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},iRe=__e((e=>Math.ceil(e))),oRe=R_e(hve.Ceil,iRe),lRe={kernelName:hve.Ceil,backendName:"cpu",kernelFunc:oRe},uRe=$_e(hve.ClipByValue,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),cRe={kernelName:hve.ClipByValue,backendName:"cpu",kernelFunc:uRe},dRe={kernelName:hve.ComplexAbs,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(hve.util.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function hRe(e,t,n,r){const a=hve.util.getArrayFromDType(n,hve.util.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=hve.util.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const s="string"===n?hve.backend_util.fromUint8ToStringArray(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]}))}return a}function pRe(e){const{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}const fRe={kernelName:hve.Imag,backendName:"cpu",kernelFunc:pRe};function mRe(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=hve.util.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));hve.backend_util.assertParamsConsistent(i,s);let o=hve.backend_util.computeOutShape(t.map((e=>e.shape)),s);if(0===hve.util.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter((e=>hve.util.sizeFromShape(e.shape)>0));if(1===l.length)return F_e({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){const e=l.map((e=>e$e({inputs:{input:e},backend:n}))),t=l.map((e=>pRe({inputs:{input:e},backend:n}))),r=mRe({inputs:e,backend:n,attrs:{axis:s}}),a=mRe({inputs:t,backend:n,attrs:{axis:s}}),i=Q_e({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}const u=l.map((e=>{const t=hve.util.sizeFromShape(e.shape.slice(s));return d$e({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),c=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=hve.backend_util.computeOutShape(u.map((e=>e.shape)),1);const d=1===u[0].shape[0],h=hRe(c,o,t[0].dtype,d),p=hve.backend_util.computeOutShape(l.map((e=>e.shape)),s),f=n.makeTensorInfo(p,t[0].dtype,h);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}const gRe={kernelName:hve.Concat,backendName:"cpu",kernelFunc:mRe};function yRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;C_e([a,s],"conv2d");const d=hve.backend_util.convertConv2DDataFormat(l),h=hve.backend_util.computeConv2DInfo(a.shape,s.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new hve.TensorBuffer(h.outShape,a.dtype),w=hve.util.computeStrides(a.shape),k=hve.util.computeStrides(s.shape),S=w[0],I=v?w[1]:w[2],T=v?w[2]:1,N=v?1:w[1],C=x.strides[0],A=v?x.strides[1]:x.strides[2],E=v?x.strides[2]:1,_=v?1:x.strides[1],$=n.data.get(a.dataId).values,R=n.data.get(s.dataId).values,D=x.values;for(let M=0;M<h.batchSize;++M){const e=M*S,t=M*C;for(let n=0;n<h.outHeight;++n){const r=t+n*A,a=n*h.strideHeight-b;for(let t=0;t<p;++t){const n=a+t*m;if(n<0||n>=h.inHeight)continue;const s=t*k[0],i=e+n*I;for(let e=0;e<h.outWidth;++e){const t=r+e*E,n=e*h.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=h.inWidth)continue;const a=i+r*T;let o=s+e*k[1];for(let e=0;e<h.inChannels;++e){const n=$[a+e*N];for(let e=0;e<h.outChannels;++e)D[t+e*_]+=n*R[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,D)}const bRe={kernelName:hve.Conv2D,backendName:"cpu",kernelFunc:yRe};const vRe={kernelName:hve.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;C_e([a,s],"conv2dBackpropFilter");const d=hve.backend_util.convertConv2DDataFormat(l),h=hve.backend_util.computeConv2DInfo(a.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new hve.TensorBuffer(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=new hve.TensorBuffer(a.shape,a.dtype,w),I=new hve.TensorBuffer(s.shape,s.dtype,k);for(let T=0;T<m;++T){const e=Math.max(0,Math.ceil((x-T)/p)),t=Math.min(h.outHeight,(h.inHeight+x-T)/p);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(h.outWidth,(h.inWidth+v-n)/f);for(let s=0;s<h.inChannels;++s)for(let i=0;i<h.outChannels;++i){let o=0;for(let l=0;l<h.batchSize;++l)for(let u=e;u<t;++u){const e=T+u*p-x;for(let t=r;t<a;++t){const r=n+t*f-v;o+=y?S.get(l,e,r,s)*I.get(l,u,t,i):S.get(l,s,e,r)*I.get(l,i,u,t)}}b.set(o,T,n,s,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const xRe={kernelName:hve.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;C_e([a,s],"conv2dBackpropInput");const d=hve.util.computeStrides(s.shape),h=hve.util.computeStrides(a.shape);let p=hve.backend_util.convertConv2DDataFormat(u);const f=hve.backend_util.computeConv2DInfo(i,s.shape,o,1,l,c,!1,p),m=new hve.TensorBuffer(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[v,x,w]=d,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:T,inHeight:N,inWidth:C,outChannels:A,outHeight:E,outWidth:_,strideHeight:$,strideWidth:R}=f;p=f.dataFormat;const D=S-1-f.padInfo.top,M=I-1-f.padInfo.left,F="channelsLast"===p,O=m.strides[0],P=F?m.strides[1]:m.strides[2],L=F?m.strides[2]:1,z=F?1:m.strides[1],B=h[0],V=F?h[1]:h[2],W=F?h[2]:1,U=F?1:h[1];for(let j=0;j<k;++j)for(let e=0;e<T;++e)for(let t=0;t<N;++t){const n=t-D,r=Math.max(0,Math.ceil(n/$)),a=Math.min(E,(S+n)/$);for(let s=0;s<C;++s){const i=s-M,o=Math.max(0,Math.ceil(i/R)),l=Math.min(_,(I+i)/R);let u=0;for(let t=r;t<a;++t){const r=t*$-n;for(let n=o;n<l;++n){const a=B*j+V*t+W*n,s=v*(S-1-r)+x*(I-1-(n*R-i))+w*e;for(let e=0;e<A;++e){u+=y[a+U*e]*b[s+e]}}}g[O*j+P*t+L*s+z*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const wRe={kernelName:hve.Conv3D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;C_e([a,s],"conv3d");const u=hve.backend_util.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new hve.TensorBuffer(u.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,S=x.values,I=hve.util.computeStrides(a.shape),T=hve.util.computeStrides(s.shape);for(let N=0;N<u.batchSize;++N){const e=N*I[0],t=N*x.strides[0];for(let n=0;n<u.outDepth;++n){const r=t+n*x.strides[1],a=n*u.strideDepth-y;for(let t=0;t<c;++t){const n=a+t*p;if(n<0||n>=u.inDepth)continue;const s=t*T[0],i=e+n*I[1];for(let e=0;e<u.outHeight;++e){const t=r+e*x.strides[2],n=e*u.strideHeight-v;for(let e=0;e<d;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const a=s+e*T[1],o=i+r*I[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<h;++e){const t=r+e*m;if(t<0||t>=u.inWidth)continue;const s=a+e*T[2],i=o+t*u.inChannels;let l=s;for(let e=0;e<u.inChannels;++e){const t=w[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const kRe={kernelName:hve.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;C_e([a,s],"conv3dBackpropFilterV2");const u=hve.util.computeStrides(a.shape),c=hve.util.computeStrides(s.shape),d=hve.backend_util.computeConv3DInfo(a.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new hve.TensorBuffer(d.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,I=n.data.get(s.dataId).values,[T,N,C,A]=c,E=n.data.get(a.dataId).values,[_,$,R,D]=u,M=d.padInfo.front,F=d.padInfo.left,O=d.padInfo.top;for(let P=0;P<m;++P){const e=Math.max(0,Math.ceil((M-P)/h)),t=Math.min(d.outDepth,(d.inDepth+M-P)/h),n=P*x;for(let r=0;r<g;++r){const a=Math.max(0,Math.ceil((O-r)/p)),s=Math.min(d.outHeight,(d.inHeight+O-r)/p),i=r*w+n;for(let n=0;n<y;++n){const o=Math.max(0,Math.ceil((F-n)/f)),l=Math.min(d.outWidth,(d.inWidth+F-n)/f),u=n*k+i;for(let i=0;i<d.inChannels;++i){const c=i*S+u;for(let u=0;u<d.outChannels;++u){let m=0;for(let c=0;c<d.batchSize;++c){const d=c*_,g=c*T;for(let c=e;c<t;++c){const e=(P+c*h-M)*$+d,t=c*N+g;for(let c=a;c<s;++c){const a=(r+c*p-O)*R+e,s=c*C+t;for(let e=o;e<l;++e){const t=e*A+s;m+=E[(n+e*f-F)*D+a+i]*I[t+u]}}}}v[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const SRe={kernelName:hve.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;C_e([a],"conv3dBackpropInputV2");const u=hve.util.computeStrides(a.shape),c=hve.util.computeStrides(s.shape),d=hve.backend_util.computeConv3DInfo(l,s.shape,o,1,i),h=new hve.TensorBuffer(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(a.dataId).values,[v,x,w,k]=u,S=n.data.get(s.dataId).values,[I,T,N,C]=c,{batchSize:A,filterDepth:E,filterHeight:_,filterWidth:$,inChannels:R,inDepth:D,inHeight:M,inWidth:F,outChannels:O,outDepth:P,outHeight:L,outWidth:z,strideDepth:B,strideHeight:V,strideWidth:W}=d,U=E-1-d.padInfo.front,j=_-1-d.padInfo.top,G=$-1-d.padInfo.left;for(let H=0;H<A;++H)for(let e=0;e<R;++e)for(let t=0;t<D;++t){const n=t-U,r=Math.max(0,Math.ceil(n/B)),a=Math.min(P,(E+n)/B);for(let s=0;s<M;++s){const i=s-j,o=Math.max(0,Math.ceil(i/V)),l=Math.min(L,(_+i)/V);for(let u=0;u<F;++u){const c=u-G,d=Math.max(0,Math.ceil(c/W)),h=Math.min(z,($+c)/W);let A=0;for(let t=r;t<a;++t){const r=t*B-n;for(let n=o;n<l;++n){const a=n*V-i;for(let s=d;s<h;++s){const i=v*H+x*t+w*n+k*s,o=I*(E-1-r)+T*(_-1-a)+N*($-1-(s*W-c))+C*e;for(let e=0;e<O;++e){A+=b[i+e]*S[o+e]}}}}p[f*H+m*t+g*s+y*u+e]=A}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},IRe=$_e(hve.Cos,(e=>Math.cos(e))),TRe={kernelName:hve.Cos,backendName:"cpu",kernelFunc:IRe},NRe=$_e(hve.Cosh,(e=>Math.cosh(e))),CRe={kernelName:hve.Cosh,backendName:"cpu",kernelFunc:NRe};const ARe={kernelName:hve.CropAndResize,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=a.shape,f=s.shape[0],[m,g]=o,y=(0,hve.buffer)([f,m,g,p],"float32"),b=n.data.get(s.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,w=hve.util.computeStrides(a.shape),k=hve.util.computeStrides(y.shape);for(let S=0;S<f;S++){const e=4*S,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],s=v[S];if(s>=c)continue;const i=m>1?(r-t)*(d-1)/(m-1):0,o=g>1?(a-n)*(h-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(d-1)+c*i:.5*(t+r)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}else if("bilinear"===l){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const l=g>1?n*(h-1)+e*o:.5*(n+a)*(h-1);if(l<0||l>h-1){for(let t=0;t<p;t++){const n=t+e*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const d=Math.floor(l),f=Math.ceil(l),m=l-d;for(let n=0;n<p;n++){let a=n+d*w[2]+t*w[1]+s*w[0];const o=x[a];a=n+f*w[2]+t*w[1]+s*w[0];const l=x[a];a=n+d*w[2]+r*w[1]+s*w[0];const u=x[a];a=n+f*w[2]+r*w[1]+s*w[0];const h=o+(l-o)*m,p=u+(x[a]-u)*m;a=n+e*k[2]+c*k[1]+S*k[0],y.values[a]=h+(p-h)*i}}}else for(let t=0;t<g;++t){const r=g>1?n*(h-1)+t*o:.5*(n+a)*(h-1);if(r<0||r>h-1){for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++){const n=e+i*w[2]+l*w[1]+s*w[0],r=e+t*k[2]+c*k[1]+S*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const ERe={kernelName:hve.Cumprod,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;C_e(a,"cumprod");const l=hve.backend_util.getAxesPermutation([s],a.shape.length);let u=a;null!=l&&(u=I$e({inputs:{x:a},backend:n,attrs:{perm:l}}));const c=hve.backend_util.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=(0,hve.upcastType)(u.dtype,"int32"),h=hve.util.makeOnesTypedArray(hve.util.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)h[t]=i?1:p[t];else{const n=m(y,e-1);h[t]=i?p[n]*h[n]:p[t]*h[n]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=I$e({inputs:{x:g},backend:n,attrs:{perm:hve.backend_util.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const _Re={kernelName:hve.Cumsum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;C_e(a,"cumsum");const l=hve.backend_util.getAxesPermutation([s],a.shape.length);let u=a;null!=l&&(u=I$e({inputs:{x:a},backend:n,attrs:{perm:l}}));const c=hve.backend_util.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=(0,hve.upcastType)(u.dtype,"int32"),h=hve.util.makeZerosTypedArray(hve.util.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)h[t]=i?0:p[t];else{const n=m(y,e-1);h[t]=i?p[n]+h[n]:p[t]+h[n]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=I$e({inputs:{x:g},backend:n,attrs:{perm:hve.backend_util.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const $Re={kernelName:hve.DenseBincount,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){const e=J$e(n.data.get(a.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,e)}if(2===a.shape.length){const e=eRe(n.bufferSync(a),n.bufferSync(s),i,o);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};const RRe={kernelName:hve.DepthToSpace,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;hve.util.assert("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const o=a.shape[0],l=a.shape[1],u=a.shape[2],c=a.shape[3],d=l*s,h=u*s,p=c/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*d*h*p);let g=0;for(let y=0;y<o;++y)for(let e=0;e<d;++e){const t=Math.floor(e/s),n=e%s;for(let e=0;e<h;++e){const r=Math.floor(e/s),a=(n*s+e%s)*p;for(let e=0;e<p;++e){const n=e+a+c*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,d,h,p],a.dtype,m)}};function DRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;C_e([a,s],"depthwiseConv2DNative");const c=hve.util.computeStrides(a.shape),d=hve.util.computeStrides(s.shape);let h=l;null==h&&(h=[1,1]),hve.util.assert(hve.backend_util.eitherStridesOrDilationsAreOne(i,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`));const p=hve.backend_util.computeConv2DInfo(a.shape,s.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new hve.TensorBuffer(p.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(s.dataId).values,T=k.values;for(let N=0;N<p.batchSize;++N){const e=N*c[0],t=N*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],a=n*p.strideHeight-x;for(let t=0;t<f;++t){const n=a+t*g;if(n<0||n>=p.inHeight)continue;const s=t*d[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=p.inWidth)continue;const a=s+e*d[1],o=i+r*p.inChannels;let l=t,u=a;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<w;++e)T[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const MRe={kernelName:hve.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:DRe};const FRe={kernelName:hve.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;C_e([a,s],"depthwiseConv2dNativeBackpropFilter");const d=hve.backend_util.computeConv2DInfo(a.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new hve.TensorBuffer(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,x=n.data.get(a.dataId).values,w=new hve.TensorBuffer(a.shape,a.dtype,x),k=n.data.get(s.dataId).values,S=new hve.TensorBuffer(s.shape,s.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((b-I)/h)),t=Math.min(d.outHeight,(d.inHeight+b-I)/h);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((y-n)/p)),a=Math.min(d.outWidth,(d.inWidth+y-n)/p);for(let s=0;s<d.outChannels;++s){const i=Math.trunc(s/v),o=s%v;let l=0;for(let u=0;u<d.batchSize;++u)for(let o=e;o<t;++o){const e=I+o*h-b;for(let t=r;t<a;++t){const r=n+t*p-y;l+=w.get(u,e,r,i)*S.get(u,o,t,s)}}g.set(l,I,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const ORe={kernelName:hve.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;C_e([a,s],"depthwiseConv2DNativeBackpropInput");const d=hve.util.computeStrides(a.shape),h=hve.util.computeStrides(s.shape),p=hve.backend_util.computeConv2DInfo(c,s.shape,i,o,l,u,!0),f=new hve.TensorBuffer(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(a.dataId).values,[x,w,k]=d,S=n.data.get(s.dataId).values,[I,T,N]=h,{batchSize:C,filterHeight:A,filterWidth:E,inChannels:_,inHeight:$,inWidth:R,outChannels:D,outHeight:M,outWidth:F,strideHeight:O,strideWidth:P}=p,L=A-1-p.padInfo.top,z=E-1-p.padInfo.left,B=D/_;for(let V=0;V<C;++V)for(let e=0;e<_;++e)for(let t=0;t<$;++t){const n=t-L,r=Math.max(0,Math.ceil(n/O)),a=Math.min(M,(A+n)/O);for(let s=0;s<R;++s){const i=s-z,o=Math.max(0,Math.ceil(i/P)),l=Math.min(F,(E+i)/P);let u=0;for(let t=r;t<a;++t){const r=t*O-n;for(let n=o;n<l;++n){const a=x*V+w*t+k*n,s=I*(A-1-r)+T*(E-1-(n*P-i))+N*e;for(let t=0;t<B;++t){u+=v[a+(e*B+t)]*S[s+t]}}}m[g*V+y*t+b*s+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const PRe={kernelName:hve.Diag,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=hve.util.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=(0,hve.buffer)([a,a],r.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*a+u]=s[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},LRe={kernelName:hve.Dilation2D,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=n,c=u.data.get(a.dataId).values,d=a.shape.length,h=u.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:T,dilationWidth:N,outShape:C}=hve.backend_util.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l),A=hve.util.sizeFromShape(C),E=C.length,_=hve.util.getArrayFromDType(a.dtype,A);for(let $=0;$<f;++$)for(let e=0;e<b;++e){const t=e*w-x.top;for(let n=0;n<v;++n){const r=n*k-x.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*T;if(n>=0&&n<m)for(let t=0;t<I;++t){const l=r+t*N;if(l>=0&&l<g){const r=hve.util.locToIndex([$,n,l,i],d,hve.util.computeStrides(a.shape)),u=hve.util.locToIndex([e,t,i],p,hve.util.computeStrides(s.shape)),f=c[r]+h[u];f>o&&(o=f)}}}_[hve.util.locToIndex([$,e,n,i],E,hve.util.computeStrides(C))]=o}}}return{dataId:u.write(hve.util.toTypedArray(_,a.dtype),C,a.dtype),shape:C,dtype:a.dtype}}},zRe={kernelName:hve.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=hve.util.toNestedArray(a.shape,c.data.get(a.dataId).values),h=hve.util.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:T,outShape:N}=hve.backend_util.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u);hve.util.assert(i.rank===N.length,(()=>`Error in ${hve.Dilation2DBackpropFilter}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));const C=hve.util.toNestedArray(N,c.data.get(i.dataId).values),A=hve.util.makeZerosNestedTypedArray(s.shape,s.dtype);for(let E=0;E<p;++E)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*T;if(l>=0&&l<m){const r=d[E][n][l][a]+h[e][t][a];r>s&&(s=r,i=e,o=t)}}}A[i][o][a]+=C[E][e][n][a]}}}return{dataId:c.write(hve.util.toTypedArray(A,a.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},BRe={kernelName:hve.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,filter:s,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=hve.util.toNestedArray(a.shape,c.data.get(a.dataId).values),h=hve.util.toNestedArray(s.shape,c.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:T,outShape:N}=hve.backend_util.computeDilation2DInfo(a.shape,s.shape,o,l,"NHWC",u);hve.util.assert(i.rank===N.length,(()=>`Error in ${hve.Dilation2DBackpropInput}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));const C=hve.util.toNestedArray(N,c.data.get(i.dataId).values),A=hve.util.makeZerosNestedTypedArray(a.shape,a.dtype);for(let E=0;E<p;++E)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let a=0;a<g;++a){let s=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*T;if(l>=0&&l<m){const r=d[E][n][l][a]+h[e][t][a];r>s&&(s=r,i=n,o=l)}}}A[E][i][o][a]+=C[E][e][n][a]}}}return{dataId:c.write(hve.util.toTypedArray(A,a.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};const VRe={kernelName:hve.Draw,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:s,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null===l||void 0===l?void 0:l.alpha)||1,c=(null===o||void 0===o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=s.getContext(c,(null===o||void 0===o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);const[h,p]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,y=new Uint8ClampedArray(p*h*4);for(let v=0;v<h*p;++v){const e=[0,0,0,255*u];for(let n=0;n<f;n++){const t=m[v*f+n];if("float32"===a.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===a.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}s.width=p,s.height=h;const b=new ImageData(y,p,h);return d.putImageData(b,0,0),a}},WRe=z_e(((e,t)=>e*t)),URe=i$e(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),jRe=s$e(hve.Multiply,WRe,URe),GRe={kernelName:hve.Multiply,backendName:"cpu",kernelFunc:jRe};function HRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;let o;C_e(a,"sum"),o="bool"===a.dtype?r$e({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):F_e({inputs:{x:a},backend:n});const l=o.shape.length,u=hve.util.parseAxisParam(s,o.shape),c=hve.backend_util.getAxesPermutation(u,l);let d=u,h=o;null!=c&&(h=I$e({inputs:{x:o},backend:n,attrs:{perm:c}}),d=hve.backend_util.getInnerMostAxes(d.length,l)),hve.backend_util.assertAxesAreInnerMostDims("sum",d,h.shape.length);const[p,f]=hve.backend_util.computeOutAndReduceShapes(h.shape,d);let m=J_e(n,p,hve.backend_util.upcastType(h.dtype,"int32"));const g=hve.util.sizeFromShape(f),y=n.data.get(m.dataId).values,b=n.data.get(h.dataId).values;for(let v=0;v<y.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(i){const e=m;m=d$e({inputs:{x:m},backend:n,attrs:{shape:hve.backend_util.expandShapeToKeepDim(m.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(h),m}const qRe={kernelName:hve.Sum,backendName:"cpu",kernelFunc:HRe};const KRe={kernelName:hve.Einsum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=hve.backend_util.decodeEinsumEquation(a,s.length);hve.backend_util.checkEinsumDimSizes(i.length,l,s);const{path:u,steps:c}=hve.backend_util.getEinsumComputePath(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=hve.backend_util.getEinsumPermutation(p,l[e]);let a;hve.backend_util.isIdentityPermutation(t)?a=s[e]:(a=I$e({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);hve.util.arraysEqual(a.shape,i)||(a=d$e({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===h?h=a:(h=jRe({inputs:{a:a,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=HRe({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};const YRe={kernelName:hve.EluGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:a}=t;C_e([r,a],"eluGrad");const s=new Float32Array(hve.util.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const e=i[l];s[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",s)}},XRe=z_e(((e,t)=>e===t?1:0)),QRe=s$e(hve.Equal,XRe,null,"bool"),ZRe={kernelName:hve.Equal,backendName:"cpu",kernelFunc:QRe},JRe=hve.backend_util.ERF_P,eDe=hve.backend_util.ERF_A1,tDe=hve.backend_util.ERF_A2,nDe=hve.backend_util.ERF_A3,rDe=hve.backend_util.ERF_A4,aDe=hve.backend_util.ERF_A5,sDe=$_e(hve.Erf,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+JRe*n);return t*(1-((((aDe*r+rDe)*r+nDe)*r+tDe)*r+eDe)*r*Math.exp(-n*n))})),iDe={kernelName:hve.Erf,backendName:"cpu",kernelFunc:sDe},oDe=__e((e=>Math.exp(e))),lDe=R_e(hve.Exp,oDe,"float32"),uDe={kernelName:hve.Exp,backendName:"cpu",kernelFunc:lDe};function cDe(e){const{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(hve.util.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),d$e({inputs:{x:a},backend:n,attrs:{shape:o}})}const dDe={kernelName:hve.ExpandDims,backendName:"cpu",kernelFunc:cDe},hDe=__e((e=>Math.expm1(e))),pDe=R_e(hve.Expm1,hDe),fDe={kernelName:hve.Expm1,backendName:"cpu",kernelFunc:pDe},mDe=z_e(((e,t)=>e/t)),gDe=s$e(hve.RealDiv,mDe),yDe={kernelName:hve.RealDiv,backendName:"cpu",kernelFunc:gDe},bDe=z_e(((e,t)=>e-t)),vDe=i$e(((e,t,n,r)=>({real:e-n,imag:t-r}))),xDe=s$e(hve.Sub,bDe,vDe),wDe={kernelName:hve.Sub,backendName:"cpu",kernelFunc:xDe};function kDe(e,t,n){const r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],c=hve.util.sizeFromShape(u),d=hve.util.getTypedArrayFromDType("float32",c),h=hve.util.getTypedArrayFromDType("float32",c);for(let g=0;g<a;g++){const e=X$e({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=X$e({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=Q_e({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=SDe(a,t,n),c=hve.backend_util.mergeRealAndImagArrays(i,u);for(let t=0;t<s;t++){const e=hve.backend_util.getComplexWithIndex(c,t);d[g*s+t]=e.real,h[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=Q_e({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function SDe(e,t,n){const r=hve.util.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(0===((o=r)&o-1)){const a=IDe(s,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),s=n.makeTensorInfo([],"float32",hve.util.createScalarValue(r,"float32")),i=F_e({inputs:{x:s},backend:n}),l=yDe.kernelFunc({inputs:{a:e,b:s},backend:n}),u=yDe.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return a}{const e=function(e,t,n){const r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){const o=hve.backend_util.exponent(a*r,t,n),l=hve.backend_util.getComplexWithIndex(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),hve.backend_util.assignToTypedArray(r,s,i,a)}return r}(hve.backend_util.mergeRealAndImagArrays(s,i),r,t);return hve.backend_util.splitRealAndImagArrays(e)}var o}function IDe(e,t,n,r,a){if(1===n)return{real:e,imag:t};const s=hve.backend_util.mergeRealAndImagArrays(e,t),i=n/2,o=hve.backend_util.complexWithEvenIndex(s),l=o.real,u=o.imag,c=[l.length],d=a.makeTensorInfo(c,"float32",l),h=a.makeTensorInfo(c,"float32",u),p=Q_e({inputs:{real:d,imag:h},backend:a}),f=hve.backend_util.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),v=a.makeTensorInfo(y,"float32",g),x=Q_e({inputs:{real:b,imag:v},backend:a}),w=IDe(l,u,i,r,a),k=w.real,S=w.imag,I=[k.length],T=a.makeTensorInfo(I,"float32",k),N=a.makeTensorInfo(I,"float32",S),C=Q_e({inputs:{real:T,imag:N},backend:a}),A=IDe(m,g,i,r,a),E=A.real,_=A.imag,$=[E.length],R=a.makeTensorInfo($,"float32",E),D=a.makeTensorInfo($,"float32",_),M=Q_e({inputs:{real:R,imag:D},backend:a}),F=hve.backend_util.exponents(n,r),O=[F.real.length],P=a.makeTensorInfo(O,"float32",F.real),L=a.makeTensorInfo(O,"float32",F.imag),z=Q_e({inputs:{real:P,imag:L},backend:a}),B=jRe({inputs:{a:z,b:M},backend:a}),V=u$e({inputs:{a:C,b:B},backend:a}),W=xDe({inputs:{a:C,b:B},backend:a}),U=e$e({inputs:{input:V},backend:a}),j=e$e({inputs:{input:W},backend:a}),G=pRe({inputs:{input:V},backend:a}),H=pRe({inputs:{input:W},backend:a}),q=mRe({inputs:[U,j],backend:a,attrs:{axis:0}}),K=mRe({inputs:[G,H],backend:a,attrs:{axis:0}}),Y=a.data.get(q.dataId).values,X=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:Y,imag:X}}const TDe={kernelName:hve.FFT,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=hve.util.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=d$e({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=kDe(i,!1,n),l=d$e({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function NDe(e){const{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||hve.util.inferDtype(a),o=hve.util.getArrayFromDType(i,hve.util.sizeFromShape(r));return function(e,t){e.fill(t)}(o,a),t.makeTensorInfo(r,i,o)}const CDe={kernelName:hve.Fill,backendName:"cpu",kernelFunc:NDe};const ADe={kernelName:hve.FlipLeftRight,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,s=r,i=hve.util.getTypedArrayFromDType(a.dtype,hve.util.sizeFromShape(a.shape)),[o,l,u,c]=a.shape,d=s.data.get(a.dataId).values;for(let h=0;h<o;h++){const e=h*u*l*c;for(let t=0;t<l;t++){const n=t*(u*c);for(let t=0;t<u;t++){const r=t*c;for(let a=0;a<c;a++){const s=Math.round(u-t-1),o=e+n+r+a;let l=d[o];if(s>=0&&s<u){l=d[e+n+s*c+a]}i[o]=l}}}}return{dataId:s.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},EDe=__e((e=>Math.floor(e))),_De=R_e(hve.Floor,EDe),$De={kernelName:hve.Floor,backendName:"cpu",kernelFunc:_De},RDe=z_e(((e,t)=>Math.floor(e/t))),DDe=s$e(hve.FloorDiv,RDe,null,"int32"),MDe={kernelName:hve.FloorDiv,backendName:"cpu",kernelFunc:DDe};const FDe={kernelName:hve.FusedConv2D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=yRe({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=d$e({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=u$e({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=u$e({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=d$e({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=X_e(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=X_e(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};const ODe={kernelName:hve.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=DRe({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;m=u$e({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=X_e(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function PDe(e,t,n,r,a,s,i,o,l){const u=(0,hve.buffer)([r,s],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<a;t++){const s=e[c*a+t];r+=s*i[t],n.push(s)}if(r<0||r>=l/s)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<s;e++)u.values[c*s+e]=t.get(...t.indexToLoc(r*s+e))}return u}const LDe={kernelName:hve.GatherNd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=hve.util.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,u,c,d]=hve.backend_util.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const h=PDe(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,o,c,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,h.values)}};function zDe(e,t,n){const r=(0,hve.buffer)(n,e.dtype);for(let a=0;a<r.size;++a){const n=r.indexToLoc(a).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];const l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}const BDe={kernelName:hve.GatherV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;C_e([a,s],"gatherV2");const l=hve.util.parseAxisParam(i,a.shape)[0],u=n.data.get(s.dataId).values,c=a.shape[l];for(let v=0;v<u.length;++v){const e=u[v];hve.util.assert(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let d=o;null==o&&(d=0);const h=hve.util.sizeFromShape(s.shape),p=hve.backend_util.segment_util.collectGatherOpShapeInfo(a,s,l,d),f=d$e({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=d$e({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=zDe(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},VDe=z_e(((e,t)=>e>t?1:0)),WDe=s$e(hve.Greater,VDe,null,"bool"),UDe={kernelName:hve.Greater,backendName:"cpu",kernelFunc:WDe},jDe=z_e(((e,t)=>e>=t?1:0)),GDe=s$e(hve.GreaterEqual,jDe,null,"bool"),HDe={kernelName:hve.GreaterEqual,backendName:"cpu",kernelFunc:GDe};const qDe={kernelName:hve.IFFT,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,a=hve.util.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=d$e({inputs:{x:r},backend:n,attrs:{shape:[a/s,s]}}),o=kDe(i,!0,n),l=d$e({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},KDe=$_e(hve.IsFinite,(e=>Number.isFinite(e)?1:0),"bool"),YDe={kernelName:hve.IsFinite,backendName:"cpu",kernelFunc:KDe},XDe=$_e(hve.IsInf,(e=>Math.abs(e)===1/0?1:0),"bool"),QDe={kernelName:hve.IsInf,backendName:"cpu",kernelFunc:XDe},ZDe=$_e(hve.IsNan,(e=>Number.isNaN(e)?1:0),"bool"),JDe={kernelName:hve.IsNan,backendName:"cpu",kernelFunc:ZDe},eMe=z_e(((e,t)=>e<t?1:0)),tMe=s$e(hve.Less,eMe,null,"bool"),nMe={kernelName:hve.Less,backendName:"cpu",kernelFunc:tMe},rMe=z_e(((e,t)=>e<=t?1:0)),aMe=s$e(hve.LessEqual,rMe,null,"bool"),sMe={kernelName:hve.LessEqual,backendName:"cpu",kernelFunc:aMe};function iMe(e,t,n){const r=(t-e)/(n-1),a=hve.util.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}const oMe={kernelName:hve.LinSpace,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=iMe(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},lMe=__e((e=>Math.log(e))),uMe=R_e(hve.Log,lMe),cMe={kernelName:hve.Log,backendName:"cpu",kernelFunc:uMe},dMe=$_e(hve.Log1p,(e=>Math.log1p(e))),hMe={kernelName:hve.Log1p,backendName:"cpu",kernelFunc:dMe},pMe=z_e(((e,t)=>e&&t)),fMe=s$e(hve.LogicalAnd,pMe,null,"bool"),mMe={kernelName:hve.LogicalAnd,backendName:"cpu",kernelFunc:fMe},gMe=$_e(hve.LogicalNot,(e=>e?0:1),"bool"),yMe={kernelName:hve.LogicalNot,backendName:"cpu",kernelFunc:gMe},bMe=z_e(((e,t)=>e||t)),vMe=s$e(hve.LogicalOr,bMe,null,"bool"),xMe={kernelName:hve.LogicalOr,backendName:"cpu",kernelFunc:vMe};const wMe={kernelName:hve.LRN,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;C_e(a,"LRN");const u=a.shape[3],c=u-1,d=n.data.get(a.dataId).values,h=hve.util.sizeFromShape(a.shape),p=new Float32Array(h);function f(e){const t=e%u;let n=e-t+Math.max(0,t-s);const r=e-t+Math.min(t+s,c);let a=0;for(;n<=r;n++){const e=d[n];a+=e*e}return a}for(let m=0;m<h;m++){const e=f(m),t=d[m]*Math.pow(i+o*e,-l);p[m]=t}return n.makeTensorInfo(a.shape,a.dtype,p)}};const kMe={kernelName:hve.LRNGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;C_e(i,"LRNGrad");const d=hve.util.sizeFromShape(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const e=b%h,t=b-e+Math.max(0,e-o),n=b-e+Math.min(h,e+o+1);let r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*c*f[a]*m[b]/r;b===a&&(e+=Math.pow(r,-c)),e*=p[b],g[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,g)}};function SMe(e,t,n,r){const a=hve.util.getTypedArrayFromDType(r,hve.util.sizeFromShape(n));for(let s=0;s<a.length;++s){const n=s*t;let r=e[n];for(let a=0;a<t;++a){const t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[s]=r}return a}function IMe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n;let l=a.shape;const u=l.length,c=hve.util.parseAxisParam(s,l);let d=c;const h=hve.backend_util.getAxesPermutation(d,u);let p=o.data.get(a.dataId).values;if(null!=h){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];p=S$e(p,l,a.dtype,h,e),d=hve.backend_util.getInnerMostAxes(d.length,u),l=e}C_e(a,"max"),hve.backend_util.assertAxesAreInnerMostDims("max",d,u);const[f,m]=hve.backend_util.computeOutAndReduceShapes(l,d),g=SMe(p,hve.util.sizeFromShape(m),f,a.dtype),y=o.write(g,f,a.dtype);let b=f;if(i){b=hve.backend_util.expandShapeToKeepDim(f,c)}return{dataId:y,shape:b,dtype:a.dtype}}const TMe={kernelName:hve.Max,backendName:"cpu",kernelFunc:IMe},NMe=z_e(((e,t)=>Math.max(e,t))),CMe=s$e(hve.Maximum,NMe),AMe={kernelName:hve.Maximum,backendName:"cpu",kernelFunc:CMe};const EMe={kernelName:hve.MaxPool,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;C_e(a,"maxPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;hve.util.assert(hve.backend_util.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hve.backend_util.computePool2DInfo(a.shape,s,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&hve.util.arraysEqual(u.inShape,u.outShape))c=F_e({inputs:{x:a},backend:n});else{const e=n.data.get(a.dataId).values,t=hve.util.computeStrides(a.shape),r=V$e(e,a.shape,a.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,a.dtype,r.values)}return c}};const _Me={kernelName:hve.MaxPool3D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;C_e(a,"maxPool3d");const c=hve.backend_util.computePool3DInfo(a.shape,s,i,1,o,l,u),d=U$e(n.data.get(a.dataId).values,a.shape,a.dtype,hve.util.computeStrides(a.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};const $Me={kernelName:hve.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;C_e([a,s],"maxPool3DGrad");const c=hve.backend_util.computePool3DInfo(s.shape,i,o,1,l,u),d=function(e,t){const n=(0,hve.buffer)(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let v=b;for(;v<0;)v+=i;const x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){const u=r*a-p;let h=u;for(;h<0;)h+=o;const w=Math.min(t.inHeight,c+u);for(let a=0;a<t.outWidth;++a){const p=a*s-f;let k=p;for(;k<0;)k+=l;const S=Math.min(t.inWidth,d+p);let I=Number.NEGATIVE_INFINITY,T=-1;for(let t=v;t<x;t+=i){const n=t-b;for(let r=h;r<w;r+=o){const a=r-u;for(let s=k;s<S;s+=l){const i=s-p,o=e.get(m,t,r,s,g);o>=I&&(I=o,T=n*c*d+a*c+i)}}}n.set(T,m,y,r,a,g)}}}return n}(n.bufferSync(s),c),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=x-1-c.padInfo.left,S=v-1-c.padInfo.top,I=(0,hve.buffer)(s.shape,"float32"),T=n.bufferSync(a);for(let N=0;N<c.batchSize;++N)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const a=t-w,s=n-S,i=r-k;let o=0;for(let t=0;t<b;t+=m){const n=(a+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){const a=(s+r)/p;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let s=0;s<x;s+=y){const l=(i+s)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=b*v*x-1-d.get(N,n,a,l,e)===t*v*x+r*x+s?1:0;if(0===u)continue;o+=T.get(N,n,a,l,e)*u}}}I.set(o,N,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const RMe={kernelName:hve.MaxPoolGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;C_e([s,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=hve.backend_util.computePool2DInfo(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=(0,hve.buffer)(h.outShape,o.dtype,W$e(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,k=v-1-h.padInfo.top,S=(0,hve.buffer)(o.shape,"float32"),I=n.data.get(a.dataId).values,T=(0,hve.buffer)(a.shape,"float32",I);for(let N=0;N<h.batchSize;++N)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){const r=t-k,a=n-w;let s=0;for(let t=0;t<v;t+=y){const n=(r+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){const i=(a+r)/g;if(i<0||i>=h.outWidth||Math.floor(i)!==i)continue;const o=v*x-1-f.get(N,n,i,e)===t*x+r?1:0;if(0===o)continue;s+=T.get(N,n,i,e)*o}}S.set(s,N,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const DMe={kernelName:hve.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;C_e(a,"MaxPoolWithArgmax");const c=u.data.get(a.dataId).values,d=hve.backend_util.computePool2DInfo(a.shape,s,i,[1,1],o),[h,p]=function(e,t,n,r,a){const s=V$e(e,0,n,hve.util.computeStrides(t),a,"max"),i=W$e(e,t,n,a,!0,r);return[s.values,i.values]}(c,a.shape,a.dtype,l,d),f=u.write(h,d.outShape,a.dtype),m=u.write(p,d.outShape,a.dtype);return[{dataId:f,shape:d.outShape,dtype:a.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};const MMe={kernelName:hve.Mean,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=hve.util.parseAxisParam(s,a.shape),l=hve.backend_util.computeOutAndReduceShapes(a.shape,o)[1],u=hve.util.sizeFromShape(l),c=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(d);const h=r$e({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});c.push(h);const p=gDe({inputs:{a:h,b:d},backend:n});c.push(p);const f=HRe({inputs:{x:p},backend:n,attrs:{axis:s,keepDims:i}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};const FMe={kernelName:hve.Min,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;C_e(a,"min");const o=hve.util.parseAxisParam(s,a.shape);let l=o;const u=hve.backend_util.getAxesPermutation(l,a.shape.length);let c=a;null!=u&&(c=I$e({inputs:{x:a},backend:n,attrs:{perm:u}}),l=hve.backend_util.getInnerMostAxes(l.length,a.shape.length)),hve.backend_util.assertAxesAreInnerMostDims("min",l,c.shape.length);const[d,h]=hve.backend_util.computeOutAndReduceShapes(c.shape,l),p=hve.util.sizeFromShape(h),f=hve.util.makeZerosTypedArray(hve.util.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=d$e({inputs:{x:g},backend:n,attrs:{shape:hve.backend_util.expandShapeToKeepDim(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},OMe=z_e(((e,t)=>Math.min(e,t))),PMe=s$e(hve.Minimum,OMe),LMe={kernelName:hve.Minimum,backendName:"cpu",kernelFunc:PMe};const zMe={kernelName:hve.MirrorPad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;C_e(a,"mirrorPad");const o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),c="reflect"===i?0:1,d=n.data.get(a.dataId).values,h=a.shape.length,p=hve.util.computeStrides(a.shape),f=hve.util.sizeFromShape(o),m=o.length,g=hve.util.computeStrides(o),y=hve.util.getTypedArrayFromDType(a.dtype,f);for(let b=0;b<f;b++){let e=hve.util.indexToLoc(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));const t=hve.util.locToIndex(e,h,p);y[b]=d[t]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}},BMe=z_e(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),VMe=s$e(hve.Mod,BMe),WMe={kernelName:hve.Mod,backendName:"cpu",kernelFunc:VMe};function UMe(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length;let o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=hve.util.parseAxisParam([o],a.shape),u=IMe({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=hve.backend_util.expandShapeToKeepDim(u.shape,l),d=d$e({inputs:{x:u},backend:n,attrs:{shape:c}}),h=xDe({inputs:{a:a,b:d},backend:n}),p=lDe({inputs:{x:h},backend:n}),f=HRe({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=d$e({inputs:{x:f},backend:n,attrs:{shape:c}}),g=gDe({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const jMe={kernelName:hve.Softmax,backendName:"cpu",kernelFunc:UMe};const GMe={kernelName:hve.Multinomial,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;C_e(a,"multinomial");const l=o?a:UMe({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,s],p=hve.util.makeZerosTypedArray(hve.util.sizeFromShape(h),"int32");for(let f=0;f<u;++f){const e=f*c,t=new Float32Array(c-1);t[0]=d[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+d[e+a];const n=XEe.alea(i.toString()),r=f*s;for(let a=0;a<s;++a){const e=n();p[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+a]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}};function HMe(e,t,n){const r=hve.util.createScalarValue(-1,n);return WRe([],t,r,e,n)}const qMe={kernelName:hve.Neg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;C_e(r,"neg");const a=n.data.get(r.dataId).values,[s,i]=HMe(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}},KMe=hve.kernel_impls.nonMaxSuppressionV3Impl;const YMe={kernelName:hve.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;C_e(a,"NonMaxSuppression");const u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:d}=KMe(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},XMe=hve.kernel_impls.nonMaxSuppressionV4Impl;const QMe={kernelName:hve.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;C_e(a,"NonMaxSuppressionPadded");const c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:h,validOutputs:p}=XMe(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},ZMe=hve.kernel_impls.nonMaxSuppressionV5Impl;const JMe={kernelName:hve.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;C_e(a,"NonMaxSuppressionWithScore");const c=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=ZMe(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},eFe=z_e(((e,t)=>e!==t?1:0)),tFe=s$e(hve.NotEqual,eFe,null,"bool"),nFe={kernelName:hve.NotEqual,backendName:"cpu",kernelFunc:tFe};const rFe={kernelName:hve.OneHot,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r;C_e(a,"oneHot");const u=hve.util.sizeFromShape(a.shape),c=new Float32Array(u*i);c.fill(l);const d=n.data.get(a.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...a.shape,i],s,c)}};function aFe(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=e$e({inputs:{input:r},backend:n}),t=aFe({inputs:{x:e},backend:n}),a=pRe({inputs:{input:r},backend:n}),s=aFe({inputs:{x:a},backend:n}),i=Q_e({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return NDe({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const sFe={kernelName:hve.ZerosLike,backendName:"cpu",kernelFunc:aFe};const iFe={kernelName:hve.OnesLike,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const t=e$e({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=pRe({inputs:{input:a},backend:r}),i=aFe({inputs:{x:s},backend:r}),o=Q_e({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return NDe({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function oFe(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return cDe({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,i=t[0].dtype;t.forEach((e=>{hve.util.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),hve.util.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=mRe({inputs:t.map((e=>{const t=cDe({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const lFe={kernelName:hve.Pack,backendName:"cpu",kernelFunc:oFe};const uFe={kernelName:hve.PadV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;C_e(a,"pad");const o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,c=hve.util.sizeFromShape(a.shape),d=a.shape.length,h=hve.util.computeStrides(a.shape),p=hve.util.sizeFromShape(o),f=o.length,m=hve.util.computeStrides(o),g=hve.util.getTypedArrayFromDType(a.dtype,p);0!==i&&g.fill(i);for(let y=0;y<c;y++){const e=hve.util.indexToLoc(y,d,h).map(((e,t)=>e+l[t]));g[hve.util.locToIndex(e,f,m)]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}},cFe=z_e(((e,t)=>Math.pow(e,t))),dFe=s$e(hve.Pow,cFe),hFe={kernelName:hve.Pow,backendName:"cpu",kernelFunc:dFe};function pFe(e,t,n,r){const[a,s]=hve.backend_util.computeOutAndReduceShapes(e,r),i=(0,hve.upcastType)(t,"int32"),o=hve.util.makeZerosTypedArray(hve.util.sizeFromShape(a),i),l=hve.util.sizeFromShape(s);for(let u=0;u<o.length;++u){const e=u*l;let t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:a,outDtype:i}}const fFe={kernelName:hve.Prod,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;C_e(a,"prod");const o=a.shape.length,l=hve.util.parseAxisParam(s,a.shape),u=hve.backend_util.getAxesPermutation(l,o);let c=l,d=a;const h=[];null!=u&&(d=I$e({inputs:{x:a},backend:n,attrs:{perm:u}}),h.push(d),c=hve.backend_util.getInnerMostAxes(c.length,o));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=pFe(d.shape,d.dtype,p,c);let y=m;return i&&(y=hve.backend_util.expandShapeToKeepDim(m,l)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function mFe(e,t,n,r){const a=[];let s=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){const a=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-a[r];for(let n=r;n<i;++n)o[s].push(a[n+1]+t)}r=a[r],i=a[i]}i!==r&&(a.push([r,i]),s+=i-r)}return{outSplits:o,valueSlices:a,numValues:s}}function gFe(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function yFe(e,t,n,r,a){const s=t.slice();s[0]=a;const i=hve.util.getArrayFromDType(n,hve.util.sizeFromShape(s)),o=e.length;return function(e,t,n,r,a,s){const i=gFe(t,2)[1],o=gFe(s,2)[1];let l=0;for(const u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)a[l*o+n]=e[t*i+n];++l}}(e,t,r,0===o?0:o/t[0],i,s),[i,s]}function bFe(e,t,n,r,a,s,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const a=hve.util.indexToLoc(r,t.length,hve.util.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(s,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:c,numValues:d}=mFe(s,i,e,l),h=function(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n].length,a=hve.util.getArrayFromDType("int32",r);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(u),p=yFe(n,r,a,c,d);return[h,p[0],p[1]]}const vFe={kernelName:hve.RaggedGather,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.data.get(e.dataId).values)),u=a.map((e=>e.shape)),c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=bFe(l,u,c,s.shape,s.dtype,d,i.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}},xFe=2147483647;function wFe(e,t,n,r,a,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===a.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(a[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=hve.util.getArrayFromDType("int32",d+1);h[0]=0;for(let g=0;g<d;++g){const t=o?e[0]:e[g],n=l?r[0]:r[g],a=u?s[0]:s[g];if(0===a)throw new Error("Requires delta != 0");let i;if(a>0&&n<t||a<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/a)),i>xFe)throw new Error(`Requires ((limit - start) / delta) <= ${xFe}`);h[g+1]=h[g]+i}const p=h[d],f=hve.util.getArrayFromDType(n,p);let m=0;for(let g=0;g<d;++g){const t=h[g+1]-h[g];let n=o?e[0]:e[g];const r=u?s[0]:s[g];for(let e=0;e<t;++e)f[m++]=n,n+=r}return[h,f]}const kFe={kernelName:hve.RaggedRange,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=wFe(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var SFe=hve.backend_util.RowPartitionType;class IFe{constructor(e,t,n,r,a,s,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=s,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=hve.backend_util.getRowPartitionTypesHelper(u),this.raggedRank=hve.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===SFe.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===SFe.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case SFe.VALUE_ROWIDS:return IFe.getMaxWidthValueRowID(t);case SFe.ROW_SPLITS:return IFe.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${SFe[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let s=1;s<t;++s){const t=e[s];t!==r&&(r=t,a=Math.max(s-n,a),n=s)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return NFe(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;hve.backend_util.validateDefaultValueShape(n,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=hve.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let s=1;s<=this.raggedRank;++s)a[s]<0&&(a[s]=this.getMaxWidth(s));return a}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),a=[];let s=0;for(let i=0;i<r;++i,s+=t)a.push(s);for(let i=r;i<e;++i)a.push(-1);return hve.util.assert(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){const a=e.length,s=[];for(let i=0;i<a-1;++i){const a=e[i+1]-e[i];let o=Math.min(r,a),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)s.push(l),l+=n;for(let e=0;e<a-o;++e)s.push(-1)}if(a>0&&s.length!==e[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){const a=e.length,s=[];if(0===a)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];s.push(l);for(let u=1;u<a;++u){const a=e[u];if(a===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}s.push(l)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){const a=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case SFe.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case SFe.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${SFe[s]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case SFe.FIRST_DIM_SIZE:return e[0];case SFe.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case SFe.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${SFe[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];const r=NFe(t,!1),a=hve.util.getArrayFromDType(this.valuesDType,hve.util.sizeFromShape(r));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){s=this.calculateOutputIndex(e-1,s,n[e],t[e])}this.setOutput(this.raggedRank,s,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;const a=this.values,s=n;let i=r.slice();i=i.slice(e+1);const o=hve.util.sizeFromShape(i),l=t.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const e=this.defaultValueShape;(0,hve.tidy)((()=>{const t=(0,hve.reshape)(u,e),n=(0,hve.broadcastTo)(t,i);u=n.dataSync()}))}let c=0,d=0,h=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==h){if(d<h){const e=a.subarray(c*o);TFe(s.subarray(d*o),e,(h-d)*o)}if(p>=l){const t=n.length;e=Math.floor(t/o)}if(e>h)if(1===this.defaultValue.length)s.subarray(h*o,e*o).fill(this.defaultValue[0]),h=e;else for(;e>h;){TFe(s.slice(h*o),u,o),++h}e<0?(c=p+1,d=h):(c=p,d=h,h=d+1)}else++h}}}function TFe(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function NFe(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function CFe(e,t,n,r,a,s,i,o,l,u){return new IFe(e,t,n,r,a,s,i,o,l,u).compute()}const AFe={kernelName:hve.RaggedTensorToTensor,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,d=n.data.get(i.dataId).values,h=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=CFe(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}};function EFe(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return hve.util.makeZerosTypedArray(0,r);const a=Math.abs(Math.ceil((t-e)/n)),s=hve.util.makeZerosTypedArray(a,r);t<e&&1===n&&(n=-1),s[0]=e;for(let i=1;i<s.length;i++)s[i]=s[i-1]+n;return s}const _Fe={kernelName:hve.Range,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=EFe(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}},$Fe=$_e(hve.Reciprocal,(e=>1/e)),RFe={kernelName:hve.Reciprocal,backendName:"cpu",kernelFunc:$Fe};const DFe={kernelName:hve.ResizeBilinear,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;C_e(a,"resizeBilinear");const l=hve.util.computeStrides(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(hve.util.sizeFromShape([d,u,c,f])),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<d;k++)for(let e=0;e<u;e++){let t;t=i?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(h-1,Math.ceil(t)),s=k*l[0]+n*l[1],o=k*l[0]+a*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(p-1,Math.ceil(t)),c=s+n*l[2],d=o+n*l[2],h=s+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[d+e],s=t+(m[h+e]-t)*a,i=s+(n+(m[y+e]-n)*a-s)*r;g[v++]=i}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}};const MFe={kernelName:hve.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;C_e([s,a],"resizeBilinearGrad");const o=hve.util.computeStrides(a.shape),[l,u,c,d]=a.shape,[,h,p]=s.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(s.dataId).values;let x=0;for(let w=0;w<l;w++){const e=w*o[0];for(let t=0;t<h;t++){const n=t*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=e+r*o[1],i=e+a*o[1],l=n-r,h=1-l;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),a=t-n,u=1-a,p=s+n*o[2],m=s+r*o[2],g=i+n*o[2],y=i+r*o[2],w=h*u,k=h*a,S=l*u,I=l*a;for(let e=0;e<d;e++){const t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*I}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}};const FFe={kernelName:hve.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;C_e(a,"resizeNearestNeighbor");const l=hve.util.computeStrides(a.shape),[u,c]=o,[d,h,p,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(d*u*c*f),y=[s&&u>1?h-1:h,s&&c>1?p-1:p],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let k=0;k<d;k++){const e=k*l[0];for(let t=0;t<u;t++){const n=i?v*(t+.5):v*t;let r=Math.min(h-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const a=e+r*l[1];for(let e=0;e<c;e++){const t=i?x*(e+.5):x*e;let n=Math.min(p-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=a+n*l[2];for(let e=0;e<f;e++){const t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([d,u,c,f],a.dtype,g)}};const OFe={kernelName:hve.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;C_e([s,a],"resizeNearestNeighborGrad");const o=hve.util.computeStrides(a.shape),l=hve.util.computeStrides(s.shape),[u,c,d,h]=a.shape,[,p,f]=s.shape,m=new Float32Array(u*c*d*h),g=n.data.get(s.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let T=0;T<u;T++){const e=T*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*w),a=Math.floor(r-S/2);for(let s=0;s<d;s++){const r=n+s*o[2],u=Math.floor(s*k),y=Math.floor(u-I/2);for(let n=0;n<h;n++){let o=0;for(let r=0;r<S;r++){const u=r+a;if(u<0||u>=p)continue;const h=e+u*l[1],m=u*v;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){const t=e+y;if(t<0||t>=f)continue;const r=h+t*l[2],a=t*x;s===Math.min(d-1,i?Math.round(a):Math.floor(a))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}};const PFe={kernelName:hve.Reverse,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;C_e(a,"reverse");const i=a.shape.length,o=hve.util.parseAxisParam(s,a.shape);if(0===i)return F_e({inputs:{x:a},backend:n});const l=new hve.TensorBuffer(a.shape,a.dtype),u=n.bufferSync(a);for(let c=0;c<l.size;c++){const e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},LFe={kernelName:hve.RotateWithOffset,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=hve.util.getTypedArrayFromDType(a.dtype,hve.util.sizeFromShape(a.shape)),[c,d,h,p]=a.shape,[f,m]=hve.backend_util.getImageCenter(o,d,h),g=Math.sin(s),y=Math.cos(s),b=l.data.get(a.dataId).values;for(let v=0;v<c;v++){const e=v*h*d*p;for(let t=0;t<d;t++){const n=t*(h*p);for(let r=0;r<h;r++){const a=r*p;for(let s=0;s<p;s++){const o=[c,t,r,s],l=o[2],v=o[1];let x=(l-f)*y-(v-m)*g,w=(l-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=i;if("number"!==typeof i&&(k=3===s?255:i[s]),x>=0&&x<h&&w>=0&&w<d){k=b[e+w*(h*p)+x*p+s]}u[e+n+a+s]=k}}}}return{dataId:l.write(u,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},zFe=$_e(hve.Round,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),BFe={kernelName:hve.Round,backendName:"cpu",kernelFunc:zFe},VFe=__e((e=>1/Math.sqrt(e))),WFe=R_e(hve.Rsqrt,VFe),UFe={kernelName:hve.Rsqrt,backendName:"cpu",kernelFunc:WFe};function jFe(e,t,n,r,a,s,i,o,l,u){const c=[r/a,a],d=e.values,h=t.values;if(0===r)return(0,hve.buffer)(n,t.dtype);const p=l instanceof hve.TensorBuffer?l:(0,hve.buffer)(c,t.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<s;f++){const e=[];let s=0;for(let t=0;t<i;t++){const n=d[f*i+t];e.push(n),s+=n*o[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?p.values[s*a+n]+=h[f*a+n]:p.values[s*a+n]=0===t.rank?h[0]:h[f*a+n]}return p}const GFe={kernelName:hve.ScatterNd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=hve.backend_util.calculateShapes(s,a,i),h=jFe(n.bufferSync(a),n.bufferSync(s),i,d,u,l,o,c,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function HFe(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function qFe(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}const KFe={kernelName:hve.SearchSorted,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=function(e,t,n,r,a,s){const i=hve.util.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?HFe(n,t[e+l]):qFe(n,t[e+l])}return i}(n.data.get(a.dataId).values,n.data.get(s.dataId).values,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",o)}};const YFe={kernelName:hve.Select,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;C_e([r,a,s],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=(0,hve.upcastType)(a.dtype,s.dtype),d=hve.util.makeZerosTypedArray(hve.util.sizeFromShape(a.shape),c);let h=0;const p=0===i||i>1||1===a.shape.length?1:hve.util.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(a.shape,c,d)}},XFe=hve.backend_util.SELU_SCALEALPHA,QFe=hve.backend_util.SELU_SCALE,ZFe=$_e(hve.Selu,(e=>e>=0?QFe*e:XFe*(Math.exp(e)-1))),JFe={kernelName:hve.Selu,backendName:"cpu",kernelFunc:ZFe},eOe=$_e(hve.Sign,(e=>e<0?-1:e>0?1:0)),tOe={kernelName:hve.Sign,backendName:"cpu",kernelFunc:eOe},nOe=$_e(hve.Sin,(e=>Math.sin(e))),rOe={kernelName:hve.Sin,backendName:"cpu",kernelFunc:nOe},aOe=$_e(hve.Sinh,(e=>Math.sinh(e))),sOe={kernelName:hve.Sinh,backendName:"cpu",kernelFunc:aOe},iOe=Math.log(1.1920928955078125e-7)+2,oOe=$_e(hve.Softplus,(e=>{const t=e>-iOe,n=e<iOe,r=Math.exp(e);let a;return a=n?r:t?e:Math.log(1+r),a})),lOe={kernelName:hve.Softplus,backendName:"cpu",kernelFunc:oOe};const uOe={kernelName:hve.SpaceToBatchND,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;C_e([a],"spaceToBatchND");const o=hve.util.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);const u=uFe.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=hve.backend_util.getReshaped(u.shape,s,o,!1),d=hve.backend_util.getPermuted(c.length,s.length,!1),h=hve.backend_util.getReshapedPermuted(u.shape,s,o,!1),p=d$e({inputs:{x:u},backend:n,attrs:{shape:c}}),f=I$e({inputs:{x:p},backend:n,attrs:{perm:d}}),m=d$e({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function cOe(e,t,n,r,a,s,i){const o=t[0],l=s[0],u=new Array(l),c=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(hve.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[hve.util.getArrayFromDType(n,0),[0,d],hve.util.getArrayFromDType(a,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<o;++g){const t=e[g*d];if(t<0)throw new Error(hve.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,t));if(t>=l)throw new Error(hve.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,t,l));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<l;++g){const e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,d],n,u,c]}{const t=f[l-1],s=hve.util.getArrayFromDType(n,t*d),h=hve.util.getArrayFromDType(a,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){const t=e[n*d],a=p[t],i=(0===t?0:f[t-1])+a;p[t]++;for(let r=0;r<d;++r)s[i*d+r]=e[n*d+r];h[i]=r[n],c[n]=i}for(let e=0;e<l;++e){if(0===p[e]){const t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;h[t]=i}}return[s,[t,d],h,u,c]}}const dOe={kernelName:hve.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=cOe(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function hOe(e,t,n,r,a){const s=hve.util.sizeFromShape(r),i=t[0],o=a.length,l=[];let u=1,c=-1;for(let m=0;m<o;++m){const e=a[m];if(-1===e){if(-1!==c)throw new Error(hve.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,m));c=m,l.push(1)}else{if(e<0)throw new Error(hve.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(m,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error(hve.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(s/u);if(u*e!==s)throw new Error(hve.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=e}if(hve.util.sizeFromShape(l)!==s)throw new Error(hve.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(r,l));const d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=hve.util.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],l]}const pOe={kernelName:hve.SparseReshape,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,d]=hOe(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};function fOe(e,t,n,r,a){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?a[o-1]+1:0;if(c<0)throw new Error(hve.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const d=t.slice();d[0]=c;const h=d.reduce(((e,t)=>e*t),1),p=hve.util.getArrayFromDType(n,h);if(0===o)return c>0&&p.fill(i),[p,d];if(c<=0)throw new Error(hve.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let t=0;if(m<o){if(t=a[m],y===t){++m;continue}if(y>=t)throw new Error(hve.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=c)throw new Error(hve.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,c));y>g&&p.fill(i,g*u,y*u);for(let n=f;n<m;++n){const t=r[n];if(t<0||t>=l[0])throw new Error(hve.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,r[n],l[0]));for(let n=0;n<u;n++)p[y*u+n]+=e[t*u+n]}if(s)for(let e=0;e<u;e++)p[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<c&&p.fill(i,g*u,c*u),[p,d]}const mOe={kernelName:hve.SparseSegmentMean,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=fOe(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const gOe={kernelName:hve.SparseSegmentSum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=fOe(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const yOe={kernelName:hve.SparseToDense,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=hve.backend_util.calculateShapes(s,a,o),p=!1,f=n.bufferSync(a);let m;switch(s.dtype){case"bool":m=jFe(f,n.bufferSync(s),o,h,c,u,l,d,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":m=jFe(f,n.bufferSync(s),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"int32":m=jFe(f,n.bufferSync(s),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"string":m=jFe(f,n.bufferSync(s),o,h,c,u,l,d,hve.util.decodeString(n.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${s.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}};const bOe={kernelName:hve.SplitV,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=hve.util.parseAxisParam(i,a.shape)[0],l=hve.backend_util.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{const t=[...c];t[o]=e;const r=X$e({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},vOe=__e((e=>Math.sqrt(e))),xOe=$_e(hve.Sqrt,(e=>Math.sqrt(e))),wOe={kernelName:hve.Sqrt,backendName:"cpu",kernelFunc:xOe},kOe={kernelName:hve.Square,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:r}=t,a=n;C_e(r,"square");const s=a.data.get(r.dataId).values,i=new Float32Array(s.length);for(let o=0;o<s.length;++o){const e=s[o];i[o]=e*e}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},SOe=z_e(((e,t)=>{const n=e-t;return n*n})),IOe=s$e(hve.SquaredDifference,SOe),TOe={kernelName:hve.SquaredDifference,backendName:"cpu",kernelFunc:IOe},NOe=__e(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),COe=R_e(hve.StaticRegexReplace,NOe),AOe={kernelName:hve.StaticRegexReplace,backendName:"cpu",kernelFunc:COe},EOe=$_e(hve.Step,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),_Oe={kernelName:hve.Step,backendName:"cpu",kernelFunc:EOe};function $Oe(e,t,n,r){const a=(0,hve.buffer)(e,t.dtype);for(let s=0;s<a.size;s++){const e=a.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}const ROe={kernelName:hve.StridedSlice,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;C_e(a,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=hve.slice_util.sliceInfo(a.shape,s,i,o,l,u,c,d,h);let w;if(m)w=d$e({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){hve.util.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=hve.slice_util.computeOutShape(b,v,x),t=X$e({inputs:{x:a},backend:n,attrs:{begin:b,size:e}});w=d$e({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=$Oe(p,n.bufferSync(a),x,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class DOe{constructor(e,t,n,r,a,s){this.separator=hve.util.encodeString(e),this.nGramWidths=t,this.leftPad=hve.util.encodeString(n),this.rightPad=hve.util.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){const o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),c=s-(l+u),d=t+(l>0?0:i-o);let h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length;h+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(h);const p=n[r+i];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const a=r-1,s=hve.util.getArrayFromDType("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[e,s]}s[0]=0;for(let o=1;o<=a;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[o]=s[o-1]+n}const i=new Array(s[a]);for(let o=0;o<a;++o){const n=t[o];let r=s[o];if(this.nGramWidths.forEach((a=>{const s=t[o+1]-t[o],l=this.getNumNGrams(s,a);this.createNGrams(e,n,i,r,l,a),r+=l})),this.preserveShort&&r===s[o]){const a=t[o+1]-t[o];if(0===a)continue;const s=a+2*this.padWidth,l=1;this.createNGrams(e,n,i,r,l,s)}}return[i,s]}}function MOe(e,t,n,r,a,s,i,o){return new DOe(n,r,a,s,i,o).compute(e,t)}const FOe={kernelName:hve.StringNGrams,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=MOe(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};function OOe(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const a=t[0];let s=e.indexOf(a);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||r.push(t),s=(e=e.subarray(s+1)).indexOf(a)}return void(n&&0===e.length||r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(a,s);n&&0===t.length||r.push(t),a=s+1}}function POe(e,t,n){const r=e.length,a=[];let s=0,i=0;const o=new Array(r);for(let h=0;h<r;++h){const r=a.length;OOe(e[h],t,n,a);const l=a.length-r;o[h]=l,s+=l,i=Math.max(i,l)}const l=hve.util.getArrayFromDType("int32",2*s),u=new Array(s),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let e=0;e<o[h];++e)l[2*d]=h,l[2*d+1]=e,u[d]=a[d],++d;return[l,u,c]}const LOe={kernelName:hve.StringSplit,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=POe(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function zOe(e,t){const n=hve.util.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=hve.util.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}const BOe={kernelName:hve.StringToHashBucketFast,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=zOe(n.data.get(s.dataId).values,a);return n.makeTensorInfo(s.shape,"int32",i)}},VOe=$_e(hve.Tan,(e=>Math.tan(e))),WOe={kernelName:hve.Tan,backendName:"cpu",kernelFunc:VOe},UOe=$_e(hve.Tanh,(e=>Math.tanh(e))),jOe={kernelName:hve.Tanh,backendName:"cpu",kernelFunc:UOe};const GOe={kernelName:hve.TensorScatterUpdate,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=hve.backend_util.calculateShapes(s,a,r.shape),d=n.bufferSync(a),h=n.bufferSync(s),p=n.bufferSync(r),f=jFe(d,h,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function HOe(e,t){const n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];const r=(0,hve.buffer)(n,e.dtype);for(let a=0;a<r.values.length;++a){const t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const s=e.locToIndex(n);r.values[a]=e.values[s]}return r}const qOe={kernelName:hve.Tile,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;C_e(a,"tile");const i=HOe(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},KOe=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function YOe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){const a=r-n+1,s=t-n+1,i=Math.log(a),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(a-o)/a)*Math.sign(s-a/2);YOe(e,t,Math.max(n,Math.floor(t-s*o/a+l)),Math.min(r,Math.floor(t+(a-s)*o/a+l)))}const a=e[t];let s=n,i=r;for(hve.util.swap(e,n,t),KOe(e[r],a)>0&&hve.util.swap(e,n,r);s<i;){for(hve.util.swap(e,s,i),s++,i--;KOe(e[s],a)<0;)s+=1;for(;KOe(e[i],a)>0;)i-=1}0===KOe(e[n],a)?hve.util.swap(e,n,i):(i+=1,hve.util.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function XOe(e,t,n,r,a){const s=t[t.length-1],[i,o]=[e.length/s,s],l=hve.util.getTypedArrayFromDType(n,i*r),u=hve.util.getTypedArrayFromDType("int32",i*r);for(let d=0;d<i;d++){const t=d*o,n=e.subarray(t,t+o);let s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(YOe(s,r),s=s.slice(0,r)),a&&s.sort(KOe);const i=d*r,c=l.subarray(i,i+r),h=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=s[e].value,h[e]=s[e].index}const c=t.slice();return c[c.length-1]=r,[(0,hve.buffer)(c,n,l),(0,hve.buffer)(c,"int32",u)]}const QOe={kernelName:hve.TopK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;C_e(a,"topk");const o=n.data.get(a.dataId).values,[l,u]=XOe(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};const ZOe={kernelName:hve.Transform,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=[c,f,m,p],y=hve.util.computeStrides(a.shape),b=y[0],v=y[1],x=y[2],w=hve.util.computeStrides(g),k=w[0],S=w[1],I=w[2],T=hve.util.getTypedArrayFromDType(a.dtype,hve.util.sizeFromShape(g));T.fill(l);const N=r.data.get(a.dataId).values,C=r.data.get(s.dataId).values;for(let A=0;A<c;++A){const e=1===s.shape[0]?C:C.subarray(8*A,8*A+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let a;const s=e[6]*n+e[7]*t+1;if(0===s)continue;const u=(e[0]*n+e[1]*t+e[2])/s,c=(e[3]*n+e[4]*t+e[5])/s,p=JOe(u,h,o),f=JOe(c,d,o);switch(i){case"nearest":a=tPe(N,d,h,b,v,x,A,f,p,r,l);break;case"bilinear":a=nPe(N,d,h,b,v,x,A,f,p,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}T[A*k+t*S+n*I+r]=a}return r.makeTensorInfo(g,a.dtype,T)}return{dataId:r.write(T,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function JOe(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return hve.util.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return hve.util.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return hve.util.clamp(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function ePe(e,t,n,r,a,s,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*a+l*s+u]:c}function tPe(e,t,n,r,a,s,i,o,l,u,c){return ePe(e,t,n,r,a,s,i,Math.round(o),Math.round(l),u,c)}function nPe(e,t,n,r,a,s,i,o,l,u,c){const d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1;return(p-o)*((f-l)*ePe(e,t,n,r,a,s,i,d,h,u,c)+(l-h)*ePe(e,t,n,r,a,s,i,d,f,u,c))+(o-d)*((f-l)*ePe(e,t,n,r,a,s,i,p,h,u,c)+(l-h)*ePe(e,t,n,r,a,s,i,p,f,u,c))}function rPe(e,t,n,r){const a=hve.util.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];const i=new Map,o=new Int32Array(n[a]),l=new hve.TensorBuffer(s,r,e),u=[],c=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(l.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,u.push(f)}}const d=s.slice();d[1]=i.size;const h=new hve.TensorBuffer(d,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)h.set(l.get(n,e,r),n,t,r)}));const p=n.slice();return p[a]=d[1],{outputValues:h.values,outputShape:p,indices:o}}const aPe={kernelName:hve.Unique,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;C_e(s,"unique");const i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=rPe(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const sPe={kernelName:hve.Unpack,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const i=a.shape.length,o=a.shape[s],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==s&&(l[u++]=a.shape[p]);const c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;const h=new Array(o);for(let p=0;p<h.length;p++){c[s]=p;const e=X$e({inputs:{x:a},backend:n,attrs:{begin:c,size:d}});h[p]=d$e({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return h}};const iPe={kernelName:hve.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;C_e(a,"unsortedSegmentSum");const o=[],l=[],u=a.shape.length-s.shape.length;let c=s;for(let h=0;h<u;++h){const e=cDe({inputs:{input:c},backend:n,attrs:{dim:h+1}});c=e,l.push(e)}for(let h=0;h<i;++h){const e=hve.util.createScalarValue(h,"int32"),t=n.makeTensorInfo([],"int32",e),r=QRe({inputs:{a:t,b:c},backend:n}),s=r$e({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=jRe({inputs:{a:s,b:a},backend:n}),u=HRe({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(s),l.push(i),l.push(u)}const d=oFe({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},oPe=[m$e,y$e,v$e,w$e,c$e,k$e,N$e,C$e,A$e,E$e,$$e,D$e,F$e,L$e,B$e,j$e,G$e,H$e,q$e,f$e,K$e,Z$e,tRe,aRe,sRe,a$e,lRe,cRe,Z_e,dRe,gRe,bRe,vRe,xRe,wRe,kRe,SRe,TRe,CRe,ARe,ERe,_Re,$Re,RRe,MRe,FRe,ORe,PRe,LRe,zRe,BRe,VRe,KRe,M_e,YRe,ZRe,iDe,uDe,dDe,fDe,TDe,CDe,ADe,$De,MDe,FDe,ODe,LDe,BDe,UDe,HDe,O_e,qDe,fRe,YDe,QDe,JDe,L_e,nMe,sMe,oMe,cMe,hMe,mMe,yMe,xMe,wMe,kMe,TMe,AMe,EMe,_Me,$Me,RMe,DMe,MMe,FMe,LMe,zMe,WMe,GMe,GRe,qMe,YMe,QMe,JMe,nFe,rFe,iFe,lFe,uFe,hFe,W_e,fFe,vFe,kFe,AFe,_Fe,t$e,yDe,RFe,j_e,H_e,h$e,DFe,MFe,FFe,OFe,PFe,LFe,BFe,UFe,GFe,KFe,YFe,JFe,Y_e,tOe,rOe,sOe,Q$e,jMe,lOe,uOe,dOe,pOe,mOe,gOe,yOe,bOe,wOe,kOe,TOe,AOe,_Oe,ROe,FOe,LOe,BOe,wDe,qRe,WOe,jOe,GOe,qOe,QOe,ZOe,T$e,aPe,sPe,iPe,sFe];for(const n of oPe)(0,hve.registerKernel)(n);const lPe={},uPe={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function cPe(e,t){if(!(e in lPe)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if((0,hve.env)().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete lPe[e]}),!1),(0,hve.env)().getBool("SOFTWARE_WEBGL_ENABLED")&&(uPe.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",uPe)||n.getContext("experimental-webgl",uPe);return n.getContext("webgl2",uPe)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;lPe[e]=n}const n=lPe[e];return null==n||n.isContextLost()?(delete lPe[e],cPe(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),lPe[e])}var dPe,hPe,pPe;function fPe(e,t){return[t,e]}function mPe(e){const t=hve.util.sizeFromShape(e),n=Math.ceil(t/4);return hve.util.sizeToSquarishShape(n)}function gPe(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function yPe(e,t){const n=e;let r,a,s,i,o,l,u,c,d,h;return 2===(0,hve.env)().getNumber("WEBGL_VERSION")?(r=n.R32F,a=n.R16F,s=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,a=e.RGBA,s=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function bPe(e,t){const n=t();return(0,hve.env)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(dPe||(dPe={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(hPe||(hPe={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(pPe||(pPe={}));function vPe(e){return!!((0,hve.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function xPe(e,t){return EPe(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const wPe=/ERROR: [0-9]+:([0-9]+):/g;function kPe(e,t){const n=wPe.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map(((e,t)=>hve.util.rightPad((t+1).toString(),s)+e));let o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${hve.util.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function SPe(e,t){if(bPe(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function IPe(e,t,n,r,a,s,i){const o=e.getAttribLocation(t,n);return-1!==o&&(bPe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),bPe(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i))),bPe(e,(()=>e.enableVertexAttribArray(o))),!0)}function TPe(e,t,n,r){bPe(e,(()=>function(e,t,n){_Pe(e,n),bPe(e,(()=>e.activeTexture(e.TEXTURE0+n))),bPe(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),bPe(e,(()=>e.uniform1i(n,r)))}function NPe(e,t,n){bPe(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),bPe(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function CPe(e,t){bPe(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),bPe(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function APe(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function EPe(e,t,n){const r=bPe(e,(()=>t()));if(null==r)throw new Error(n);return r}function _Pe(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function $Pe(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return hve.util.sizeFromShape(e.slice(0,e.length-t))}function RPe(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function DPe(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[$Pe(e),...RPe(e)]),t}function MPe(e){return e%2===0}function FPe(e,t){if(e=e.slice(-2),t=t.slice(-2),hve.util.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(MPe(n)&&MPe(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&MPe(e[0])&&MPe(t[0])}let OPe,PPe;function LPe(e,t){return null!=e.getExtension(t)}function zPe(e){try{if(null!=cPe(e))return!0}catch(KR){return console.log("Error when getting WebGL context: ",KR),!1}return!1}function BPe(e){if(0===e)return!1;const t=cPe(e);if(1!==e){if(LPe(t,"EXT_color_buffer_float"))return VPe(t);const e="EXT_color_buffer_half_float";if(LPe(t,e)){const n=t.getExtension(e);return function(e,t){const n=yPe(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const a=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}(t,n)}return!1}if(!LPe(t,"OES_texture_float"))return!1;if(!LPe(t,"WEBGL_color_buffer_float"))return!1;return VPe(t)}function VPe(e){const t=yPe(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function WPe(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&hve.util.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const UPe=(0,hve.env)();function jPe(){let e,t,n,r,a,s,i,o,l,u;return 2===(0,hve.env)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o=(0,hve.env)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function GPe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=hve.util.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${t}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function HPe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=hve.util.computeStrides(t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / outShapeStrides[${a}]`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function qPe(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`${`int ${e[a]} = ${n} / ${r[a]}`}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}function KPe(e){const t=hve.util.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}UPe.registerFlag("HAS_WEBGL",(()=>UPe.getNumber("WEBGL_VERSION")>0)),UPe.registerFlag("WEBGL_VERSION",(()=>zPe(2)?2:zPe(1)?1:0)),UPe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),UPe.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===UPe.get("WEBGL_VERSION"))),UPe.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),UPe.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),UPe.registerFlag("WEBGL_PACK",(()=>UPe.getBool("HAS_WEBGL"))),UPe.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>UPe.getBool("WEBGL_PACK"))),UPe.registerFlag("WEBGL_PACK_CLIP",(()=>UPe.getBool("WEBGL_PACK"))),UPe.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>UPe.getBool("WEBGL_PACK"))),UPe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>UPe.getBool("WEBGL_PACK"))),UPe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>UPe.getBool("WEBGL_PACK"))),UPe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>UPe.getBool("WEBGL_PACK"))),UPe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>UPe.getBool("WEBGL_PACK"))),UPe.registerFlag("WEBGL_PACK_REDUCE",(()=>UPe.getBool("WEBGL_PACK"))),UPe.registerFlag("WEBGL_LAZILY_UNPACK",(()=>UPe.getBool("WEBGL_PACK"))),UPe.registerFlag("WEBGL_CONV_IM2COL",(()=>UPe.getBool("WEBGL_PACK"))),UPe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>UPe.getBool("WEBGL_PACK"))),UPe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==OPe){const t=cPe(e);OPe=t.getParameter(t.MAX_TEXTURE_SIZE)}return OPe}(UPe.getNumber("WEBGL_VERSION")))),UPe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==PPe){const t=cPe(e);PPe=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,PPe)}(UPe.getNumber("WEBGL_VERSION")))),UPe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=UPe.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=cPe(e);return t=LPe(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:LPe(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),UPe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>UPe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!hve.device_util.isMobile())),UPe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=cPe(e);if(1===e){if(!LPe(t,"OES_texture_float"))return!1}else if(!LPe(t,"EXT_color_buffer_float"))return!1;return VPe(t)}(UPe.getNumber("WEBGL_VERSION")))),UPe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!UPe.getBool("WEBGL_FORCE_F16_TEXTURES")&&UPe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),UPe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>BPe(UPe.getNumber("WEBGL_VERSION")))),UPe.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=UPe.getNumber("WEBGL_VERSION"))&&null!=cPe(e).fenceSync;var e})),UPe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>UPe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),UPe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),UPe.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>hve.device_util.isMobile()?1:-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),UPe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),UPe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),UPe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),UPe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),UPe.registerFlag("WEBGL_EXP_CONV",(()=>!1)),UPe.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>UPe.getBool("IS_TEST"))),UPe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),UPe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),UPe.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),UPe.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const YPe="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:XPe}=hve.backend_util;function QPe(e,t,n){const r=[];if(e.forEach((e=>{const t=hve.util.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=lLe(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const a=r.join("\n"),s=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,a="";a+=n?JPe(e,r):ZPe(e,r);const s=e.shapeInfo.logicalShape,i=t.logicalShape;s.length<=i.length&&(a+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=XPe(e.shapeInfo.logicalShape,t.logicalShape),l=oLe(i),u=i-s;let c;const d=["x","y","z","w","u","v"];c=0===s?"":i<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${d[e+u]} = 0;`)).join("\n");let h="";h=i<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+u]}`)).join(", ");let p="return outputValue;";const f=1===hve.util.sizeFromShape(e.shapeInfo.logicalShape),m=hve.util.sizeFromShape(t.logicalShape),g=1===m;if(1!==s||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=s-2,t=s-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${a}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&hve.util.arraysEqual(i,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=oLe(l),c=XPe(e.shapeInfo.logicalShape,t.logicalShape),d=l-o;let h;const p=["x","y","z","w","u","v"];h=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+d]} = 0;`)).join("\n");let f="";f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+d]}`)).join(", ");return`\n    float ${a}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${f});\n    }\n  `}(e,t));return a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,o=jPe(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,d=function(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${eLe}\n    ${tLe}\n    ${nLe}\n  `;return t}(o);t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return aLe();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(hve.util.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const a=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2);let i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function(e,t,n){switch(e.length){case 0:return aLe();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(hve.util.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${HPe(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=GPe(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${HPe(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=GPe(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=GPe(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=GPe(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(d+=rLe);return[d,l,c,a,u,s,n.userCode].join("\n")}function ZPe(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=sLe(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${iLe(e)}\n      }\n    `;const a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=sLe(n);if(1===i)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===s)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&hve.util.arraysEqual(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=s[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=hve.util.squeezeShape(n),l=i;if(l.length<n.length){const n=["row","col"];return`\n      ${ZPe(uLe(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${cLe(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${iLe(e)}\n      }\n    `;const u=s[0],c=s[1],d=sLe(r);if(1===c)return t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===u)return t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=hve.util.squeezeShape(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${ZPe(uLe(e,u),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${cLe(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${iLe(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=sLe(r);if(t)return`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=hve.util.squeezeShape(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${ZPe(uLe(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${cLe(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${iLe(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===s&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=sLe(r);if(t)return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=hve.util.squeezeShape(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${ZPe(uLe(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${cLe(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${a})) +\n          depth3;\n        ${iLe(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=sLe(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=hve.util.squeezeShape(t);if(a.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${ZPe(uLe(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${cLe(t,s)});\n      }\n    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${iLe(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=sLe(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function JPe(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=jPe();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=jPe();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=jPe();if(null!=s&&hve.util.arraysEqual(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const r=[1,2],s=["b","row","col"];return`\n        ${JPe(uLe(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${cLe(s,r)});\n        }\n      `}const o=jPe();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=jPe();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;const s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(s[i-1]/2);let h=d*Math.ceil(s[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=s[i-m-1],f=`b${m} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const eLe="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",tLe="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",nLe="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",rLe="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function aLe(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function sLe(e){return`offset${e}`}function iLe(e){const t=e.name,n=hve.util.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function oLe(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function lLe(e,t,n){const{newShape:r,keptDims:a}=hve.util.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!hve.util.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function uLe(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function cLe(e,t){return t.map((t=>e[t])).join(", ")}function dLe(e,t,n,r){const a=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=QPe(a,i,t),l=function(e,t){const n=EPe(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(bPe(e,(()=>e.shaderSource(n,t))),bPe(e,(()=>e.compileShader(n))),(0,hve.env)().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw kPe(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),u=e.createProgram(l);return(0,hve.env)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},hLe(e,t,u)))}function hLe(e,t,n){const r=[],a=[];let s,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===(0,hve.env)().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const d of t.variableNames){const a={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${d}Shape`,c),a.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),r.push(a)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const d of t.customUniforms)a.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:a,infLoc:l,nanLoc:u,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function pLe(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,a=t[n],s=a.shape;if(!hve.util.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;const i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!hve.util.arraysEqual(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function fLe(e){return(0,hve.env)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class mLe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=dPe.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=jPe();this.outputShape=e,this.enableShapeUniforms=fLe(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?HPe(["r","c","d"],e):GPe(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class gLe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=dPe.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=jPe();this.outputShape=e,this.enableShapeUniforms=fLe(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?HPe(["r","c","d"],e):GPe(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class yLe{constructor(e){this.variableNames=["A"],this.outTexUsage=hPe.DOWNLOAD;const t=jPe();this.outputShape=e,this.userCode=`\n      ${YPe}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class bLe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=hPe.DOWNLOAD;const t=jPe();this.outputShape=e,this.userCode=`\n      ${YPe}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const vLe={R:0,G:1,B:2,A:3};class xLe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=jPe();this.outputShape=e,this.enableShapeUniforms=fLe(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let s="";for(let i=0;i<n.length;i++){const e=n[i];s+=`\n          if(offset == ${i}) {\n            result = values[${vLe[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":KPe(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${s}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class wLe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=jPe();this.outputShape=e,this.enableShapeUniforms=fLe(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){const a=2*s+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":KPe(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}}function kLe(e){const t=jPe();return function(e,t){const n=EPe(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(bPe(e,(()=>e.shaderSource(n,t))),bPe(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function SLe(e){return function(e,t){const n=EPe(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return bPe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),bPe(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function ILe(e){return function(e,t){const n=EPe(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return bPe(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),bPe(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function TLe(e,t,n,r,a,s){!function(e,t){const n=(0,hve.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return EPe(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return bPe(e,(()=>e.bindTexture(o,i))),bPe(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),bPe(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),bPe(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),bPe(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===(0,hve.env)().getNumber("WEBGL_VERSION")?bPe(e,(()=>e.texImage2D(o,0,r,t,n,0,a,s,null))):bPe(e,(()=>e.texStorage2D(o,1,r,t,n))),bPe(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function NLe(e){return e.internalFormatFloat}function CLe(e){return e.internalFormatHalfFloat}function ALe(e){return e.downloadTextureFormat}function ELe(e){return e.internalFormatPackedFloat}function _Le(e){return e.internalFormatPackedHalfFloat}function $Le(e,t,n,r,a,s,i,o){const l=e,u=new Float32Array(function(e,t){const[n,r]=gPe(e,t);return n*r*4}(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}class RLe{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=(0,hve.env)().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){lPe[e]=t}(t,e)):this.gl=cPe(t),e=this.gl,2===(0,hve.env)().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>bPe(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>bPe(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>bPe(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>bPe(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>bPe(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>bPe(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>bPe(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>bPe(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,hve.env)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=xPe(this.gl,e),LPe(this.gl,t))this.textureHalfFloatExtension=xPe(this.gl,t);else if((0,hve.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),LPe(this.gl,r))this.colorBufferHalfFloatExtension=xPe(this.gl,r);else if((0,hve.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",LPe(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!LPe(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=SLe(this.gl),this.indexBuffer=ILe(this.gl),this.framebuffer=function(e){return EPe(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=yPe(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,hve.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;bPe(e,(()=>e.finish())),bPe(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),bPe(e,(()=>e.deleteFramebuffer(this.framebuffer))),bPe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),bPe(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),bPe(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=fPe(t,n);return TLe(e,a,s,NLe(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=fPe(t,n);return TLe(e,a,s,CLe(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=fPe(t,n);return TLe(e,a,s,ALe(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){bPe(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===(0,hve.env)().getNumber("WEBGL_VERSION")?bPe(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):bPe(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===(0,hve.env)().getNumber("WEBGL_VERSION")?bPe(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):bPe(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),bPe(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,a,s){let i,o,l;bPe(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===(0,hve.env)().getNumber("WEBGL_VERSION")?bPe(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):bPe(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),bPe(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=gPe(t,n);return TLe(e,a,s,_Le(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[a,s]=gPe(t,n);return TLe(e,a,s,ELe(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(CPe(this.gl,this.framebuffer),this.outputTexture=null),bPe(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[a,s]=fPe(t,n),i=new Uint8Array(t*n*4);return bPe(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return $Le(this.gl,e,0,0,0,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();bPe(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const a=16*t*n;return bPe(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ))),bPe(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),bPe(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if((0,hve.env)().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else(0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,(0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return bPe(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=kLe(t));const n=function(e){return EPe(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);bPe(t,(()=>t.attachShader(n,this.vertexShader))),bPe(t,(()=>t.attachShader(n,e))),function(e,t){if(bPe(e,(()=>e.linkProgram(t))),!(0,hve.env)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&SPe(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;bPe(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){bPe(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),IPe(e,t,"clipSpacePos",n,3,20,0)&&IPe(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(bPe(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&SPe(this.gl,this.program),bPe(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return EPe(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),bPe(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),TPe(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,a]=gPe(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&SPe(this.gl,this.program),APe(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}bPe(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),bPe(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=xPe(this.gl,2===(0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===(0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await hve.util.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,(0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,(0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in(0,hve.env)().platform&&(n=(0,hve.env)().platform.setTimeoutCustom.bind((0,hve.env)().platform)),hve.util.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),NPe(this.gl,e,this.framebuffer),this.debug&&APe(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(NPe(this.gl,this.outputTexture,this.framebuffer),this.debug&&APe(this.gl)):CPe(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;NPe(r,e,this.framebuffer),this.debug&&APe(r),this.outputTexture=e,bPe(r,(()=>r.viewport(0,0,t,n))),bPe(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),bPe(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:DLe,XI:MLe,Nk:FLe,f6:OLe,ct:PLe,YG:LLe,hH:zLe,z3:BLe,sG:VLe,uM:WLe,vS:ULe,qB:jLe,GG:GLe,rq:HLe,lg:qLe,WR:KLe,cu:YLe,GE:XLe,px:QLe,jC:ZLe,He:JLe,hE:eze,BF:tze,Dk:nze,cl:rze,_B:aze,ub:sze,_f:ize,Ku:oze,qy:lze,Zy:uze,bu:cze,zv:dze,dH:hze,HS:pze,yH:fze,l3:mze,z9:gze,x6:yze,_m:bze,eW:vze,GK:xze,SP:wze,yr:kze,dl:Sze,Dw:Ize,xT:Tze,_X:Nze,wz:Cze}=e;function Aze(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function Eze(e,t){return 1===t?[e]:Aze(e,t)}class _ze{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=fLe(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Eze("rc",this.rank),t=oLe(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class $ze{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=fLe(this.outputShape.length);let n="";for(let s=0;s<4;s++){let e="thisRC = rc;";s%2===1&&(e+="thisRC.z += 1;"),s>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}var r,a;this.userCode=`\n      ${r=t,a=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${a?qPe(["r","c","d"],"inputShape"):GPe(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":KPe(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class Rze{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=Mze(t,n),a=Fze(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const s=Dze(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}let i;return r===pPe.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===pPe.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===pPe.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===pPe.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===pPe.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const a=Mze(n,r),s=Fze(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);const i=Dze(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=(0,hve.env)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[s],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Dze(e,t,n,r,a){const s=function(e,t){switch(e){case pPe.PACKED_2X2_FLOAT32:return ELe(t);case pPe.PACKED_2X2_FLOAT16:return _Le(t);case pPe.UNPACKED_FLOAT32:return NLe(t);case pPe.UNPACKED_FLOAT16:return CLe(t);case pPe.PACKED_4X1_UNSIGNED_BYTE:return ALe(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(a){const[t,n]=gPe(e[0],e[1]);i=t*n}else{const[t,n]=fPe(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,s);return i*o}function Mze(e,t){if(e===hPe.UPLOAD)return pPe.PACKED_2X2_FLOAT32;if(e===hPe.RENDER||null==e)return function(e){return(0,hve.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?pPe.PACKED_2X2_FLOAT32:pPe.UNPACKED_FLOAT32:e?pPe.PACKED_2X2_FLOAT16:pPe.UNPACKED_FLOAT16}(t);if(e===hPe.DOWNLOAD||e===hPe.PIXELS)return pPe.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Fze(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class Oze{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=fLe(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Pze="if (isnan(x)) return x;",Lze="return x;",zze="return abs(x);";const Bze="return (x >= 0.0) ? x : (exp(x) - 1.0);",Vze=Pze+"\n  return (x < 0.0) ? 0.0 : x;\n",Wze=Pze+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Uze="return x;",jze="return 1.0 / (1.0 + exp(-1.0 * x));",Gze="return x;",Hze="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",qze="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Kze="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Yze="return 1.0 / (1.0 + exp(-1.0 * x));";class Xze{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=fLe(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class Qze{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=fLe(this.outputShape.length);const t=e.length,n=Eze("rc",t),r=oLe(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const Zze=hve.kernel_impls.whereImpl,Jze={};const eBe=(0,hve.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class tBe extends hve.KernelBackend{nextDataId(){return tBe.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,hve.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof RLe)t=e;else{const n=cPe((0,hve.env)().getNumber("WEBGL_VERSION"),e);t=new RLe(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=cPe((0,hve.env)().getNumber("WEBGL_VERSION"));t=new RLe(e),this.binaryCache=((n=(0,hve.env)().getNumber("WEBGL_VERSION"))in Jze||(Jze[n]={}),Jze[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Rze(this.gpgpu),this.numMBBeforeWarning=null==(0,hve.env)().global.screen?1024:(0,hve.env)().global.screen.height*(0,hve.env)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new hve.DataStorage(this,(0,hve.engine)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,s){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,a]},o.texShape=[r,a];const l=DPe(t),u=new xLe(l,!1,s),c=this.runWebGLProgram(u,[i],n,[[r,a]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if(((0,hve.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,hve.env)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:hPe.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,a){if((0,hve.env)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:hPe.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new Xze(i,Uze):new Oze(i,Uze);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=hve.util.now()),"complex64"===r){const e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);c=hve.backend_util.mergeRealAndImagArrays(e,t)}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=hve.util.now()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=a){let t;t=o?new Xze(r,Uze):new Oze(r,Uze);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if((0,hve.env)().getBool("DEBUG")&&!(0,hve.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,hve.env)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==s&&(0,hve.env)().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...mPe(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),t=e[0],n=e[1];u=hve.backend_util.mergeRealAndImagArrays(t,n)}else if(null==c)u=this.getValuesFromTexture(e);else{const e=hve.util.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;bPe(e,(()=>e.deleteBuffer(c)))}const d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&(0,hve.engine)().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new Xze(a,Uze):new Oze(a,Uze);const r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=(0,hve.engine)().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>hve.util.decodeString(e)));return(0,hve.buffer)(e.shape,e.dtype,n)}catch(DP){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,hve.buffer)(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!vPe(n)){if((0,hve.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=hve.util.sizeFromShape(t);if((0,hve.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...mPe(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}const s=(0,hve.env)().getBool("WEBGL_PACK")&&!0===r,i=s?DPe(t):t,o=s?new bLe(i):new yLe(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return(0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const a=hve.util.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=hve.util.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if((0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(a);i.kernelMs=hve.util.sum(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:hve.util.now(),endMs:null}}endTimer(e){return(0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=hve.util.now(),e)}async getQueryTime(e){if((0,hve.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:eBe;return(0,hve.env)().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&hve.util.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){hve.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return Zze(e.shape,t)}packedUnaryOp(e,t,n){const r=new Xze(e.shape,t),a=this.compileAndRun(r,[e],n);return(0,hve.engine)().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=hze(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if((0,hve.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,zze,e.dtype);const t=new Oze(e.shape,zze),n=this.compileAndRun(t,[e]);return(0,hve.engine)().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&hve.util.isString(n[0])){const a=n.map((e=>hve.util.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return(0,hve.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new Qze(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new _ze(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[$Pe(e.shape),...RPe(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[$Pe(t),...RPe(t)],s=new $ze(a,n),i=[n],o=this.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){const e=hve.util.sizeFromShape(a),n=t[0]*t[1]*4;hve.util.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=DPe(a);let o;o=r?new gLe(i):new mLe(i);const l=[null!=t?t:mPe(i)];return{dtype:s,shape:a,dataId:this.runWebGLProgram(o,[{shape:i,dtype:s,dataId:e}],s,l,!0,t).dataId}}runWebGLProgram(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0;const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===dPe.DENSE){const t=null!=s?s:mPe(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===hve.util.sizeFromShape(i.shape))return o.values=hve.util.getTypedArrayFromDType(i.dtype,0),i;const l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&hve.util.sizeFromShape(t.shape)<=(0,hve.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!FPe(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},d=function(e,t,n){let r="";t.concat(n).forEach((t=>{const a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=lLe(e.packedInputs,t.shape,s);let u="",c="",d="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=hve.util.computeStrides(o);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const h=t.shape.length,p=2===o.length&&hve.util.arraysEqual(t.shape,s),f=1===hve.util.sizeFromShape(t.shape),m=hve.backend_util.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&hve.util.arraysEqual(s,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${h}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${d}_${y}_${a}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));const a=e.userCode;let s=e.constructor.name;return s+="_"+r+"_"+a+`${(0,hve.env)().getNumber("WEBGL_VERSION")}`,s}(e,u,c),h=this.getAndSaveBinary(d,(()=>dLe(this.gpgpu,e,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),(0,hve.env)().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(pLe(t.inShapeInfos,n),pLe([t.outShapeInfo],[r]));const s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===(0,hve.env)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const r=n[l],{uniform:a,offset:s,shape:i,texShape:o}=t.variablesLocations[l];if(i){const{uniformShape:n}=lLe(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=a)if(r.isUniform)if(hve.util.sizeFromShape(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=r.texData.slice&&null!=s&&e.gl.uniform1i(s,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,l)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=hve.util.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){const n=t.program.customUniforms[l],r=t.customUniformLocations[l],s=a[l];if("float"===n.type)e.gl.uniform1fv(r,s);else if("vec2"===n.type)e.gl.uniform2fv(r,s);else if("vec3"===n.type)e.gl.uniform3fv(r,s);else if("vec4"===n.type)e.gl.uniform4fv(r,s);else if("int"===n.type)e.gl.uniform1iv(r,s);else if("ivec2"===n.type)e.gl.uniform2iv(r,s);else if("ivec3"===n.type)e.gl.uniform3iv(r,s);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,s)}}e.executeProgram()}(this.gpgpu,h,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=(0,hve.env)().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=hve.util.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!(0,hve.env)().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!(0,hve.env)().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,hve.tidy)((()=>{if(!(0,hve.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,hve.env)().getBool("DEBUG");(0,hve.env)().set("DEBUG",!1);const t=this.abs((0,hve.scalar)(1e-8)).dataSync()[0];if((0,hve.env)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;const l=null!=this.activeTimers;let u;l&&(u=hve.util.now());let c=t.texShape;if(null==c&&(c=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=(0,hve.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=(0,hve.env)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&(0,hve.env)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?hve.util.nearestLargerEven(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=hve.util.squeezeShape(e);e=t.newShape}let a=hve.util.sizeFromShape(e),s=null;e.length<=1&&a<=n?s=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);const i=null!=s&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||i)if(t){const t=$Pe(e);let n=2,r=2;e.length&&([n,r]=RPe(e)),a=t*(n/2)*(r/2),s=hve.util.sizeToSquarishShape(a).map((e=>2*e))}else s=hve.util.sizeToSquarishShape(a);return s}(n,o),t.texShape=c),null!=a){const e=DPe(n);let s,i=c[1],d=c[0];const h=a instanceof Uint8Array||a instanceof Uint8ClampedArray;!o&&h||([i,d]=gPe(c[0],c[1])),s=o?new wLe(e,h):new xLe(e,h);const p=h?[d,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=h?hPe.PIXELS:hPe.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,a);const g=[[d,i]],y=!0,b=this.runWebGLProgram(s,[f],r,g,y),v=this.texData.get(b.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,(0,hve.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=hve.util.now()-u)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*hve.util.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await(0,hve.nextFrame)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw kPe(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=hLe(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:a,width:s,channels:i}=e,o=(0,hve.engine)().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=o.writeTexture(r,t,n,a,s,i);return(0,hve.engine)().makeTensorFromDataId(l,t,n,o)}}tBe.nextDataId=0;hve.device_util.isBrowser()&&(0,hve.registerBackend)("webgl",(()=>new tBe),2);const nBe="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class rBe{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=hve.backend_util.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=fLe(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const aBe="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class sBe{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=hve.backend_util.assertAndGetBroadcastShape(t,n);const a=this.outputShape.length;this.enableShapeUniforms=fLe(a);let s="";if(r)if(0===a||1===hve.util.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(s=`\n          ${oLe(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=Eze("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}}function iBe(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const oBe={kernelName:hve.Identity,backendName:"webgl",kernelFunc:iBe};function lBe(e){const{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=iBe({inputs:{x:r},backend:n}),l=iBe({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}const uBe={kernelName:hve.Complex,backendName:"webgl",kernelFunc:lBe},cBe="return (a < 0.) ? b * a : a;",dBe="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const hBe={kernelName:hve.LeakyRelu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",hve.util.createScalarValue(s,"float32")),o=(0,hve.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sBe(dBe,a.shape,i.shape):new rBe(cBe,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},pBe="return (a < 0.) ? b * a : a;",fBe="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const mBe={kernelName:hve.Prelu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=(0,hve.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sBe(fBe,r.shape,a.shape):new rBe(pBe,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}},gBe="if (isnan(x)) return x;";function yBe(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:a}=e;return e=>{let{inputs:s,backend:i}=e;const{x:o}=s,l=i,u=a||o.dtype;if(l.shouldExecuteOnCPU([o])&&null!=r){const e=l.texData.get(o.dataId),t=r(e.values,u);return l.makeTensorInfo(o.shape,u,t)}let c;return c=(0,hve.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new Xze(o.shape,n):new Oze(o.shape,t),l.runWebGLProgram(c,[o],u)}}function bBe(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:a=!1,cpuKernelImpl:s,dtype:i}=e;return e=>{let{inputs:o,backend:l}=e;const{a:u,b:c}=o,d=l;if(a&&"complex64"===u.dtype){const e=d.texData.get(u.dataId),n=d.texData.get(c.dataId),[r,a]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,a={dataId:n.dataId,dtype:n.dtype,shape:u.shape},s={dataId:r.dataId,dtype:r.dtype,shape:c.shape},i=new rBe(t,u.shape,c.shape);return d.runWebGLProgram(i,[a,s],(0,hve.upcastType)(n.dtype,r.dtype))})),s=lBe({inputs:{real:r,imag:a},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(a),s}const h=i||(0,hve.upcastType)(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=s){const e=d.texData.get(u.dataId).values,t=d.texData.get(c.dataId).values,n="string"===u.dtype?hve.backend_util.fromUint8ToStringArray(e):e,r="string"===u.dtype?hve.backend_util.fromUint8ToStringArray(t):t,[a,i]=s(u.shape,c.shape,n,r,h),o=d.makeTensorInfo(i,h);return d.texData.get(o.dataId).values=a,o}let p;return p=(0,hve.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new sBe(n,u.shape,c.shape,r):new rBe(t,u.shape,c.shape),d.runWebGLProgram(p,[u,c],h)}}function vBe(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?Gze:Lze;if("relu"===e)return t?qze:Vze;if("elu"===e)return t?Hze:Bze;if("relu6"===e)return t?Kze:Wze;if("prelu"===e)return t?fBe:pBe;if("leakyrelu"===e)return t?dBe:cBe;if("sigmoid"===e)return t?Yze:jze;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class xBe{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=fLe(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const wBe={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class kBe{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=hve.backend_util.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const SBe="return a * b;";function IBe(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=hve.backend_util.upcastType(r.dtype,a.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),s=new kBe(wBe.REAL,r.shape,a.shape),i=new kBe(wBe.IMAG,r.shape,a.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:a.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:a.shape}],l=n.runWebGLProgram(s,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=lBe({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,a])){const e=n.texData.get(r.dataId),t=n.texData.get(a.dataId),[i,o]=tze(r.shape,a.shape,e.values,t.values,s),l=n.makeTensorInfo(o,s);return n.texData.get(l.dataId).values=i,l}let i;return i=(0,hve.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sBe(SBe,r.shape,a.shape):new rBe(SBe,r.shape,a.shape),n.runWebGLProgram(i,[r,a],s)}const TBe={kernelName:hve.Multiply,backendName:"webgl",kernelFunc:IBe};function NBe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=hve.util.sizeFromShape(a.shape),l=hve.util.inferFromImplicitShape(s,o),u=hve.util.sizeFromShape(l);hve.util.assert(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=i.texData.get(a.dataId);return!c.isPacked||FPe(a.shape,l)||null!==c.texture&&FPe(c.shape,l)?(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){const r=[$Pe(e.shape),...RPe(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[$Pe(t),...RPe(t)],i=new $ze(s,r),o=[r],l=n.runWebGLProgram(i,[a],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(a,l,i)}const CBe={kernelName:hve.Reshape,backendName:"webgl",kernelFunc:NBe};class ABe{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${hve.util.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class EBe{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";a%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}}function _Be(e,t,n,r){const a=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=hve.backend_util.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let s=e;for(let i=0;i<a.length;i++){const{inSize:o,windowSize:l,outSize:u}=a[i];let c,d;c="mean"===n?0===i?new ABe({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new ABe({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new EBe({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=s,s=r.runWebGLProgram(c,[s],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return s}class $Be{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;const r=oLe(this.rank),a=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}class RBe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=oLe(this.rank),a=Aze("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];const i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function DBe(e,t,n){const r=(0,hve.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RBe(e.shape,t):new $Be(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function MBe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return function(e,t,n,r){const a=t,s=e.shape.length,i=hve.util.parseAxisParam(a,e.shape);let o=i;const l=hve.backend_util.getAxesPermutation(o,s),u=null!=l;let c=e;u&&(c=DBe(e,l,r),o=hve.backend_util.getInnerMostAxes(o.length,s)),hve.backend_util.assertAxesAreInnerMostDims("sum",o,s);const[d,h]=hve.backend_util.computeOutAndReduceShapes(c.shape,o);let p=d;n&&(p=hve.backend_util.expandShapeToKeepDim(d,i));const f=hve.util.sizeFromShape(h),m=NBe({inputs:{x:c},attrs:{shape:[hve.util.sizeFromShape(e.shape)/f,f]},backend:r}),g=_Be(m,(0,hve.sumOutType)(e.dtype),"sum",r),y=NBe({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),y}(a,s,i,n)}const FBe={kernelName:hve.Sum,backendName:"webgl",kernelFunc:MBe};function OBe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{perm:s}=r,i=n,o=a.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=a.shape[s[c]];let u;if(i.shouldExecuteOnCPU([a])){const e=i.texData.get(a.dataId).values,t=Nze(e,a.shape,a.dtype,s,l);u=i.makeTensorInfo(l,a.dtype);i.texData.get(u.dataId).values=t}else u=DBe(a,s,i);return u}const PBe={kernelName:hve.Transpose,backendName:"webgl",kernelFunc:OBe},LBe=1e3;function zBe(e){let{a:t,b:n,transposeA:r,transposeB:a,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e;const c=t.shape.length,d=n.shape.length,h=r?t.shape[c-2]:t.shape[c-1],p=a?n.shape[d-1]:n.shape[d-2],f=r?t.shape[c-1]:t.shape[c-2],m=a?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=hve.util.sizeFromShape(g),v=hve.util.sizeFromShape(y),x=hve.broadcast_util.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);hve.util.assert(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${a} must match.`));const w=r?[b,h,f]:[b,f,h],k=a?[v,m,p]:[v,p,m],S=NBe({inputs:{x:t},backend:s,attrs:{shape:w}}),I=NBe({inputs:{x:n},backend:s,attrs:{shape:k}}),T=[S,I],N=Math.max(b,v),C=r?S.shape[1]:S.shape[2],A=null!=i,E=null!=o,_="leakyrelu"===u,$=null!=u?vBe(u,!0):null;let R;if((1===f||1===m)&&C>LBe&&!1===(A||E||_||null!=$)){let e=S,t=I;r&&(e=OBe({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),T.push(e)),a&&(t=OBe({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),T.push(t));const n=1===m;let i=e;1!==m&&(i=NBe({inputs:{x:e},backend:s,attrs:{shape:[N,C,1]}}),T.push(i));const o=1===m?2:1;let l=t;n&&(l=NBe({inputs:{x:t},backend:s,attrs:{shape:[N,1,C]}}),T.push(l));const u=IBe({inputs:{a:i,b:l},backend:s});R=MBe({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),T.push(u)}else{const e=(0,hve.upcastType)(t.dtype,n.dtype),u=new xBe(w,k,[N,f,m],r,a,A,$,E,_),c=[S,I];if(null!=i&&c.push(i),E&&c.push(o),_){const e=s.makeTensorInfo([],"float32",hve.util.createScalarValue(l,"float32"));c.push(e),T.push(e)}R=s.runWebGLProgram(u,c,e)}const D=NBe({inputs:{x:R},backend:s,attrs:{shape:x}});T.push(R);for(const M of T)s.disposeIntermediateTensorInfo(M);return D}const BBe={kernelName:hve._FusedMatMul,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return zBe({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},VBe="return abs(x);";const WBe={kernelName:hve.Abs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=hze(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let a;return a=(0,hve.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Xze(r.shape,VBe):new Oze(r.shape,VBe),n.runWebGLProgram(a,[r],r.dtype)}},UBe=yBe({opSnippet:Pze+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),jBe={kernelName:hve.Acos,backendName:"webgl",kernelFunc:UBe},GBe=yBe({opSnippet:Pze+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),HBe={kernelName:hve.Acosh,backendName:"webgl",kernelFunc:GBe},qBe="return a + b;",KBe=bBe({opSnippet:qBe,packedOpSnippet:qBe,supportsComplex:!0,cpuKernelImpl:DLe}),YBe={kernelName:hve.Add,backendName:"webgl",kernelFunc:KBe};class XBe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class QBe{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const ZBe={kernelName:hve.AddN,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,a=n;if(1===a.length)return iBe({inputs:{x:a[0]},backend:r});if(a.length>(0,hve.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),s=e({inputs:a.slice(t),backend:r});return e({inputs:[n,s],backend:r})}const s=a.map((e=>e.dtype)).reduce(((e,t)=>(0,hve.upcastType)(e,t))),i=a.map((e=>e.shape)),o=(0,hve.env)().getBool("WEBGL_PACK")?new QBe(a[0].shape,i):new XBe(a[0].shape,i);return r.runWebGLProgram(o,a,s)}};const JBe={kernelName:hve.All,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=hve.util.parseAxisParam(s,a.shape);let u=l;const c=hve.backend_util.getAxesPermutation(u,o);let d=a;null!=c&&(d=OBe({inputs:{x:a},backend:n,attrs:{perm:c}}),u=hve.backend_util.getInnerMostAxes(u.length,o)),hve.backend_util.assertAxesAreInnerMostDims("all",u,o);const[h,p]=hve.backend_util.computeOutAndReduceShapes(d.shape,u),f=NBe({inputs:{x:d},backend:n,attrs:{shape:[-1,hve.util.sizeFromShape(p)]}}),m=_Be(f,f.dtype,"all",n);let g;if(i){g=NBe({inputs:{x:m},backend:n,attrs:{shape:hve.backend_util.expandShapeToKeepDim(h,l)}})}else g=NBe({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};const eVe={kernelName:hve.Any,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=hve.util.parseAxisParam(s,a.shape);let u=l;const c=hve.backend_util.getAxesPermutation(u,o);let d=a;null!=c&&(d=OBe({inputs:{x:a},backend:n,attrs:{perm:c}}),u=hve.backend_util.getInnerMostAxes(u.length,o)),hve.backend_util.assertAxesAreInnerMostDims("any",u,o);const[h,p]=hve.backend_util.computeOutAndReduceShapes(d.shape,u),f=NBe({inputs:{x:d},backend:n,attrs:{shape:[-1,hve.util.sizeFromShape(p)]}}),m=_Be(f,f.dtype,"any",n);let g;if(i){g=NBe({inputs:{x:m},backend:n,attrs:{shape:hve.backend_util.expandShapeToKeepDim(h,l)}})}else g=NBe({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};class tVe{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class nVe{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,hve.util.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,l=oLe(o),u=Eze("coords",o);let c,d;if(1===s){d=o+1;const e=oLe(d);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else d=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),m=Eze("sourceLocR",d-1).concat("inIdx.r"),g=Eze("sourceLocG",d-1).concat("inIdx.g"),y=Eze("sourceLocB",d-1).concat("inIdx.b"),b=Eze("sourceLocA",d-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function rVe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);const i=hve.backend_util.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new tVe(o,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=rVe(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function aVe(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const a=null!=r?r.shape:t.shape,s=a[a.length-1],i=hve.backend_util.computeOptimalWindowSize(s),o=new nVe(a,i,n,null==r),l=null==r?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){const r=aVe(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function sVe(e,t,n,r){const a=[n];if(hve.backend_util.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!(0,hve.env)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId);let i=t;null!==s&&s.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,l]=hve.backend_util.computeOutAndReduceShapes(i.shape,a),u=hve.util.sizeFromShape(l),c=NBe({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);const d=rVe(e,c,r);n.push(d);const h=NBe({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return aVe(e,t,r)}const iVe={kernelName:hve.ArgMax,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let i=hve.util.parseAxisParam(s,a.shape);const o=hve.backend_util.getAxesPermutation(i,a.shape.length);let l=a;const u=[];null!=o&&(l=OBe({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=hve.backend_util.getInnerMostAxes(i.length,l.shape.length)),hve.backend_util.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);const c=sVe(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};const oVe={kernelName:hve.ArgMin,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;let i=hve.util.parseAxisParam(s,a.shape);const o=hve.backend_util.getAxesPermutation(i,a.shape.length);let l=a;const u=[];null!=o&&(l=OBe({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=hve.backend_util.getInnerMostAxes(i.length,l.shape.length)),hve.backend_util.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);const c=sVe(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},lVe=yBe({opSnippet:Pze+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),uVe={kernelName:hve.Asin,backendName:"webgl",kernelFunc:lVe},cVe=yBe({opSnippet:Pze+"return log(x + sqrt(x * x + 1.0));"}),dVe={kernelName:hve.Asinh,backendName:"webgl",kernelFunc:cVe},hVe=yBe({opSnippet:Pze+"\n  return atan(x);\n"}),pVe={kernelName:hve.Atan,backendName:"webgl",kernelFunc:hVe},fVe=bBe({opSnippet:nBe+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+aBe+"\n  return result;\n"}),mVe={kernelName:hve.Atan2,backendName:"webgl",kernelFunc:fVe},gVe=yBe({opSnippet:Pze+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),yVe={kernelName:hve.Atanh,backendName:"webgl",kernelFunc:gVe};class bVe{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");const v=4*Math.floor(s/4),x=s%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class vVe{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(s/4),k=s%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}}const xVe={kernelName:hve.AvgPool,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;WPe(a,"avgPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;hve.util.assert(hve.backend_util.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hve.backend_util.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&hve.util.arraysEqual(u.inShape,u.outShape))return iBe({inputs:{x:a},backend:n});const c=new bVe(u,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}};const wVe={kernelName:hve.AvgPool3D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=hve.backend_util.computePool3DInfo(a.shape,s,i,[1,1,1],o,l,u),d=new vVe(c,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}};class kVe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class SVe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const IVe={kernelName:hve.AvgPool3DGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=hve.backend_util.computePool3DInfo(i.shape,o,l,[1,1,1],u,c),h=new SVe(d);return n.runWebGLProgram(h,[a],i.dtype)}};const TVe={kernelName:hve.AvgPoolGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;WPe([a,s],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=hve.backend_util.computePool2DInfo(i.shape,o,l,1,u),d=new kVe(c);return n.runWebGLProgram(d,[a],i.dtype)}};const NVe={kernelName:hve.BatchMatMul,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;return zBe({a:a,b:s,transposeA:i,transposeB:o,backend:n})}};class CVe{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],hve.backend_util.assertAndGetBroadcastShape(e,t),hve.backend_util.assertAndGetBroadcastShape(e,n);let i="0.0";null!=r&&(hve.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(hve.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class AVe{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],hve.backend_util.assertAndGetBroadcastShape(e,t),hve.backend_util.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";null!=r&&(hve.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(hve.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const EVe={kernelName:hve.FusedBatchNorm,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a,mean:s,variance:i,offset:o,scale:l}=t;hve.util.assert(s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),hve.util.assert(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),hve.util.assert(null==l||s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=[a,s,i];let d=null;null!=o&&(d=o.shape,c.push(o));let h=null;null!=l&&(h=l.shape,c.push(l));const p=(0,hve.env)().getBool("WEBGL_PACK_NORMALIZATION")?new AVe(a.shape,s.shape,i.shape,d,h,u):new CVe(a.shape,s.shape,i.shape,d,h,u);return n.runWebGLProgram(p,c,c[0].dtype)}};class _Ve{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=oLe(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return $Ve.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${$Ve[t]} = start[${t}] + coords.${$Ve[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const $Ve=["x","y","z","w","u","v"];class RVe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=oLe(this.rank),n=Eze("coords",this.rank),r=Eze("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function DVe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=hve.slice_util.parseSliceParams(a,s,i);if(hve.slice_util.assertParamsValid(a,o,l),0===hve.util.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const e=n.texData.get(a.dataId),t=pze(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}const{isPacked:u}=n.texData.get(a.dataId),c=hve.slice_util.isSliceContinous(a.shape,o,l);if(u||!c){const e=(0,hve.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RVe(l):new _Ve(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){const a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=hve.slice_util.computeFlatOffset(t,hve.util.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}(a,o,l,n)}const MVe={kernelName:hve.Slice,backendName:"webgl",kernelFunc:DVe},FVe={kernelName:hve.BatchToSpaceND,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;hve.util.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((e,t)=>e*t)),l=hve.backend_util.getReshaped(a.shape,s,o),u=hve.backend_util.getPermuted(l.length,s.length),c=hve.backend_util.getReshapedPermuted(a.shape,s,o),d=hve.backend_util.getSliceBeginCoords(i,s.length),h=hve.backend_util.getSliceSize(c,i,s.length),p=[],f=NBe({inputs:{x:a},backend:n,attrs:{shape:l}}),m=OBe({inputs:{x:f},backend:n,attrs:{perm:u}}),g=NBe({inputs:{x:m},backend:n,attrs:{shape:c}}),y=DVe({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const OVe={kernelName:hve.Bincount,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=MLe(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}};const PVe={kernelName:hve.BitwiseAnd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:a}=t,s=(0,hve.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=(0,hve.env)().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,a])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(a.dataId).values,[s,i]=OLe(r.shape,a.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=s,o}let o;return o=s?new sBe("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,a.shape,!1):new rBe("\n  return float(int(a.r) & int(b.r));\n",r.shape,a.shape),n.runWebGLProgram(o,[r,a],r.dtype)}};const LVe={kernelName:hve.BroadcastArgs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=hve.backend_util.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},zVe=bBe({opSnippet:"return float(a != b);",cpuKernelImpl:rze,dtype:"bool"}),BVe={kernelName:hve.NotEqual,backendName:"webgl",kernelFunc:zVe};function VVe(e){const{inputs:t,backend:n}=e,{input:r}=t;return iBe({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const WVe={kernelName:hve.Real,backendName:"webgl",kernelFunc:VVe},UVe="return float(int(x));";const jVe={kernelName:hve.Cast,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:a}=t,{x:s}=n,{dtype:i}=a;if("complex64"===i){if("complex64"===s.dtype)return iBe({inputs:{x:s},backend:r});const t=hve.zeros(s.shape),n=e({inputs:{x:s},backend:r,attrs:{dtype:"float32"}}),a=lBe({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===s.dtype){const t=VVe({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!hve.util.hasEncodingLoss(s.dtype,i)){const e=iBe({inputs:{x:s},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([s])){const e=r.texData.get(s.dataId).values,[t,n,a]=PLe(e,s.shape,s.dtype,i);return r.makeTensorInfo(t,n,a)}if("int32"===i)return function(e,t){const n=new Oze(e.shape,UVe),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",hve.util.getTypedArrayFromDType("bool",1)),t=zVe({inputs:{a:s,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},GVe="return ceil(x);",HVe=yBe({opSnippet:GVe,packedOpSnippet:GVe,cpuKernelImpl:LLe}),qVe={kernelName:hve.Ceil,backendName:"webgl",kernelFunc:HVe};class KVe{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class YVe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const XVe={kernelName:hve.ClipByValue,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r;let o;o=(0,hve.env)().getBool("WEBGL_PACK_CLIP")?new YVe(a.shape):new KVe(a.shape);const l=[[s],[i]];return n.runWebGLProgram(o,[a],a.dtype,l)}};class QVe{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function ZVe(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const JVe={kernelName:hve.ComplexAbs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new QVe(r.shape),i=[ZVe(r,a.complexTensorInfos.real),ZVe(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}};class eWe{constructor(e){this.outputShape=[],this.outputShape=hve.backend_util.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){const e=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${e}));`)}const r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class tWe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=hve.backend_util.computeOutShape(e,t);const n=this.outputShape,r=n.length,a=oLe(r),s=Eze("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const l=i[t],u=i.slice(-2),c=i.join();let d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){const e=o[f-1];d+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${nWe(i,l,e)}),\n            vec2(${nWe(u,l,e)}));\n        }`}const h=o.length,p=o[o.length-1];d+=`\n        return getChannel(\n          getT${h}(${nWe(i,l,p)}),\n          vec2(${nWe(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}}function nWe(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function rWe(e){const{inputs:t,backend:n}=e,{input:r}=t;return iBe({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const aWe={kernelName:hve.Imag,backendName:"webgl",kernelFunc:rWe};function sWe(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>VVe({inputs:{input:e},backend:n}))),a=e.map((e=>rWe({inputs:{input:e},backend:n}))),s=sWe(r,t,n),i=sWe(a,t,n),o=lBe({inputs:{real:s,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){const a=e.map((e=>{const r=hve.util.sizeFromShape(e.shape.slice(t));return NBe({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=hve.backend_util.computeOutShape(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=zLe(s,i,r,o),u=hve.backend_util.computeOutShape(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const s=e.filter((e=>hve.util.sizeFromShape(e.shape)>0)),i=(0,hve.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const t=i?new Oze(e[0].shape,Uze):new Xze(e[0].shape,Uze);return n.runWebGLProgram(t,e,r)}const o=(0,hve.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){const e=[];for(let a=0;a<s.length;a+=o){const r=s.slice(a,a+o);e.push(sWe(r,t,n))}const r=sWe(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new tWe(s.map((e=>e.shape)),t);return n.runWebGLProgram(e,s,r)}const{tensors2D:l,outShape:u}=function(e,t,n){const r=hve.backend_util.computeOutShape(e.map((e=>e.shape)),t),a=e.map((e=>NBe({inputs:{x:e},attrs:{shape:[-1,hve.util.sizeFromShape(e.shape.slice(t))]},backend:n})));return{tensors2D:a,outShape:r}}(s,t,n),c=new eWe(l.map((e=>e.shape))),d=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const h=NBe({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function iWe(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=hve.util.parseAxisParam(a,t[0].shape)[0],i=t.map((e=>e.shape));hve.backend_util.assertParamsConsistent(i,s);const o=hve.backend_util.computeOutShape(t.map((e=>e.shape)),s);if(0===hve.util.sizeFromShape(o))return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter((e=>hve.util.sizeFromShape(e.shape)>0));return 1===l.length?iBe({inputs:{x:l[0]},backend:n}):sWe(l,s,n)}const oWe={kernelName:hve.Concat,backendName:"webgl",kernelFunc:iWe};class lWe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}}class uWe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class cWe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=fLe(this.outputShape.length);const s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)d+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){const t=2*m;if(d+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,d+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){const e=s%2===0?hve.util.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,d+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):d+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(s%2===1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(d+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(d+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(d+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class dWe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=fLe(this.outputShape.length);const{dataFormat:n}=t,r=jPe(),a="channelsLast"===n,s=a?1:2,i=a?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function hWe(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function pWe(e){let{x:t,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const u=t.shape,c=a.texData.get(t.dataId),d=r.inChannels,h=u[0]*u[1]*u[2],p=r.outChannels,f="channelsLast"===r.dataFormat,m=!1;let g;const y=[];if(null!=i){const e=hWe(i.shape,f);null!=e&&(i=NBe({inputs:{x:i},backend:a,attrs:{shape:e}}),y.push(i))}if(null!=s){const e=hWe(s.shape,f);null!=e&&(s=NBe({inputs:{x:s},backend:a,attrs:{shape:e}}),y.push(s))}if(!((1===h||1===p)&&d>LBe)&&c.isPacked&&f&&null!=c.texture&&u[2]%2!==0&&hve.util.arraysEqual(c.shape.slice(-3),u.slice(-3))){const e=u[0]*u[1]*(u[2]+1),d={dataId:t.dataId,shape:[1,e,r.inChannels],dtype:t.dtype},h=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,hve.util.assert(FPe(c.shape,d.shape),(()=>`packed reshape ${c.shape} to ${d.shape} isn't free`));const p=NBe({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}});y.push(p);const f=zBe({a:d,b:p,backend:a,transposeA:false,transposeB:m,bias:s,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),b=a.texData.get(f.dataId);hve.util.assert(b.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=h,b.shape=r.outShape,g=iBe({inputs:{x:f},backend:a}),g.shape=r.outShape,y.push(f)}else{const e=r.outHeight*r.outWidth,u=NBe({inputs:{x:t},backend:a,attrs:{shape:f?[r.batchSize,e,r.inChannels]:[r.batchSize,r.inChannels,e]}}),c=NBe({inputs:{x:n},backend:a,attrs:{shape:[1,r.inChannels,r.outChannels]}}),d=zBe({a:f?u:c,b:f?c:u,transposeA:!f,transposeB:m,backend:a,bias:s,activation:l,preluActivationWeights:i,leakyreluAlpha:o});g=NBe({inputs:{x:d},backend:a,attrs:{shape:r.outShape}}),y.push(u),y.push(c),y.push(d)}for(const b of y)a.disposeIntermediateTensorInfo(b);return g}function fWe(e){let{x:t,filter:n,convInfo:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const{filterWidth:u,filterHeight:c,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=u*c*d,y=p*h,b=[r.batchSize,g,y],v=[];if(null!=i){const e=hWe(i.shape,m);null!=e&&(i=NBe({inputs:{x:i},backend:a,attrs:{shape:e}}),v.push(i))}if(null!=s){const e=hWe(s.shape,m);null!=e&&(s=NBe({inputs:{x:s},backend:a,attrs:{shape:e}}),v.push(s))}const x=NBe({inputs:{x:n},backend:a,attrs:{shape:[1,g,hve.util.sizeFromShape(n.shape)/g]}});v.push(x);const w=new dWe(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=a.runWebGLProgram(w,[t],"float32",k),I=NBe({inputs:{x:S},backend:a,attrs:{shape:b}});v.push(S),v.push(I);const T=null!=s,N=null!=i,C="leakyrelu"===l,A=l?vBe(l,!0):null,E=new xBe(m?I.shape:x.shape,m?x.shape:I.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,T,A,N,C),_=m?[I,x]:[x,I];if(s&&_.push(s),N&&_.push(i),C){const e=a.makeTensorInfo([],"float32",hve.util.createScalarValue(o,"float32"));_.push(e),v.push(e)}const $=a.runWebGLProgram(E,_,"float32"),R=NBe({inputs:{x:$},backend:a,attrs:{shape:r.outShape}});v.push($);for(const D of v)a.disposeIntermediateTensorInfo(D);return R}const mWe={kernelName:hve.Conv2D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=hve.backend_util.convertConv2DDataFormat(l),h=hve.backend_util.computeConv2DInfo(a.shape,s.shape,i,u,o,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&(0,hve.env)().getBool("WEBGL_EXP_CONV")){const e=new cWe(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[a,s],"float32",t)}else if((0,hve.env)().getBool("WEBGL_CONV_IM2COL"))p=fWe({x:a,filter:s,convInfo:h,backend:n});else{const e=new lWe(h);p=n.runWebGLProgram(e,[a,s],"float32")}else p=pWe({x:a,filter:s,convInfo:h,backend:n});const f=NBe({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class gWe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class yWe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class bWe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class vWe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const xWe={kernelName:hve.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=hve.backend_util.convertConv2DDataFormat(l),h=hve.backend_util.computeConv2DInfo(a.shape,c,i,1,o,u,!1,d),p=new gWe(h);return n.runWebGLProgram(p,[a,s],"float32")}};class wWe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=fLe(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const kWe={kernelName:hve.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=hve.backend_util.convertConv2DDataFormat(u),h=hve.backend_util.computeConv2DInfo(i,s.shape,o,1,l,c,!1,d);if((0,hve.env)().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new wWe(h);return n.runWebGLProgram(t,[a,s],"float32",e)}{const e=new yWe(h);return n.runWebGLProgram(e,[a,s],"float32")}}};const SWe={kernelName:hve.Conv3D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=hve.backend_util.computeConv3DInfo(a.shape,s.shape,i,l,o),c=new uWe(u);return n.runWebGLProgram(c,[a,s],"float32")}};const IWe={kernelName:hve.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=hve.backend_util.computeConv3DInfo(a.shape,l,i,1,o),c=new bWe(u);return n.runWebGLProgram(c,[a,s],"float32")}};const TWe={kernelName:hve.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=hve.backend_util.computeConv3DInfo(l,s.shape,o,1,i),c=new vWe(u);return n.runWebGLProgram(c,[a,s],"float32")}},NWe=yBe({opSnippet:gBe+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${aBe}\n  return result;\n`}),CWe={kernelName:hve.Cos,backendName:"webgl",kernelFunc:NWe},AWe=yBe({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),EWe={kernelName:hve.Cosh,backendName:"webgl",kernelFunc:AWe};class _We{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];const h="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,x]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const $We={kernelName:hve.CropAndResize,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new _We(a.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[a,s,i],"float32")}};var RWe;!function(e){e.Prod="*",e.Sum="+"}(RWe||(RWe={}));class DWe{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,s=this.op===RWe.Prod?"1.0":"0.0",i=n?s:`getX(${MWe(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${oLe(a)} coords = getOutputCoords();\n        int end = ${FWe(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${FWe(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${MWe(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function MWe(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function FWe(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function OWe(e,t,n,r,a,s){const i=t.shape.length,o=hve.backend_util.getAxesPermutation([r],i);let l=t;null!=o&&(l=OBe({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=hve.backend_util.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=iBe({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const t=new DWe(e,l.shape,!1,s),r=[[h]],a=d;d=n.runWebGLProgram(t,[d],d.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){const t=new DWe(e,l.shape,a,s),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=OBe({inputs:{x:d},backend:n,attrs:{perm:hve.backend_util.getUndoAxesPermutation(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}const PWe={kernelName:hve.Cumprod,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return OWe(RWe.Prod,a,n,s,i,o)}};const LWe={kernelName:hve.Cumsum,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return OWe(RWe.Sum,a,n,s,i,o)}};const zWe={kernelName:hve.DenseBincount,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){const e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=MLe(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){const e=n.bufferSync(a),t=n.bufferSync(s),r=FLe(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};class BWe{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const VWe={kernelName:hve.DepthToSpace,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l=("NHWC"===i?a.shape[1]:a.shape[2])*s,u=("NHWC"===i?a.shape[2]:a.shape[3])*s,c=("NHWC"===i?a.shape[3]:a.shape[1])/(s*s),d=new BWe("NHWC"===i?[o,l,u,c]:[o,c,l,u],s,i);return n.runWebGLProgram(d,[a],a.dtype)}};class WWe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=fLe(this.outputShape.length);const s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class UWe{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],a=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=fLe(this.outputShape.length);const s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)h+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){const e=2*g;if(h+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,h+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=i%2===0?hve.util.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,h+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):h+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(h+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(h+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(h+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const jWe={kernelName:hve.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),hve.util.assert(hve.backend_util.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=hve.backend_util.computeConv2DInfo(a.shape,s.shape,i,c,o,u,!0);let h;h=(0,hve.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new UWe(d):new WWe(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[a,s],"float32",p)}};class GWe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class HWe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const qWe={kernelName:hve.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=hve.backend_util.computeConv2DInfo(a.shape,c,i,o,l,u,!0),h=new GWe(d);return n.runWebGLProgram(h,[a,s],"float32")}};const KWe={kernelName:hve.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=hve.backend_util.computeConv2DInfo(c,s.shape,i,o,l,u,!0),h=new HWe(d);return n.runWebGLProgram(h,[a,s],"float32")}};class YWe{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const XWe={kernelName:hve.Diag,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=hve.util.sizeFromShape(r.shape),i=NBe({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new YWe(s),l=n.runWebGLProgram(o,[i],i.dtype),u=NBe({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}};class QWe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const ZWe={kernelName:hve.Dilation2D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=hve.backend_util.computeDilation2DInfo(a.shape,s.shape,i,o,"NHWC",l);let c;const d=new QWe(u);c=n.runWebGLProgram(d,[a,s],"float32");const h=NBe({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}};const JWe={kernelName:hve.Einsum,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=hve.backend_util.decodeEinsumEquation(a,s.length);hve.backend_util.checkEinsumDimSizes(i.length,l,s);const{path:u,steps:c}=hve.backend_util.getEinsumComputePath(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=hve.backend_util.getEinsumPermutation(p,l[e]);let a;hve.backend_util.isIdentityPermutation(t)?a=s[e]:(a=OBe({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(a));const i=a.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);hve.util.arraysEqual(a.shape,i)||(a=NBe({inputs:{x:a},backend:n,attrs:{shape:i}}),f.push(a)),null===h?h=a:(h=IBe({inputs:{a:a,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=MBe({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},eUe=yBe({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),tUe={kernelName:hve.Elu,backendName:"webgl",kernelFunc:eUe},nUe={kernelName:hve.EluGrad,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=(0,hve.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sBe("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new rBe("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)}},rUe=bBe({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:BLe}),aUe={kernelName:hve.Equal,backendName:"webgl",kernelFunc:rUe},sUe=yBe({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${hve.backend_util.ERF_P};\n  float a1 = ${hve.backend_util.ERF_A1};\n  float a2 = ${hve.backend_util.ERF_A2};\n  float a3 = ${hve.backend_util.ERF_A3};\n  float a4 = ${hve.backend_util.ERF_A4};\n  float a5 = ${hve.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),iUe={kernelName:hve.Erf,backendName:"webgl",kernelFunc:sUe},oUe=yBe({opSnippet:gBe+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:VLe,dtype:"float32"}),lUe={kernelName:hve.Exp,backendName:"webgl",kernelFunc:oUe};function uUe(e){const{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(hve.util.assert(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),NBe({inputs:{x:s},backend:r,attrs:{shape:o}})}const cUe={kernelName:hve.ExpandDims,backendName:"webgl",kernelFunc:uUe},dUe="return exp(x) - 1.0;",hUe=yBe({opSnippet:dUe,packedOpSnippet:dUe,cpuKernelImpl:WLe}),pUe={kernelName:hve.Expm1,backendName:"webgl",kernelFunc:hUe};class fUe{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${s};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function mUe(e,t,n){const r=n.texData.get(e.dataId),a=hve.util.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=NBe({inputs:{x:e},backend:n,attrs:{shape:[a/s,s]}}),o=i.shape,l=new fUe("real",o,t),u=new fUe("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(l,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),p=lBe({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=NBe({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const gUe={kernelName:hve.FFT,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return mUe(r,!1,n)}};class yUe{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function bUe(e){const{backend:t,attrs:n}=e,{shape:r,value:a}=n;let{dtype:s}=n;if(s=s||hve.util.inferDtype(a),"string"===s){const e=hve.util.getArrayFromDType(s,hve.util.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{const e=new yUe(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}const vUe={kernelName:hve.Fill,backendName:"webgl",kernelFunc:bUe};class xUe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const wUe={kernelName:hve.FlipLeftRight,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:r}=t,a=n,s=new xUe(r.shape);return a.runWebGLProgram(s,[r],r.dtype)}},kUe="return floor(x);",SUe=yBe({opSnippet:kUe,packedOpSnippet:kUe,cpuKernelImpl:ULe}),IUe={kernelName:hve.Floor,backendName:"webgl",kernelFunc:SUe},TUe=bBe({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),NUe={kernelName:hve.FloorDiv,backendName:"webgl",kernelFunc:TUe};class CUe{constructor(e){this.variableNames=["A"];const t=jPe(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class AUe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=jPe(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const EUe={kernelName:hve.FromPixels,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:a}=t;const{numChannels:s}=r,i="undefined"!==typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],c=[u,l],d=[u,l,s];if(o||i){const e=(0,hve.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=_Ue&&e===$Ue||($Ue=e,_Ue=document.createElement("canvas").getContext("2d",{willReadFrequently:$Ue})),_Ue.canvas.width=l,_Ue.canvas.height=u,_Ue.drawImage(a,0,0,l,u),a=_Ue.canvas}const h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=hPe.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),a);const p=(0,hve.env)().getBool("WEBGL_PACK")?new AUe(d):new CUe(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let _Ue,$Ue=(0,hve.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const RUe={kernelName:hve.FusedConv2D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=hve.backend_util.convertConv2DDataFormat(c),g=hve.backend_util.computeConv2DInfo(a.shape,s.shape,l,d,u,h,!1,m);let y;const b=[],v=null!=i,x=null!=o,w="leakyrelu"===p,k=()=>{const e=[a,s],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=NBe({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(i,c)),x&&e.push(t(o,c)),w){const t=n.makeTensorInfo([],"float32",hve.util.createScalarValue(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&(0,hve.env)().getBool("WEBGL_EXP_CONV")){const e=p?vBe(p,!0):null,t=new cWe(g,v,e,x,w),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],a=k();y=n.runWebGLProgram(t,a,"float32",r)}else if((0,hve.env)().getBool("WEBGL_CONV_IM2COL"))y=fWe({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?vBe(p,!1):null,t=new lWe(g,v,e,x,w),r=k();y=n.runWebGLProgram(t,r,"float32")}else y=pWe({x:a,filter:s,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=NBe({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const DUe={kernelName:hve.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),hve.util.assert(hve.backend_util.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=hve.backend_util.computeConv2DInfo(a.shape,s.shape,l,m,u,d,!0),y=(0,hve.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=h?vBe(h,y):null,v=[a,s],x=null!=i,w=null!=o,k="leakyrelu"===h;if(x&&v.push(i),w&&v.push(o),k){const e=n.makeTensorInfo([],"float32",hve.util.createScalarValue(p,"float32"));v.push(e),f.push(e)}let S;S=y?new UWe(g,x,b,w,k):new WWe(g,x,b,w,k);const I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],T=n.runWebGLProgram(S,v,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),T}};class MUe{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const a=oLe(n.length);let s="\n    int index;";for(let i=0;i<this.sliceDim;i++)s+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${s}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const FUe={kernelName:hve.GatherNd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=hve.util.sizeFromShape(r.shape),[l,u,c,d]=hve.backend_util.prepareAndValidate(r,a),h=NBe({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),p=NBe({inputs:{x:r},backend:n,attrs:{shape:[hve.util.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const e=n.readSync(a.dataId),t=n.bufferSync(r),s=jLe(e,t,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}const f=new MUe(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=NBe({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class OUe{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=oLe(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function PUe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=hve.util.parseAxisParam(i,a.shape)[0];if((0,hve.env)().get("DEBUG")){const e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){const r=e[n];hve.util.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const u=hve.backend_util.segment_util.collectGatherOpShapeInfo(a,s,l,o),c=hve.util.sizeFromShape(s.shape),d=[],h=NBe({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=NBe({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),r=GLe(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new OUe(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const y=NBe({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const LUe={kernelName:hve.GatherV2,backendName:"webgl",kernelFunc:PUe},zUe=bBe({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:HLe,dtype:"bool"}),BUe={kernelName:hve.Greater,backendName:"webgl",kernelFunc:zUe},VUe=bBe({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:qLe}),WUe={kernelName:hve.GreaterEqual,backendName:"webgl",kernelFunc:VUe};const UUe={kernelName:hve.IFFT,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return mUe(r,!0,n)}},jUe=yBe({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),GUe={kernelName:hve.IsFinite,backendName:"webgl",kernelFunc:jUe},HUe=yBe({opSnippet:"return float(isinf(x));",dtype:"bool"}),qUe={kernelName:hve.IsInf,backendName:"webgl",kernelFunc:HUe},KUe=yBe({opSnippet:"return float(isnan(x));",dtype:"bool"}),YUe={kernelName:hve.IsNan,backendName:"webgl",kernelFunc:KUe},XUe=bBe({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:KLe,dtype:"bool"}),QUe={kernelName:hve.Less,backendName:"webgl",kernelFunc:XUe},ZUe=bBe({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:YLe,dtype:"bool"}),JUe={kernelName:hve.LessEqual,backendName:"webgl",kernelFunc:ZUe};const eje={kernelName:hve.LinSpace,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=XLe(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}},tje=yBe({opSnippet:gBe+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:QLe}),nje={kernelName:hve.Log,backendName:"webgl",kernelFunc:tje},rje=yBe({opSnippet:gBe+"\n  return log(1.0 + x);\n"}),aje={kernelName:hve.Log1p,backendName:"webgl",kernelFunc:rje},sje=bBe({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),ije={kernelName:hve.LogicalAnd,backendName:"webgl",kernelFunc:sje},oje=yBe({opSnippet:"return float(!(x >= 1.0));"}),lje={kernelName:hve.LogicalNot,backendName:"webgl",kernelFunc:oje},uje=bBe({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),cje={kernelName:hve.LogicalOr,backendName:"webgl",kernelFunc:uje};class dje{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];const s=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class hje{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const pje={kernelName:hve.LRN,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=(0,hve.env)().getBool("WEBGL_PACK_NORMALIZATION")?new hje(a.shape,s,i,o,l):new dje(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)}};class fje{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const mje={kernelName:hve.LRNGrad,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new fje(a.shape,o,l,u,c);return n.runWebGLProgram(d,[a,s,i],a.dtype)}};function gje(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=hve.util.parseAxisParam(s,a.shape);let u=l;const c=hve.backend_util.getAxesPermutation(u,o),d=null!=c,h=n.shouldExecuteOnCPU([a]);let p=a;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=a.shape[c[n]];const r=Nze(e,a.shape,a.dtype,c,t);p=n.makeTensorInfo(t,a.dtype);n.texData.get(p.dataId).values=r}else p=DBe(a,c,n);u=hve.backend_util.getInnerMostAxes(u.length,o)}hve.backend_util.assertAxesAreInnerMostDims("max",u,o);const[f,m]=hve.backend_util.computeOutAndReduceShapes(p.shape,u);let g,y=f;if(i&&(y=hve.backend_util.expandShapeToKeepDim(f,l)),h){const e=n.texData.get(p.dataId).values,t=ZLe(e,hve.util.sizeFromShape(m),y,a.dtype);g=n.makeTensorInfo(y,a.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const a=hve.util.sizeFromShape(t),s=NBe({inputs:{x:e},attrs:{shape:[hve.util.sizeFromShape(e.shape)/a,a]},backend:r}),i=_Be(s,e.dtype,"max",r),o=NBe({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(p,m,y,n);return d&&n.disposeIntermediateTensorInfo(p),g}const yje={kernelName:hve.Max,backendName:"webgl",kernelFunc:gje},bje=bBe({opSnippet:nBe+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+aBe+"\n  return result;\n",cpuKernelImpl:JLe}),vje={kernelName:hve.Maximum,backendName:"webgl",kernelFunc:bje};const xje={kernelName:hve.MaxPool,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;WPe(a,"maxPool");const{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r;hve.util.assert(hve.backend_util.eitherStridesOrDilationsAreOne(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hve.backend_util.computePool2DInfo(a.shape,s,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&hve.util.arraysEqual(u.inShape,u.outShape))return iBe({inputs:{x:a},backend:n});const c=new bVe(u,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}};const wje={kernelName:hve.MaxPool3D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=hve.backend_util.computePool3DInfo(a.shape,s,i,[1,1,1],o,u,l),d=new vVe(c,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}};class kje{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Sje{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Ije={kernelName:hve.MaxPool3DGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=hve.backend_util.computePool3DInfo(i.shape,o,l,[1,1,1],u,c),h=new vVe(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new Sje(d),m=n.runWebGLProgram(f,[a,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};const Tje={kernelName:hve.MaxPoolGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;WPe([s,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=hve.backend_util.computePool2DInfo(o.shape,l,u,1,c,d),p=new bVe(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new kje(h),g=n.runWebGLProgram(m,[a,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const Nje={kernelName:hve.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;hve.util.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));const c=[1,1];hve.util.assert(hve.backend_util.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=hve.backend_util.computePool2DInfo(a.shape,s,i,c,o),[h,p]=function(e,t,n,r){let a=new bVe(n,"max",!1);const s=r.runWebGLProgram(a,[e],"float32");return a=new bVe(n,"max",!0,!0,t),[s,r.runWebGLProgram(a,[e],"float32")]}(a,l,d,u);return[h,p]}};const Cje={kernelName:hve.Mean,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,{keepDims:s,axis:i}=n,o=r,l=a.shape.length,u=hve.util.parseAxisParam(i,a.shape);let c=u;const d=hve.backend_util.getAxesPermutation(c,l),h=null!=d,p=o.shouldExecuteOnCPU([a]),f=[];let m=a;if(h){if(p){const e=o.texData.get(m.dataId).values,t=new Array(l);for(let r=0;r<t.length;r++)t[r]=a.shape[d[r]];const n=Nze(e,a.shape,a.dtype,d,t);m=o.makeTensorInfo(t,a.dtype);o.texData.get(m.dataId).values=n}else m=DBe(a,d,o);f.push(m),c=hve.backend_util.getInnerMostAxes(c.length,l)}hve.backend_util.assertAxesAreInnerMostDims("sum",c,l);const[g,y]=hve.backend_util.computeOutAndReduceShapes(m.shape,c);let b=g;s&&(b=hve.backend_util.expandShapeToKeepDim(g,u));const v=function(e,t,n,r){const a=hve.util.sizeFromShape(t),s=NBe({inputs:{x:e},attrs:{shape:[hve.util.sizeFromShape(e.shape)/a,a]},backend:r}),i=_Be(s,"float32","mean",r),o=NBe({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}(m,y,b,o);for(const x of f)o.disposeIntermediateTensorInfo(x);return v}};const Aje={kernelName:hve.Min,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=hve.util.parseAxisParam(s,a.shape);let u=l;const c=hve.backend_util.getAxesPermutation(u,o);let d=a;null!=c&&(d=OBe({inputs:{x:a},backend:n,attrs:{perm:c}}),u=hve.backend_util.getInnerMostAxes(u.length,a.shape.length)),hve.backend_util.assertAxesAreInnerMostDims("min",u,o);const[h,p]=hve.backend_util.computeOutAndReduceShapes(d.shape,u),f=NBe({inputs:{x:d},backend:n,attrs:{shape:[-1,hve.util.sizeFromShape(p)]}}),m=_Be(f,f.dtype,"min",n);let g;if(i){g=NBe({inputs:{x:m},backend:n,attrs:{shape:hve.backend_util.expandShapeToKeepDim(h,l)}})}else g=NBe({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},Eje=bBe({opSnippet:nBe+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+aBe+"\n  return result;\n",cpuKernelImpl:eze}),_je={kernelName:hve.Minimum,backendName:"webgl",kernelFunc:Eje};class $je{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=oLe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Rje{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=oLe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=Eze("rc",r),l=Eze("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1;let h="";if(1===r){const e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const Dje={kernelName:hve.MirrorPad,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:a}=t,{paddings:s,mode:i}=r,o=(0,hve.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rje(a.shape,s,i):new $je(a.shape,s,i);return n.runWebGLProgram(o,[a],a.dtype)}},Mje=bBe({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+aBe+"\n  return result;\n"}),Fje={kernelName:hve.Mod,backendName:"webgl",kernelFunc:Mje};class Oje{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const Pje=bBe({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Lje={kernelName:hve.RealDiv,backendName:"webgl",kernelFunc:Pje},zje="return a - b;",Bje=bBe({opSnippet:zje,packedOpSnippet:zje,supportsComplex:!0,cpuKernelImpl:Sze}),Vje={kernelName:hve.Sub,backendName:"webgl",kernelFunc:Bje};function Wje(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=hve.util.parseAxisParam([s],a.shape),o=gje({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=hve.backend_util.expandShapeToKeepDim(o.shape,i),u=NBe({inputs:{x:o},backend:n,attrs:{shape:l}}),c=Bje({inputs:{a:a,b:u},backend:n}),d=oUe({inputs:{x:c},backend:n}),h=MBe({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=NBe({inputs:{x:h},backend:n,attrs:{shape:l}}),f=Pje({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const Uje={kernelName:hve.Softmax,backendName:"webgl",kernelFunc:Wje};const jje={kernelName:hve.Multinomial,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:Wje({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new Oje(u,c,s),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}},Gje=Pze+"\n  return -x;\n";const Hje={kernelName:hve.Neg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,a]=nze(e.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,t)}let a;return a=(0,hve.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Xze(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Oze(r.shape,Gje),n.runWebGLProgram(a,[r],r.dtype)}},qje=hve.kernel_impls.nonMaxSuppressionV3Impl;const Kje={kernelName:hve.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function(e){hve.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=qje(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Yje=hve.kernel_impls.nonMaxSuppressionV4Impl;const Xje={kernelName:hve.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function(e){hve.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:h,validOutputs:p}=Yje(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},Qje=hve.kernel_impls.nonMaxSuppressionV5Impl;const Zje={kernelName:hve.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(e){hve.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(a.dataId),d=n.readSync(s.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=Qje(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class Jje{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const eGe={kernelName:hve.OneHot,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:s,depth:i,onValue:o,offValue:l}=r,u=hve.util.sizeFromShape(a.shape),c=new Jje(u,i,o,l),d=NBe({inputs:{x:a},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],s);n.disposeIntermediateTensorInfo(d);const p=NBe({inputs:{x:h},backend:n,attrs:{shape:[...a.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function tGe(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=VVe({inputs:{input:r},backend:n}),t=tGe({inputs:{x:e},backend:n}),a=rWe({inputs:{input:r},backend:n}),s=tGe({inputs:{x:a},backend:n}),i=lBe({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return bUe({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const nGe={kernelName:hve.ZerosLike,backendName:"webgl",kernelFunc:tGe};const rGe={kernelName:hve.OnesLike,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const t=VVe({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),s=rWe({inputs:{input:a},backend:r}),i=tGe({inputs:{x:s},backend:r}),o=lBe({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(i),o}return bUe({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}};const aGe={kernelName:hve.Pack,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return uUe({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const s=t[0].shape,i=t[0].dtype;t.forEach((e=>{hve.util.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),hve.util.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=iWe({inputs:t.map((e=>{const t=uUe({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class sGe{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=oLe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class iGe{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,a=oLe(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=Eze("rc",r),l=Eze("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${d[f]}\n        if (${h}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const oGe=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===hve.util.sizeFromShape(a.shape)){const e=s.map(((e,t)=>e[0]+a.shape[t]+e[1]));return bUe({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}const o=(0,hve.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new iGe(a.shape,s,i):new sGe(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},lGe={kernelName:hve.PadV2,backendName:"webgl",kernelFunc:oGe},uGe=bBe({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+aBe+"\n  return result;\n"}),cGe={kernelName:hve.Pow,backendName:"webgl",kernelFunc:uGe};const dGe={kernelName:hve.Prod,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=[],u=hve.util.parseAxisParam(s,a.shape);let c=u;const d=hve.backend_util.getAxesPermutation(c,o);let h,p=a;if(null!=d&&(p=OBe({inputs:{x:a},backend:n,attrs:{perm:d}}),c=hve.backend_util.getInnerMostAxes(c.length,o),l.push(p)),hve.backend_util.assertAxesAreInnerMostDims("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:a}=aze(p.shape,p.dtype,e,c);h=n.makeTensorInfo(r,a,t)}else{const[e,t]=hve.backend_util.computeOutAndReduceShapes(p.shape,c),r=hve.util.sizeFromShape(t),s=NBe({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=_Be(s,(0,hve.sumOutType)(a.dtype),"prod",n);h=NBe({inputs:{x:i},backend:n,attrs:{shape:e}}),l.push(s),l.push(i)}if(i){l.push(h);const e=hve.backend_util.expandShapeToKeepDim(h.shape,u);h=NBe({inputs:{x:h},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const hGe={kernelName:hve.RaggedGather,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=r,l=a.map((e=>n.readSync(e.dataId))),u=a.map((e=>e.shape)),c=n.readSync(s.dataId),d=n.readSync(i.dataId),[h,p,f]=sze(l,u,c,s.shape,s.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};const pGe={kernelName:hve.RaggedRange,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:s}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=ize(i,r.shape,r.dtype,o,a.shape,l,s.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};const fGe={kernelName:hve.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:a,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),d=n.readSync(i.dataId),h=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=oze(u,a.shape,c,s.shape,s.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,s.dtype,m)}},mGe=e=>{const{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=lze(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},gGe={kernelName:hve.Range,backendName:"webgl",kernelFunc:mGe},yGe=yBe({opSnippet:"return 1.0 / x;"}),bGe={kernelName:hve.Reciprocal,backendName:"webgl",kernelFunc:yGe},vGe=yBe({opSnippet:Pze+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),xGe={kernelName:hve.Relu,backendName:"webgl",kernelFunc:vGe},wGe=yBe({opSnippet:Pze+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),kGe={kernelName:hve.Relu6,backendName:"webgl",kernelFunc:wGe};class SGe{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class IGe{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const TGe={kernelName:hve.ResizeBilinear,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=(0,hve.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new IGe(a.shape,l,u,s,i):new SGe(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],"float32")}};class NGe{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const CGe={kernelName:hve.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new NGe(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};class AGe{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class EGe{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,i,o,l]=e;this.outputShape=[s,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const _Ge={kernelName:hve.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=(0,hve.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new EGe(a.shape,l,u,s,i):new AGe(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],a.dtype)}};class $Ge{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const RGe={kernelName:hve.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new $Ge(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}};class DGe{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=oLe(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class MGe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=Eze("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=oLe(n);function o(n){const r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const FGe={kernelName:hve.Reverse,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=hve.util.parseAxisParam(s,a.shape);if(0===i)return iBe({inputs:{x:a},backend:n});const l=(0,hve.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new MGe(a.shape,o):new DGe(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}};class OGe{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let a="";a="number"===typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const PGe={kernelName:hve.RotateWithOffset,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:a}=t,{radians:s,fillValue:i,center:o}=n,l=r,u=new OGe(a.shape,i),[c,d]=hve.backend_util.getImageCenter(o,a.shape[1],a.shape[2]),h=[[c,d,Math.sin(s),Math.cos(s)]];return l.runWebGLProgram(u,[a],a.dtype,h)}},LGe=yBe({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),zGe={kernelName:hve.Round,backendName:"webgl",kernelFunc:LGe},BGe=yBe({opSnippet:"return inversesqrt(x);",cpuKernelImpl:uze}),VGe={kernelName:hve.Rsqrt,backendName:"webgl",kernelFunc:BGe};class WGe{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const o=oLe(a.length),l=oLe(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}}class UGe{constructor(e,t,n,r,a,s){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const o=oLe(a.length),l=oLe(s.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${g};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}}const jGe={kernelName:hve.ScatterNd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=hve.backend_util.calculateShapes(s,a,i),h=[d/u,u];if(0===d)return n.makeTensorInfo(i,a.dtype);const p=NBe({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=NBe({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=(0,hve.env)().getBool("WEBGL_PACK")?new UGe(l,o,p.shape.length,f.shape.length,c,h):new WGe(l,o,p.shape.length,f.shape.length,c,h);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=NBe({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class GGe{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,s=2===(0,hve.env)().getNumber("WEBGL_VERSION")?"while (left < right) {":a,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${s}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const HGe={kernelName:hve.SearchSorted,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new GGe(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}};class qGe{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}const s=oLe(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}const KGe={kernelName:hve.Select,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new qGe(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],(0,hve.upcastType)(a.dtype,s.dtype))}},YGe=yBe({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${hve.backend_util.SELU_SCALEALPHA};\n  float scale = ${hve.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),XGe={kernelName:hve.Selu,backendName:"webgl",kernelFunc:YGe},QGe=yBe({opSnippet:gBe+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:dze}),ZGe={kernelName:hve.Sigmoid,backendName:"webgl",kernelFunc:QGe},JGe=yBe({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),eHe={kernelName:hve.Sign,backendName:"webgl",kernelFunc:JGe},tHe=yBe({opSnippet:gBe+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${aBe}\n  return result;\n`}),nHe={kernelName:hve.Sin,backendName:"webgl",kernelFunc:tHe},rHe=yBe({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),aHe={kernelName:hve.Sinh,backendName:"webgl",kernelFunc:rHe},sHe=yBe({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),iHe={kernelName:hve.Softplus,backendName:"webgl",kernelFunc:sHe},oHe={kernelName:hve.SpaceToBatchND,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;hve.util.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);const u=[],c=oGe({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=hve.backend_util.getReshaped(c.shape,s,o,!1),h=hve.backend_util.getPermuted(d.length,s.length,!1),p=hve.backend_util.getReshapedPermuted(c.shape,s,o,!1),f=NBe({inputs:{x:c},backend:n,attrs:{shape:d}}),m=OBe({inputs:{x:f},backend:n,attrs:{perm:h}}),g=NBe({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const lHe={kernelName:hve.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=fze(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],a.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};const uHe={kernelName:hve.SparseReshape,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,d]=mze(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};const cHe={kernelName:hve.SparseSegmentMean,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);const i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=gze(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const dHe={kernelName:hve.SparseSegmentSum,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);const i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=gze(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const hHe={kernelName:hve.SparseToDense,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=hve.backend_util.calculateShapes(s,a,o),p=!1;if("string"===s.dtype){const e=n.bufferSync(a),t=n.bufferSync(s),r=hve.util.decodeString(n.readSync(i.dataId)[0]),f=cze(e,t,o,h,c,u,l,d,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new WGe(u,l,a.shape.length,s.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=NBe({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};const pHe={kernelName:hve.SplitV,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=hve.util.parseAxisParam(i,a.shape)[0],l=hve.backend_util.prepareSplitSize(a,s,o),u=a.shape.length,c=new Array(u).fill(0),d=a.shape.slice();return l.map((e=>{const t=[...d];t[o]=e;const r=DVe({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},fHe="return sqrt(x);",mHe=yBe({opSnippet:fHe,packedOpSnippet:fHe,cpuKernelImpl:yze}),gHe={kernelName:hve.Sqrt,backendName:"webgl",kernelFunc:mHe},yHe=yBe({opSnippet:"return x * x;"}),bHe={kernelName:hve.Square,backendName:"webgl",kernelFunc:yHe},vHe="return (a - b) * (a - b);",xHe=bBe({opSnippet:vHe,packedOpSnippet:vHe}),wHe={kernelName:hve.SquaredDifference,backendName:"webgl",kernelFunc:xHe};const kHe={kernelName:hve.StaticRegexReplace,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");const s=n.readSync(a.dataId),i=hve.backend_util.fromUint8ToStringArray(s),o=bze(i,"string",r);return n.makeTensorInfo(a.shape,"string",o)}};const SHe={kernelName:hve.Step,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e;const{x:a}=t,s=Pze+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,i=new Oze(a.shape,s);return r.runWebGLProgram(i,[a],a.dtype)}};class IHe{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,a=oLe(n.length),s=oLe(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const THe={kernelName:hve.StridedSlice,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=hve.slice_util.sliceInfo(a.shape,s,i,o,l,u,c,d,h);let w;if(m)w=NBe({inputs:{x:a},backend:n,attrs:{shape:f}});else if(g||y){hve.util.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));const e=hve.slice_util.computeOutShape(b,v,x),t=DVe({inputs:{x:a},backend:n,attrs:{begin:b,size:e}});w=NBe({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([a])){const e=n.readSync(a.dataId),t=(0,hve.buffer)(a.shape,a.dtype,e),r=vze(p,t,x,b);w=n.makeTensorInfo(f,a.dtype,r.values)}else{const e=new IHe(b,x,p);w=n.runWebGLProgram(e,[a],a.dtype)}}const k=NBe({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const NHe={kernelName:hve.StringNGrams,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=xze(h,p,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};const CHe={kernelName:hve.StringSplit,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=wze(o,l,a),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const AHe={kernelName:hve.StringToHashBucketFast,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(s.dataId),o=kze(i,a);return n.makeTensorInfo(s.shape,"int32",o)}},EHe=yBe({opSnippet:"return tan(x);"}),_He={kernelName:hve.Tan,backendName:"webgl",kernelFunc:EHe},$He=yBe({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),RHe={kernelName:hve.Tanh,backendName:"webgl",kernelFunc:$He};const DHe={kernelName:hve.TensorScatterUpdate,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:s,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=hve.backend_util.calculateShapes(i,s,a.shape),h=[d/u,u];if(0===d)return n.makeTensorInfo(a.shape,s.dtype);const p=NBe({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=NBe({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=NBe({inputs:{x:a},backend:n,attrs:{shape:h}}),g=new WGe(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=NBe({inputs:{x:y},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class MHe{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;const r=oLe(this.rank),a=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}function FHe(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){const e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>hve.util.decodeString(e))):e,r=(0,hve.buffer)(a.shape,a.dtype,t),i=Ize(r,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new MHe(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}const OHe={kernelName:hve.Tile,backendName:"webgl",kernelFunc:FHe};class PHe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class LHe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function zHe(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function BHe(e){let t=1;for(;t<e;)t*=2;return t}const VHe={kernelName:hve.TopK,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=(0,hve.env)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=(0,hve.env)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([a])||c<o||s>l){const e=n.readSync(a.dataId),[t,r]=Tze(e,u,a.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[a,bUe({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(a.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(a):a,f=hve.util.sizeFromShape(u)/c,m=NBe({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&zHe(n,p);const g=BHe(s),y=BHe(c);let b=null;const v=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{const a=v(),s=new PHe(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(s,a,"int32",i),zHe(n,o)};for(let T=1;T<g;T*=2){const e=2*T;for(let t=T;t>=1;t/=2)x(e,t,[f,y])}for(let T=y;T>g;T/=2){const e=v(),t=new LHe([f,T/2]),r=[[c],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(t,e,"int32",r),zHe(n,a);const s=g/2,i=2*s;for(let n=s;n>=1;n/=2)x(i,n,b.shape)}let w=b;b=DVe({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),zHe(n,w);let k=PUe({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});zHe(n,m);const S=u.slice(0,-1);S.push(s),w=b,b=NBe({inputs:{x:b},attrs:{shape:S},backend:n}),zHe(n,w);const I=k;return k=NBe({inputs:{x:k},attrs:{shape:S},backend:n}),zHe(n,I),[k,b]}};class WHe{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const UHe={kernelName:hve.Transform,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=a.shape,[f,m]=null!=u?u:[d,h],g=new WHe(d,h,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[a,s],"float32")}};const jHe={kernelName:hve.Unique,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;WPe(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=Cze(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const GHe={kernelName:hve.Unpack,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==s&&(u[c++]=i.shape[m]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[s]=1;const f=new Array(l);for(let m=0;m<f.length;m++){h[s]=m;const e=DVe({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),t=NBe({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class HHe{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const qHe={kernelName:hve.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[];let u=0;const c=hve.backend_util.getAxesPermutation([u],o);let d=a;null!=c&&(d=OBe({inputs:{x:a},backend:n,attrs:{perm:c}}),l.push(d),u=hve.backend_util.getInnerMostAxes(1,o)[0]);const h=hve.backend_util.segment_util.computeOutShape(d.shape,u,i),p=hve.util.sizeFromShape([d.shape[u]]),f=NBe({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=(0,hve.sumOutType)(a.dtype),g=(e,t,r,a,s)=>{const i=e.shape[0],o=e.shape[1],u=hve.backend_util.segment_util.segOpComputeOptimalWindowSize(o,s),c=new HHe({windowSize:u,inSize:o,batchSize:i,numSegments:s},t),d=n.compileAndRun(c,[e,r],a);if(l.push(d),d.shape[1]===s)return d;const h=mGe({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=FHe({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});l.push(h),l.push(p);return g(d,t,p,a,s)},y=NBe({inputs:{x:g(f,"unsortedSegmentSum",s,m,i)},backend:n,attrs:{shape:h}});let b=y;if(null!=c){l.push(y);const e=hve.backend_util.getUndoAxesPermutation(c);b=OBe({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},KHe=[BBe,WBe,jBe,HBe,YBe,ZBe,JBe,eVe,iVe,oVe,uVe,dVe,pVe,mVe,yVe,xVe,wVe,IVe,TVe,NVe,EVe,FVe,OVe,PVe,LVe,jVe,qVe,XVe,uBe,JVe,oWe,mWe,xWe,kWe,SWe,IWe,TWe,CWe,EWe,$We,PWe,LWe,zWe,VWe,jWe,qWe,KWe,XWe,ZWe,JWe,tUe,nUe,aUe,iUe,lUe,cUe,pUe,gUe,vUe,wUe,IUe,NUe,EUe,RUe,DUe,FUe,LUe,BUe,WUe,oBe,UUe,aWe,GUe,qUe,YUe,hBe,QUe,JUe,eje,nje,aje,ije,lje,cje,pje,mje,yje,vje,xje,wje,Ije,Tje,Nje,Cje,Aje,_je,Dje,Fje,jje,TBe,Hje,Kje,Xje,Zje,BVe,eGe,rGe,aGe,lGe,cGe,mBe,dGe,hGe,pGe,fGe,gGe,WVe,Lje,bGe,xGe,kGe,CBe,TGe,CGe,_Ge,RGe,FGe,PGe,zGe,VGe,jGe,HGe,KGe,XGe,ZGe,eHe,nHe,aHe,MVe,Uje,iHe,oHe,lHe,uHe,cHe,dHe,hHe,pHe,gHe,bHe,wHe,kHe,SHe,THe,NHe,CHe,AHe,Vje,FBe,_He,RHe,DHe,OHe,VHe,UHe,PBe,jHe,GHe,qHe,nGe];for(const n of KHe)(0,hve.registerKernel)(n);hve.version_core,YEe.version_converter;function YHe(e,t,n,r){return new(n||(n=Promise))((function(a,s){function i(e){try{l(r.next(e))}catch(e){s(e)}}function o(e){try{l(r.throw(e))}catch(e){s(e)}}function l(e){var t;e.done?a(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))}function XHe(e,t){var n,r,a,s,i={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function o(o){return function(l){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;s&&(s=0,o[0]&&(i=0)),i;)try{if(n=1,r&&(a=2&o[0]?r.return:o[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,o[1])).done)return a;switch(r=0,a&&(o=[2&o[0],a.value]),o[0]){case 0:case 1:a=o;break;case 4:return i.label++,{value:o[1],done:!1};case 5:i.label++,r=o[1],o=[0];continue;case 7:o=i.ops.pop(),i.trys.pop();continue;default:if(!((a=(a=i.trys).length>0&&a[a.length-1])||6!==o[0]&&2!==o[0])){i=0;continue}if(3===o[0]&&(!a||o[1]>a[0]&&o[1]<a[3])){i.label=o[1];break}if(6===o[0]&&i.label<a[1]){i.label=a[1],a=o;break}if(a&&i.label<a[2]){i.label=a[2],i.ops.push(o);break}a[2]&&i.ops.pop(),i.trys.pop();continue}o=t.call(e,i)}catch(e){o=[6,e],r=0}finally{n=a=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,l])}}}function QHe(e,t,n){if(n||2===arguments.length)for(var r,a=0,s=t.length;a<s;a++)!r&&a in t||(r||(r=Array.prototype.slice.call(t,0,a)),r[a]=t[a]);return e.concat(r||Array.prototype.slice.call(t))}function ZHe(e){return[Math.abs(e.endPoint[0]-e.startPoint[0]),Math.abs(e.endPoint[1]-e.startPoint[1])]}function JHe(e){return[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])/2,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])/2]}function eqe(e,t){void 0===t&&(t=1.5);var n=JHe(e),r=ZHe(e),a=[t*r[0]/2,t*r[1]/2];return{startPoint:[n[0]-a[0],n[1]-a[1]],endPoint:[n[0]+a[0],n[1]+a[1]],palmLandmarks:e.palmLandmarks}}function tqe(e){var t=JHe(e),n=ZHe(e),r=Math.max.apply(Math,n)/2;return{startPoint:[t[0]-r,t[1]-r],endPoint:[t[0]+r,t[1]+r],palmLandmarks:e.palmLandmarks}}function nqe(e,t){var n=[e.endPoint[0]-e.startPoint[0],e.endPoint[1]-e.startPoint[1]],r=[n[0]*t[0],n[1]*t[1]];return{startPoint:[e.startPoint[0]+r[0],e.startPoint[1]+r[1]],endPoint:[e.endPoint[0]+r[0],e.endPoint[1]+r[1]],palmLandmarks:e.palmLandmarks}}"function"==typeof SuppressedError&&SuppressedError;var rqe=function(){function e(e,t,n,r,a,s){this.model=e,this.width=t,this.height=n,this.iouThreshold=a,this.scoreThreshold=s,this.anchors=r.map((function(e){return[e.x_center,e.y_center]})),this.anchorsTensor=(0,hve.tensor2d)(this.anchors),this.inputSizeTensor=(0,hve.tensor1d)([t,n]),this.doubleInputSizeTensor=(0,hve.tensor1d)([2*t,2*n])}return e.prototype.normalizeBoxes=function(e){var t=this;return(0,hve.tidy)((function(){var n=(0,hve.slice)(e,[0,0],[-1,2]),r=(0,hve.slice)(e,[0,2],[-1,2]),a=(0,hve.add)((0,hve.div)(n,t.inputSizeTensor),t.anchorsTensor),s=(0,hve.div)(r,t.doubleInputSizeTensor),i=(0,hve.mul)((0,hve.sub)(a,s),t.inputSizeTensor),o=(0,hve.mul)((0,hve.add)(a,s),t.inputSizeTensor);return(0,hve.concat2d)([i,o],1)}))},e.prototype.normalizeLandmarks=function(e,t){var n=this;return(0,hve.tidy)((function(){var r=(0,hve.add)((0,hve.div)((0,hve.reshape)(e,[-1,7,2]),n.inputSizeTensor),n.anchors[t]);return(0,hve.mul)(r,n.inputSizeTensor)}))},e.prototype.getBoundingBoxes=function(e){return YHe(this,void 0,void 0,(function(){var t,n,r,a,s,i,o,l,u,c,d,h,p,f,m,g=this;return XHe(this,(function(y){switch(y.label){case 0:return t=(0,hve.tidy)((function(){return(0,hve.mul)((0,hve.sub)(e,.5),2)})),"webgl"===(0,hve.getBackend)()?(r=(0,hve.env)().get("WEBGL_PACK_DEPTHWISECONV"),(0,hve.env)().set("WEBGL_PACK_DEPTHWISECONV",!0),n=this.model.predict(t),(0,hve.env)().set("WEBGL_PACK_DEPTHWISECONV",r)):n=this.model.predict(t),a=(0,hve.squeeze)(n),s=(0,hve.tidy)((function(){return(0,hve.squeeze)((0,hve.sigmoid)((0,hve.slice)(a,[0,0],[-1,1])))})),i=(0,hve.slice)(a,[0,1],[-1,4]),o=this.normalizeBoxes(i),l=console.warn,console.warn=function(){},u=hve.image.nonMaxSuppression(o,s,1,this.iouThreshold,this.scoreThreshold),console.warn=l,[4,u.array()];case 1:return c=y.sent(),d=[t,n,u,a,o,i,s],0===c.length?(d.forEach((function(e){return e.dispose()})),[2,null]):(h=c[0],p=(0,hve.slice)(o,[h,0],[1,-1]),f=(0,hve.slice)(a,[h,5],[1,14]),m=(0,hve.tidy)((function(){return(0,hve.reshape)(g.normalizeLandmarks(f,h),[-1,2])})),d.push(f),d.forEach((function(e){return e.dispose()})),[2,{boxes:p,palmLandmarks:m}])}}))}))},e.prototype.estimateHandBounds=function(e){return YHe(this,void 0,void 0,(function(){var t,n,r,a,s,i,o,l,u=this;return XHe(this,(function(c){switch(c.label){case 0:return t=e.shape[1],n=e.shape[2],r=(0,hve.tidy)((function(){return(0,hve.div)(hve.image.resizeBilinear(e,[u.width,u.height]),255)})),[4,this.getBoundingBoxes(r)];case 1:return null===(a=c.sent())?(r.dispose(),[2,null]):(s=a.boxes.arraySync(),i=s[0].slice(0,2),o=s[0].slice(2,4),l=a.palmLandmarks.arraySync(),r.dispose(),a.boxes.dispose(),a.palmLandmarks.dispose(),[2,(d={startPoint:i,endPoint:o,palmLandmarks:l},h=[n/this.width,t/this.height],{startPoint:[d.startPoint[0]*h[0],d.startPoint[1]*h[1]],endPoint:[d.endPoint[0]*h[0],d.endPoint[1]*h[1]],palmLandmarks:d.palmLandmarks.map((function(e){return[e[0]*h[0],e[1]*h[1]]}))})])}var d,h}))}))},e}(),aqe={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]};var sqe=function(e,t){return[[1,0,e],[0,1,t],[0,0,1]]};function iqe(e,t){for(var n=0,r=0;r<e.length;r++)n+=e[r]*t[r];return n}function oqe(e,t){for(var n=[],r=0;r<e.length;r++)n.push(e[r][t]);return n}function lqe(e,t){for(var n=[],r=e.length,a=0;a<r;a++){n.push([]);for(var s=0;s<r;s++)n[a].push(iqe(e[a],oqe(t,s)))}return n}function uqe(e,t){var n=Math.cos(e),r=Math.sin(e),a=[[n,-r,0],[r,n,0],[0,0,1]],s=lqe(sqe(t[0],t[1]),a);return lqe(s,sqe(-t[0],-t[1]))}function cqe(e,t){return[iqe(e,t[0]),iqe(e,t[1])]}var dqe=[0,-.4],hqe=[0,-.1],pqe=[0,5,9,13,17,1,2],fqe=function(){function e(e,t,n,r,a,s){this.boundingBoxDetector=e,this.meshDetector=t,this.meshWidth=n,this.meshHeight=r,this.maxContinuousChecks=a,this.detectionConfidence=s,this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.maxHandsNumber=1}return e.prototype.getBoxForPalmLandmarks=function(e,t){var n=e.map((function(e){return cqe(QHe(QHe([],e,!0),[1],!1),t)}));return eqe(tqe(nqe(this.calculateLandmarksBoundingBox(n),dqe)),3)},e.prototype.getBoxForHandLandmarks=function(e){for(var t=eqe(tqe(nqe(this.calculateLandmarksBoundingBox(e),hqe)),1.65),n=[],r=0;r<pqe.length;r++)n.push(e[pqe[r]].slice(0,2));return t.palmLandmarks=n,t},e.prototype.transformRawCoords=function(e,t,n,r){var a,s,i,o,l=this,u=ZHe(t),c=[u[0]/this.meshWidth,u[1]/this.meshHeight],d=e.map((function(e){return[c[0]*(e[0]-l.meshWidth/2),c[1]*(e[1]-l.meshHeight/2),e[2]]})),h=uqe(n,[0,0]),p=d.map((function(e){return QHe(QHe([],cqe(e,h),!0),[e[2]],!1)})),f=(s=[[(a=r)[0][0],a[1][0]],[a[0][1],a[1][1]]],i=[a[0][2],a[1][2]],o=[-iqe(s[0],i),-iqe(s[1],i)],[s[0].concat(o[0]),s[1].concat(o[1]),[0,0,1]]),m=QHe(QHe([],JHe(t),!0),[1],!1),g=[iqe(m,f[0]),iqe(m,f[1])];return p.map((function(e){return[e[0]+g[0],e[1]+g[1],e[2]]}))},e.prototype.estimateHand=function(e){return YHe(this,void 0,void 0,(function(){var t,n,r,a,s,i,o,l,u,c,d,h,p,f,m,g,y,b,v,x;return XHe(this,(function(w){switch(w.label){case 0:return!0!==(t=this.shouldUpdateRegionsOfInterest())?[3,2]:[4,this.boundingBoxDetector.estimateHandBounds(e)];case 1:return null===(n=w.sent())?(e.dispose(),this.regionsOfInterest=[],[2,null]):(this.updateRegionsOfInterest(n,!0),this.runsWithoutHandDetector=0,[3,3]);case 2:this.runsWithoutHandDetector++,w.label=3;case 3:return r=this.regionsOfInterest[0],a=function(e,t){var n;return(n=Math.PI/2-Math.atan2(-(t[1]-e[1]),t[0]-e[0]))-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}(r.palmLandmarks[0],r.palmLandmarks[2]),s=JHe(r),i=[s[0]/e.shape[2],s[1]/e.shape[1]],o=hve.image.rotateWithOffset(e,a,0,i),l=uqe(-a,s),u=!0===t?this.getBoxForPalmLandmarks(r.palmLandmarks,l):r,c=function(e,t,n){var r=t.shape[1],a=t.shape[2],s=[[e.startPoint[1]/r,e.startPoint[0]/a,e.endPoint[1]/r,e.endPoint[0]/a]];return hve.image.cropAndResize(t,s,[0],n)}(u,o,[this.meshWidth,this.meshHeight]),d=(0,hve.div)(c,255),c.dispose(),o.dispose(),"webgl"===(0,hve.getBackend)()?(p=(0,hve.env)().get("WEBGL_PACK_DEPTHWISECONV"),(0,hve.env)().set("WEBGL_PACK_DEPTHWISECONV",!0),h=this.meshDetector.predict(d),(0,hve.env)().set("WEBGL_PACK_DEPTHWISECONV",p)):h=this.meshDetector.predict(d),f=h[0],m=h[1],d.dispose(),g=f.dataSync()[0],f.dispose(),g<this.detectionConfidence?(m.dispose(),this.regionsOfInterest=[],[2,null]):(y=(0,hve.reshape)(m,[-1,3]),b=y.arraySync(),m.dispose(),y.dispose(),v=this.transformRawCoords(b,u,a,l),x=this.getBoxForHandLandmarks(v),this.updateRegionsOfInterest(x,!1),[2,{landmarks:v,handInViewConfidence:g,boundingBox:{topLeft:x.startPoint,bottomRight:x.endPoint}}])}}))}))},e.prototype.calculateLandmarksBoundingBox=function(e){var t=e.map((function(e){return e[0]})),n=e.map((function(e){return e[1]}));return{startPoint:[Math.min.apply(Math,t),Math.min.apply(Math,n)],endPoint:[Math.max.apply(Math,t),Math.max.apply(Math,n)]}},e.prototype.updateRegionsOfInterest=function(e,t){if(t)this.regionsOfInterest=[e];else{var n=this.regionsOfInterest[0],r=0;if(null!=n&&null!=n.startPoint){var a=e.startPoint,s=a[0],i=a[1],o=e.endPoint,l=o[0],u=o[1],c=n.startPoint,d=c[0],h=c[1],p=n.endPoint,f=p[0],m=p[1],g=Math.max(s,d),y=Math.max(i,h),b=(Math.min(l,f)-g)*(Math.min(u,m)-y);r=b/((l-s)*(u-i)+(f-d)*(m-i)-b)}this.regionsOfInterest[0]=r>.8?n:e}},e.prototype.shouldUpdateRegionsOfInterest=function(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks},e}();function mqe(){return YHe(this,void 0,void 0,(function(){return XHe(this,(function(e){return[2,(0,YEe.loadGraphModel)("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1",{fromTFHub:!0})]}))}))}function gqe(){return YHe(this,void 0,void 0,(function(){return XHe(this,(function(e){return[2,(0,YEe.loadGraphModel)("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1",{fromTFHub:!0})]}))}))}function yqe(){return YHe(this,void 0,void 0,(function(){return XHe(this,(function(e){return[2,hve.util.fetch("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then((function(e){return e.json()}))]}))}))}var bqe=function(){function e(e){this.pipeline=e}return e.getAnnotations=function(){return aqe},e.prototype.estimateHands=function(e,t){return void 0===t&&(t=!1),YHe(this,void 0,void 0,(function(){var n,r,a,s,i,o,l,u,c;return XHe(this,(function(d){switch(d.label){case 0:return n=function(e){return e instanceof hve.Tensor?[e.shape[0],e.shape[1]]:[e.height,e.width]}(e),r=n[1],a=(0,hve.tidy)((function(){return e instanceof hve.Tensor||(e=hve.browser.fromPixels(e)),(0,hve.expandDims)((0,hve.cast)(e,"float32"))})),[4,this.pipeline.estimateHand(a)];case 1:if(s=d.sent(),a.dispose(),null===s)return[2,[]];for(i=s,!0===t&&(i=function(e,t){var n=e.handInViewConfidence,r=e.landmarks,a=e.boundingBox;return{handInViewConfidence:n,landmarks:r.map((function(e){return[t-1-e[0],e[1],e[2]]})),boundingBox:{topLeft:[t-1-a.topLeft[0],a.topLeft[1]],bottomRight:[t-1-a.bottomRight[0],a.bottomRight[1]]}}}(s,r)),o={},l=0,u=Object.keys(aqe);l<u.length;l++)c=u[l],o[c]=aqe[c].map((function(e){return i.landmarks[e]}));return[2,[{handInViewConfidence:i.handInViewConfidence,boundingBox:i.boundingBox,landmarks:i.landmarks,annotations:o}]]}}))}))},e}();const vqe={thumb:[0,1,2,3,4],indexFinger:[0,5,6,7,8],middleFinger:[0,9,10,11,12],ringFinger:[0,13,14,15,16],littleFinger:[0,17,18,19,20]};var xqe=n(757);const wqe=xqe.Finger.Thumb,kqe=xqe.Finger.Index,Sqe=xqe.Finger.Middle,Iqe=xqe.Finger.Ring,Tqe=xqe.Finger.Pinky,Nqe=xqe.FingerCurl.NoCurl,Cqe=xqe.FingerCurl.FullCurl,Aqe=xqe.FingerCurl.HalfCurl,Eqe=xqe.FingerDirection.VerticalUpRight,_qe=xqe.FingerDirection.VerticalUp,$qe=xqe.FingerDirection.VerticalDown,Rqe=xqe.FingerDirection.DiagonalUpRight,Dqe=xqe.FingerDirection.DiagonalDownRight,Mqe=xqe.FingerDirection.DiagonalUpLeft,Fqe=xqe.FingerDirection.HorizontalRight,Oqe=xqe.FingerDirection.HorizontalLeft,Pqe=new xqe.GestureDescription("A");Pqe.addCurl(wqe,Nqe,1),Pqe.addDirection(kqe,Eqe,.7),Pqe.addCurl(kqe,Cqe,1),Pqe.addDirection(kqe,$qe,.7),Pqe.addCurl(Sqe,Cqe,1),Pqe.addDirection(Sqe,_qe,.7),Pqe.addCurl(Iqe,Cqe,1),Pqe.addDirection(Iqe,_qe,.7),Pqe.addCurl(Tqe,Cqe,1),Pqe.addDirection(Tqe,_qe,.7);const Lqe=new xqe.GestureDescription("B");Lqe.addCurl(wqe,Aqe,1),Lqe.addDirection(kqe,Mqe,.7),Lqe.addDirection(kqe,Rqe,.7),Lqe.addCurl(kqe,Nqe,1),Lqe.addDirection(kqe,_qe,.7),Lqe.addCurl(Sqe,Nqe,1),Lqe.addDirection(Sqe,_qe,.7),Lqe.addCurl(Iqe,Nqe,1),Lqe.addDirection(Iqe,_qe,.7),Lqe.addCurl(Tqe,Nqe,1),Lqe.addDirection(Tqe,_qe,.7);const zqe=new xqe.GestureDescription("C");zqe.addCurl(wqe,Nqe,1),zqe.addDirection(kqe,Rqe,.7),zqe.addCurl(kqe,Nqe,1),zqe.addDirection(kqe,Rqe,.7),zqe.addCurl(Sqe,Aqe,1),zqe.addDirection(Sqe,Rqe,.7),zqe.addCurl(Iqe,Aqe,1),zqe.addDirection(Iqe,Rqe,.7),zqe.addCurl(Tqe,Aqe,1),zqe.addDirection(Tqe,Rqe,.7);const Bqe=new xqe.GestureDescription("D");Bqe.addCurl(wqe,Aqe,1),Bqe.addDirection(kqe,_qe,.7),Bqe.addCurl(kqe,Nqe,1),Bqe.addDirection(kqe,_qe,.7),Bqe.addCurl(Sqe,Cqe,1),Bqe.addDirection(Sqe,_qe,.7),Bqe.addCurl(Iqe,Cqe,1),Bqe.addDirection(Iqe,_qe,.7),Bqe.addCurl(Tqe,Cqe,1),Bqe.addDirection(Tqe,_qe,.7);const Vqe=new xqe.GestureDescription("E");Vqe.addCurl(wqe,Aqe,1),Vqe.addDirection(kqe,_qe,.7),Vqe.addCurl(kqe,Cqe,1),Vqe.addDirection(kqe,_qe,.7),Vqe.addCurl(Sqe,Cqe,1),Vqe.addDirection(Sqe,_qe,.7),Vqe.addCurl(Iqe,Cqe,1),Vqe.addDirection(Iqe,_qe,.7),Vqe.addCurl(Tqe,Cqe,1),Vqe.addDirection(Tqe,_qe,.7);const Wqe=new xqe.GestureDescription("F");Wqe.addCurl(wqe,Aqe,1),Wqe.addDirection(kqe,Rqe,.7),Wqe.addCurl(kqe,Cqe,1),Wqe.addDirection(kqe,Rqe,.7),Wqe.addCurl(Sqe,Nqe,1),Wqe.addDirection(Sqe,_qe,.7),Wqe.addCurl(Iqe,Nqe,1),Wqe.addDirection(Iqe,_qe,.7),Wqe.addCurl(Tqe,Nqe,1),Wqe.addDirection(Tqe,_qe,.7);const Uqe=new xqe.GestureDescription("G");Uqe.addCurl(wqe,Nqe,1),Uqe.addDirection(kqe,Rqe,.7),Uqe.addCurl(kqe,Nqe,1),Uqe.addDirection(kqe,Fqe,.7),Uqe.addCurl(Sqe,Cqe,1),Uqe.addDirection(Sqe,Rqe,.7),Uqe.addCurl(Iqe,Cqe,1),Uqe.addDirection(Iqe,Fqe,.7),Uqe.addCurl(Tqe,Cqe,1),Uqe.addDirection(Tqe,Fqe,.7);const jqe=new xqe.GestureDescription("H");jqe.addCurl(wqe,Nqe,1),jqe.addDirection(kqe,Fqe,.7),jqe.addCurl(kqe,Nqe,1),jqe.addDirection(kqe,Fqe,.7),jqe.addCurl(Sqe,Nqe,1),jqe.addDirection(Sqe,Fqe,.7),jqe.addCurl(Iqe,Cqe,1),jqe.addDirection(Iqe,Fqe,.7),jqe.addCurl(Tqe,Cqe,1),jqe.addDirection(Tqe,Fqe,.7);const Gqe=new xqe.GestureDescription("I");Gqe.addCurl(wqe,Aqe,1),Gqe.addDirection(kqe,Mqe,.7),Gqe.addCurl(kqe,Cqe,1),Gqe.addDirection(kqe,_qe,.7),Gqe.addCurl(Sqe,Cqe,1),Gqe.addDirection(Sqe,_qe,.7),Gqe.addCurl(Iqe,Cqe,1),Gqe.addDirection(Iqe,_qe,.7),Gqe.addCurl(Tqe,Nqe,1),Gqe.addDirection(Tqe,_qe,.7);const Hqe=new xqe.GestureDescription("J");Hqe.addCurl(wqe,Nqe,1),Hqe.addDirection(kqe,Rqe,.7),Hqe.addCurl(kqe,Cqe,1),Hqe.addDirection(kqe,Rqe,.7),Hqe.addCurl(Sqe,Cqe,1),Hqe.addDirection(Sqe,Rqe,.7),Hqe.addCurl(Iqe,Cqe,1),Hqe.addDirection(Iqe,Fqe,.7),Hqe.addCurl(Tqe,Nqe,1),Hqe.addDirection(Tqe,Fqe,.7);const qqe=new xqe.GestureDescription("K");qqe.addCurl(wqe,Nqe,1),qqe.addDirection(kqe,Mqe,.7),qqe.addCurl(kqe,Nqe,1),qqe.addDirection(kqe,Rqe,.7),qqe.addCurl(Sqe,Nqe,1),qqe.addDirection(Sqe,_qe,.7),qqe.addCurl(Iqe,Cqe,1),qqe.addDirection(Iqe,_qe,.7),qqe.addCurl(Tqe,Cqe,1),qqe.addDirection(Tqe,_qe,.7);const Kqe=new xqe.GestureDescription("L");Kqe.addCurl(wqe,Nqe,1),Kqe.addDirection(kqe,Rqe,.7),Kqe.addCurl(kqe,Nqe,1),Kqe.addDirection(kqe,_qe,.7),Kqe.addCurl(Sqe,Cqe,1),Kqe.addDirection(Sqe,_qe,.7),Kqe.addCurl(Iqe,Cqe,1),Kqe.addDirection(Iqe,_qe,.7),Kqe.addCurl(Tqe,Cqe,1),Kqe.addDirection(Tqe,_qe,.7);const Yqe=new xqe.GestureDescription("M");Yqe.addCurl(wqe,Aqe,1),Yqe.addDirection(kqe,Mqe,.7),Yqe.addCurl(kqe,Cqe,1),Yqe.addDirection(kqe,Rqe,.7),Yqe.addCurl(Sqe,Cqe,1),Yqe.addDirection(Sqe,_qe,.7),Yqe.addCurl(Iqe,Cqe,1),Yqe.addDirection(Iqe,_qe,.7),Yqe.addCurl(Tqe,Cqe,1),Yqe.addDirection(Tqe,_qe,.7);const Xqe=new xqe.GestureDescription("N");Xqe.addCurl(wqe,Aqe,1),Xqe.addDirection(kqe,Mqe,.7),Xqe.addCurl(kqe,Cqe,1),Xqe.addDirection(kqe,Rqe,.7),Xqe.addCurl(Sqe,Cqe,1),Xqe.addDirection(Sqe,_qe,.7),Xqe.addCurl(Iqe,Cqe,1),Xqe.addDirection(Iqe,_qe,.7),Xqe.addCurl(Tqe,Cqe,1),Xqe.addDirection(Tqe,Mqe,.7);const Qqe=new xqe.GestureDescription("O");Qqe.addCurl(wqe,Nqe,1),Qqe.addDirection(kqe,Rqe,.7),Qqe.addCurl(kqe,Aqe,1),Qqe.addDirection(kqe,Rqe,.7),Qqe.addCurl(Sqe,Aqe,1),Qqe.addDirection(Sqe,Rqe,.7),Qqe.addCurl(Iqe,Cqe,1),Qqe.addDirection(Iqe,Rqe,.7),Qqe.addCurl(Tqe,Cqe,1),Qqe.addDirection(Tqe,Rqe,.7);const Zqe=new xqe.GestureDescription("P");Zqe.addCurl(wqe,Nqe,1),Zqe.addDirection(kqe,Fqe,.7),Zqe.addCurl(kqe,Nqe,1),Zqe.addDirection(kqe,Fqe,.7),Zqe.addCurl(Sqe,Aqe,1),Zqe.addDirection(Sqe,Dqe,.7),Zqe.addCurl(Iqe,Cqe,1),Zqe.addDirection(Iqe,Dqe,.7),Zqe.addCurl(Tqe,Cqe,1),Zqe.addDirection(Tqe,Dqe,.7);const Jqe=new xqe.GestureDescription("Q");Jqe.addCurl(wqe,Nqe,1),Jqe.addDirection(kqe,Dqe,.7),Jqe.addCurl(kqe,Aqe,1),Jqe.addDirection(kqe,Fqe,.7),Jqe.addCurl(Sqe,Cqe,1),Jqe.addDirection(Sqe,Fqe,.7),Jqe.addCurl(Iqe,Cqe,1),Jqe.addDirection(Iqe,Dqe,.7),Jqe.addCurl(Tqe,Cqe,1),Jqe.addDirection(Tqe,Dqe,.7);const eKe=new xqe.GestureDescription("R");eKe.addCurl(wqe,Aqe,1),eKe.addDirection(kqe,Mqe,.7),eKe.addCurl(kqe,Nqe,1),eKe.addDirection(kqe,_qe,.7),eKe.addCurl(Sqe,Nqe,1),eKe.addDirection(Sqe,_qe,.7),eKe.addCurl(Iqe,Cqe,1),eKe.addDirection(Iqe,_qe,.7),eKe.addCurl(Tqe,Cqe,1),eKe.addDirection(Tqe,_qe,.7);const tKe=new xqe.GestureDescription("S");tKe.addCurl(wqe,Aqe,1),tKe.addDirection(kqe,_qe,.7),tKe.addCurl(kqe,Cqe,1),tKe.addDirection(kqe,Rqe,.7),tKe.addCurl(Sqe,Cqe,1),tKe.addDirection(Sqe,_qe,.7),tKe.addCurl(Iqe,Cqe,1),tKe.addDirection(Iqe,_qe,.7),tKe.addCurl(Tqe,Cqe,1),tKe.addDirection(Tqe,Mqe,.7);const nKe=new xqe.GestureDescription("T");nKe.addCurl(wqe,Nqe,1),nKe.addDirection(kqe,_qe,.7),nKe.addCurl(kqe,Cqe,1),nKe.addDirection(kqe,Rqe,.7),nKe.addCurl(Sqe,Cqe,1),nKe.addDirection(Sqe,_qe,.7),nKe.addCurl(Iqe,Cqe,1),nKe.addDirection(Iqe,_qe,.7),nKe.addCurl(Tqe,Cqe,1),nKe.addDirection(Tqe,Mqe,.7);const rKe=new xqe.GestureDescription("U");rKe.addCurl(wqe,Aqe,1),rKe.addDirection(kqe,Mqe,.7),rKe.addCurl(kqe,Nqe,1),rKe.addDirection(kqe,_qe,.7),rKe.addCurl(Sqe,Nqe,1),rKe.addDirection(Sqe,_qe,.7),rKe.addCurl(Iqe,Cqe,1),rKe.addDirection(Iqe,_qe,.7),rKe.addCurl(Tqe,Cqe,1),rKe.addDirection(Tqe,Mqe,.7);const aKe=new xqe.GestureDescription("V");aKe.addCurl(wqe,Aqe,1),aKe.addDirection(kqe,Mqe,.7),aKe.addCurl(kqe,Nqe,1),aKe.addDirection(kqe,Rqe,.7),aKe.addCurl(Sqe,Nqe,1),aKe.addDirection(Sqe,_qe,.7),aKe.addCurl(Iqe,Cqe,1),aKe.addDirection(Iqe,_qe,.7),aKe.addCurl(Tqe,Cqe,1),aKe.addDirection(Tqe,Mqe,.7);const sKe=new xqe.GestureDescription("W");sKe.addCurl(wqe,Aqe,1),sKe.addDirection(kqe,Mqe,.7),sKe.addCurl(kqe,Nqe,1),sKe.addDirection(kqe,Rqe,.7),sKe.addCurl(Sqe,Nqe,1),sKe.addDirection(Sqe,_qe,.7),sKe.addCurl(Iqe,Nqe,1),sKe.addDirection(Iqe,Mqe,.7),sKe.addCurl(Tqe,Cqe,1),sKe.addDirection(Tqe,Mqe,.7);const iKe=new xqe.GestureDescription("X");iKe.addCurl(wqe,Aqe,1),iKe.addDirection(kqe,_qe,.7),iKe.addCurl(kqe,Aqe,1),iKe.addDirection(kqe,_qe,.7),iKe.addCurl(Sqe,Cqe,1),iKe.addDirection(Sqe,_qe,.7),iKe.addCurl(Iqe,Cqe,1),iKe.addDirection(Iqe,_qe,.7),iKe.addCurl(Tqe,Cqe,1),iKe.addDirection(Tqe,_qe,.7);const oKe=new xqe.GestureDescription("Y");oKe.addCurl(wqe,Nqe,1),oKe.addDirection(kqe,Rqe,.7),oKe.addCurl(kqe,Cqe,1),oKe.addDirection(kqe,_qe,.7),oKe.addCurl(Sqe,Cqe,1),oKe.addDirection(Sqe,_qe,.7),oKe.addCurl(Iqe,Nqe,1),oKe.addDirection(Iqe,_qe,.7),oKe.addCurl(Tqe,Nqe,1),oKe.addDirection(Tqe,Mqe,.7);const lKe=new xqe.GestureDescription("Z");lKe.addCurl(wqe,Nqe,.8),lKe.addDirection(kqe,Oqe,.7),lKe.addCurl(kqe,Nqe,1),lKe.addDirection(kqe,Mqe,.7),lKe.addCurl(Sqe,Cqe,1),lKe.addDirection(Sqe,Oqe,.7),lKe.addCurl(Iqe,Cqe,1),lKe.addDirection(Iqe,Oqe,.7),lKe.addCurl(Tqe,Cqe,1),lKe.addDirection(Tqe,Oqe,.7);const uKe={a_ASL:Pqe,b_ASL:Lqe,c_ASL:zqe,d_ASL:Bqe,e_ASL:Vqe,f_ASL:Wqe,g_ASL:Uqe,h_ASL:jqe,i_ASL:Gqe,j_ASL:Hqe,k_ASL:qqe,l_ASL:Kqe,m_ASL:Yqe,n_ASL:Xqe,o_ASL:Qqe,p_ASL:Zqe,q_ASL:Jqe,r_ASL:eKe,s_ASL:tKe,t_ASL:nKe,u_ASL:rKe,v_ASL:aKe,w_ASL:sKe,x_ASL:iKe,y_ASL:oKe,z_ASL:lKe};var cKe=n(1136);const dKe=t.createContext();function hKe(e){return(0,Kn.Ay)("MuiGrid",e)}const pKe=["auto",!0,1,2,3,4,5,6,7,8,9,10,11,12],fKe=(0,Fn.A)("MuiGrid",["root","container","item","zeroMinWidth",...[0,1,2,3,4,5,6,7,8,9,10].map((e=>`spacing-xs-${e}`)),...["column-reverse","column","row-reverse","row"].map((e=>`direction-xs-${e}`)),...["nowrap","wrap-reverse","wrap"].map((e=>`wrap-xs-${e}`)),...pKe.map((e=>`grid-xs-${e}`)),...pKe.map((e=>`grid-sm-${e}`)),...pKe.map((e=>`grid-md-${e}`)),...pKe.map((e=>`grid-lg-${e}`)),...pKe.map((e=>`grid-xl-${e}`))]);function mKe(e){let{breakpoints:t,values:n}=e,r="";Object.keys(n).forEach((e=>{""===r&&0!==n[e]&&(r=e)}));const a=Object.keys(t).sort(((e,n)=>t[e]-t[n]));return a.slice(0,a.indexOf(r))}const gKe=(0,Wn.Ay)("div",{name:"MuiGrid",slot:"Root",overridesResolver:(e,t)=>{const{ownerState:n}=e,{container:r,direction:a,item:s,spacing:i,wrap:o,zeroMinWidth:l,breakpoints:u}=n;let c=[];r&&(c=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!e||e<=0)return[];if("string"===typeof e&&!Number.isNaN(Number(e))||"number"===typeof e)return[n[`spacing-xs-${String(e)}`]];const r=[];return t.forEach((t=>{const a=e[t];Number(a)>0&&r.push(n[`spacing-${t}-${String(a)}`])})),r}(i,u,t));const d=[];return u.forEach((e=>{const r=n[e];r&&d.push(t[`grid-${e}-${String(r)}`])})),[t.root,r&&t.container,s&&t.item,l&&t.zeroMinWidth,...c,"row"!==a&&t[`direction-xs-${String(a)}`],"wrap"!==o&&t[`wrap-xs-${String(o)}`],...d]}})((e=>{let{ownerState:t}=e;return{boxSizing:"border-box",...t.container&&{display:"flex",flexWrap:"wrap",width:"100%"},...t.item&&{margin:0},...t.zeroMinWidth&&{minWidth:0},..."wrap"!==t.wrap&&{flexWrap:t.wrap}}}),(function(e){let{theme:t,ownerState:n}=e;const r=(0,cKe.kW)({values:n.direction,breakpoints:t.breakpoints.values});return(0,cKe.NI)({theme:t},r,(e=>{const t={flexDirection:e};return e.startsWith("column")&&(t[`& > .${fKe.item}`]={maxWidth:"none"}),t}))}),(function(e){let{theme:t,ownerState:n}=e;const{container:r,rowSpacing:a}=n;let s={};if(r&&0!==a){const e=(0,cKe.kW)({values:a,breakpoints:t.breakpoints.values});let n;"object"===typeof e&&(n=mKe({breakpoints:t.breakpoints.values,values:e})),s=(0,cKe.NI)({theme:t},e,((e,r)=>{const a=t.spacing(e);return"0px"!==a?{marginTop:t.spacing(-e),[`& > .${fKe.item}`]:{paddingTop:a}}:n?.includes(r)?{}:{marginTop:0,[`& > .${fKe.item}`]:{paddingTop:0}}}))}return s}),(function(e){let{theme:t,ownerState:n}=e;const{container:r,columnSpacing:a}=n;let s={};if(r&&0!==a){const e=(0,cKe.kW)({values:a,breakpoints:t.breakpoints.values});let n;"object"===typeof e&&(n=mKe({breakpoints:t.breakpoints.values,values:e})),s=(0,cKe.NI)({theme:t},e,((e,r)=>{const a=t.spacing(e);if("0px"!==a){return{width:`calc(100% + ${a})`,marginLeft:t.spacing(-e),[`& > .${fKe.item}`]:{paddingLeft:a}}}return n?.includes(r)?{}:{width:"100%",marginLeft:0,[`& > .${fKe.item}`]:{paddingLeft:0}}}))}return s}),(function(e){let t,{theme:n,ownerState:r}=e;return n.breakpoints.keys.reduce(((e,a)=>{let s={};if(r[a]&&(t=r[a]),!t)return e;if(!0===t)s={flexBasis:0,flexGrow:1,maxWidth:"100%"};else if("auto"===t)s={flexBasis:"auto",flexGrow:0,flexShrink:0,maxWidth:"none",width:"auto"};else{const i=(0,cKe.kW)({values:r.columns,breakpoints:n.breakpoints.values}),o="object"===typeof i?i[a]:i;if(void 0===o||null===o)return e;const l=Math.round(t/o*1e8)/1e6+"%";let u={};if(r.container&&r.item&&0!==r.columnSpacing){const e=n.spacing(r.columnSpacing);if("0px"!==e){const t=`calc(${l} + ${e})`;u={flexBasis:t,maxWidth:t}}}s={flexBasis:l,flexGrow:0,maxWidth:l,...u}}return 0===n.breakpoints.values[a]?Object.assign(e,s):e[n.breakpoints.up(a)]=s,e}),{})}));const yKe=e=>{const{classes:t,container:n,direction:r,item:a,spacing:s,wrap:i,zeroMinWidth:o,breakpoints:l}=e;let u=[];n&&(u=function(e,t){if(!e||e<=0)return[];if("string"===typeof e&&!Number.isNaN(Number(e))||"number"===typeof e)return[`spacing-xs-${String(e)}`];const n=[];return t.forEach((t=>{const r=e[t];if(Number(r)>0){const e=`spacing-${t}-${String(r)}`;n.push(e)}})),n}(s,l));const c=[];l.forEach((t=>{const n=e[t];n&&c.push(`grid-${t}-${String(n)}`)}));const d={root:["root",n&&"container",a&&"item",o&&"zeroMinWidth",...u,"row"!==r&&`direction-xs-${String(r)}`,"wrap"!==i&&`wrap-xs-${String(i)}`,...c]};return(0,Bn.A)(d,hKe,t)},bKe=t.forwardRef((function(e,n){const r=Hi({props:e,name:"MuiGrid"}),{breakpoints:a}=jn(),s=Tn(r),{className:i,columns:o,columnSpacing:l,component:u="div",container:c=!1,direction:d="row",item:h=!1,rowSpacing:p,spacing:f=0,wrap:m="wrap",zeroMinWidth:g=!1,...y}=s,b=p||f,v=l||f,x=t.useContext(dKe),w=c?o||12:x,k={},S={...y};a.keys.forEach((e=>{null!=y[e]&&(k[e]=y[e],delete S[e])}));const I={...s,columns:w,container:c,direction:d,item:h,rowSpacing:b,columnSpacing:v,wrap:m,zeroMinWidth:g,spacing:f,...k,breakpoints:a.keys},T=yKe(I);return(0,$n.jsx)(dKe.Provider,{value:w,children:(0,$n.jsx)(gKe,{ownerState:I,className:(0,vn.A)(T.root,i),as:u,ref:n,...S})})}));const vKe=bKe;var xKe=n(3915);let wKe;hve.setBackend("webgl");const kKe=e=>{let{userData:n,userId:r}=e;const a=E(),s=(0,t.useRef)(null),i=(0,t.useRef)(null),[o,l]=(0,t.useState)(!1),[u,c]=(0,t.useState)(""),[d,h]=(0,t.useState)("block"),[p,f]=(0,t.useState)(!1),[m,g]=(0,t.useState)(60),y=(0,t.useRef)(null),b=Qt(),v="B",x=`<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; color: #333333;">\n  <h1 style="color: #0066cc; text-align: center;">Authentication Instructions</h1>\n  <p style="font-size: 16px; line-height: 1.5;">Dear User,</p>\n  <p style="font-size: 16px; line-height: 1.5;">To authenticate yourself, please follow these steps:</p>\n  <ol style="font-size: 16px; line-height: 1.5;">\n    <li>Position yourself in front of your camera.</li>\n    <li>Ensure your background is clear and no other person is in the frame.</li>\n    <li>Make the hand sign for the letter ${v} in American Sign Language, as shown in the image below.</li>\n    <li>Make sure both your face and hand sign are clearly visible in the camera frame.</li>\n  </ol>\n  <h2 style="color: #0066cc; text-align: center;">Hand Sign for Letter ${v}</h2>\n  <img src=${`https://firebasestorage.googleapis.com/v0/b/auth-tfjs.appspot.com/o/HandSign%20Image%2F${v}.jpg?alt=media&token=d891e715-d5ab-49ee-8c4c-d14c25d7fb7a`} alt="Hand sign for letter ${v} in American Sign Language" style="display: block; max-width: 100%; height: auto; margin: 20px auto; border: 2px solid #0066cc;">\n  <p style="font-size: 16px; line-height: 1.5; font-weight: bold;">Important Notes:</p>\n  <ul style="font-size: 16px; line-height: 1.5;">\n    <li>Ensure good lighting for clear visibility.</li>\n    <li>Hold the hand sign steady for a few seconds.</li>\n  </ul>\n  <p style="font-size: 16px; line-height: 1.5;">Thank you for your cooperation in maintaining the security of your account.</p>\n  <p style="font-size: 16px; line-height: 1.5;">Best regards,<br>Your Authentication Team</p>\n  </div>`,w=()=>{g(60),y.current=setInterval((()=>{g((e=>e<=1?(clearInterval(y.current),a(Ze()),a(Qe("Time out. Please try again.")),b("/authenticated?username=invalid"),0):e-1))}),1e3)},k=(e,t)=>{"clickaway"!==t&&l(!1)},S=async()=>{await(async(e,t,n,r)=>{try{await jb(lb(Kb,"mail"),{to:[e],message:{subject:`Instructions: You have to draw ${n} in American Sign Language`,html:t}}),console.log("Image uploaded and email sent successfully"),r()}catch(a){console.error("Error uploading image or sending email: ",a)}})(n.email,x,v,w);const e=await function(e){var t=void 0===e?{}:e,n=t.maxContinuousChecks,r=void 0===n?1/0:n,a=t.detectionConfidence,s=void 0===a?.8:a,i=t.iouThreshold,o=void 0===i?.3:i,l=t.scoreThreshold,u=void 0===l?.5:l;return YHe(this,void 0,void 0,(function(){var e,t,n,a,i,l;return XHe(this,(function(c){switch(c.label){case 0:return[4,Promise.all([yqe(),mqe(),gqe()])];case 1:return e=c.sent(),t=e[0],n=e[1],a=e[2],i=new rqe(n,256,256,t,o,u),l=new fqe(i,a,256,256,r,s),[2,new bqe(l)]}}))}))}();y.current=setInterval((()=>{T(e,v)}),170)},I=(e,t,n,r)=>{e.save(),e.beginPath(),e.ellipse(t/2,n/2-20,t/6,n/3.5,0,0,2*Math.PI),e.lineWidth=10,e.strokeStyle=r,e.stroke(),e.restore()},T=async(e,t)=>{const{current:o}=s,{video:u}=o||{};if(4!==u.readyState||!o||!o.video||!i.current||p)return console.error("Webcam or canvas not available for face detection."),c("Webcam or canvas not available for face detection."),void l(!0);try{const s=u.videoWidth,p=u.videoHeight;o.video.width=s,o.video.height=p,i.current.width=s,i.current.height=p;const m=await e.estimateHands(u),g=i.current.getContext("2d");((e,t)=>{e.length>0&&e.forEach((e=>{const n=e.landmarks;Object.keys(vqe).forEach((e=>{const r=vqe[e];r.slice(0,-1).forEach(((e,a)=>{const s=r[a],i=r[a+1];t.beginPath(),t.moveTo(n[s][0],n[s][1]),t.lineTo(n[i][0],n[i][1]),t.strokeStyle="#FF4500",t.lineWidth=3,t.stroke()}))})),n.forEach((e=>{let[n,r]=e;t.beginPath(),t.arc(n,r,5,0,3*Math.PI),t.fillStyle="#32CD32",t.fill()}))}))})(m,g),g.clearRect(0,0,i.width,i.height),g.save(),g.beginPath(),g.ellipse(i.current.width/2,i.current.height/2-20,i.current.width/6,i.current.height/3.5,0,0,2*Math.PI),g.clip(),g.drawImage(u,0,0,s,p),g.restore();const v=i.current.toDataURL("image/png"),x=await Dge(v),w=await Abe(x).withFaceLandmarks();if(w.length>0?I(g,i.current.width,i.current.height,"green"):I(g,i.current.width,i.current.height,"purple"),m.length>0){var d;const e="ABCDEFGHIJKLMNOPQRSTUVWXYZ".toLowerCase().split("").map((e=>uKe[`${e}_ASL`])),s=new xqe.GestureEstimator([...e]),i=await s.estimate(m[0].landmarks,6.5);if((null===(d=i.gestures.reduce(((e,t)=>t.score>e.score?t:e),i.gestures[0]))||void 0===d?void 0:d.name)===t){if(w.length<1)return c("Kindly fit your face inside the circle and make sure there is no person in background."),void l(!0);clearInterval(y.current),y.current=null,f(!0),h("none");const e=await(async e=>!(!wKe||!e)&&(await wKe.detect(e)).some((e=>"cell phone"===e.class)))(u);console.log("Mobile Detected:",e);const t=await(async(e,t)=>{try{return new Promise((async n=>{const r=[...Array(5)].map(((e,n)=>new rge(t.name,[new Float32Array(t.descriptors[n])])));let a=!1;const s=new Ebe(r,.5),i=await Abe(e).withFaceLandmarks().withFaceDescriptors();i.length>1?n(!1):(i.forEach((e=>{const{descriptor:n}=e,r=s.findBestMatch(n);a=r.distance<.5&&t.name})),n(a))}))}catch(n){console.log("Error caught in faceRecognition",n)}})(x,n);return t&&!e?(a(Ye({name:n.name,email:n.email,dateOfBirth:n.DOB,userId:r})),b(`/authenticated?username=${t}`)):(a(Qe(e?"There was a spoofing attempt using a mobile phone.":"Face not recognized.")),b(`/authenticated?username=${t}`))}}}catch(m){console.log("Error during the recognition:",m)}};return(0,t.useEffect)((()=>((async()=>{try{S()}catch(e){console.error("Error during model loading or inference:",e)}})(),(async()=>{wKe=await xKe.load()})(),()=>clearInterval(y.current))),[]),(0,$n.jsx)(zn,{padding:1,sx:{display:"flex",alignItems:"center",justifyContent:"center",height:"100dvh"},children:(0,$n.jsxs)(vKe,{container:!0,spacing:2,alignItems:"center",justifyContent:"center",children:[(0,$n.jsxs)(vKe,{item:!0,xs:12,md:9,lg:8,children:[(0,$n.jsx)(zn,{display:"flex",justifyContent:"center",position:"relative",sx:{width:"100%"},children:(0,$n.jsxs)(zn,{sx:{position:"relative",width:"100%",maxWidth:"600px"},children:[(0,$n.jsx)(UN(),{ref:s,style:{width:"100%",height:"100%",borderRadius:"10px",objectFit:"cover"}}),(0,$n.jsx)("canvas",{ref:i,style:{display:d,position:"absolute",top:0,left:0,width:"100%",height:"100%",borderRadius:"10px"}})]})}),(0,$n.jsxs)(mr,{variant:"h5",align:"center",sx:{marginTop:2},children:["Time Remaining: ",m," seconds"]})]}),(0,$n.jsx)(vKe,{item:!0,xs:12,md:3,lg:2,children:(0,$n.jsxs)(zn,{display:"flex",flexDirection:"column",justifyContent:"flex-start",children:[(0,$n.jsxs)(Zn,{elevation:3,sx:{padding:"20px",marginBottom:"20px"},children:[(0,$n.jsx)(mr,{variant:"h6",align:"center",children:"Kindly Check your email for Instructions on performing Hand Signs"}),(0,$n.jsx)(mr,{variant:"body1",align:"center",sx:{marginTop:"10px"},children:"Ensure your background is clear and no other person is present in the frame."})]}),(0,$n.jsxs)(Zn,{elevation:3,sx:{padding:"20px",marginBottom:"20px",backgroundColor:"#f9f9f9",borderRadius:"8px"},children:[(0,$n.jsx)(mr,{variant:"h6",align:"center",sx:{fontWeight:"bold",color:"#333"},children:"Kindly Fit Your Face Inside the circle"}),(0,$n.jsx)(mr,{variant:"body1",align:"center",sx:{marginTop:"10px",color:"#555"},children:"Adjust your face until the circle turns green."})]}),(0,$n.jsx)(sve,{open:o,autoHideDuration:6e3,onClose:k,anchorOrigin:{vertical:"top",horizontal:"center"},children:(0,$n.jsx)(tl,{onClose:k,severity:"error",sx:{width:"100%"},children:u})})]})})]})})},SKe=()=>{const[e,n]=(0,t.useState)(""),[r,a]=(0,t.useState)(null),[s,i]=(0,t.useState)(""),[o,l]=(0,t.useState)(!1),[u,c]=(0,t.useState)(!1),[d,h]=(0,t.useState)(!1),p=()=>{c(!1)};return d?(0,$n.jsx)(kKe,{userData:r,userId:e}):(0,$n.jsxs)(vl,{maxWidth:"sm",sx:{mt:10},children:[(0,$n.jsxs)(zn,{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",sx:{padding:4,boxShadow:"0px 0px 20px rgba(0, 0, 0, 0.1)",borderRadius:3,backgroundColor:"#ffffff",transition:"box-shadow 0.3s ease","&:hover":{boxShadow:"0px 0px 30px rgba(0, 0, 0, 0.15)"}},children:[(0,$n.jsx)(mr,{variant:"h4",gutterBottom:!0,sx:{color:"#1976d2",fontWeight:"bold"},children:"Enter Your User ID"}),(0,$n.jsx)(ro,{label:"User ID",variant:"outlined",fullWidth:!0,error:!!s,helperText:s,value:e,onChange:e=>n(e.target.value),sx:{marginBottom:3}}),(0,$n.jsx)(Po,{variant:"contained",color:"primary",onClick:async()=>{if(!e)return void i("User ID is required.");if(/^[a-zA-Z0-9]+$/.test(e)){i(""),l(!0);try{const n=await Yb(e);if(console.log("userDocSnap",n.data()),void 0!==n.data()){var t;const e=null!==(t=n.data())&&void 0!==t?t:{},r=((e,t)=>ove().AES.decrypt(e,t.name+t.DOB).toString(ove().enc.Utf8))(e.email,e),s=(e=>Object.keys(e).filter((e=>e.startsWith("descriptors_"))).map((t=>JSON.parse(ove().AES.decrypt(e[t],e.name+e.DOB).toString(ove().enc.Utf8)))))(e);a({...e,email:r,descriptors:s}),setTimeout((()=>{h(!0)}),1500)}else i("No such User ID exists.")}catch(s){i("Something went wrong! Please try again.")}finally{c(!0),l(!1)}}else i("User ID must be alphanumeric.")},sx:{backgroundColor:"#1976d2","&:hover":{backgroundColor:"#1565c0"},width:"100%",padding:"10px 0",fontSize:"16px",display:"flex",alignItems:"center",justifyContent:"center"},disabled:o,children:o?(0,$n.jsx)(Vbe,{size:24}):"Submit"})]}),(0,$n.jsx)(sve,{open:u,autoHideDuration:3e3,onClose:p,anchorOrigin:{vertical:"top",horizontal:"right"},children:(0,$n.jsx)(tl,{onClose:p,severity:s.length?"error":"success",sx:{width:"100%"},children:s.length?s:"You are successfully Logged In!"})})]})};function IKe(){return(0,t.useEffect)((()=>{(async()=>{await(async()=>{try{await Promise.all([lbe.ssdMobilenetv1.loadFromUri("/auth-tfjs/models"),lbe.tinyFaceDetector.loadFromUri("/auth-tfjs/models"),lbe.faceLandmark68Net.loadFromUri("/auth-tfjs/models"),lbe.faceRecognitionNet.loadFromUri("/auth-tfjs/models")]),console.log("Face Models are loaded!!!")}catch(e){console.error("Error loading models:",e)}})()})()}),[]),(0,$n.jsx)(gn,{basename:"/auth-tfjs",children:(0,$n.jsxs)(pn,{children:[(0,$n.jsx)(dn,{path:"/",element:(0,$n.jsx)(cve,{})}),(0,$n.jsx)(dn,{path:"/login",element:(0,$n.jsx)(SKe,{})}),(0,$n.jsx)(dn,{path:"/loggedUser",element:(0,$n.jsx)(dl,{})}),(0,$n.jsx)(dn,{path:"/authenticated",element:(0,$n.jsx)(Qb,{})}),(0,$n.jsx)(dn,{path:"/error",element:(0,$n.jsx)(dve,{})})]})})}a.render((0,$n.jsx)(T,{store:nt,children:(0,$n.jsx)(IKe,{})}),document.getElementById("root"))})()})();
//# sourceMappingURL=main.4ecd0882.js.map